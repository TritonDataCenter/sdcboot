diff -Nu d:7.501/4all.h SOURCES/4all.h
--- d:7.501/4all.h	2006-11-12 16:00:50 +0200
+++ SOURCES/4all.h	2008-10-19 16:57:56 +0200
@@ -36,6 +36,15 @@
 typedef unsigned char * LPTSTR;
 typedef unsigned char _far * LPBYTE;
 
+#ifdef NATIVE_INT64
+typedef __int64 t_int64;
+#else
+typedef struct {
+	unsigned long ulLowPart;
+	unsigned long ulHighPart;
+} t_int64;
+#endif
+
 #define wcmemset memset
 
 #define STDIN 0			// standard input, output, error, aux, & prn
@@ -325,6 +334,8 @@
 	int uTSeconds;
 	int uTHundreds;
 	long lDay;
+	t_int64 llClock;// DOS mode clock timestamp (40 bits used)
+	unsigned long ulMs;// Windows mode milliseconds
 } TIMERS;
 
 
@@ -458,11 +469,12 @@
 #define LIST_BY_ATTRIBUTES 1	// /a:-rhsda
 #define LIST_HIBIT 2			// strip high bit
 #define LIST_NOWILDCARDS 4
-#define LIST_REVERSE 8
-#define LIST_STDIN 0x10			// get input from STDIN
-#define LIST_WRAP 0x20			// wrap lines at right margin
-#define LIST_HEX 0x40			// display in hex
-#define LIST_SEARCH 0x80
+#define LIST_LINENUMBERS 8
+#define LIST_REVERSE 0x10
+#define LIST_STDIN 0x20			// get input from STDIN
+#define LIST_WRAP 0x40			// wrap lines at right margin
+#define LIST_HEX 0x80			// display in hex
+#define LIST_SEARCH 0x100
 
 // Include INI file data structures
 #include "inistruc.h"
@@ -505,7 +517,7 @@
 #define EDIT_DIGITS 0x1000
 #define EDIT_SWAP_SCROLL 0x2000
 #define EDIT_MOUSE_BUTTON 0x4000
-#define EDIT_NO_PIPES 0x8000
+#define EDIT_NO_PIPES (int)0x8000	// 0x8000 overflows 16-bit int!
 #define EDIT_UNICODE_FILE 0x10000L
 
 
@@ -583,19 +595,22 @@
 #define ERROR_4DOS_NOT_SWAPPING_MODE	53+OFFSET_4DOS_MSG
 #define ERROR_4DOS_NO_UMBS		54+OFFSET_4DOS_MSG
 #define ERROR_4DOS_REGION_SYNTAX	55+OFFSET_4DOS_MSG
+#define ERROR_4DOS_CANT_EJECT		56+OFFSET_4DOS_MSG
+#define ERROR_4DOS_CANT_CLOSE		57+OFFSET_4DOS_MSG
+#define ERROR_4DOS_IDLE_DISABLED	58+OFFSET_4DOS_MSG
 
 
 // error return codes
 #define USAGE_ERR 1
 #define ERROR_EXIT 2
 // #define CTRLC 3
-#define ERROR_NOT_IN_LIST 0xFFFE
-#define ERROR_LIST_EMPTY 0xFFFF
+#define ERROR_NOT_IN_LIST (-2)
+#define ERROR_LIST_EMPTY (-1)
 
 
 #define EOS '\0'		// standard end of string
 #define FALSE 0
-#define TRUE 1
+#define TRUE (!0)
 
 #define SOH 1
 #define CTRLC 3
@@ -709,6 +724,8 @@
 #define LEFT_MOUSE_BUTTON 250+FBIT
 #define RIGHT_MOUSE_BUTTON 251+FBIT
 #define MIDDLE_MOUSE_BUTTON 252+FBIT
+#define WHEEL_DOWN      253+FBIT
+#define WHEEL_UP        254+FBIT
 
 #include "version.h"
 
diff -Nu d:7.501/4dlinit.asm SOURCES/4dlinit.asm
--- d:7.501/4dlinit.asm	2006-11-12 16:00:50 +0200
+++ SOURCES/4dlinit.asm	2008-04-25 16:07:16 +0200
@@ -162,6 +162,10 @@
 SERV_TEXT ends
           ;
 _TEXT     segment   para public 'CODE'  ;transient portion text segment
+ifdef __WATCOM__
+          ; Use Watcom equivalents of original MS RTL symbols
+_STKHQQ   EQU       __STACKLOW
+endif
           extrn     __astart:far
 _TEXT     ends
           ;
@@ -552,7 +556,13 @@
           calldos   SETDRV              ;set drive (no-op, returns max drive)
           mov       MaxDrive,al         ;save max drive
           calldos   VERSION             ;get DOS version
-          mov       DosMajor,al         ;save major version
+          cmp       al,2		;DOS version 2 or later?
+          jae       SaveVer		;yes, continue
+          xor       ax,ax		;no, it's DOS 1.x - abort!
+          push      cs			;CS = PSP now
+          push      ax			;push warm start vector PSP:0
+          retf				;DOS 1.0 exit program (Int 20h at PSP:0)
+SaveVer:  mov       DosMajor,al         ;save major version
           mov       DosMinor,ah         ;and minor
           ;
           mov       dl,CurDrive         ;get current drive
@@ -656,6 +666,8 @@
 DoTail:   call      ParsTail            ;parse the command tail, process the
                                         ;  default INI file in the primary
                                         ;  shell
+          call      GetDRF58            ;get DR-DOS F5/F8 boot keys, if any,
+                                        ;  and set init flags accordingly
           call      FixupINI            ;fix up INI data
           ;
           call      SetupNN             ;set up Netware Names
@@ -1903,15 +1915,15 @@
           ;
           ; ------- /K - "command follows" -------
           ;
-SwKCmd:   cmp       bptr [si],":"       ;is it /K:?
-           jne      SwKVer              ;if not go on
-          inc       si                  ;skip ":"
-          ;
-SwKVer:   cmp       DosMajor,6          ;check if DOS 6
+SwKCmd:   cmp       DosMajor,6          ;check if DOS 6
            jne      SwKDone		;if not, tail processing is done
           bset      InitFlg2,NOAUTOEX   ;/K disables AUTOEXEC.BAT in DOS 6+
           ;
-SwKDone:  jmp       PTDisp              ;tail processing done, return rest
+SwKDone:  cmp       bptr [si],":"       ;is it /K:?
+           jne      PTDisp              ;no, tail processing done, return rest
+          mov       bptr [si]," "       ;yes, replace with a space
+          bset      InitFlag,TRANLOAD   ;transient load, set flag
+          jmp       short SwTrDone      ;treat it like "/C"
           ;
           ;
           ; ------- /L[AFHD] - local aliases / cmd history / dir history-------
@@ -2373,12 +2385,18 @@
 	;
 	; Set the MS-DOS 7+ flag
 	;
+	cmp	DosMajor,7	;DOS 2.x would crash at Int 2Fh AX=4A33h
+	jb	FIAutoEx	;and we don't care about versions < 7 anyway
 	push	ds		;save DS
 	mov	ax, 04A33h	;undoc'd call to see if it's MS-DOS7
 	int	2Fh		;  versus PC-DOS7
 	popm	ds		;restore DS
 	cmp	ax, 0		;is it MS-DOS 7?
 	 jne	FIAutoEx		;if not go on
+        mov	ax,(D_VERSION shl 8)	;if so check OEM ID
+	int	21h
+	cmp	bh,0FFh		;Microsoft?
+	 jne	FIAutoEx		;if not go on
 	mov	IFData.I_MSDOS7,1	;if so set flag
           ;
           ; Set up shell level, and AUTOEXEC path if it isn't set already
@@ -3991,6 +4009,54 @@
           mov       DREnvLen,si         ;save length
           ;
 GDRExit:  exit                          ;all done
+	  ;
+	  ; =================================================================
+	  ;
+	  ; GetDRF58 - Get DR-DOS F5 or F8 boot key scan code
+	  ;
+	  ; On entry:
+	  ;	    No requirements.
+	  ;
+	  ; On exit:
+	  ;	    DS preserved
+	  ;	    All other registers destroyed, interrupt state unchanged
+	  ;	    Init flags set according to boot key, if any had been hit
+	  ;
+	  ;
+	  entry     GetDRF58,noframe,,local  ;set up entry point
+	  assume    ds:@curseg		;fix assumes
+	  ;
+	  test	    LMFlags,ROOTFLAG	;are we the true root shell?
+	   jz	    GDRFend		;if not, forget about DR boot keys
+	  mov	    ax,DRCHECK		;get DR-DOS check code
+	  calldos			;check for it
+	   jc	    GDRFend		;if not DR-DOS go on
+	  mov	    ax,DRSTART		;code to get startup data address
+	  calldos			;get the address
+	   jc	    GDRFend		;if can't get it go on
+	  mov	    ax,es:12h[bx]	;get DR env segment
+	  mov	    dx,ds:[PSP_MEND]	;get end of memory
+	  sub	    dx,800h		;address of last 32K
+	  cmp	    ax,dx		;is addr in last 32K (sanity check)?
+	   jb	    GDRFend		;if not forget it
+	  cld				;go forward
+	  mov	    es,ax		;source is DR segment
+	  xor	    di,di		;clear destination offset
+	  ;
+	  mov	    al,1Ah		;end-of-environment
+	  mov	    cx,DRENVMAX 	;top address limit
+	  repne     scasb		;search for the 1Ah byte
+	   jne	    GDRFend		;not found (should be impossible!)
+	  mov	    ax,es:[di]		;found - get boot key scan code, if any
+	  cmp	    ax,3F00h		;was F5 hit?
+	   jne	    GDRF8		;no, check next
+	  bset	    InitFlg2,NOAUTOEX	;yes, disable AUTOEXEC.BAT
+	  jmp	    short GDRFend	;done
+GDRF8:	  cmp	    ax,4200h		;was F8 hit?
+	   jne	    GDRFend		;no, exit
+	  mov	    IFData.I_Step,1	;yes, set the "single-step" flag
+	  ;
+GDRFend:  exit				;all done
           ;
           ; =================================================================
           ;
diff -Nu d:7.501/4dlmsg.asm SOURCES/4dlmsg.asm
--- d:7.501/4dlmsg.asm	2006-11-12 16:00:50 +0200
+++ SOURCES/4dlmsg.asm	2007-09-18 00:01:58 +0200
@@ -42,19 +42,38 @@
           ;         Messages for 4DOS.ASM
           ;
           if        _MsgType eq 0       ;assemble resident messages
-RespTab   db        "IRAF"              ;table of allowed critical error
-                                        ;  responses, in order by DOS
+RespTab   db        "FARI"              ;table of allowed critical error
+                                        ;  responses, reverse-ordered by DOS
                                         ;  response code (0=ignore, 1=retry,
                                         ;  2=abort, 3=fail)
 RespCnt   equ       $ - RespTab         ;number of allowed responses
+PermTab   db        00001000b           ;bit 3 - Fail allowed
+          db               0            ;        Abort always allowed
+          db        00010000b           ;bit 4 - Retry allowed
+          db        00100000b           ;bit 5 - Ignore allowed
 LdError   db        BELL, CR, LF, "4DOS unrecoverable error "
 ErrCode   db        "  "                ;space for code
           db        CR, LF, "$"         ;rest of message
           ;
           ;         Critical error handler messages
           ;
-DevErr    db        " on device "
+ReadErr   db        " reading", 0
+WritErr   db        " writing", 0
+DrivErr   db        " drive ", 0
+DevErr    db        " device "
 DevName   db        8 dup (?), 0
+InsVol    db        CR, LF, "Please insert volume ", 0
+Serial    db        " serial "
+NumMSW    db        "0000-"
+NUMLSW    db        "0000", 0
+          ;
+          ;         Prompt offsets (the prompts are in a different section!)
+          ;         If you change the prompts, you must adjust these offsets
+          ;
+PrROffs   equ       10
+PrIOffs   equ       20
+PrFOffs   equ       31
+PrQOffs   equ       40
           endif                         ;end resident portion
           ;
           ;
@@ -130,13 +149,18 @@
           ; version).  CAUTION:  The "Prompt" variable in INT24.ASM holds
           ; one of these prompts; it must be long enough to do so!  If you 
           ; modify these you may need to adjust the length of Prompt.
+          ; Also, don't forget to adjust the 4 Pr?Offs offsets above!
           ;
 Prompt2   db        Pr2Len, CR, LF
-          db        "R(etry), I(gnore), or A(bort)? ", 0
-Pr2Len    equ       ($ - Prompt2)
+          db        "A(bort), R(etry), I(gnore)? ", 0
+Pr2Len    equ       ($ - Prompt2 - 1)
 Prompt3   db        Pr3Len, CR, LF
-          db        "R(etry), I(gnore), F(ail), or A(bort)? ", 0
-Pr3Len    equ       ($ - Prompt3)
+          db        "A(bort)", 0
+PrRetry   db        ", R(etry)", 0
+PrIgnore  db        ", I(gnore)", 0
+PrFail    db        ", F(ail)", 0
+PrQuestn  db        "? ", 0
+Pr3Len    equ       ($ - Prompt3 - 1)
           ;
           ;
           ; Module names for debug messages during load.  Byte before
diff -Nu d:7.501/4dlparms.asm SOURCES/4dlparms.asm
--- d:7.501/4dlparms.asm	2006-11-12 16:00:50 +0200
+++ SOURCES/4dlparms.asm	2009-02-26 13:15:40 +0200
@@ -67,7 +67,7 @@
 	endif
 INTVER	=	(INTVER or PRODBITS)  ;add new bits to INTVER
 	;
-VERSION   equ       3207h               ;4DOS version 7.50
+VERSION   equ       (((INTVER - 100) SHL 8) + 7);e.g. 7.51 for INTVER=151
           ;
 SERVINT   equ       I_MPX               ;server uses multiplex interrupt
 SERVSIG   equ       0D44Dh              ;server signature value
@@ -93,7 +93,7 @@
 STACKSIZ  equ       320                 ;4DOS loader local stack
 LOWSTSAV  equ       64                  ;bytes of local stack to save during
                                         ;  INT 2E
-MODMAX    equ       2048                ;maximum total space for all loadable
+MODMAX    equ       2560                ;maximum total space for all loadable
                                         ;  modules (bytes)
 DRENVMAX  equ       MODMAX - 2          ;maximum total space for DR-DOS env
                                         ;  variables passed from CONFIG.SYS;
diff -Nu d:7.501/4dos SOURCES/4dos
--- d:7.501/4dos	2004-08-15 21:37:40 +0200
+++ SOURCES/4dos	2008-12-28 11:21:08 +0200
@@ -21,13 +21,14 @@
 !INCLUDE SETUP.MAK
 
 # Set up local macros and header list
-headers=4all.h proto.h globals.h 4dos.h inistruc.h
+headers=4all.h proto.h globals.h 4dos.h inistruc.h message.$(MHDR)
 
 # Define local commands
 LASM=$(ASM) /D_CSEG=LOAD /D_PREFIX=L_ /D_MODEL=TINY %s
 SASM=$(ASM) /D_CSEG=SERV /D_MODEL=SMALL %s
 TASM=$(ASM) /D_MODEL=SMALL %s
 BASM=$(ASM) /D_MODEL=SMALL /DTEXTLEN=160 %s
+CASM=$(ASM) /D__MEDIUM__ /DTEXT_SEG=SHARE_TEXT %s
 LINKCMD=$(LINK) @..\$(LNKNAME)
 
 #!IF "$(_LANGUAGE)" == "ENGLISH"
@@ -51,7 +52,7 @@
         $(LASM)
 
 4dostart.lib : $(OBJ)\4dostart.obj
-        lib 4dostart -+$(OBJ)\4dostart.obj;
+        lib /nologo 4dostart -+$(OBJ)\4dostart.obj;
 
 
 
@@ -174,26 +175,26 @@
 $(OBJ)\errormsg.obj : errormsg.asm
         $(SASM)
 
-$(OBJ)\main.obj : main.c $(headers) swerror.c
+$(OBJ)\main.obj : main.c $(headers)
         $(COMP) /NT_TEXT main.c
 
-$(OBJ)\parser.obj : parser.c $(headers) sharware.h swerror.c
+$(OBJ)\parser.obj : parser.c $(headers)
         $(COMP) /NT_TEXT parser.c
 
-$(OBJ)\dosinit.obj : dosinit.c $(headers) version.h sharware.h
+$(OBJ)\dosinit.obj : dosinit.c $(headers) version.h build.h
         $(COMP) /NT_TEXT dosinit.c
 
 $(OBJ)\cmds.obj : cmds.c $(headers)
         $(COMP) /NT_TEXT cmds.c
 
-$(OBJ)\expand.obj : expand.c $(headers)
+$(OBJ)\expand.obj : expand.c $(headers) version.h build.h
         $(COMP) /NTMISC_TEXT expand.c
 
 $(OBJ)\eval.obj : eval.c $(headers)
-        $(COMP) /NTDIRCMDS_TEXT eval.c
+        $(COMP) /NTSCREENIO_TEXT eval.c
 
 $(OBJ)\dircmds.obj : dircmds.c $(headers) dblspace.h
-        $(COMP) dircmds.c
+        $(COMP) /NTSCREENIO_TEXT dircmds.c
 
 $(OBJ)\filecmds.obj : filecmds.c $(headers)
         $(COMP) /NT_TEXT filecmds.c
@@ -202,9 +203,9 @@
         $(COMP) /NT_TEXT syscmds.c
 
 $(OBJ)\select.obj : select.c selectc.c $(headers) dblspace.h
-        $(COMP) /NTDIRCMDS_TEXT select.c
+        $(COMP) /NTSCREENIO_TEXT select.c
 
-$(OBJ)\misc.obj : misc.c $(headers) swerror.c
+$(OBJ)\misc.obj : misc.c $(headers) md5.h sha.h
         $(COMP) misc.c
 
 $(OBJ)\env.obj : env.c $(headers)
@@ -213,7 +214,7 @@
 $(OBJ)\batch.obj : batch.c $(headers)
         $(COMP) /NT_TEXT batch.c
 
-$(OBJ)\error.obj : error.c $(headers) message.$(MHDR)
+$(OBJ)\error.obj : error.c $(headers)
         $(COMP) /NT_TEXT error.c
 
 !IF "$(FAMILY)" != "RT"
@@ -228,18 +229,18 @@
         $(COMP) /NTSCREENIO_TEXT window.c
  
 $(OBJ)\listall.obj : listall.c listc.c $(headers)
-        $(COMP) /NTDIRCMDS_TEXT listall.c
+        $(COMP) /NTSCREENIO_TEXT listall.c
 
 $(OBJ)\lines.obj : lines.c $(headers)
         $(COMP) /NTSCREENIO_TEXT lines.c
 
-$(OBJ)\doscmds.obj : doscmds.c $(headers) version.h build.h
-        $(COMP) /NT_TEXT doscmds.c
+$(OBJ)\doscmds.obj : doscmds.c $(headers) version.h build.h idle.h
+        $(COMP) /I. /NT_TEXT doscmds.c
 
 $(OBJ)\iofmt.obj : iofmt.c $(headers)
-        $(COMP) /NTSCREENIO_TEXT iofmt.c
+        $(COMP) /NTMISC_TEXT iofmt.c
 
-$(OBJ)\doscalls.obj : doscalls.c $(headers) version.h sharware.h
+$(OBJ)\doscalls.obj : doscalls.c $(headers) version.h build.h
         $(COMP) /NTMISC_TEXT doscalls.c
 
 $(OBJ)\dostty.obj : dostty.c $(headers)
@@ -272,8 +273,44 @@
 $(OBJ)\strmenc.obj : strmenc.c
         $(COMP) /NTSHARE_TEXT strmenc.c
 
-$(OBJ)\md5.obj : md5.c md5.h
-        $(COMP) /NTSHARE_TEXT md5.c
+$(OBJ)\md5c.obj : md5c.c md5.h
+        $(COMP) /NTSHARE_TEXT md5c.c
+
+$(OBJ)\sha1.obj : sha1.c sha.h sha-priv.h
+        $(COMP) /NTSHARE_TEXT sha1.c
+
+$(OBJ)\cputype.obj : cputype.c tmi0sdgl.h
+        $(COMP) /NTSHARE_TEXT /D_dist=_far cputype.c
+
+$(OBJ)\cpuspeed.obj : cpuspeed.asm header.ash tmi0sdgl.inc
+        $(CASM)
+
+$(OBJ)\realcode.obj : realcode.asm header.ash tmi0sdgl.inc pci.inc
+        $(CASM)
+
+# the next 6 files from the Open Watcom RTL must be compiled if MSVC is used
+#---------------------------------------------------------------------------
+
+$(OBJ)\gmtime.obj : gmtime.c variety.h thetime.h timedata.h
+        $(COMP) /NTSHARE_TEXT gmtime.c
+
+$(OBJ)\leapyear.obj : leapyear.c variety.h rtdata.h timedata.h
+        $(COMP) /NTSHARE_TEXT leapyear.c
+
+$(OBJ)\locmktim.obj : locmktim.c variety.h rtdata.h timedata.h
+        $(COMP) /NTSHARE_TEXT locmktim.c
+
+$(OBJ)\mktime.obj : mktime.c variety.h rtdata.h timedata.h
+        $(COMP) /NTSHARE_TEXT mktime.c
+
+$(OBJ)\timeutil.obj : timeutil.c variety.h rtdata.h timedata.h
+        $(COMP) /NTSHARE_TEXT timeutil.c
+
+$(OBJ)\tzset.obj : tzset.c variety.h rtdata.h timedata.h exitwmsg.h _time.h
+        $(COMP) /NTSHARE_TEXT tzset.c
+
+#---------------------------------------------------------------------------
+# end of Open Watcom RTL files
 
 $(OBJ)\batdcomp.obj : batdcomp.asm
         $(TASM)
@@ -282,31 +319,33 @@
    $(ASM) win95.asm
 
 $(LINKTARG) : \
+#       initialization (LOAD_TEXT segment)
+              $(OBJ)\initerrs.obj $(OBJ)\4dlinit.obj $(OBJ)\fname.obj \
+              $(OBJ)\ldosumb.obj $(OBJ)\decout.obj $(OBJ)\srchenv.obj \
+              $(OBJ)\parspath.obj $(OBJ)\findems.obj $(OBJ)\findureg.obj \
+              $(OBJ)\iniparse.obj $(OBJ)\lreloc.obj $(OBJ)\hexout.obj \
 #       resident (LOAD_TEXT segment)
               $(OBJ)\4dos.obj $(OBJ)\lerrmsg.obj $(OBJ)\modules.obj \
-#       initialization (LOAD_TEXT segment)
-              $(OBJ)\ldosumb.obj $(OBJ)\initerrs.obj \
-              $(OBJ)\4dlinit.obj $(OBJ)\fname.obj $(OBJ)\decout.obj \
-              $(OBJ)\srchenv.obj $(OBJ)\parspath.obj $(OBJ)\findems.obj \
-              $(OBJ)\findureg.obj $(OBJ)\iniparse.obj $(OBJ)\lreloc.obj \
-              $(OBJ)\hexout.obj \
 #       transient - server (SERV_TEXT segment)
-              $(OBJ)\server.obj $(OBJ)\swapchk.obj $(OBJ)\serverrs.obj \
+              $(OBJ)\serverrs.obj $(OBJ)\server.obj $(OBJ)\swapchk.obj \
               $(OBJ)\reshigh.obj $(OBJ)\dosumb.obj $(OBJ)\relocate.obj \
               $(OBJ)\dv.obj $(OBJ)\errormsg.obj \
 #       transient - general (_TEXT segment)
+              $(OBJ)\dosutil.obj $(OBJ)\inout.obj $(OBJ)\bcd.obj \
+              $(OBJ)\keyparse.obj $(OBJ)\tokens.obj $(OBJ)\umbreg.obj \
+              $(OBJ)\compdrv.obj $(OBJ)\win95.obj \
+              $(OBJ)\cpuspeed.obj $(OBJ)\realcode.obj \
               $(OBJ)\main.obj $(OBJ)\parser.obj $(OBJ)\dosinit.obj \
               $(OBJ)\cmds.obj $(OBJ)\expand.obj $(OBJ)\eval.obj \
               $(OBJ)\dircmds.obj $(OBJ)\filecmds.obj $(OBJ)\syscmds.obj \
               $(OBJ)\select.obj $(OBJ)\misc.obj $(OBJ)\env.obj \
-              $(OBJ)\batch.obj $(OBJ)\error.obj \
+              $(OBJ)\batch.obj $(OBJ)\error.obj $(OBJ)\_file.obj \
               $(OBJ)\screenio.obj $(OBJ)\window.obj $(OBJ)\listall.obj \
               $(OBJ)\lines.obj $(OBJ)\doscmds.obj $(OBJ)\iofmt.obj \
-              $(OBJ)\doscalls.obj $(OBJ)\_file.obj $(OBJ)\dosutil.obj \
-              $(OBJ)\dostty.obj $(OBJ)\inout.obj $(OBJ)\bcd.obj \
-              $(OBJ)\keyparse.obj $(OBJ)\tokens.obj $(OBJ)\umbreg.obj \
-              $(OBJ)\compdrv.obj $(OBJ)\strmenc.obj $(OBJ)\md5.obj \
-              $(OBJ)\batdcomp.obj $(OBJ)\win95.obj \
+              $(OBJ)\doscalls.obj $(OBJ)\dostty.obj $(OBJ)\strmenc.obj \
+              $(OBJ)\md5c.obj $(OBJ)\sha1.obj $(OBJ)\cputype.obj \
+              $(OBJ)\gmtime.obj $(OBJ)\leapyear.obj $(OBJ)\locmktim.obj \
+              $(OBJ)\mktime.obj $(OBJ)\timeutil.obj $(OBJ)\tzset.obj \
 #       other
               4dostart.lib startupm.lib 4dos $(LNKNAME) build.txt \
               setup.mak dolink.mak
diff -Nu d:7.501/4dos.asm SOURCES/4dos.asm
--- d:7.501/4dos.asm	2006-11-12 16:00:50 +0200
+++ SOURCES/4dos.asm	2007-09-18 00:01:58 +0200
@@ -161,9 +161,12 @@
           ;
           ; Critical error handler data and message storage
           ;
-SaveCode  dw        ?                   ;temp save of return code
+MediaID   farptr    <>                  ;temp save of media id structure ptr
+SaveCode  db        ?                   ;temp save of return code
+SaveDrive db        ?                   ;temp save drive number
+SaveInfo  db        ?                   ;temp save error information
           ;
-BSMsg     db        BS, ' ', BS, 0      ;backspace and overwrite
+BSMsg     db        BS, 0               ;backspace
 LocCrLf   db        CR, LF, 0           ;cr / lf
           ;
           ifdef     ENGLISH
@@ -471,46 +474,56 @@
           mov       bx,sp               ;copy stack pointer
           add       bx,6                ;make bx = original stack pointer
           pushm     cx,dx,si,di,bp,es   ;save other registers
-          push      ax                  ;save ax for a bit
           loadseg   ds,cs               ;set ds to data area
+          mov       wptr SaveDrive,ax   ;save drive (AL) and error info (AH)
           ;
           ; Figure out the error code
           ;
           and       di,0FFH             ;strip high byte of error number
+          test      LMFlags,DOS3        ;DOS 3 or above?
+           jnz      GetExt              ;yes, get extended error
+          cmp       di,12               ;no, code > 12?
+           jbe      Remap               ;no, remap it
+          mov       di,12               ;yes, limit critical error code to 12
+Remap:    add       di,19               ;convert to extended error code
+          jmp       short ChkAuto
           ;
           ; DOS 3 or above -- get extended error
           ;
 GetExt:   pushm     si,bp,ds            ;save registers destroyed by dos call
           xor       bx,bx               ;need bx=0 for dos get ext error
           calldos   GETERR              ;get extended error code
-          mov       di,ax               ;copy to di
-          popm      ds,bp,si            ;restore registers
+          pop       ds                  ;restore data segment
+          mov       MediaID.foff,di     ;save media id structure pointer
+          mov       MediaID.fseg,es     ;  for an invalid disk change error
+          cmp       ax,19               ;non-critical error code?
+           jae      SavErr              ;no, continue
+          mov       ax,31               ;yes, replace it with "general failure"
+SavErr:   mov       di,ax               ;copy to di
+          popm      bp,si               ;restore registers
           ;
           ; Check for automatic Fail response
           ;
-ChkAuto:  pop       ax                  ;get back original ax
-          test      LMFlag2,AUTOFAIL    ;automatic Fail response?
+ChkAuto:  test      LMFlag2,AUTOFAIL    ;automatic Fail response?
            jz       FixFH               ;if not go on
           mov       SaveCode,3          ;set code to Fail
           jmp       Ret24               ;and issue the fail response
           ;
           ; Fix up file handles so we can use them
           ;
-FixFH:    push      ax                  ;save error code
-          mov       es,PSPSeg           ;get our PSP
+FixFH:    mov       es,PSPSeg           ;get our PSP
           mov       dx,Err24Hdl         ;get SFT handles for error I/O
           calldos   GETPSP              ;get the current program's PSP
           mov       es,bx               ;copy it
           les       bx,es:[PSP_FPTR]    ;get JFT pointer
           xchg      es:[bx],dx          ;set STDIN and STDOUT to true STDERR,
                                         ;  get old value
-          pop       ax                  ;restore error code
           push      dx                  ;save old file handles for restore
           ;
           ; Figure out what kind of error it is
           ;
           cld                           ;all moves go forward
-          test      ah,080H             ;test for block dev error (bit 7 = 0)
+          test      SaveInfo,080H       ;test for block dev error (bit 7 = 0)
            jz       DiskErr             ;if so go handle that
           ;
           ; Handle character device or FAT error
@@ -518,10 +531,6 @@
           mov       es,bp               ;set es = driver header segment
           test      wptr es:[si+4],08000H  ;check driver char dev bit
            jz       FATErr              ;not a character device, must be FAT
-          cmp       di,21               ;device not ready?
-           jne      GetDname            ;if some other error go on
-          mov       di,40               ;use "not ready" instead of "drive
-                                        ;  not ready" error message
           ;
           ; Get device name from driver header
           ;
@@ -539,7 +548,7 @@
           call      PrtErr              ;print error message
           mov       si,offset DevErr    ;point to "on device" message
           call      PrtMsg              ;print it
-          jmp       short DoPrompt      ;go print prompt
+          jmp       short CkInvChg      ;continue
           ;
           ; Handle FAT error
           ;
@@ -547,15 +556,65 @@
           ;
           ; Handle block device errors
           ;
-;FIXME - Change this to display drive letter first
 ;Maybe also get file name used in transient portion (if 4DOS is active) and
 ;display full name??
 DiskErr:  call      PrtErr              ;print error message
+          mov       si,offset DrivErr   ;point to "drive" message
+          call      PrtMsg              ;display it
+          mov       dl,SaveDrive        ;copy byte to DL for INT 21
+          add       dl,'A'              ;convert drive number to letter
+          calldos   DISPCHR             ;output the drive letter
+          ;
+          ; Handle invalid disk change telling the user which volume is needed
+          ;
+CkInvChg: cmp       di,34               ;invalid disk change?
+           jne      DoPrompt            ;no, continue
+          mov       si,offset InsVol    ;load "please insert volume" message
+          call      PrtMsg              ;print it
+          loadseg   es,ds               ;load message segment
+          push      ds                  ;save data segment
+          lds       si,MediaID          ;load needed volume id string
+          calldos   VERSION             ;check whether there is a serial #
+          cmp       al,4                ;version 4 or later?
+           jb       PrtVol              ;no, skip serial number
+          push      si                  ;save original pointer for serial #
+          call      PrtMsg              ;print it
+          pop       si                  ;restore pointer and
+          add       si,12               ;yes, get serial number
+          push      di                  ;save error code
+          mov       di,offset NumLSW    ;point to LSW string
+          lodsw                         ;get LSW
+          call      Hex2str             ;convert it
+          mov       di,offset NumMSW    ;point to MSW string
+          lodsw                         ;get MSW
+          call      Hex2str             ;convert it
+          pop       di                  ;restore error code
+          mov       si,offset Serial    ;get serial number message
+PrtVol:   pop       ds                  ;restore data segment
+          call      PrtMsg              ;print it
           ;
-          ; Get user response to error
+          ; Prompt the user the allowed actions
           ;
 DoPrompt: mov       si,offset Prompt    ;point to prompt
           call      PrtMsg              ;display it
+          test      LMFlags,DOS3        ;DOS 3 or above?
+           jz       GetKey              ;no, go check the response
+          test      SaveInfo,00010000b  ;yes, retry allowed?
+           jz       IgnChk1             ;no, check ignore
+          mov       si,offset Prompt+PrROffs
+          call      PrtMsg              ;yes, show "retry"
+IgnChk1:  test      SaveInfo,00100000b  ;ignore allowed?
+           jz       FailChk1            ;no, check fail
+          mov       si,offset Prompt+PrIOffs
+          call      PrtMsg              ;yes, show "ignore"
+FailChk1: test      SaveInfo,00001000b  ;fail allowed?
+           jz       DoQuestn            ;no, show question mark
+          mov       si,offset Prompt+PrFOffs
+          call      PrtMsg              ;yes, show "fail"
+DoQuestn: mov       si,offset Prompt+PrQOffs
+          call      PrtMsg              ;show question mark
+          ;
+          ; Get user response to error
           ;
 GetKey:   
 ;          mov       ax,0E00h + BELL     ;get write char func + beep character
@@ -585,6 +644,10 @@
           jb        GetKey              ;if so retry
           cmp       al,126              ;too large?
           ja        GetKey              ;if so retry
+          cmp       al,97               ;is it lower case alpha?
+           jb       PrtChar             ;if too small for lower case go on
+          sub       al,32               ;convert lower case to upper case
+PrtChar:
 ;          push      ax                  ;save it (int 10h destroys AL)
 ;          mov       ah,0Eh              ;get write character function code
 ;          xor       bx,bx               ;page 0
@@ -594,25 +657,31 @@
           mov       dl,al               ;copy character
           calldos   DISPCHR             ;echo it
           pop       ax                  ;get back character
-          cmp       al,97               ;is it lower case alpha?
-           jb       ChkResp             ;if too small for lower case go on
-          sub       al,32               ;convert lower case to upper case
           ;
           ; Calculate response value
           ;
 ChkResp:  mov       di,offset RespTab   ;point to table
           loadseg   es,ds               ;set segment
           mov       cx,RespCnt          ;get number of possible responses
-          repne     scasb               ;find response
-           je       RespVal             ;if found go on
-          mov       si,offset BSMsg     ;illegal key pressed -- backspace 
+          test      LMFlags,DOS3        ;DOS 3 or above?
+           jz       ChkRsp2             ;no, do it the simple way
+          repne     scasb               ;yes, find response
+           jne      BadKey              ;try again if not found
+          mov       al,PermTab-RespTab-1[di] ;get permission mask
+          or        al,al               ;zero mask (always allowed)?
+           jz       RespVal             ;yes, go on
+          test      SaveInfo,al         ;no, response allowed?
+           jnz      RespVal             ;if so go on
+BadKey:   mov       si,offset BSMsg     ;illegal key pressed -- backspace 
                                         ;  over it
           call      PrtMsg              ;do backspace
           jmp       short GetKey        ;go try again
           ;
-RespVal:  sub       di,offset RespTab + 1  ;get response value (0=I, 1=R,
-                                           ;  2=A, 3=F)
-          mov       SaveCode,di          ;save to send back to DOS
+ChkRsp2:  dec       cx                  ;skip the "fail" response
+          inc       di                  ;  (not supported in DOS 2.x)
+          repne     scasb               ;find response (0=I, 1=R, 2=A, 3=F)
+           jne      BadKey              ;try again if not found
+RespVal:  mov       SaveCode,cl         ;save response to send back to DOS
           ;
           ; All done, display final message
           ;
@@ -629,7 +698,7 @@
           ; Return to DOS
           ;
 Ret24:    popm      es,bp,di,si,dx,cx,bx,ax   ;restore registers
-          mov       al,bptr SaveCode    ;get return code (low byte)
+          mov       al,SaveCode         ;get return code
           pop       ds                  ;restore ds
           iret                          ;return to dos
           ;
@@ -690,7 +759,7 @@
           var       OutBuf,ERRMAX       ;output buffer on stack
           varend
           ;
-          pushm     bx,si,ds            ;save prompt message address, ds
+          pushm     bx,si,di,ds         ;save prompt message address, ds
           mov       ax,di               ;copy error number
           loadseg   es,ss               ;get buffer segment
           lea       di,OutBuf           ;get buffer offset
@@ -701,7 +770,13 @@
           stosb                         ;store null at end of message
           popm      ds,si               ;point to output buffer
           call      PrtMsg              ;print error message
-          popm      ds,si,bx            ;get back prompt address, ds
+          pop       ds                  ;get back data segment
+          test      SaveInfo,1          ;was it a read operation?
+          mov       si,offset ReadErr   ;(assume so)
+           jz       PrtOper             ;yes, go display it
+          mov       si,offset WritErr   ;no, it was a write
+PrtOper:  call      PrtMsg              ;display the chosen string
+          popm      di,si,bx            ;get back prompt address
           exit                          ;all done
           ;
           ;
@@ -733,6 +808,32 @@
           exit                          ;all done
           ;
           ;
+          ; HEX2STR - Convert a 16-bit hexadecimal number into a string
+          ;
+          ; On entry:
+          ;         AX = hexadecimal number
+          ;         ES:DI = pointer to destination string
+          ;
+          ; On exit:
+          ;         AX, CX destroyed
+          ;         ES:DI = offset of last byte of string + 1
+          ;         All other registers and interrupt state unchanged
+          ;
+          entry     Hex2str,noframe,,local  ;convert a hex number to string
+          call	    @f                  ;process high byte
+@@:       xchg      al,ah               ;swap bytes
+          call      @f                  ;process high nibble
+@@:       rorn      al,4,cl             ;swap nibbles
+          push      ax                  ;save accumulator
+          and       al,0Fh              ;isolate low nibble
+          cmp       al,10               ;tell digits from letters
+          sbb       al,69h              ;0-9 => 96h-9Fh, 0Ah-0Fh => 0A1h-0A6h
+          das                   ;subtract 66h from digits or 60h from letters
+          stosb                 ;store 30h-39h ('0'-'9') or 41h-46h ('A'-'F')
+          pop       ax                  ;restore accumulator
+          exit                          ;return to caller
+          ;
+          ;
 @curseg   ends                          ;close code seg
           ;
           end                           ;that's all folks
diff -Nu d:7.501/4dos.h SOURCES/4dos.h
--- d:7.501/4dos.h	2006-11-12 16:00:50 +0200
+++ SOURCES/4dos.h	2008-11-23 12:52:12 +0200
@@ -62,6 +62,12 @@
 #define _stprintf sprintf
 #define _stscanf sscanf
 
+#ifdef __WATCOMC__
+	#define _SH_DENYNO SH_DENYNO
+	#define _SH_DENYWR SH_DENYWR
+	#define _SH_COMPAT SH_COMPAT
+#endif
+
 typedef unsigned char UCHAR;
 typedef unsigned short USHORT;
 typedef unsigned short WORD;
@@ -96,6 +102,7 @@
 
 #define MIN_STACK	1024
 
+#define DOS_OEM_ID    0x07F8	// DOS OEM ID bits in gnOSFlags
 #define DOS_IN_ROM    0x0800	// DOS is in ROM (DH)
 #define DOS_IN_HMA    0x1000	// DOS in HMA (DH)
 #define DOS_IS_OS2    0x4000	// OS/2 VDM
@@ -129,6 +136,16 @@
 	TCHAR szBytesTotal[16];
 } QDISKINFO;
 
+typedef struct {
+	WORD uBufSize;
+	WORD uFlags;
+	DWORD ulCylinders;
+	DWORD ulHeads;
+	DWORD ulSectPerTrack;
+	t_int64 llTotalSectors;
+	WORD uSectSize;
+} LBA;
+
 /* FindFirst/FindNext structure from <winbase.h>: */
 
 #define WINAPI	_far _pascal
@@ -175,7 +192,7 @@
 
 /* Possible error return from handle functions: */
 
-#define INVALID_HANDLE_VALUE 0xFFFF
+#define INVALID_HANDLE_VALUE (-1)
 
 
 // find first / find next structure
diff -Nu d:7.501/4dos.lnk SOURCES/4dos.lnk
--- d:7.501/4dos.lnk	2004-08-15 21:36:44 +0200
+++ SOURCES/4dos.lnk	2008-12-27 17:18:14 +0200
@@ -1,13 +1,15 @@
 4dos+lerrmsg+modules+
 ldosumb+initerrs+4dlinit+fname+decout+srchenv+
-parspath+findems+findureg+iniparse+lreloc+hexout+
+findems+findureg+iniparse+lreloc+hexout+
 server+swapchk+serverrs+reshigh+dosumb+relocate+dv+errormsg+
 doscalls+main+parser+dosinit+iofmt+dostty+
 expand+_file+win95+misc+env+error+cmds+screenio+batch+dircmds+filecmds+
 syscmds+doscmds+select+window+listall+lines+
 inout+dosutil+eval+bcd+keyparse+tokens+
-umbreg+compdrv+strmenc+md5+batdcomp
+umbreg+compdrv+strmenc+md5c+sha1+
+gmtime+leapyear+locmktim+mktime+timeutil+tzset+
+cputype+cpuspeed+realcode
 4dos.com
 4dos/map
-sasjp + ..\4dostart + ..\startupm + mlibce
+..\sasjp + ..\4dostart + ..\startupm + mlibce
 
diff -Nu d:7.501/4dos.wlk SOURCES/4dos.wlk
--- d:7.501/4dos.wlk	1970-01-01 02:00:00 +0200
+++ SOURCES/4dos.wlk	2007-10-10 13:14:58 +0200
@@ -0,0 +1,14 @@
+# WLINK control file for 4DOS
+
+system    dos
+option    map
+option    verbose
+option    quiet
+option    stack=8k
+option    nodefaultlibs
+option    nocaseexact
+#disable   2030 # multiple starting addresses
+library   sasjp.lib
+#library  startupm.lib
+library   4dostart.lib
+library   clibm.lib
diff -Nu d:7.501/_time.h SOURCES/_time.h
--- d:7.501/_time.h	1970-01-01 02:00:00 +0200
+++ SOURCES/_time.h	2007-07-03 13:37:06 +0200
@@ -0,0 +1,34 @@
+/****************************************************************************
+*
+*                            Open Watcom Project
+*
+*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
+*
+*  ========================================================================
+*
+*    This file contains Original Code and/or Modifications of Original
+*    Code as defined in and that are subject to the Sybase Open Watcom
+*    Public License version 1.0 (the 'License'). You may not use this file
+*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
+*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
+*    provided with the Original Code and Modifications, and is also
+*    available at www.sybase.com/developer/opensource.
+*
+*    The Original Code and all software distributed under the License are
+*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
+*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
+*    NON-INFRINGEMENT. Please see the License for the specific language
+*    governing rights and limitations under the License.
+*
+*  ========================================================================
+*
+* Description:  prototypes for internal time related functions
+*
+****************************************************************************/
+
+
+extern int  __DontCacheOSTZ( void );
+extern int  __CacheOSTZ( void );
+extern void __parse_tz( char * tz );
diff -Nu d:7.501/batch.c SOURCES/batch.c
--- d:7.501/batch.c	2006-11-12 16:00:50 +0200
+++ SOURCES/batch.c	2008-10-20 08:32:58 +0200
@@ -296,6 +296,8 @@
 
    		if ((( pBTMHdr->fEncrypted & 0xF ) ^ ( pBTMHdr->fEncrypted >> 4 )) == 0 ) {
 
+			bframe[cv.bn].nFlags |= BATCH_ENCRYPTED;
+
 			// build the key to decrypt the user's key
 			for ( i = 0, cKeyChar = ' '; i < BC_KK_LEN; i++ ) {
 				cKeyChar += (int)szKeyKeyOffsets[i + 4];
@@ -416,7 +418,7 @@
 	extern int gnPopExitKey;
 	int i, nFH, nEditMode = EDIT_DATA;
 	unsigned int nLength, uSize;
-	unsigned long ulListSize = 0L;
+	unsigned long ulSize, ulListSize = 0L;
 	TCHAR _far * lpszArg;
 	TCHAR _far *lpBuf;
 	TCHAR szBuffer[MAXFILENAME+12];
@@ -429,7 +431,11 @@
 	if (( nFH = _sopen( bframe[ cv.bn ].pszBatchName, (_O_RDONLY | _O_BINARY), _SH_DENYWR )) < 0 )
 		return ( error( _doserrno, bframe[cv.bn].pszBatchName ));
 	
-	uSize = (UINT)( QueryFileSize( bframe[ cv.bn ].pszBatchName, 0 ) + 0x10 ) * sizeof(TCHAR);
+	if (( ulSize = ( QueryFileSize( bframe[ cv.bn ].pszBatchName, 0 ) + 0x10 ) * sizeof(TCHAR)) >= 0xFFF0L ) {
+		_close( nFH );
+		return (error( ERROR_NOT_ENOUGH_MEMORY, bframe[ cv.bn ].pszBatchName ));
+	}
+	uSize = (unsigned int)ulSize;
 	lpBuf = (TCHAR _far *)AllocMem( &uSize );
 
 	HoldSignals();
@@ -452,7 +458,7 @@
 	_close( nFH );
 
 	// call the popup window
-	sprintf( szBuffer, _TEXT("%s [%u]"), bframe[cv.bn].pszBatchName, bframe[cv.bn].uBatchLine );
+	sprintf( szBuffer, _TEXT("%s [%u], Stack: %u"), bframe[cv.bn].pszBatchName, bframe[cv.bn].uBatchLine, _stackavail() );
 
 	if ( wPopSelect( 2, 4, 8, 70, lppList, i, bframe[cv.bn].uBatchLine, szBuffer, DEBUGGER_PROMPT, _TEXT("TSJXVAOQL"), 0x12 ) == 0L )
 		gnPopExitKey = ESC;
@@ -643,7 +649,7 @@
 			szFileName[0] = _TEXT('\0');
 
 			// initialize date/time/size ranges start & end values
-			ntharg( pszArg, 0x8002 );
+			ntharg( pszArg, (int)0x8002 );
 			if (( pExpression = gpNthptr ) == NULL )
 				goto do_usage;
 
@@ -1242,7 +1248,7 @@
 	if ( pszArg[1] == _TEXT('\0') )
 		strins( pszForVar, _TEXT("\001") );
 
-	ntharg( pszCmdLine, 0x8002 );
+	ntharg( pszCmdLine, (int)0x8002 );
 	pszArgumentSet = gpNthptr;
 	if (( pszArgumentSet == NULL ) || ( *pszArgumentSet != _TEXT('(') ))
 		goto for_usage_error;
@@ -1741,7 +1747,7 @@
 							// add arguments to environment
 							for ( i = 0; (( pszArg = ntharg( bframe[ cv.bn ].pszGosubArgs, i )) != NULL ); i ++ ) {
 								strcpy( szLabel, pszArg );
-								if (( pszArg = ntharg( pszCmdLine, i+1 )) == NULL )
+								if (( pszArg = ntharg( pszCmdLine, i+0x801 )) == NULL )
 									pszArg = NULLSTR;
 								sprintf( szLine, _TEXT("%c%s=%s"), bframe[ cv.bn ].uGosubStack+1, szLabel, pszArg );
 								add_variable( szLine );
@@ -1786,7 +1792,7 @@
 	LPTSTR pszLine, pszArg;
 	int nCondition;
 
-	if ( ntharg( pszCmdLine, 0x8001 ) == NULL ) {
+	if ( ntharg( pszCmdLine, (int)0x8001 ) == NULL ) {
 if_usage:
 		return ( Usage( fIff ? IFF_USAGE : IF_USAGE ));
 	}
@@ -2064,11 +2070,11 @@
 						nCondition = 1;
 
 				} else
-					nCondition = fstrcmp( pszArg, pszArg2, 1 );
+					nCondition = _stricmp( pszTest, EQC ) ? fstrcmp( pszArg, pszArg2, 1 ) : _fstrcmp( pszArg, pszArg2 );
 			}
 
 			// modify result based on equality test
-			if ( _stricmp( pszTest, EQ ) == 0 )
+			if ( _stricmp( pszTest, EQ ) == 0 || _stricmp( pszTest, EQC ) == 0 )
 				nCondition = ( nCondition == 0 );
 			else if ( _stricmp( pszTest, GT ) == 0 )
 				nCondition = ( nCondition > 0 );
@@ -2406,7 +2412,8 @@
 			} else if ( c == MIDDLE_MOUSE_BUTTON ) {
 				c = 0x1F2;
 				break;
-			}
+			} else if ( c == WHEEL_UP || c == WHEEL_DOWN )
+				continue;
 
 			// if printable character, display it
 			if ((( nEditFlag & EDIT_PASSWORD ) == 0 ) && ( c >= 32 ) && ( c < FBIT ))
@@ -2712,7 +2719,7 @@
 	int nRow = 0, nColumn = 0;
 
 	// make sure row & column are displayable on the current screen
-	ntharg( pszCmdLine, 0x8002 );
+	ntharg( pszCmdLine, (int)0x8002 );
 	pszText = gpNthptr;
 	if (( pszText != NULL ) && ( GetCursorRange( pszCmdLine, &nRow, &nColumn ) == 0 ))
 		nAttribute = GetColors( pszText, 0 );
@@ -2921,9 +2928,9 @@
 	if (( pszCmdLine ) && ( *pszCmdLine )) {
 
 		// collapse starting at a particular argument
-		if ( *pszCmdLine == _TEXT('/') ) {
+		if ( *pszCmdLine == gpIniptr->SwChr ) {
 
-			nShift = atoi( pszCmdLine + 1 ) + bframe[aGlobals.bn].Argv_Offset;
+			nShift = atoi( pszCmdLine + 1 ) + bframe[ cv.bn ].Argv_Offset;
 			for ( i = 1; ( bframe[ cv.bn ].Argv[i] != NULL ) ; i++ )
 				;
 			if (( i <= nShift ) || ( nShift < 0 ))
diff -Nu d:7.501/batcomp SOURCES/batcomp
--- d:7.501/batcomp	2003-01-09 20:42:54 +0200
+++ SOURCES/batcomp	2008-11-05 08:57:04 +0200
@@ -10,18 +10,16 @@
 OBJ=DOS_D
 !ENDIF
 
-CFLAGS=/c /D$(LANGUAGE) /Fo$(OBJ)\ /Lp /AM /J /Gs /Os /W3 /Zp1
+CFLAGS=/c /nologo /D__4DOS /D$(LANGUAGE) /Fo$(OBJ)\ /AM /J /Ocs /Gs /W3 /Zp1
+
+LINKCMD=link /B /NOE /ON:N batcomp+strmenc;
 
-!IF "$(LANGUAGE)" == "ENGLISH"
-ALL : batcomp.exe
-!ELSE
 ALL : $(OBJ)\batcomp.exe
-!ENDIF
 
 $(OBJ)\batcomp.obj : batcomp.c batcomp.h
 	cl $(CFLAGS) batcomp.c
 
-batcomp.exe : \
-	$(OBJ)\batcomp.obj
+$(OBJ)\batcomp.exe : \
+	$(OBJ)\batcomp.obj $(OBJ)\strmenc.obj
 !INCLUDE DOLINK.MAK        
 
diff -Nu d:7.501/build.h SOURCES/build.h
--- d:7.501/build.h	2006-11-12 16:00:50 +0200
+++ SOURCES/build.h	2009-02-26 11:09:34 +0200
@@ -26,4 +26,4 @@
 //  SOFTWARE.
 
 
-#define VER_BUILD 132
+#define VER_BUILD 200
diff -Nu d:7.501/cmds.c SOURCES/cmds.c
--- d:7.501/cmds.c	2006-11-12 16:00:50 +0200
+++ SOURCES/cmds.c	2009-02-26 15:52:02 +0200
@@ -75,9 +75,11 @@
 	_TEXT("CDD"), Cdd_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_SET_ERRORLEVEL | CMD_BACKSLASH_OK | CMD_HELP | CMD_PERIOD_OK ),
 	_TEXT("CHCP"), Chcp_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_SET_ERRORLEVEL | CMD_HELP),
 	_TEXT("CHDIR"), Cd_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_SET_ERRORLEVEL | CMD_BACKSLASH_OK | CMD_HELP | CMD_PERIOD_OK ),
+	_TEXT("CLOSETRAY"), Closetray_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_HELP),
 	_TEXT("CLS"), Cls_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_HELP),
 	_TEXT("COLOR"), Color_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_SET_ERRORLEVEL | CMD_HELP),
 	_TEXT("COPY"), Copy_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_CLOSE_BATCH | CMD_RESET_DISKS | CMD_SET_ERRORLEVEL | CMD_BACKSLASH_OK | CMD_HELP  | CMD_PERIOD_OK ),
+	_TEXT("COUNTRY"), Country_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_SET_ERRORLEVEL | CMD_HELP),
 	"CTTY", Ctty_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_HELP),
 	_TEXT("DATE"), Date_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_SET_ERRORLEVEL | CMD_HELP),
 	_TEXT("DEFAULT"),  Case_Cmd, CMD_ONLY_BATCH, 
@@ -95,6 +97,7 @@
 	_TEXT("ECHOERR"), EchoErr_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_BACKSLASH_OK  | CMD_PERIOD_OK ),
 	_TEXT("ECHOS"), Echos_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES  | CMD_PERIOD_OK ),
 	_TEXT("ECHOSERR"), EchosErr_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES  | CMD_PERIOD_OK ),
+	_TEXT("EJECTMEDIA"), Ejectmedia_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_HELP),
 	_TEXT("ENDLOCAL"), Endlocal_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_ONLY_BATCH),
 	_TEXT("ENDSWITCH"),  Remark_Cmd, CMD_ONLY_BATCH, 
 	_TEXT("ERASE"), Del_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_CLOSE_BATCH | CMD_RESET_DISKS | CMD_SET_ERRORLEVEL | CMD_BACKSLASH_OK | CMD_HELP  | CMD_PERIOD_OK ),
@@ -111,6 +114,7 @@
 	_TEXT("HEAD"), Head_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_CLOSE_BATCH | CMD_HELP),
 	_TEXT("HELP"), Help_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_HELP),
 	_TEXT("HISTORY"), History_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_CLOSE_BATCH | CMD_HELP),
+	_TEXT("IDLE"), Idle_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_HELP),
 	_TEXT("IF"), If_Cmd, CMD_GROUPS,
 	_TEXT("IFF"), Iff_Cmd, CMD_GROUPS,
 	_TEXT("INKEY"), Inkey_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES ),
@@ -148,6 +152,7 @@
 	_TEXT("SELECT"), Select_Cmd,CMD_GROUPS | CMD_HELP,
 	_TEXT("SET"), Set_Cmd, ( CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES ),
 	_TEXT("SETDOS"), Setdos_Cmd, (CMD_EXPAND_VARS | CMD_STRIP_QUOTES | CMD_EXPAND_REDIR),
+	_TEXT("SETERROR"), Seterror_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_BACKSLASH_OK),
 	_TEXT("SETLOCAL"), Setlocal_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_ONLY_BATCH | CMD_SET_ERRORLEVEL | CMD_HELP),
 	_TEXT("SHIFT"), Shift_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_ONLY_BATCH | CMD_HELP),
 	_TEXT("START"), Start_Cmd, (CMD_EXPAND_VARS | CMD_STRIP_QUOTES | CMD_CLOSE_BATCH | CMD_PERIOD_OK ),
@@ -158,7 +163,9 @@
 	_TEXT("TEXT"), Battext_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_ONLY_BATCH ),
 	_TEXT("TIME"), Time_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_SET_ERRORLEVEL | CMD_HELP),
 	_TEXT("TIMER"), Timer_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_HELP),
+	_TEXT("TITLE"), Title_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_BACKSLASH_OK),
 	_TEXT("TOUCH"), Touch_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_HELP | CMD_PERIOD_OK ),
+	_TEXT("TRANSIENT"), Transient_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_SET_ERRORLEVEL | CMD_HELP | CMD_ONLY_BATCH),
 	_TEXT("TREE"), Tree_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_HELP | CMD_PERIOD_OK ),
 	_TEXT("TRUENAME"), Truename_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_BACKSLASH_OK | CMD_HELP),
 	_TEXT("TYPE"), Type_Cmd, (CMD_EXPAND_VARS | CMD_EXPAND_REDIR | CMD_STRIP_QUOTES | CMD_SET_ERRORLEVEL | CMD_CLOSE_BATCH | CMD_BACKSLASH_OK | CMD_HELP),
diff -Nu d:7.501/compdrv.asm SOURCES/compdrv.asm
--- d:7.501/compdrv.asm	2006-11-12 16:00:50 +0200
+++ SOURCES/compdrv.asm	2008-12-26 09:47:44 +0200
@@ -304,7 +304,7 @@
 	endif
 	;
 	;
-DIRCMDS_TEXT	segment	word public 'CODE'	;start code segment
+SCREENIO_TEXT	segment	word public 'CODE'	;start code segment
 	;
 	assume	cs:@curseg, ds:DGROUP, es:nothing, ss:nothing
 	;
diff -Nu d:7.501/cpuspeed.asm SOURCES/cpuspeed.asm
--- d:7.501/cpuspeed.asm	1970-01-01 02:00:00 +0200
+++ SOURCES/cpuspeed.asm	2008-12-22 21:09:36 +0200
@@ -0,0 +1,184 @@
+; -----------------------------------------------------------------------------
+; CPUSPEED.ASM  CPU speed measurement routine for TMi0SDGL 2      Version 2.15
+;
+; Too-Much-In-One-So-Don't-Get-Lost(tm) Revision 2 CPU/FPU Detection Library
+; Copyright(c) 1996-2000 by B-coolWare.  Written by Bobby Z.
+; -----------------------------------------------------------------------------
+; This file contains Speed routine that plays part in CPU clock frequency
+; calculation. Algorithm was taken from Norton SysInfo as well as several
+; constants.
+
+        INCLUDE HEADER.ASH
+
+        PUBLIC  Speed
+
+; --- Windows detection and critical section handling
+
+IFNDEF  __32bit__
+
+isUnderWin      proc near
+        mov     ax,1600h
+        int     2Fh
+        or      al,al
+        jz      @@nowin
+        cmp     al,80h
+        jz      @@nowin
+        stc
+        ret
+@@nowin:
+        clc
+        ret
+isUnderWin      endp
+
+winStartCritical        proc near
+        push    ax
+        call    IsUnderWin
+        jnc     @@Q
+        mov     ax,1681h
+        int     2Fh
+@@Q:
+        pop     ax
+        ret
+winStartCritical        endp
+
+winEndCritical          proc near
+        push    ax
+        call    IsUnderWin
+        jnc     @@Q
+        mov     ax,1682h
+        int     2Fh
+@@Q:
+        pop     ax
+        ret
+winEndCritical          endp
+
+ENDIF
+
+; ------ Speed routine implementation
+
+IFDEF  __32bit__
+ Speed   PROC  DIST USES ebx ecx edx esi edi
+ELSE
+ Speed   PROC  DIST USES si di
+ LOCAL   Stage : Word           ; local variable to differ test stages
+ENDIF
+        mov     cx,2
+IFNDEF  __32bit__
+        mov     Stage,0
+        call    winStartCritical; enter Windows critical section
+                                ; IBM OS/2 doesn't provide a critical section
+                                ; mechanism, so you should set HW_TIMER = ON
+                                ; in DOS Box settings to get correct result.
+ENDIF
+@@1:
+        mov     speedShift,cx   ; initialize speedShift
+IFNDEF  __32bit__
+        push    Stage
+ELSE
+        push    0
+ENDIF
+        call    speedTest       ; do a code section 101 times
+        cmp     ax,1000h
+        jnb     @@2
+        mov     cx,speedShift
+IFDEF   __32bit__
+        shl     cx,3
+ELSE
+        shl     cx,1            ; repeat test with increasing values until
+        shl     cx,1            ; we get reasonable time value worth working
+        shl     cx,1            ; with
+ENDIF
+        jmp     @@1
+@@2:
+        push    ax
+        mov     cx,speedShift   ; now do the same code section 100 times less
+IFNDEF  __32bit__
+        mov     Stage,1
+        push    Stage
+ELSE
+        push    1
+ENDIF
+        call    speedTest
+IFNDEF  __32bit__
+        call    winEndCritical  ; exit Windows critical section
+ENDIF
+        pop     dx
+        sub     dx,ax           ; now we got time how long 100*shift instructions
+        xchg    ax,dx           ; were performed - knowing number of ticks it
+        ret                     ; takes for each CPU type we can compute the
+Speed   ENDP                    ; CPU clock frequency.
+
+speedTest       PROC    NEAR, Stage : Word
+
+        clr     dx
+        mov     si,0AAAAh
+        mov     bx,05555h
+        in      al,61h          ; initialize hardware timer
+        jmp     $+2
+        and     al,0FCh
+        out     61h,al
+        jmp     $+2
+        mov     al,0B4h
+        out     43h,al
+        jmp     $+2
+        clr     al
+        out     42h,al
+        jmp     $+2
+        out     42h,al
+        jmp     $+2
+        in      al,61h
+        mov     di,ax
+        or      al,01
+        cmp     Stage,0
+        jnz     @@2
+@@1:
+        cli
+        out     61h,al
+@@3:
+        REPT    101
+        mov     ax,si
+        div     bx
+        ENDM
+        dec     cx
+        jz      @@4
+        jmp     @@3
+@@2:
+        cli
+        out     61h,al
+@@5:
+        mov     ax,si
+        div     bx
+        dec     cx
+        jz      @@4
+        jmp     @@5
+
+@@4:
+        mov     ax,di           ; shut down timer and get results
+        out     61h,al
+        jmp     $+2
+        sti
+        in      al,42h
+        jmp     $+2
+        xchg    ah,al
+        in      al,42h
+        jmp     $+2
+        xchg    ah,al
+        neg     ax
+        push    ax
+        in      al,61h
+        jmp     $+2
+        and     al,0FDh
+        out     61h,al
+; fix the waveform back to default (suggested by Pascal Moulart)
+        mov     al,0B6h
+        out     43h,al
+        jmp     $+2
+        clr     al
+        out     42h,al
+        jmp     $+2
+        out     42h,al
+        pop     ax
+        ret
+speedTest       ENDP
+
+        END
diff -Nu d:7.501/cputype.c SOURCES/cputype.c
--- d:7.501/cputype.c	1970-01-01 02:00:00 +0200
+++ SOURCES/cputype.c	2008-12-29 11:05:42 +0200
@@ -0,0 +1,1071 @@
+/*****************************************************************************
+ * CPUTYPE.C    C/C++ TMi0SDGL main module                       Version 2.15
+ *
+ * Too-Much-in-0ne-So-Don't-Get-Lost(tm) CPU/FPU detection library.
+ * Copyright(c) 1996-2000 by B-coolWare.  Written by Bobby Z.
+ *****************************************************************************
+ * This file contains high-level detection routines                          */
+
+#define __LIB__         /* we're compiling with library version of header */
+#include "tmi0sdgl.h"
+#include <stdio.h>
+#ifdef __Win32__
+ #include <windows.h>
+#else
+ #include <stdlib.h>
+ #include <string.h>
+#endif
+
+byte lo(word value)
+{
+ return value & 0x00FF; /* clear high byte, just to be sure */
+}
+
+byte hi(word value)
+{
+ return value >> 8;
+}
+
+#ifdef __Win32__
+int __cdecl _sprintf( char _FAR *, const char _FAR *, ...);
+#endif
+
+int compare12( char * s )
+{
+ int register i;
+ for (i = 0; i < 12; i++)
+  if ((char)cpuid0[i] != s[i])
+   return 1;
+ return 0;
+}
+
+char * CyrixModel( void )
+/* distinguishes Cyrix CPU model based on DIR0/DIR1 contents */
+{
+ byte Family;
+ byte DIR0 = lo(getCyrixModel());
+ byte DIR1 = hi(getCyrixModel());
+ byte isTI = ((DIR1 & 0x80) != 0);
+ if(extFlags & efCPUIDSupport)
+  Family = (byte)((cpuid1 & 0x0F00) >> 8);
+ switch(DIR0) {
+  case 0:    return("Cyrix Cx486SLC");
+  case 1:    return("Cyrix Cx486DLC");
+  case 2:    return("Cyrix Cx486SLC2");
+  case 3:    return("Cyrix Cx486DLC2");
+  case 4:    return("Cyrix Cx486SRx");
+  case 5:    return("Cyrix Cx486DRx");
+  case 6:    return("Cyrix Cx486SRx2");
+  case 7:    return("Cyrix Cx486DRx2");
+  case 8:    return("Cyrix Cx486SRu");
+  case 9:    return("Cyrix Cx486DRu");
+  case 0x0A: return("Cyrix Cx486SRu2");
+  case 0x0B: return("Cyrix Cx486DRu2");
+  case 0x10: return("Cyrix Cx486S");
+  case 0x11: return("Cyrix Cx486S2");
+  case 0x12:
+  case 0x14:
+  case 0x16: return("Cyrix Cx486Se");
+  case 0x13:
+  case 0x15:
+  case 0x17: return("Cyrix Cx486S2e");
+  case 0x1A:
+             extFlags |= efHasFPUonChip;
+             if(isTI)
+              return("Texas Instruments Ti486DX");
+             return("Cyrix Cx486DX");
+  case 0x1B:
+             extFlags |= efHasFPUonChip;
+             if(isTI || (DIR1 == 0xB2))
+               return("Texas Instruments Ti486DX2");
+             return("Cyrix Cx486DX2");
+  case 0x1F:
+             extFlags |= efHasFPUonChip;
+             if(isTI)
+              return("Texas Instruments Ti486DX4");
+             return("Cyrix Cx486DX4");
+  case 0x28:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             return("Cyrix 5x86-S (clock x1 mode)");
+  case 0x29:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             return("Cyrix 5x86-S (clock x2 mode)");
+  case 0x2A:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             return("Cyrix 5x86-P (clock x1 mode)");
+  case 0x2B:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             return("Cyrix 5x86-P (clock x2 mode)");
+  case 0x2C:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             return("Cyrix 5x86-S (clock x4 mode)");
+  case 0x2D:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             return("Cyrix 5x86-S (clock x3 mode)");
+  case 0x2E:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             return("Cyrix 5x86-P (clock x4 mode)");
+  case 0x2F:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             return("Cyrix 5x86-P (clock x3 mode)");
+  case 0x20:
+  case 0x21:
+  case 0x22:
+  case 0x23:
+  case 0x24:
+  case 0x25:
+  case 0x26:
+  case 0x27:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             return("Cyrix 5x86 (M1sc)");
+  case 0x30:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             if(DIR1 <= 0x21)
+              return("Cyrix 6x86-S (clock x1 mode)");
+             else
+              return("Cyrix 6x86L-S (clock x1 mode)");
+  case 0x31:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             if(DIR1 <= 0x21)
+              return("Cyrix 6x86-S (clock x2 mode)");
+             else
+              return("Cyrix 6x86L-S (clock x2 mode)");
+  case 0x32:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             if(DIR1 <= 0x21)
+              return("Cyrix 6x86-P (clock x1 mode)");
+             else
+              return("Cyrix 6x86L-P (clock x1 mode)");
+  case 0x33:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             if(DIR1 <= 0x21)
+              return("Cyrix 6x86-P (clock x2 mode)");
+             else
+              return("Cyrix 6x86L-P (clock x2 mode)");
+  case 0x34:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             if(DIR1 <= 0x21)
+              return("Cyrix 6x86-S (clock x4 mode)");
+             else
+              return("Cyrix 6x86L-S (clock x4 mode)");
+  case 0x35:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             if(DIR1 <= 0x21)
+              return("Cyrix 6x86-S (clock x3 mode)");
+             else
+              return("Cyrix 6x86L-S (clock x3 mode)");
+  case 0x36:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             if(DIR1 <= 0x21)
+              return("Cyrix 6x86-P (clock x4 mode)");
+             else
+              return("Cyrix 6x86L-P (clock x4 mode)");
+  case 0x37:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             if(DIR1 <= 0x21)
+              return("Cyrix 6x86-P (clock x3 mode)");
+             else
+              return("Cyrix 6x86L-P (clock x3 mode)");
+  case 0x38:
+  case 0x39:
+  case 0x3A:
+  case 0x3B:
+  case 0x3C:
+  case 0x3D:
+  case 0x3E:
+  case 0x3F:
+             cpu = CxM1;
+             extFlags |= efHasFPUonChip;
+             return("Cyrix 6x86 (M1)");
+  case 0x40:
+  case 0x41:
+  case 0x42:
+  case 0x43:
+  case 0x44:
+  case 0x45:
+  case 0x46:
+  case 0x47:
+            switch(Family) {
+            case 4:
+                   switch(DIR0) {
+                    case 0x41:
+                              cpu = CxM1;
+                              extFlags |= efHasFPUonChip;
+                              return("Cyrix MediaGX (clock x3 mode)");
+                    case 0x45:
+                    case 0x47:
+                              cpu = CxM1;
+                              extFlags |= efHasFPUonChip;
+                              return("Cyrix MediaGX (clock x3 mode)");
+                    case 0x44:
+                    case 0x46:
+                              cpu = CxM1;
+                              extFlags |= efHasFPUonChip;
+                              return("Cyrix MediaGX (clock x4 mode)");
+                    default:
+                              cpu = CxM1;
+                              extFlags |= efHasFPUonChip;
+                              return("Cyrix MediaGX");
+                   }
+            case 5:
+                   switch(DIR0) {
+                    case 0x40:
+                    case 0x42:
+                              cpu = CxM1;
+                              extFlags |= efHasFPUonChip;
+                              return("Cyrix GXm (clock x4 mode)");
+                    case 0x41:
+                    case 0x43:
+                              cpu = CxM1;
+                              extFlags |= efHasFPUonChip;
+                              return("Cyrix GXm (clock x6 mode)");
+                    case 0x44:
+                    case 0x46:
+                              cpu = CxM1;
+                              extFlags |= efHasFPUonChip;
+                              return("Cyrix GXm (clock x7 mode)");
+                    case 0x45:
+                              cpu = CxM1;
+                              extFlags |= efHasFPUonChip;
+                              return("Cyrix GXm (clock x5 mode)");
+                    case 0x47:
+                              cpu = CxM1;
+                              extFlags |= efHasFPUonChip;
+                              return("Cyrix GXm (clock x8 mode)");
+                    default:
+                              cpu = CxM1;
+                              extFlags |= efHasFPUonChip;
+                              return("Cyrix GXm");
+                   }
+            }
+  case 0x50:
+             cpu = CxM2;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix 6x86MX-S (clock x1.5 mode)");
+  case 0x51:
+             cpu = CxM2;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix 6x86MX-S (clock x2.0 mode)");
+  case 0x52:
+             cpu = CxM2;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix 6x86MX-S (clock x2.5 mode)");
+  case 0x53:
+             cpu = CxM2;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix 6x86MX-S (clock x3.0 mode)");
+  case 0x54:
+             cpu = CxM2;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix 6x86MX-S (clock x3.5 mode)");
+  case 0x55:
+             cpu = CxM2;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix 6x86MX-S (clock x4.0 mode)");
+  case 0x56:
+             cpu = CxM2;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix 6x86MX-S (clock x4.5 mode)");
+  case 0x57:
+             cpu = CxM2;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix 6x86MX-S (clock x5.0 mode)");
+  case 0x58:
+             cpu = CxM2;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix 6x86MX-P (clock x1.5 mode)");
+  case 0x59:
+             cpu = CxM2;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix 6x86MX-P (clock x2.0 mode)");
+  case 0x5A:
+             cpu = CxM2;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix 6x86MX-P (clock x2.5 mode)");
+  case 0x5B:
+             cpu = CxM2;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix 6x86MX-P (clock x3.0 mode)");
+  case 0x5C:
+             cpu = CxM2;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix 6x86MX-P (clock x3.5 mode)");
+  case 0x5D:
+             cpu = CxM2;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix 6x86MX-P (clock x4.0 mode)");
+  case 0x5E:
+             cpu = CxM2;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix 6x86MX-P (clock x4.5 mode)");
+  case 0x5F:
+             cpu = CxM2;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix 6x86MX-P (clock x5.0 mode)");
+  case 0x80:
+             cpu = CxIII;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix III");
+  case 0x81:
+             cpu = CxIII;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix III (clock x3.0 mode)");
+  case 0x82:
+             cpu = CxIII;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix III (clock x4.0 mode)");
+  case 0x83:
+             cpu = CxIII;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix III (clock x5.0 mode)");
+  case 0x84:
+             cpu = CxIII;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix III (clock x6.0 mode)");
+  case 0x85:
+             cpu = CxIII;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix III (clock x3.5 mode)");
+  case 0x86:
+             cpu = CxIII;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix III (clock x4.5 mode)");
+  case 0x87:
+             cpu = CxIII;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix III (clock x5.5 mode)");
+  case 0x88:
+             cpu = CxIII;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix III (clock x6.0 mode)");
+  case 0x89:
+             cpu = CxIII;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix III (clock x7.0 mode)");
+  case 0x8A:
+             cpu = CxIII;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix III (clock x6.5 mode)");
+  case 0x8B:
+             cpu = CxIII;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix III (clock x7.5 mode)");
+  case 0x8C:
+  case 0x8D:
+  case 0x8E:
+  case 0x8F:
+             cpu = CxIII;
+             extFlags |= efHasFPUonChip;
+             return("VIA Cyrix III");
+  case 0xEF: return("Cyrix Cx486S_a"); /* this id is software-generated */
+  case 0xFD:
+             extFlags |= efHasFPUonChip;
+             return("Cyrix OverDrive");
+  case 0xFE: return("Texas Instruments Ti486SXL");
+  default:   return("Cyrix/TI 486-class processor");
+ }
+}
+
+static char s[50];
+
+char * _call cpu_Type ( void )
+ {
+  cpuid1Layout cpuid1_;
+
+  if(cpu==0xFF)
+   getCPUType();
+  switch(cpu) {
+   case i80386SX: if(cpu_Speed() > 35)
+                   cpu=Am386SX;
+                  break;
+   case i80386DX: if(cpu_Speed() > 35)
+                   cpu=Am386DX;
+  } /* switch */
+  if(extFlags & efCPUIDSupport)
+   {
+    cpuid1_.Extra = (byte)((cpuid1 & 0xF000) >> 12);
+    cpuid1_.Family= (byte)((cpuid1 & 0x0F00) >> 8);
+    cpuid1_.Model = (byte)((cpuid1 & 0x00F0) >> 4);
+    cpuid1_.Step  = (byte)(cpuid1 & 0x000F);
+    switch(cpuid1_.Family) {
+     case 4:
+            if(!compare12("UMC UMC UMC ")) /* UMC U5-x 486s */
+             switch(cpuid1_.Model) {
+              case 1:
+                     cpu=umcU5S;
+                     break;
+              case 2:
+                     cpu=umcU5D;
+                     break;
+              case 3:
+                     cpu=umcU5D;
+                     return("UMC U486DX2");
+              case 5:
+                     cpu=umcU5S;
+                     return("UMC U486SX2");
+              default:
+                     cpu=umcU5S;
+                     return("Undistinguished UMC U486");
+              } /* switch */
+             else
+             if(!compare12("GenuineIntel")) /* Intel i486s */
+              {
+              if(extFlags & efHasFPUonChip)
+               cpu = i486DX;
+              switch(cpuid1_.Model) {
+               case 0: return("Intel i486DX");
+               case 1: return("Intel i486DX50");
+               case 2: if(i486DX == cpu)
+                        return("Intel i486DX2");
+                       else
+                        return("Intel i486SX");
+               case 3: if ((cpuid1_.Extra & 3) == 1)
+                        return("Intel i486DX OverDrive");
+                       else
+                        return("Intel i486DX");
+               case 4: return("Intel i486SL");
+               case 5: return("Intel i486SX2");
+               case 7: return("Intel i486DX2WB");
+               case 8: return("Intel i486DX4");
+               case 9: return("Intel i486DX4WB");
+               default: if((cpuid1_.Extra & 3) == 1)
+                         return("Intel i486 OverDrive");
+                        else
+                         return("Intel i486 (undistinguished model)");
+               } /* switch */
+              }
+             else
+             if(!compare12("AuthenticAMD")) /* AMD Enhanced Am486s */
+              {
+              cpu = Am486;
+              if (extFlags & efHasFPUonChip)
+               cpu = Am486DX;
+              switch(cpuid1_.Model) {
+               case 3: return("AMD Enhanced Am486DX2");
+               case 7: return("AMD Enhanced Am486DX2+");
+               case 8: return("AMD Enhanced Am486DX4");
+               case 9: return("AMD Enhanced Am486DX4+");
+               case 0x0A: if ((extFlags & efHasFPUonChip) == 0)
+                           return("AMD Elan SC400 Microcontroller");
+                          else
+                           return("AMD Enhanced Am486DX (undistinguished model)");
+               case 0x0E: return("AMD X5 (Am5x86)");
+               case 0x0F: return("AMD X5+ (Am5x86+)");
+               default: return("AMD Enhanced Am486DX (undistinguished model)");
+               }
+              }
+             else
+              {
+              #ifdef __Win32__
+               _sprintf(s,"Unknown 486-class processor (Make: %s)",cpuid0);
+              #else
+               sprintf(s,"Unknown 486-class processor (Make: %s)",cpuid0);
+              #endif
+               return s;
+              }
+             break;
+     case 5:
+             if(!compare12("RiseRiseRise"))
+             {
+              cpu = Rise_mP6;
+              switch(cpuid1_.Model)
+              {
+                case 0: return("Rise iDragon(tm) mP6(tm)");
+                case 2: return("Rise iDragon(tm) mP6(tm) Tiger (0.18u)");
+                case 8: return("Rise iDragon(tm) mP6(tm) II");
+                case 9: return("Rise iDragon(tm) mP6(tm) II Tiger (0.18u)");
+               default: return("Rise iDragon(tm) mP6(tm) (undistinguished)");
+              }
+             }
+             else
+             if(!compare12("CyrixInstead"))
+              return(CyrixModel());
+             else
+             if((!compare12("CentaurHauls")) || (extFlags & efCentaurLevel))
+              {
+               cpu = WinChipC6;
+               switch(cpuid1_.Model) {
+                case 4 : return("IDT/Centaur Tech. WinChip C6'");
+                case 8 : cpu = WinChip2;
+                         switch(cpuid1_.Step) {
+                          case 7:
+                          case 8:
+                          case 9: return("IDT/Centaur Tech. WinChip 2A");
+                          default:
+                                  return("IDT/Centaur Tech. WinChip 2");
+                         }
+                case 9 : cpu = WinChip3;
+                         return("IDT/Centaur Tech. WinChip 3");
+                default: return("IDT/Centaur Tech. WinChip (unknown model)");
+               }
+              }
+             else
+             if(!compare12("GenuineIntel"))
+              {
+              cpu = iP54C;
+              switch(cpuid1_.Model) {
+               case 0: cpu = iPentium;
+                       return("Intel Pentium (A-Step)");
+               case 1: cpu = iPentium;
+                       return("Intel Pentium");
+               case 2: if (cpuFeatures & 0x00800000)
+                        return("Intel Pentium with MMX");
+                       return("Intel Pentium");
+               case 3: return("Intel Pentium OverDrive");
+               case 4: if ((cpuid1_.Extra & 3) == 1)
+                        return("Intel Pentium OverDrive for Pentium 3.3v");
+                       else
+                        return("Intel Pentium with MMX");
+               case 5: return("Intel Pentium OverDrive for i486DX4");
+               case 6: return("Intel Pentium OverDrive for Pentium 5v");
+               case 7: if (cpuFeatures & 0x00800000)
+                        return("Intel Pentium with MMX");
+                       return("Intel Pentium (> 133MHz)");
+               case 8: return("SL28x Mobile Pentium with MMX");
+               default:
+                       if ((cpuid1_.Extra & 3) == 1)
+                        return("Intel Pentium OverDrive");
+                       else
+                       if ((cpuid1_.Extra & 3) == 2)
+                        return("Auxiliary Intel Pentium (SMP)");
+                       else
+                        return("Intel Pentium");
+               } /* switch */
+              } /* if */
+             else
+             if(!compare12("NexGenDriven")) /* NexGen is now part of AMD family */
+              {
+              cpu = Nx586;
+              switch(cpuid1_.Model) {
+               case 0: return("NexGen Nx586 or Nx586FPU");
+               default: return("NexGen 586-class processor (undistinguished)");
+               }
+              }
+             else
+             if(!compare12("AuthenticAMD"))
+              {
+              cpu = AmdK5;
+              switch(cpuid1_.Model) {
+               case 0: return("AMD SSA/5 (K5)");
+               case 1: return("AMD 5k86 (K5)");
+               case 2:
+               case 3: cpu = AmdK5_2;
+                       return("AMD 5k86 (K5)");
+               case 6:
+               case 7:
+                       cpu = AmdK6;
+                       break;
+               case 8:
+                       cpu = AmdK6;
+                       return("AMD K6-2");
+               case 9:
+                       cpu = AmdK6;
+                       return("AMD K6-III");
+               case 0xD:
+                       cpu = AmdK6;
+                       return("AMD K6-III (0.18u)");
+               default: return("AMD 586-class processor (undistinguished)");
+               }
+              }
+             else
+              {
+              #ifdef __Win32__
+               _sprintf(s,"Unknown 586-class processor (Make: %s)",cpuid0);
+              #else
+               sprintf(s,"Unknown 586-class processor (Make: %s)",cpuid0);
+              #endif
+               return s;
+              }
+     case 6:
+             if(!compare12("GenuineIntel"))
+             {
+             cpu = iPentiumPro;
+             switch(cpuid1_.Model) {
+              case 0 : return("Intel Pentium Pro (P6) A-Step");
+              case 1 : return("Intel Pentium Pro (P6)");
+              case 3 : if(cpuid1_.Extra == 1)
+                        return("Intel Pentium Pro OverDrive");
+                       else
+                        return("Intel Pentium II");
+              case 4 : return("Intel iP55CT (OverDrive for iP54C socket)");
+              case 5 : switch( getL2CacheDesc() )
+                       {
+                        case cdNoCache:
+                        case cd128k   : return("Intel Celeron");
+                        case cd256k   : return("Intel Pentium IIe");
+                        case cd512k   : if (3 == cpuBrand)
+                                         return("Intel Pentium II Xeon");
+                                        else
+                                         return("Intel Pentium II");
+
+                        case cd1M     :
+                        case cd2M     : return("Intel Pentium II Xeon");
+                        default       : if (3 == cpuBrand)
+                                         return("Intel Pentium II Xeon");
+                                        else
+                                         return("Intel Pentium II");
+                       }
+              case 6 : switch( getL2CacheDesc() )
+                       {
+                        case cdNoCache:
+                        case cd128k   : return("Intel CeleronA");
+                        case cd256k   : return("Intel Pentium IIe");
+                        default       : return("Intel Pentium II");
+                       }
+              case 7 : if (!cpuBrand)
+                        switch( getL2CacheDesc() )
+                        {
+                         case cd128k   : return("Intel Celeron");
+                         case cd512k   : return("Intel Pentium III");
+                         case cd1M     :
+                         case cd2M     : return("Intel Pentium III Xeon");
+                         default       : return("Intel Pentium III");
+                        }
+                       else
+                        switch( cpuBrand )
+                        {
+                         case 1  : return("Intel Celeron");
+                         case 2  : return("Intel Pentium III");
+                         case 3  : return("Intel Pentium III Xeon");
+                         default : return("Intel Pentium III");
+                        }
+              case 8 : if (!cpuBrand)
+                        switch( getL2CacheDesc() )
+                        {
+                         case cd128k   : return("Intel Celeron");
+                         case cd512k   : return("Intel Pentium III E");
+                         case cd1M     :
+                         case cd2M     : return("Intel Pentium III Xeon E");
+                         default       : return("Intel Pentium III E");
+                        }
+                       else
+                        switch( cpuBrand )
+                        {
+                         case 1  : return("Intel Celeron");
+                         case 2  : return("Intel Pentium III E");
+                         case 3  : return("Intel Pentium III Xeon E");
+                         default : return("Intel Pentium III E");
+                        }
+              case 0x0A:
+                        return("Intel Pentium III Xeon");
+              default:
+                        return("Intel Pentium Pro (undistinguished)");
+              } /* switch */
+             }
+             else
+             if(!compare12("CyrixInstead"))
+             {
+              switch( cpuid1_.Model )
+               {
+                case 0  :cpu = CxM2;
+                         return(CyrixModel());
+                case 5  :cpu = CxIII;
+                         return(CyrixModel());
+                default :cpu = CxM2;
+                         return(CyrixModel());
+               }
+             }
+             else
+             if(!compare12("AuthenticAMD"))
+             {
+              cpu = AmdK7;
+              switch(cpuid1_.Model) {
+               case 1  : return("AMD Athlon(tm)");
+               case 2  : return("AMD Athlon(tm) (0.18u)");
+               case 3  : return("AMD Duron(tm)");
+               case 4  : return("AMD Athlon(tm) (Thunderbird)");
+               default : return("AMD Athlon(tm) (undistinguished model)");
+              }
+
+             }
+             else
+              {
+              #ifdef __Win32__
+               _sprintf(s,"Unknown 686-class processor (Make: %s)",cpuid0);
+              #else
+               sprintf(s,"Unknown 686-class processor (Make: %s)",cpuid0);
+              #endif
+               return s;
+              }
+     case 7:
+             if (!compare12("GenuineIntel"))
+             {
+              cpu = iP7;
+              break;
+             }
+             else
+              {
+              #ifdef __Win32__
+               _sprintf(s,"Unknown 786-class processor (Make: %s)",cpuid0);
+              #else
+               sprintf(s,"Unknown 786-class processor (Make: %s)",cpuid0);
+              #endif
+               return s;
+              }
+     case 8:
+             cpu = iP8;
+             break;
+     } /* switch */
+   }
+  switch(cpu) {
+#ifndef __DPMI__
+ #ifndef __Windows__
+  #ifndef __Win32__
+ /* Under DPMI host or Windows it is not necessary to check for CPUs lower than
+    80286 - neither of them works on these CPUs. */
+   case i8088      : return("Intel 8088");
+   case i8086      : return("Intel 8086");
+   case i80C88     : return("Intel 80C88");
+   case i80C86     : return("Intel 80C86");
+   case i80188     : return("Intel 80188");
+   case i80186     : return("Intel 80186");
+   case necV20     : return("NEC V20");
+   case necV30     : return("NEC V30");
+  #endif
+ #endif
+#endif
+   case i80286     : return("Intel 80286");
+   case i80386SX   : return("Intel 80386SX");
+   case i80386DX   : return("Intel 80386DX");
+   case i386SL     : return("Intel i386SL");
+   case i376       : return("Intel i376");
+   case ibm386SLC  : return("IBM 386SLC");
+   case Am386SX    : return("AMD Am386SX");
+   case Am386DX    : return("AMD Am386DX");
+   case CT38600    : return("C&T 38600");
+   case CT38600SX  : return("C&T 38600SX");
+   case RapidCAD   : return("Intel RapidCAD");
+   case i486SX     : return("Intel i486SX");
+   case i486DX     : return("Intel i486DX or i487SX");
+   case i486SL     : return("Intel i486SL");
+   case ibm486SLC  : return("IBM 486SLC");
+   case ibm486SLC2 : return("IBM 486SLC2");
+   case ibm486BL3  : return("IBM 486BLX3 (Blue Lightning)");
+   case Cx486      : return(CyrixModel());
+   case umcU5S     : return("UMC U5S-Super33");
+   case umcU5D     : return("UMC U5SD");
+   case Am486      : return("AMD Am486SX");
+   case Am486DX    : return("AMD Am486DX");
+   case CxM1       :
+   case CxM2       : return(CyrixModel());
+   case AmdK5      :
+   case AmdK5_2    : return("AMD K5");
+   case AmdK6      : return("AMD K6");
+   case Nx586      : return("NexGen Nx586");
+   case iPentiumPro: return("Intel Pentium Pro");
+   case iP7        : return("Intel Itanium");
+   case iP8        : return("Intel P8");
+   case AmdK7      : return("AMD Athlon(tm)");
+   case WinChipC6  : return("IDT/Centaur WinChip C6");
+   case WinChip2   : return("IDT/Centaur WinChip 2");
+   case WinChip3   : return("IDT/Centaur WinChip 3");
+   case Rise_mP6   : return("Rise mP6");
+   default         : return("Unknown CPU");
+   } /* switch */
+ }
+
+char * _call fpu_Type( void )
+ {
+  if(fpu==0xFF)
+   {
+    cpu_Type();
+    getFPUType();
+   }
+  if(extFlags & efHasFPUonChip)
+   fpu = fpuInternal;
+  switch(fpu) {
+  case fpuInternal: return("Internal");
+  case fpuNone:     return("None");
+  case i8087:       return("Intel 8087");
+  case i80287:      return("Intel 80287");
+  case i80287XL:    return("Intel 80287XL");
+  case i80387:      return("Intel 80387");
+  case rCAD:        return("Intel RapidCAD");
+  case cx287:       return("Cyrix 82x87");
+  case cx387:       return("Cyrix 83x87");
+  case cx487:       return("Cyrix 84x87");
+  case cxEMC87:     return("Cyrix EMC87");
+  case iit287:      return("IIT 2C87");
+  case iit387:      return("IIT 3C87");
+  case iit487:      return("IIT 4C87");
+  case iit487DLC:   return("IIT 4C87DLC");
+  case ct387:       return("C&T 38700");
+  case ulsi387:     return("ULSI 83x87");
+  case ulsi487:     return("ULSI 84x87");
+  case i487sx:      return("Intel i487SX (integrated)");
+  case Nx587:       return("NexGen Nx587");
+  case i387SLMobile:return("Intel i387SL Mobile");
+  default:          return("Unknown FPU");
+  }
+ }
+
+#if !defined __No_87Speed__ || !defined __No_P5Speed__
+int UnderNT( void )
+{
+#ifdef __Win32__
+ OSVERSIONINFO vi;
+ vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
+ GetVersionEx(&vi);
+ return (vi.dwPlatformId == VER_PLATFORM_WIN32_NT);
+
+#else
+/* return (!strcmp(getenv("OS"),"Windows_NT")); */
+ return (!strcmp(getenv("OS"),"Windows_NT"));
+#endif
+}
+#endif
+
+#define EOA 0
+
+#define Tolerance 4
+
+static int Clone486Norm[] = { 33, 40, 50, 66, 80, 75, 100, 120, 150, 166, 188, 200, 233, EOA };
+static int CloneP5Norm[]  = { 75, 90, 100, 120, 133, 150, 166, 185, 200, 233, 266, 300,
+                              333, 350, 366, 380, 400, 450, 500, 533, EOA };
+static int CloneP6Norm[]  = { 300, 333, 350, 366, 380, 400, 450, 500, 550, 600, 650,
+                              700, 750, 800, 833, 866, 933, 966, 1000, EOA};
+static int CyrixNorm[]    = { 80, 100, 110, 120, 125, 133, 150, 166, 185, 200,
+                              225, 233, 250, 300, 333, 350, 366, 400, 433, 466,
+                              500, 533, EOA };
+static int i486Norm[]     = { 25, 33, 40, 50, 66, 75, 80, 100, EOA };
+static int iP5Norm[]      = { 60, 66, 75, 90, 100, 120, 133, 150, 166, 185,
+                              200, 233, 266, 300, EOA };
+static int iP6Norm[]      = { 133, 150, 167, 185, 200, 220, 240, 266, 300,
+                              333, 350, 366, 400, 450, 500, 550, 600, 667,
+                              700, 733, 750, 800, 833, 866, 933, 966, 1000,
+                              EOA };
+static int WinChipNorm[]  = { 180, 200, 225, 233, 240, 250, 266, 300, 333,
+                              350, 366, 380, 400, EOA };
+static int RiseNorm[]     = { 266, 300, 333, EOA };
+
+
+int NormFreq( int freq, int fTable[] )
+{
+ int ptr = 0;
+ while( EOA != fTable[ptr] )
+  {
+   if( fTable[ptr] + Tolerance >= freq )
+    if( (0 < ptr) && (10 < (fTable[ptr] - freq)) )
+     return( fTable[ptr-1] );
+    else
+     return( fTable[ptr] );
+   ++ptr;
+  }
+ return freq;
+}
+
+#ifndef __No_87Speed__
+int _call ncpu_Speed( void )
+{
+ word spd;
+ if(cpu == 0xFF)
+   cpu_Type();
+ spd = cpu_Speed();
+ switch (cpu) {
+  case iPentium   :
+  case iP54C      : return NormFreq(spd, iP5Norm);
+  case iP7        :
+  case iP8        :
+  case iPentiumPro: return NormFreq(spd, iP6Norm);
+  case i486SX     :
+  case i486DX     :
+  case i486SL     : return NormFreq(spd, i486Norm);
+  case ibm486SLC  :
+  case ibm486SLC2 :
+  case ibm486BL3  :
+  case Cx486      :
+  case Am486      :
+  case Am486DX    :
+  case umcU5S     :
+  case umcU5D     : return NormFreq(spd, Clone486Norm);
+  case CxM1       :
+  case CxM2       :
+  case CxIII      : return NormFreq(spd, CyrixNorm);
+  case AmdK5      :
+  case AmdK5_2    :
+  case AmdK6      : return NormFreq(spd, CloneP5Norm);
+  case AmdK7      : return NormFreq(spd, CloneP6Norm);
+  case WinChipC6  :
+  case WinChip2   :
+  case WinChip3   : return NormFreq(spd, WinChipNorm);
+  case Rise_mP6   : return NormFreq(spd, RiseNorm);
+  default         : return spd;
+  }
+}
+#endif
+
+/*
+int AmdCPU( void )
+{
+ return ( (AmdK5 == cpu) || (AmdK6 == cpu) || (AmdK5_2 == cpu) || (AmdK7 == cpu) );
+}
+*/
+
+int _call cpu_Speed( void )
+ {
+#ifdef __NewSpeedCalc__
+ unsigned int ms = 0xFFFF, sps = 0, i, j;
+#endif
+ int f1, f2, f3;
+
+ if(cpu == 0xFF)
+   cpu_Type();
+
+#ifndef __No_P5Speed__
+ if((extFlags & efTSCSupport)
+     && !TSCDisabled()
+     && !UnderNT()
+/*
+#ifndef __Win32__
+ #ifndef __Windows__
+  #ifndef __DPMI__
+     && !checkEMM386()
+  #endif
+ #endif
+#endif
+*/
+   )
+  {
+   f1 = getPentiumSpeed();
+   f2 = getPentiumSpeed();
+   f3 = getPentiumSpeed();
+   return ((f1 + f2 + f3) / 3);
+  }
+#endif
+#ifdef __NewSpeedCalc__
+ for (i = 0; i<=7; i++ )
+  {
+   j = Speed();
+   if ( ( j < ms ) && ( speedShift >= sps ) )
+    {
+     ms = j;
+     sps = speedShift;
+    }
+  }
+  return ( ( ( speedTable[cpu] * (long)sps ) / ms + 5 ) / 10 );
+#else
+  f1 = (int)( ( ( speedTable[cpu] * (long)speedShift ) / Speed() + 5 ) / 10 );
+  f2 = (int)( ( ( speedTable[cpu] * (long)speedShift ) / Speed() + 5 ) / 10 );
+  f3 = (int)( ( ( speedTable[cpu] * (long)speedShift ) / Speed() + 5 ) / 10 );
+  return ((f1 + f2 + f3) / 3);
+#endif
+ }
+
+#ifdef __need_fp_cpu_Speed__ /* this code links in too much and disables
+                                TINY model programs to be converted to .COM */
+
+float _call fcpu_Speed( void )
+/* exactly the same as cpu_Speed, but returns floating point result */
+ {
+#ifdef __NewSpeedCalc__
+ unsigned int ms = 0xFFFF, sps = 0, i, j;
+#endif
+ float f1, f2, f3;
+ if(cpu == 0xFF)
+   cpu_Type();
+ if((extFlags & efTSCSupport)
+     && !TSCDisabled()
+     && !UnderNT()
+/*
+#ifndef __Win32__
+ #ifndef __Windows__
+  #ifndef __DPMI__
+     && !checkEMM386()
+  #endif
+ #endif
+#endif
+*/
+   )
+  {
+   f1 = getPentiumSpeed();
+   f2 = getPentiumSpeed();
+   f3 = getPentiumSpeed();
+   return ((f1 + f2 + f3) / 3);
+  }
+#ifdef __NewSpeedCalc__
+ for (i = 0; i<=7; i++ )
+  {
+   j = Speed();
+   if ( ( j < ms ) && ( speedShift >= sps ) )
+    {
+     ms = j;
+     sps = speedShift;
+    }
+  }
+  res = ( ( speedTable[cpu] * (long)sps ) / ms + 5 ) / 10;
+#else
+  f1 = ( ( speedTable[cpu] * (long)speedShift ) / Speed() + 5 ) / 10;
+  f2 = ( ( speedTable[cpu] * (long)speedShift ) / Speed() + 5 ) / 10;
+  f3 = ( ( speedTable[cpu] * (long)speedShift ) / Speed() + 5 ) / 10;
+#endif
+  return ((f1 + f2 + f3)/3);
+ }
+
+#endif /* __need_fp_cpu_Speed__ */
+
+#ifdef __BORLANDC__
+ #pragma warn -aus
+#endif
+
+#ifndef __No_SerialN__
+static char SN[30];
+
+char * _call getCPUSerialNumber( void )
+{
+ customCpuid A;
+ char T[10];
+ word tmp = 0;   /* temporary storage for word-sized parts of PSN */
+ if(!(cpuFeatures & 0x00040000))
+  return("");
+ else
+  {
+   getCPUID(1,&A);
+#ifdef __Win32__
+   _sprintf(T,"%04X-%04X",(tmp = A.eax >> 16),
+                          (tmp = A.eax & 0xFFFF));
+#else
+   sprintf(T,"%04X-%04X",(tmp = (word)(A.eax >> 16)),
+                         (tmp = (word)(A.eax & 0xFFFF)));
+#endif
+   getCPUID(3,&A);
+#ifdef __Win32__
+   _sprintf(SN,"%s-%04X-%04X-%04X-%04X",T ,(tmp = A.edx >> 16),
+                                           (tmp = A.edx & 0xFFFF),
+                                           (tmp = A.ecx >> 16),
+                                           (tmp = A.ecx & 0xFFFF));
+#else
+   sprintf(SN,"%s-%04X-%04X-%04X-%04X",T ,(tmp = (word)(A.edx >> 16)),
+                                          (tmp = (word)(A.edx & 0xFFFF)),
+                                          (tmp = (word)(A.ecx >> 16)),
+                                          (tmp = (word)(A.ecx & 0xFFFF)));
+#endif
+   return SN;
+  }
+}
+#endif
+
+#define libVersion 0x0215
+
+#ifndef __No_Version__
+word _call getVersion( void )
+{
+  return libVersion;
+}
+#endif
diff -Nu d:7.501/criterrs.txt SOURCES/criterrs.txt
--- d:7.501/criterrs.txt	2001-12-26 11:43:20 +0200
+++ SOURCES/criterrs.txt	2007-02-15 08:37:32 +0200
@@ -49,22 +49,22 @@
 #15 Invalid drive
 #16 Can't remove current directory
 #17 Not same device
-#18 File not found
+#18 No more files
           ;
           ; DOS INT 24 (critical error) messages 
           ;
-#19 Disk is write protected
-#20 Bad disk unit
-#21 Drive not ready--close door
-#22 Bad disk command
+#19 Write protect error
+#20 Invalid unit
+#21 Not ready
+#22 Invalid device request
 #23 Data error
-#24 Bad call format
+#24 Invalid device request parameters
 #25 Seek error
-#26 Non-DOS disk
+#26 Invalid media type
 #27 Sector not found
-#28 Out of paper
-#29 Write error
-#30 Read error
+#28 Printer out of paper error
+#29 Write fault error
+#30 Read fault error
 #31 General failure
           ;
           ; DOS 3 extended errors (mostly network errors)
@@ -75,7 +75,10 @@
 #34 Invalid disk change
 #35 FCB unavailable
 #36 Sharing buffer overflow
-#40 Not ready
+#37 Code page mismatch
+#38 Out of input before end
+#39 Out of disk space
+#40 Device not ready
 #41 File allocation table bad
 #50 Invalid net request
 #51 Remote computer not listening
@@ -89,18 +92,25 @@
 #59 Unexpected net error
 #60 Incompatible remote adapter
 #61 Print queue full
-#62 Queue not full
-#63 No room for print file
+#62 No room for print file
+#63 Print file was cancelled
 #64 Net name was deleted
-#65 Access denied
+#65 Net access denied
 #66 Net device type incorrect
-#67 Net name not found
+#67 Network name not found
 #68 Net name limit exceeded
 #69 NetBIOS session limit exceeded
-#70 Temporarily paused
+#70 Sharing temporarily paused
 #71 Net request not accepted
-#72 Redirection is paused
+#72 Print or disk redirection is paused
+#73 Invalid network version
+#74 Account expired
+#75 Password expired
+#76 Login currently not allowed
+#77 Disk limit exceeded on node
+#78 Not logged in to net node
 #80 File exists
+#81 Duplicated FCB
 #82 Can't make directory entry
 #83 Fail on INT 24
 #84 Too many redirections
@@ -108,6 +118,18 @@
 #86 Invalid password
 #87 Invalid parameter
 #88 Net device fault
+          ;
+          ; DOS 4 extended errors (mostly network errors)
+          ;
+#89 Net function not supported
+#90 Required component not installed
+#91 Timer server table overflow
+#92 Duplicate in timer service table
+#93 No items to work on
+#95 Invalid system call
+          ;
+          ; MSCDEX errors (duplicated by other network errors!)
+          ;
 #100 CD-ROM unknown error
 #101 CD-ROM not ready
 #102 CD-ROM EMS memory bad
diff -Nu d:7.501/cstrt086.asm SOURCES/cstrt086.asm
--- d:7.501/cstrt086.asm	1970-01-01 02:00:00 +0200
+++ SOURCES/cstrt086.asm	2007-09-19 22:03:44 +0200
@@ -0,0 +1,481 @@
+;*****************************************************************************
+;*
+;*                            Open Watcom Project
+;*
+;*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
+;*
+;*  ========================================================================
+;*
+;*    This file contains Original Code and/or Modifications of Original
+;*    Code as defined in and that are subject to the Sybase Open Watcom
+;*    Public License version 1.0 (the 'License'). You may not use this file
+;*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
+;*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
+;*    provided with the Original Code and Modifications, and is also
+;*    available at www.sybase.com/developer/opensource.
+;*
+;*    The Original Code and all software distributed under the License are
+;*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+;*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
+;*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
+;*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
+;*    NON-INFRINGEMENT. Please see the License for the specific language
+;*    governing rights and limitations under the License.
+;*
+;*  ========================================================================
+;*
+;* Description:  DOS 16-bit startup code.
+;*
+;*****************************************************************************
+
+
+;       This must be assembled using one of the following commands:
+;               wasm cstrt086 -bt=DOS -ms -0
+;               wasm cstrt086 -bt=DOS -mm -0
+;               wasm cstrt086 -bt=DOS -mc -0
+;               wasm cstrt086 -bt=DOS -ml -0
+;               wasm cstrt086 -bt=DOS -mh -0
+;
+
+include mdef.inc
+include xinit.inc
+
+.286p
+
+        name    cstart
+
+        assume  nothing
+
+if _MODEL and _BIG_CODE
+        extrn   __CMain                 : far
+        extrn   __InitRtns              : far
+        extrn   __FiniRtns              : far
+        extrn   __fatal_runtime_error_  : far
+else
+        extrn   __CMain                 : near
+        extrn   __InitRtns              : near
+        extrn   __FiniRtns              : near
+        extrn   __fatal_runtime_error_  : near
+endif
+        extrn   _edata                  : byte  ; end of DATA (start of BSS)
+        extrn   _end                    : byte  ; end of BSS (start of STACK)
+
+        extrn   "C",_curbrk             : word
+        extrn   "C",_psp                : word
+        extrn   "C",_osmajor            : byte
+        extrn   "C",_osminor            : byte
+        extrn   __osmode                : byte
+        extrn   __HShift                : byte
+        extrn   "C",_STACKLOW           : word
+        extrn   "C",_STACKTOP           : word
+        extrn   "C",_cbyte              : word
+        extrn   "C",_child              : word
+        extrn   __no87                  : word
+        extrn   "C",__FPE_handler       : dword
+        extrn   "C",_LpCmdLine          : word
+        extrn   "C",_LpPgmName          : word
+        extrn   __get_ovl_stack         : word
+        extrn   __restore_ovl_stack     : word
+        extrn   __close_ovl_file        : word
+        extrn   __DOSseg__              : byte
+
+ifdef __TINY__
+        extrn   __stacksize             : word
+ DGROUP group _TEXT,CONST,STRINGS,_DATA,DATA,XIB,XI,XIE,YIB,YI,YIE,_BSS
+else
+ DGROUP group _NULL,_AFTERNULL,CONST,STRINGS,_DATA,DATA,XIB,XI,XIE,YIB,YI,YIE,_BSS,STACK
+endif
+
+ife _MODEL and _BIG_CODE
+
+; this guarantees that no function pointer will equal NULL
+; (WLINK will keep segment 'BEGTEXT' in front)
+; This segment must be at least 4 bytes in size to avoid confusing the
+; signal function.
+; need a symbol defined here to prevent the dead code elimination from
+; eliminating the segment.
+; (the int 3h is useful for quickly revealing jumps to NULL code pointers)
+
+BEGTEXT  segment word public 'CODE'
+        assume  cs:BEGTEXT
+forever label   near
+        int     3h
+        jmp     short forever
+___begtext label byte
+        nop
+        nop
+        nop
+        nop
+        public ___begtext
+        assume  cs:nothing
+BEGTEXT  ends
+
+endif
+
+_TEXT   segment word public 'CODE'
+
+FAR_DATA segment byte public 'FAR_DATA'
+FAR_DATA ends
+
+        assume  ds:DGROUP
+
+        INIT_VAL        equ 0101h
+        NUM_VAL         equ 16
+
+_NULL   segment para public 'BEGDATA'
+__nullarea label word
+        dw      NUM_VAL dup(INIT_VAL)
+        public  __nullarea
+_NULL   ends
+
+_AFTERNULL segment word public 'BEGDATA'
+        dw      0                       ; nullchar for string at address 0
+_AFTERNULL ends
+
+
+CONST   segment word public 'DATA'
+CONST   ends
+
+STRINGS segment word public 'DATA'
+STRINGS ends
+
+XIB     segment word public 'DATA'
+XIB     ends
+XI      segment word public 'DATA'
+XI      ends
+XIE     segment word public 'DATA'
+XIE     ends
+
+YIB     segment word public 'DATA'
+YIB     ends
+YI      segment word public 'DATA'
+YI      ends
+YIE     segment word public 'DATA'
+YIE     ends
+
+_DATA   segment word public 'DATA'
+
+if _MODEL and _BIG_CODE
+;       Variables filled in by Microsoft Overlay Manager
+;       These are here for people who want to link with Microsoft Linker
+;       and use CodeView for debugging overlayed programs.
+__ovlflag  db 0                 ; non-zero => program is overlayed
+__intno    db 0                 ; interrupt number used by MS Overlay Manager
+__ovlvec   dd 0                 ; saved contents of interrupt vector used
+        public  __ovlflag
+        public  __intno
+        public  __ovlvec
+endif
+
+_DATA   ends
+
+DATA    segment word public 'DATA'
+DATA    ends
+
+_BSS    segment word public 'BSS'
+_BSS    ends
+
+STACK_SIZE      equ     800h
+
+STACK   segment para stack 'STACK'
+        db      (STACK_SIZE) dup(?)
+STACK   ends
+
+        assume  nothing
+        public  __astart
+        public  _Not_Enough_Memory_
+
+        assume  cs:_TEXT
+
+ __astart proc near
+        jmp     around
+
+;
+; miscellaneous code-segment messages
+;
+
+NullAssign      db      0dh,0ah,'*** NULL assignment detected',0dh,0ah,0
+
+NoMemory        db      'Not enough memory',0dh,0ah,0
+
+ConsoleName     db      'con',00h
+
+ife _MODEL and _BIG_CODE
+                dw      ___begtext      ; make sure dead code elimination
+endif                                   ; doesn't kill BEGTEXT segment
+
+around: sti                             ; enable interrupts
+
+; 
+; On entry (called by 4DOS), we have:
+;   DS = SS = DGROUP
+;   ES = PSP segment
+;   AX = DGROUP size
+;   SP = adjusted stack pointer we should not modify
+;
+; DGROUP contains initialized data + BSS, ending at _end. That is also the
+; bottom of the stack. The top of the stack can be calculated from sp.
+; Between the top of stack and the size passed in ax is pre-allocated heap.
+;
+
+        mov     cx,ds                   ; get proper stack segment
+
+        assume  ds:DGROUP
+
+        mov     bx,offset DGROUP:_end   ; get bottom of stack
+        add     bx,0Fh                  ; ...
+        and     bl,0F0h                 ; ...
+        mov     _STACKLOW,bx            ; ...
+        mov     _psp,es                 ; save segment address of PSP
+
+        mov     bx,sp                   ; calculate top address for stack
+	add     bx,0Fh                  ; round up to paragraph boundary
+	and     bl,0F0h                 ; ...
+        mov     _STACKTOP,bx            ; set stack top
+
+        mov     dx,bx                   ; make sure enough memory for stack
+        shr     dx,1                    ; calc # of paragraphs needed
+        shr     dx,1                    ; ... for data segment
+        shr     dx,1                    ; ...
+        shr     dx,1                    ; ...
+
+        mov     cx,es:2h                ; get highest segment address
+        mov     si,ds                   ; point to data segment
+        sub     cx,si                   ; calc # of paragraphs available
+        cmp     dx,cx                   ; compare with what we need
+        jb      enuf_mem                ; if not enough memory
+_Not_Enough_Memory_:
+        mov     bx,1                    ; - set exit code
+        mov     ax,offset NoMemory      ;
+        mov     dx,cs                   ;
+        call    __fatal_runtime_error_  ; - display msg and exit
+enuf_mem:                               ; endif
+
+        mov     _curbrk,ax              ; set top of memory owned by process
+        mov     ax,_psp                 ; get segment addr of PSP
+        mov     es,ax                   ; place in ES
+;
+;       copy command line into bottom of stack
+;
+        mov     di,es                   ; point ds to PSP
+	mov     ds,di                   ; ...
+        mov     di,81H                  ; DOS command buffer _psp:80
+        mov     cl,-1[di]               ; get length of command
+        mov     ch,0
+        cld                             ; set direction forward
+        mov     al,' '
+        repe    scasb
+        lea     si,-1[di]
+
+        mov     dx,DGROUP
+        mov     es,dx                   ; es:di is destination
+        mov     di,es:_STACKLOW
+        mov     es:_LpCmdLine+0,di      ; stash lpCmdLine pointer
+        mov     es:_LpCmdLine+2,es      ; ...
+        je      noparm
+        inc     cx
+        rep     movsb
+noparm: sub     al,al
+        stosb                           ; store NULLCHAR
+        mov     al,0                    ; assume no pgm name
+        stosb                           ; . . .
+        dec     di                      ; back up pointer 1
+;
+;       get DOS version number
+;
+        mov     ah,30h
+        int     21h
+        mov     es:_osmajor,al
+        mov     es:_osminor,ah
+        mov     cx,di                   ; remember address of pgm name
+        cmp     al,3                    ; if DOS version 3 or higher
+        jb      nopgmname               ; then
+;
+;       copy the program name into bottom of stack
+;
+        mov     ds,ds:2ch               ; get segment addr of environment area
+        sub     si,si                   ; offset 0
+        xor     bp,bp                   ; no87 not present!
+L0:     mov     ax,[si]                 ; get first part of environment var
+        or      ax,2020H                ; lower case
+        cmp     ax,"on"                 ; if first part is 'NO'
+        jne     L1                      ; - then
+        mov     ax,2[si]                ; - get second part
+        cmp     ax,"78"                 ; - if second part is '87'
+        jne     L1                      ; - then
+        inc     bp                      ; - - set bp to indicate NO87
+L1:     cmp     byte ptr [si],0         ; end of string ?
+        lodsb
+        jne     L1                      ; until end of string
+        cmp     byte ptr [si],0         ; end of all strings ?
+        jne     L0                      ; if not, then skip next string
+        lodsb
+        inc     si                      ; - point to program name
+        inc     si                      ; - . . .
+L2:     cmp     byte ptr [si],0         ; - end of pgm name ?
+        movsb                           ; - copy a byte
+        jne     L2                      ; - until end of pgm name
+nopgmname:                              ; endif
+        mov     si,cx                   ; save address of pgm name
+        mov     es:_LpPgmName+0,si      ; stash LpPgmName pointer
+        mov     es:_LpPgmName+2,es      ; ...
+
+        mov     ax,es:_psp              ; get segment addr of PSP
+        mov     es,ax                   ; place in ES
+        mov     bx,sp                   ; end of stack in data segment
+
+        assume  ds:DGROUP
+        mov     dx,DGROUP
+        mov     ds,dx
+        mov     es,dx
+        mov     __no87,bp               ; set state of "NO87" environment var
+        mov     _STACKLOW,di            ; save low address of stack
+
+        mov     cx,offset DGROUP:_end   ; end of _BSS segment (start of STACK)
+        mov     di,offset DGROUP:_edata ; start of _BSS segment
+        sub     cx,di                   ; calc # of bytes in _BSS segment
+        mov     al,0                    ; zero the _BSS segment
+        rep     stosb                   ; . . .
+
+        cmp     word ptr __get_ovl_stack,0 ; if program not overlayed
+        jne     _is_ovl                 ; then
+        mov     ax,offset __null_ovl_rtn; - set vectors to null rtn
+        mov     __get_ovl_stack,ax      ; - ...
+        mov     __get_ovl_stack+2,cs    ; - ...
+        mov     __restore_ovl_stack,ax  ; - ...
+        mov     __restore_ovl_stack+2,cs; - ...
+        mov     __close_ovl_file,ax     ; - ...
+        mov     __close_ovl_file+2,cs   ; - ...
+_is_ovl:                                ; endif
+        xor     bp,bp                   ; set up stack frame
+if _MODEL and _BIG_CODE
+        push    bp                      ; ... for new overlay manager
+        mov     bp,sp                   ; ...
+endif
+        ; DON'T MODIFY BP FROM THIS POINT ON!
+        mov     ax,offset __null_FPE_rtn; initialize floating-point exception
+        mov     word ptr __FPE_handler,ax       ; ... handler address
+        mov     word ptr __FPE_handler+2,cs     ; ...
+
+        mov     ax,0FFh                 ; run all initalizers
+        call    __InitRtns              ; call initializer routines
+        call    __CMain
+__astart endp
+
+;       don't touch AL in __exit, it has the return code
+
+__exit  proc near
+        public  "C",__exit
+        push    ax
+        mov     dx,DGROUP
+        mov     ds,dx
+        cld                             ; check lower region for altered values
+        lea     di,__nullarea           ; set es:di for scan
+        mov     es,dx
+        mov     cx,NUM_VAL
+        mov     ax,INIT_VAL
+        repe    scasw
+        pop     ax                      ; restore return code
+        je      ok
+;
+; low memory has been altered
+;
+        mov     bx,ax                   ; get exit code
+        mov     ax,offset NullAssign    ; point to msg
+        mov     dx,cs                   ; . . .
+
+        public  __do_exit_with_msg__
+
+; input: DX:AX - far pointer to message to print
+;        BX    - exit code
+
+__do_exit_with_msg__:
+        mov     sp,offset DGROUP:_end+80h; set a good stack pointer
+        push    bx                      ; save return code
+        push    ax                      ; save address of msg
+        push    dx                      ; . . .
+        mov     dx,_TEXT
+        mov     ds,dx
+        mov     dx,offset ConsoleName
+        mov     ax,03d01h               ; write-only access to screen
+        int     021h
+        mov     bx,ax                   ; get file handle
+        pop     ds                      ; restore address of msg
+        pop     dx                      ; . . .
+        mov     si,dx                   ; get address of msg
+        cld                             ; make sure direction forward
+L3:     lodsb                           ; get char
+        cmp     al,0                    ; end of string?
+        jne     L3                      ; no
+        mov     cx,si                   ; calc length of string
+        sub     cx,dx                   ; . . .
+        dec     cx                      ; . . .
+        mov     ah,040h                 ; write out the string
+        int     021h                    ; . . .
+        pop     ax                      ; restore return code
+ok:
+if _MODEL and _BIG_CODE
+        mov     dx,DGROUP               ; get access to DGROUP
+        mov     ds,dx                   ; . . .
+        cmp     byte ptr __ovlflag,0    ; if MS Overlay Manager present
+        je      no_ovl                  ; then
+        push    ax                      ; - save return code
+        mov     al,__intno              ; - get interrupt number used
+        mov     ah,25h                  ; - DOS func to set interrupt vector
+        lds     dx,__ovlvec             ; - get previous contents of vector
+        int     21h                     ; - restore interrupt vector
+        pop     ax                      ; - restore return code
+no_ovl:                                 ; endif
+endif
+        push    ax                      ; save return code
+        mov     ax,00h                  ; run finalizers
+        mov     dx,FINI_PRIORITY_EXIT-1 ; less than exit
+        call    __FiniRtns              ; do finalization
+        pop     ax                      ; restore return code
+        mov     ah,04cH                 ; DOS call to exit with return code
+        int     021h                    ; back to DOS
+__exit  endp
+
+
+;
+;       set up addressability without segment relocations for emulator
+;
+public  __GETDS
+__GETDS proc    near
+        push    ax                      ; save ax
+ifdef __TINY__
+;       can't have segment fixups in the TINY memory model
+        mov     ax,cs                   ; DS=CS
+else
+        mov     ax,DGROUP               ; get DGROUP
+endif
+        mov     ds,ax                   ; load DS with appropriate value
+        pop     ax                      ; restore ax
+        ret                             ; return
+__GETDS endp
+
+
+__null_FPE_rtn proc far
+        ret                             ; return
+__null_FPE_rtn endp
+
+__null_ovl_rtn proc far
+        ret                             ; return
+__null_ovl_rtn endp
+
+        xref    __HeapInit_
+
+InitHeap proc   far
+        push    dx                      ; save dx
+        mov     dx,_curbrk              ; get size of segment
+        mov     ax,_STACKTOP            ; get start address of heap
+        sub     dx,ax                   ; subtract start of heap
+        call    __HeapInit_             ; initialize the heap
+        pop     dx                      ; restore dx
+        ret                             ; return
+											InitHeap endp
+_TEXT   ends
+
+        xinit   InitHeap,0
+
+        end
Common subdirectories: d:7.501/debug and SOURCES/debug
diff -Nu d:7.501/dircmds.c SOURCES/dircmds.c
--- d:7.501/dircmds.c	2006-11-12 16:00:50 +0200
+++ SOURCES/dircmds.c	2008-09-21 09:16:46 +0200
@@ -50,12 +50,12 @@
 extern int _pascal CompDriveCleanup(COMPDRIVEINFO *);
 extern int _pascal CompData(COMPDRIVEINFO *, FILESEARCH *, LPTSTR , ULONG *, ULONG *);
 
-static void PrintDirHeader( LPTSTR , LPTSTR , TCHAR _far * );
+static void PrintDirHeader( LPTSTR , LPTSTR );
+static void PrintColorName( LPTSTR , TCHAR _far * , int );
 static int GetDirectory(LPTSTR , LPTSTR );
 static int DrawTree( LPTSTR , LPTSTR  );
 static void _nxtrow(void);
 static int _near files_cmp( DIR_ENTRY _far *, DIR_ENTRY _far *);
-static void _near ssort(char _huge *, unsigned int);
 
 DIR_ENTRY _huge * _near GetDescriptions( unsigned int, DIR_ENTRY _huge *, unsigned long, unsigned long, LPTSTR );
 
@@ -63,33 +63,28 @@
 // disk total & free space
 static QDISKINFO DiskInfo;
 
-typedef struct {
-	unsigned long ulLowPart;
-	unsigned long ulHighPart;
-} __int64;
-
 // global compression ratio data
 static COMPDRIVEINFO CDriveData;
-static __int64 ulTreeUnCompSec;
-static __int64 ulTreeCompSec;
-static __int64 ulTotUnCompSec;
-static __int64 ulTotCompSec;
+static t_int64 ulTreeUnCompSec;
+static t_int64 ulTreeCompSec;
+static t_int64 ulTotUnCompSec;
+static t_int64 ulTotCompSec;
 static unsigned long ulLowMemFree;
 static unsigned int uScreenRows;			// screen size in rows (base 0 )
 
 
 // files and sizes within directory tree branch
 static unsigned long ulTreeFiles, ulTreeDirs;
-static __int64 ulTreeSize;		// size of all files in tree
-static __int64 ulTreeAlloc; 	// allocated size of all files in tree
+static t_int64 ulTreeSize;		// size of all files in tree
+static t_int64 ulTreeAlloc; 	// allocated size of all files in tree
 static unsigned int uDirRow;			// current row number
 static unsigned long ulDirMode;			// search attribute
 static unsigned int uDirColumns;		// number of columns (varies by screen size )
 static unsigned int uScreenColumns; 	// screen size in columns (base 1)
 static int nScreenColor;				// default screen color ( for colorization)
 static int fConsole;					// if != 0, STDOUT is console
-static __int64 ulTotalFileSize; 		// total of file sizes
-static __int64 ulTotalAllocated;	// total amount of disk space actually used
+static t_int64 ulTotalFileSize; 		// total of file sizes
+static t_int64 ulTotalAllocated;	// total amount of disk space actually used
 extern RANGES aRanges;			// date/time/size ranges
 static LPTSTR pszCPBuffer;		// pointer to temp buffer
 
@@ -246,20 +241,27 @@
 
 
 // add a DWORD to a QWORD
-static void Add32To64( __int64 *ullVal, unsigned long ulVal )
+void Add32To64( t_int64 *ullVal, unsigned long ulVal )
 {
+#ifdef NATIVE_INT64
+        *ullVal += ulVal;
+#else
 	unsigned long ulTemp;
 	
 	ulTemp = ullVal->ulLowPart;
 	ullVal->ulLowPart += ulVal;
 	if ( ullVal->ulLowPart < ulTemp )
 		ullVal->ulHighPart++;
+#endif
 }
 
 
 // add a QWORD to a QWORD
-static void Add64To64( __int64 *ullVal, __int64 *ullAdd )
+void Add64To64( t_int64 *ullVal, t_int64 *ullAdd )
 {
+#ifdef NATIVE_INT64
+        *ullVal += *ullAdd;
+#else
 	unsigned long ulTemp;
 	
 	ullVal->ulHighPart += ullAdd->ulHighPart;
@@ -268,12 +270,16 @@
 	ullVal->ulLowPart += ullAdd->ulLowPart;
 	if ( ullVal->ulLowPart < ulTemp )
 		ullVal->ulHighPart++;
+#endif
 }
 
 
 // subtract a QWORD from a QWORD; return result in second arg
-static void Subtract64From64( __int64 *ullVal, __int64 *ullSubtract )
+void Subtract64From64( t_int64 *ullVal, t_int64 *ullSubtract )
 {
+#ifdef NATIVE_INT64
+        *ullSubtract = *ullVal - *ullSubtract;
+#else
 	unsigned long ulTemp;
 	
 	ullSubtract->ulHighPart = ullVal->ulHighPart - ullSubtract->ulHighPart;
@@ -282,29 +288,38 @@
 	ullSubtract->ulLowPart = ullVal->ulLowPart - ullSubtract->ulLowPart;
 	if ( ullSubtract->ulLowPart > ulTemp )
 		ullSubtract->ulHighPart--;
+#endif
 }
 
 
 // divide a QWORD by a QWORD, return a string
-static LPTSTR  Divide64By64( __int64 *ullVal, __int64 *ullDivide, int nPrecision, int nPercent )
+LPTSTR  Divide64By64( t_int64 *ullVal, t_int64 *ullDivide, int nPrecision, int nPercent )
 {
 	static char szLongLong[80];
-	
+
+#ifdef NATIVE_INT64
+	ulltoa( *ullVal / *ullDivide, szLongLong, 10 ); // @TODO!!
+#else
 	sprintf( szLongLong, "(((4294967296*%lu)+%lu)/((4294967296*%lu)+%lu))*%d=0.%d", ullVal->ulHighPart, ullVal->ulLowPart, ullDivide->ulHighPart, ullDivide->ulLowPart, nPercent, nPrecision );
 	
 	evaluate( szLongLong );
+#endif
 	return szLongLong;
 }
 
 
 // Convert a 64-bit longlong to ASCII
-static LPTSTR  Format64( __int64 *ullVal )
+LPTSTR  Format64( t_int64 *ullVal )
 {
 	static char szLongLong[32];
-	
+
+#ifdef NATIVE_INT64
+	ulltoa( *ullVal, szLongLong, 10 );
+#else	
 	sprintf( szLongLong, "(4294967296*%lu)+%lu", ullVal->ulHighPart, ullVal->ulLowPart );
 	
 	evaluate( szLongLong );
+#endif
 	AddCommas( szLongLong );
 	
 	return szLongLong;
@@ -326,10 +341,17 @@
 	ulDirMode = 0x10;		// default to normal files + directories
 	ulTreeFiles = ulTreeDirs = 0L;
 
+#ifdef NATIVE_INT64
+	ulTreeSize = 0;
+	ulTreeAlloc = 0;
+	ulTreeCompSec = 0;
+	ulTreeUnCompSec = 0;
+#else
 	ulTreeSize.ulLowPart = ulTreeSize.ulHighPart = 0L;
 	ulTreeAlloc.ulLowPart = ulTreeAlloc.ulHighPart = 0L;
 	ulTreeCompSec.ulLowPart = ulTreeCompSec.ulHighPart = 0L;
 	ulTreeUnCompSec.ulLowPart = ulTreeUnCompSec.ulHighPart = 0L;
+#endif
 
 	uScreenColumns = GetScrCols();
 	nScreenColor = -1;
@@ -521,11 +543,11 @@
 			crlf();
 			
 		} else
-			PrintDirHeader( FMT_STR, pszArg, 0L );
+			PrintDirHeader( FMT_STR, pszArg );
 		
 		copy_filename( szFilename, pszArg );
 
-		mkdirname( szFilename, ((( ifs_type( szFilename ) != 0 ) && ( fWin95 )) ? _TEXT("*") : WILD_FILE ));
+		mkdirname( szFilename, ifs_type( szFilename ) ? _TEXT("*") : WILD_FILE );
 
 		if ((( nReturn = DrawTree( szFilename, szSequelBuffer )) != 0 ) || ( cv.fException ))
 			break;
@@ -569,7 +591,7 @@
 		
 		if ( fTree & TREE_SIZE ) {
 
-			printf( (( nAttrib & _A_SUBDIR ) ? DIR_LABEL : "%9lu" ), dir.ulSize );
+			printf( (( nAttrib & _A_SUBDIR ) ? DIR_LABEL : "%10lu" ), dir.ulSize );
 			qputs( _TEXT("  ") );
 		}
 		
@@ -653,7 +675,7 @@
 				pszSave = strdup( pszCurrent );
 				insert_path( pszCurrent, pszName, pszCurrent );
 
-				mkdirname( pszCurrent, ((( ifs_type( pszCurrent ) != 0 ) && ( fWin95 )) ? _TEXT("*") : WILD_FILE ));
+				mkdirname( pszCurrent, ifs_type( pszCurrent ) ? _TEXT("*") : WILD_FILE );
 
 				free( pszName );
 				
@@ -692,7 +714,7 @@
 	
 	// default to *.* on FAT, * on LFN/NTFS
 
-	strcpy( szFName, ((( ifs_type( NULL ) != 0 ) && ( fWin95 )) ? "*" : WILD_FILE ));
+	strcpy( szFName, ifs_type( NULL ) ? _TEXT("*") : WILD_FILE );
 
 	argc = nReturn = 0;
 	
@@ -1000,8 +1022,8 @@
 	unsigned int uLastEntry, uVRows, uVOffset, uColumns;
 	int nReturn = 0;
 	unsigned long ulFiles, ulDirs;
-	__int64 ulTSize, ulTAlloc;
-	__int64 ulTempUnCompSec, ulTempCompSec;
+	t_int64 ulTSize, ulTAlloc;
+	t_int64 ulTempUnCompSec, ulTempCompSec;
 
 	DIR_ENTRY _huge *files = 0L;	// file array in system memory
 	LPTSTR pszPtr;
@@ -1026,14 +1048,27 @@
 	
 	// save the current tree size & entries for recursive display
 
+#ifdef NATIVE_INT64
+	ulTSize = ulTreeSize;
+	ulTAlloc = ulTreeAlloc;
+#else
 	ulTSize.ulLowPart = ulTreeSize.ulLowPart;
 	ulTSize.ulHighPart = ulTreeSize.ulHighPart;
 	ulTAlloc.ulLowPart = ulTreeAlloc.ulLowPart;
 	ulTAlloc.ulHighPart = ulTreeAlloc.ulHighPart;
+#endif
 
 	ulFiles = ulTreeFiles;
 	ulDirs = ulTreeDirs;
-	
+
+#ifdef NATIVE_INT64
+	ulTempUnCompSec = ulTreeUnCompSec;
+	ulTempCompSec = ulTreeCompSec;
+	ulTotUnCompSec = 0;
+	ulTotCompSec = 0;
+	ulTotalFileSize = 0;
+	ulTotalAllocated = 0;
+#else	
 	ulTempUnCompSec.ulLowPart = ulTreeUnCompSec.ulLowPart;
 	ulTempUnCompSec.ulHighPart = ulTreeUnCompSec.ulHighPart;
 	ulTempCompSec.ulLowPart = ulTreeCompSec.ulLowPart;
@@ -1044,6 +1079,7 @@
 	
 	ulTotalFileSize.ulLowPart = ulTotalFileSize.ulHighPart = 0L;
 	ulTotalAllocated.ulLowPart = ulTotalAllocated.ulHighPart = 0L;
+#endif
 	
 	if ( is_dir( pszCurrent )) {
 
@@ -1095,7 +1131,7 @@
 				_nxtrow();
 			
 			// display "Directory of c:\wonky\*.*"
-			PrintDirHeader( DIRECTORY_OF, pszCurrent, ( TCHAR _far *)NULL );
+			PrintDirHeader( DIRECTORY_OF, pszCurrent );
 			_nxtrow();
 		}
 		
@@ -1189,10 +1225,10 @@
 				if ( glDirFlags & DIRFLAGS_NT_ALT_NAME ) {
 					
 					GetShortName( pszPtr );
-					PrintDirHeader( _TEXT("%s%Fs"), pszPtr, files[i].szFATName );
+					PrintColorName( pszPtr, files[i].szFATName, files[i].nColor );
 					
 				} else
-					PrintDirHeader( _TEXT("%s%Fs"), pszPtr, ((( glDirFlags & DIRFLAGS_LFN ) && (( glDirFlags & DIRFLAGS_LFN_TO_FAT ) == 0 )) ? files[i].lpszLFN : files[i].szFATName ));
+					PrintColorName( pszPtr, ((( glDirFlags & DIRFLAGS_LFN ) && (( glDirFlags & DIRFLAGS_LFN_TO_FAT ) == 0 )) ? files[i].lpszLFN : files[i].szFATName ), files[i].nColor );
 				
 				uColumns = 1;
 				
@@ -1209,7 +1245,7 @@
 					
 					if ( uColumns <= 2 ) {
 
-						nCPLength += sprintf( pszCPBuffer+nCPLength, ( files[i].uAttribute & _A_SUBDIR) ? DIR_LABEL : _TEXT("%9lu"), files[i].ulFileSize );
+						nCPLength += sprintf( pszCPBuffer+nCPLength, ( files[i].uAttribute & _A_SUBDIR) ? DIR_LABEL : _TEXT("%10lu"), files[i].ulFileSize );
 
 						nCPLength += sprintf( pszCPBuffer+nCPLength, _TEXT("  %s "),(( files[i].days == 0 ) ? _TEXT("        ") : FormatDate( files[i].months, files[i].days, files[i].years, 0 )));
 						nCPLength += sprintf( pszCPBuffer+nCPLength, (( files[i].days == 0 ) ? _TEXT("      ") : (( gaCountryInfo.fsTimeFmt == 0 ) ? _TEXT("%2u%c%02u%c") : _TEXT(" %2u%c%02u") )),
@@ -1251,8 +1287,8 @@
 											_nxtrow();
 											
 											// pad start of next line w/blanks
-											wcmemset( pszCPBuffer, _TEXT(' '), 39 );
-											strcpy( pszCPBuffer + 39, pszCPBuffer + j + 1 );
+											wcmemset( pszCPBuffer, _TEXT(' '), 40 );
+											strcpy( pszCPBuffer + 40, pszCPBuffer + j + 1 );
 											nCPLength = strlen( pszCPBuffer );
 										}
 									}
@@ -1272,11 +1308,14 @@
 							
 							fsize = files[i].ulFileSize;
 							
-							// if between 1 & 10 Mb, display
+							// if between 1 & 10 Mb or above 1 Gb, display
 							//	 decimal part too
 							if (( files[i].ulFileSize >= 1048576L ) && ( files[i].ulFileSize < 10485760L )) {
 								fsize /= 1048576L;
 								sprintf( pszCPBuffer+nCPLength, _TEXT(" %lu.%luM"), (ULONG)fsize, (ULONG)(( (ULONG)files[i].ulFileSize % 1048576L ) / 104858L ));
+							} else if (( files[i].ulFileSize >= 1073741824L )) {
+								fsize /= 1073741824L;
+								sprintf( pszCPBuffer+nCPLength, _TEXT(" %lu.%luG"), (ULONG)fsize, (ULONG)(( (ULONG)files[i].ulFileSize % 1073741824L ) / 107374183L ));
 							} else {
 								for ( pszPtr = DIR_FILE_SIZE; (( fsize = (( fsize + 1023 ) / 1024L )) > 999 ); pszPtr++ )
 									;
@@ -1362,10 +1401,12 @@
 			if (( uColumns <= 1 ) || ((( n + 1 ) % uColumns ) == 0 )) {
 				if (( glDirFlags & DIRFLAGS_FULLNAME ) == 0 )
 					_nxtrow();
-			} else if (( glDirFlags & DIRFLAGS_LFN ) && (( glDirFlags & DIRFLAGS_LFN_TO_FAT ) == 0 ))
+			} else if (( glDirFlags & DIRFLAGS_LFN ) && (( glDirFlags & ( DIRFLAGS_LFN_TO_FAT | DIRFLAGS_NT_ALT_NAME )) == 0 ) || ( glDirFlags & DIRFLAGS_WIDE ))
 				qputs( _TEXT("  ") );
+			else if ( uColumns == 2 )
+				qputs( fConsole ? _TEXT("") : _TEXT("|") );
 			else
-				qputs(( glDirFlags & DIRFLAGS_WIDE ) ? _TEXT("  ") : _TEXT("   ") );
+				qputs( _TEXT("   ") );
 
 
 		}
@@ -1388,7 +1429,11 @@
 	// print the directory totals
 	if ((( glDirFlags & ( DIRFLAGS_NO_FOOTER | DIRFLAGS_GLOBAL_SUMMARY )) == 0 ) && ((( uFilesDisplayed + uDirsDisplayed ) > 0 ) || (( glDirFlags & DIRFLAGS_RECURSE ) == 0 ))) {
 
+#ifdef NATIVE_INT64
+		if (( glDirFlags & DIRFLAGS_COMPRESSION ) && ( ulTotCompSec > 0 ) ) {
+#else
 		if (( glDirFlags & DIRFLAGS_COMPRESSION ) && (( ulTotCompSec.ulLowPart > 0 ) || ( ulTotCompSec.ulHighPart > 0 ))) {
+#endif
 			if ( glDirFlags & DIRFLAGS_PERCENT_COMPRESSION )
 				printf( DIR_AVERAGE_PERCENT_RATIO, Divide64By64( &ulTotCompSec, &ulTotUnCompSec, 0, 100 ));
 			else
@@ -1458,14 +1503,18 @@
 				// display figures for local tree branch
 				strcpy( pszPtr, pszFileName );
 				_nxtrow();
-				PrintDirHeader( DIR_TOTAL, pszCurrent, (TCHAR _far *)NULL );
+				PrintDirHeader( DIR_TOTAL, pszCurrent );
 
 				if ( glDirFlags & DIRFLAGS_COMPRESSION ) {
 						
 					Subtract64From64( &ulTreeUnCompSec, &ulTempUnCompSec );
 					Subtract64From64( &ulTreeCompSec, &ulTempCompSec );
 						
+#ifdef NATIVE_INT64
+					if ( ulTempCompSec > 0 ) {
+#else
 					if (( ulTempCompSec.ulLowPart > 0 ) || ( ulTempCompSec.ulHighPart > 0 )) {
+#endif
 						if ( glDirFlags & DIRFLAGS_PERCENT_COMPRESSION )
 							printf( DIR_AVERAGE_PERCENT_RATIO, Divide64By64( &ulTempCompSec, &ulTempUnCompSec, 0, 100 ));
 						else
@@ -1508,29 +1557,50 @@
 
 
 // print header or footer, with page wrapping optional
-static void PrintDirHeader( LPTSTR pszHeader, LPTSTR pszName, TCHAR _far *pszOtherName )
+static void PrintDirHeader( LPTSTR pszHeader, LPTSTR pszName )
 {
-	LPTSTR pszBuf;	// don't make register - will break _alloca!
-	
-	if ( pszOtherName == 0L )
-		pszOtherName = NULLSTR;
-	pszBuf = _alloca( ( strlen( pszHeader ) + strlen( pszName ) + _fstrlen( pszOtherName ) + 1 ) * sizeof(TCHAR) );
-	sprintf( pszBuf, pszHeader, pszName, pszOtherName );
+	LPTSTR pszBuf = _alloca( ( strlen( pszHeader ) + strlen( pszName ) + 1 ) * sizeof(TCHAR) );
+	sprintf( pszBuf, pszHeader, pszName );
 	more_page( pszBuf, 0 );
 }
 
 
+// print file name in colour, with page wrapping optional
+static void PrintColorName( LPTSTR pszName, TCHAR _far *pszOtherName, int color )
+{
+	LPTSTR pszBuf = _alloca( ( 5 + strlen( pszName ) + _fstrlen( pszOtherName ) + 1 ) * sizeof(TCHAR) );
+	nCPLength = sprintf( pszBuf, _TEXT("%s%Fs"), pszName, pszOtherName );
+	if ( !fConsole || gfCTTY ) {
+		qputs( pszBuf );
+		crlf();
+	} else {
+		unsigned i;	// wrap long names
+		for ( i = 0; ; ) {
+			color_printf( color, FMT_PREC_STR, uScreenColumns, pszBuf + i );
+			if (( i += uScreenColumns ) >= nCPLength ) {
+				_nxtrow();
+				break;
+			}
+			if ( color == -1 )
+				_page_break();
+			else
+				_nxtrow();
+		}
+	}
+}
+
+
 // go to next row & check for page full
 static void _nxtrow( void )
 {
-	static unsigned int nRow, nColumn;
+	static int nRow, nColumn;
 	int fCtrlC = 0;
 	
 	// check for colorized directories & scroll w/o ANSI
 	if ( nScreenColor != -1 ) {
 		
 		GetCurPos( &nRow, &nColumn );
-		if ( nRow == uScreenRows ) {
+		if ( nRow == (int)uScreenRows ) {
 			
 			// set our own scroll, because the BIOS will use the
 			//	 color from the 1st char on the previous line
@@ -1570,6 +1640,7 @@
 {
 	if ( ++uDirRow == gnPageLength ) {
 		
+		unsigned key;
 		uDirRow = 0;
 
 		// make sure STDOUT hasn't been redirected
@@ -1577,7 +1648,9 @@
 			return;
 		
 		qputs( PAUSE_PAGE_PROMPT );
-		if ( GetKeystroke( EDIT_NO_ECHO | EDIT_SCROLL_CONSOLE | EDIT_ECHO_CRLF ) == ESC )
+		key = GetKeystroke( EDIT_NO_ECHO | EDIT_SCROLL_CONSOLE );
+		qputs( PAUSE_PAGE_CLEAR );
+		if (key == ESC )
 			BreakOut();
 	}
 }
@@ -1900,33 +1973,36 @@
 }
 
 
-// do a Shell sort on the directory (much smaller & less stack than Quicksort)
-static void _near ssort( char _huge *lpBase, unsigned int uEntries )
+static void _near downHeap( DIR_ENTRY _huge *lpBase, unsigned int k, unsigned int n )
 {
-	register unsigned int i, uGap;
-	char _huge *lpPtr1, _huge *lpPtr2;
+	register unsigned int i;
 	char szTmp[ sizeof(DIR_ENTRY) ];
-	long j;
-	
-	for ( uGap = ( uEntries >> 1 ); ( uGap > 0 ); uGap >>= 1) {
-		
-		for ( i = uGap; ( i < uEntries ); i++ ) {
-			
-			for ( j = ( i - uGap ); ( j >= 0L ); j -= uGap ) {
-				
-				lpPtr1 = lpPtr2 = lpBase;
-				lpPtr1 += ( j * sizeof( DIR_ENTRY));
-				lpPtr2 += (( j + uGap ) * sizeof( DIR_ENTRY));
-				
-				if ( files_cmp(( DIR_ENTRY _far *)lpPtr1,( DIR_ENTRY _far *)lpPtr2 ) <= 0 )
-					break;
-				
-				// swap the two records
-				_fmemmove( szTmp, lpPtr1, sizeof( DIR_ENTRY) );
-				_fmemmove( lpPtr1, lpPtr2, sizeof( DIR_ENTRY) );
-				_fmemmove( lpPtr2, szTmp, sizeof( DIR_ENTRY) );
-			}
-		}
+
+	for ( _fmemmove( szTmp, &lpBase[k], sizeof( DIR_ENTRY) ); k <= n / 2; k = i ) {
+		i = 2 * k;
+		if ( i < n && files_cmp(( DIR_ENTRY _far *)&lpBase[i], ( DIR_ENTRY _far *)&lpBase[i+1] ) < 0 )
+			i++;
+		if ( files_cmp(( DIR_ENTRY _far *)szTmp, ( DIR_ENTRY _far *)&lpBase[i] ) >= 0 )
+			break;
+		_fmemmove( &lpBase[k], &lpBase[i], sizeof( DIR_ENTRY) );
+	}
+	_fmemmove( &lpBase[k], szTmp, sizeof( DIR_ENTRY) );
+}
+
+
+// do a heapsort on the directory (much smaller & less stack than Quicksort)
+static void _near heapSort( DIR_ENTRY _huge *lpBase, unsigned int uEntries )
+{
+	register unsigned int i;
+	char szTmp[ sizeof(DIR_ENTRY) ];
+
+	for ( i = uEntries >> 1 - 1; i < UINT_MAX; i-- )
+		downHeap( lpBase, i, uEntries - 1 );
+	for ( i = uEntries - 1; i != 0; i-- ) {
+		_fmemmove( szTmp, &lpBase[i], sizeof( DIR_ENTRY) );
+		_fmemmove( &lpBase[i], lpBase, sizeof( DIR_ENTRY) );
+		_fmemmove( lpBase, szTmp, sizeof( DIR_ENTRY) );
+		downHeap( lpBase, 0, i - 1 );
 	}
 }
 
@@ -2174,7 +2250,7 @@
 		files[*puEntries].years = dir.fd.file_date.years + 80;
 		files[*puEntries].months = dir.fd.file_date.months;
 		files[*puEntries].days = dir.fd.file_date.days;
-		files[*puEntries].seconds = dir.ft.file_time.seconds;
+		files[*puEntries].seconds = dir.ft.file_time.seconds * 2;
 		files[*puEntries].minutes = dir.ft.file_time.minutes;
 		files[*puEntries].hours = dir.ft.file_time.hours;
 
@@ -2273,7 +2349,7 @@
 
 		// unless /Ou (unsorted) specified, sort the dir array
 		if ( gszSortSequence[0] != _TEXT('u') )
-			ssort( (char _huge *)*hptr, *puEntries );
+			heapSort( *hptr, *puEntries );
 
 		if ( nFlags & 4 ) {
 			// check for file colorization (SET COLORDIR=...)
Common subdirectories: d:7.501/dos and SOURCES/dos
diff -Nu d:7.501/doscalls.c SOURCES/doscalls.c
--- d:7.501/doscalls.c	2006-11-12 16:00:50 +0200
+++ SOURCES/doscalls.c	2009-02-27 09:38:10 +0200
@@ -173,7 +173,7 @@
 		lea	bx, word ptr dosline
 		lea	si, word ptr cmd
 		xor	ch, ch
-		mov	cl, byte ptr cmd.len
+		mov	cl, byte ptr [cmd + 0]
 		mov	dx, 0FFFFh
 		int	02Fh
 
@@ -559,6 +559,8 @@
 }
 
 
+#pragma alloc_text( _TEXT, killpipes )
+
 // Delete temporary pipe input file
 void _fastcall killpipes( REDIR_IO *redirect )
 {
@@ -578,9 +580,7 @@
 	_lseek( fh, lSize, SEEK_SET );
 
 	// MSC write() function won't truncate
-	_dos_write( fh, NULLSTR, 0, &uBytesWritten );
-
-	return 0;
+	return _dos_write( fh, NULLSTR, 0, &uBytesWritten );
 }
 
 
@@ -711,70 +711,141 @@
 // enable the ^C / ^BREAK / KILLPROCESS signals
 void EnableSignals( void )
 {
-	ServCtrl( SERV_SIGNAL, (int)BreakHandler );
+	ServCtrl( SERV_SIGNAL, (int)(long)BreakHandler );
 	ServCtrl( SERV_SIGNAL, SERV_SIG_ENABLE );
 }
 
 
-// wait the specified number of seconds
-void _fastcall SysWait( unsigned long ulSeconds, int fFlags )
+// get elapsed milliseconds since midnight (DOS) or since Windows has started
+ULONG _near GetMs( void )
 {
-	register int nInterval = 5;
-	unsigned long i;
+	t_int64 llClock;
 
-	// milliseconds (2) or seconds?
-	if (( fFlags & 2 ) == 0 ) {
-		// if not /B or /M, just wait
-		if (( fFlags & 1 ) == 0 ) {
-			DosBeep( 0, (unsigned int)(ulSeconds * 18) );
-			return;
-		}
-		ulSeconds *= 4;
+	if ( gnOSFlags & DOS_IS_OS2 )
+		return 0;
+	if ( gpIniptr->WinMode )
+		return GetWinMs();
+	GetTimeStamp( &llClock );
+	ShiftLeft16( &llClock );
+	return Divide64By32( &llClock, 78196354 );
+}    // 65536 * 14318180 / 12 / 1000 = 78196353.7066667
+
+
+// get the current timestamp that is relevant for the running operating system
+static ULONG GetOSclock( void )
+{
+	ULONG ulVal;
+	if ( gnOSFlags & DOS_IS_OS2 ) {	// OS/2 system time accuracy is 31.25 ms
+		struct dostime_t tm;
+		_dos_gettime( &tm );// return hundredths since midnight (range: 0 to 8640000)
+		return (( tm.hour * 60L + tm.minute ) * 60L + tm.second ) * 100L + tm.hsecond;
 	}
+	return gpIniptr->WinMode && (ulVal = GetWinMs()) ? ulVal : GetTimer();
+}
 
-	for ( i = 0; ( i < ulSeconds ); ) {
 
-		if (( fFlags & 1 ) && ( _kbhit() ))
-			break;
+// wait the specified number of [milli]seconds
+void _fastcall SysWait( unsigned long ulSeconds, int fFlags )
+{
+	int nInterval, key;
+	ULONG i;
 
-		if ( fFlags & 2 ) {
-			// 18.2 ticks/second == roughly 50ms (with overhead)
-			nInterval = 1;
-			i += 50;
-		} else {
-			nInterval = (( nInterval == 5 ) ? 4 : 5 );
-			i++;
+	// milliseconds (2) or seconds?
+	if ( fFlags & 2 ) {
+		ULONG ulWrap = 65536, ulNew, ulOld = i = GetOSclock();
+		if ( gnOSFlags & DOS_IS_OS2 ) {
+			ulSeconds = ( ulSeconds + 5 ) / 10;
+			ulWrap = 8640000;
+		} else if ( !gpIniptr->WinMode || !GetWinMs() )
+			ulSeconds *= 1193;
+		for ( i += ulSeconds; (ulNew = GetOSclock()) < i && ( ulOld <= ulNew || i > ulWrap && (i -= ulWrap) >= 0 ); ulOld = ulNew )
+			if (( key = bios_keystroke()) != -1 )
+				if ( !key || key == 0x2E03 ) // Ctrl-Break or Ctrl-C
+					goto delayRet;
+				else if ( fFlags & 1 )
+					goto getChr;
+	} else for ( nInterval = 5, ulSeconds <<= 2, i = 0; i < ulSeconds; i++ ) {
+		if (( fFlags & 1 ) && ( _kbhit() )) {
+getChr:			_getch();
+			return;
 		}
+		nInterval ^= 1;
 
 		// DosBeep with a frequency < 20 Hz just counts ticks & returns
-		if ( DosBeep( 0, nInterval ) ) {
+		if ( DosBeep( 0, nInterval ) )
 			// Got a ^C / ^Break; allow it to signal break handler
-			GetKeystroke( EDIT_NO_ECHO );
-		}
+delayRet:		GetKeystroke( EDIT_NO_ECHO );
 	}
 }
 
 
 // check if arg is a +, -, or 0-9
-int PASCAL is_signed_digit( register int nDigit )
+int _fastcall is_signed_digit( register char nDigit )
 {
 	return (( is_unsigned_digit( nDigit )) || ( nDigit == '+' ) || ( nDigit == '-' ));
 }
 
 
 // check if arg is a 0-9
-int PASCAL is_unsigned_digit( register int digit )
+int _fastcall is_unsigned_digit( register char digit )
 {
 	return (( digit >= '0' ) && ( digit <= '9' ));
 }
 
 
-// get the amount of installed RAM
-int QuerySystemRAM( void )
-{
-_asm {
-	int	12h		; get RAM size from BIOS
-}
+/*
+ * Get a string from the Desktop Management Interface or System Management BIOS
+ */
+typedef struct DMIStructureTableHeader {
+	BYTE  header[5];		// _DMI_
+	BYTE  checksum;			// checksum of DMI BIOS Header Structure
+	WORD  len;			// Total Length of DMI BIOS Structure Table
+	DWORD biosStructureTableAddress;// 32 bit physical address of beginning of byte aligned DMI structure table
+	WORD  numStructures;		// Total number of structures within the DMI Structure table
+	BYTE  DMIBiosRevision;		// Revision of the DMI BIOS Extensions
+} DMIStructureTableHeader;
+
+typedef struct DMIHeader {
+	BYTE  type;
+	BYTE  length;
+	WORD  handle;
+} DMIHeader;
+
+char _far * GetDMIstring( BYTE nType, int nStrNum )
+{
+	DMIStructureTableHeader _far *fpDMIHeader;
+	DWORD _far *fpPNPHeader;
+	char _far *p;
+	WORD wSegment, i;
+	int n;
+
+	for ( wSegment = 0xF000; wSegment /* wraparound? */; wSegment++ ) {
+		if (*( fpPNPHeader = (DWORD _far *)MK_FP(wSegment, 0 )) == 0x494D445F ) { // _DMI
+			BYTE nCkSum = 0; // _DMI_ is validated by a 0 sum of bLength bytes
+			for ( i = 0; i < sizeof(DMIStructureTableHeader); i++ )
+				nCkSum += *(( BYTE _far * )fpPNPHeader + i );
+			if ( !nCkSum )  // If checksum passed, we got it
+				break;
+		}
+	}
+	if ( wSegment ) {
+		fpDMIHeader = ( DMIStructureTableHeader _far * )fpPNPHeader;
+
+		// convert 32-bit physical address to segment:offset address
+		p = (char _far *)(((( fpDMIHeader->biosStructureTableAddress ) >> 4 ) << 16 ) + ( fpDMIHeader->biosStructureTableAddress & 0xFUL ));
+
+		for ( i = 0; i < fpDMIHeader->numStructures; i++, p++ ) {
+			DMIHeader _far *fpHdr = ( DMIHeader _far * )p;
+			p += fpHdr->length; // go to start of string space, if any
+			for ( n = 1; *p; n++, p++ ) {
+				if ( fpHdr->type == nType && n == nStrNum )
+					return p;
+				while ( *p )
+					p++;
+			}
+		}
+	}
+	return "";
 }
 
 
@@ -786,6 +857,8 @@
 }
 
 
+#pragma alloc_text( _TEXT, SetDateTime )
+
 // Set the current date & time
 int SetDateTime( DATETIME *sysDateTime )
 {
@@ -846,7 +919,7 @@
 		uDate = sysDateTime->day + ( sysDateTime->month << 5 ) + (( sysDateTime->year - 1980 ) << 9 );
 		uTime = ( sysDateTime->seconds / 2 ) + ( sysDateTime->minutes << 5 ) + ( sysDateTime->hours << 11 );
 
-		if ( fWin95 ) {
+		if ( ifs_type( pszFilename )) {
 		    if ( fField == 1 )
 			nFunction = 0x5705;
 		    else if ( fField == 2 )
@@ -900,6 +973,34 @@
 }
 
 
+// Get total file size in 64 bits; return 0 if OK or !0 if file doesn't exist
+int QueryFileSize64( char *fname, int fAllocated, t_int64 *size )
+{
+	int fval = FIND_FIRST;
+	FILESEARCH dir;
+	QDISKINFO DiskInfo;
+	char szFileName[MAXFILENAME];
+
+	strcpy( szFileName, fname );
+	if ( fAllocated )
+		QueryDiskInfo( szFileName, &DiskInfo, 0 );
+
+#ifdef NATIVE_INT64
+	for ( *size = 0; ( find_file( fval, szFileName, 0x07 | FIND_NO_ERRORS | FIND_NO_FILELISTS, &dir, NULL ) != NULL ); fval = FIND_NEXT ) {
+#else
+	for ( size->ulHighPart = size->ulLowPart = 0L; ( find_file( fval, szFileName, 0x07 | FIND_NO_ERRORS | FIND_NO_FILELISTS, &dir, NULL ) != NULL ); fval = FIND_NEXT ) {
+#endif
+		if ( fAllocated ) {
+		    if ( dir.ulSize > 0L )
+			Add32To64( size, (unsigned long)(( dir.ulSize + ( DiskInfo.ClusterSize - 1 )) / DiskInfo.ClusterSize ) * DiskInfo.ClusterSize );
+		} else
+		    Add32To64( size, dir.ulSize );
+	}
+
+	return ( fval == FIND_FIRST );
+}
+
+
 // get the current code page
 int QueryCodePage( void )
 {
@@ -942,6 +1043,38 @@
 }
 
 
+// get the current code page
+int QueryDeviceCodePage( LPTSTR device )
+{
+	int nFH;
+	static struct {
+		int length;
+		int codepage;
+	} parblk = { 2, 0 };
+
+	parblk.codepage = 0;
+	if ( gnOsVersion >= 330 ) {
+		if ( QueryIsCON( device ))
+			_asm	mov	ch,3
+		else if ( QueryIsPRN( device ))
+			_asm	mov	ch,5
+		else
+			return -1;
+		if (( nFH = _sopen( device, (_O_RDONLY | _O_BINARY), _SH_DENYNO )) >= 0 ) {
+			_asm {
+				mov	bx,nFH
+				mov	cl,6Ah
+				mov	ax,440Ch
+				lea	dx,parblk
+				int	21h
+			}
+			_close( nFH );
+		}
+	}
+	return parblk.codepage;
+}
+
+
 // call DOS to get the volume label
 char * QueryVolumeInfo( register char *arg, register char *volume_name, unsigned long *ulSerial )
 {
@@ -958,7 +1091,7 @@
 		return NULL;
 
 	// get the drive spec
-	szVolName[0] = (char)_ctoupper( *arg );
+	szVolName[0] = _ctoupper( *arg );
 
 	// get the serial number (local drives, DOS 4+ & OS/2 2.0 VDMs only)
 	if ( QueryDriveRemote( szVolName[0] - 64 ))
@@ -966,7 +1099,7 @@
 
 _asm {
 	cmp	_osmajor, 4
-	jb	dos_3
+	jb	dos_3		; @TODO!! for __WATCOMC__
 	mov	ax, 06900h	; int 21h 440Dh 66 call doesn't work in OS/2!
 	xor	bh, bh
 	mov	bl, byte ptr szVolName[0]
@@ -974,7 +1107,7 @@
 	xor	cx, cx
 	lea	dx, word ptr bpb
 	int	21h		; return serial # & volume info
-	jc	dos_3
+	jc	dos_3		; @TODO!! for __WATCOMC__
 }
 	*ulSerial = bpb.disk_serial_number;
 dos_3:
@@ -995,6 +1128,29 @@
 }
 
 
+// get drive type:
+// 0=unknown, 1=invalid, 2=removable, 3=fixed, 4=remote, 5=CD/DVD, 6:RAM disk
+int QueryDriveType( LPTSTR szDrv )
+{
+	BYTE _far *p;
+	int i = gcdisk( szDrv );
+
+	if ( !QueryDriveExists( i ))
+		return 1;
+	if ( QueryDriveRemovable( i ))
+		return 2;
+	if ( GetDrivePhysUnit( i ) > 0x7F )
+		return 3;
+	if ( QueryIsCDROM( i ))
+		return 5;
+	if ( QueryDriveRemote( i ))
+		return 4;
+	if ( QueryDriveReady( i ) && ( p = GetDPB( i )) && p[8] == 1 )
+		return 6;	// RAM disks should have only 1 FAT^
+	return 0;
+}
+
+
 // Check for ANSI - return 1 if loaded, 0 if absent
 int QueryIsANSI( void )
 {
@@ -1020,7 +1176,6 @@
 //	1 - LFN or other
 int ifs_type( char *drive )
 {
-	static char szSystemName[32];
 	char lszRoot[4];
 	unsigned int uRoot, uType;
 	int rval = 0;
@@ -1036,7 +1191,7 @@
 	// get the drive name (if no drive specified, get the default)
 	sprintf( lszRoot, FMT_ROOT, (gcdisk( drive ) + 64) );
 	uRoot = (UINT)lszRoot;
-	uType = (UINT)szSystemName;
+	uType = (UINT)gszFileSystemName;
 
 _asm {
 	mov	ax, 71A0h
@@ -1131,7 +1286,7 @@
 	mov	dx, di
 	mov	ax, 06000h
 	int	21h		; call true name function
-	jnc	true_bye
+	jnc	true_bye	; @TODO!! for __WATCOMC__
 }
 	strcpy( target, source );
 true_bye:
@@ -1213,7 +1368,7 @@
 // get the country code (for date formatting)
 void QueryCountryInfo( void )
 {
-	if (gnOsVersion >= 330 ) {
+	if (gnOsVersion >= 330 && ( gnOSFlags & DOS_OEM_ID ) >> 3 != 0xFC ) {
 _asm {
 		mov	ax, 06501h		; get international info
 		mov	bx, -1
@@ -1223,7 +1378,7 @@
 		pop	es
 		lea	di, gaCountryInfo
 		int	21h
-		jc	old_func
+		jc	old_func	; @TODO!! for __WATCOMC__
 }
 	} else {
 _asm {
@@ -1232,6 +1387,14 @@
 		lea	dx,gaCountryInfo
 		add	dx,7		; skip extended info
 		int	21h
+		mov	bx,dx
+		cmp	byte ptr [bx+7],0;PC-DOS 2.0 or 2.1?
+		jne	cntryOK		; no, done
+		mov	al,[bx+6]	; yes, move values to the new places
+		mov	[bx+9],al	; decimal separator
+		mov	al,[bx+4]
+		mov	[bx+7],al	; thousands separator
+cntryOK:
 }
 	}
 
@@ -1243,11 +1406,14 @@
 	else
 		gaCountryInfo.fsTimeFmt &= 1;
 
-	if ( gaCountryInfo.szThousandsSeparator[0] == '\0' ) {
+	if ( gaCountryInfo.szDecimal[0] == '\0' )
+		gaCountryInfo.szDecimal[0] = '.';
+	if ( gaCountryInfo.szThousandsSeparator[0] == '\0' )
 		gaCountryInfo.szThousandsSeparator[0] = ',';
+	if ( gaCountryInfo.szDateSeparator[0] == '\0' )
 		gaCountryInfo.szDateSeparator[0] = '-';
+	if ( gaCountryInfo.szTimeSeparator[0] == '\0' )
 		gaCountryInfo.szTimeSeparator[0] = ':';
-	}
 
 	if ( gpIniptr->DecimalChar )
 		gaCountryInfo.szDecimal[0] = (( gpIniptr->DecimalChar == 1 ) ? '.' : ',');
@@ -1268,29 +1434,6 @@
 }
 
 
-// map character to upper case (including foreign language chars)
-int _fastcall _ctoupper( int c )
-{
-	if ( c < 'a' )
-		return c;
-
-	if (( c >= 'a' ) && ( c <= 'z' ))
-		return ( c - 32 );
-
-	if (( c >= 0x80 ) && ( c <= 0xFF )) {
-
-_asm {
-		mov	ax, c
-		call	far ptr gaCountryInfo.case_map_func
-		xor	ah, ah
-		mov	c, ax
-}
-	}
-
-	return c;
-}
-
-
 // get various disk info (free space, total space, cluster size)
 int QueryDiskInfo( char *drive, QDISKINFO * DiskInfo, int fNoErrors )
 {
@@ -1316,12 +1459,22 @@
 		nDisk = gcdisk( drive );
 	}
 
+	// DOS functions 36h and 7303 return incorrect results for CD-/DVD-ROMs
+	if ( QueryIsCDROM( nDisk )) {
+		if (( Fat32.ExtFree_TotalClusters = CDIOctl( gcdisk( drive ), 8 )) == -1 )
+			goto QDFailure;
+		Fat32.ExtFree_SectorsPerCluster = 4;
+		Fat32.ExtFree_AvailableClusters = 0;
+		Fat32.ExtFree_BytesPerSector = 512;
+		goto QDBigDisk;
+	}
+
 	// If FAT32 info is available, use it
-	if ( gpIniptr->MSDOS7 ) {
+	if ( _osmajor >= 7 ) {
 
 		sprintf( szFAT32Drive, FMT_ROOT, (nDisk + 64) );
 		if (( Win95GetFAT32Info( szFAT32Drive, &Fat32, sizeof(FAT32)) == 0 ) && ( Fat32.ExtFree_BytesPerSector != 0L )) {
-
+QDBigDisk:
 			// get string equivalents (for > 4Gb drives)
 			sprintf( szBuf, "(%lu*%lu)*%lu", Fat32.ExtFree_BytesPerSector, Fat32.ExtFree_SectorsPerCluster, Fat32.ExtFree_TotalClusters );
 			evaluate( szBuf );
@@ -1406,7 +1559,7 @@
 	for ( i = 0; ( i <= 0xFFF ); i++ ) {
 
 		// create a temporary filename using the Random routine
-		sprintf( strend( buffer ), "%08lx.%03x", GetRandom( 0L, 0x7FFFFFFFL ), i);
+		sprintf( strend( buffer ), "%08lx.%03x", GetRandom(), i);
 
 		// try to create the temporary file
 		errno = 0;
@@ -1441,7 +1594,12 @@
 	mov	si, rval
 	int	21h
 	mov	rval, ax
-	jc	FT_Error
+	jnc	FT_OK
+	cmp	ax, ERROR_INVALID_DATA ; happens with DOSLFN but not with Win9x
+	jne	FT_Error	; another error - don't touch pusTime & pusDate
+	xor	cx, cx		; zero access or creation time is a common case
+	xor	dx, dx		; when Win9x returns CX = DX = 0, not an error!
+FT_OK:
 	mov	bx, pusTime
 	mov	[bx], cx
 	mov	bx, pusDate
@@ -1478,7 +1636,8 @@
 	register char *ptr;
 	char *pszFileName, *pszNext, *pszNamePart;
 	int rval, fval = fflag, i, mode, nPathLength, fWildBrackets = 0;
-	unsigned int uTime, uDate, fUnicode = 0, fWildcards = 1;
+	unsigned short uTime, uDate;
+	unsigned int fUnicode = 0, fWildcards = 1;
 	unsigned long ulDTRange;
 	WIN32_FIND_DATA *pWin95Dir;
 
@@ -1587,7 +1746,7 @@
 		//   wildcards (for example: "*m*s*.*d*").  MS-DOS & PC-DOS
 		//   handle them all right (by ignoring them!), but DR-DOS doesn't.
 		//   (MS-DOS 7 (in Win95) supports the extended wildcard syntax)
-		if ( fWin95 == 0 ) {
+		if ( dir->fLFN == 0 ) {
 
 		    for ( ; (( ptr = strchr( ptr, '*' )) != NULL ); ) {
 
@@ -1864,13 +2023,15 @@
 }
 
 
+#pragma alloc_text( _TEXT, strupr )
+
 // map string to upper case (including foreign language chars)
 char * strupr( char *pszSource )
 {
 	register char *arg;
 
 	for ( arg = pszSource; (*arg != '\0' ); arg++)
-		*arg = (char)_ctoupper( *arg );
+		*arg = _ctoupper( *arg );
 
 	return pszSource;
 }
diff -Nu d:7.501/doscmds.c SOURCES/doscmds.c
--- d:7.501/doscmds.c	2006-11-12 16:00:50 +0200
+++ SOURCES/doscmds.c	2009-02-26 17:13:44 +0200
@@ -47,8 +47,8 @@
 #include <string.h>
 
 #include "4all.h"
+#include "idle.h"
 
-static int _near SetKeystack( int, char * );
 static int _near _lock( int );
 static int _near _unlock( int );
 
@@ -205,9 +205,6 @@
 
 	} else {		// setting new break status
 
-		if ( *pszCmdLine == '=' )
-			pszCmdLine++;
-
 		if (( argc = OffOn( pszCmdLine )) == -1 )
 			return ( Usage( BREAK_USAGE ));
 _asm {
@@ -221,6 +218,22 @@
 }
 
 
+int _near Closetray_Cmd( char *pszCmdLine )
+{
+	register int i;
+	int rval = 0;
+	char *arg;
+
+	if (( pszCmdLine == NULL ) || ( *pszCmdLine == '\0' )) { // no arguments
+		if ( CDIOctl( 0, 5 ) == -1 )		  // - close first drive
+			rval = error( ERROR_4DOS_CANT_CLOSE, NULL );
+	} else for ( i = 0; (( arg = ntharg( pszCmdLine, i )) != NULL ); i++ )
+		if ( CDIOctl( gcdisk( arg ), 5 ) == -1 )// close specified drive(s)
+			rval = error( ERROR_4DOS_CANT_CLOSE, arg );
+	return rval;
+}
+
+
 // clear the screen (using ANSI or BIOS calls), with optional color set
 int _near Cls_Cmd( char *pszCmdLine )
 {
@@ -311,6 +324,47 @@
 }
 
 
+// enable/disable dynamic idle detection (DR DOS only)
+// see "Implementing Power Management (BatteryMAX) in DR-DOS" for details
+int _near Idle_Cmd( LPTSTR pszCmdLine )
+{
+	struct _idle_state _far *idle = GetIdlePtr();
+
+	// don't be surprised: all DR DOS boolean names are reversed!
+	if ( idle->flags & IDLE_ENABLE )
+		return error( ERROR_4DOS_IDLE_DISABLED, NULL );
+	if ( pszCmdLine == NULL || *pszCmdLine == '\0' )
+    		printf( IDLE_IS, idle->flags & IDLE_ON ? OFF : ON );
+	else switch ( OffOn( pszCmdLine )) {
+		case 1:
+			idle->flags &= ~IDLE_ON;
+			break;
+		case 0:
+			idle->flags |= IDLE_ON;
+			break;
+		default:
+			return Usage( IDLE_USAGE );
+	}
+	return 0;
+}
+
+
+int _near Ejectmedia_Cmd( char *pszCmdLine )
+{
+	register int i;
+	int rval = 0;
+	char *arg;
+
+	if (( pszCmdLine == NULL ) || ( *pszCmdLine == '\0' )) { // no arguments
+		if ( CDIOctl( 0, 0 ) == -1 )		  // - eject first drive
+			rval = error( ERROR_4DOS_CANT_EJECT, NULL );
+	} else for ( i = 0; (( arg = ntharg( pszCmdLine, i )) != NULL ); i++ )
+		if ( CDIOctl( gcdisk( arg ), 0 ) == -1 )// eject specified drive(s)
+			rval = error( ERROR_4DOS_CANT_EJECT, arg );
+	return rval;
+}
+
+
 // exit the current shell
 int _near Exit_Cmd( char *pszCmdLine )
 {
@@ -328,13 +382,15 @@
 
 		// watch out for EXITs inside 4EXIT!
 		if ( fExit++ == 0 )
-			find_4files( AUTOEXIT );
+			find_4files( AUTOEXIT, 0 );
 
+#ifdef SHAREWARE_VERSION
 		// ensure shareware data is written
 		if ( gfShareware && gfSharewareDataRead ) {
 			AccessSharewareData( &SharewareData, 1 );
 			AccessSharewareDup( &SharewareData, 1 );
 		}
+#endif
 
 		ServCtrl( SERV_QUIT, nRet );
 	}
@@ -401,20 +457,6 @@
 }
 
 
-// transfer the string to KSTACK.COM through an INT 2Fh
-
-static int _near SetKeystack( int nLength, char *buf )
-{
-_asm {
-	mov	ax, 0D44Fh		; call KSTACK & load the KSTACK buffer
-	mov	bx, 1
-	mov	cx, nLength
-	mov	dx, [buf]
-	int	2Fh
-}
-}
-
-
 // pump characters from a keyboard buffer into a program
 int _near Keystack_Cmd( char *pszCmdLine )
 {
@@ -448,7 +490,7 @@
 	arg = _alloca( strlen( pszCmdLine ) + 1 );
 	strcpy( arg, pszCmdLine );
 
-	for ( kptr = (int *)gszCmdline; ( *arg != '\0' ); ) {
+	for ( kptr = (unsigned *)gszCmdline; ( *arg != '\0' ); ) {
 
 		argc = 1;
 
@@ -531,9 +573,19 @@
 	}
 
 	// send the buffer to KSTACK
-	if ( SetKeystack( (int)( (char *)kptr - gszCmdline ) / 2, gszCmdline ) != 0 )
-		return ( error( ERROR_4DOS_NO_KEYSTACK, NULL ));
-
+	_asm {
+		mov	ax,0D44Fh	; call KSTACK & load the KSTACK buffer
+		mov	bx,1
+		mov	cx,kptr
+		mov	dx,offset gszCmdline
+		sub	cx,dx
+		shr	cx,1		; cx = ( (char *)kptr - gszCmdline ) / 2
+		int	2Fh
+		or	ax,ax
+		jz	OK		; @TODO!! for __WATCOMC__
+	}
+	return ( error( ERROR_4DOS_NO_KEYSTACK, NULL ));
+OK:
 	return 0;
 }
 
@@ -671,7 +723,7 @@
 		// if no arguments, lock everything
 		for ( nDisk = 1; ( nDisk <= 26 ); nDisk++ ) {
 			sprintf( szDisk, "%c:", nDisk+64 );
-			if (( QueryDriveExists( nDisk ) == 0 ) || ( QueryDriveRemote( nDisk ) == 1 ) || ( QueryIsCDROM( szDisk ) == 1 ))
+			if (( QueryDriveExists( nDisk ) == 0 ) || ( QueryDriveRemote( nDisk ) == 1 ) || ( QueryIsCDROM( nDisk ) == 1 ))
 				continue;
 			if (( argc = _lock( nDisk )) != 0 )
 				rval = error( argc, szDisk );
@@ -828,22 +880,41 @@
 }
 
 
-// reboot the system (warm or cold boot)
+// reboot the system (warm or cold boot) or turn it off
 int _near Reboot_Cmd( char *pszCmdLine )
 {
-	int nBootType;
+	char chBootType;
+	int nFH;
 	long fReboot;
-	char _far *reboot_offset = (char _far *)(0xF000FFF0L);
 
-	// check for /C(old boot) or /V(erify) switches
-	if ( GetSwitches( pszCmdLine, "CV", &fReboot, 0 ) != 0 )
+	// check for: C)old boot, V)erify, P)ower off, M)onitor off, S)uspend
+	if ( GetSwitches( pszCmdLine, "CVPMS", &fReboot, 0 ) != 0 )
 		return ( Usage( REBOOT_USAGE ));
 
-	if (( fReboot & 2 ) && ( QueryInputChar( REBOOT_IT, YES_NO ) != YES_CHAR ))
+	chBootType = (int)fReboot;
+
+	if (( chBootType & 2 ) && ( QueryInputChar( chBootType & 16 ? ENTER_STANDBY : ( chBootType & 8 ? TURN_MONITOR_OFF : ( chBootType & 4 ? SHUT_IT_DOWN : REBOOT_IT )), YES_NO ) != YES_CHAR ))
 		return 0;
 
+	if ( chBootType & 24 ) {	// monitor off and/or system suspend
+		SysWait( 2, 0 );	// wait 2 seconds for floppy motor off
+		if ( chBootType & 8 ) {	// monitor off
+			MonitorOnOff( 4 );	// display off
+			if ( chBootType & 16 )	// system suspend
+				SetPowerState( 2 );
+			else
+				GetKeystroke( EDIT_NO_ECHO | EDIT_BIOS_KEY | EDIT_MOUSE_BUTTON );
+			MonitorOnOff( 0 );	// display on
+		} else
+			SetPowerState( 2 );	// system suspend
+		return 0;
+	}
+
 	// run 4EXIT
-	find_4files( AUTOEXIT );
+	find_4files( AUTOEXIT, 0 );
+
+	// flush any SMARTDRV and compatible disk caches
+	SDFlush();
 
 	// flush the disk buffers & reset disks for nitwits like FASTOPEN
 	reset_disks();
@@ -851,35 +922,29 @@
 	// wait 2 seconds for caches to flush
 	SysWait( 2L, 0 );
 
-	nBootType = (int)fReboot;
-
-_asm {
-	and	nBootType, 1		; check for cold boot
-	jz	warm_boot		;   do a warm boot
+	if ( chBootType & 4 ) {	// power off
+		SetPowerState( 3 );
+		if ( !(chBootType & 1 ) )//unsuccessful power off
+		return ERROR_EXIT;	// if /C also specified, do a cold boot
+	}
+	// set POST reset flag according to boot type
+	*((int _far *)0x472L) = chBootType & 1 ? 0 : 0x1234;
 
-	call	get_cpu			; get CPU type - XTs have different
-					;   keyboard controller
-	xor	dx,dx			; write a 0 to 0000:0472
-	cmp	ax,286
-	jb	not_AT
-	cli
-	xor	al,al			; clear DMA page port
-	out	080h, al		; clear mfg port
-	mov	al,0FEh			; cold boot (through keyboard reset)
-	out	064h,al			;   (because QEMM & MAX intercept boot)
-	nop
-        jmp     short not_AT
-
-warm_boot:
-	mov	dx,01234h
-not_AT:
-	xor	ax,ax
-	mov	es,ax
-	mov	word ptr es:[0472h],dx
-	jmp	[reboot_offset]		; reboot
+	if (( gnOSFlags & DOS_IS_OS2 ) && ( nFH = _sopen ( "DOS$", _O_RDWR | _O_BINARY, _SH_DENYNO )) > 0 )
+		RebootOS2( nFH );
+	if ( fWin95 )
+		RebootW9x( );
+	Reboot( chBootType );		// do a "soft" or "hard" reset
 }
 
-	return ERROR_EXIT;
+
+// set extended error information (DOS 3.1+)
+int _near Seterror_Cmd( LPTSTR pszCmdLine )
+{
+	if ( !pszCmdLine || *pszCmdLine == _TEXT('\0') || !isdigit( *pszCmdLine ))
+		return Usage( SETERROR_USAGE );
+	SetExtError( _doserrno = gnErrorLevel = atoi( pszCmdLine ));
+	return 0;
 }
 
 
@@ -1329,7 +1394,7 @@
 		// if no arguments, unlock everything
 		for ( nDisk = 1; ( nDisk <= 26 ); nDisk++ ) {
 			sprintf( szDisk, "%c:", nDisk+64 );
-			if (( QueryDriveExists( nDisk ) == 0 ) || ( QueryDriveRemote(nDisk) == 1) || (QueryIsCDROM( szDisk ) == 1))
+			if (( QueryDriveExists( nDisk ) == 0 ) || ( QueryDriveRemote( nDisk ) == 1) || (QueryIsCDROM( nDisk ) == 1))
 				continue;
 			if (( argc = _unlock( nDisk )) != 0 )
 				rval = error( argc, szDisk );
@@ -1355,34 +1420,16 @@
 	extern int fWin98;
 	extern int fWinME;
 	long lVerFlags;
-	char *pszOS;
 
 	if (( lVerFlags = switch_arg( pszCmdLine, "R" )) < 0 )
 		return ( Usage( VER_USAGE ));
 
-	if ( gnOSFlags & DOS_IS_DR ) {
-		pszOS = (( gchMajor >= 7 ) ? NOVVER : DRVER );
-	} else if ( gnOSFlags & DOS_IS_OS2 )
-		pszOS = OS2VER;
-	else if ( fWinME )
-		pszOS = MSMEVER;
-	else if ( fWin98 )
-		pszOS = MS98VER;
-	else if ( fWin95 )
-		pszOS = MS95VER;
-	else
-		pszOS = MSVER;
-
-	if (( gnOSFlags & DOS_IS_OS2 ) && ( _osmajor == 20 ) && ( _osminor >= 30 )) {
-		char chOS2Major = (( _osminor >= 40 ) ? 4 : 3 );
-		printf( DOS_VERSION, PROGRAM, WARPVER, chOS2Major, gaCountryInfo.szDecimal[0], ( _osminor - ( 10 * chOS2Major )));
-	} else
-		printf( DOS_VERSION, PROGRAM, pszOS, gchMajor, gaCountryInfo.szDecimal[0], gchMinor );
+	ShowOS();
 
 	// display version info (Rev level, & whether in HMA or ROM)
 	if ( lVerFlags == 1 ) {
 
-		printf( FOURDOS_REV, VER_BUILD );
+		printf( FOURDOS_REV, VER_BUILD, __DATE__ );
 
 		// DR-DOS doesn't have an internal revision number
 		if (( gnOSFlags & DOS_IS_DR ) == 0 ) {
@@ -1397,8 +1444,10 @@
 
 		crlf();
 
+#ifdef SHAREWARE_VERSION
 		// display serial number (brand) info
 		TestBrand( 0 );
+#endif
 	}
 
 	return 0;
diff -Nu d:7.501/dosinit.c SOURCES/dosinit.c
--- d:7.501/dosinit.c	2006-11-12 16:00:50 +0200
+++ SOURCES/dosinit.c	2008-11-04 15:03:24 +0200
@@ -46,14 +46,78 @@
 
 int fWin98 = 0;
 int fWinME = 0;
+static int fWarp = 0;
+
+// set OS brand name (called even with 4DOS /C to allow getting %_DOS)
+static void SetOSname( void )
+{
+	char *pszOS;
+
+	if ( gnOSFlags & DOS_IS_DR ) {
+		// if gchMajor >= 7, OEM ID = 0 for Novell and Caldera and EEh for EDR-DOS
+		pszOS = gchMajor == 7 && gchMinor <= 1 && !( gnOSFlags & DOS_OEM_ID ) ? NOVVER : DRVER;
+	} else if ( gnOSFlags & DOS_IS_OS2 )
+		pszOS = OS2VER;
+	else if ( fWinME )
+		pszOS = MSMEVER;
+	else if ( fWin98 )
+		pszOS = MS98VER;
+	else if ( fWin95 )
+		pszOS = MS95VER;
+	else switch (( gnOSFlags & DOS_OEM_ID ) >> 3 ) {
+		case 0:
+			pszOS = IBMVER;
+			break;
+		case 0x44:
+			pszOS = WENVER;
+			break;
+		case 0x5E:
+			pszOS = RXVER;
+			break;
+		case 0x66:
+			pszOS = PTSVER;
+			break;
+		case 0x98:
+			pszOS = GSVER;
+			break;
+		case 0xCD:
+			pszOS = SDVER;
+			break;
+		case 0xDB:
+			pszOS = RDVER;
+			break;
+		case 0xFC:
+			pszOS = XDVER;
+			break;
+		case 0xFD:
+			pszOS = FDVER;
+			break;
+		case 0xFE:
+			pszOS = LZVER;
+			break;
+		case 0xFF:
+			pszOS = MSVER;
+			break;
+		default:
+			pszOS = UNKVER;
+	}
+	if (( gnOSFlags & DOS_IS_OS2 ) && _osmajor == 20 && _osminor >= 30 ) {
+		fWarp = TRUE;
+		pszOSname = WARPVER;
+	} else
+		pszOSname = pszOS;
+}
+
 
 void _near InitOS( int argc, char **argv )
 {
 	register char *arg;
 	int fMSDOS7 = (int)(gpIniptr->MSDOS7);
+	int nologo = 0;
 	char szMSDOS[16];
 	char szPassedLine[CMDBUFSIZ+1];
 
+	gnCPU = get_cpu();
 	Win95DisableClose();
 
 	// reduce malloc() block size
@@ -81,6 +145,14 @@
 	GetDOSVersion();
 	gnOsVersion = ( _osmajor * 100 ) + _osminor;
 
+	if (!(gnOSFlags & DOS_IS_OS2 ) && !( gpIniptr->WinMode )) {
+		int i = 100;
+		while ( i-- )			// idea from Borland's delay()
+			if ( GetTimer() & 1 )	// odd value (in mode 2 only)?
+				goto setenv;	// already mode 2, skip setting
+		SetTimerMode2();		// setting can take up to 55 ms
+	}					// but GetTimer requires mode 2
+setenv:
 	glpEnvironment = MAKEP( gpIniptr->EnvSeg, 0 );
 
 	// point to the master environment (created in ServInit)
@@ -106,9 +178,12 @@
 	// Reset internal LFN / SFN flags
 	SetWin95Flags();
 
-	// disable START if not OS/2 2+
-	if ( _osmajor < 20 )
+	// if not OS/2 2+, disable START (and also TITLE if not Win95)
+	if ( _osmajor < 20 ) {
 		commands[ findcmd( "START", 1 )].fParse |= CMD_DISABLED;
+		if ( !fWin95 )
+			commands[ findcmd( "TITLE", 1 )].fParse |= CMD_DISABLED;
+	}
 
 	// (Undocumented: Win95's COMMAND.COM looks for WINBOOT.INI first,
 	//   then for MSDOS.SYS)
@@ -126,10 +201,17 @@
 		commands[ findcmd( "UNLOCK", 1 ) ].fParse |= CMD_DISABLED;
 	}
 
+	// if not DR DOS 5.0+, disable IDLE
+	if (!( gnOSFlags & DOS_IS_DR ) || gchMajor < 5 )
+		commands[ findcmd( "IDLE", 1 ) ].fParse |= CMD_DISABLED;
+
 	// set the current drive
 	if (( gnCurrentDisk = _getdrive()) < 0 )
 		gnCurrentDisk = 0;
 
+	if (( arg = gcdir( NULL, TRUE )) != NULL ) // set the startup directory
+		strcpy( gszStartPath, arg );
+
 	SetCurSize( );		// set the default cursor shape
 
 	// get the international format chars (for PROMPT)
@@ -191,6 +273,10 @@
 
 				break;
 
+			case 'K':	// undocumented COMMAND.COM behaviour
+				nologo = 1;
+				break;
+
 			case 'P':	// permanent load in 4DOS
 
 				gpIniptr->ShellLevel = 0;
@@ -222,11 +308,12 @@
 	SetCurSize( );
 
 	// enable ^C and ^BREAK handling
-	ServCtrl( SERV_SIGNAL, (unsigned int)BreakHandler );
+	ServCtrl( SERV_SIGNAL, (int)(long)BreakHandler );
 	ServCtrl( SERV_SIGNAL, SERV_SIG_ENABLE );
 
 	// if non-transient, display signon message & test user brand
-	if ( gnTransient == 0 )
+	SetOSname();
+	if ( gnTransient == 0 && nologo == 0 )
 		DisplayCopyright();
 
 	// set LogFileName
@@ -252,12 +339,9 @@
 }
 	}
 
-	// turn off single-step unless we're in a nested batch file
-	if ( cv.bn < 0 )
-		gpIniptr->SingleStep = 0;
-
-	// execute 4START.BTM / 4START.BAT / 4START.CMD
-	find_4files( AUTOSTART );
+	// execute _4INST.BTM or if not found, 4START.BTM/4START.BAT/4START.CMD
+	if ( find_4files( AUTOINST, 1 ) == NULL )
+		find_4files( AUTOSTART, 0 );
 
 	// execute AUTOEXEC.BAT if we're in the root shell
 	if (( gpIniptr->ShellLevel == 0 ) && ( gpIniptr->AEPath != INI_EMPTYSTR )) {
@@ -290,7 +374,7 @@
 			strcat( gszCmdline, (gpIniptr->StrData + gpIniptr->AEParms));
 		}
 
-		command( gszCmdline, ( gnTransient == 0 ));
+		command( gszCmdline, 0 );
 	}
 
 	// check for BootGUI=1 in MSDOS.SYS (or WINBOOT.INI) in Win95
@@ -327,26 +411,24 @@
 }
 
 
+// print OS brand string
+void _near ShowOS( void )
+{
+	if ( fWarp ) {
+		char chOS2Major = _osminor >= 40 ? 4 : 3;
+		char chOS2Minor = ( _osminor - 10 * chOS2Major ) * ( chOS2Major == 4 ? 10 : 1 );
+		printf( DOS_VERSION, PROGRAM, pszOSname, chOS2Major, gaCountryInfo.szDecimal[0], chOS2Minor );
+	} else
+		printf( DOS_VERSION, PROGRAM, pszOSname, gchMajor, gaCountryInfo.szDecimal[0], gchMinor );
+}
+
+
 // display copyright / beta test message & test brand
 void DisplayCopyright( void )
 {
 	char MsgBuf[256];
-	char *pszOS;
-
-	if ( gnOSFlags & DOS_IS_DR ) {
-		pszOS = (( gchMajor >= 7 ) ? NOVVER : DRVER );
-	} else if ( gnOSFlags & DOS_IS_OS2 )
-		pszOS = OS2VER;
-	else if ( fWinME )
-		pszOS = MSMEVER;
-	else if ( fWin98 )
-		pszOS = MS98VER;
-	else if ( fWin95 )
-		pszOS = MS95VER;
-	else
-		pszOS = MSVER;
 
-	printf( DOS_VERSION, PROGRAM, pszOS, gchMajor, gaCountryInfo.szDecimal[0], gchMinor );
+	ShowOS();
 
 	printf( DecodeMsg( SEC_COPYRIGHT, MsgBuf ));		// copyright
 	crlf();
diff -Nu d:7.501/dostty.c SOURCES/dostty.c
--- d:7.501/dostty.c	2006-11-12 16:00:50 +0200
+++ SOURCES/dostty.c	2008-12-18 11:09:24 +0200
@@ -57,8 +57,11 @@
 		fClose = ( Win95EnableClose() == 0 );
 
 		nButton = 0;
-		while ( _kbhit() == 0 ) {
-
+#ifdef __WATCOMC__
+		while (( eflag & EDIT_BIOS_KEY ? bios_kbhit() : _kbhit() ) == 0 ) {
+#else
+		while (( eflag & EDIT_BIOS_KEY ? bios_kbhit : _kbhit )() == 0 ) {
+#endif
 			// check for mouse button pressed
 			if ( eflag & EDIT_MOUSE_BUTTON ) {
 
@@ -69,6 +72,8 @@
 					return RIGHT_MOUSE_BUTTON;		// right button
 				if ( nButton & 4 )
 					return MIDDLE_MOUSE_BUTTON;		// middle button
+				if ( nButton >>= 8 )
+					return nButton < 0 ? WHEEL_UP : WHEEL_DOWN;
 			}
 
 			if (( fClose ) && ( Win95QueryClose() == 0 )) {
@@ -153,8 +158,17 @@
 // return the current number of screen rows (make it 0 based)
 unsigned int GetScrRows( void )
 {
+#ifdef __WATCOMC__
+	unsigned rc;
+#endif
+	
 	if ( gpIniptr->Rows != 0 )
+#ifdef __WATCOMC__
+		rc = gpIniptr->Rows - 1;
+	else {
+#else
 		return ( gpIniptr->Rows - 1 );
+#endif
 
 _asm {
         push    bx
@@ -171,19 +185,36 @@
 	xor	ch,ch
 	mov	cl,es:[0484h]		; yes, so get rows from BIOS data area
 not_vga:
+#ifdef __WATCOMC__
+	mov	rc,cx
+#else
 	mov	ax,cx
+#endif
         pop     bx
 }
+#ifdef __WATCOMC__
+	}
+	return rc;
+#endif
 }
 
 
 // return the current number of screen columns
 unsigned int GetScrCols( void )
 {
+#ifdef __WATCOMC__
+	unsigned rc;
+#endif
+	
 	// get the number of columns from the BIOS data area
 	//   (TI Professionals return 0!)
 	if ( gpIniptr->Columns != 0 )
+#ifdef __WATCOMC__
+		rc = gpIniptr->Columns;
+	else {
+#else
 		return gpIniptr->Columns;
+#endif
 _asm {
 	xor	ax,ax
 	mov	es,ax
@@ -192,7 +223,14 @@
 	jnz	not_ti_pro
 	mov	ax,80
 not_ti_pro:
+#ifdef __WATCOMC__
+	mov	rc,ax
+#endif
 }
+#ifdef __WATCOMC__
+	}
+	return rc;
+#endif
 }
 
 
@@ -260,7 +298,7 @@
 
 int PASCAL keyparse( char _far *keystr, int klen )
 {
-	extern void _far _KeyParse( void );
+	extern void _cdecl _far _KeyParse( void );
 
 	int rval = -1;
 
@@ -284,10 +322,19 @@
 // resets mouse - returns non-zero if mouse installed
 int MouseReset( void )
 {
+	_asm {
+		mov	ax,3533h
+		push	es
+		int	21h
+		mov	ax,es
+		pop	es
+		or	ax,bx	; Int 33h vector zero?
+		jz	NoMouse	; if so, don't call it even if user asks so!
+	}
 	if ( gpIniptr->Mouse == 1 )
 		fMousePresent = 1;
 	else if ( gpIniptr->Mouse == 2 )
-		fMousePresent = 0;
+NoMouse:	fMousePresent = 0;
 	else {
 _asm {
 		mov	ax, 0
diff -Nu d:7.501/dosumb.asm SOURCES/dosumb.asm
--- d:7.501/dosumb.asm	2006-11-12 16:00:50 +0200
+++ SOURCES/dosumb.asm	2007-09-18 00:01:58 +0200
@@ -204,7 +204,7 @@
 ;mov dx,offset msg_02
 ;calldos message
 ;popm ds,dx,ax
-          mov       cl,HFIRST + FIRSTFIT  ;set for first fit in high mem
+          mov       cl,HFIRST + BESTFIT ;set for best fit in high mem
           or        ch,ch               ;check function code
           jnz       LUTry               ;if it's link go on
           mov       bx,ULINKOFF         ;get value to clear UMB links
diff -Nu d:7.501/dosutil.asm SOURCES/dosutil.asm
--- d:7.501/dosutil.asm	2006-11-12 16:00:50 +0200
+++ SOURCES/dosutil.asm	2009-02-26 17:05:00 +0200
@@ -71,11 +71,19 @@
           extrn     __osminor:byte	; DOS minor version number
           extrn     _gchMajor:byte	; "Real" version numbers
           extrn     _gchMinor:byte
+          extrn     _gnOsVersion:word	; Decimal DOS version number
+          extrn     _gaCountryInfo:CTRYINFO
+          extrn     _gnCPU:word         ; CPU (86, 186, 286, 386, etc.)
           extrn     _gnOSFlags:word     ; O/S status flags
           extrn     _gpIniptr:word      ; INI file data pointer
           extrn     _gszCmdline:byte    ; parser's command line buffer
 
 emm_name  db        'EMMXXXX0'          ; name of EMS driver
+qemm_dev  db        'QEMM386$',0        ; name of QEMM driver
+
+code37h   db        74h,7,3Ch,2,0B2h,0FFh,74h,1,0C3h; MS-DOS Fn 37h code:
+code37len equ       $-code37h           ; jz $+9/cmp al,2/mov dl,-1/jz $+3/ret
+          even
 StatusNDP dw        ?                   ; address of NDP control word
 
 SaveESP   dd        ?
@@ -99,7 +107,35 @@
           db        04h, 3, 41          ;1064 or below is DR-DOS 3.41
           db        05h, 5, 00          ;1065 is DR-DOS 5.00
           db        11h, 6, 00          ;1071 or below is DR-DOS 6.00
-          db        1Fh, 7, 00          ;107F or below is Novell DOS 7.00
+          db        12h, 7, 01          ;1072 is Novell DOS 7 or OpenDOS 7.01
+          db        13h, 7, 03          ;1073 is DR-DOS 7.02 or 7.03
+          db        1Fh, 8, 00          ;1074 is DR-DOS 8.0
+
+ IOCTL_INPUT	equ	 3
+ IOCTL_OUTPUT	equ	12
+  OPEN_COMMAND	equ	 0
+ CLOSE_COMMAND	equ	 5
+STATUS_COMMAND	equ	 6
+  SIZE_COMMAND	equ	 8
+          ;
+          ; Device driver request header + data
+          ;
+ReqData	struc
+          slength   db	?
+          subunit   db	?
+          command   db	?
+          status    dw	?
+          reserved  db	8 dup (?)
+          media_id  db	?
+          d_offset  dw	?
+          d_segment dw	?
+          bytes     db	?
+          function  db	?
+          cdstatus  dd	?
+ReqData	ends
+
+ReqHdr	ReqData	<18,0,IOCTL_OUTPUT,100h,'RESERVED',0,offset ReqHdr.function,_DATA,1,0,0>
+
 
 	;
 	; In DOS, references are in various segments; code is in MISC_TEXT
@@ -132,7 +168,36 @@
 	;
 	;==================================================================
 
-	;
+          ;
+          ; _ctoupper: map character to upper case (including NLS chars)
+          ;
+          ; On entry:
+          ;         AX = character to convert
+          ;
+          ; On exit:
+          ;         AX = converted character
+          ;         All other registers unchanged, interrupts on
+          ;
+
+          public    _ctoupper_	; __WATCOMC__
+_ctoupper_ label    far		; _fastcall
+          entry     @_ctoupper,noframe,far
+          or        ah,ah		; extended character?
+          jnz       c2upret		; yes, return
+          cmp       al,'a'		; no, upper case or other?
+          jb        c2upret		; yes, return
+          cmp       al,'z'		; no, lower case?
+          ja        c2upnls		; no, see if NLS character
+          and       al,11011111b	; yes, convert to upper case
+          jmp       short c2upret	; return
+c2upnls:  or        al,al		; ASCII?
+          jns       c2upret		; yes, return
+          cmp       _gnOsVersion,211	; no, DOS 2.11+?
+          jb        c2upret		; no, return
+          call      _gaCountryInfo.CY_CFUNC; yes, convert NLS character
+c2upret:  exit
+
+          ;
           ; QuerySwitchChar - get the current DOS switch character
           ;
           ; On exit:
@@ -152,6 +217,61 @@
 
           exit
 
+
+          ; SetSwitchChar - set the current DOS switch character
+          ;
+          ; On entry:
+          ;         Arguments on stack:
+          ;           char SwitchChar
+          ;
+          ; On exit:
+          ;         AX, DX destroyed
+          ;         All other registers unchanged, interrupts on
+          ;
+
+          entry     SetSwitchChar,argframe,far
+          argB      SwitchChar
+          push      cx
+          push      si
+          push      di
+          push      es                  ;save all used registers but ax and dx
+          mov       ax,3701h
+          mov       dl,SwitchChar       ;try to set the switchar the normal way
+          calldosW
+          mov       ax,3700h            ;now verify that it was really accepted
+          calldosW                      ;or just coincides with the current one
+          cmp       dl,SwitchChar       ;do the requested and actual one match?
+          je        SetSwChret          ;if so return, else do it the hard way!
+          mov       dx,_gnOSFlags       ;Patch the Fn 37h code for MS-DOS 5.0+:
+          shln      dh,4,cl             ; shift HMA bit (4) to CF
+          sbb       ax,ax               ; -1 if DOS in HMA, 0 otherwise
+          mov       es,ax               ; search segment
+          xor       di,di               ; start from its beginning
+          mov       cx,0FFFFh           ; search it all
+          mov       al,code37h          ; for the start of the Fn 37h code
+SearchCod:repne     scasb               ; do the search; first byte found?
+          jne       SetSwChret          ; no, return
+          push      di                  ; yes, save pointer
+          push      cx                  ; save counter
+          mov       cx,code37len-1      ; count from the second to last byte
+          mov       si,offset code37h+1 ; point to the second byte
+          repe      cmpsb               ; search for the rest of code 
+          pop       cx                  ; restore counter
+          pop       di                  ; restore pointer; found?
+          jne       SearchCod           ; if not, keep searching
+          cmp       word ptr es:[di-4],0B2C0h; C0=[or] al,al; B2=mov dl,['/']
+          jne       SearchCod           ; previous 2 bytes don't match (hardly)
+          mov       al,SwitchChar       ; take the new switchar
+          dec       di                  ; point to the immediate operang of the
+          dec       di                  ; previous instruction (mov dl,'/')
+          stosb                         ; and store the new switchar there!
+SetSwChret:pop      es                  ;restore the registers saved
+          pop       di
+          pop       si
+          pop       cx
+          exit
+
+
           ;
           ; QueryVerifyWrite - check disk write verify flag
           ;
@@ -186,10 +306,28 @@
 
 
           ;
+          ; GetFontPage - get Arabic/Hebrew font page
+          ;
+          ; On exit:
+          ;         AX = current font page (0 if no Arabic or Hebrew installed)
+          ;         All other registers unchanged, interrupts on
+          ;
+
+          entry     GetFontPage,noframe,far
+          push      cx
+          mov       ax,0AD41h		; get current font page in CX (DX = ???)
+          xor       cx,cx		; so 0 is returned if no Arabic / Hebrew
+          int       2Fh			; returned values:
+          xchg      ax,cx		; Arabic CX=164/DX=161, Hebrew CX=DX=100
+          pop       cx
+          exit
+
+
+          ;
           ; SetCodePage - set the current code page
           ;
           ; On entry:
-          ;         int lpt_num = printer number (1-n)
+          ;         int codepage = code page number to be set
           ;
           ; On exit:
           ;         AX, DX destroyed
@@ -212,6 +350,54 @@
 
 
           ;
+          ; SetCountry - set the current country code
+          ;
+          ; On entry:
+          ;         int country = country code to be set
+          ;
+          ; On exit:
+          ;         AX = 0 if successful, else error code
+          ;         DX destroyed
+          ;         All other registers unchanged, interrupts on
+          ;
+
+          entry     SetCountry,argframe,far
+          ArgW      country
+          push      bx
+          mov       ax,country
+          mov       bx,0FFh
+          cmp       ax,bx
+          jb        ctry_set
+          xchg      ax,bx
+ctry_set: mov       ah,38h
+          mov       dx,-1
+          calldosW
+          jc        ctry_err
+          xor       ax,ax
+ctry_err: pop       bx
+          exit
+
+
+          ;
+          ; GetIdlePtr - get DR DOS idle state data structure pointer
+          ;
+          ; On exit:
+          ;         DX:AX = far pointer to the idle state data structure
+          ;         All other registers unchanged, interrupts on
+          ;
+
+          entry     GetIdlePtr,noframe,far
+
+          pushm     es,si,di
+          mov       ax,4458h
+          calldosW			; get pointer in ES:AX
+          mov       dx,es
+          popm      di,si,es
+
+          exit
+
+
+          ;
           ; CheckForBreak - check for a ^C / ^Break
           ;
           ; On exit:
@@ -291,6 +477,36 @@
 
 
           ;
+          ; SetExtError - set extended error code, retrieved by DOS Function 59h
+          ;
+          ; On entry:
+          ;         Argument on stack:
+          ;           int nErrorCode
+          ;
+          ; On exit:
+          ;         All registers unchanged, interrupts on
+          ;
+
+          entry     SetExtError,argframe,far
+          ArgW      nErrorCode
+          pushm     ax,bx,cx,dx,si,di,bp,ds,es
+          calldos   GETPSP
+          push      bx                  ; process ID in the DOS parameter list
+          xor       ax,ax               ; (see RBIL Table 01686)
+          pushm     ax,ax               ; reserved (0) and computer ID (current)
+          calldos   GETERR              ; get extended error code (DOS Fn 59h)
+          pushm     es,ds,di,si,dx,cx,bx
+          push      nErrorCode          ; to be returned in AX by Function 59h
+          mov       dx,sp               ; get a pointer to the parameter list
+          loadseg   ds,ss               ; DS was destroyed by Function 59h!
+          mov       ax,5D0Ah            ; set extended error information
+          int       21h
+          add       sp,22
+          popm      es,ds,bp,di,si,dx,cx,bx,ax
+          exit
+
+
+          ;
           ; GETERROR - Get a DOS error message
           ;
           ; On entry:
@@ -350,13 +566,28 @@
 
           pushm     bx,si,di,bp         ;save registers
 
-          calldos   VERSION             ;get DOS version
+          mov       ax,(D_VERSION shl 8);get DOS version in AX, OEM ID in BH
+          calldos
           mov       bptr __osmajor,al   ;save major version
           mov       bptr __osminor,ah   ;save minor version
           mov       bptr _gchMajor,al   ;save true major version
           mov       bptr _gchMinor,ah   ;save true minor version
-          mov       _gnOSFlags,0        ;clear OS flags
-          mov       ax,4452h            ;get DR-DOS inquiry flag
+          mov       bl,bh               ;store the OEM ID
+          mov       bh,0                ;isolate it
+          shln      bx,3,cl             ;move it to bits 10-3
+          mov       _gnOSFlags,bx       ;store these bits in OS flags
+          ;
+          mov       ax,30DBh            ;check for Datalight ROM-DOS
+          xor       cx,cx               ;CX must be 0
+          mov       si,0B2D2h           ;ROM-DOS specific function "key"
+          mov       di,3                ;function #3, Get ROM-DOS revision
+          calldos
+          cmp       cx,0B2D2h           ;verify that ROM-DOS really set things
+          jne       ChkDR               ;not ROM-DOS
+          mov       _gnOSFlags,(0DBh shl 3) ;ROM-DOS - replace its 0FFh OEM ID
+          jmp       short ChkDOS5
+          ;
+ChkDR:    mov       ax,DRCHECK          ;get DR-DOS inquiry flag
           calldos                       ;get DR-DOS version
           mov       bx,ax               ;copy result
           and       bx,0FBE0h           ;ignore low 5 bits
@@ -378,14 +609,40 @@
           cmp       bl,10               ;is it OS/2 1.x?
           je        AdjOS2              ;if so skip DOS 5 check and do
                                         ;  OS/2 adjustment
-          xor       bx,bx               ;clear BX for 3306 call
+ChkDOS5:  xor       bx,bx               ;clear BX for 3306 call
           mov       ax,3306h            ;check DOS 5, get real version
           calldos                       ;do the call
           or        bx,bx               ;was it DOS 5?
            jz       GVDone              ;if not go on
+          cmp       __osmajor,al        ;now check for X-DOS 5.0 which
+          jne       ChkD5BX             ;wrongly sets AX=1F03, BX=FF00
+          cmp       __osminor,ah        ;(as if AH was 30h on input!)
+          jne       ChkD5BX             ;did this mistake occur?
+          and       _gnOSFlags,1111111111100111b   ;yes, set OEM ID=FC
+          jmp       short GVDone
+ChkD5BX:  cmp       bh,100              ;check also minor
+          jae       GVDone
+          cmp       bl,5                ;and major version
+           jb       GVDone
           mov       bptr __osmajor,bl   ;save major version
           mov       bptr __osminor,bh   ;save minor version
           or        _gnOSFlags,dx       ;save flags
+          ;
+          cmp       bx,0A07h            ;version 7.10?
+          jne       StoreVer            ;no, continue
+          mov       ax,_gnOSFlags       ;yes
+          and       ax,11111111000b     ;mask OEM ID
+          cmp       ax,11111111000b     ;MS?
+          jne       StoreVer            ;no, continue
+          shln      dh,4,cl             ;shift HMA bit (4) to CF
+          sbb       ax,ax               ;-1 if DOS in HMA, 0 otherwise
+          mov       es,ax               ;search segment
+          xor       di,di               ;start from its beginning
+          mov       cx,8000h            ;search it all
+          mov       ax,'ZL'             ;for the LZ-DOS ID
+          repne     scasw               ;do the search; found?
+          jne       StoreVer            ;no, continue
+          and       _gnOSFlags,1111111111110111b   ;yes, set OEM ID=FE
 
 StoreVer: mov       bptr _gchMajor,bl   ;save true major version
           mov       bptr _gchMinor,bh   ;save true minor version
@@ -407,6 +664,108 @@
 
 
           ;
+          ; InstalledCheck - find out if a standard DOS TSR is installed
+          ;
+          ; On entry:
+          ;         Arguments on stack:
+          ;           int id
+          ;
+          ; On exit:
+          ;         for SMARTDRV (id = 4A10h):
+          ;           AX = BABEh if installed
+          ;         else
+          ;           AX = -1 if installed, 0 or 1 if not installed
+          ;                 (0 if OK to install, 1 if not OK to install)
+          ;         All other registers and interrupt state unchanged
+          ;
+
+          entry	InstalledCheck,argframe,far
+          argW      id
+          pushm     bx,cx,di,es
+          mov       ax,0DADAh		; the MSCDEX check
+          push      ax			; needs DADA in stack
+          mov       ax,id
+          xor       bx,bx		; for SMARTDRV check
+          mov       cx,0EBABh		;	"	"
+          xor       di,di		; for DOS Task Switcher check
+          mov       es,di		;	"	"
+          int       2Fh
+          pop       bx
+          cmp       ax,0BABEh		; generic TSR "installed" state?
+          je        InstRet		; no, return AX without changes
+          cbw				; yes, return 0, 1 or -1
+InstRet:  popm      es,di,cx,bx
+          exit
+
+
+          ;
+          ; PowerInstalled - find out if POWER.EXE is installed
+          ;
+          ; On entry:
+          ;         No requirements
+          ;
+          ; On exit:
+          ;         AX = 1 if POWER.EXE installed, 0 if not installed
+          ;         All other registers and interrupt state unchanged
+          ;
+
+          entry	PowerInstalled,noframe,far
+          push      bx
+          mov       ax,5400h
+          xor       bx,bx
+          int       2Fh
+          xor       ax,ax
+          cmp       bx,'PM'	; POWER installed?
+          jne       PwrRet	; no, return zero
+          inc       ax		; yes, return flags
+PwrRet:   pop       bx
+          exit
+
+
+          ;
+          ; NetworkInstalled - find out if a network is installed
+          ;
+          ; On entry:
+          ;         No requirements
+          ;
+          ; On exit:
+          ;         AX destroyed
+          ;         All other registers and interrupt state unchanged
+          ;
+
+          entry	NetworkInstalled,noframe,far
+          push      bx
+          mov       ax,0B800h
+          xor       bx,bx
+          int       2Fh		; BX = flags of installed network components
+          or        al,al	; any network installed?
+          jz        NetRet	; no, return zero
+          xchg      ax,bx	; yes, return flags
+NetRet:   pop       bx
+          exit
+
+
+          ;
+          ; GetMachineName - get the machine name in the network
+          ;
+          ; On entry:
+          ;         Arguments on stack:
+          ;           char *machine
+          ;
+          ; On exit:
+          ;         AX, DX destroyed
+          ;         All other registers unchanged, interrupts on
+          ;
+
+          entry     GetMachineName,argframe,far
+          argW      machine
+          mov       dx,machine
+          mov       ax,5E00h
+          calldosW
+          exit
+
+
+          ;
           ; reset_disks - flush buffers & reset disk drives
           ;
           ; On entry:
@@ -611,6 +970,133 @@
           exit
 	
 
+          ;
+          ; CDIOctl - open or close CD tray or get drive status
+          ;
+          ; On entry:
+          ;         Argument on stack using pascal calling convention:
+          ;            int drivespec:   drive (0 - first, 1 - A, 2 - B, etc.)
+          ;            int operation:   0: open, 5: close, 6: status, 8: size
+          ;
+          ; On exit:
+          ;         DX:AX = -1 for invalid drive, status (operation = 6) or size
+          ;         AX, DX destroyed
+          ;         All other registers unchanged, interrupts on
+          ;
+
+          entry     CDIOctl,argframe,far
+
+          ArgW      operation
+          ArgW      drivespec
+
+          push      bx
+          mov       ax,1500h		; CD-ROM installation check, returns:
+          xor       bx,bx		; BX = # of CD-ROM drive letters used
+          int       2Fh			; CX = starting drive letter (0 = A:)
+          dec       bx			; any CD-ROM drive letters?
+          js        cdio_error		; no, error
+          dec       word ptr drivespec	; yes, adjust (A=0, B=1, etc.)
+          js        cdio_oper		; if it was 0, use current CX (1st drv)
+          cmp       drivespec,cx	; drive argument too low?
+          jb        cdio_error		; yes, error
+          add       bx,cx		; no, get last drive letter
+          cmp       drivespec,bx	; drive argument too high?
+          ja        cdio_error		; yes, error
+          mov       cx,drivespec	; no, use it
+cdio_oper:
+          mov       dx,operation
+          mov       ReqHdr.function,dl
+          mov       bl,IOCTL_OUTPUT
+          mov       dh,1
+          cmp       dl,STATUS_COMMAND	; status or size command?
+          jb        cdio_doit		; no, do 1-byte output
+          mov       bl,IOCTL_INPUT	; yes, do 5-byte input
+          mov       dh,5
+cdio_doit:
+          mov       ReqHdr.command,bl
+          mov       ReqHdr.bytes,dh
+          mov       bx,offset ReqHdr
+          loadseg   es,ds,dx
+          mov       ReqHdr.d_segment,dx	; these 2 may get overwritten by driver
+          mov       ReqHdr.d_offset,offset ReqHdr.function
+          mov       al,10h
+          int       2Fh			; send device driver request, CX: drive
+          mov       ax,word ptr ReqHdr.cdstatus; return status, for operation 6
+          mov       dx,word ptr ReqHdr.cdstatus+2    ; or size, for operation 8
+          jmp       short cdio_exit
+cdio_error:
+          mov       ax,-1
+          mov       dx,ax
+cdio_exit:
+          pop       bx
+          exit
+
+
+          ;
+          ; GetDPB - get a far pointer to the DOS Drive Parameter Block
+          ;
+          ; On entry:
+          ;         Argument on stack:
+          ;           int drivespec:   logical drive (1 - A, 2 - B, etc.)
+          ;
+          ; On exit:
+          ;         DX:AX = far pointer to the DPB for the specified drive
+          ;         DX:AX = 0 on error (invalid or network drive)
+          ;         All other registers unchanged, interrupts on
+          ;
+          entry     GetDPB,argframe,far
+          ArgW      drivespec
+          pushm     bx,ds
+          mov       dx,drivespec
+          mov       ah,32h		; get DPB for the specified drive
+          int       21h
+          xor       dx,dx		; prepare 0 to return in case of failure
+          cmp       al,0		; successful?
+          mov       ax,dx
+          jne       DPBret		; no, invalid or network drive, return 0
+          xchg      ax,bx		; yes
+          mov       dx,ds		; move the DPB pointer to DX:AX
+DPBret:   popm      ds,bx
+          exit
+
+
+          ;
+          ; GetDrivePhysUnit - get physical (BIOS Int 13h) drive unit number
+          ;
+          ; On entry:
+          ;         Argument on stack:
+          ;           int drivespec:   drive to check (1 - A, 2 - B, etc.)
+          ;
+          ; On exit:
+          ;         AX = physical unit # (0,1,...: FDD; 80h,81h,...: HDD)
+          ;         AX = -1 on error (call not supported or no physical unit)
+          ;         All other registers unchanged, interrupts on
+          ;
+
+          entry     GetDrivePhysUnit,argframe,far
+          ArgW      drivespec
+          pushm     bx,di,ds
+          mov       bx,drivespec
+          dec       bx			; logical drive: 0 = A:, 1 = B:. etc.
+          xor       di,di
+          mov       ds,di
+          mov       ax,803h		; get Drive Data Table list (DOS 4.0+)
+          int       2Fh
+          mov       ax,ds
+          or        ax,di		; valid address?
+          jz        PUnitErr		; no, return -1
+          xor       ax,ax		; yes, prepare unit number MSW
+NextDDT:  mov       al,[di+4]		; get physical unit number
+          cmp       bl,[di+5]		; same logical drive?
+          je        PUnitRet		; yes, return unit number in AX
+          lds       di,[di]		; no, load next DDT address
+          cmp       di,-1		; last DDT?
+          jne       NextDDT		; no, continue
+PUnitErr: mov       ax,-1		; yes, return -1
+PUnitRet: popm      ds,di,bx
+          exit
+
+
 	;==================================================================
 	;
 	;  HARDWARE / BIOS INTERFACE ROUTINES (except video)
@@ -618,6 +1104,30 @@
 	;==================================================================
 
           ;
+          ; GetHDDParams - get physical (BIOS Int 13h) HDD parameters
+          ;
+          ; On entry:
+          ;         Argument on stack:
+          ;           int drv:   physical unit # (80h,81h,...) for Int 13h
+          ;           LBA *buf:  LBA buffer
+          ;
+          ; On exit:
+          ;         All registers unchanged, interrupts on
+          ;
+
+          entry     GetHDDParams,argframe,far
+          argW      buf
+          argW      drv
+          pushm     ax,dx,si
+          mov       ah,48h		; Get drive parameters (LBA BIOS)
+          mov       dx,drv
+          mov       si,buf
+          int       13h
+          popm      si,dx,ax
+          exit
+
+
+          ;
           ; QueryMouseReady - test for mouse driver
           ;
           ; On exit:
@@ -626,7 +1136,13 @@
 
           entry     _QueryMouseReady,noframe,far
 
-          push      bx
+          pushm     bx,es
+          mov       al,33h              ; get mouse interrupt number
+          calldos   GETINT              ; get interrupt vector in ES:BX
+          mov       ax,es
+          pop       es
+          or        ax,bx		; Int 33h vector zero?
+          jz        no_mouse		; if so, don't call it!
           mov       ax,015h
           xor       bx,bx
           int       033h		; if mouse loaded, BX != 0
@@ -661,10 +1177,7 @@
           mov       ax,04408h		; IOCTL check if block dev is removable
           calldosW
           jc        is_fixed		; error - assume fixed
-          or        al,al		; 0 - removable, 1 - fixed
-          jne       is_fixed
-is_removable:
-          mov       ax,1		; set removable flag
+          xor       al,1		; DOS returns AX=0: removable, 1: fixed
           jmp       short dr_bye
 is_fixed:
           xor       ax,ax		; clear removable flag
@@ -689,14 +1202,36 @@
 
           ArgW      drivespec
 
+          push      drivespec
+          call      QueryIsCDROM
+          or        ax, ax		; CD-ROM?
+          jz        ready_nocd		; no, continue
+          push      drivespec		; yes, get inverted status
+          mov       ax, STATUS_COMMAND	; bit 11, "no disc in drive"
+          push      ax
+          call      CDIOctl
+          push      drivespec		; second call - the first may miss
+          mov       ax, STATUS_COMMAND	; a CD if no other calls have been
+          push      ax			; made since it has been inserted!
+          call      CDIOctl
+          not       ax
+          push      cx
+          mov       cl, 11
+          shr       ax, cl
+          pop       cx
+          and       ax, 1
+          jmp       short ready_ret
+
+ready_nocd:
           push      bx
           mov       ax, 2
           push      ax
           call      DosError		; disable error popup
 
           mov       dx, drivespec
-          mov       ah, 36h
-          calldosW
+          xor       cx, cx
+          calldos   DSKFREE		;get AX=sectors/cluster,CX=bytes/sector
+          jcxz      ready_error		;PTS-DOS doesn't set AX=-1 if not ready
           cmp       ax, 0FFFFh
           jne       no_error
 
@@ -714,6 +1249,7 @@
 
           pop       ax
           pop       bx
+ready_ret:
           exit
 
 
@@ -739,8 +1275,16 @@
           mov       ax,04409h		; IOCTL check if block dev is remote
           calldosW
           jnc       d_e_exists		; no error - assume drive exists
-          cmp       al,15
-          jne       d_e_exists		; if not "invalid drive" assume exists
+          mov       ah,0
+          cmp       __osmajor,3
+          jb        d_e_invchk		; if DOS 2.x, use the returned AL
+          pushm     cx,dx,si,di,bp,ds,es; save registers destroyed by DOS call
+          xor       bx,bx		; PTS-DOS may have returned invalid AL
+          calldos   GETERR              ; so get extended error code
+          popm      es,ds,bp,di,si,dx,cx
+d_e_invchk:
+          cmp       ax,15h
+          je        d_e_exists		; if "drive not ready" assume it exists
           xor       ax,ax		; clear exists flag
           jmp       short d_e_bye
 d_e_exists:
@@ -785,29 +1329,21 @@
           ;
           ; On entry:
           ;         Argument on stack:
-          ;           char *drivespec:   drive to check (1 - A, 2 - B, etc.)
+          ;           int drivespec:   drive to check (1 - A, 2 - B, etc.)
           ;
           ; On exit:
-          ;         AX = -1 for invalid drive, 0 for local, 1 for remote
+          ;         AX = 1 if drive is CD-/DVD-ROM, 0 otherwise
           ;         BX, DX destroyed
           ;         All other registers unchanged, interrupts on
           ;
 
           entry     QueryIsCDROM,argframe,far
 
-          ArgW      driveptr
+          ArgW      drive
 
           push      bx
-	mov	bx,driveptr		;point to drive string
-	mov	cl,[bx]		;get drive letter
-	cmp	cl,'a'		;lower case?
-	jb	cd_drive		;if not go on
-	cmp	cl,'z'		;check high end
-	ja	cd_drive		;if not LC go on
-	sub	cl,32		;make it upper case
-cd_drive:
-	sub	cl,'A'		;convert to drive value
-	xor	ch,ch		;clear high byte
+	mov	cx,drive
+	dec	cx			;0 = A:, 1 = B:, etc.
 	mov	ax,0150Bh		;MSCDEX call
 	xor	bx,bx
 	int	2Fh			;returns AX=0 if drive not supported
@@ -852,6 +1388,99 @@
           exit
 
           ;
+          ; QuerySerialReady  - test if the specified serial port is ready
+          ;
+          ; On entry:
+          ;         int com_num = serial port number (1-n)
+          ;
+          ; On exit:
+          ;         AX = 1: ready, 0: not ready
+          ;         DX destroyed, all other registers unchanged, interrupts on
+          ;
+
+          entry     QuerySerialReady,argframe,far
+          argW      com_num
+          mov       ax,300h
+          mov       dx,com_num
+          int       14h			; get serial port status
+          cmp       ax,-1		; disabled ports return -1 in W9x
+          jne       com_dsr		; if not so, continue normally
+          inc       ax			; clear AX if port disabled in W9x
+com_dsr:  and       ax,100000b		; mask DSR bit
+          jz        com_ret		; return 0 if inactive
+          mov       al,1
+com_ret:  exit
+
+          ;
+          ; GetSBDSPver - get Sound Blaster DSP version (see SBHWPG.PDF)
+          ;
+          ; On exit:
+          ;    AX = DSP version, or 0 if no Sound Blaster present
+          ;    All other registers unchanged, interrupts on
+          ;
+          extrn     @SysWait:far
+          entry	GetSBDSPver,noframe,far
+          pushm     bx,cx,dx
+          mov       ax,1
+          mov       dx,226h		; DSP reset port
+          out       dx,al
+          xor       cx,cx
+          loop      $			; must wait at least 3 microseconds
+          dec       ax
+          out       dx,al
+          push      dx
+          mov       al,5
+          cwd
+          mov       bx,2		; 5 ms delay, much longer than 0.1 ms
+          call      @SysWait
+          pop       dx
+          add       dl,8		; read buffer status port (22Eh)
+          in        al,dx
+          and       ax,10000000b	; any data to read?
+          jz        SBDSPretn		; no, return 0 (no SB found)
+          sub       dl,4		; yes, read DSP data port (22Ah)
+          in        al,dx
+          cmp       al,0AAh		; OK?
+          mov       al,0		; (assume no)
+          jne       SBDSPretn		; no SB found - return 0
+          add       dl,2		; a SB was found
+SBDSPbsy1:in        al,dx		; read DSP write buffer status (22Ch)
+          or        al,al		; can we write to the DSP?
+          js        SBDSPbsy1		; not yet, try again
+          mov       al,0E1h		; yes, send the Get DSP Version command
+          out       dx,al
+          add       dl,2		; read buffer status port (22Eh)
+SBDSPbsy2:in        al,dx
+          or        al,al		; any data to read?
+          jns       SBDSPbsy2		; not yet, try again
+          sub       dl,4		; read data port (22Ah)
+          in        al,dx		; read the version MSB
+          mov       ah,al		; save it
+          add       dl,4		; read buffer status port (22Eh)
+SBDSPbsy3:in        al,dx		; repeat the procedure for the LSB
+          or        al,al
+          jns       SBDSPbsy3
+          sub       dl,4
+          in        al,dx		; read the version LSB
+SBDSPretn:popm      dx,cx,bx
+          exit				; return the DSP version in AX
+
+          ;
+          ; InV86mode - return 1 if CPU is in V86 mode, else 0 (386+ only)
+          ;
+          ; On exit:
+          ;    AX = 0: CPU is in real mode
+          ;         1: CPU is in V86 mode
+          ;         All other registers unchanged, interrupts on
+          ;
+          entry     InV86mode,noframe,far
+          .286
+          smsw      ax			; get LSW of CR0
+          .8086
+          and       ax,1		; isolate bit 0 (PE)
+          exit
+
+          ;
           ; GET_CPU - get cpu type
           ;
           ; On exit:
@@ -862,7 +1491,8 @@
           ;        386 if an 80386
           ;        486 if an 80486
           ;        586 if a Pentium
-          ;        686 if a Pentium Pro
+          ;        686 if a Pentium Pro, II or III
+          ;        786 if a Pentium 4 or later
           ;    CX destroyed, all other registers unchanged, interrupts on
           ;
 
@@ -937,9 +1567,12 @@
           cmp       ax,0500h		; get Family field (5=Pentium)
           jb        got_486
 
-          cmp       ax, 500h
-          jbe       got_586
-
+          cmp       ax, 600h
+          jb        got_586
+          je        got_686
+          mov       ax,786
+          jmp       short restore_486
+got_686:
           mov       ax,686
           jmp       short restore_486
 got_586:
@@ -985,7 +1618,7 @@
 
           exit
 
-
+if 0
           ;
           ; GET_NDP - get ndp type
           ; Must assemble with the /R option set in MASM
@@ -1037,6 +1670,67 @@
           mov       ax,0387		; must be a 80387
 bye_ndp:
           exit
+endif
+
+          ;
+          ; get_cpu_brand - get the CPU "brand string", if supported
+          ;
+          ; On entry:
+          ;         Argument on stack:
+          ;           char *brandstr:   48-byte brand string buffer
+          ;
+          ; On exit:
+          ;         AX = 0 if this feature is supported, else a non-zero value
+          ;         All other registers unchanged, interrupts on
+          ;         brandstr buffer filled with the CPU brand string if AX = 0
+          ;         Note: Brand string is zero-terminated and right-justified.
+          ;               It can be left-padded with blank (space) characters.
+
+          entry     get_cpu_brand,argframe,far
+          argW      brandstr
+          .386
+          push      eax
+          mov       eax,80000000h	; extended function information
+          CPUID
+          or        eax,eax		; extended functions supported?
+          jns       nobrstr		; no, return
+          sub       ax,4		; yes, Fn 4 (brand string) supported?
+          jae       getbrst		; yes, continue
+nobrstr:  pop       eax			; no, return -1
+          mov       ax,-1
+          jmp       short brstret
+getbrst:  pushm     ebx,ecx,edx,si,di,es
+          loadseg   es,ds
+          mov       di,brandstr
+          mov       si,2
+          cld
+next16b:  mov       eax,80000004h	; do CPUID with AX=0x8000000|2|3|4
+          sub       ax,si
+          CPUID
+          stosd				; save returned string to brandstr
+          xchg      eax,ebx		;   (4 x 4 x 3 = 48 bytes total)
+          stosd
+          xchg      eax,ecx
+          stosd
+          xchg      eax,edx
+          stosd
+          dec       si
+          jns       next16b		; do it 3 times until SI becomes -1
+          popm      es,di,si,edx,ecx,ebx,eax
+          .8086
+          xor       ax,ax		; return 0 (success)
+brstret:  exit
+
+          ;
+          ; QuerySystemRAM - get the amount of installed [base] RAM
+          ;
+          ; On exit:
+          ;         AX = kilobytes of contiguous memory starting at address 0
+          ;         All other registers unchanged, interrupts on
+          ;
+          entry     QuerySystemRAM,noframe,far
+          int       12h			; get RAM size from BIOS
+          exit
 
           ;
           ; GET_EXPANDED - get amount of expanded memory
@@ -1081,24 +1775,56 @@
           ; GET_EXTENDED - get amount of extended memory
           ;
           ; On exit:
-          ;         AX = # of 1K blocks of extended memory
+          ;         DX:AX = # of 1K blocks of extended memory
           ;         All other registers unchanged, interrupts on
           ;
 
           entry     _get_extended,noframe,far
-
+          pushm     bx,cx
           cmp       __osmajor,10
-          jae       got_88
-          call      _get_cpu
+          cmc
+          jb        got_88
+          mov       ax,_gnCPU
           cmp       ax,286		; is it an 86/88/186/188/V20/V30?
           jb        got_88		;   yup, so no extended mem
-          mov       ax,08800h           ; get interrupt number
-          int       15h
-          cmp       ah,080h
-          jb        got_ext
-got_88:
-          xor       ax,ax		; probably not really extended!
-got_ext:
+          cmp       ax,386		; is it at least a 386?
+          jb        got_286		; if not, use the CMOS
+          mov       ax,0E801h		; try the "get memory size" request
+          mov       cx,ax
+          xor       bx,bx		; load registers with invalid values
+          xor       dx,dx
+          int       15h			; CF set even on success in Win9x, so
+          push      ax			; it can't be used to check for error
+          or        ax,bx
+          pop       ax
+          jnz       gotE801		; AX = BX = 0 in Win9x
+          xchg      ax,cx		; if so, use CX, DX instead of AX, BX
+          mov       bx,dx
+gotE801:  or        bx,bx		; any memory above 16 MB?
+          jz        got_286		; if not, use the CMOS
+          cmp       ax,15*1024		; any memory "hole" below 16 MB?
+          ja        got_286		; ERROR if > 15 MB! Try the CMOS
+          xchg      ax,bx		; now BX = KBytes below 16 MB
+          mov       dx,64		; convert the 64K units in AX
+          mul       dx			;   into 1K units in DX:AX
+          add       ax,bx		; add the KBytes below 16 MB
+          adc       dx,0
+          jnc       got_ext
+got_286:  mov       al,31h		; get extended memory size (286+)
+          out       70h,al		; (Int 15h function 88h is often
+          jmp       $+2			; hooked by memory managers and
+          in        al,71h		; returns 0, so don't use it)
+          jmp       $+2
+          mov       ah,al
+          mov       al,30h		; 30:LSB, 31:MSB; 70:reg, 71:data
+          out       70h,al		; get the size in KB from where
+          jmp       $+2			; BIOS itself gets it - CMOS RAM
+          in        al,71h
+          clc
+got_88:   mov       dx,0		; not a XOR to avoid clearing CF
+          jnc       got_ext
+          xor       ax,ax		; no extended memory
+got_ext:  popm      cx,bx
           exit
 
           ;
@@ -1108,8 +1834,8 @@
           ;       int *hma_status
           ;
           ; On exit:
-          ;         AX = # of 1K blocks of extended memory
-          ;         DX, ES destroyed
+          ;         DX:AX = # of 1K blocks of extended memory
+          ;         ES destroyed
           ;         All other registers unchanged, interrupts on
           ;
 
@@ -1120,8 +1846,7 @@
           varend
 
           push      bx
-          call      _get_cpu
-          cmp       ax,286		; is it an 86/88/186/188/V20/V30?
+          cmp       _gnCPU,286		; is it an 86/88/186/188/V20/V30?
           jb        not_286
 
           mov       ax,XMSTEST
@@ -1130,6 +1855,7 @@
           je        got_xms
 not_286:
           xor       ax,ax
+	  xor	    dx,dx
           jmp       short no_xms
 got_xms:
           mov       ax,XMSADDR
@@ -1154,14 +1880,66 @@
           mov       bx,hma_state
           mov       [bx],ax
 
+	  cmp	    _gnCPU,386		; is it at least a 80386?
+	  jb	    no_v3		; no, use the old method (up to 64 MB)
+
+	  mov	    ah,0		; query XMS version
+	  call	    dword ptr [XMSControl]
+	  cmp	    ah,3		; 3.0+ ?
+	  jb	    no_v3		; no, use the old method
+
+	  mov	    ah,88h		; query free extended memory (XMS 3.0+)
+	  call	    dword ptr [XMSControl]
+	  .386
+	  push	    eax
+	  .8086
+	  pop	    ax			; copy total free to DX:AX
+	  pop	    dx
+	  jmp	    short no_xms
+no_v3:
           mov       ah,8		; query free extended memory
           call      dword ptr [XMSControl]
           mov       ax,dx               ; copy total free to AX
+	  xor	    dx,dx
 no_xms:
           pop       bx
           exit
 
           ;
+          ; BIOS_SHIFTSTATE - check Shift/Alt/Ctrl/*Lock/Insert/SysReq status
+          ;
+          ; On exit:
+          ;         AX destroyed
+          ;         All other registers unchanged, interrupts on
+          ;
+
+          entry     _bios_shiftstate,noframe,far
+
+          mov       ah,2
+          int       16h
+          mov       ah,12h
+          int       16h ; PC/XT/AT BIOS will exit with AH = 10h and AL intact
+          exit
+
+          ;
+          ; BIOS_KBHIT - check if a key is ready from the BIOS (for LIST /S)
+          ;
+          ; On exit:
+          ;         AX, DX destroyed
+          ;         All other registers unchanged, interrupts on
+          ;
+
+          entry     _bios_kbhit,noframe,far
+
+          mov       ah,1
+          int       16h
+          mov       ax,1
+          jnz       kbh_done
+          dec       ax
+kbh_done:
+          exit                          ; all done
+
+          ;
           ; BIOS_KEY - get key from the BIOS (for LIST /S)
           ;
           ; On exit:
@@ -1185,6 +1963,27 @@
           exit                          ; all done
 
           ;
+          ; BIOS_KEYSTROKE - check for keystroke and return its codes if ready
+          ;
+          ; On exit:
+          ;         AX = BIOS scan code (AH) and ASCII code (AL) if key pressed
+          ;              -1 if no key pressed
+          ;         All other registers unchanged, interrupts on
+          ;
+
+          entry     _bios_keystroke,noframe,far
+          mov       ah,1
+          int       16h			; is a keystroke available in buffer?
+          jnz       key_ret		; yes, return its scan and ASCII code
+          mov       ax,1680h		; no, give up Windows timeslice
+          int       2Fh
+          cmp       al,80h
+          jne       key_none
+          int       28h			; 2Fh 1680h not supported; call DOS idle
+key_none: mov       ax,-1		; return FFFF which is an impossible
+key_ret:  exit				; scan code / ASCII code combination
+
+          ;
           ; DosBeep - beep the speaker with the specified tone & duration
           ;
           ; On entry:
@@ -1260,8 +2059,6 @@
 
           cmp       word ptr freq,20	; check if DELAY'ing
           jae       beep_loop
-          cmp       word ptr duration,6	; don't give up timeslice for short wait
-          jbe       beep_loop
           mov       ax,1680h
           int       2Fh			; give up Win / OS/2 timeslice
           cmp       al,80h
@@ -1290,6 +2087,76 @@
 	;==================================================================
 
           ;
+          ; GetDDCstring - get DDC (Display Data Channel)
+          ;                   EDID (Enhanced Display Identification Data) string
+          ;
+          ; On entry:
+          ;       int what (1 = manufacturer, 2 = model, 3 = serial number)
+          ;       char *buf (128-byte buffer to store the EDID record)
+          ;
+          ; On exit:
+          ;       AX = pointer to the desired string in buf, if any; else 0
+          ;         All other registers unchanged, interrupts on
+          ;
+
+          entry     GetDDCstring,argframe,far
+          argW      buf
+          argW      what
+          pushm     bx,cx,dx,si,di,es
+          mov       di,buf
+          loadseg   es,ds
+          mov       cx,64
+          xor       ax,ax
+          rep       stosw		; clear buffer
+          mov       di,buf
+          xchg      ax,dx		; clear DX (CX already 0)
+          mov       ax,4F15h
+          mov       bl,1
+          int       10h			; try to read the EDID from the BIOS
+          cmp       ax,4Fh		; function supported and successful?
+DDCzero:  mov       ax,0		; (return 0 if not)
+          jne       DDCret		; no, exit
+          mov       bx,what		; yes, check requested string
+          dec       bx			; 3-letter manufacturer ID?
+          jnz       DDCmodel		; no, continue
+          mov       di,buf		; yes -
+          mov       dx,[di+8]		; load its word
+          xchg      dh,dl		; convert to big to little endian
+          mov       cx,4		; 3 letters + 1 terminating null
+DDCmanuf: mov       al,dh		; get next 5 MS bits
+          shr       al,1		; move bits 14..10
+          shr       al,1		;   to bits 12..08
+          and       al,11111b		; mask them
+          jz        DDCstr1		; leave a 0 the 3rd time
+          add       al,'@'		; convert to ASCII
+DDCstr1:  stosb				; store to the string
+          push      cx			; shift bits 9..5 to 14..10
+          shln      dx,5,cl		;	 and 4..0 to 09..05
+          pop       cx			; loop until all letters plus
+          loop      DDCmanuf		; a null terminator are stored
+          mov       ax,buf		; return a pointer to the string
+          jmp       short DDCret
+DDCmodel: dec       bx			; model?
+          mov       dx,0FC00h		; (load its text ID)
+          jz        DDCtext		; yes, find it
+          dec       bx			; no, serial number?
+          mov       dx,0FF00h		; (load its text ID)
+          jnz       DDCzero		; no, return 0
+DDCtext:  mov       si,buf		; yes -
+          add       si,26h		; 1st text ID address minus 10h
+          mov       cx,4		; there are 4 of them
+DDCfind:  add       si,10h		; next address
+          lodsw
+          or        ax,ax		; leading zeros?
+          jne       DDCnext		; no, try next address
+          cmp       [si],dx		; ID match?
+          lea       ax,[si+3]		; (prepare pointer if so)
+DDCnext:  loopne    DDCfind		; repeat until ID match
+          jne       DDCzero		; if not found, return 0
+DDCret:   popm      es,di,si,dx,cx,bx	; yes
+          exit
+
+          ;
           ; GetCurPos - get the cursor position
           ;
           ; On entry:
@@ -1358,6 +2225,39 @@
           exit
 
           ;
+          ; HideCursor - hide the cursor
+          ;
+          ; On exit:
+          ;         All registers unchanged, interrupts on
+          ;
+
+          entry     HideCursor,noframe,far
+          pushm     ax,cx,bp		; save BP for PC1 BIOS bug
+          mov       ax,100h		; set cursor shape
+          mov       cx,0FFFFh		; set start=end=FF to make it invisible
+          int       10h
+          popm      bp,cx,ax
+          exit
+
+          ;
+          ; QuerySVGA - test to see if the video adapter is VESA SuperVGA
+          ;
+          ; On exit:
+          ;         AX = 1: VESA SuperVGA BIOS present
+          ;         AX = 0: no	"	"	"
+          ;         BX destroyed, all other registers unchanged, interrupts on
+          ;
+
+          entry     QuerySVGA,noframe,far
+          mov       ax,4F03h
+          int       10h			; get current SuperVGA video mode in BX
+          cmp       al,4Fh		; VESA SuperVGA BIOS present?
+          mov       ax,0		; (assume no)
+          jne       QSVGAret		; no, return 0
+          inc       ax			; yes, return 1
+QSVGAret: exit
+
+          ;
           ; GETVIDEOMODE - get the video adapter and monitor type
           ;
           ; On exit:
@@ -2208,10 +3108,19 @@
 
           call      GetVideoMode
           cmp       ax, 2
-          jae       vga
-
-          mov       ax,0B000h           ;assume mono screen
+          jb        mda_cga
+          mov       ah,12h              ;alternate function select
+          mov       bl,10h              ;get EGA info
+          int       10h
+          cmp       bl,4
+          ja        mda_cga             ;older than EGA (source: TECH Help!)
+          cmp       bh,1
+          je        mono                ;mono mode in effect
+          cmp       bh,0
+          je        vga                 ;colour mode in effect
+mda_cga:
           cmp       byte ptr es:[0449h],7  ;check video mode
+mono:     mov       ax,0B000h           ;assume mono screen
           je        ipdone              ;if mode 7, it's mono & we're done
           mov       ax,es:[0463h]       ;address of 6845 video controller
           add       ax,6                ;offset for status register
@@ -2722,7 +3631,504 @@
 	int	2Fh			; close clipboard
 	exit
 
+	;
+	; Divide64By32 - Divide a QWORD by a DWORD
+	;
+	; On entry:
+	;	Arguments on stack:
+	;	t_int64 *ullDividend	    pointer to the dividend
+	;	unsigned long ulDivisor     divisor
+	;
+	; On exit:
+	;	DX:AX = quotient
+        ;	All other registers unchanged, interrupts on
+	;
+	entry	Divide64By32,argframe,far; set up entry point
+	argD	ulDivisor
+	argW	ullDividend
+	push	bx
+	mov	bx,ullDividend		; load dividend address
+	cmp	_gnCPU,386
+	jb	Div8086			; old CPU - divide by bit shifting
+	.386
+	push	eax
+	pop	ax
+	push	edx			; save MSDW of the used registers
+	pop	dx
+	mov	eax,[bx]
+	mov	edx,[bx+4]		; and the dividend itself
+	div	dword ptr ulDivisor
+	push	eax			; move return value from EAX to DX:AX
+	pop	ax
+	pop	edx
+	push	ax			; restore MSDW of the used registers
+	pop	eax
+	.8086
+	jmp	short DivRet
+Div8086:push	cx		; thanks to Peter Norton for this method!
+	mov	cx,64
+	xor	ax,ax
+	xor	dx,dx
+DivShft:shl	[bx+6],1	; shift 96 bits of DX:AX:ullDividend left by 1
+	rcl	[bx+4],1
+	rcl	[bx+2],1
+	rcl	[bx],1
+	rcl	ax,1
+	rcl	dx,1
+	cmp	dx,ulDivisor+2	; compare DX:AX and ulDivisor - first the MSW
+	ja	DivOne
+	jb	DivZero
+	cmp	ax,ulDivisor	; DX = MSW of ulDivisor - check LSW
+	jb	DivZero
+DivOne:	sub	ax,ulDivisor
+	sbb	dx,ulDivisor+2
+	inc	word ptr [bx+6]	; put in a 1 as divisor went into dividend once
+DivZero:loop	DivShft		; keep going all 64 times
+	mov	ax,[bx]		; end up with quotient in ullDividend
+	mov	dx,[bx+2]
+	pop	cx
+DivRet:	pop	bx
+	exit
+
+	;
+	; ShiftLeft16 - Shift a 48-bit number left by 16 bits
+	;
+	; On entry:
+	;	Arguments on stack:
+	;	t_int64 *ullVal	    pointer to the number to shift
+	;
+	; On exit:
+        ;	All registers unchanged, interrupts on
+	;
+	entry	ShiftLeft16,argframe,far; set up entry point
+	argW	ullVal
+	pushm	ax,bx
+	mov	bx,ullVal		; load number address
+	mov	ax,[bx+4]
+	mov	[bx+6],ax		; shift bits 47-32 to bits 63-48
+	mov	ax,[bx+2]
+	mov	[bx+4],ax		; shift bits 31-16 to bits 47-32
+	mov	ax,[bx]
+	mov	[bx+2],ax		; shift bits 15-0 to bits 31-16
+	popm	bx,ax
+	exit
+
+	;
+	; SetTimerMode2 - Set timer to mode 2 (thanks to Kris Heidenstrom!)
+	;
+	; On entry:
+	;	No requirements
+	;
+	; On exit:
+        ;	All registers unchanged, interrupts on
+	;
+	entry	SetTimerMode2,noframe,far; set up entry point
+	pushm	ax,es
+	sti
+	xor	ax,ax
+	mov	es,ax
+	mov	ax,es:[46Ch]	; get LSW of tick count
+Waitick:cmp	ax,es:[46Ch]	; changed?
+	je	Waitick		; if not, loop
+	mov	al,00110100b	; channel 0, mode 2
+	cli			; while disturbance to system time is minimal,
+	out	43h,al		; set the mode
+	jmp	$+2
+	xor	ax,ax
+	out	40h,al		; LSW of divisor
+	jmp	$+2
+	out	40h,al		; MSW of divisor
+	jmp	$+2
+	sti
+	popm	es,ax
+	exit
+
+	;
+	; GetTimer - Read current programmable interval timer 0 value
+	;
+	; On entry:
+	;	No requirements
+	;
+	; On exit:
+	;	AX = current timer 0 value
+        ;	All other registers unchanged, interrupts on
+	;
+	entry	GetTimer,noframe,far	; set up entry point
+	mov	al,0
+	cli
+	out	43h,al
+	jmp	$+2
+	in	al,40h	; LSB
+	jmp	$+2
+	mov	ah,al
+	in	al,40h	; MSB
+	jmp	$+2
+	sti
+	xchg	ah,al
+	neg	ax	; timer counts down
+	exit
+
+	;
+	; GetTimeStamp - Get 48-bit timestamp in 838.09534452 ns units since
+	;		midnight (thanks to Kris Heidenstrom for this code!)
+	;
+	; On entry:
+	;	Arguments on stack:
+	;	t_int64 *ullClock    pointer for the timestamp to be written to
+	;
+	; On exit:
+        ;	All registers unchanged, interrupts on
+	;
+	entry	GetTimeStamp,argframe,far; set up entry point
+	argW	ullClock
+	pushm	ax,bx,cx,dx,si,di,es
+	xor	ax,ax
+	mov	es,ax
+	cli
+	mov	si,es:[46Ch]	; tick count LSW
+	mov	di,es:[46Eh]	;   "	"    MSW
+	call	GetTimer	; timer 0 must operate in mode 2, divisor 65536
+	cli			; GetTimer enables interrupts on exit
+	mov	dx,es:[46Ch]	; read tick count again
+	mov	bx,es:[46Eh]	; (timer may have generated interrupt since)
+	sti
+	cmp	dx,si		; tick counts same?
+	je	GotTick		; yes, just return second tick count
+	or	ax,ax		; no, is tick count low or high?
+	jns	GotTick		; low, read was just past interrupt
+	mov	dx,si		; high, previous tick count is right
+	mov	bx,di		; get MSW of tick count too
+GotTick:mov	di,ullClock
+	mov	[di],ax		; write timestamp
+	mov	[di+2],dx	; (possible range: [0...1800AFFFFFh])
+	mov	[di+4],bx
+	mov	[di+6],es
+	popm	es,di,si,dx,cx,bx,ax
+	exit
+
+	;
+	; GetTSC - Read current time stamp counter value (586+ only)
+	;
+	; On entry:
+	;	Arguments on stack:
+	;	t_int64 *ullTSC     pointer for the TSC value to be written to
+	;
+	; On exit:
+        ;	All registers unchanged, interrupts on
+	;
+	entry	GetTSC,argframe,far	; set up entry point
+	argW	ullTSC
+
+RDTSC	MACRO
+	db	0Fh,31h		  ; hardcoded opcode for RDTSC instruction
+ENDM
+	.386
+	pushad
+	mov	eax,1			; function 1 to get features in EDX
+	CPUID				; serialise instruction execution
+	xor	eax,eax			; prepare 0 in case there is no TSC
+	and	edx,10000b		; does this CPU contain a TSC?
+	jz	WrTSC			; no, write 0 (EDX is also 0 now)
+	RDTSC				; yes, read the current TSC value
+WrTSC:	mov	bx,ullTSC		; load the address to write it to
+	mov	[bx],eax		; write the LSDW
+	mov	[bx+4],edx		; write the MSDW
+	popad
+	.8086
+	exit
+
+	;
+	; GetWinMs - Get Windows VTD time (thanks to Lattice Semiconductor!)
+	;
+	; On entry:
+	;	No requirements
+	;
+	; On exit:
+	;	DX:AX = current system time [ms since Windows started]
+	;		(0 if the VTD does not support an API)
+        ;	All other registers unchanged, interrupts on
+	;
+	entry	GetWinMs,noframe,far	; set up entry point
+	pushm	bx,di,es
+	mov	ax,1684h		; get Windows device API entry point
+	mov	bx,5			; virtual timer device ID
+	xor	di,di
+	mov	es,di
+	int	2Fh
+	mov	ax,di			; get ready to return 0 on failure
+	mov	dx,es
+	or	ax,dx			; does the VTD support an API?
+	jz	vtdRet			; no, return 0
+	mov	word ptr SaveESP,di
+	mov	word ptr SaveESP+2,es
+	mov	ax,101h			; get current system time [ms] in EAX
+	.386
+	push	eax
+	pop	ax
+	push	edx			; save MSDW of the used registers
+	pop	dx
+	call	SaveESP
+	push	eax			; move return value from EAX to DX:AX
+	pop	ax
+	pop	edx
+	push	ax			; restore MSDW of the used registers
+	pop	eax
+	.8086
+vtdRet:	popm	es,di,bx
+	exit
+
+	;
+	; MonitorOnOff - Turn monitor on or off
+	;		(if VESA BIOS present and function supported)
+	;
+	; On entry:
+	;	Arguments on stack:
+	;	char state     new power state:
+	;			0	On
+	;			1	standby
+	;			2	suspend
+	;			4	Off
+	;			8	reduced On (for flat screens)
+	;
+	; On exit:
+	;	Monitor turns off
+	;
+	entry	MonitorOnOff,argframe,far; set up entry point
+	argW	state
+	mov	ax,4F10h
+	mov	bl,1			; set display power state
+	mov	bh,state
+	int	10h
+	exit
+
+	; convert 2 BCD nibbles in AL to binary (AH is zeroed)
+
+	entry	bcd2bin,noframe,near
+	mov	ah,al
+	and	al,0Fh
+	shrn	ah,4
+	aad
+	exit
+	;
+	; SetPowerState - Set new system power state (Standby, Suspend or Off)
+	;		  (thanks to David Lindauer for this method!)
+	;
+	; On entry:
+	;	Arguments on stack:
+	;	  int state    new power state:
+	;		1	standby
+	;		2	suspend
+	;		3	off (not supported for device ID 1 in APM 1.0)
+	;
+	; On exit:
+	;	System switches off or enters standby or suspend state
+	;
+	entry	SetPowerState,argframe,far; set up entry point
+	argW	state
+	mov	ax,5300h		; See if APM available
+	mov	bx,0			; device = BIOS
+	int	15h
+	jc	err
+	cmp	ax,101h 		; See if version 1.1 or greater
+	jc	err
+	mov	cx,ax			; save version
+	mov	ax,5304h		; disconnect any 32-bit prot.m.interface
+	mov	bx,0			; device = BIOS
+	int	15h
+	mov	ax,5301h		; Do a real mode connection
+	mov	bx,0			; device = BIOS
+	int	15h
+	jc	err
+	mov	ax,530eh		; Enable latest version of APM
+	mov	bx,0			; device = BIOS
+	int	15h
+	jc	err
+	mov	ax,530dh		; Now engage and enable power management
+	mov	bx,1			; device = all
+	mov	cx,1			; enable
+	int	15h
+	jc	err
+	mov	ax,530fh
+	mov	bx,1			; device = ALL
+	mov	cx,1			; enable
+	int	15h
+	jc	err
+	mov	ax,5307h		; Set the power state
+	mov	bx,1			; device = ALL
+	mov	cx,state
+	int	15h			; During Suspend, timer tick "freezes"
+	cmp	_gnCPU,286		; so the time must be updated from RTC
+	jb	err			; no Real-Time Clock (RTC) - exit
+	mov	ah,2
+	int	1Ah			; get Real-Time Clock time in BCD
+	jc	err
+	mov	al,ch			; Convert from BCD to binary
+	call	bcd2bin			; hour
+	mov	ch,al
+	mov	al,cl
+	call	bcd2bin			; minute
+	mov	cl,al
+	mov	al,dh
+	call	bcd2bin			; second
+	mov	dh,al
+	calldos	SETTIME			; have DOS set the timer ticks
+err:	exit
+
+	;
+	; RebootW9x - Reboot Windows 9x/ME (thanks to "sk" for this method!)
+	;
+	; On entry:
+	;	No requirements
+	;
+	; On exit:
+	;	Windows reboots
+	;
+	entry	RebootW9x,noframe,far	; set up entry point
+	mov	bp,sp			; stack frame
+	cli
+	mov	ax,1687h		; get address of DPMI host's
+	int	2Fh			; mode switch entry point
+	or	ax,ax
+	jnz	reset			; no DPMI host?!
+	push	es			; save entry point
+	push	di
+	push	ds			; will zap the first 656 bytes of data
+	pop	es			; segment of the data area
+	push	cs			; all subsequent data - inline in code
+	pop	ds			; 4DOS data section not needed anymore
+	xor	ax,ax			; bit 0=0 indicates 16-bit application
+	call	far ptr [bp-4]		; switch to protected mode
+	jc	reset			; mode switch failed?!
+	call	clcdlta
+delta	db	'MS-DOS',0		; vendor-specific API name (MS Windows)
+descr	dq	?			; descriptor copy buffer
+clcdlta:pop	si			; "delta" offset
+	mov	ax,168Ah
+	int	2Fh			; get vendor-specific API entry point
+	and	al,al
+	jne	reset			; failed?!
+	push	es			; save the entry point
+	push	di
+	push	ds			; descriptor buffer segment
+	pop	es
+	mov	cx,1			; number of descriptors to allocate
+	xor	ax,ax
+	int	31h			; allocate first LDT descriptor
+	jc	reset
+	push	ax			; save its base selector
+	xor	ax,ax
+	int	31h			; allocate second LDT descriptor
+	jc	reset
+	mov	[bp-2],ax		; save its base selector
+	and	al,11111000b
+	push	ax			; and a copy with TI=GDT:RPL=0
+	mov	bx,cs			; LDT selector
+	lea	di,[descr-delta+si]	; descriptor buffer offset
+	mov	ax,0Bh
+	int	31h			; get CS descriptor
+	jc	reset
+	mov	ax,100h
+	call	far ptr [bp-8]		; get LDT alias selector
+	jc	reset
+	mov	es,ax			; save it
+	lea	ax,[reset-delta+si]	; target segment entry point offset
+	add	ax,[di+2]		; segment base, bits 15:00
+	mov	bl,[di+4]		;	"	"    23:16
+	mov	bh,[di+7]		;	"	"    31:24
+	adc	bx,0			; now BX:AX = offset in segment
+	pop	di			; the LDT base selector with RPL=0
+	stosw				; Generate call gate: offset bits 15:00
+	pop	ax			;		      segment selector
+	stosw
+	and	al,11111000b		; save a copy with TI=GDT:RPL=0
+	push	ax
+	mov	ax,11101100b shl 8	; P=1:DPL=3:S=0:Type=0Ch (call gate)
+	stosw				;		      control bits
+	xchg	ax,bx			;		      offset bits 31:16
+	stosw
+	pop	di			; Generate Ring 0 CS descriptor:
+	mov	ax,-1			; segment limit will be 4 GB
+	stosw				;	"	, bits 15:00
+	inc	ax
+	stosw				; zero segment base, bits 15:00
+	stosb				;	"	"	" 23:16
+	mov	ax,1100111110011010b	; G=1:32=1:AVL=0:Limit=4GB (bits 19:16)
+	stosw				; P=1:DPL=0:S=1:Code:NoConf:Read:NoAces
+	xor	al,al
+	stosb				; zero segment base, bits 31:24
+	call	far ptr [bp-4]		; switch to Ring 0
+reset:	mov	al,0FEh			; pulse RESET low for 6 microseconds
+	out	64h,al			; "cold" boot
+RebootW9x endp
+
+	;
+	; RebootOS2 - Reboot OS/2 (thanks to Roman Stangl for this method!)
+	;
+	; On entry:
+	;	Arguments on stack:
+	;	  int nFH		file handle to the opened "DOS$" device
+	;
+	; On exit:
+	;	OS/2 reboots
+	;
+	entry	RebootOS2,argframe,far	; set up entry point
+	argW	nFH
+	mov	ax,440Ch		; generic character device request
+	mov	bx,nFH
+	mov	cx,0D5ABh		; CH: category (IOCTL_DOS)
+	xor	dx,dx			; CL: function (DOS_REBOOT)
+	xor	si,si			; all other IOCTL parameters are zero
+	xor	di,di
+	int	21h			; do IOCTL device request and reboot
+	mov	al,0FEh			; OS/2 didn't reboot for some reason -
+	out	64h,al			;   let it terminate the process...
+	exit
+
+	;
+	; Reboot
+	;
+	; On entry:
+	;	Arguments on stack:
+	;	  char fType		bit 0: 1 = "hard", 0 = "soft" reset
+	;
+	; On exit:
+	;	PC reboots
+	;
+	entry	Reboot,argframe,far	; set up entry point
+	argB	fType
+	test	byte ptr fType,1	; "standard" reboot?
+	jz	softRst			; yes
+	cmp	_gnCPU,286		; no, get CPU type - XTs have different
+	jb	softRst			;   keyboard controller
+	cli
+	in	al,64h			; read 804x status byte
+	test	al,10b			; bit 1: "input buffer full"
+	jnz	softRst
+	xor	al,al			; clear DMA page port
+	out	080h, al		; clear mfg port
+	mov	al,0FEh			; cold boot (through keyboard reset)
+	out	064h,al			;   (because QEMM & MAX intercept boot)
+softRst:mov	ax,seg rsegm
+	mov	es,ax
+	cmp	es:[0FFF0h],19CDh	; Int 19h opcode (put by some EMM)?
+	jne	jump			; no, jump to the ROM reset address
+	int	19h			; yes, do it as intended by the EMM
+jump:	mov	dx,offset qemm_dev	; check if QEMM installed (needed as
+	mov	ax,3D00h		;   Stealth ROM doesn't support E05B)
+	int	21h			; try to open "QEMM386$"
+	jc	noqemm			; if CY, QEMM not present
+	jmp	far ptr FFF0h		; reset (BIOS jumps to E05B)
+noqemm:	jmp	far ptr E05Bh		; reboot
+Reboot	endp
+
 @curseg	ends
 
+rsegm	segment at 0F000h
+	org	0E05Bh
+E05Bh	label	byte
+	org	0FFF0h
+FFF0h	label	byte
+rsegm	ends
+
           end
 
diff -Nu d:7.501/env.c SOURCES/env.c
--- d:7.501/env.c	2006-11-12 16:00:50 +0200
+++ SOURCES/env.c	2009-02-26 15:45:56 +0200
@@ -65,7 +65,7 @@
 int _fastcall __Unset( LPTSTR, TCHAR _far * );
 
 
-#pragma alloc_text( MISC_TEXT, SetFromFile, __Set, __Unset, add_list )
+#pragma alloc_text( MISC_TEXT, SetFromFile, __Set, __Unset, get_alias, add_list, next_env, end_of_env )
 
 
 
@@ -201,7 +201,9 @@
 
 	// strip leading switches
 	if (( pszCmdLine != NULL ) && ( *pszCmdLine == gpIniptr->SwChr )) {
-		if ( GetSwitches( pszCmdLine, "AMPR", &fSet, 1 ) != 0 )
+		if ( pszCmdLine[2] == _TEXT('=') )// kludge for SET /S=PARAMETER
+			goto do_it;
+		if ( GetSwitches( pszCmdLine, "AMPRE", &fSet, 1 ) != 0 )
 			return USAGE_ERR;
 	}
 
@@ -210,8 +212,11 @@
 		pchList = glpMasterEnvironment;
 
 	// read environment or alias file(s)
-	if ( fSet & SET_READ )
+	if ( fSet & SET_READ ) {
+		if (( fSet & SET_DEFAULT ) && pchList == glpMasterEnvironment && pchList != glpEnvironment )
+			SetFromFile( pszCmdLine, glpEnvironment, fSet & ( SET_DEFAULT | SET_SYSTEM | SET_USER | SET_VOLATILE ));
 		return ( SetFromFile( pszCmdLine, pchList, fSet & ( SET_DEFAULT | SET_SYSTEM | SET_USER | SET_VOLATILE )));
+	}
 
 	if ( setjmp( cv.env ) == -1 )
 		return CTRLC;
@@ -261,15 +266,26 @@
 			qputs( pszArg );
 			crlf();
 		}
+		if ( pszArg == pszCmdLine )
+			return 0;
 
 		// create/modify/delete a variable
-		return (( pszArg == pszCmdLine ) ? 0 : add_list( pszCmdLine, pchList ));
+		goto do_it;
 	}
 
 	// display the current variable or alias argument?
 	// (setting environment vars requires a '='; it's optional with aliases)
-	if ((( pszArg = strchr( pszCmdLine, _TEXT('=') )) == NULL ) && (( pchList == 0L ) || ( ntharg( pszCmdLine, 0x8001 ) == NULL ))) {
+	if (( strchr( pszCmdLine, _TEXT('=') ) == NULL ) && (( pchList == 0L ) || ( ntharg( pszCmdLine, (int)0x8001 ) == NULL ))) {
 
+		if ( strpbrk( pszCmdLine, _TEXT("*?[") )) { // wildcard display
+			for ( lpszVars = pchList; *lpszVars; lpszVars = next_env( lpszVars ) ) {
+				TCHAR szVarName[128];
+				sscanf_far( lpszVars, _TEXT("%127[^=]"), szVarName );
+				if ( szVarName[0] && !wild_cmp( pszCmdLine, szVarName, FALSE, TRUE ))
+					more_page( lpszVars, 0 ); // got a match - display it
+			}
+			return 0;
+		}
 		if (( lpszVars = get_list( pszCmdLine, pchList )) == 0L ) {
 
 			return ERROR_NOT_IN_LIST;
@@ -280,6 +296,8 @@
 	}
 
 	// create/modify/delete a variable or alias
+do_it:	if (( fSet & SET_DEFAULT ) && pchList == glpMasterEnvironment && pchList != glpEnvironment )
+		add_list( pszCmdLine, glpEnvironment );
 	return ( add_list( pszCmdLine, pchList ));
 }
 
@@ -579,7 +597,7 @@
 
 	for ( ; (( *pszLine ) && ( *pszLine != _TEXT('=') )); pszLine++ ) {
 
-		if ( pchList != glpEnvironment ) {
+		if ( pchList != glpEnvironment && pchList != glpMasterEnvironment ) {
 
 			if ( iswhite( *pszLine )) {
 				strcpy( pszLine, skipspace( pszLine ) );
@@ -592,7 +610,7 @@
 
 	// stupid kludge to strip quotes from PATH for compatibility with
 	//   COMMAND.COM
-	if (( fWin95 ) && ( pchList == glpEnvironment )) {
+	if (( fWin95 ) && ( pchList == glpEnvironment || pchList == glpMasterEnvironment )) {
 
 		char szVarName[8];
 
@@ -611,7 +629,7 @@
 
 		// collapse whitespace around '=' in aliases, but not in env
 		//   variables, for COMMAND.COM compatibility (set abc def= ghi)
-		if ( pchList != glpEnvironment )
+		if ( pchList != glpEnvironment && pchList != glpMasterEnvironment )
 			strcpy( pszLine, skipspace( pszLine ));
 
 	} else if ( *pszLine ) {
@@ -623,7 +641,7 @@
 	// removing single back quotes at the beginning and end of an alias
 	//   argument (they're illegal there; the user is probably making a
 	//   mistake with ALIAS /R)
-	if (( *pszLine == SINGLE_QUOTE ) && ( pchList != glpEnvironment )) {
+	if (( *pszLine == SINGLE_QUOTE ) && ( pchList != glpEnvironment ) && ( pchList != glpMasterEnvironment )) {
 
 		// remove leading single quote
 		strcpy( pszLine, pszLine + 1 );
diff -Nu d:7.501/eval.c SOURCES/eval.c
--- d:7.501/eval.c	2006-11-12 16:00:50 +0200
+++ SOURCES/eval.c	2008-10-12 13:28:54 +0200
@@ -118,6 +118,10 @@
 		delim_type = XOR;
 		line += 2;
 		return operators[XOR];
+	} else if ( _strnicmp( line, "mod", 3 ) == 0 ) {
+		delim_type = MODULO;
+		line += 2;
+		return operators[MODULO];
 	}
 
 	delim_type = 0;
@@ -461,9 +465,6 @@
 
 		unsigned long ulHex;
 
-		// _fmtin (in inout.asm) doesn't like lower case!
-		strupr( token );
-
 		sscanf( token, "%lx", &ulHex );
 		sprintf( token, "%lu", ulHex );
 
@@ -508,7 +509,7 @@
 {
 	register int n;
 	unsigned int uMax, uMin;
-	int rval = 0;
+	int rval = 0, fHexOut = 0, fLeading0x = 0;
 	char *ptr;
 	BCD x;
 
@@ -517,10 +518,17 @@
 
 	// %@eval[...=n] sets the default minimum decimal precision
 	// %@eval[...=.n] sets the default maximum decimal precision
+	// %@eval[...=H] sets hex unsigned output (32-bit as hex input in 4DOS)
+	// %@eval[...=X] is as =H but the hex output is preceded by a 0x
 	if (( ptr = strchr( expr, '=' )) != NULL ) {
 
 		*ptr++ = '\0';
-		SetEvalPrecision( skipspace( ptr ), &uMin, &uMax );
+		if ( *ptr == 'H' || *ptr == 'h' )
+			fHexOut = 1;
+		else if ( *ptr == 'X' || *ptr == 'x' )
+			fHexOut = fLeading0x = 1;
+		else
+			SetEvalPrecision( skipspace( ptr ), &uMin, &uMax );
 		if ( *expr == '\0' )
 			return 0;
 	}
@@ -575,6 +583,11 @@
 
 		if (( x.sign == '-' ) && ( _stricmp( expr, "0" ) != 0 ))
 			strins( expr, "-" );
+		if ( fHexOut ) {
+			unsigned long ulHex;
+			sscanf( expr, "%ld", &ulHex );
+			sprintf( expr, fLeading0x ? "0x%lx" : "%lx", ulHex );
+		}
 	}
 
 	return rval;
diff -Nu d:7.501/exitwmsg.h SOURCES/exitwmsg.h
--- d:7.501/exitwmsg.h	1970-01-01 02:00:00 +0200
+++ SOURCES/exitwmsg.h	2008-11-04 15:00:12 +0200
@@ -0,0 +1,13 @@
+#include <string.h>
+
+#define TZNAME_MAX 128
+
+const char _far * _fastcall get_variable(const char *);
+
+// replacement of getenv() to avoid linking the standard MSVC startup code
+static char *getenv(const char *var)
+{
+	static char TZbuf[TZNAME_MAX*4];
+	const char _far *p = get_variable(var);
+	return p ? (char *)(long)_fstrcpy(TZbuf, p) : NULL;
+}
diff -Nu d:7.501/expand.c SOURCES/expand.c
--- d:7.501/expand.c	2006-11-12 16:00:50 +0200
+++ SOURCES/expand.c	2009-02-27 09:26:00 +0200
@@ -45,6 +45,7 @@
 #include <dos.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <malloc.h>
 #include <math.h>
 #include <sys\types.h>
@@ -52,10 +53,18 @@
 #include <io.h>
 #include <share.h>
 #include <string.h>
+#include <time.h>
 
 #include "4all.h"
 #include "inifile.h"
 
+extern TCHAR gaPushdQueue[];
+#ifndef __WATCOMC__
+extern int __dst_adjust;
+#endif
+extern struct tm *_gmtime( const time_t *, struct tm * );
+
+static int nExecStrRet = 0;
 
 void _fastcall SeekToEnd( int );
 static int _near _fastcall UserFunctions( LPTSTR, LPTSTR );
@@ -63,6 +72,7 @@
 static LPTSTR _near _fastcall var_internal( LPTSTR );
 static int _near _fastcall AttributeString( LPTSTR, int * );
 static void _near FormatLong( LPTSTR, LPCTSTR, ULONG_PTR );
+static int _near Format64bit( LPTSTR, LPCTSTR, t_int64 * );
 static int _fastcall __history( LPTSTR, int );
 
 
@@ -695,7 +705,7 @@
 	LPTSTR pszVariable, pszArg;
 	TCHAR szBuffer[MAXLINESIZ+8], szFunction[32];
 	LPTSTR pszLine, pszStartVar, pszOldVar = NULL;
-	int i, n, nLoopCount = 0, nLength, fAliasFunc, fUserFunc, fExpansion;
+	int i, n, nLoopCount = 0, nLength, fAliasFunc, fUserFunc, fExpansion, fAsterisk = 0;
 	char _far *lpszVarValue;
 
 	// check for variable expansion disabled
@@ -874,7 +884,7 @@
 			// kludge for CMD.EXE compatibility - %* means
 			//   "all the arguments" - i.e., %1$
 			if (( *pszVariable == _TEXT('*') ) && (( pszVariable[1] == _TEXT('\0') ) || ( strchr( _TEXT(" \t,\"|<>"), pszVariable[1] ) != NULL )))
-				*pszVariable = gpIniptr->ParamChr;
+				fAsterisk = *pszVariable = gpIniptr->ParamChr;
 
 			// get the environment (or internal) variable name
 			if (( cv.bn >= 0 ) && (( isdigit( *pszVariable )) || ( *pszVariable == gpIniptr->ParamChr ))) {
@@ -957,9 +967,10 @@
 					pszVariable = szBuffer;
 
 					// check for %* (return all arguments, UNSHIFTED!)
-					if ( *pszVariable == '*' )
+					if ( fAsterisk ) {
+						fAsterisk = 0;
 						i = 1;
-					else
+					} else
 						i = (( *pszVariable == gpIniptr->ParamChr ) ? 1 : atoi( pszVariable )) + bframe[cv.bn].Argv_Offset;
 
 					for ( pszVariable = szBuffer; isdigit( *pszVariable ); pszVariable++ )
@@ -1049,7 +1060,7 @@
 		if ( pszArg != NULL ) {
 
 			i = strlen( pszArg );
-			if (( strlen( pszStartLine ) + i ) >= (int)(( pszStartLine == gszCmdline ) ? CMDBUFSIZ - 1 : MAXLINESIZ - 1 ))
+			if (( strlen( pszStartLine ) + i ) >= (unsigned int)(( pszStartLine == gszCmdline ) ? CMDBUFSIZ - 1 : MAXLINESIZ - 1 ))
 				goto var_too_long;
 
 			strins( pszLine, pszArg );
@@ -1057,7 +1068,7 @@
 			// kludge to allow alias expansion when variable is
 			//   first arg on command line
 			pszArg = first_arg( pszStartLine );
-			if (( pszArg != NULL ) && ( fRecurse == 0 ) && ((int)( pszLine - pszStartLine ) < strlen( pszArg ))) {
+			if (( pszArg != NULL ) && ( fRecurse == 0 ) && ((unsigned int)( pszLine - pszStartLine ) < strlen( pszArg ))) {
 				if ( alias_expand( pszStartLine ) != 0 )
 					return ERROR_EXIT;
 			}
@@ -1292,6 +1303,28 @@
 			*pszArg = _TEXT('\0');
 			break;
 
+		case FUNC_AGEDATE:
+
+			// make a formatted date/time from the DOS "age" value
+			sscanf( pszVar, _TEXT("%lu,%u"), &ulTemp, &i );
+
+			if (( i < 0 ) || ( i > 6 ))
+				return ERROR_INVALID_PARAMETER;
+
+			uYear =  (unsigned)( ulTemp >> 25 ) + 80;
+			uMonth = (unsigned)( ulTemp >> 21 ) & 0xF;
+			uDay =	 (unsigned)( ulTemp >> 16 ) & 0x1F;
+
+			// replace leading space with a 0
+			if (*( pszVar = FormatDate( uMonth, uDay, uYear, i )) == _TEXT(' ') )
+				*pszVar = _TEXT('0');
+
+			uYear = (unsigned)( ulTemp >> 11 ) & 0x1F;	// hours
+			uMonth = (unsigned)( ulTemp >> 5 ) & 0x3F;	// minutes
+			uDay =	 (unsigned)( ulTemp & 0x1F ) << 1;	// seconds
+			sprintf( pszVar + strlen( pszVar ), ",%02u%c%02u%c%02u", uYear, gaCountryInfo.szTimeSeparator[0], uMonth, gaCountryInfo.szTimeSeparator[0], uDay );
+			break;
+
 		case FUNC_ALIAS:
 
 			// return the alias definition
@@ -1410,7 +1443,7 @@
 		case FUNC_CDROM:
 
 			// return 1 if the drive is a CD-ROM
-			IntToAscii( QueryIsCDROM( szDrive ), pszVar );
+			IntToAscii( QueryIsCDROM( gcdisk( szDrive )), pszVar );
 			break;
 
 		case FUNC_CHAR:
@@ -1452,6 +1485,28 @@
 			pszVar = _TEXT("0");
 			break;
 
+		case FUNC_CLUSTSIZE:
+
+			if ( QueryDiskInfo( szDrive, &DiskInfo, 0 ))
+				return -ERROR_EXIT;
+			sprintf( pszVar, FMT_LONG, DiskInfo.ClusterSize );
+			break;
+
+		case FUNC_CODEPAGE:
+
+			// device (CON or PRN) codepage, SELECTed by MODE
+			strip_trailing( pszFileName, _TEXT(":") );
+			if (( n = QueryDeviceCodePage( pszFileName )) < 0 )
+				return ERROR_INVALID_PARAMETER;
+			IntToAscii( n, pszVar );
+			break;
+
+		case FUNC_COM:
+
+			// return ready (1) or not ready (0) for the serial port
+			IntToAscii( QuerySerialReady( atoi( pszFileName ) - 1 ), pszVar );
+			break;
+
 		case FUNC_COMMA:
 
 			// format a long integer by inserting commas (or other
@@ -1459,6 +1514,21 @@
 			AddCommas( pszVar );
 			break;
 
+		case FUNC_COMPARE:
+
+			// compare the specified files
+			pszFileName = scan( pszVar, _TEXT(","), QUOTES );
+			if ( pszFileName == pszVar || pszFileName == BADQUOTES || *pszFileName != _TEXT(',') || pszFileName[1] == _TEXT('\0'))
+				return ERROR_INVALID_PARAMETER;
+			*pszFileName++ = _TEXT('\0');
+
+			strcpy( szFindFilename, pszFileName );// allow expansion
+			if ( ProcessFileName( pszVar, 1 ) || ProcessFileName( szFindFilename, 1 ))
+				return -ERROR_EXIT;
+
+			IntToAscii( CompareFiles( pszVar, szFindFilename ), pszVar );
+			break;
+
 		case FUNC_CONVERT:
 			{
 
@@ -1485,23 +1555,60 @@
 			break;
 			}
 
+		case FUNC_COUNT:
+
+			// count occurrences of a character in a string
+			escape( pszVar );
+			if ( sscanf( pszVar, _TEXT("%c%*[^,],%n"), (TCHAR *)&i, &n ) < 2 )
+				return ERROR_INVALID_PARAMETER;
+
+			for ( pszVar += n, n = 0; *pszVar; pszVar++ )
+				if ( *pszVar == (TCHAR)i )
+					n++;
+			IntToAscii( n, pszVar = szBuffer );
+			break;
+
 		case FUNC_CRC32:
-			// calculate a CRC32 for the specified file
+		case FUNC_MD5:
+		case FUNC_SHA1:
+			// calculate a CRC32, MD5 or SHA1 for the specified file
 			if ( ProcessFileName( pszVar, 1 ) != 0 )
 				return -ERROR_EXIT;
 
 			if ( is_file( pszVar ) == 0 )
 				IntToAscii( -1, pszVar );
-			else {
+			else if ( nOffset != FUNC_CRC32 ) {
+				TCHAR ucDigest[20];
+				if ( MD5SHA1( pszVar, ucDigest, nOffset == FUNC_SHA1 ))
+					IntToAscii( -1, pszVar );
+				else for ( i = 0; i < ( nOffset == FUNC_SHA1 ? 20 : 16 ); i++ )
+					sprintf( &pszVar[2*i], _TEXT("%02x"), ucDigest[i] );
+			} else {
 				ulTemp = CRC32( pszVar );
 				sprintf( pszVar, _TEXT("%08lx"), ulTemp );
 			}
 
 			break;
 
+		case FUNC_CWD:
+
+			// current working directory
+			if (( pszVar = gcdir( szDrive, 0 )) == NULL)
+				return -ERROR_EXIT;
+			break;
+
+		case FUNC_CWDS:
+
+			// cwd w/backslash guaranteed
+			if (( pszVar = gcdir( szDrive, 0 )) == NULL )
+				return -ERROR_EXIT;
+			mkdirname( pszVar, NULLSTR );
+			break;
+
 		case FUNC_DOW:		// day of week (Sun - Sat)
 		case FUNC_DOWF:		// day of week (Sunday - Saturday)
 		case FUNC_DOWI:		// day of week (1-7)
+		case FUNC_ISODOWI:	// day of week (1-7, ISO)
 
 			if (( n = MakeDaysFromDate(  &lOffset, pszVar )) != 0 )
 				return n;
@@ -1510,6 +1617,8 @@
 				sprintf( pszVar, _TEXT("%.3s"), daytbl[n] );
 			else if ( nOffset == FUNC_DOWF )
 				strcpy( pszVar, daytbl[n] );
+			else if ( nOffset == FUNC_ISODOWI )
+				IntToAscii( n ? n : 7, pszVar );
 			else
 				IntToAscii( n+1, pszVar );
 			break;
@@ -1517,29 +1626,30 @@
 		case FUNC_DOY:		// day of year (1-366)
 		case FUNC_DAY:
 		case FUNC_MONTH:
+		case FUNC_MONTHF:
 		case FUNC_YEAR:
-			if ( GetStrDate( pszVar, &uMonth, &uDay, &uYear ) != 3 )
+		case FUNC_ISOWEEK:	// week of year (ISO)
+		case FUNC_ISOWYEAR:
+
+			if ( GetStrDate( pszVar, &uMonth, &uDay, &uYear ))
 				return ERROR_4DOS_INVALID_DATE;
 
 			if ( nOffset == FUNC_DOY ) {
-
-				// get days for previous months
-				for ( i = 1; ( i < ( int)uMonth ); i++ ) {
-					if ( i == 2 ) {
-						if (( uYear % 100 ) == 0 )
-							uDay += ((( uYear % 400 ) == 0 ) ? 29 : 28 );
-						else
-							uDay += ((( uYear % 4 ) == 0 ) ? 29 : 28 );
-					} else
-						uDay += ((( i == 4 ) || ( i == 6 ) || ( i == 9 ) || ( i == 11 )) ? 30 : 31 );
-				}
-				IntToAscii( uDay, pszVar );
-
+				ISOweekDOY( &uDay, uMonth, &uYear, &n );
+				IntToAscii( n, pszVar );
 			} else if ( nOffset == FUNC_DAY )
 				IntToAscii( uDay, pszVar );
 			else if ( nOffset == FUNC_MONTH )
 				IntToAscii( uMonth, pszVar );
-			else		// year needs to be at least 2 digits, with leading 0 if necessary
+			else if ( nOffset == FUNC_MONTHF ) {
+				if ( uMonth > 0 && uMonth <= 12 )
+					strcpy( pszVar, lmontbl[uMonth-1] );
+				else
+					return ERROR_4DOS_INVALID_DATE;
+			} else if ( nOffset == FUNC_ISOWEEK || nOffset == FUNC_ISOWYEAR ) {
+				n = ISOweekDOY( &uDay, uMonth, &uYear, &i );
+				IntToAscii( nOffset == FUNC_ISOWEEK ? n : uYear, pszVar );
+			} else	// year needs to be at least 2 digits, with leading 0 if necessary
 				sprintf( pszVar, _TEXT("%02d"), uYear );
 			break;
 
@@ -1552,6 +1662,25 @@
 			sprintf( pszVar, FMT_LONG, ulTemp );
 			break;
 
+		case FUNC_DATECONV:
+
+			// convert date from one format to another
+			for ( pszFileName = pszVar; *pszFileName && *pszFileName != _TEXT(','); pszFileName++ )
+				;		// search for a comma
+			if ( *pszFileName ) {	// found one
+				*pszFileName++ = _TEXT('\0'); // terminate date
+				if ( sscanf( pszFileName, _TEXT("%d"), &i ) < 1 || i < 0 || i > 6 )
+					return ERROR_INVALID_PARAMETER;
+			} // else i = 0 still
+
+			if ( GetStrDate( pszVar, &uMonth, &uDay, &uYear ))
+				return ERROR_4DOS_INVALID_DATE;
+
+ 			// replace leading space with a 0
+			if (*( pszVar = FormatDate( uMonth, uDay, uYear, i )) == _TEXT(' ') )
+				*pszVar = _TEXT('0');
+			break;
+
 		case FUNC_DECIMAL:
 
 			// return the decimal (fractional) part
@@ -1588,9 +1717,23 @@
 			pszVar = szBuffer;
 			break;
 
+		case FUNC_DIRSTACK:
+
+			// return nth entry in the directory stack or its length
+			n = *pszFileName ? atoi( pszFileName ) : INT_MAX;
+			// still i = 0
+			for ( lpPtr = gaPushdQueue; *lpPtr && i < n; i++ )
+				lpPtr = next_env( lpPtr );
+			if ( n < INT_MAX )
+				_fstrcpy( pszVar, lpPtr );
+			else
+				IntToAscii( i, pszVar );
+			break;
+
 		case FUNC_DISKFREE:
 		case FUNC_DISKTOTAL:
 		case FUNC_DISKUSED:
+		case FUNC_HDDSIZE:
 			{
 
 				// return the disk stats
@@ -1608,11 +1751,16 @@
 					strcpy( pszVar, DiskInfo.szBytesFree );
 				else if ( nOffset == FUNC_DISKTOTAL )
 					strcpy( pszVar, DiskInfo.szBytesTotal );
-				else
+				else if ( nOffset == FUNC_DISKUSED )
 					sprintf( pszVar, "(%s-%s)", DiskInfo.szBytesTotal, DiskInfo.szBytesFree );
+				else {	// FUNC_HDDSIZE
+					static LBA buf = { 26 };
+					buf.uFlags = 0;	// PhoenixBIOS 4.0R6.0 bug
+					GetHDDParams( GetDrivePhysUnit( gcdisk( szDrive )), &buf );
+					sprintf( pszVar, "%s*%u", Format64( &buf.llTotalSectors ), buf.uSectSize );
+				}
 
-				// get the size value (B, K, or M)
-				// if user wants K or M, shift it
+				// get the size value (B, K, M or G)
 
 				if ( i != 0 ) {
 					if ( i == 'k' )
@@ -1623,6 +1771,10 @@
 						strcat( pszVar, "\\1000000" );
 					else if ( i == 'M' )
 						strcat( pszVar, "\\1048576" );
+					else if ( i == 'g' )
+						strcat( pszVar, "\\1000000000" );
+					else if ( i == 'G' )
+						strcat( pszVar, "\\1073741824" );
 				}
 
 				evaluate( pszVar );
@@ -1639,6 +1791,20 @@
 			FormatLong( pszVar, pszFileName, (unsigned long)(unsigned int)ServCtrl( SERV_AVAIL, 0 ) << 4 );
 			break;
 
+		case FUNC_DRIVETYPE:
+
+			// return drive type (0-6)
+			IntToAscii( QueryDriveType( szDrive ), pszVar );
+			break;
+
+		case FUNC_DDCSTR:
+
+			// return a Display Data Channel (DDC)
+			// Enhanced Display Identification Data (EDID) string
+			if (( pszVar = GetDDCstring( atoi( pszFileName ), pszVar )) != NULL )
+				strip_trailing( pszVar, _TEXT("\n "));
+			break;
+
 		case FUNC_ERRTEXT:
 
 			// returns OS text for the specified code
@@ -1656,6 +1822,15 @@
 			pszVar = szBuffer;
 			break;
 
+		case FUNC_CEILING:
+		case FUNC_FLOOR:
+
+			pszArg = strend( pszVar );
+			sprintf( pszArg, _TEXT("+0%c4999999999=0%c0"), gaCountryInfo.szDecimal[0], gaCountryInfo.szDecimal[0] );
+			if ( nOffset == FUNC_FLOOR )
+				*pszArg = _TEXT('-');
+			goto Eval;
+
 		case FUNC_INC:
 		case FUNC_DEC:
 			// shorthand for %@EVAL[pszVar+1] or %@EVAL[pszVar-1]
@@ -1663,7 +1838,7 @@
 			//lint -fallthrough
 
 		case FUNC_EVAL:
-
+Eval:
 			// calculate simple algebraic expressions
 			if ( evaluate( pszVar ) != 0 )
 				return -ERROR_EXIT;
@@ -1712,7 +1887,7 @@
 				i = cv.fVerbose;
 				cv.fVerbose = 0;
 
-				DoINT2E( pszVar );
+				nExecStrRet = DoINT2E( pszVar );
 				if ( cv.bn >= 0 )
 					bframe[cv.bn].uEcho = n;
 
@@ -1838,7 +2013,7 @@
 				} else if ( nOffset == FUNC_FILEDATE ) {
 
 					// optional date format
-					if (( i = atoi( pszArg )) > 4 )
+					if (( i = atoi( pszArg )) > 5 )
 						return ERROR_INVALID_PARAMETER;
 
 					// replace leading space with a 0
@@ -1915,10 +2090,11 @@
 			break;
 
 		case FUNC_FILEREAD:
+		case FUNC_FILEREADB:
 
 			// read a line from the specified file handle
-			// second argument is optional read length
-			if (( sscanf( pszVar, _TEXT("%d ,%d"), &i, &n ) < 1 ) || ( i < 3 ) || ( n < 0 ))
+			// second argument is read length, optional for FILEREAD
+			if (( sscanf( pszVar, _TEXT("%d ,%d"), &i, &n ) < ( nOffset == FUNC_FILEREAD ? 1 : 2 )) || ( i < 3 ) || ( n < ( nOffset == FUNC_FILEREAD ? 0 : 1 )))
 				return ERROR_INVALID_PARAMETER;
 
 			if ( n == 0 ) {
@@ -1934,7 +2110,15 @@
 				else
 					pszVar[n] = _TEXT('\0');
 			}
-
+			if ( nOffset == FUNC_FILEREADB ) {
+				szDrive[0] = _TEXT('\0');
+				for ( pszArg = pszVar; n > 0 && strlen( szDrive ) < sizeof( szDrive ) - 4; pszArg++, n-- ) {
+					if ( pszArg != pszVar )
+						strcat( szDrive, _TEXT(" ") );
+					IntToAscii( *pszArg, strend( szDrive ));
+				}
+				pszVar = szDrive;
+			}
 			break;
 
 		case FUNC_FILES:
@@ -1988,7 +2172,7 @@
 		case FUNC_FILESIZE:
 			{
 
-				unsigned long llTemp;
+				t_int64 llTemp;
 				// display allocated size?
 				if ((( pszVar = ntharg( pszVar, 2 )) != NULL ) && ( _ctoupper( *pszVar ) == _TEXT('A') ))
 					i = 1;
@@ -2001,7 +2185,7 @@
 
 				// file size test
 
-				if (( llTemp = (ULONG)QueryFileSize( pszFileName, i )) != (ULONG)-1L ) {
+				if ( QueryFileSize64( pszFileName, i, &llTemp ) == 0 ) {
 
 					// get the size value (B, K, or M)
 					if (( pszFileName = ntharg( szBuffer, 1 )) == NULL )
@@ -2009,21 +2193,22 @@
 
 					// round file sizes upwards (to match DIR /4)
 					if ( *pszFileName == _TEXT('k') )
-						llTemp += 999;
+						Add32To64( &llTemp, 499L );
 					else if ( *pszFileName == _TEXT('K') )
-						llTemp += 1023;
+						Add32To64( &llTemp, 511L );
 					else if ( *pszFileName == _TEXT('m') )
-						llTemp += 999999L;
+						Add32To64( &llTemp, 499999L );
 					else if ( *pszFileName == _TEXT('M') )
-						llTemp += 1048575L;
-
-					// unknown type
-					else if (( *pszFileName ) && ( *pszFileName != _TEXT('b')) && ( *pszFileName != _TEXT('B')))
-						return ERROR_INVALID_PARAMETER;
+						Add32To64( &llTemp, 524287L );
+					else if ( *pszFileName == _TEXT('g') )
+						Add32To64( &llTemp, 499999999L );
+					else if ( *pszFileName == _TEXT('G') )
+						Add32To64( &llTemp, 536870911L );
 
 					pszVar = szBuffer;
 
-					FormatLong( pszVar, pszFileName, llTemp );
+					if ( Format64bit( pszVar, pszFileName, &llTemp ))
+						return ERROR_INVALID_PARAMETER;	// unknown type
 
 				} else
 					pszVar = _TEXT("-1");
@@ -2039,8 +2224,8 @@
 			if ( i < 1 )
 				return ERROR_INVALID_PARAMETER;
 
-			if (( n = qprintf( i, FMT_STR_CRLF, pszVar + n )) > 0 )
-				n++;
+			n = qprintf( i, FMT_STR_CRLF, pszVar + n );
+
 			IntToAscii( n, pszVar );
 			break;
 
@@ -2052,7 +2237,12 @@
 			if ( i < 3 )
 				return ERROR_INVALID_PARAMETER;
 
-			n = _write( i, pszVar+n, nLength );
+			if ( nLength < 0 ) {
+				int j, k, l = 1, m;
+				for ( j = n, n = 0; l; j += l, n += m )
+					m = sscanf( pszVar + j, FMT_UINT_LEN, &k, &l ) > 1 && l ? _write( i, &k, 1 ) : 0;
+			} else
+				n = _write( i, pszVar + n, nLength );
 
 			IntToAscii( n, pszVar );
 			break;
@@ -2108,6 +2298,15 @@
 			pszVar = szBuffer;
 			break;
 
+		case FUNC_FSTYPE:
+
+			// return file system type
+			pszVar = gszFileSystemName;
+			pszVar[0] = _TEXT('\0');
+			if ( ifs_type( szDrive ) && pszVar[0] == _TEXT('\0') )
+				pszVar = _TEXT("?");	// NTFS for Windows 98
+			break;
+
 		case FUNC_FULLNAME:
 
 			// return fully qualified filename
@@ -2124,6 +2323,35 @@
 			sprintf( szBuffer, FMT_FAR_PREC_STR, MAXLINESIZ-1, lpPtr );
 			return -6666;
 
+		case FUNC_HISTORY:
+
+			// return a line or a word from the command history
+			n = -1;	// still i = 0
+			if ( sscanf( pszVar, "%d,%d", &i, &n ) < 1 || i < 0 )
+				return ERROR_INVALID_PARAMETER;
+			for ( lpPtr = NULL; i >= 0; i-- )
+				lpPtr = prev_hist( lpPtr );
+			_fstrcpy( pszVar, lpPtr );
+			if ( n >= 0 ) {	// now i = -1
+				for ( pszArg = pszVar; n >= 0 && *pszArg; pszArg++ ) {
+					if ( isdelim( *pszArg ))
+						i = TRUE;
+					else {
+						if ( i )
+							n--;
+						i = FALSE;
+						pszVar = pszArg;
+					}
+				}
+				if ( *pszArg == _TEXT('\0') ) {
+					pszVar = pszArg;
+					break;// not reached - return empty string
+				}
+				while ( !isdelim( *pszArg ))
+					pszArg++;
+				*pszArg = _TEXT('\0');
+			}
+			break;
 
 		case FUNC_IF:
 			// return a value based upon the result of the condition
@@ -2296,8 +2524,9 @@
 			break;
 
 		case FUNC_INSERT:
+		case FUNC_SUBST:
 
-			// insert a string into another
+			// insert a string into or substitute in another
 			if (( sscanf( pszVar, _TEXT("%d ,%n"), &i, &n ) < 1 ) || ( i < 0 ))
 				return ERROR_INVALID_PARAMETER;
 
@@ -2308,9 +2537,84 @@
 				return ERROR_INVALID_PARAMETER;
 			*pszVar++ = _TEXT('\0');
 
-			if ( i > (int)strlen( pszVar ))
-				i = strlen( pszVar );
-			strins( pszVar + i, pszFileName );
+			n = strlen( pszVar );
+			if ( i > n )
+				i = n;
+			if (( nOffset == FUNC_INSERT ? n : i ) + 2 * strlen( pszFileName ) > MAXLINESIZ )
+				return ERROR_4DOS_COMMAND_TOO_LONG;
+			if ( nOffset == FUNC_INSERT )
+				strins( pszVar + i, pszFileName );
+			else
+				strcpy( pszVar + i, pszFileName );
+			break;
+
+		case FUNC_ISALNUM:
+			n = _UPPER | _LOWER | _DIGIT;
+			goto WhatChars;
+
+		case FUNC_ISALPHA:
+			n = _UPPER | _LOWER;
+			goto WhatChars;
+
+		case FUNC_ISASCII:
+#ifdef __WATCOMC__
+			n = _CNTRL | _PRINT;
+#else
+			n = _CONTROL | _BLANK | _PUNCT | _UPPER | _LOWER | _DIGIT;
+#endif
+			goto WhatChars;
+
+		case FUNC_ISCNTRL:
+#ifdef __WATCOMC__
+			n = _CNTRL;
+#else
+			n = _CONTROL;
+#endif
+			goto WhatChars;
+
+		case FUNC_ISDIGIT:
+			n = _DIGIT;
+			goto WhatChars;
+
+		case FUNC_ISLOWER:
+			n = _LOWER;
+			goto WhatChars;
+
+		case FUNC_ISPRINT:
+#ifdef __WATCOMC__
+			n = _PRINT;
+#else
+			n = _BLANK | _PUNCT | _UPPER | _LOWER | _DIGIT;
+#endif
+			goto WhatChars;
+
+		case FUNC_ISPUNCT:
+			n = _PUNCT;
+			goto WhatChars;
+
+		case FUNC_ISSPACE:
+			n = _SPACE;
+			goto WhatChars;
+
+		case FUNC_ISUPPER:
+			n = _UPPER;
+			goto WhatChars;
+
+		case FUNC_ISXDIGIT:
+#ifdef __WATCOMC__
+			n = _XDIGT;
+#else
+			n = _HEX;
+#endif
+WhatChars:
+			for ( i = 0; pszVar[i]; i++ )
+#ifdef __WATCOMC__
+				if (!(_IsTable[pszVar[i]+1] & n ))
+#else
+				if (!((_ctype+1)[pszVar[i]] & n ))
+#endif
+					break;
+			IntToAscii( !pszVar[i], pszVar );
 			break;
 
 		case FUNC_LABEL:
@@ -2430,15 +2734,10 @@
 
 			// make an "age long" from the specified date & time
 			uMonth = uDay = uYear = 0;
-			if (( GetStrDate( pszVar, &uMonth, &uDay, &uYear ) != 3 ) || ( uMonth == 0 ) || ( uMonth > 12 ) || ( uDay == 0 ) || ( uDay > 31 ))
+			if ( GetStrDate( pszVar, &uMonth, &uDay, &uYear ))
 				return ERROR_4DOS_INVALID_DATE;
 
-			if ( uYear < 80 )
-				uYear += 2000;
-			if ( uYear > 1900 )
-				uYear -= 1900;
-			if ( uYear >= 80 )
-				uYear -= 80;
+			uYear -= 1980;
 			ulTemp = ( uDay + ( uMonth << 5 ) + ( uYear << 9 ));
 			ulTemp <<= 16;
 
@@ -2462,7 +2761,7 @@
 			if (( n = MakeDateFromDays( ulTemp, &uYear, &uMonth, &uDay )) != 0 )
 				return n;
 
-			if (( i < 0 ) || ( i > 4 ))
+			if (( i < 0 ) || ( i > 6 ))
 				return ERROR_INVALID_PARAMETER;
 
 			// replace leading space with a 0
@@ -2484,10 +2783,11 @@
 
 		case FUNC_MAX:
 		case FUNC_MIN:
+		case FUNC_AVERAGE:
 			{
 				long lNum = 0;
 
-				// return largest/smallest number in list
+				// return largest/smallest/avergage number in list
 				for ( pszArg = pszVar; ( *pszArg != _TEXT('\0') ); ) {
 
 					if ( sscanf( pszArg, _TEXT("%ld%*[ ,\t]%n"), &lOffset, &i ) < 2 )
@@ -2501,6 +2801,9 @@
 					} else if ( nOffset == FUNC_MIN ) {
 						if ( lOffset < lNum )
 							lNum = lOffset;
+					} else if ( nOffset == FUNC_AVERAGE ) {
+						lNum += lOffset;
+						n++;
 					}
 
 					pszArg += i;
@@ -2508,6 +2811,12 @@
 
 				sprintf( pszVar, FMT_LONG, lNum );
 
+				if ( nOffset == FUNC_AVERAGE && n ) {
+					char s[8];
+					sprintf( s, "/%d", n + 1 );
+					strcat( pszVar, s );
+					evaluate( pszVar );
+				}
 				break;
 			}
 
@@ -2537,6 +2846,12 @@
 			pszVar = path_part( pszVar );
 			break;
 
+		case FUNC_QUOTE:
+
+			// enclose name containing whitespace by double quotes
+			AddQuotes( pszVar );
+			break;
+
 		case FUNC_RANDOM:
 			{
 				// get min & max
@@ -2544,7 +2859,7 @@
 				if (( sscanf( pszVar, _TEXT("%ld ,%ld"), &lStart, &lEnd ) != 2 ) || ( lStart > lEnd))
 					return ERROR_INVALID_PARAMETER;
 
-				sprintf( pszVar, FMT_LONG, GetRandom( lStart, lEnd ));
+				sprintf( pszVar, FMT_LONG, GetRandom() % ( ++lEnd - lStart ) + lStart );
 				break;
 			}
 
@@ -2633,6 +2948,13 @@
 				break;
 			}
 
+		case FUNC_REVERSE:
+
+			// reverse string
+			_strrev( pszVar );
+			break;
+
+
 		case FUNC_SEARCH:
 
 			if ( pszFileName == NULLSTR )
@@ -2762,6 +3084,27 @@
 				break;
 			}
 
+		case FUNC_SERIAL:
+
+			// get the volume serial number for the specified drive
+			if ( QueryVolumeInfo( szDrive, pszVar, &ulTemp ) == NULL )
+				*pszVar = _TEXT('\0');
+			else
+				sprintf( pszVar, _TEXT("%04lx:%04lx"), ulTemp >> 16, ulTemp & 0xFFFF );
+			break;
+
+		case FUNC_SMBSTR:
+
+			// get the n-th string of type i from SMBIOS (DMI)
+			escape( pszVar );
+			if (( sscanf( pszVar, _TEXT("%d%*[^,],%d"), &i, &n ) < 1 ) || i < 0 || i > 127 || n <= 0 )
+				return ERROR_INVALID_PARAMETER;
+
+			_fstrcpy( pszVar, GetDMIstring((BYTE)i, n ));
+			break;
+
+		case FUNC_LTRIM:
+		case FUNC_RTRIM:
 		case FUNC_STRIP:
 
 			// remove specified characters from string
@@ -2778,7 +3121,12 @@
 			// remove escapes from the chars to remove
 			EscapeLine( pszVar );
 
-			for ( pszVar = pszFileName; ( *pszVar != _TEXT('\0') ); ) {
+			// remove specified leading or trailing characters?
+			if ( nOffset == FUNC_LTRIM )
+				strip_leading( pszFileName, pszVar );
+			else if ( nOffset == FUNC_RTRIM )
+				strip_trailing( pszFileName, pszVar );
+			else for ( pszVar = pszFileName; ( *pszVar != _TEXT('\0') ); ) {
 
 				// skip escaped characters
 				if (( *pszVar == gpIniptr->EscChr ) && (( gpIniptr->Expansion & EXPAND_NO_ESCAPES ) == 0 )) {
@@ -2883,6 +3231,14 @@
 			strcpy( pszVar, szDrive );
 			break;
 
+		case FUNC_TRUNCATE:
+
+			// truncate the specified file at its current position
+			if (( i = atoi( pszVar )) <= 2 )
+				return ERROR_INVALID_HANDLE;
+			IntToAscii( _chsize( i, _lseek( i, 0, SEEK_CUR )), pszVar );
+			break;
+
 		case FUNC_UNIQUE:
 
 			// Creat a unique filename
@@ -2901,6 +3257,22 @@
 
 			break;
 
+		case FUNC_UNQUOTE:
+
+			// strip double quotes
+			StripQuotes( pszVar );
+			break;
+
+		case FUNC_UNQUOTES:
+
+			// strip leading and trailing double quotes
+			if ( *pszVar == DOUBLE_QUOTE )
+				strcpy( pszVar, pszVar + 1 );
+			pszArg = strlast( pszVar );
+			if ( *pszArg == DOUBLE_QUOTE )
+				*pszArg = _TEXT('\0');
+			break;
+
 		case FUNC_UPPER:
 
 			// shift string to upper case
@@ -2908,18 +3280,26 @@
 			break;
 
 		case FUNC_WILD:
+		case FUNC_LCS:
+		case FUNC_SIMILAR:
 
-			// wildcard comparison
+			// wildcard comparison or Longest Common Subsequence
 			pszFileName = pszVar;
 			pszVar = scan( pszVar, _TEXT(","), QUOTES );
 			if (( pszVar == BADQUOTES ) || ( *pszVar != _TEXT(',') ))
 				return ERROR_INVALID_PARAMETER;
 			*pszVar++ = _TEXT('\0');
 
-			pszVar = (( wild_cmp( pszVar, pszFileName, 1, TRUE ) == 0 ) ? _TEXT("1") : _TEXT("0") );
+			if ( nOffset == FUNC_WILD )
+				pszVar = (( wild_cmp( pszVar, pszFileName, 1, TRUE ) == 0 ) ? _TEXT("1") : _TEXT("0") );
+			else if ( nOffset == FUNC_LCS )
+				pszVar = LCS( pszVar, pszFileName );
+			else	// FUNC_SIMILAR
+				IntToAscii( similar_text( pszVar, pszFileName ), pszVar );
 			break;
 
 		case FUNC_FIELD:
+		case FUNC_FIELDS:
 		case FUNC_WORD:
 		case FUNC_WORDS:
 
@@ -2932,13 +3312,11 @@
 				if ( pszFileName[i-1] == _TEXT('"') )
 					pszFileName[i-1] = _TEXT('\0');
 				EscapeLine( ++pszFileName );
-				pszVar = skipspace( pszVar + i + 1 );
-			} else {
+				pszVar += i + 1; // string may begin with space so don't wkip it
+			} else
 				pszFileName = _TEXT(" ,\t");
-				pszVar = skipspace( pszVar );
-			}
 
-			if ( nOffset != FUNC_WORDS ) {
+			if ( nOffset == FUNC_WORD || nOffset == FUNC_FIELD ) {
 				// check for negative offset (scan backwards from end)
 				if ( *pszVar == _TEXT('-') ) {
 					n = 1;
@@ -2961,13 +3339,13 @@
 				// find start of arg[i]
 				while (( *pszVar != _TEXT('\0') ) && ( pszVar >= szBuffer ) && ( strchr( pszFileName, *pszVar ) != NULL )) {
 
-					// if @FIELD and first char is delimiter, don't skip it!
-					if ( nOffset == FUNC_FIELD ) {
+					// if @FIELD[S] and first char is delimiter, don't skip it!
+					if ( nOffset == FUNC_FIELD || nOffset == FUNC_FIELDS ) {
 
 						if ( fClip > 0 )
 							pszVar += ( n ? -1 : 1 );
 
-						// only look for a single delimiter for @FIELD
+						// only look for a single delimiter for @FIELD[S]
 						break;
 
 					} else
@@ -2975,7 +3353,7 @@
 				}
 
 				fClip++;
-				if ( *pszVar == _TEXT('\0') )
+				if ( *pszVar == _TEXT('\0') || pszVar < szBuffer )
 					break;
 
 				// search for next delimiter character
@@ -3010,12 +3388,12 @@
 
 				i += (( i < 0 ) ? 1 : -1 );
 
-				if (( *pszVar == _TEXT('\0') ) || (( n ) && ( pszVar <= szBuffer )))
+				if ( *pszVar == _TEXT('\0') || pszVar < szBuffer )
 					break;
 			}
 
-			if ( nOffset != FUNC_WORDS ) {
-				if ( i != 0 )
+			if ( nOffset == FUNC_WORD || nOffset == FUNC_FIELD ) {
+				if ( i != 0 || pszVar < szBuffer )
 					pszVar = NULL;
 			} else
 				IntToAscii(( 0x4000 - i ), pszVar );
@@ -3025,11 +3403,19 @@
 		case FUNC_XMS:
 
 			// get free XMS memory ( if any)
-			ulTemp = get_xms( &i );
+			ulTemp = get_xms( (unsigned *)&i );
 			FormatLong( pszVar, pszFileName, (ulTemp << 10 ));
 			break;
 
 
+		case FUNC_EMS:
+
+			// get free EMS memory ( if any)
+			get_expanded( (unsigned *)&ulTemp ); // MSW = 0 already
+			FormatLong( pszVar, pszFileName, ulTemp << 14 );
+			break;
+
+
 		case FUNC_LFN:
 			// return the LFN form of the filename
 
@@ -3120,13 +3506,66 @@
 }
 
 
+// format a 64-bit value for FUNC_FILESIZE, etc.
+// return 0 if OK, !0 if invalid format
+static int _near Format64bit( LPTSTR pszTarget, LPCTSTR pszFormat, t_int64 *llVal )
+{
+	// *llVal comes in as a value in B - if user wants K, M or G, divide it
+#ifdef NATIVE_INT64
+	t_int64 divisor = 1L;
+
+	if ( *pszFormat ) {
+		if ( *pszFormat == _TEXT('k') )
+			divisor = 1000L;
+		else if ( *pszFormat == _TEXT('K') )
+			divisor = 1024L;
+		else if ( *pszFormat == _TEXT('m') )
+			divisor = 1000000L;
+		else if ( *pszFormat == _TEXT('M') )
+			divisor = 1048576L;
+		else if ( *pszFormat == _TEXT('g') )
+			divisor = 1000000000L;
+		else if ( *pszFormat == _TEXT('G') )
+			divisor = 1073741824L;
+		else if ( _ctoupper( *pszFormat ) != _TEXT('B') )
+			return -1;
+	}
+#else
+	t_int64 divisor = {1, 0};
+
+	if ( *pszFormat ) {
+		if ( *pszFormat == _TEXT('k') )
+			divisor.ulLowPart = 1000L;
+		else if ( *pszFormat == _TEXT('K') )
+			divisor.ulLowPart = 1024L;
+		else if ( *pszFormat == _TEXT('m') )
+			divisor.ulLowPart = 1000000L;
+		else if ( *pszFormat == _TEXT('M') )
+			divisor.ulLowPart = 1048576L;
+		else if ( *pszFormat == _TEXT('g') )
+			divisor.ulLowPart = 1000000000L;
+		else if ( *pszFormat == _TEXT('G') )
+			divisor.ulLowPart = 1073741824L;
+		else if ( _ctoupper( *pszFormat ) != _TEXT('B') )
+			return -1;
+	}
+#endif
+	strcpy( pszTarget, Divide64By64( llVal, &divisor, 0, 1 ) );
+	return 0;
+}
+
+
 // process the internal variables (%_...)
 static LPTSTR _near _fastcall var_internal( LPTSTR lpszVar )
 {
 	extern const TCHAR *VAR_ARRAY[];
-
+	static TCHAR szBrandString[48];
+	TCHAR *ptr;
 	int i = 0, n, nOffset;
 	DATETIME sysDateTime;
+	ULONG ulUnixTime;
+	t_int64 lla, llb;
+	struct tm t;
 
 	if (( _stricmp( lpszVar, _TEXT("?") ) == 0 ) || ( _stricmp( lpszVar, _TEXT("ERRORLEVEL") ) == 0 )) {
 		// exit code of last external program?
@@ -3150,9 +3589,10 @@
 			switch ( nOffset ) {
 
 		case VAR_4VER:
+		case VAR_VERSION:
 
 			// Version of 4DOS
-			sprintf( lpszVar, _TEXT("%u%c%02u"), VER_MAJOR, gaCountryInfo.szDecimal[0], VER_MINOR );
+			sprintf( lpszVar, _TEXT("%u%c%02u"), VER_MAJOR, nOffset == VAR_4VER ? gaCountryInfo.szDecimal[0] : _TEXT('.'), VER_MINOR );
 			break;
 
 		case VAR_ALIAS:
@@ -3161,6 +3601,12 @@
 			IntToAscii((( glpAliasList + gpIniptr->AliasSize ) - ( end_of_env( glpAliasList) + 1 )), lpszVar );
 			break;
 
+		case VAR_ALT:
+
+			// is Alt key depressed?
+			IntToAscii(( bios_shiftstate() >> 3 & 1 ), lpszVar );
+			break;
+
 		case VAR_ANSI:
 
 			// ANSI loaded?
@@ -3176,7 +3622,7 @@
 					mov	ax,5300h
 						xor	bx,bx
 						int	15h
-						jnc	APMInstalled
+						jnc	APMInstalled	; @TODO!! for __WATCOMC__
 				}
 				// APM not installed!
 				*lpszVar = _TEXT('\0');
@@ -3226,6 +3672,27 @@
 			strcpy( lpszVar, (( cv.bn >= 0 ) ? filecase( bframe[cv.bn].pszBatchName ) : NULLSTR ));
 			break;
 
+		case VAR_BATCHTYPE:
+
+			// current batch type:
+			// -1 not in batch, 0 normal, 1 compressed, 2 encrypted
+			if ( cv.bn < 0 )
+				n = -1;
+			else if ( bframe[cv.bn].nFlags & BATCH_ENCRYPTED )
+				n = 2;
+			else if ( bframe[cv.bn].nFlags & BATCH_COMPRESSED )
+				n = 1;
+			else
+				n = 0;
+			IntToAscii( n, lpszVar );
+			break;
+
+		case VAR_BDEBUGGER:
+
+			// batch debugger active
+			IntToAscii( gpIniptr->SingleStep, lpszVar );
+			break;
+
 		case VAR_BG_COLOR:
 		case VAR_FG_COLOR:
 
@@ -3256,6 +3723,41 @@
 			IntToAscii( VER_BUILD, lpszVar );
 			break;
 
+		case VAR_CAPSLOCK:
+
+			// is CapsLock on?
+			IntToAscii(( bios_shiftstate() >> 6 & 1 ), lpszVar );
+			break;
+
+		case VAR_CDROMS:
+		case VAR_DRIVES:
+		case VAR_HDRIVES:
+		case VAR_READY:
+
+			// return list of CD-ROM, present, hard or ready drives
+			for ( ptr = lpszVar, i = 1; i <= 26; i++ ) {
+				if ( QueryDriveExists( i )) {
+					if ( i == 2 && GetDrivePhysUnit( 2 ) == GetDrivePhysUnit( 1 ))
+						continue; // phantom floppy B:
+					if ( nOffset == VAR_CDROMS ) {
+						if ( !QueryIsCDROM( i ))
+							continue;
+					} else if ( nOffset == VAR_HDRIVES ) {
+						if ( GetDrivePhysUnit( i ) < 0x80 )
+							continue;
+					} else if ( nOffset == VAR_READY ) {
+						if ( !QueryDriveReady( i ))
+							continue;
+					}
+					lpszVar += sprintf( lpszVar, "%c: ", i + '@');
+				}
+			}
+			if ( ptr < lpszVar )
+				lpszVar--;
+			*lpszVar = _TEXT('\0');
+			lpszVar = ptr;
+			break;
+
 		case VAR_CI:
 			IntToAscii( gpIniptr->CursI, lpszVar );
 			break;
@@ -3272,6 +3774,10 @@
 			lpszVar = SHORT_NAME;
 			break;
 
+		case VAR_CMDSPEC:
+			sprintf( lpszVar, FMT_FAR_STR, _pgmptr );
+			break;
+
 		case VAR_CO:
 			IntToAscii( gpIniptr->CursO, lpszVar );
 			break;
@@ -3303,8 +3809,51 @@
 
 		case VAR_CPU:
 
-			// get the CPU type
-			IntToAscii( get_cpu(), lpszVar );
+			// get the CPU type or brand string, if supported
+			if ( gnCPU > 586 && !get_cpu_brand( szBrandString ) ) {
+				trim( szBrandString, WHITESPACE );
+				lpszVar = szBrandString;
+			} else
+				lpszVar = cpu_Type();
+			break;
+
+		case VAR_CPUSPEED:
+
+			// CPU speed in MHz
+			if ( gnCPU >= 586 && ( gpIniptr->WinMode || !InV86mode() )) {
+				if ( gpIniptr->WinMode ) {
+					_asm {	// start critical section
+						mov	ax,1681h
+						int	2Fh
+					}
+					for ( ulUnixTime = GetWinMs(); ulUnixTime == GetWinMs(); )
+						;	// await new tick
+				}
+				GetTSC( &lla );
+				SysWait( 50, 2 );	// wait 50 ms
+				GetTSC( &llb );
+				if ( gpIniptr->WinMode ) {
+					_asm {	// end critical section
+						mov	ax,1682h
+						int	2Fh
+					}
+				}
+				Subtract64From64( &llb, &lla );
+#ifdef NATIVE_INT64
+				llb = 50000L;
+#else
+				llb.ulHighPart = 0L;
+				llb.ulLowPart = 50000L;
+#endif
+				lpszVar = Divide64By64( &lla, &llb, 0, 1 );
+			} else
+				IntToAscii( cpu_Speed(), lpszVar );
+			break;
+
+		case VAR_CTRL:
+
+			// is Ctrl key depressed?
+			IntToAscii(( bios_shiftstate() >> 2 & 1 ), lpszVar );
 			break;
 
 		case VAR_CWD:
@@ -3339,12 +3888,28 @@
 
 		case VAR_DATE:
 		case VAR_ISODATE:
+		case VAR_ISORDATE:
+		case VAR_ISOWDATE:
+		case VAR_DATETIME:
 
 			// system date
 			QueryDateTime( &sysDateTime );
 
+			if ( nOffset == VAR_DATETIME ) {
+				sprintf( lpszVar, _TEXT("%4u%02u%02u%02u%02u%02u"), sysDateTime.year, sysDateTime.month, sysDateTime.day, sysDateTime.hours, sysDateTime.minutes, sysDateTime.seconds );
+				break;
+			}
+			if ( nOffset == VAR_ISODATE )
+				n = 4;
+			else if ( nOffset == VAR_ISOWDATE )
+				n = 5;
+			else if ( nOffset == VAR_ISORDATE )
+				n = 6;
+			else
+				n = 0;
+
 			// replace leading space with a 0
-			if (*( lpszVar = FormatDate( sysDateTime.month, sysDateTime.day, sysDateTime.year, (( nOffset == VAR_DATE ) ? 0 : 4 ) )) == _TEXT(' ') )
+			if (*( lpszVar = FormatDate( sysDateTime.month, sysDateTime.day, sysDateTime.year, n )) == _TEXT(' ') )
 				*lpszVar = _TEXT('0');
 			break;
 
@@ -3374,7 +3939,7 @@
 
 			// operating system flavor (DOS, WIN, or NT)
 
-			lpszVar = "DOS";
+			lpszVar = pszOSname;
 			break;
 
 		case VAR_DOSVER:
@@ -3386,6 +3951,8 @@
 		case VAR_DOW:
 		case VAR_DOWF:
 		case VAR_DOWI:
+		case VAR_ISODOWI:
+
 			// get the day of week (Mon, Tue, etc. or 1 - 7)
 			QueryDateTime( &sysDateTime );
 
@@ -3393,24 +3960,27 @@
 				sprintf( lpszVar, _TEXT("%.3s"), daytbl[(int)sysDateTime.weekday] );
 			else if ( nOffset == VAR_DOWF )
 				strcpy( lpszVar, daytbl[(int)sysDateTime.weekday] );
+			else if ( nOffset == VAR_ISODOWI )
+				IntToAscii( sysDateTime.weekday ? sysDateTime.weekday : 7, lpszVar );
 			else
 				IntToAscii( sysDateTime.weekday+1, lpszVar );
 			break;
 
 		case VAR_DOY:
+		case VAR_ISOWEEK:
+		case VAR_ISOWYEAR:
 
-			// return the day of year (1-366)
+			// return the day (1-366) or the week (0-53) of the year
 			QueryDateTime( &sysDateTime );
 			n = sysDateTime.day;
+			n = ISOweekDOY( &n, sysDateTime.month, &sysDateTime.year, &i );
 
-			// get days for previous months
-			for ( i = 1; ( i < ( int)sysDateTime.month); i++) {
-				if ( i == 2 )
-					n += ((( sysDateTime.year % 4 ) == 0 ) ? 29 : 28 );
-				else
-					n += ((( i == 4) || ( i == 6 ) || ( i == 9 ) || ( i == 11 )) ? 30 : 31 );
-			}
-
+			// at this point, n = ISO week number, i = day of year
+			if ( nOffset == VAR_DOY )
+				n = i;
+			else if ( nOffset == VAR_ISOWYEAR )
+				n = sysDateTime.year;
+			// else ( nOffset == VAR_ISOWEEK ) use n;
 			IntToAscii( n, lpszVar );
 			break;
 
@@ -3428,13 +3998,128 @@
 						mov	i, ax		; if AX != 0, DPMI not present
 						mov	n, dx		; get version level
 				}
+DPMI_version:
 				if ( i != 0 )
 					lpszVar = _TEXT("0");
 				else
-					sprintf( lpszVar, _TEXT("%d%c%d"), ( n >> 8 ), gaCountryInfo.szDecimal[0], ( n & 0xFF));
+					sprintf( lpszVar, _TEXT("%d%c%02d"), ( n >> 8 ), gaCountryInfo.szDecimal[0], ( n & 0xFF));
 				break;
 			}
 
+		case VAR_VCPI:
+			// return the VCPI version number, or 0 if not present
+			_asm {
+				mov	ax,3567h
+				push	es
+				int	21h
+				mov	dx,es
+				pop	es
+				or	bx,dx	; Int 67h vector zero?
+				jz	no_vcpi	; if so, don't call it!
+				mov	ax,0DE00h
+				int	67h
+				mov	al,0
+			no_vcpi:mov	i,ax	; if AH != 0, VCPI not present
+				mov	n,bx	; get version level
+			}
+			goto DPMI_version;
+
+		case VAR_VDS:
+			// return the VDS version number, or 0 if not present
+			_asm {
+				push	es
+				xor	dx,dx
+				mov	es,dx
+				test	es:[47Bh],100000b;bit 5 clear = no VDS
+				pop	es
+				mov	ax,8102h	; get VDS version
+				jz	no_vds
+				push	cx
+				push	dx
+				push	si
+				push	di
+				int	4Bh
+				pop	di
+				pop	si
+				pop	dx
+				pop	cx
+				jc	no_vds
+				xchg	ax,dx	; now DX = version, AX = 0
+			no_vds:	mov	i,ax	; if AX != 0, VDS not present
+				mov	n,dx	; get version level
+			}
+			goto DPMI_version;
+
+		case VAR_VERMAJOR:
+
+			// 4DOS major version
+			IntToAscii( VER_MAJOR, lpszVar );
+			break;
+
+		case VAR_VERMINOR:
+
+			// 4DOS minor version
+			IntToAscii( VER_MINOR, lpszVar );
+			break;
+
+		case VAR_DST:
+		case VAR_MJD:
+		case VAR_STZN:
+		case VAR_STZO:
+		case VAR_TZN:
+		case VAR_TZO:
+		case VAR_UNIXTIME:
+		case VAR_UTCDATE:
+		case VAR_UTCDATETIME:
+		case VAR_UTCHOUR:
+		case VAR_UTCISODATE:
+		case VAR_UTCMINUTE:
+		case VAR_UTCSECOND:
+		case VAR_UTCTIME:
+
+			// UTC-related variables
+			QueryDateTime( &sysDateTime );
+			t.tm_sec = sysDateTime.seconds;
+			t.tm_min = sysDateTime.minutes;
+			t.tm_hour = sysDateTime.hours;
+			t.tm_mday = sysDateTime.day;
+			t.tm_mon = sysDateTime.month - 1;
+			t.tm_year = sysDateTime.year - 1900;
+			t.tm_isdst = -1; // unknown: see Watcom's mktime()
+			ulUnixTime = mktime( &t );// seconds past 1-1-1970
+			n = t.tm_isdst;	 // will be cleared by _gmtime()
+			_gmtime( &ulUnixTime, &t );
+			if ( nOffset == VAR_DST )
+				IntToAscii( n, lpszVar );
+			else if ( nOffset == VAR_MJD ) {
+				sprintf( lpszVar, "40587+%lu/86400+%d/8640000=6", ulUnixTime, (int)sysDateTime.hundredths );
+				evaluate( lpszVar );
+			} else if ( nOffset == VAR_STZN )
+				lpszVar = tzname[0];
+			else if ( nOffset == VAR_STZO )
+				IntToAscii( (int)(timezone / 60), lpszVar );
+			else if ( nOffset == VAR_TZN )
+				lpszVar = n ? tzname[1] : tzname[0];
+			else if ( nOffset == VAR_TZO )
+				IntToAscii( (int)((timezone - (n ? __dst_adjust : 0)) / 60), lpszVar );
+			else if ( nOffset == VAR_UNIXTIME )
+				sprintf( lpszVar, FMT_LONG, ulUnixTime );
+			else if ( nOffset == VAR_UTCDATE || nOffset == VAR_UTCISODATE ) {
+				// replace leading space with a 0
+				if (*( lpszVar = FormatDate( t.tm_mon + 1, t.tm_mday, t.tm_year + 1900, nOffset == VAR_UTCISODATE ? 4 : 0 )) == _TEXT(' ') )
+					*lpszVar = _TEXT('0');
+			} else if ( nOffset == VAR_UTCDATETIME )
+				sprintf( lpszVar, _TEXT("%4u%02u%02u%02u%02u%02u"), t.tm_year + 1900, t.tm_mon + 1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec );
+			else if ( nOffset == VAR_UTCHOUR )
+				IntToAscii( t.tm_hour, lpszVar );
+			else if ( nOffset == VAR_UTCMINUTE )
+				IntToAscii( t.tm_min, lpszVar );
+			else if ( nOffset == VAR_UTCSECOND )
+				IntToAscii( t.tm_sec, lpszVar );
+			else	// VAR_UTCTIME
+				sprintf( lpszVar, _TEXT("%02u%c%02u%c%02u"), t.tm_hour, gaCountryInfo.szTimeSeparator[0], t.tm_min, gaCountryInfo.szTimeSeparator[0], t.tm_sec );
+			break;
+
 		case VAR_DV:
 
 			// is DESQview loaded?
@@ -3453,6 +4138,35 @@
 			IntToAscii( (( cv.bn >= 0 ) ? bframe[cv.bn].uEcho : cv.fVerbose ), lpszVar );
 			break;
 
+		case VAR_EDITMODE:
+
+			IntToAscii( gnEditMode, lpszVar );
+			break;
+
+		case VAR_EXECSTR:
+
+			// integer return code of last @EXECSTR function
+			IntToAscii( nExecStrRet, lpszVar );
+			break;
+
+		case VAR_EXPANSION:
+
+			// current expansion mode (SETDOS /X)
+			ptr = lpszVar;
+			if ( ( n = gpIniptr->Expansion ) == 0 )
+				*ptr++ = _TEXT('0');
+			else for ( i = _TEXT('1'); n > 0 ; n >>= 1, i++ )
+				if ( n & 1 )
+					*ptr++ = i;
+			*ptr = _TEXT('\0');
+			break;
+
+		case VAR_FONTPAGE:
+
+			// current font page (0 if no Arabic or Hebrew loaded)
+			IntToAscii( GetFontPage(), lpszVar );
+			break;
+
 		case VAR_HLOGFILE:
 
 			// name of command log file
@@ -3472,17 +4186,56 @@
 			IntToAscii( gnInternalErrorLevel, lpszVar );
 			break;
 
+		case VAR_ININAME:
+
+			// name of INI file
+			strcpy( lpszVar, gpIniptr->PrimaryININame == INI_EMPTYSTR ? NULLSTR : gpIniptr->StrData + gpIniptr->PrimaryININame );
+			break;
+
 		case VAR_KBHIT:
 			// is a key waiting?
 			IntToAscii(( _kbhit() != 0 ), lpszVar );
 			break;
 
+		case VAR_KEYSTACKED:
+
+			// number of keystrokes left in the KSTACK buffer
+			_asm	xor	cx,cx	; the old KSTACK won't touch CX
+			if ( QueryKSTACK() ) {
+				_asm {
+					cmp	cx,2	; function 2 supported?
+					jb	KSret	; no - old KSTACK.COM!
+					mov	ax,0D44Fh
+					mov	bx,2	; get the number of the
+					int	2Fh	; keystrokes in buffer
+					mov	i,ax
+				KSret:
+				}
+			}
+			IntToAscii( i, lpszVar );
+			break;
+
 		case VAR_KSTACK:
 
 			// KSTACK loaded?
 			IntToAscii( QueryKSTACK(), lpszVar );
 			break;
 
+		case VAR_LALT:
+
+			// is left Alt key depressed?
+			IntToAscii(( bios_shiftstate() >> 9 & 1 ), lpszVar );
+			break;
+
+		case VAR_LASTDIR:
+
+			// previous directory
+			{
+				extern TCHAR szLastDirectory[];
+				lpszVar = szLastDirectory;
+			}
+			break;
+
 		case VAR_LASTDISK:
 
 			// return last active disk
@@ -3494,12 +4247,31 @@
 			sprintf( lpszVar, FMT_CHAR, i+64);
 			break;
 
+		case VAR_LCTRL:
+
+			// is left Ctrl key depressed?
+			IntToAscii(( bios_shiftstate() >> 8 & 1 ), lpszVar );
+			break;
+
 		case VAR_LOGFILE:
 
 			// name of command log file
 			strcpy( lpszVar, (( gpIniptr->LogOn) ? GetLogName( 0 ) : NULLSTR));
 			break;
 
+		case VAR_LSHIFT:
+
+			// is Left Shift key depressed?
+			IntToAscii(( bios_shiftstate() >> 1 & 1 ), lpszVar );
+			break;
+
+		case VAR_MACHINE:
+
+			*lpszVar = _TEXT('\0');
+			GetMachineName( lpszVar );
+			strip_trailing( lpszVar, _TEXT(" ") );
+			break;
+
 		case VAR_MINUTE:
 
 			// system date
@@ -3514,10 +4286,14 @@
 			break;
 
 		case VAR_MONTH:
+		case VAR_MONTHF:
 
 			// system date
 			QueryDateTime( &sysDateTime );
-			IntToAscii( sysDateTime.month, lpszVar );
+			if ( nOffset == VAR_MONTHF )
+				strcpy( lpszVar, lmontbl[sysDateTime.month-1] );
+			else
+				IntToAscii( sysDateTime.month, lpszVar );
 			break;
 
 		case VAR_MOUSE:
@@ -3528,8 +4304,89 @@
 
 		case VAR_NDP:
 
-			// get type (0 (none), 8087, 80287 or 80387)
-			IntToAscii( get_ndp(), lpszVar );
+			// get FPU type
+			lpszVar = fpu_Type();
+			break;
+
+		case VAR_NETWORK:
+
+			// network installed? (return installed component flags)
+			IntToAscii( NetworkInstalled(), lpszVar );
+			break;
+
+		case VAR_NLSFUNC:
+			n = 0x1400;
+TSRcheck:
+			// TSR installed? (1=yes, 0=OK to install, -1=not OK
+			IntToAscii( -InstalledCheck( n ), lpszVar );
+			break;
+
+		case VAR_POWER:
+
+			// POWER.EXE installed?
+			IntToAscii( PowerInstalled(), lpszVar );
+			break;
+
+		case VAR_PRINT:
+			n = 0x100;
+			goto TSRcheck;
+
+		case VAR_ASSIGN:
+			n = 0x600;
+			goto TSRcheck;
+
+		case VAR_DRIVER:
+			n = 0x800;
+			goto TSRcheck;
+
+		case VAR_SHARE:
+			n = 0x1000;
+			goto TSRcheck;
+
+		case VAR_MSCDEX:
+			n = 0x1100;
+			goto TSRcheck;
+
+		case VAR_TASKMAX:
+			n = 0x2700;
+			goto TSRcheck;
+
+		case VAR_GRAPHICS:
+			n = 0xAC00;
+			goto TSRcheck;
+
+		case VAR_DISPLAY:
+			n = 0xAD00;
+			goto TSRcheck;
+
+		case VAR_GRAFTABL:
+			n = 0xB000;
+			goto TSRcheck;
+
+		case VAR_APPEND:
+			n = 0xB700;
+			goto TSRcheck;
+
+		case VAR_EGA:
+			n = 0xBC00;
+			goto TSRcheck;
+
+		case VAR_NUMLOCK:
+
+			// is NumLock on?
+			IntToAscii(( bios_shiftstate() >> 5 & 1 ), lpszVar );
+			break;
+
+		case VAR_RALT:
+
+			// is right Alt key depressed?
+			IntToAscii(( bios_shiftstate() >> 11 & 1 ), lpszVar );
+			break;
+
+		case VAR_RCTRL:
+
+			// is right Ctrl key depressed?
+			IntToAscii(( bios_shiftstate() >> 10 & 1 ), lpszVar );
 			break;
 
 		case VAR_ROWS:
@@ -3538,6 +4395,25 @@
 			IntToAscii( GetScrRows() + 1, lpszVar );
 			break;
 
+		case VAR_RSHIFT:
+
+			// is Right Shift key depressed?
+			IntToAscii(( bios_shiftstate() & 1 ), lpszVar );
+			break;
+
+		case VAR_SBDSP:
+
+			// SB DSP version
+			i = !(n = GetSBDSPver());
+			goto DPMI_version;
+			break;
+
+		case VAR_SCROLLLOCK:
+
+			// is ScrollLock on?
+			IntToAscii(( bios_shiftstate() >> 4 & 1 ), lpszVar );
+			break;
+
 		case VAR_SECOND:
 
 			// system date
@@ -3551,6 +4427,42 @@
 			IntToAscii( gpIniptr->ShellNum, lpszVar );
 			break;
 
+		case VAR_SHIFT:
+
+			// is either Shift key depressed?
+			IntToAscii(( bios_shiftstate() & 3 ? 1 : 0 ), lpszVar );
+			break;
+
+		case VAR_SMARTDRV:
+
+			// is SMARTDRV installed?
+			IntToAscii( InstalledCheck( 0x4A10 ) == 0xBABE, lpszVar );
+			break;
+
+		case VAR_STARTPATH:
+
+			// startup directory
+			lpszVar = gszStartPath;
+			break;
+
+		case VAR_STDERR:
+
+			// does standard error point to CON?
+			IntToAscii( _isatty( STDERR ), lpszVar );
+			break;
+
+		case VAR_STDIN:
+
+			// does standard input point to CON?
+			IntToAscii( _isatty( STDIN ), lpszVar );
+			break;
+
+		case VAR_STDOUT:
+
+			// does standard output point to CON?
+			IntToAscii( _isatty( STDOUT ), lpszVar );
+			break;
+
 		case VAR_SWAPPING:
 
 			// swapping type
@@ -3563,6 +4475,24 @@
 			IntToAscii( gnSysError, lpszVar );
 			break;
 
+		case VAR_SYSREQ:
+
+			// is SysReq key depressed?
+			IntToAscii(( bios_shiftstate() >> 15 ), lpszVar );
+			break;
+
+		case VAR_TASKSWITCHER:
+
+			// is DOSSHELL Task Switcher installed?
+			IntToAscii( InstalledCheck( 0x4B02 ) == 0, lpszVar );
+			break;
+
+		case VAR_TICK:
+
+			// BIOS clock ticks since midnight
+			sprintf( lpszVar, FMT_LONG, *(( volatile long _far * )0x46CL ));
+			break;
+
 		case VAR_TIME:
 
 			// system time (24-hour); replace leading space with a 0
@@ -3576,10 +4506,26 @@
 			IntToAscii( gnTransient, lpszVar );
 			break;
 
+		case VAR_TSC:
+
+			// Time-Stamp Counter of the CPU (586+)
+			if ( gnCPU >= 586 ) {
+				GetTSC( &lla );
+				lpszVar = Format64( &lla );
+			} else
+				lpszVar = _TEXT("?");
+			break;
+
+		case VAR_V86:
+
+			// is CPU in V86 mode?
+			IntToAscii( gnCPU >= 386 ? InV86mode() : 0, lpszVar );
+			break;
+
 		case VAR_VIDEO:
 
 			// get video adaptor type
-			lpszVar = video_type[ GetVideoMode() ];
+			lpszVar = QuerySVGA() ? SVGA_TYPE : video_type[ GetVideoMode() ];
 			break;
 
 		case VAR_WIN:
@@ -3588,11 +4534,20 @@
 			IntToAscii( gpIniptr->WinMode, lpszVar );
 			break;
 
+		case VAR_WINTICKS:
+
+			// ms since midnight (DOS) or since Windows started
+			sprintf( lpszVar, FMT_LONG, GetMs() );
+			break;
+
 		case VAR_WINTITLE:
 
 			// get the title of our window
 			*lpszVar = _TEXT('\0');
-			ServTtl( lpszVar );
+			if ( fWin95 )
+				Win95GetTitle( lpszVar );
+			else
+				ServTtl( lpszVar, 2 );
 			break;
 
 		case VAR_YEAR:
@@ -3680,7 +4635,6 @@
 static int _fastcall __history( LPTSTR, int );
 #pragma alloc_text( _TEXT, DirHistory_Cmd )
 #pragma alloc_text( _TEXT, History_Cmd )
-#pragma alloc_text( _TEXT, __history )
 
 // print the directory history, read it from a file, or clear it
 int _near DirHistory_Cmd( LPTSTR pszCmdLine )
@@ -3864,6 +4818,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, prev_hist )
+
 // return previous command in history list
 TCHAR _far * _fastcall prev_hist( TCHAR _far *pszCmd )
 {
@@ -3884,6 +4840,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, next_hist )
+
 // return next command in history list
 TCHAR _far * _fastcall next_hist( TCHAR _far *pszCmd )
 {
diff -Nu d:7.501/filecmds.c SOURCES/filecmds.c
--- d:7.501/filecmds.c	2006-11-12 16:00:50 +0200
+++ SOURCES/filecmds.c	2009-02-27 10:42:18 +0200
@@ -39,7 +39,11 @@
 #include <direct.h>
 #include <dos.h>
 
+#ifdef __WATCOMC__
+extern unsigned *__io_mode;
+#else
 #include <msdos.h>
+#endif
 
 #include <fcntl.h>
 #include <sys/types.h>
@@ -724,7 +728,7 @@
 	// check for and remove switches
 	// abort if no filename arguments
 
-	if (( GetSwitches( pszCmdLine, "*CDEFGH MNOPQRSTUV Z", &(Move.fFlags), 0 ) != 0 ) || ( first_arg( pszCmdLine ) == NULL ))
+	if (( GetSwitches( pszCmdLine, "*CDEFGH MNOPQRSTUVWZ", &(Move.fFlags), 0 ) != 0 ) || ( first_arg( pszCmdLine ) == NULL ))
 
 		return ( Usage( MOVE_USAGE ));
 
@@ -1108,19 +1112,7 @@
 
 				if (( Move->fFlags & MOVE_FORCEDEL ) && ( gnOSFlags & DOS_IS_OS2 )) {
 
-					pszSourceArg = Move->szSourceName;
-_asm {
-					push   di
-					push   si
-					mov    ax, 06400h
-					mov    bx, 0CBh		; ordinal
-					mov    cx, 0636Ch
-					mov    dx, pszSourceArg
-					int    21h
-					mov    _doserrno, ax
-					pop    si
-					pop    di
-}
+					_doserrno = ForceDelete( Move->szSourceName );
 				} else
 
 				{
@@ -1300,9 +1292,11 @@
 		goto filebye;
 	}
 
+	_doserrno = 0;	// can be 768 here (bug in MSVCRT library?)
+
 	// lock the file (and check for somebody else already locking it!)
 	if (( fFlags & ( DEVICE_SOURCE | PIPE_SOURCE )) == 0 ) {
-		if ( _locking( nInputFile, _LK_NBLCK, 0x7FFFFFFFL ) != 0 ) {
+		if ( InstalledCheck( 0x1000 ) < 0 /* SHARE installed */ && _locking( nInputFile, _LK_NBLCK, 0xFFFFFFFFL )) {
 			if ( _doserrno != ERROR_INVALID_FUNCTION ) {
 				nReturn = error( _doserrno, szInputName );
 				goto filebye;
@@ -1525,8 +1519,8 @@
 
 	if ( nInputFile > 0 ) {
 
-		if (( fFlags & ( DEVICE_SOURCE | PIPE_SOURCE )) == 0 )
-			_locking( nInputFile, _LK_UNLCK, 0x7FFFFFFFL );
+		if (( fFlags & ( DEVICE_SOURCE | PIPE_SOURCE )) == 0 && InstalledCheck( 0x1000 ) < 0 /* SHARE installed */ )
+			_locking( nInputFile, _LK_UNLCK, 0xFFFFFFFFL );
 		_close( nInputFile );
 	}
 
@@ -1808,7 +1802,8 @@
 						}
 					}
 				}
-			}
+			} else if ( is_file( szTargetName ) )
+				nReturn = error( _doserrno = ERROR_ACCESS_DENIED, szTargetName );
 		}
 
 		// delete the descriptions for renamed or missing files
@@ -2146,9 +2141,10 @@
 
 #define ATTRIB_DIRS 2
 #define ATTRIB_NOERRORS 4
-#define ATTRIB_PAUSE 8
-#define ATTRIB_QUIET 0x10
-#define ATTRIB_SUBDIRS 0x20
+#define ATTRIB_NOTHING 8
+#define ATTRIB_PAUSE 0x10
+#define ATTRIB_QUIET 0x20
+#define ATTRIB_SUBDIRS 0x40
 
 typedef struct
 {
@@ -2197,7 +2193,7 @@
 		return ERROR_EXIT;
 
 	// check for flags
-	if ( GetSwitches( pszCmdLine, _TEXT("*DEPQS"), &(Attrib.fFlags), 0 ) != 0 )
+	if ( GetSwitches( pszCmdLine, _TEXT("*DENPQS"), &(Attrib.fFlags), 0 ) != 0 )
 		return (Usage( ATTRIB_USAGE ));
 
 	if ( Attrib.fFlags & ATTRIB_PAUSE )
@@ -2341,7 +2337,7 @@
 
 
 
-#pragma alloc_text( MISC_TEXT, _attrib, show_atts )
+#pragma alloc_text( MISC_TEXT, _attrib )
 
 
 static int _attrib( register ATTRIB_STRUCT *Attrib )
@@ -2404,7 +2400,7 @@
 		}
 
 		// check for a change; ignore if same
-		if ( uOldAttribute != dir.attrib ) {
+		if ( uOldAttribute != dir.attrib && !( Attrib->fFlags & ATTRIB_NOTHING )) {
 
 			// can't change directory attribute
 			dir.attrib &= ~_A_SUBDIR;
@@ -2452,6 +2448,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, show_atts )
+
 LPTSTR _fastcall show_atts( register int nAttribute )
 {
 
@@ -2599,7 +2597,7 @@
 					sysDateTime.day = dir.fd.file_date.days;
 					sysDateTime.hours = dir.ft.file_time.hours;
 					sysDateTime.minutes = dir.ft.file_time.minutes;
-					sysDateTime.seconds = dir.ft.file_time.seconds;
+					sysDateTime.seconds = dir.ft.file_time.seconds * 2;
 
 				}
 
@@ -2631,13 +2629,9 @@
 					    break;
 					}
 
-					if ( GetStrDate( pszArg, &uMonth, &uDay, &uYear ) == 3 ) {
-
-						if (( sysDateTime.year = uYear ) < 80 )
-							sysDateTime.year += 2000;
-					    else if ( sysDateTime.year < 100 )
-						    sysDateTime.year += 1900;
+					if ( !GetStrDate( pszArg, &uMonth, &uDay, &uYear )) {
 
+						sysDateTime.year = uYear;
 						sysDateTime.month = (unsigned char)uMonth;
 						sysDateTime.day = (unsigned char)uDay;
 						pszArg = NULLSTR;
@@ -2777,7 +2771,7 @@
 			if ( Touch->fFlags & TOUCH_PRESERVE_TIME ) {
 				sysDateTime->hours = dir.ft.file_time.hours;
 				sysDateTime->minutes = dir.ft.file_time.minutes;
-				sysDateTime->seconds = dir.ft.file_time.seconds;
+				sysDateTime->seconds = dir.ft.file_time.seconds * 2;
 			}
 
 		}
@@ -2876,6 +2870,7 @@
 
 #define TYPE_NUMBER 2
 #define TYPE_PAUSE 4
+#define TYPE_FNAME 8
 
 // display file(s) to stdout
 int _near Type_Cmd( LPTSTR pszCmdLine )
@@ -2889,12 +2884,14 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, FileOutput )
+
+
 // display file(s) to stdout -- called by HEAD, TAIL, and TYPE
 static int _fastcall FileOutput( LPTSTR pszCmdLine, int fOp )
 {
 	register TCHAR *pszArg, *pszLine;
-	int nArgc, nFind, nReturn = 0, fEOF, nBytes = 0, nEditFlags = EDIT_DATA, fFlags = 0, nColumn = 0, nFH = -1;
-	unsigned int uMode = _O_BINARY | _O_RDONLY;
+	int nArgc, nFind, nReturn = 0, fEOF, nBytes = 0, nEditFlags = EDIT_DATA, fFlags = 0, nColumn = 0, nFH = -1, fNoLF = 0;
 	long lRow, lOptions, lDisplayLines = 10, lLines;
 	unsigned long ulChars = (ULONG)-1L, ulAttributes = 0L;
 	TCHAR chBKM;
@@ -2918,7 +2915,7 @@
 	if ( fOp & FO_TYPE ) {
 
 		// check for and remove switches
-		if ( GetSwitches( pszCmdLine, _TEXT("*LP"), &lOptions, 0 ) != 0 )
+		if ( GetSwitches( pszCmdLine, _TEXT("*LPV"), &lOptions, 0 ) != 0 )
 			return USAGE_ERR;
 
 		if ( lOptions & 1 )
@@ -2935,6 +2932,10 @@
 			fFlags |= FO_PAUSE;
 			gnPageLength = GetScrRows();
 		}
+
+		// header?
+		if ( lOptions & TYPE_FNAME )
+			fFlags |= FO_VERBOSE;
 	}
 
 	// save arguments on stack so we can overwrite with input buffer
@@ -3091,6 +3092,10 @@
 
 			// print header for HEAD & TAIL
 			if ( fFlags & FO_VERBOSE ) {
+				if ( fNoLF ) {
+					fNoLF = 0;
+					qputs( _TEXT("\r\n") );
+				}
 				qputs( _TEXT("---- ") );
 				more_page( gszCmdline, 5 );
 			}
@@ -3098,7 +3103,7 @@
 #
 				if ( nFH != STDIN ) {
 
-					if (( nFH = _sopen( gszCmdline, uMode, _SH_DENYNO )) < 0 ) {
+					if (( nFH = _sopen( gszCmdline, _O_BINARY | _O_RDONLY, _SH_DENYNO )) < 0 ) {
 						nReturn = error( _doserrno, gszCmdline );
 						if ( szClip[0] )
 							break;
@@ -3124,7 +3129,7 @@
 						// back up "ulChars" (characters, not bytes!) from the end
 						llEnd = _lseek( nFH, 0L, SEEK_END );
 
-							_lseek( nFH, (( ulChars > llEnd ) ? -llEnd : -(LONG)ulChars ), SEEK_END );
+							_lseek( nFH, (( ulChars > (ULONG)llEnd ) ? -llEnd : -(LONG)ulChars ), SEEK_END );
 
 					// now we'll fall through to the TYPE read routine & read the last "ulChars" of the file
 				}
@@ -3173,9 +3178,9 @@
 					// close the file / pipe
 					goto CloseHandles;
 
-				} else if ( fFlags & ( FO_NUMBERING | FO_PAUSE )) {
+				} else if ( fFlags & ( FO_NUMBERING | FO_PAUSE ) || _isatty( STDOUT )) {
 
-					// TYPE /L or /P
+					// TYPE /L or /P, or neither flag if not redirected
 					for ( lRow = 1; ( getline( nFH, gszCmdline, CMDBUFSIZ-1, nEditFlags ) > 0 ); lRow++ ) {
 						if ( fFlags & FO_NUMBERING )
 							printf( _TEXT("%4lu : "), lRow );
@@ -3189,26 +3194,14 @@
 
 				nBytes = 0;
 
-					wwrite( STDOUT, (LPSTR)(glpPipe + llPipeOffset), uSize );
-
-					break;
-
-				} else {
-
-					if (( nBytes = _read( nFH, gszCmdline, (( ulChars < CMDBUFSIZ ) ? ulChars : CMDBUFSIZ ))) <= 0 )
-						break;
-
-					// make sure we're not at the end of the file ("type file >> file")
-					fEOF = _eof( nFH );
-				}
-
-
 				if (( nBytes = _read( nFH, gszCmdline, (unsigned int)(( ulChars < CMDBUFSIZ ) ? ulChars : CMDBUFSIZ ))) <= 0 )
 					break;
 
 				// make sure we're not at the end of the file ("type file >> file")
 				fEOF = _eof( nFH );
 
+				if ( nBytes ) // with /C option, file may end without \n
+					fNoLF = gszCmdline[nBytes-1] != _TEXT('\n');
 
 				if ( wwrite( STDOUT, gszCmdline, nBytes ) == -1 ) {
 
@@ -3275,7 +3268,11 @@
 	}
 
 	// clear EOF flag
+#ifdef __WATCOMC__
+	__io_mode[STDIN] &= ~( _EOF | _BINARY );
+#else
 	_osfile[STDIN] &= ~( FEOFLAG | FCRLF );
+#endif
 
 	return ((( pszCmdLine ) && ( *pszCmdLine )) ? Type_Cmd( pszCmdLine ) : 0 );
 }
diff -Nu d:7.501/fileio.inc SOURCES/fileio.inc
--- d:7.501/fileio.inc	2007-01-30 13:39:24 +0200
+++ SOURCES/fileio.inc	2007-09-18 00:01:58 +0200
@@ -0,0 +1,2 @@
+O_RDONLY EQU 0
+O_DENYWR EQU 20h
diff -Nu d:7.501/forceref.asm SOURCES/forceref.asm
--- d:7.501/forceref.asm	1970-01-01 02:00:00 +0200
+++ SOURCES/forceref.asm	2007-09-19 14:03:38 +0200
@@ -0,0 +1,46 @@
+; Force references to various bits and pieces from sasjp.lib. We need to
+; ensure that these are referenced *before* 4dostart.
+
+include product.asm
+include trmac.asm
+.cseg   LOAD
+include model.inc
+
+.extrnx MEM_CPY:near
+.extrnx MEM_MOV:near
+.extrnx MEM_SET:near
+.extrnx MEM_CMPI:near
+.extrnx MEM_CHRN:near
+.extrnx MEM_CSPN:near
+.extrnx GET_CHR:near
+.extrnx PUT_CHR:near
+.extrnx GET_STR:near
+.extrnx PUT_NEWLINE:near
+.extrnx PUT_STR:near
+.extrnx STR_CSPN:near
+.extrnx STR_LEN:near
+.extrnx STR_NCMPI:near
+.extrnx STR_PBRKN:near
+.extrnx E_CODE:near
+.extrnx OPENEX_H:near
+.extrnx CLOSE_H:near
+.extrnx READ_H:near
+.extrnx DEC_TO_BYTE:near
+.extrnx DEC_TO_WORD:near
+.extrnx DEC_TO_WORDS:near
+.extrnx ASC_TO_BYTE:near
+.extrnx ASC_TO_WORD:near
+.extrnx ASC_TO_WORDS:near
+.extrnx WORD_TO_DEC:near
+.extrnx IS_ALPHA:near
+.extrnx IS_DIGIT:near
+.extrnx TO_UPPER:near
+.extrnx MEM_CHRNDI:near
+.extrnx STR_LENDI:near
+.extrnx $CHR_CMPI:near
+.extrnx $SET_ECODE:near
+.extrnx _OSMAJOR:near
+.extrnx WORD_TO_ASCE:near
+.extrnx DIV_WB:near
+
+end
diff -Nu d:7.501/globals.h SOURCES/globals.h
--- d:7.501/globals.h	2006-11-12 16:00:50 +0200
+++ SOURCES/globals.h	2008-11-03 08:48:38 +0200
@@ -32,6 +32,7 @@
 #ifdef DEFINE_GLOBALS
 
 // 4START is executed at startup; 4EXIT at exit
+TCHAR AUTOINST[] = _TEXT("_4INST.BTM");
 TCHAR AUTOSTART[] = _TEXT("4START");
 TCHAR AUTOEXIT[] = _TEXT("4EXIT");
 
@@ -39,10 +40,12 @@
 // "gszCmdline" is the input buffer for command line & batch file entry
 // also used as temporary stack by server when a TSR terminates in an
 //   unusual way, and by some of the internal commands
-TCHAR gszCmdline[CMDBUFSIZ+16];
+TCHAR gszCmdline[CMDBUFSIZ+MAXFILENAME+60];// enough room for strins in batch.c
 TCHAR *pszCmdLineOpts;
+TCHAR *pszOSname;		// OS name as string
 TCHAR gszOsVersion[6];		// holds DOS / OS2 version as string
 TCHAR gszMyVersion[6];		// major and minor 4xxx version string
+TCHAR gszFileSystemName[32];	// file system type
 TCHAR *gpNthptr;			// pointer to nth arg in line
 TCHAR *gpInternalName;		// name of internal command being executed
 TCHAR *gpBatchName;		// name of batch file to be executed
@@ -99,6 +102,7 @@
 };
 
 
+int gnCPU;			// CPU (86, 186, 286, 386, etc.)
 int gnOsVersion;		// combined major & minor version
 int gnTransient = 0;	// transient processor (/C) flag
 int gnCurrentDisk;		// current disk drive (A=1, B=2, etc.)
@@ -119,6 +123,7 @@
 int fWin95LFN = 0;
 int fWin95SFN = 0;
 
+TCHAR gszStartPath[MAXPATH];
 TCHAR AUTOEXEC[MAXFILENAME];
 extern int end;  		// end of data segment
 INIFILE *gpIniptr = (INIFILE *)&end;	// pointer to inifile
@@ -128,11 +133,14 @@
 
 // external definitions
 
+extern TCHAR AUTOINST[];
 extern TCHAR AUTOSTART[];
 extern TCHAR AUTOEXIT[];
 extern TCHAR gszCmdline[];
 extern TCHAR *pszCmdLineOpts;
+extern TCHAR *pszOSname;
 extern TCHAR gszOsVersion[];
+extern TCHAR gszFileSystemName[];
 extern TCHAR *gpNthptr;
 extern TCHAR *gpInternalName;
 extern TCHAR *gpBatchName;
@@ -179,6 +187,7 @@
 extern TCHAR gaIniStrings[];
 extern UINT gaIniKeys[];
 
+extern int gnCPU;
 extern int gnOsVersion;
 extern int gnTransient;
 extern int gnCurrentDisk;
@@ -200,6 +209,7 @@
 extern int gfCTTY;
 extern int gnOSFlags;
 extern int gnHighErrorLevel;
+extern TCHAR gszStartPath[];
 extern TCHAR AUTOEXEC[];
 extern char gchMajor;		// "true" major and minor OS versions
 extern char gchMinor;
diff -Nu d:7.501/gmtime.c SOURCES/gmtime.c
--- d:7.501/gmtime.c	1970-01-01 02:00:00 +0200
+++ SOURCES/gmtime.c	2007-07-03 13:37:06 +0200
@@ -0,0 +1,141 @@
+/****************************************************************************
+*
+*                            Open Watcom Project
+*
+*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
+*
+*  ========================================================================
+*
+*    This file contains Original Code and/or Modifications of Original
+*    Code as defined in and that are subject to the Sybase Open Watcom
+*    Public License version 1.0 (the 'License'). You may not use this file
+*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
+*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
+*    provided with the Original Code and Modifications, and is also
+*    available at www.sybase.com/developer/opensource.
+*
+*    The Original Code and all software distributed under the License are
+*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
+*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
+*    NON-INFRINGEMENT. Please see the License for the specific language
+*    governing rights and limitations under the License.
+*
+*  ========================================================================
+*
+* Description:  __brktime() is an internal function to convert time to struct tm
+*
+****************************************************************************/
+
+#include "variety.h"
+#include <time.h>
+#include "thetime.h"
+#include "timedata.h"
+
+// #define DAYS_IN_4_YRS   ( 365 + 365 + 365 + 366 )
+// #define DAYS_IN_400_YRS ( ( 100 * DAYS_IN_4_YRS ) - 3 )
+
+//  #define SECONDS_PER_DAY ( 24 * 60 * 60 )
+//  extern  short   __diyr[], __dilyr[];
+
+/*
+ The number of leap years from year 1 to year 1900 is 460.
+ The number of leap years from year 1 to current year is
+ expressed by "years/4 - years/100 + years/400". To determine
+ the number of leap years from current year to 1900, we subtract
+ 460 from the formula result. We do this since "days" is the
+ number of days since 1900.
+*/
+
+static unsigned long __DaysToJan1( unsigned year )
+{
+    unsigned    years = 1900 + year - 1;
+    unsigned    leap_days = years / 4 - years / 100 + years / 400 - 460;
+
+    return( year * 365UL + leap_days );
+}
+
+/*  __brktime breaks down a calendar time (clock) into a struct tm t */
+
+struct tm *__brktime( unsigned long     days,
+                      time_t            wallclock,
+                      long              gmtdelta,       // localtime - gmtime
+                      struct tm         *t )
+{
+    unsigned long       secs;
+    unsigned            year;
+    int                 day_of_year;
+    int                 month;
+    short const         *month_start;
+
+    /*
+        If date is Jan 1, 1970 0:00 to 12:00 UTC and we are west of UTC
+        then add a day to wallclock, subtract the gmtdelta value, and
+        decrement the calculated days. This prevents local times
+        such as "Wed Dec 31 19:00:00 1969 (EST)" from being
+        erroneously reported as "Sun Feb 6 01:28:16 2106 (EST)"
+        since (wallclock - gmtdelta) wraps (i.e., wallclock < gmtdelta).
+    */
+    if( wallclock < 12 * 60 * 60UL && gmtdelta > 0 )
+        wallclock += SECONDS_PER_DAY, days--; /* days compensated for wallclock one day ahead */
+    wallclock -= ( time_t ) gmtdelta;
+    days      += wallclock / SECONDS_PER_DAY;
+    secs       = wallclock % SECONDS_PER_DAY;
+    t->tm_hour = ( int ) ( secs / 3600 ) ;
+    secs       = secs % 3600;
+    t->tm_min  = ( int ) ( secs / 60 );
+    t->tm_sec  = secs % 60;
+
+    // The following two lines are not needed in the current implementation
+    // because the range of values for days does not exceed DAYS_IN_400_YRS.
+    // Even if it did, the algorithm still computes the correct values.
+    //
+    //    unsigned  year400s;
+    //
+    //    year400s = (days / DAYS_IN_400_YRS) * 400;
+    //    days %= DAYS_IN_400_YRS;
+    //
+    // It is OK to reduce days to a value less than DAYS_IN_400_YRS, because
+    // DAYS_IN_400_YRS is exactly divisible by 7. If it wasn't divisible by 7,
+    // then the following line which appears at the bottom, should be computed
+    // before the value of days is range reduced.
+    //    t->tm_wday = (days + 1) % 7;                /* 24-sep-92 */
+    //
+    year = days / 365;
+    day_of_year = ( int ) ( days - __DaysToJan1( year ) );
+    while( day_of_year < 0 ) {
+        --year;
+        day_of_year += __leapyear( year + 1900 ) + 365;
+    }
+    // year += year400s;
+
+    t->tm_yday = day_of_year;
+    t->tm_year = ( int ) year;
+    month_start = __diyr;
+    if( __leapyear( year + 1900 ) )
+        month_start = __dilyr;
+    month = day_of_year / 31;               /* approximate month */
+    if( day_of_year >= month_start[month + 1] )
+        ++month;
+    t->tm_mon  = month;
+    t->tm_mday = day_of_year - month_start[month] + 1;
+
+    /*  Calculate the day of the week */
+    /*   Jan 1,1900 is a Monday */
+
+    t->tm_wday = ( days + 1 ) % 7;                /* 24-sep-92 */
+    return( t );
+}
+
+_WCRTLINK struct tm *_gmtime( const time_t *timer, struct tm *tm )
+{
+    tm->tm_isdst = 0;          /* assume not */
+    return __brktime( DAYS_FROM_1900_TO_1970, *timer, 0L, tm );
+}
+
+_WCRTLINK struct tm *gmtime( const time_t *timer )
+{
+    _INITTHETIME;
+    return( _gmtime( timer, &_THE_TIME ) );
+}
diff -Nu d:7.501/header.ash SOURCES/header.ash
--- d:7.501/header.ash	1970-01-01 02:00:00 +0200
+++ SOURCES/header.ash	2008-12-30 09:36:48 +0200
@@ -0,0 +1,144 @@
+; -----------------------------------------------------------------------------
+; HEADER.ASH - TMi0SDGL Revision 2 Assembler Header               Version 2.15
+;
+; Too-Much-in-0ne-So-Don't-Get-Lost(tm) Revision 2 CPU/FPU Detection Library
+; Copyright(c) 1996-2000 by B-coolWare. Written by Bobby Z.
+; -----------------------------------------------------------------------------
+; This file is INCLUDEd in all assembler modules of the library.
+;
+; defines that affect compilation:
+;
+; __32bit__     type: define
+;               default: not defined
+;               purpose: to compile code and data as USE32 segments as well
+;                        as use 32-bit version of DPMICODE.ASM.
+; should not be defined with Borland Pascal 7 - it does not support 32-bit
+; protected mode program generation.
+;
+; __Windows__   type: define
+;               default: not defined
+;               purpose: to force TASM to add Windows entry/exit code to
+;                        public routines (for use in DLL).
+;
+; __Use_MSR_TSC__  type: define
+;                  default: not defined
+;                  purpose: to force _RDTSC macro to use RDMSR instruction
+;                           for obtaining TSC value instead of RDTSC.
+;                           Primarily to workaround an EMM386 bug(?) that
+;                           generates a crash on RDTSC instruction.
+
+
+; Global conditional defines
+; ~~~~~~~~~~~~~~~~~~~~~~~~~~
+; __32bit__             equ     1
+; __Windows__           equ     1
+; __Use_MSR_TSC__       equ     1
+
+IFDEF @version
+ IF @version LT 611
+  .err This code requires Microsoft Macro Assembler Version 6.11 or later
+ ENDIF
+ GLOBAL TEXTEQU <EXTERNDEF>
+ MODEL TEXTEQU <.MODEL>
+ OPTION PROC : PRIVATE
+ELSEIFDEF ??version
+ IF ??version LT 500h
+  %out This code requires Turbo Assembler Version 5.x or later
+  .err
+ ENDIF
+ELSE
+ .err This code requires Microsoft Macro Assembler or Turbo Assembler
+ENDIF
+
+IFDEF   __32bit__
+        .386
+IFDEF   __Windows__
+        MODEL   FLAT, WINDOWS STDCALL
+ELSE
+        MODEL   FLAT, PASCAL
+ENDIF
+        DIST    equ   <>        ; use default distance
+ELSE
+
+        ; set memory model and calling convention
+
+IFNDEF  __Windows__
+
+IFNDEF __HUGE__
+ IFNDEF __LARGE__
+  IFNDEF __MEDIUM__
+   IFNDEF __COMPACT__
+    IFNDEF __SMALL__
+     IFNDEF __TINY__
+        %out Must define a memory model
+        .err
+     ELSE
+      MODEL TINY, PASCAL
+      DIST  EQU  <NEAR>
+     ENDIF
+    ELSE
+     MODEL SMALL, PASCAL
+     DIST  EQU   <NEAR>
+    ENDIF
+   ELSE
+    MODEL COMPACT, PASCAL
+    DIST   EQU   <NEAR>
+   ENDIF
+  ELSE
+   MODEL MEDIUM, PASCAL
+   DIST    EQU   <FAR>
+  ENDIF
+ ELSE
+  MODEL LARGE, PASCAL
+  DIST     EQU   <FAR>
+ ENDIF
+ELSE
+ MODEL HUGE, PASCAL
+ DIST      EQU   <FAR>
+ENDIF
+
+ELSE
+
+IFNDEF __HUGE__
+ IFNDEF __LARGE__
+  IFNDEF __MEDIUM__
+   IFNDEF __COMPACT__
+    IFNDEF __SMALL__
+     IFNDEF __TINY__
+        %out Must define a memory model
+        .err
+     ELSE
+      MODEL TINY, WINDOWS PASCAL
+      DIST  EQU  <NEAR>
+     ENDIF
+    ELSE
+     MODEL SMALL, WINDOWS PASCAL
+     DIST  EQU   <NEAR>
+    ENDIF
+   ELSE
+    MODEL COMPACT, WINDOWS PASCAL
+    DIST   EQU   <NEAR>
+   ENDIF
+  ELSE
+   MODEL MEDIUM, WINDOWS PASCAL
+   DIST    EQU   <FAR>
+  ENDIF
+ ELSE
+  MODEL LARGE, WINDOWS PASCAL
+  DIST     EQU   <FAR>
+ ENDIF
+ELSE
+ MODEL HUGE, WINDOWS PASCAL
+ DIST      EQU   <FAR>
+ENDIF
+
+ENDIF   ; __Windows__
+
+ENDIF   ; __32bit__
+
+INCLUDE TMI0SDGL.INC            ; Include TMi0SDL-specific defines
+
+IFDEF ??version
+        LOCALS  @@              ; enable local symbols
+        JUMPS                   ; enable jump optimization
+ENDIF
diff -Nu d:7.501/hexout.asm SOURCES/hexout.asm
--- d:7.501/hexout.asm	2006-11-12 16:00:50 +0200
+++ SOURCES/hexout.asm	2008-11-04 13:07:08 +0200
@@ -54,7 +54,7 @@
           ;
           .defcode                      ;set up code segment, no DGROUP
           ;
-          assume    cs:@curseg, ds:nothing, es:nothing, ss:nothing
+          assume    ds:nothing, es:nothing, ss:nothing
           ;
           ;
           public    hexoutb, hexoutw, hexoutd
diff -Nu d:7.501/idle.h SOURCES/idle.h
--- d:7.501/idle.h	1970-01-01 02:00:00 +0200
+++ SOURCES/idle.h	1997-04-16 21:11:44 +0200
@@ -0,0 +1,52 @@
+/*
+;    File              : $Workfile$
+;
+;    Description       :
+;
+;    Original Author   : DIGITAL RESEARCH
+;
+;    Last Edited By    : $CALDERA$
+;
+;-----------------------------------------------------------------------;
+;    Copyright Work of Caldera, Inc. All Rights Reserved.
+;      
+;    THIS WORK IS A COPYRIGHT WORK AND CONTAINS CONFIDENTIAL,
+;    PROPRIETARY AND TRADE SECRET INFORMATION OF CALDERA, INC.
+;    ACCESS TO THIS WORK IS RESTRICTED TO (I) CALDERA, INC. EMPLOYEES
+;    WHO HAVE A NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF
+;    THEIR ASSIGNMENTS AND (II) ENTITIES OTHER THAN CALDERA, INC. WHO
+;    HAVE ACCEPTED THE CALDERA OPENDOS SOURCE LICENSE OR OTHER CALDERA LICENSE
+;    AGREEMENTS. EXCEPT UNDER THE EXPRESS TERMS OF THE CALDERA LICENSE
+;    AGREEMENT NO PART OF THIS WORK MAY BE USED, PRACTICED, PERFORMED,
+;    COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED, ABRIDGED,
+;    CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;    TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF
+;    CALDERA, INC. ANY USE OR EXPLOITATION OF THIS WORK WITHOUT
+;    AUTHORIZATION COULD SUBJECT THE PERPETRATOR TO CRIMINAL AND
+;    CIVIL LIABILITY.
+;-----------------------------------------------------------------------;
+;
+;    *** Current Edit History ***
+;    *** End of Current Edit History ***
+;
+;    $Log$
+;
+;    ENDLOG
+*/
+
+#include	<portab.h>
+
+#define	IDLE_COMMAND	0x0001
+#define	IDLE_DOSFUNC	0x0002
+#define IDLE_ON		0x4000
+#define	IDLE_ENABLE	0x8000
+
+typedef struct _idle_state {
+	WORD	count;
+	WORD	max;
+	WORD	flags;
+	VOID FAR *vec;
+	WORD	delay;
+	WORD	reload;
+	WORD	indos;
+} IDLE_STATE;
diff -Nu d:7.501/inifile.h SOURCES/inifile.h
--- d:7.501/inifile.h	2006-11-12 16:00:50 +0200
+++ SOURCES/inifile.h	2008-05-14 11:43:18 +0200
@@ -470,7 +470,7 @@
 	_TEXT("LogOn"), INI_CHOICE, 0, &V_YesNo, &gaInifile.LogOn, STARTUP_PP, DLG_DATA(IDI_LogOn, INI_CTL_CHECK, 0)
 	_TEXT("LogErrors"), INI_CHOICE, 0, &V_YesNo, &gaInifile.LogErrors, STARTUP_PP, DLG_DATA(IDI_LogErrors, INI_CTL_CHECK, 0)
 	_TEXT("NoClobber"), INI_CHOICE, 0, &V_YesNo, &gaInifile.NoClobber, STARTUP_PP, DLG_DATA(IDI_NoClobber, INI_CTL_CHECK, 0)
-	_TEXT("PathExt"), INI_CHOICE, 0, &V_YesNo, &gaInifile.PathExt, STARTUP_PP, DLG_DATA(IDI_PathExt, INI_CTL_CHECK, 0)
+	//_TEXT("PathExt"), INI_CHOICE, 0, &V_YesNo, &gaInifile.PathExt, STARTUP_PP, DLG_DATA(IDI_PathExt, INI_CTL_CHECK, 0)
 	_TEXT("PopupWinHeight"), INI_UINT, 12, &V_RCRng, &gaInifile.PWHeight, HISTORY_PP, DLG_DATA(IDI_PopupWinHeight, INI_CTL_INT, 0)
 	_TEXT("PopupWinTop"), INI_UINT, 1, &V_RCRng, &gaInifile.PWTop, HISTORY_PP, DLG_DATA(IDI_PopupWinTop, INI_CTL_INT, 0)
 
diff -Nu d:7.501/iniparse.asm SOURCES/iniparse.asm
--- d:7.501/iniparse.asm	2006-11-12 16:00:50 +0200
+++ SOURCES/iniparse.asm	2008-11-04 13:06:12 +0200
@@ -463,7 +463,7 @@
           ; If we are in OS/2 end data segment, and start code segment.
           ; If not, we just continue with code segment.
           ;
-          assume    cs:@curseg,ds:@DATASEG  ;set up CS assume
+          assume    ds:@DATASEG
           ;
           ;
           ; Externals
diff -Nu d:7.501/inout.asm SOURCES/inout.asm
--- d:7.501/inout.asm	2006-11-12 16:00:50 +0200
+++ SOURCES/inout.asm	2008-10-12 11:26:16 +0200
@@ -687,14 +687,20 @@
           ;
 InHex:    call      SkSpace             ;skip space
           mov       cx,InMax            ;get maximum width
-          call      ReadHex             ;read the hex value
+InHex1:   call      ReadHex             ;read the hex value
           jmp       short InICom        ;go to common code
           ;
           ; %d - integer; %u - unsigned
           ;
 InInt:    call      SkSpace             ;skip space
           mov       cx,InMax            ;get maximum width
-          call      ReadInt             ;read the integer
+          cmp       [si],'x0'           ;hex input?
+          jne       InInt2              ;no, check with capital X
+InInt1:   lodsw                         ;yes, skip the 0x
+          jmp       short InHex1        ;and process as hex input
+InInt2:   cmp       [si],'X0'           ;hex input?
+          je        InInt1              ;yes, process as hex
+          call      ReadInt             ;no, read as decimal integer
           ;
 InICom:   cmp       bptr Ignore,0       ;ignoring data?
           jnz       IFmtDone            ;if so go on
@@ -832,7 +838,7 @@
           exit                          ;all done
 
           ;
-          ; ReadHex - Read a hex integer (upper case only) from format spec
+          ; ReadHex - Read a hex integer from format spec
           ;           or source
           ;
           ; On entry:
@@ -858,6 +864,7 @@
           jb        RHDone              ;if < '0' we're done
           cmp       al,9                ;too big for a digit?
           jbe       RHAdd               ;if not we have 0 - 9
+          and       al,11011111b        ;yes, convert lower to upper case
           sub       al,('A' - '0')      ;OK, check upper case alpha
           jb        RHDone              ;if too low we're done
           add       al,10               ;adjust up to 10 - 15
@@ -890,8 +897,15 @@
           entry     GetArg,noframe,,local  ;start GetArg
           ;
           mov       bx,ArgList          ;get next argument pointer
+ifdef __WATCOM__
+          mov       bx,ss:[bx]          ;get actual argument pointer
+          mov       ax,ss:[bx]          ;get argument
+          mov       bx,ArgList          ;get argument pointer again
+          add       wptr ss:[bx],2      ;and move pointer
+else
           mov       ax,ss:[bx]          ;get argument
           add       wptr ArgList,2      ;and move pointer
+endif
           ;
           exit                          ;all done
           ;
@@ -940,13 +954,25 @@
           loadseg   es,ss               ;default to data segment (ASSUMES
                                         ;   small model)
           mov       bx,InArgs           ;get next argument pointer
+ifdef __WATCOM__
+          mov       bx,ss:[bx]          ;dereference another level
+endif
           mov       di,ss:[bx]          ;get argument offset
           add       bx,2                ;and move pointer
           cmp       bptr InFar,0        ;is it far?
           jz        GPDone              ;if not we're done
           mov       es,ss:[bx]          ;get argument segment
           add       bx,2                ;and move pointer
-GPDone:   mov       InArgs,bx           ;put back new pointer
+GPDone:
+ifdef __WATCOM__
+          push      ax
+          mov       ax,bx
+          mov       bx,InArgs
+          mov       ss:[bx],ax
+          pop       ax
+else
+          mov       InArgs,bx           ;put back new pointer
+endif
           pop       bx                  ;restore BX
           ;
           if        (_DOS ne 0) and (_WIN eq 0)  ;in DOS ...
diff -Nu d:7.501/intver.asm SOURCES/intver.asm
--- d:7.501/intver.asm	2006-11-12 16:00:50 +0200
+++ SOURCES/intver.asm	2009-02-26 11:09:42 +0200
@@ -26,4 +26,4 @@
 ;  SOFTWARE.
 
 
-INTVER    =         131
+INTVER    =         200
diff -Nu d:7.501/iofmt.c SOURCES/iofmt.c
--- d:7.501/iofmt.c	2006-11-12 16:00:50 +0200
+++ SOURCES/iofmt.c	2008-12-26 09:49:58 +0200
@@ -34,6 +34,7 @@
 #include "product.h"
 
 #include <io.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
 #include <string.h>
@@ -45,7 +46,7 @@
 
 
 // replace the RTL sscanf()
-int _cdecl sscanf( const char *source, const char *fmt, ... )
+int sscanf( const char *source, const char *fmt, ... )
 {
 	va_list arglist;
 
@@ -65,7 +66,7 @@
 
 
 // replaces the RTL sprintf()
-int _cdecl sprintf( char *dest, const char *fmt, ... )
+int sprintf( char *dest, const char *fmt, ... )
 {
 	va_list arglist;
 
@@ -74,6 +75,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, sprintf_far )
+
 // far target version of sprintf()
 int _cdecl sprintf_far( char _far *dest, const char *fmt, ... )
 {
@@ -102,7 +105,7 @@
 
 
 // fast printf() replacement function (always writes to STDOUT)
-int _cdecl printf(const char *format, ...)
+int printf(const char *format, ...)
 {
 	va_list arglist;
 
@@ -111,6 +114,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, color_printf )
+
 // colorized printf()
 int _cdecl color_printf( int attrib, const char *format, ... )
 {
@@ -139,6 +144,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, qputs )
+
 // write a string to STDOUT
 int _fastcall qputs( LPTSTR string )
 {
diff -Nu d:7.501/kstack SOURCES/kstack
--- d:7.501/kstack	2001-12-26 11:43:26 +0200
+++ SOURCES/kstack	2008-11-04 15:34:10 +0200
@@ -7,13 +7,12 @@
 COMPNAME=MSC7
 EXENAME=KSTACK.COM
 MAPNAME=KSTACK.MAP
-POSTLINKCMD=exe2com kstack.exe kstack.com
 
 # Set up language and compiler macros
 !INCLUDE SETUP.MAK
 
 # Define local commands
-LINKCMD=$(ALINK) kstack/map;
+LINKCMD=$(ALINK) kstack,$(EXENAME)/map;
 
 # Define ALL: target
 ALL : setenv $(LINKTARG)
diff -Nu d:7.501/kstack.asm SOURCES/kstack.asm
--- d:7.501/kstack.asm	2006-11-12 16:00:50 +0200
+++ SOURCES/kstack.asm	2008-11-05 01:47:00 +0200
@@ -27,7 +27,7 @@
 
 
           name      KSTACK
-          title     'KSTACK -- TSR for 4DOS 7.50 KEYSTACK function'
+          title     'KSTACK -- TSR for 4DOS 7.9 KEYSTACK function'
 
 ; KSTACK.ASM - copyright (c) 1991-2003  Rex C. Conn
 ;  TSR to support the KEYSTACK function in 4DOS
@@ -35,6 +35,27 @@
           include   product.asm
           include   trmac.asm           ; general macros
 
+kstacksvc macro     num
+          mov       ax,KSCODE
+          mov       bx,num
+          int       2Fh
+          endm
+
+writemsg  macro     msg
+          lea       dx,msg
+          calldos   MESSAGE
+          endm
+
+exitok    macro
+          mov       ax,4C00h
+          calldos
+          endm
+
+exiterr   macro
+          mov       ax,4C01h
+          calldos
+          endm
+
 code      segment   byte public 'text'
           assume cs:code, ds:nothing, es:nothing
 
@@ -51,6 +72,18 @@
 EntryPoint:
           jmp       Initialize
 
+; Above JMP instruction use approximately three bytes.
+; These bytes are used for storage when resident.
+;
+; flags    db ?
+; hdr_size dw ?
+;
+; flags   : Reserved. Set to zero
+; hdr_size: Header size at start of resident memory block in bytes (prior the
+;           EntryPoint label). This can be the partial PSP, other data, or none.
+;           The first WORD of this data defines the kind of data.
+;           21CDh: PSP.   Other values are reserved.
+
 oldint16  dd        ?                   ; pointers to previous interrupt handlers
 oldint2F  dd        ?
 
@@ -62,7 +95,6 @@
 nchleft   dw        0                   ; number of characters left in buffer
 savetype  db        0                   ; saved caller's AH
 
-
 newint16  proc      far                 ; new BIOS Int 16h (Keyboard)
           ;
           sti
@@ -137,7 +169,7 @@
 newint16  endp
 
 
-GetTicks  proc      near                ;gets current BIOS tick counter
+GetTicks  proc      near                ; gets current BIOS tick counter
           push      es
           mov       ax, 040h            ; point ES to ROM BIOS data area
           mov       es, ax
@@ -163,8 +195,12 @@
 ; -------------------------------------------------------------------
 ; INT 2F multiplex
 ;    AX = D44Fh
-;    BX = 0   Check for installed state
-;    BX = 1   Load the string in DS:DX
+;    BX = 00h  Check for installed state. Returns:
+;              CX= 2 if KSTACK 7.90 or zero if < 7.90
+;    BX = 01h  Load the string in DS:DX
+;    BX = 02h  Get number of characters left in buffer into AX (v7.90+)
+;    BX = 10h  Get start address of resident code into AX:CX (v7.90+).
+;              Points to the EntryPoint label.
 ;--------------------------------------------------------------------
 new2f     proc      far
 
@@ -172,147 +208,294 @@
           jne       jmpold2f
 
           mov       ax,KSRCODE
-          or        bx,bx                         ; check for installation?
+          or        bx,bx               ; check for installation?
           jz        new_2f_bye
+          cmp       bx,1
+          je        load_str
+          cmp       bx,2
+          je        get_nchleft
+          cmp       bx,10h
+          jne       jmpold2f
+
+; get resident memory block segment (not the MCB)
+          mov       ax,cs
+          lea       cx,EntryPoint
+          iret
 
+get_nchleft:
+; get number of characters left in buffer
+          mov       ax,nchleft
+          iret
+
+load_str:
+; load string from DS:DX
           sti
-          push      di
-          push      si
+          pushm     di,si
 
           cld
-          push      cs
-          pop       es
-          lea       di,k_buffer                   ; initialize destination pointer
+          loadseg   es,cs
+          lea       di,k_buffer         ; initialize destination pointer
           mov       cs:bufptr,di
           mov       cs:nchleft,cx
           mov       cs:delaycnt,0
           mov       si,dx
-	cmp	cx,01FFh			; limit to 511
-	jbe	cnt_ok
-	mov	cx,01FFh
+          cmp       cx,01FFh            ; limit to 511
+          jbe       cnt_ok
+          mov       cx,01FFh
 cnt_ok:
-          rep       movsw                         ; save string (DS:SI) to keystack buffer
+          rep       movsw               ; save string (DS:SI) to keystack buffer
 
-          pop       si
-          pop       di
+          popm      si,di
 
           xor       ax,ax
 new_2f_bye:
+          mov       cx,2                ; maximum user function number supported
           iret
 
 jmpold2f:
-          jmp       cs:oldint2F                   ; jump to previous INT 2F routine
+          jmp       cs:oldint2F         ; jump to previous INT 2F routine
 
 new2f     endp
 
 
-k_buffer label   byte            ; 1024 byte (512 scan codes) keystroke buffer
+k_buffer label   byte                   ; 1024 byte (512 scan codes) keystroke buffer
 
 
+;--------------------------------------------------------------------
+; Main program block
+;--------------------------------------------------------------------
+
+          assume ds:code
+
 ; Initialize the KEYSTACK support
 Initialize          proc      near
 
           mov       si,PSP_TLEN
-          lodsb                                   ; get length byte
-          cbw                                     ; make it a work
+          lodsb                         ; get length byte
+          cbw                           ; make it a work
           mov       bx,ax
-          mov       bptr[si][bx],0                ; null-terminate tail
+          mov       bptr[si][bx],0      ; null-terminate tail
 
 ParseTail:
           lodsb
-          or        al,al                         ; end of tail?
+          or        al,al               ; end of tail?
           je        TailDone
-          cmp       al,'/'                        ; switch char?
+          cmp       al,'/'              ; switch char?
           jne       ParseTail
           lodsb
-          cmp       al,'I'                        ; I(nstall) again?
-          je        not_installed
+          cmp       al,'I'              ; I(nstall) again?
+          je        DoInstall
           cmp       al,'i'
-          je        not_installed
-          jmp       short ParseTail
+          je        DoInstall
+          cmp       al,'U'              ; U(ninstall)?
+          je        DoUninstall
+          cmp       al,'u'
+          je        DoUninstall
+          jmp       ParseTail
 
 TailDone:
 ; check if we're already installed
-          mov       ax,KSCODE
-          xor       bx,bx
-          int       02Fh
+          kstacksvc 0
           cmp       ax,KSRCODE
-          jne       not_installed
+          jne       DoInstall
 
           ifndef    SILENT
-          mov       ah,9
-          lea       dx,ID_NO            ; display "already installed" message
-          int       21h
+          writemsg  ID_NO               ; display "already installed" message
           endif
+          exiterr                       ; terminate with errorlevel = 1
 
-          mov       ax,04C01h           ; terminate with errorlevel = 1
-          int       21h
+DoInstall: ;----------------------------
+          cld
 
-not_installed:
+; point to break address (free memory after driver loaded)
+          lea       dx,cs:k_buffer      ; set end of keyboard buffer
+          add       dx,1024             ; max characters anybody could enter
+          mov       cs:k_buffer_end,dx
 
-          mov       ax,cs:[PSP_ENV]     ; point to our environment block
-          or        ax,ax
-          jz        no_env
-          mov       es,ax
+; calculate resident code size (without any header)
+          add       dx,0Fh              ; align to next paragraph
+          mov       cx,4
+          shr       dx,cl               ; adjust number of paragraphs to keep
+          sub       dx,10h              ; exclude PSP area
+          mov       si,dx
+
+; initialize variables
+          mov       byte ptr [EntryPoint], 0    ; mark standard resident in low memory
+          mov       word ptr [EntryPoint+1],90h ; set header size
+
+; move resident code to PSP+90h
+          push      si
+          lea       si,EntryPoint
+          mov       di,80h              ; clear command line area
+          mov       cx,8
+          xor       ax,ax
+          rep       stosw
+          lea       cx,k_buffer         ; move the code
+          sub       cx,si
+          inc       cx
+          shr       cx,1
+          rep       movsw
+          pop       si
+          add       si,9                ; add lower 90h bytes PSP area
+
+; free environment memory block
+          mov       bx,2Ch              ; get environment segment
+          mov       es,[bx]
           calldos   FREE                ; free it
 
-no_env:
+; adjust resident segment
+          mov       ax,cs
+          sub       ax,7
+          mov       ds,ax
+          mov       cx,si
+
+set_interrupts:
 ; Load INT 16h (BIOS keyboard) trapping
           mov       ax,03516h
-          int       21h                 ; get old INT 16 address
+          calldos                       ; get old INT 16 address
           mov       word ptr [oldint16],bx
           mov       word ptr [oldint16+2],es
 
           mov       ax,02516h
           lea       dx,newint16
-          int       21h                 ; set new INT 16 address
+          calldos                       ; set new INT 16 address
 
 ; Load INT 2Fh (Multiplex) trapping
           mov       ax,0352Fh
-          int       21h                 ; get old INT 2F address
+          calldos                       ; get old INT 2F address
           mov       word ptr [oldint2F],bx
           mov       word ptr [oldint2F+2],es
 
           mov       ax,0252Fh
           lea       dx,new2F
-          int       21h                 ; set new INT 2F address
+          calldos                       ; set new INT 2F address
+          loadseg   ds,cs
 
           ifndef    SILENT
-          mov       ah,9
-          lea       dx,ID                         ; display sign-on message
-          int       21h
+          writemsg  ID                  ; display sign-on message
           endif
 
-; point to break address (free memory after driver loaded)
-          lea       dx,cs:k_buffer                ; set end of keyboard buffer
-          add       dx,1024                       ; max characters anybody could enter
-          mov       cs:k_buffer_end,dx
+; Go resident
+          mov       ax,3100h
+          mov       dx,cx
+          calldos
+
+DoUninstall: ;--------------------------
+; check if already installed
+          xor       cx,cx
+          kstacksvc 0
+          cmp       ax,KSRCODE
+          je        check_version
 
-          mov       cx,4
-          shr       dx,cl                         ; adjust number of paragraphs to keep
-          inc       dx
+          ifndef    SILENT
+          writemsg  ID_NONE             ; display not yet installed message
+          endif
+          exiterr
+
+check_version:
+; check if old KSTACK version
+          cmp       cx,2
+          jne       cant_unhook         ; can't unload old version (yet)
+
+; check if kstack is not busy
+          kstacksvc 2
+          or        ax,ax
+          jz        chk_hooks
 
-          mov       ax,03100h           ; terminate & stay resident
-          int       21h
+          ifndef    SILENT
+          writemsg  ID_BUSY             ; display busy message
+          endif
+          exiterr
+
+chk_hooks:
+; check if interrupt hooks can be restored
+          kstacksvc 10h                 ; get resident code address
+          mov       bp,ax               ; save for later use
+          mov       ax,3516h            ; check interrupt vector 16h
+          calldos
+          mov       ax,es
+          cmp       ax,bp
+          jne       cant_unhook
+          cmp       bx,offset newint16
+          jne       cant_unhook
+
+          mov       ax,352Fh            ; check interrupt vector 2Fh
+          calldos
+          mov       ax,es
+          cmp       ax,bp
+          jne       cant_unhook
+          cmp       bx,offset new2f
+          je        do_unhook
+
+cant_unhook:
+          ifndef    SILENT
+          loadseg   ds,cs
+          writemsg  ID_FAIL             ; display fail message
+          endif
+          exiterr
+
+do_unhook:
+; restore interrupt hooks
+          mov       ds,bp               ; restore int 16h
+          mov       ax,2516h
+          lds       dx,oldint16
+          calldos
+
+          mov       ds,bp               ; restore int 2Fh
+          mov       ax,252Fh
+          lds       dx,oldint2F
+          calldos
+
+; calculate memory block segment
+          mov       ds,bp
+          mov       ax,word ptr [EntryPoint+1]
+          sub       cx,ax
+          mov       ax,cx
+          mov       cl,4
+          shr       ax,cl
+          add       bp,ax
+
+free_mem:
+; free resident memory block
+          mov       es,bp
+          calldos   FREE
+
+          ifndef    SILENT
+          loadseg   ds,cs
+          writemsg  ID_UN               ; display unloaded message
+          endif
+          exitok
 
 Initialize  endp
 
+MCB_ID    db        'KSTACK  '
+
           ifdef     ENGLISH
           ifndef    SILENT
-ID        db        '4DOS 7.50 KSTACK loaded',13,10
-          db        'Copyright 1991-2003 Rex Conn & JP Software Inc.  All Rights Reserved.',13,10,'$'
+ID        db        '4DOS 7.9 KSTACK loaded',13,10
+          db        'Copyright 1991-2003 Rex Conn & JP Software Inc.  Changes 2008 JCU',13,10,'$'
 ID_NO     db        'KSTACK already loaded',13,10,'$'
+ID_NONE   db        'KSTACK not yet loaded',13,10,'$'
+ID_BUSY   db        'KSTACK is busy',13,10,'$'
+ID_NOMEM  db        'Not enough free memory',13,10,'$'
+ID_FAIL   db        'KSTACK can not be unloaded',13,10,'$'
+ID_UN     db        'KSTACK unloaded',13,10,'$'
           else                          ;define embedded copyright if silent
           db        'Copyright 1991-2003, Rex Conn & JP Software Inc., All Rights Reserved.'
           endif
           endif
 
           ifdef     GERMAN
-ID        db        '4DOS 7.50 KSTACK geladen',13,10
+ID        db        '4DOS 7.9 KSTACK geladen',13,10
           db        'Copyright 1988-2003  JP Software Inc.',13,10
           db        'Alle Rechte vorbehalten.  Vertrieb unter Lizenz von JP Software.',13,10,'$'
 
 ID_NO     db        'KSTACK bereits geladen',13,10,'$'
+ID_NONE   db        'KSTACK not yet loaded',13,10,'$'
+ID_BUSY   db        'KSTACK is busy',13,10,'$'
+ID_NOMEM  db        'Not enough free memory',13,10,'$'
+ID_FAIL   db        'KSTACK can not be unloaded',13,10,'$'
+ID_UN     db        'KSTACK unloaded',13,10,'$'
           endif
 
 code      ends
diff -Nu d:7.501/kstack.txt SOURCES/kstack.txt
--- d:7.501/kstack.txt	1970-01-01 02:00:00 +0200
+++ SOURCES/kstack.txt	2008-10-30 22:59:50 +0200
@@ -0,0 +1,21 @@
+Behaviour change in original KSTACK :
+
+* The environment memory block freeing routines have been removed since they will be done automatically by DOS.
+
+
+About KSTACK unload feature:
+
+* The DOS TSR function (i.e. Int 21h AH 31h) is not used. Instead, it mimics that function in order to have a greater control when going resident.
+
+* The type of memory used depends on current setting, so if UMB is available and KSTACK is loaded using the LOADHIGH command, it will be respected and search for the available free memory space is done first at the UMB and then the low memory.
+
+* Currently, HMA is not yet supported. Problem: memory manager may not have a "Deallocate HMA memory block" function so KSTACK may not be unloadable.
+
+* The once resident PSP area of KSTACK has been removed to shrink memory usage by 256 bytes.
+
+* /U or /u parameter is added for unloading KSTACK. If it's not specified, the original parameter parsing behaviour is performed.
+
+
+Overall:
+
+* Almost all of the original non-resident portion of the code have been changed. e.g. label renaming, conversion to macros. The resident portion only have very little code additions without affecting original code behaviour. Conversion to macros usage is intended to make the source easier to read.
diff -Nu d:7.501/langenv.inc SOURCES/langenv.inc
--- d:7.501/langenv.inc	1970-01-01 02:00:00 +0200
+++ SOURCES/langenv.inc	2006-11-28 19:18:16 +0200
@@ -0,0 +1,33 @@
+;*****************************************************************************
+;*
+;*                            Open Watcom Project
+;*
+;*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
+;*
+;*  ========================================================================
+;*
+;*    This file contains Original Code and/or Modifications of Original
+;*    Code as defined in and that are subject to the Sybase Open Watcom
+;*    Public License version 1.0 (the 'License'). You may not use this file
+;*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
+;*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
+;*    provided with the Original Code and Modifications, and is also
+;*    available at www.sybase.com/developer/opensource.
+;*
+;*    The Original Code and all software distributed under the License are
+;*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+;*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
+;*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
+;*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
+;*    NON-INFRINGEMENT. Please see the License for the specific language
+;*    governing rights and limitations under the License.
+;*
+;*  ========================================================================
+;*
+;* Description:  WHEN YOU FIGURE OUT WHAT THIS FILE DOES, PLEASE
+;*               DESCRIBE IT HERE!
+;*
+;*****************************************************************************
+
+
+COMP_CFG_COFF equ 0
diff -Nu d:7.501/ldosumb.asm SOURCES/ldosumb.asm
--- d:7.501/ldosumb.asm	1970-01-01 02:00:00 +0200
+++ SOURCES/ldosumb.asm	2007-09-18 18:00:00 +0200
@@ -0,0 +1 @@
+include dosumb.asm
diff -Nu d:7.501/leapyear.c SOURCES/leapyear.c
--- d:7.501/leapyear.c	1970-01-01 02:00:00 +0200
+++ SOURCES/leapyear.c	2007-07-03 13:37:06 +0200
@@ -0,0 +1,77 @@
+/****************************************************************************
+*
+*                            Open Watcom Project
+*
+*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
+*
+*  ========================================================================
+*
+*    This file contains Original Code and/or Modifications of Original
+*    Code as defined in and that are subject to the Sybase Open Watcom
+*    Public License version 1.0 (the 'License'). You may not use this file
+*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
+*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
+*    provided with the Original Code and Modifications, and is also
+*    available at www.sybase.com/developer/opensource.
+*
+*    The Original Code and all software distributed under the License are
+*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
+*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
+*    NON-INFRINGEMENT. Please see the License for the specific language
+*    governing rights and limitations under the License.
+*
+*  ========================================================================
+*
+* Description:  Check if a year is a leap year + associated arrays
+*
+****************************************************************************/
+
+#include "variety.h"
+#include <time.h>
+#include "rtdata.h"
+#include "timedata.h"
+
+short const __based(__segname("_CONST")) __diyr[] = { /* days in normal year array */
+    0,                                                          /* Jan */
+    31,                                                         /* Feb */
+    31 + 28,                                                    /* Mar */
+    31 + 28 + 31,                                               /* Apr */
+    31 + 28 + 31 + 30,                                          /* May */
+    31 + 28 + 31 + 30 + 31,                                     /* Jun */
+    31 + 28 + 31 + 30 + 31 + 30,                                /* Jul */
+    31 + 28 + 31 + 30 + 31 + 30 + 31,                           /* Aug */
+    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31,                      /* Sep */
+    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30,                 /* Oct */
+    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,            /* Nov */
+    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30,       /* Dec */
+    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31   /* Jan, next year */
+};
+
+short const __based(__segname("_CONST")) __dilyr[] = { /* days in leap year array */
+    0,                                                          /* Jan */
+    31,                                                         /* Feb */
+    31 + 29,                                                    /* Mar */
+    31 + 29 + 31,                                               /* Apr */
+    31 + 29 + 31 + 30,                                          /* May */
+    31 + 29 + 31 + 30 + 31,                                     /* Jun */
+    31 + 29 + 31 + 30 + 31 + 30,                                /* Jul */
+    31 + 29 + 31 + 30 + 31 + 30 + 31,                           /* Aug */
+    31 + 29 + 31 + 30 + 31 + 30 + 31 + 31,                      /* Sep */
+    31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30,                 /* Oct */
+    31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,            /* Nov */
+    31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30,       /* Dec */
+    31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31   /* Jan, next year */
+};
+
+int __leapyear( unsigned year )
+{
+    if( year & 3 )
+        return( 0 );
+    if( ( year % 100 ) != 0 )
+        return( 1 );
+    if( ( year % 400 ) == 0 )
+        return( 1 );
+    return( 0 );
+}
diff -Nu d:7.501/lerrmsg.asm SOURCES/lerrmsg.asm
--- d:7.501/lerrmsg.asm	1970-01-01 02:00:00 +0200
+++ SOURCES/lerrmsg.asm	2007-09-18 17:40:10 +0200
@@ -0,0 +1 @@
+include errormsg.asm
diff -Nu d:7.501/lines.c SOURCES/lines.c
--- d:7.501/lines.c	2006-11-12 16:00:50 +0200
+++ SOURCES/lines.c	2008-11-17 09:10:24 +0200
@@ -389,13 +389,13 @@
 			nLeft = nRight - 1;
 
 		// read the character and attribute, and change
-		//   the attribute to black background, low intensity
+		//   the attribute to black background, dark gray
 		//   foreground
-		SetLineColor( ++nBottom, nLeft, (nRight-nLeft), 7 );
+		SetLineColor( ++nBottom, nLeft, (nRight-nLeft), 8 );
 
 		// shadow the right side of the window
 		for ( nTop++; ( nTop <= nBottom ); nTop++ )
-			SetLineColor( nTop, nRight, 2, 7 );
+			SetLineColor( nTop, nRight, 2, 8 );
 	}
 }
 
diff -Nu d:7.501/listall.c SOURCES/listall.c
--- d:7.501/listall.c	2006-11-12 16:00:50 +0200
+++ SOURCES/listall.c	2008-10-20 08:33:26 +0200
@@ -73,6 +73,7 @@
 
 TCHAR  szListFindWhat[80] = _TEXT("");
 TCHAR  szFFindFindWhat[128] = _TEXT("");
+static TCHAR szStartLine[32] = _TEXT("");
 static TCHAR szClip[MAXFILENAME];
 
 static BOOL bListSkipLine = 0;
@@ -421,8 +422,10 @@
 
 		if (( glDirFlags & DIRFLAGS_NO_FOOTER ) == 0 ) {
 			// display number of lines & files found
-			crlf();
-			_page_break();
+			if (( Find.fFlags & FFIND_SUMMARY ) == 0 ) {
+				crlf();
+				_page_break();
+			}
 			if ( Find.fFlags & FFIND_TEXT )
 				printf( FFIND_TEXT_FOUND, Find.lLinesFound, (( Find.lLinesFound == 1) ? FFIND_ONE_LINE : FFIND_MANY_LINES) );
 			FilesProcessed( FFIND_FOUND, Find.lFilesFound );
@@ -800,6 +803,8 @@
 static VOID SetRightMargin( void )
 {
 	nRightMargin = (( lListFlags & LIST_WRAP ) ? nScreenColumns + 1 : MAXLISTLINE );
+	if ( !( lListFlags & LIST_HEX ) && lListFlags & LIST_LINENUMBERS )
+		nRightMargin -= 6;
 }
 
 
@@ -858,9 +863,9 @@
 // Display Line
 static int _fastcall DisplayLine( UINT nRow, LONG lLinePtr )
 {
-	register int i, n;
+	register int n, nCol;
 	INT nLength, nBytesPrinted = 0, nHOffset = 0, nHexOffset;
-	TCHAR *pszArg, cSave;
+	TCHAR *pszArg;
 	TCHAR szBuffer[MAXLISTLINE+1];
 
 	ListSetCurrent( lLinePtr );
@@ -870,9 +875,9 @@
 	if (( lListFlags & LIST_HEX ) == 0 ) {
 		nHOffset = LFile.nListHorizOffset;
 		nLength -= LFile.nListHorizOffset;
-		nHexOffset = 0;
+		nHexOffset = lListFlags & LIST_LINENUMBERS ? 6 : 0;
 	} else
-		nHexOffset = 9;
+		nHexOffset = 10;
 
 	// adjust to max screen width
 	if ( nLength > ( nScreenColumns + 1 ))
@@ -885,26 +890,30 @@
 	}
 
 	// if we're displaying a search result, highlight the string
-	if (( LFile.fDisplaySearch ) && ( strlen( szBuffer ) > (int)nHOffset )) {
-
-		for ( i = 0; ; ) {
+	if ( LFile.fDisplaySearch && strlen( szBuffer ) > (UINT)nHOffset ) {
+		TCHAR *pszWhere = szBuffer + nHOffset + nHexOffset;
 
-			if ( LFile.fDisplaySearch & 2 )
-				pszArg = strstr( szBuffer + nHOffset + i + nHexOffset, szListFindWhat );
+		if ( fSearchFlags & FFIND_HEX_SEARCH ) {
+			// don't search in the ASCII string at the right
+			pszWhere[48] = _TEXT('\0');
+			// remove 1 of the 2 middle spaces
+			strcpy( pszWhere + 23, pszWhere + 24 );
+		} else if ( lListFlags & LIST_HEX )  // text search in hex mode -
+			memset( pszWhere, 0xFF, 51 );// don't search in hex area
+		n = strlen( szListFindWhat );
+		if ( fSearchFlags & FFIND_HEX_SEARCH )
+			n++;
+		for ( ; ; pszWhere++ ) {
+			if ( LFile.fDisplaySearch & 2 && !( fSearchFlags & FFIND_HEX_SEARCH ))
+				pszArg = strstr( pszWhere, szListFindWhat );
 			else
-				pszArg = stristr( szBuffer + nHOffset + i + nHexOffset, szListFindWhat );
+				pszArg = stristr( pszWhere, szListFindWhat );
 			if ( pszArg == NULL )
 				break;
-
-			n = strlen( szListFindWhat );
-			cSave = pszArg[ n ];
-			pszArg[ n ] = _TEXT('\0');
-			i = (int)( pszArg - ( szBuffer + nHOffset ));
-
-			WriteStrAtt( nRow, i, nInverse, pszArg );
-
-			pszArg[ n ] = cSave;
-			i += n;
+			nCol = pszArg - szBuffer - nHOffset;
+			if ( n > nLength - nCol && ( n = nLength - nCol ) <= 0 )
+				break;
+			SetLineColor( nRow, nCol, n, nInverse );
 		}
 	}
 
@@ -984,6 +993,10 @@
 
 		// Print as ASCII until CR/LF or for "nRightMargin" characters.
 
+		if ( lListFlags & LIST_LINENUMBERS ) {
+			sprintf( szBuffer, "%5lu ", LFile.lCurrentLine + gpIniptr->ListRowStart );
+			szBuffer += 6;
+		}
 		SetRightMargin();
 		for ( i = 0; ( i < nBufferLength-1 ); ) {
 
@@ -1019,13 +1032,14 @@
 		}
 
 		szBuffer[i] = _TEXT('\0');
-
+		if ( lListFlags & LIST_LINENUMBERS )
+			i += 6;
 	} else {
 
 		// Convert from Hex and print.
 
 		// clear the whole line to blanks
-		sprintf( szBuffer, _TEXT("%04lx %04lx%70s"), (long)( lLinePtr / 0x10000L), (long)( lLinePtr & 0xFFFF ), NULLSTR );
+		sprintf( szBuffer, _TEXT("%04lx %04lx%68s"), (long)( lLinePtr / 0x10000L), (long)( lLinePtr & 0xFFFF ), NULLSTR );
 
 		for ( i = 0; ( i < 16 ); i++ ) {
 
@@ -1084,7 +1098,7 @@
 					if ((( i = GetNextChar()) == EOF ) || ( i == LFile.fEoL ))
 						break;
 
-					if ( n >= nRightMargin ) {
+					if ( n >= nRightMargin && i != CR ) {
 						GetPrevChar();
 						break;
 					}
@@ -1196,7 +1210,6 @@
 	UINT  uLimit;
 	LONG  lTemp, lLocalPtr;
 	TCHAR szSearchStr[128], *pszSearchStr;
-	int fKBHit;
 
 	nCodePage = QueryCodePage();
 
@@ -1208,7 +1221,6 @@
 	if ( fFlags & FFIND_HEX_SEARCH ) {
 
 		// convert ASCII hex string to binary equivalent
-		strupr( pszSearchStr );
 		for ( i = 0; (( sscanf( pszSearchStr, _TEXT("%x%n"), &uLimit, &LFile.nSearchLen ) != 0 ) && ( LFile.nSearchLen > 0 )); i++ ) {
 			sprintf( szSearchStr+i, FMT_CHAR, uLimit );
 			pszSearchStr += LFile.nSearchLen;
@@ -1260,26 +1272,18 @@
 			// abort search if ESC key is hit
 			if (( nLoopCounter % 1024 ) == 0 ) {
 
+				CheckForBreak();
+
 				// kbhit() in DOS tries to read from STDIN, which
 				//   screws up a LIST /S pipe
-				_asm {
-					mov		ah, 1
-					int		16h
-					mov		fKBHit, 1
-					jnz		KBHDone
-					mov		fKBHit, 0
-KBHDone:
-				}
-				if ( fKBHit && ( GetKeystroke( EDIT_NO_ECHO | EDIT_BIOS_KEY ) == ESC ))
+				if ( bios_kbhit() && ( GetKeystroke( EDIT_NO_ECHO | EDIT_BIOS_KEY ) == ESC ))
 					break;
 
 			}
 			nLoopCounter++;
 
-			if (( c >= _TEXT('a') ) && ( fIgnoreCase )) {
-				if (( c <= _TEXT('z') ) || ( c >= 0x80 ))
-					c = _ctoupper( c );
-			}
+			if ( fIgnoreCase )
+				c = _ctoupper( c );
 
 			if ( c != (int)szSearchStr[i] ) {
 
@@ -1325,19 +1329,14 @@
 				}
 
 				if (( nLoopCounter % 1024 ) == 0 ) {
+
+					CheckForBreak();
+
 					// abort search if ESC key is hit
 
 					// kbhit() in DOS tries to read from STDIN, which
 					//   screws up a LIST /S pipe
-					_asm {
-						mov		ah, 1
-						int		16h
-						mov		fKBHit, 1
-						jnz		KBHDone2
-						mov		fKBHit, 0
-KBHDone2:
-					}
-					if ( fKBHit && ( GetKeystroke( EDIT_NO_ECHO | EDIT_BIOS_KEY ) == ESC ))
+					if ( bios_kbhit() && ( GetKeystroke( EDIT_NO_ECHO | EDIT_BIOS_KEY ) == ESC ))
 						break;
 
 				}
@@ -1346,10 +1345,8 @@
 
 				nOffset++;
 
-				if (( c >= _TEXT('a') ) && ( fIgnoreCase )) {
-					if (( c <= _TEXT('z')) || ( c >= 0x80 ))
-						c = _ctoupper( c );
-				}
+				if ( fIgnoreCase )
+					c = _ctoupper( c );
 
 				// ? matches any single character
 				if ( szSearchStr[i] == _TEXT('?') )
diff -Nu d:7.501/listc.c SOURCES/listc.c
--- d:7.501/listc.c	2006-11-12 16:00:50 +0200
+++ SOURCES/listc.c	2008-11-24 11:37:48 +0200
@@ -91,8 +91,11 @@
 		sscanf( szSource+1, _TEXT("%79[^\"]"), szListFindWhat );
 	else if ( szSource[0] )
 		sprintf( szListFindWhat, FMT_PREC_STR, 79, szSource );
+
+	// check for /Ln
+	GetMultiCharSwitch( pszCmdLine, _TEXT("L"), szStartLine, 31 );
 	
-	if ( GetSwitches( pszCmdLine, _TEXT("*HIRSWX"), &lListFlags, 0 ) != 0 )
+	if ( GetSwitches( pszCmdLine, _TEXT("*HINRSWX"), &lListFlags, 0 ) != 0 )
 		return ( Usage( LIST_USAGE ));
 	
 	if ( szSource[0] )
@@ -218,7 +221,7 @@
 	if ( LFile.hHandle > 0 )
 		_close( LFile.hHandle );
 	LFile.hHandle = -1;
-	
+	SetCurSize();	// restore cursor
 	return nReturn;
 }
 
@@ -230,7 +233,8 @@
 	long lTemp, lRow;
 	POPWINDOWPTR wn = NULL;
 	FILESEARCH dir;
-	
+	static long fOldFindMode = 0;
+
 	// get default normal and inverse attributes
 	if ( gpIniptr->ListColor != 0 ) {
 		SetScrColor( nScreenRows, nScreenColumns, gpIniptr->ListColor );
@@ -252,8 +256,17 @@
 	// kludge for empty files or pipes
 	if ( LFile.lSize == 0L )
 		LFile.lSize = 1L;
+
+	MouseReset();
+
+	if ( szStartLine[0] ) {
+		strcpy( szLine, szStartLine );
+		goto SetStartLine;
+	}
 	
 	for ( ; ; ) {
+
+		HideCursor();
 		
 		// display header
 		if ( fDirtyHeader ) {
@@ -262,12 +275,17 @@
 			WriteStrAtt( 0, 0, nInverse, szHeader );
 			fDirtyHeader = 0;
 		}
+		// avoid overflow
+		if ( LFile.lViewPtr < LONG_MAX / 100 )
+			i = (int)(( LFile.lViewPtr + 1 ) * 100 / LFile.lSize );
+		else
+			i = (int)(( LFile.lViewPtr + 99 ) / (( LFile.lSize + 99 ) / 100 ));
 		
 		// display location within file
 		//	(don't use color_printf() so we won't have
 		//	problems with windowed sessions)
 
-		i = sprintf( szHeader, LIST_LINE, LFile.nListHorizOffset, LFile.lCurrentLine + gpIniptr->ListRowStart, (int)((( LFile.lViewPtr + 1 ) * 100 ) / LFile.lSize ));
+		i = sprintf( szHeader, LIST_LINE, LFile.nListHorizOffset, LFile.lCurrentLine + gpIniptr->ListRowStart, i );
 
 		WriteStrAtt( 0, ( nScreenColumns - i ), nInverse, szHeader );
 		SetCurPos( 0, 0 );
@@ -289,6 +307,11 @@
 			
 			if ( lListFlags & LIST_NOWILDCARDS )
 				fSearchFlags |= FFIND_NOWILDCARDS;
+			if ( lListFlags & LIST_HEX ) {
+				fSearchFlags |= FFIND_HEX_SEARCH;
+				fOldFindMode |= FFIND_HEX_SEARCH;
+			} else
+				fOldFindMode &= ~FFIND_HEX_SEARCH;
 			bListSkipLine = 0;
 			goto FindNext;
 		}
@@ -296,7 +319,7 @@
 		// get the key from the BIOS, because
 		//	 STDIN might be redirected
 		
-		if ((( c = cvtkey( GetKeystroke( EDIT_NO_ECHO | EDIT_BIOS_KEY | EDIT_UC_SHIFT), MAP_GEN | MAP_LIST)) == (TCHAR)ESC ))
+		if (( c = cvtkey( GetKeystroke( EDIT_NO_ECHO | EDIT_BIOS_KEY | EDIT_UC_SHIFT | EDIT_MOUSE_BUTTON), MAP_GEN | MAP_LIST)) == (TCHAR)ESC || c == (TCHAR)RIGHT_MOUSE_BUTTON )
 			break;
 		
 		switch ( c ) {
@@ -324,6 +347,7 @@
 			break;
 			
 		case CUR_UP:
+		case WHEEL_UP:
 			
 			if ( ListMoveLine( -1 ) == 0 )
 				goto bad_key;
@@ -333,6 +357,7 @@
 			continue;
 			
 		case CUR_DOWN:
+		case WHEEL_DOWN:
 			
 			if ( ListMoveLine( 1 ) == 0 )
 				goto bad_key;
@@ -343,8 +368,11 @@
 			lTemp = LFile.lViewPtr;
 			lRow = (nScreenRows - 1);
 			lTemp += MoveViewPtr( lTemp, &lRow );
-			if ( lRow == ( nScreenRows - 1 ))
+			if ( lRow == ( nScreenRows - 1 )) {
+				LFile.lCurrentLine += lRow;
 				DisplayLine( nScreenRows, lTemp );
+				LFile.lCurrentLine -= lRow;
+			}
 			continue;
 			
 		case HOME:
@@ -479,26 +507,26 @@
 					
 					lpszText = lpszArg = (TCHAR _far *)AllocMem( &uSize );
 
-					strcpy(szBuf, FormatDate( dir.fd.file_date.months, dir.fd.file_date.days, dir.fd.file_date.years + 80, 0 ));
+					strcpy(szBuf, FormatDate( dir.fd.file_date.months, dir.fd.file_date.days, dir.fd.file_date.years + 80, 0x100 ));
 					
 					if (fFSType != FAT) {
 						FileTimeToDOSTime( &(dir.ftLastAccessTime), &( laDir.ft.wr_time), &( laDir.fd.wr_date) );
 						FileTimeToDOSTime( &(dir.ftCreationTime), &(crDir.ft.wr_time), &(crDir.fd.wr_date) );
-						strcpy( szLine, FormatDate( laDir.fd.file_date.months, laDir.fd.file_date.days, laDir.fd.file_date.years + 80, 0 ));
+						strcpy( szLine, FormatDate( laDir.fd.file_date.months, laDir.fd.file_date.days, laDir.fd.file_date.years + 80, 0x100 ));
 						sprintf_far( lpszText, LIST_INFO_LFN,
 							LFile.szName, szDescription, dir.ulSize,
 							szBuf,
-							dir.ft.file_time.hours, gaCountryInfo.szTimeSeparator[0],dir.ft.file_time.minutes,
+							dir.ft.file_time.hours, gaCountryInfo.szTimeSeparator[0],dir.ft.file_time.minutes, gaCountryInfo.szTimeSeparator[0], dir.ft.file_time.seconds * 2,
 							szLine,
-							laDir.ft.file_time.hours, gaCountryInfo.szTimeSeparator[0], laDir.ft.file_time.minutes,
-							FormatDate( crDir.fd.file_date.months, crDir.fd.file_date.days, crDir.fd.file_date.years + 80, 0 ),
-							crDir.ft.file_time.hours, gaCountryInfo.szTimeSeparator[0], crDir.ft.file_time.minutes);
+							laDir.ft.file_time.hours, gaCountryInfo.szTimeSeparator[0], laDir.ft.file_time.minutes, gaCountryInfo.szTimeSeparator[0], laDir.ft.file_time.seconds * 2,
+							FormatDate( crDir.fd.file_date.months, crDir.fd.file_date.days, crDir.fd.file_date.years + 80, 0x100 ),
+							crDir.ft.file_time.hours, gaCountryInfo.szTimeSeparator[0], crDir.ft.file_time.minutes,  gaCountryInfo.szTimeSeparator[0], crDir.ft.file_time.seconds * 2 );
 					} else {
 						
 						sprintf_far( lpszText, LIST_INFO_FAT,
 							LFile.szName, szDescription, dir.ulSize,
 							szBuf, dir.ft.file_time.hours, 
-							gaCountryInfo.szTimeSeparator[0],dir.ft.file_time.minutes );
+							gaCountryInfo.szTimeSeparator[0],dir.ft.file_time.minutes, gaCountryInfo.szTimeSeparator[0], dir.ft.file_time.seconds * 2 );
 					}
 
 					// print the text
@@ -553,11 +581,11 @@
 			
 			if ( i == 0 )
 				break;
+SetStartLine:
 			list_wait( LIST_WAIT );
 			
 			// if in hex mode, jump to offset 
 			if ( lListFlags & LIST_HEX ) {
-				strupr( szLine );
 				sscanf( szLine, _TEXT("%lx"), &lRow );
 				lRow = lRow / 0x10;
 			} else if ( sscanf( szLine, FMT_LONG, &lRow ) == 0 )
@@ -579,11 +607,20 @@
 			lListFlags ^= LIST_HIBIT;
 			break;
 			
+		case LIST_LINENUMB_CHAR:
+			
+			// toggle line numbers
+			lListFlags ^= LIST_LINENUMBERS;
+			if ( lListFlags & LIST_WRAP )
+				goto WrapRecalc;
+			break;
+			
 		case LIST_WRAP_CHAR:
 			
 			// toggle line wrap
 			lListFlags ^= LIST_WRAP;
-			nRightMargin = (( lListFlags & LIST_WRAP ) ? GetScrCols() : MAXLISTLINE );
+WrapRecalc:
+			SetRightMargin();
 			
 			// recalculate current line
 			list_wait( LIST_WAIT );
@@ -631,13 +668,19 @@
 				
 				// disable ^C / ^BREAK handling
 				HoldSignals();
-				
-				fSearchFlags = 0;
-				wn = wOpen( 2, 1, 4, 75, nInverse, (( c == LIST_FIND_NEXT_CHAR_REVERSE ) ? LIST_FIND_TITLE_REVERSE : LIST_FIND_TITLE ), NULL );
+
+				// match case if a Shift key held
+				if ( bios_shiftstate() & 3 )
+					fSearchFlags = FFIND_CHECK_CASE;
+				else
+					fSearchFlags = 0;
+
+				wn = wOpen( 2, 1, 4, 75, nInverse, (( c == LIST_FIND_CHAR_REVERSE ) ? LIST_FIND_TITLE_REVERSE : LIST_FIND_TITLE ), fSearchFlags ? LIST_FIND_BTITLE_CASE : NULL );
 				wn->nAttrib = nNormal;
 				wClear();
 				
 				if ( lListFlags & LIST_HEX ) {
+					SetCurSize(); // restore cursor temporarily
 					wWriteListStr( 0, 1, wn, LIST_FIND_HEX );
 					if ( GetKeystroke( EDIT_ECHO | EDIT_BIOS_KEY | EDIT_UC_SHIFT ) == YES_CHAR )
 						fSearchFlags |= FFIND_HEX_SEARCH;
@@ -645,7 +688,8 @@
 				}
 				
 				wWriteListStr( 0, 1, wn, LIST_FIND );
-				egets( szListFindWhat, 64, (EDIT_DIALOG | EDIT_BIOS_KEY | EDIT_NO_CRLF));
+				egets( szListFindWhat, 64, EDIT_DIALOG | EDIT_BIOS_KEY | EDIT_NO_CRLF | ( fOldFindMode == ( fSearchFlags & FFIND_HEX_SEARCH ) ? EDIT_ECHO : 0 ));
+				fOldFindMode = fSearchFlags & FFIND_HEX_SEARCH;
 				wRemove( wn );
 				
 				// enable ^C / ^BREAK handling
@@ -751,9 +795,10 @@
 	if ( LFile.szName[0] == _TEXT('\0') )
 		return;
 	
-	for ( nRow = 1; ( nRow <= nScreenRows ); nRow++ )
+	for ( nRow = 1; ( nRow <= nScreenRows ); nRow++, LFile.lCurrentLine++ )
 		lTemp += DisplayLine( nRow, lTemp );
 
+	LFile.lCurrentLine -= nScreenRows;
 	LFile.fDisplaySearch = 0;
 }
 
@@ -763,10 +808,9 @@
 {
 	register int i, n;
 	int c, nRows, nBytesPrinted, nFH;
-	long lTemp;
+	long lTemp, lLine;
 	POPWINDOWPTR wn;
 	TCHAR szBuffer[MAXLISTLINE+1];
-	int fKBHit;
 	
 	// disable ^C / ^BREAK handling
 	HoldSignals();
@@ -781,6 +825,7 @@
 		
 		// save start position
 		lTemp = LFile.lViewPtr;
+		lLine = LFile.lCurrentLine;
 		
 		// display "Printing ..."
 		wWriteListStr( 0, 1, wn, LIST_PRINTING );
@@ -793,9 +838,10 @@
 			}
 
 			// reset to beginning of file
-			if ( c == LIST_PRINT_FILE_CHAR )
+			if ( c == LIST_PRINT_FILE_CHAR ) {
 				ListSetCurrent( 0L );
-			else {
+				LFile.lCurrentLine = 0;
+			} else {
 				nRows = GetScrRows();
 				ListSetCurrent( LFile.lViewPtr );
 			}
@@ -808,19 +854,12 @@
 
 				// kbhit() in DOS tries to read from STDIN, which screws
 				//	 up a LIST /S pipe
-				_asm {
-					mov 	ah, 1
-					int 	16h
-					mov 	fKBHit, 1
-					jnz 	KBHDone
-					mov 	fKBHit, 0
-KBHDone:
-				}
-				if ( fKBHit && ( GetKeystroke( EDIT_NO_ECHO | EDIT_BIOS_KEY ) == ESC ))
+				if ( bios_kbhit() && ( GetKeystroke( EDIT_NO_ECHO | EDIT_BIOS_KEY ) == ESC ))
 					break;
 
 				i = FormatLine( szBuffer, MAXLISTLINE, LFile.lViewPtr, &nBytesPrinted, TRUE );
 				LFile.lViewPtr += 16;
+				LFile.lCurrentLine++;
 				
 				// replace 0-31 with "."
 				if ( lListFlags & LIST_HEX ) {
@@ -841,6 +880,7 @@
 			
 			// restore start position
 			LFile.lViewPtr = lTemp;
+			LFile.lCurrentLine = lLine;
 			ListSetCurrent( LFile.lViewPtr );
 			
 		} else
diff -Nu d:7.501/locmktim.c SOURCES/locmktim.c
--- d:7.501/locmktim.c	1970-01-01 02:00:00 +0200
+++ SOURCES/locmktim.c	2007-07-03 13:37:06 +0200
@@ -0,0 +1,103 @@
+/****************************************************************************
+*
+*                            Open Watcom Project
+*
+*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
+*
+*  ========================================================================
+*
+*    This file contains Original Code and/or Modifications of Original
+*    Code as defined in and that are subject to the Sybase Open Watcom
+*    Public License version 1.0 (the 'License'). You may not use this file
+*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
+*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
+*    provided with the Original Code and Modifications, and is also
+*    available at www.sybase.com/developer/opensource.
+*
+*    The Original Code and all software distributed under the License are
+*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
+*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
+*    NON-INFRINGEMENT. Please see the License for the specific language
+*    governing rights and limitations under the License.
+*
+*  ========================================================================
+*
+* Description:  mktime() without timezone and struct tm fields adjustment.
+*               used by mktime() and DOS clock()
+*
+****************************************************************************/
+
+#include "variety.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <limits.h>
+#include "rtdata.h"
+#include "timedata.h"
+
+#define MONTH_YR        ( 12 )
+#define DAY_YR          ( 365 )
+#define HOUR_YR         ( DAY_YR * 24 )
+#define MINUTE_YR       ( HOUR_YR * 60 )
+#define SECOND_YR       ( MINUTE_YR * 60 )
+#define __MONTHS        ( INT_MIN / MONTH_YR )
+#define __DAYS          ( INT_MIN / DAY_YR )
+
+// these ones can underflow in 16bit environments,
+// so check the relative values first
+#if ( HOUR_YR ) < ( INT_MAX / 60 )
+ #define __MINUTES      ( INT_MIN / MINUTE_YR )
+ #if ( MINUTE_YR ) < ( INT_MAX / 60 )
+  #define __SECONDS     ( INT_MIN / SECOND_YR )
+ #else
+  #define __SECONDS     ( 0 )
+ #endif
+#else
+ #define __MINUTES      ( 0 )
+ #define __SECONDS      ( 0 )
+#endif
+
+#define SMALLEST_YEAR_VALUE ( __MONTHS + __DAYS + __MINUTES + __SECONDS )
+
+time_t __local_mktime( const struct tm *t, long *pdays, long *pseconds )
+{
+    int         month;
+    int         year;
+    long        days;
+    long        seconds;
+    short const *month_start;
+
+    month_start = __diyr;
+    month = t->tm_mon % 12; /* put tm_mon into range */
+    year = t->tm_year;
+    if( year < SMALLEST_YEAR_VALUE )
+        return( ( time_t ) -1 );
+    year += t->tm_mon / 12;
+    while( month < 0 )
+        --year, month += 12;
+    if( year < 0 )
+        return( ( time_t ) -1 );
+    if( __leapyear( ( unsigned ) ( year + 1900 ) ) )
+        month_start = __dilyr;
+    days = year * 365L                   /* # of days in the years */
+        + ( ( year + 3 ) / 4 )           /* add # of leap years before year */
+        - ( ( year + 99 ) / 100 )        /* sub # of leap centuries */
+        + ( ( year + 399 - 100 ) / 400 ) /* add # of leap 4 centuries */
+                                         /* adjust for 1900 offset */
+                                         /* note: -100 == 300 (mod 400) */
+        + month_start[month]             /* # of days to 1st of month*/
+        + t->tm_mday - 1;                /* day of the month */
+    seconds = ( ( ( long ) ( t->tm_hour ) ) *60L + ( long ) ( t->tm_min ) ) *60L + t->tm_sec;
+                                         /* seconds needs to be positive for __brktime */
+    while( seconds < 0 )
+        days -= 1, seconds += ( long ) SECONDS_PER_DAY;
+    while( seconds >= ( long ) SECONDS_PER_DAY )
+        days += 1, seconds -= ( long ) SECONDS_PER_DAY;
+    if( days < ( DAYS_FROM_1900_TO_1970 - 1 ) )
+        return( ( time_t ) -1 );
+    if ( pdays ) *pdays = days;
+    if ( pseconds ) *pseconds = seconds;
+    return( seconds + ( days - DAYS_FROM_1900_TO_1970 ) * ( long ) SECONDS_PER_DAY );
+}
diff -Nu d:7.501/lreloc.asm SOURCES/lreloc.asm
--- d:7.501/lreloc.asm	1970-01-01 02:00:00 +0200
+++ SOURCES/lreloc.asm	2007-09-18 18:01:18 +0200
@@ -0,0 +1 @@
+include relocate.asm
diff -Nu d:7.501/master.mif SOURCES/master.mif
--- d:7.501/master.mif	1970-01-01 02:00:00 +0200
+++ SOURCES/master.mif	2008-12-26 09:48:30 +0200
@@ -0,0 +1,140 @@
+# 4DOS master makefile
+
+# Tools setup
+
+cc = wcc
+as = ml
+link = wlink
+
+# Build flags
+
+cflags = -zq -bt=dos -DENGLISH -D__4DOS -mm -zp1 -zls -s #-wx -we
+aflags = -nologo -c -Zm -DENGLISH -D__4DOS -D__WATCOM__
+lflags =
+
+!ifdef debug
+cflags += -d2
+aflags += -Zi
+lflags += debug all
+!else
+cflags += -oasbmr -0
+!endif
+
+# File locations
+
+.c: ..
+.h: ..
+.asm: ..
+
+# Implicit build rules
+
+.c.obj: .autodepend
+   $(cc) $(cflags) $(cflags_$[&) $[@
+
+.asm.obj
+   $(as) $(aflags) $(aflags_$[&) $[@
+
+# Additional flags for individual objects
+
+cflags_main     = -NT_TEXT
+cflags_parser   = -NT_TEXT
+cflags_dosinit  = -NT_TEXT
+cflags_cmds     = -NT_TEXT
+cflags_expand   = -NTMISC_TEXT
+cflags_eval     = -NTSCREENIO_TEXT
+cflags_filecmds = -NT_TEXT
+cflags_syscmds  = -NT_TEXT
+cflags_select   = -NTSCREENIO_TEXT
+cflags_env      = -NT_TEXT
+cflags_batch    = -NT_TEXT
+cflags_error    = -NT_TEXT
+cflags_window   = -NTSCREENIO_TEXT
+cflags_listall  = -NTSCREENIO_TEXT
+cflags_lines    = -NTSCREENIO_TEXT
+cflags_doscmds  = -NT_TEXT
+cflags_iofmt    = -NTSCREENIO_TEXT
+cflags_doscalls = -NTMISC_TEXT
+cflags_dostty   = -NTSCREENIO_TEXT
+cflags__file    = -NT_TEXT
+cflags_strmenc  = -NTSHARE_TEXT
+cflags_wrapper  = -NT_TEXT
+
+cflags_apprel   = -ml
+
+aflags_4dostart = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+aflags_4dos     = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+aflags_lerrmsg  = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+aflags_modules  = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+aflags_ldosumb  = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+aflags_initerrs = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+aflags_4dlinit  = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+aflags_fname    = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+aflags_decout   = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+aflags_srchenv  = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+aflags_parspath = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+aflags_findems  = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+aflags_findureg = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+aflags_iniparse = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+aflags_lreloc   = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+aflags_hexout   = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+aflags_forceref = -D_CSEG=LOAD -D_PREFIX=L_ -D_MODEL=TINY
+
+aflags_server   = -D_CSEG=SERV -D_MODEL=SMALL
+aflags_swapchk  = -D_CSEG=SERV -D_MODEL=SMALL
+aflags_serverrs = -D_CSEG=SERV -D_MODEL=SMALL
+aflags_reshigh  = -D_CSEG=SERV -D_MODEL=SMALL
+aflags_dosumb   = -D_CSEG=SERV -D_MODEL=SMALL
+aflags_relocate = -D_CSEG=SERV -D_MODEL=SMALL
+aflags_dv       = -D_CSEG=SERV -D_MODEL=SMALL
+aflags_errormsg = -D_CSEG=SERV -D_MODEL=SMALL
+
+aflags_inout    = -D_MODEL=SMALL
+aflags_dosutil  = -D_MODEL=SMALL
+aflags_bcd      = -D_MODEL=SMALL
+aflags_keyparse = -D_MODEL=SMALL
+aflags_tokens   = -D_MODEL=SMALL
+aflags_umbreg   = -D_MODEL=SMALL
+aflags_compdrv  = -D_MODEL=SMALL
+aflags_batdcomp = -D_MODEL=SMALL
+
+# Targets and explicit rules
+
+all : 4dos.com
+
+4dostart.lib : 4dostart.obj
+    wlib -q -b 4dostart -+4dostart.obj
+
+4dosobjs = &
+	   4dos.obj lerrmsg.obj modules.obj ldosumb.obj initerrs.obj    &
+	   forceref.obj 4dlinit.obj fname.obj decout.obj srchenv.obj    &
+	   findems.obj findureg.obj iniparse.obj lreloc.obj hexout.obj  &
+	   server.obj swapchk.obj serverrs.obj reshigh.obj dosumb.obj   &
+	   relocate.obj dv.obj errormsg.obj cstrt086.obj                &
+	   doscalls.obj main.obj parser.obj dosinit.obj iofmt.obj       &
+	   dostty.obj expand.obj $(_file_obj) win95.obj misc.obj        &
+	   env.obj error.obj cmds.obj screenio.obj batch.obj            &
+	   dircmds.obj filecmds.obj syscmds.obj doscmds.obj select.obj  &
+	   window.obj listall.obj lines.obj                             &
+	   inout.obj dosutil.obj eval.obj bcd.obj keyparse.obj          &
+	   tokens.obj umbreg.obj compdrv.obj strmenc.obj wrapper.obj
+
+4dos.com : $(4dosobjs) 4dostart.lib 4dos.wlk apprel.exe
+    $(link) $(lflags) name $@ @4dos.wlk file { $(4dosobjs) }
+    apprel $@ 0
+
+cstrt086.obj : cstrt086.asm
+    wasm -bt=DOS -mm -0 -I..\h $[@
+
+apprel.exe : apprel.c
+    wcl -zq -ml $<
+
+# Clean target
+
+clean : .symbolic
+    @if exist *.obj del *.obj
+    @if exist *.lib del *.lib
+    @if exist *.com del *.com
+    @if exist *.exe del *.exe
+    @if exist *.bak del *.bak
+    @if exist *.err del *.err
+    @if exist *.map del *.map
diff -Nu d:7.501/md5.h SOURCES/md5.h
--- d:7.501/md5.h	1970-01-01 02:00:00 +0200
+++ SOURCES/md5.h	2007-10-27 09:37:30 +0200
@@ -0,0 +1,10 @@
+typedef unsigned long int UINT4;// 4-byte word
+typedef struct {		// MD5 context
+  UINT4 state[4];		// state (ABCD)
+  UINT4 count[2];		// number of bits, modulo 2^64 (LSB first)
+  unsigned char buffer[64];	// input buffer
+} MD5_CTX;
+
+void MD5Init (MD5_CTX *);
+void MD5Update (MD5_CTX *, const unsigned char _far *, unsigned int);
+void MD5Final (unsigned char [16], MD5_CTX *);
diff -Nu d:7.501/md5c.c SOURCES/md5c.c
--- d:7.501/md5c.c	1970-01-01 02:00:00 +0200
+++ SOURCES/md5c.c	2007-10-27 08:08:28 +0200
@@ -0,0 +1,251 @@
+/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
+   Copyright (C) 1991, RSA Data Security, Inc. All rights reserved.
+
+   License to copy and use this software is granted provided that it
+   is identified as the "RSA Data Security, Inc. MD5 Message-Digest
+   Algorithm" in all material mentioning or referencing this software
+   or this function.
+
+   License is also granted to make and use derivative works provided
+   that such works are identified as "derived from the RSA Data
+   Security, Inc. MD5 Message-Digest Algorithm" in all material
+   mentioning or referencing the derived work.
+
+   RSA Data Security, Inc. makes no representations concerning either
+   the merchantability of this software or the suitability of this
+   software for any particular purpose. It is provided "as is"
+   without express or implied warranty of any kind.
+
+   These notices must be retained in any copies of any part of this
+   documentation and/or software.
+ */
+
+#include <string.h>
+#include "md5.h"
+
+/* Constants for MD5Transform routine.
+ */
+#define S11 7
+#define S12 12
+#define S13 17
+#define S14 22
+#define S21 5
+#define S22 9
+#define S23 14
+#define S24 20
+#define S31 4
+#define S32 11
+#define S33 16
+#define S34 23
+#define S41 6
+#define S42 10
+#define S43 15
+#define S44 21
+
+static void MD5Transform(UINT4 [4], const unsigned char _far [64]);
+
+static unsigned char PADDING[64] = {
+  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/* F, G, H and I are basic MD5 functions.
+ */
+#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
+#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
+#define H(x, y, z) ((x) ^ (y) ^ (z))
+#define I(x, y, z) ((y) ^ ((x) | (~z)))
+
+/* ROTATE_LEFT rotates x left n bits.
+ */
+#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
+
+/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
+   Rotation is separate from addition to prevent recomputation.
+ */
+#define FF(a, b, c, d, x, s, ac) { \
+    (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
+    (a) = ROTATE_LEFT ((a), (s)); \
+    (a) += (b); \
+  }
+#define GG(a, b, c, d, x, s, ac) { \
+    (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
+    (a) = ROTATE_LEFT ((a), (s)); \
+    (a) += (b); \
+  }
+#define HH(a, b, c, d, x, s, ac) { \
+    (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
+    (a) = ROTATE_LEFT ((a), (s)); \
+    (a) += (b); \
+  }
+#define II(a, b, c, d, x, s, ac) { \
+    (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
+    (a) = ROTATE_LEFT ((a), (s)); \
+    (a) += (b); \
+  }
+
+/* MD5 initialization. Begins an MD5 operation, writing a new context.
+ */
+void MD5Init(MD5_CTX *context)
+{
+  context->count[0] = context->count[1] = 0;
+
+  /* Load magic initialization constants.
+   */
+  context->state[0] = 0x67452301;
+  context->state[1] = 0xefcdab89;
+  context->state[2] = 0x98badcfe;
+  context->state[3] = 0x10325476;
+}
+
+/* MD5 block update operation. Continues an MD5 message-digest operation,
+     processing another message block, and updating the context.
+ */
+void MD5Update(MD5_CTX *context, const unsigned char _far *input, unsigned int inputLen)
+{
+  unsigned int i, index, partLen;
+
+  /* Compute number of bytes mod 64 */
+  index = (unsigned int)((context->count[0] >> 3) & 0x3F);
+
+  /* Update number of bits */
+  if ((context->count[0] += ((UINT4)inputLen << 3)) < ((UINT4)inputLen << 3))
+    context->count[1]++;
+  context->count[1] += ((UINT4)inputLen >> 29);
+
+  partLen = 64 - index;
+
+  /* Transform as many times as possible.
+   */
+  if (inputLen >= partLen) {
+    _fmemcpy(&context->buffer[index], input, partLen);
+    MD5Transform(context->state, context->buffer);
+
+    for (i = partLen; i + 63 < inputLen; i += 64)
+      MD5Transform(context->state, &input[i]);
+
+    index = 0;
+  }
+  else
+    i = 0;
+
+  /* Buffer remaining input */
+  _fmemcpy(&context->buffer[index], &input[i], inputLen-i);
+}
+
+/* MD5 finalization. Ends an MD5 message-digest operation, writing the
+     the message digest and zeroizing the context.
+ */
+void MD5Final(unsigned char digest[16], MD5_CTX *context)
+{
+  unsigned char bits[8];
+  unsigned int index, padLen;
+
+  /* Save number of bits */
+  memcpy(bits, context->count, 8);
+
+  /* Pad out to 56 mod 64.
+   */
+  index = (unsigned int)((context->count[0] >> 3) & 0x3F);
+  padLen = (index < 56) ? (56 - index) : (120 - index);
+  MD5Update(context, PADDING, padLen);
+
+  /* Append length (before padding) */
+  MD5Update(context, bits, 8);
+
+  /* Store state in digest */
+  memcpy(digest, context->state, 16);
+
+  /* Zeroize sensitive information. */
+  memset((void *)context, 0, sizeof(*context));
+}
+
+/* MD5 basic transformation. Transforms state based on block.
+ */
+static void MD5Transform(UINT4 state[4], const unsigned char _far block[64])
+{
+  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];
+
+  _fmemcpy(x, block, 64);
+
+  /* Round 1 */
+  FF ( a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
+  FF ( d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
+  FF ( c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
+  FF ( b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
+  FF ( a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
+  FF ( d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
+  FF ( c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
+  FF ( b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
+  FF ( a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
+  FF ( d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
+  FF ( c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
+  FF ( b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
+  FF ( a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
+  FF ( d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
+  FF ( c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
+  FF ( b, c, d, a, x[15], S14, 0x49b40821); /* 16 */
+
+  /* Round 2 */
+  GG ( a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
+  GG ( d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
+  GG ( c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
+  GG ( b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
+  GG ( a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
+  GG ( d, a, b, c, x[10], S22, 0x02441453); /* 22 */
+  GG ( c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
+  GG ( b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
+  GG ( a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
+  GG ( d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
+  GG ( c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
+  GG ( b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
+  GG ( a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
+  GG ( d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
+  GG ( c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
+  GG ( b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
+
+  /* Round 3 */
+  HH ( a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
+  HH ( d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
+  HH ( c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
+  HH ( b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
+  HH ( a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
+  HH ( d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
+  HH ( c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
+  HH ( b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
+  HH ( a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
+  HH ( d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
+  HH ( c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
+  HH ( b, c, d, a, x[ 6], S34, 0x04881d05); /* 44 */
+  HH ( a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
+  HH ( d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
+  HH ( c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
+  HH ( b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */
+
+  /* Round 4 */
+  II ( a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
+  II ( d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
+  II ( c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
+  II ( b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
+  II ( a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
+  II ( d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
+  II ( c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
+  II ( b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
+  II ( a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
+  II ( d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
+  II ( c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
+  II ( b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
+  II ( a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
+  II ( d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
+  II ( c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
+  II ( b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */
+
+  state[0] += a;
+  state[1] += b;
+  state[2] += c;
+  state[3] += d;
+
+  /* Zeroize sensitive information. */
+  memset((void *)x, 0, sizeof(x));
+}
diff -Nu d:7.501/mdef.inc SOURCES/mdef.inc
--- d:7.501/mdef.inc	1970-01-01 02:00:00 +0200
+++ SOURCES/mdef.inc	2006-11-28 19:25:00 +0200
@@ -0,0 +1,358 @@
+;*****************************************************************************
+;*
+;*                            Open Watcom Project
+;*
+;*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
+;*
+;*  ========================================================================
+;*
+;*    This file contains Original Code and/or Modifications of Original
+;*    Code as defined in and that are subject to the Sybase Open Watcom
+;*    Public License version 1.0 (the 'License'). You may not use this file
+;*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
+;*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
+;*    provided with the Original Code and Modifications, and is also
+;*    available at www.sybase.com/developer/opensource.
+;*
+;*    The Original Code and all software distributed under the License are
+;*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+;*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
+;*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
+;*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
+;*    NON-INFRINGEMENT. Please see the License for the specific language
+;*    governing rights and limitations under the License.
+;*
+;*  ========================================================================
+;*
+;* Description:  Memory model setup for interfacing with C code.
+;*
+;*****************************************************************************
+
+
+_SMALL_CODE     =       00h
+_BIG_CODE       =       01h
+_SMALL_DATA     =       00h
+_BIG_DATA       =       02h
+_HUGE_DATA      =       04h
+_LONG_INTS      =       08h
+
+_USE_32_SEGS    =       10h
+_386            =       10h     ; from old clib
+
+_DS_PEGGED      =       20h     ; from old clib (used for Windows)
+_TINY           =       40h     ; from old clib (formerly 10h)
+
+_FLAT           =       ( _SMALL_CODE or _SMALL_DATA or _USE_32_SEGS )
+_SMALL          =       ( _SMALL_CODE or _SMALL_DATA )
+_COMPACT        =       ( _SMALL_CODE or _BIG_DATA )
+_MEDIUM         =       ( _BIG_CODE   or _SMALL_DATA )
+_LARGE          =       ( _BIG_CODE   or _BIG_DATA )
+_HUGE           =       ( _BIG_CODE   or _HUGE_DATA )
+
+_EMULATION      =       00h
+_8087           =       01h
+
+ifdef __WASM__
+    ifdef __FLAT__
+        _MODEL = _FLAT
+    endif
+    ifdef __SMALL__
+        _MODEL = _SMALL
+    endif
+    ifdef __COMPACT__
+        _MODEL = _COMPACT
+    endif
+    ifdef __MEDIUM__
+        _MODEL = _MEDIUM
+    endif
+    ifdef __LARGE__
+        _MODEL = _LARGE
+    endif
+    ifdef __HUGE__
+        _MODEL = _HUGE
+    endif
+    ifdef __386__
+        _MODEL = ( _MODEL or _USE_32_SEGS )
+    endif
+    ifdef __WINDOWS__
+        if _MODEL and (_BIG_DATA or _HUGE_DATA)
+            _MODEL = ( _MODEL or _DS_PEGGED )
+        endif
+    endif
+    ifdef __FPC__
+        _MATH = _EMULATION
+    endif
+    ifdef __FPI__
+        _MATH = _8087
+    endif
+    ifdef __FPI87__
+        _MATH = _8087
+    endif
+else
+include         .\model.inc     ; defines _MODEL, _MATH symbols
+endif
+
+if _MODEL and _BIG_CODE
+
+modstart        macro   modname,alignment
+ifdef NDEBUG
+                name    modname
+endif
+                ifb <alignment>
+_TEXT           segment word public 'CODE'
+                else
+_TEXT           segment alignment public 'CODE'
+                endif
+                assume  cs:_TEXT
+                endm
+
+calli           macro   regname
+                call    dword ptr [regname]
+                endm
+
+codeptr         macro   p1,p2
+                ifb <p2>
+                extrn p1 : dword
+                else
+                extrn "&p1",p2 : dword
+                endif
+                endm
+
+docall          macro   dest
+                call    far ptr dest
+                endm
+
+dojmp           macro   dest
+                jmp     far ptr dest
+                endm
+
+defp            macro   dsym,exp
+         dsym   proc    far exp
+                endm
+
+defpe           macro   dsym
+                ifdef _EXPORT
+         dsym   proc    far export
+                else
+         dsym   proc    far
+                endif
+                endm
+
+defn            macro   dsym
+         dsym   proc    near
+                endm
+
+endproc         macro   dsym
+         dsym   endp
+                endm
+
+epilog          macro
+                if _MODEL and _USE_32_SEGS
+                    pop     EBP
+                    dec     EBP
+                    mov     ESP,EBP
+                else
+                    pop     BP
+                    dec     BP
+                endif
+                endm
+
+prolog          macro
+                if _MODEL and _USE_32_SEGS
+                    inc     EBP
+                    push    EBP
+                    mov     EBP,ESP
+                else
+                    inc     BP
+                    push    BP
+                    mov     BP,SP
+                endif
+                endm
+
+xdefp           macro   p1,p2
+                ifb <p2>
+                public p1
+                else
+                public "&p1",p2
+                endif
+                endm
+
+xref            macro   p1,p2
+                ifb <p2>
+                extrn `p1` : far
+                else
+                extrn "&p1",`p2` : far
+                endif
+                endm
+
+lcall           macro   dest
+                push    cs
+                call    near ptr dest
+                endm
+
+else
+
+modstart        macro   modname,alignment
+ifdef NDEBUG
+                name    modname
+endif
+                if _MODEL and _USE_32_SEGS
+_TEXT               segment use32 alignment public 'CODE'
+                else
+_TEXT               segment alignment public 'CODE'
+                endif
+                assume  cs:_TEXT
+                endm
+
+calli           macro   regname
+                call    regname
+                endm
+
+codeptr         macro   p1,p2
+                if _MODEL and _USE_32_SEGS
+                    ifb <p2>
+                    extrn p1 : dword
+                    else
+                    extrn "&p1",p2 : dword
+                    endif
+                else
+                    ifb <p2>
+                    extrn p1 : word
+                    else
+                    extrn "&p1",p2 : word
+                    endif
+                endif
+                endm
+
+defn            macro   dsym
+         dsym   proc    near
+                endm
+
+defp            macro   dsym,exp
+         dsym   proc    near exp
+                endm
+
+defpe           macro   dsym
+                ifdef _EXPORT
+         dsym       proc    near export
+                else
+         dsym       proc    near
+                endif
+                endm
+
+docall          macro   dest
+                call    dest
+                endm
+
+dojmp           macro   dest
+                jmp     dest
+                endm
+
+endproc         macro   dsym
+         dsym   endp
+                endm
+
+epilog          macro
+                if _MODEL and _USE_32_SEGS
+                    pop     EBP
+                else
+                    pop     BP
+                endif
+                endm
+
+prolog          macro
+                if _MODEL and _USE_32_SEGS
+                    push    EBP
+                    mov     EBP,ESP
+                else
+                    push    BP
+                    mov     BP,SP
+                endif
+                endm
+
+xdefp           macro   p1,p2
+                ifb <p2>
+                public p1
+                else
+                public "&p1",p2
+                endif
+                endm
+
+xref            macro   p1,p2
+                ifb <p2>
+                extrn `p1` : near
+                else
+                extrn "&p1",`p2` : near
+                endif
+                endm
+
+lcall           macro   dest
+                call    dest
+                endm
+
+endif
+
+endmod          macro
+_TEXT           ends
+                endm
+
+dataseg         macro
+DGROUP          group _DATA
+assume          ds:DGROUP,ss:DGROUP
+                if _MODEL and _USE_32_SEGS
+_DATA               segment use32 dword public 'DATA'
+                else
+_DATA               segment word public 'DATA'
+                endif
+                endm
+datasegment     macro
+                dataseg ; should be phased out
+                endm
+
+enddata         macro
+_DATA   ends
+                endm
+
+bss_segment     macro
+                if _MODEL and _USE_32_SEGS
+_BSS                segment use32 dword public 'BSS'
+                else
+_BSS                segment word public 'BSS'
+                endif
+DGROUP          group _BSS
+                assume  ds:DGROUP
+                endm
+
+endbss          macro
+_BSS            ends
+                endm
+
+alias_function  macro   alias, function
+                ifb <function>
+                    xref    "C",_&alias
+                else
+                    xref    "C",function
+                endif
+                .code
+                public      "C",`alias`
+                ifdef _EXPORT
+         `alias`    proc    export
+                else
+         `alias`    proc
+                endif
+                ifb <function>
+                    jmp     _&alias
+                else
+                    jmp     `function`
+                endif
+         `alias`    endp
+                endm
+
+xred            macro   p1,p2,p3
+                ifb <p3>
+                extrn p1 : p2
+                else
+                extrn "&p1",p2 : p3
+                endif
+                endm
+
diff -Nu d:7.501/message.h SOURCES/message.h
--- d:7.501/message.h	2006-11-12 16:00:50 +0200
+++ SOURCES/message.h	2009-02-27 09:49:54 +0200
@@ -50,6 +50,7 @@
 #define LIST_HIBIT_CHAR _TEXT('H')
 #define LIST_EDITOR_CHAR _TEXT('E')
 #define LIST_INFO_CHAR _TEXT('I')
+#define LIST_LINENUMB_CHAR _TEXT('L')
 #define LIST_FIND_NEXT_CHAR _TEXT('N')
 #define LIST_FIND_NEXT_CHAR_REVERSE 14
 #define LIST_OPEN_CHAR _TEXT('O')
@@ -193,10 +194,26 @@
 };
 
 
+TCHAR *lmontbl[] = {
+	_TEXT("January"),
+	_TEXT("February"),
+	_TEXT("March"),
+	_TEXT("April"),
+	_TEXT("May"),
+	_TEXT("June"),
+	_TEXT("July"),
+	_TEXT("August"),
+	_TEXT("September"),
+	_TEXT("October"),
+	_TEXT("November"),
+	_TEXT("December")
+};
+
+
 TCHAR *dateformat[] = {
-	_TEXT("mm-dd-[yy]yy"),		// USA date format
-	_TEXT("dd-mm-[yy]yy"),		// Europe
-	_TEXT("[yy]yy-mm-dd")		// Japan
+	_TEXT("mm%cdd%c[yy]yy"),	// USA date format
+	_TEXT("dd%cmm%c[yy]yy"),	// Europe
+	_TEXT("[yy]yy%cmm%cdd")		// Japan
 };
 
 
@@ -295,14 +312,19 @@
 	_TEXT("Clipboard is not text format"),
 	_TEXT("Already excluded files"),
 	_TEXT("No functions defined"),
-	_TEXT("Not a function"),
+	_TEXT("Not a function"),			// 50
 
-	"KSTACK.COM not loaded",
-	"Invalid DOS version",
-	"Not in swapping mode",
-	"No UMBs; loading low",
-	"Syntax error in region number or size",
+	_TEXT("KSTACK.COM not loaded"),
+	_TEXT("Invalid DOS version"),
+	_TEXT("Not in swapping mode"),
+	_TEXT("No UMBs; loading low"),
+	_TEXT("Syntax error in region number or size"),
+	_TEXT("Can't eject media"),
+	_TEXT("Can't close tray"),
+	_TEXT("IDLE is disabled")
 
+#if _WIN
+	,
 	_TEXT("Error in command-line directive"),
 	_TEXT("Window title not found"),
 	_TEXT("Command not supported in this OS version"),
@@ -319,12 +341,13 @@
 	_TEXT("No SMTP user address"),
 	_TEXT("Can't end current process"),
 	_TEXT("Can't query key type")
+#endif
 };
 
 
 // USAGE messages
 TCHAR ALIAS_USAGE[] = _TEXT("ALIAS [/P /R ?] name=value");
-TCHAR ATTRIB_USAGE[] = _TEXT("ATTRIB [/A:-rhsda /D /E /I /P /Q /S] [+|-AHRS] ?...");
+TCHAR ATTRIB_USAGE[] = _TEXT("ATTRIB [/A:-rhsda /D /E /I /N /P /Q /S] [+|-AHRS] ?...");
 TCHAR BEEP_USAGE[] = _TEXT("BEEP [frequency duration]");
 TCHAR BREAK_USAGE[] = _TEXT("BREAK [ON | OFF]");
 TCHAR CALL_USAGE[] = _TEXT("CALL ?");
@@ -349,13 +372,14 @@
 TCHAR GLOBAL_USAGE[] = _TEXT("GLOBAL [/H /I /P /Q] ...");
 TCHAR HEAD_USAGE[] = _TEXT("HEAD [/A:-rhsda /Cn /I /Nn /P /Q /V] ?...");
 TCHAR HISTORY_USAGE[] = _TEXT("HISTORY [/A /F /P /R ?]");
+TCHAR IDLE_USAGE[] = _TEXT("IDLE [ON | OFF]");
 TCHAR IF_USAGE[] = _TEXT("IF [/I] [NOT] condition ...");
 TCHAR IFF_USAGE[] = _TEXT("IFF [NOT] condition THEN ^ ... [ELSE[IFF] ^ ...] ENDIFF");
 TCHAR INKEY_USAGE[] = _TEXT("INKEY [/CDMPX /K\"mask\" /Wn] [text] %%var");
 TCHAR INPUT_USAGE[] = _TEXT("INPUT [/CDENPX /Ln /Wn] [text] %%var");
 TCHAR KEYBD_USAGE[] = _TEXT("KEYBD [/Cn /Nn /Sn]");
 TCHAR KEYSTACK_USAGE[] = _TEXT("KEYSTACK [\"text\"] [n] [/Wn] [!]");
-TCHAR LIST_USAGE[] = _TEXT("LIST [/A:-rhsda /T\"text\" /HIRSWX] ?...");
+TCHAR LIST_USAGE[] = _TEXT("LIST [/A:-rhsda /Ln /T\"text\" /HINRSWX] ?...");
 TCHAR LOADBTM_USAGE[] = _TEXT("LOADBTM [ON | OFF]");
 TCHAR LFNFOR_USAGE[] = _TEXT("LFNFOR [ON | OFF]");
 TCHAR LOADHIGH_USAGE[] = _TEXT("LOADHIGH [/L:r1,n1;r2,n2;... /S] ?");
@@ -365,22 +389,25 @@
 TCHAR ON_USAGE[] = _TEXT("ON [BREAK | ERROR | ERRORMSG] ...");
 TCHAR POPD_USAGE[] = _TEXT("POPD [*]");
 TCHAR RD_USAGE[] = _TEXT("RD [/I] ~...");
-TCHAR REBOOT_USAGE[] = _TEXT("REBOOT [/C /V]");
+TCHAR REBOOT_USAGE[] = _TEXT("REBOOT [/C /M /P /S /V]");
 TCHAR RENAME_USAGE[] = _TEXT("REN [/A:-rhsda /EINPQST] ?... ?");
 TCHAR SCREEN_USAGE[] = _TEXT("SCREEN row col [text]");
 TCHAR SCRPUT_USAGE[] = _TEXT("SCRPUT row col # text");
 TCHAR VSCRPUT_USAGE[] = _TEXT("VSCRPUT row col # text");
 TCHAR SELECT_USAGE[] = _TEXT("SELECT [/A:-rhsda /C[hp] /1DEHIJLTXZ /O:-cdeginrsu /T:acw] ... (?) ...");
-TCHAR SET_USAGE[] = _TEXT("SET [/AMPR ?] name=value");
+TCHAR SETERROR_USAGE[] = _TEXT("SETERROR errorlevel");;
+TCHAR SET_USAGE[] = _TEXT("SET [/AEMPR ?] name=value");
 TCHAR SWAPPING_USAGE[] = _TEXT("SWAPPING [ON | OFF]");
 TCHAR TAIL_USAGE[] = _TEXT("TAIL [/A:-rhsda /Cn /I /Nn /P /Q /V] ?...");
 TCHAR TEE_USAGE[] = _TEXT("TEE [/A] ?...");
 TCHAR TIME_USAGE[] = _TEXT("TIME [/T] [hh:mm:ss]");
-TCHAR TIMER_USAGE[] = _TEXT("TIMER [/123S] [ON | OFF]");
+TCHAR TIMER_USAGE[] = _TEXT("TIMER [/123QS] [ON | OFF]");
+TCHAR TITLE_USAGE[] = _TEXT("TITLE title");
 TCHAR TOUCH_USAGE[] = _TEXT("TOUCH [/A:-rhsda /C /E /F /I /Q /S /R[:acw]? /D[acw]date /T[acw]time] ?...");
+TCHAR TRANSIENT_USAGE[] = _TEXT("TRANSIENT [ON | OFF]");
 TCHAR TREE_USAGE[] = _TEXT("TREE [/A /B /F /H /P /S /T[acw]] dir...");
 TCHAR TRUENAME_USAGE[] = _TEXT("TRUENAME ?");
-TCHAR TYPE_USAGE[] = _TEXT("TYPE [/A:-rhsda /ILP] ?...");
+TCHAR TYPE_USAGE[] = _TEXT("TYPE [/A:-rhsda /ILPV] ?...");
 TCHAR UNALIAS_USAGE[] = _TEXT("UNALIAS [/Q /R] name...");
 TCHAR UNFUNCTION_USAGE[] = _TEXT("UNFUNCTION [/Q /R] name...");
 TCHAR UNSET_USAGE[] = _TEXT("UNSET [/M /Q /R ?] name...");
@@ -397,6 +424,7 @@
 TCHAR ECHO_IS[] = _TEXT("ECHO is %s\r\n");
 TCHAR LOADBTM_IS[] = _TEXT("LOADBTM is %s\r\n");
 TCHAR PAUSE_PAGE_PROMPT[] = _TEXT("Press ESC to quit or another key to continue...");
+TCHAR PAUSE_PAGE_CLEAR[] = _TEXT("\r                                               \r");
 TCHAR PAUSE_PROMPT[] = _TEXT("Press any key when ready...");
 TCHAR DO_DO[] = _TEXT("do");
 TCHAR DO_BY[] = _TEXT("by");
@@ -429,6 +457,7 @@
 TCHAR LT[] = _TEXT("LT");
 TCHAR LE[] = _TEXT("LE");
 TCHAR NE[] = _TEXT("NE");
+TCHAR EQC[] = _TEXT("EQC");
 
 TCHAR THEN[] = _TEXT("then");
 TCHAR IFF[] = _TEXT("iff");
@@ -454,7 +483,7 @@
 TCHAR DIR_BYTES_FREE[] = _TEXT("%15s bytes free");
 
 TCHAR DIR_TOTAL[] = _TEXT("    Total for:  %s");
-TCHAR DIR_LABEL[] =          _TEXT(" <DIR>   ");
+TCHAR DIR_LABEL[] =          _TEXT(" <DIR>    ");
 TCHAR DIR_PERCENT_RATIO[] = _TEXT("  %2d%%");
 
 TCHAR DIR_RATIO[] = _TEXT("  %2d.%d to 1.0");
@@ -483,7 +512,10 @@
 TCHAR KBD_CAPS_LOCK[] = _TEXT("Caps=%s\r\n");
 TCHAR KBD_NUM_LOCK[] = _TEXT("Num=%s\r\n");
 TCHAR KBD_SCROLL_LOCK[] = _TEXT("Scroll=%s\r\n");
+TCHAR ENTER_STANDBY[] = _TEXT("Confirm system standby");
+TCHAR TURN_MONITOR_OFF[] = _TEXT("Confirm monitor shutdown");
 TCHAR REBOOT_IT[] = _TEXT("Confirm system reboot");
+TCHAR SHUT_IT_DOWN[] = _TEXT("Confirm system shutdown");
 TCHAR TOTAL_ENVIRONMENT[] = _TEXT("\r\n%15Lu bytes total environment\r\n");
 
 TCHAR TOTAL_ALIAS[] = _TEXT("\r\n%15Lu characters total alias\r\n");
@@ -542,7 +574,7 @@
 TCHAR SET_PROGRAM[] = _TEXT("4DOS %u%c%02u");
 TCHAR *DOS_NAME = _TEXT("4DOS.COM");
 TCHAR *SHORT_NAME = _TEXT("4DOS");
-TCHAR FOURDOS_REV[] = _TEXT("4DOS Build %u");
+TCHAR FOURDOS_REV[] = _TEXT("4DOS Build %u (%s)");
 
 TCHAR DOS_VERSION[] = _TEXT("\r\n%s   %s %u%c%02u\r\n");
 TCHAR COMSPEC_DOS[] = _TEXT("%s=%Fs");
@@ -550,14 +582,25 @@
 TCHAR MS98VER[] = _TEXT("(Win98) DOS");
 TCHAR MSMEVER[] = _TEXT("(WinME) DOS");
 
-TCHAR MSVER[] = _TEXT("DOS");
+TCHAR UNKVER[] = _TEXT("DOS");
+TCHAR MSVER[] = _TEXT("MS-DOS");
+TCHAR LZVER[] = _TEXT("LZ-DOS");
 TCHAR OS2VER[] = _TEXT("OS/2");
 TCHAR WARPVER[] = _TEXT("OS/2 Warp");
 TCHAR DRVER[] = _TEXT("DR DOS");
 TCHAR NOVVER[] = _TEXT("Novell DOS");
-TCHAR DOS_REVISION[] = _TEXT("   DOS Revision %c");
-TCHAR OS2_REVISION[] = _TEXT("   OS/2 Revision %u");
-TCHAR DOS_LOCATION[] = _TEXT("\r\nDOS is in %s");
+TCHAR IBMVER[] = _TEXT("PC DOS");
+TCHAR WENVER[] = _TEXT("Wendin-DOS");
+TCHAR XDVER[] = _TEXT("X-DOS");
+TCHAR FDVER[] = _TEXT("FreeDOS");
+TCHAR RDVER[] = _TEXT("ROM-DOS");
+TCHAR GSVER[] = _TEXT("DOS-ROM");
+TCHAR RXVER[] = _TEXT("RXDOS");
+TCHAR SDVER[] = _TEXT("S/DOS");
+TCHAR PTSVER[] = _TEXT("PTS-DOS");
+TCHAR DOS_REVISION[] = _TEXT("\r\nDOS Revision %c");
+TCHAR OS2_REVISION[] = _TEXT("\r\nOS/2 Revision %u");
+TCHAR DOS_LOCATION[] = _TEXT("; DOS is in %s");
 TCHAR DOS_HMA[] = _TEXT("HMA");
 TCHAR DOS_ROM[] = _TEXT("ROM");
 TCHAR DOS_LOW[] = _TEXT("low memory");
@@ -580,6 +623,7 @@
 
 TCHAR MONO_MONITOR[] = _TEXT("mono");
 TCHAR COLOR_MONITOR[] = _TEXT("color");
+TCHAR SVGA_TYPE[] = _TEXT("svga");
 
 TCHAR END_OF_FILE_STR[] = _TEXT("**EOF**");
 
@@ -603,32 +647,44 @@
 	_TEXT("4ver"),			// 4DOS / 4NT / TC32 version
 	_TEXT("?"),			// return code of previous internal command
 	_TEXT("alias"),			// free alias space
+	_TEXT("alt"),			// Alt key depressed
 	_TEXT("ansi"),			// ANSI driver loaded
 	_TEXT("apmac"),			// APM AC line status
 	_TEXT("apmbatt"),		// APM battery status
 	_TEXT("apmlife"),		// APM remaining battery life
+	_TEXT("append"),		// APPEND loaded (0 or 1)
+	_TEXT("assign"),		// ASSIGN loaded (0, 1 or -1)
 	_TEXT("batch"),			// batch nesting level
 	_TEXT("batchline"),		// line # in current batch file
 	_TEXT("batchname"),		// name of current batch file
+	_TEXT("batchtype"),		// type of current batch file
+	_TEXT("bdebugger"),		// batch debugger active
 	_TEXT("bg"),			// background color at cursor
 	_TEXT("boot"),			// boot drive
 	_TEXT("build"),			// internal 4DOS / 4NT / TC32 build number
+	_TEXT("capslock"),		// CapsLock on
+	_TEXT("cdroms"),		// list of CD-ROM drives
 	_TEXT("ci"),			// insert cursor shape
 	_TEXT("cmdline"),		// current (partial?) command line
 	_TEXT("cmdproc"),		// command processor
+	_TEXT("cmdspec"),		// command processor full pathname
 	_TEXT("co"),			// overstrike cursor shape
 	_TEXT("codepage"),		// active codepage
 	_TEXT("column"),		// current column position
 	_TEXT("columns"),		// # of columns on active display
 	_TEXT("country"),		// country code
 	_TEXT("cpu"),			// cpu type
+	_TEXT("cpuspeed"),		// cpu speed [MHz] (586+)
+	_TEXT("ctrl"),			// Ctrl key depressed
 	_TEXT("cwd"),			// current working directory
 	_TEXT("cwds"),			// current working directory with trailing '\'
 	_TEXT("cwp"),			// current working path
 	_TEXT("cwps"),			// current working path with trailing '\'
 	_TEXT("date"),			// current date
+	_TEXT("datetime"),		// current date and time, yyyyMMddhhmmss
 	_TEXT("day"),			// current day
 	_TEXT("disk"),			// current disk
+	_TEXT("display"),		// DISPLAY.SYS loaded (0 or 1)
 	_TEXT("dname"),			// description file name
 	_TEXT("dos"),			// OS type
 	_TEXT("dosver"),		// OS version #
@@ -637,36 +693,103 @@
 	_TEXT("dowi"),			// day of week as integer
 	_TEXT("doy"),			// day of year (1 - 366)
 	_TEXT("dpmi"),			// DPMI version
+	_TEXT("driver"),		// DRIVER.SYS loaded (0, 1 or -1)
+	_TEXT("drives"),		// list of all available drives
+	_TEXT("dst"),			// daylight savings time in effect
 	_TEXT("dv"),			// DESQview loaded flag
 	_TEXT("echo"),			// ECHO state (batch or command line)
+	_TEXT("editmode"),		// current line editor state (0 or 1)
+	_TEXT("ega"),			// EGA.SYS loaded (0, 1 or -1)
 	_TEXT("env"),			// free environment space
+	_TEXT("execstr"),		// return code of the last @EXECSTR
+	_TEXT("expansion"),		// current expansion mode (SETDOS /X)
 	_TEXT("fg"),			// foreground color at cursor
+	_TEXT("fontpage"),		// active fontpage
+	_TEXT("graftabl"),		// GRAFTABL loaded (0, 1 or -1)
+	_TEXT("graphics"),		// GRAPHICS loaded (0 or 1)
+	_TEXT("hdrives"),		// list of hard (fixed) drives
 	_TEXT("hlogfile"),		// name of current history log file
 	_TEXT("hour"),			// current hour
 	_TEXT("idow"),			// international day (short name)
 	_TEXT("idowf"),			// international day (long name)
-	_TEXT("isodate"),		// yyyy/mm/dd (ISO format)
+	_TEXT("ininame"),		// pathname of the current INI file
+	_TEXT("isodate"),		// yyyy-mm-dd (ISO format)
+	_TEXT("isodowi"),		// day of week as integer (ISO)
+	_TEXT("isordate"),		// yyyy-ddd (ISO ordinal date format)
+	_TEXT("isowdate"),		// yyyy-Www-d (ISO week date format)
+	_TEXT("isoweek"),		// week of year (ISO)
+	_TEXT("isowyear"),		// year of ISO week date
 	_TEXT("kbhit"),			// != 0 if key is waiting
+	_TEXT("keystacked"),		// number of keystrokes in KSTACK buffer
 	_TEXT("kstack"),		// != 0 if KSTACK is loaded
+	_TEXT("lalt"),			// left Alt key depressed
+	_TEXT("lastdir"),		// previous directory
 	_TEXT("lastdisk"),		// last disk in use
+	_TEXT("lctrl"),			// left Ctrl key depressed
 	_TEXT("logfile"),		// name of current log file
+	_TEXT("lshift"),		// left Shift key depressed
+	_TEXT("machine"),		// machine name in the network
 	_TEXT("minute"),		// current minute
+	_TEXT("mjd"),			// modified Julian day
 	_TEXT("monitor"),		// monitor type (mono or color)
 	_TEXT("month"),			// current month
+	_TEXT("monthf"),		// current month (full name)
 	_TEXT("mouse"),			// mouse loaded (0 or 1)
+	_TEXT("mscdex"),		// MSCDEX loaded (0, 1 or -1)
 	_TEXT("ndp"),			// math coprocessor type
+	_TEXT("network"),		// network components installed
+	_TEXT("nlsfunc"),		// NLSFUNC installed (0, 1 or -1)
+	_TEXT("numlock"),		// NumLock on
 	_TEXT("pipe"),			// currently in a pipe (0 or 1)
+	_TEXT("power"),			// POWER loaded (0 or 1)
+	_TEXT("print"),			// PRINT loaded (0, 1 or -1)
+	_TEXT("ralt"),			// right Alt key depressed
+	_TEXT("rctrl"),			// right Ctrl key depressed
+	_TEXT("ready"),			// list of all ready drives
 	_TEXT("row"),			// current row
 	_TEXT("rows"),			// # of rows on active display
+	_TEXT("rshift"),		// right Shift key depressed
+	_TEXT("sbdsp"),			// SB DSP version
+	_TEXT("scrolllock"),		// ScrollLock on
 	_TEXT("second"),		// current second
-	_TEXT("selected"),		// selected text
+	_TEXT("share"),			// SHARE installed (0, 1 or -1)
 	_TEXT("shell"),			// shell level (0 - 99)
+	_TEXT("shift"),			// Shift key depressed
+	_TEXT("smartdrv"),		// SMARTDRV installed (0 or 1)
+	_TEXT("startpath"),		// startup directory of current shell
+	_TEXT("stderr"),		// standard error points to CON
+	_TEXT("stdin"),			// standard input points to CON
+	_TEXT("stdout"),		// standard output points to CON
+	_TEXT("stzn"),			// name of time zone for standard time
+	_TEXT("stzo"),			// offset in minutes from UTC for standard time
 	_TEXT("swapping"),		// current 4DOS swapping mode
 	_TEXT("syserr"),		// last system error #
+	_TEXT("sysreq"),		// SysReq key depressed
+	_TEXT("taskmax"),		// DR DOS TASKMAX or TASKMGR loaded
+	_TEXT("taskswitcher"),		// DOSSHELL task switcher present
+	_TEXT("tick"),			// BIOS clock ticks since midnight
 	_TEXT("time"),			// current time
 	_TEXT("transient"),		// transient or resident shell
+	_TEXT("tsc"),			// time stamp counter (586+ only)
+	_TEXT("tzn"),			// name of current time zone
+	_TEXT("tzo"),			// offset in minutes from UTC for current time zone
+	_TEXT("unixtime"),		// number of seconds since 1-1-1970
+	_TEXT("utcdate"),		// current UTC date
+	_TEXT("utcdatetime"),		// current UTC date and time
+	_TEXT("utchour"),		// current UTC hour
+	_TEXT("utcisodate"),		// current UTC date in ISO format
+	_TEXT("utcminute"),		// current UTC minute
+	_TEXT("utcsecond"),		// current UTC second
+	_TEXT("utctime"),		// current UTC time
+	_TEXT("v86"),			// CPU in V86 mode (386+ only)
+	_TEXT("vcpi"),			// VCPI version
+	_TEXT("vds"),			// VDS version
+	_TEXT("vermajor"),		// 4DOS major version
+	_TEXT("verminor"),		// 4DOS minor version
+	_TEXT("version"),		// 4DOS version in major.minor format
 	_TEXT("video"),			// video type (cga, mono, ega, vga)
 	_TEXT("win"),			// Windows loaded flag
+	_TEXT("winticks"),		// ms since midnight/Windows started
 	_TEXT("wintitle"),		// window title
 	_TEXT("year"),			// current year
 
@@ -675,25 +798,38 @@
 
 const TCHAR *FUNC_ARRAY[] = {
 	_TEXT("abs"),
+	_TEXT("agedate"),
 	_TEXT("alias"),
 	_TEXT("altname"),
 	_TEXT("ascii"),
 	_TEXT("attrib"),
+	_TEXT("average"),
 	_TEXT("caps"),
 	_TEXT("cdrom"),
+	_TEXT("ceiling"),
 	_TEXT("char"),
 	_TEXT("clip"),			// clipboard read
 	_TEXT("clipw"),			// clipboard paste
+	_TEXT("clustsize"),
+	_TEXT("codepage"),
+	_TEXT("com"),
 	_TEXT("comma"),
+	_TEXT("compare"),
 	_TEXT("convert"),
+	_TEXT("count"),
 	_TEXT("crc32"),
+	_TEXT("cwd"),
+	_TEXT("cwds"),
 	_TEXT("date"),
+	_TEXT("dateconv"),
 	_TEXT("day"),
+	_TEXT("ddcstr"),
 	_TEXT("dec"),
 	_TEXT("decimal"),
 	_TEXT("descript"),
 	_TEXT("device"),
 	_TEXT("digits"),
+	_TEXT("dirstack"),
 	_TEXT("diskfree"),
 	_TEXT("disktotal"),
 	_TEXT("diskused"),
@@ -702,6 +838,7 @@
 	_TEXT("dowf"),
 	_TEXT("dowi"),
 	_TEXT("doy"),			// day of year (1-366)
+	_TEXT("drivetype"),
 	_TEXT("ems"),
 	_TEXT("errtext"),
 	_TEXT("eval"),
@@ -711,12 +848,14 @@
 	_TEXT("ext"),
 	_TEXT("extended"),
 	_TEXT("field"),
+	_TEXT("fields"),
 	_TEXT("fileage"),
 	_TEXT("fileclose"),
 	_TEXT("filedate"),
 	_TEXT("filename"),
 	_TEXT("fileopen"),
 	_TEXT("fileread"),
+	_TEXT("filereadb"),
 	_TEXT("files"),
 	_TEXT("fileseek"),
 	_TEXT("fileseekl"),
@@ -727,9 +866,13 @@
 	_TEXT("findclose"),
 	_TEXT("findfirst"),
 	_TEXT("findnext"),
+	_TEXT("floor"),
 	_TEXT("format"),
+	_TEXT("fstype"),
 	_TEXT("full"),
 	_TEXT("function"),
+	_TEXT("hddsize"),
+	_TEXT("history"),
 	_TEXT("if"),
 	_TEXT("inc"),
 	_TEXT("index"),
@@ -738,7 +881,22 @@
 	_TEXT("insert"),
 	_TEXT("instr"),
 	_TEXT("int"),
+	_TEXT("isalnum"),
+	_TEXT("isalpha"),
+	_TEXT("isascii"),
+	_TEXT("iscntrl"),
+	_TEXT("isdigit"),
+	_TEXT("islower"),
+	_TEXT("isodowi"),
+	_TEXT("isoweek"),
+	_TEXT("isowyear"),
+	_TEXT("isprint"),
+	_TEXT("ispunct"),
+	_TEXT("isspace"),
+	_TEXT("isupper"),
+	_TEXT("isxdigit"),
 	_TEXT("label"),
+	_TEXT("lcs"),
 	_TEXT("left"),
 	_TEXT("len"),
 	_TEXT("lfn"),
@@ -746,17 +904,21 @@
 	_TEXT("lines"),
 	_TEXT("lower"),
 	_TEXT("lpt"),
+	_TEXT("ltrim"),
 	_TEXT("makeage"),
 	_TEXT("makedate"),
 	_TEXT("maketime"),
 	_TEXT("master"),
 	_TEXT("max"),
+	_TEXT("md5"),
 	_TEXT("min"),
 	_TEXT("month"),
+	_TEXT("monthf"),
 	_TEXT("mouse"),
 	_TEXT("name"),
 	_TEXT("numeric"),
 	_TEXT("path"),
+	_TEXT("quote"),
 	_TEXT("random"),
 	_TEXT("readscr"),
 	_TEXT("ready"),
@@ -764,17 +926,27 @@
 	_TEXT("removable"),
 	_TEXT("repeat"),
 	_TEXT("replace"),
+	_TEXT("reverse"),
 	_TEXT("right"),
+	_TEXT("rtrim"),
 	_TEXT("search"),
 	_TEXT("select"),
+	_TEXT("serial"),
 	_TEXT("sfn"),
+	_TEXT("sha1"),
+	_TEXT("similar"),
+	_TEXT("smbstr"),
 	_TEXT("strip"),
+	_TEXT("subst"),
 	_TEXT("substr"),
 	_TEXT("time"),
 	_TEXT("timer"),
 	_TEXT("trim"),
 	_TEXT("truename"),
+	_TEXT("truncate"),
 	_TEXT("unique"),
+	_TEXT("unquote"),
+	_TEXT("unquotes"),
 	_TEXT("upper"),
 	_TEXT("wild"),
 	_TEXT("word"),
@@ -825,10 +997,10 @@
 TCHAR LIST_GOTO_OFFSET[] = _TEXT("Hex Offset: ");
 TCHAR LIST_INFO_PIPE[] = _TEXT("LIST is displaying the output of a pipe.");
 
-TCHAR LIST_INFO_FAT[] = _TEXT("File:  %s\nDesc:  %.64s\nSize:  %Ld bytes\nDate:  %s\nTime:  %02u%c%02u\n");
-TCHAR LIST_INFO_LFN[] = _TEXT("File:        %s\nDescription: %.55s\nSize:        %Ld bytes\nLast Write:  %-8s  %02u%c%02u\nLast Access: %-8s  %02u%c%02u\nCreated:     %-8s  %02u%c%02u");
+TCHAR LIST_INFO_FAT[] = _TEXT("File:  %s\nDesc:  %.64s\nSize:  %Ld bytes\nDate:  %s\nTime:  %02u%c%02u%c%02u\n");
+TCHAR LIST_INFO_LFN[] = _TEXT("File:        %s\nDescription: %.55s\nSize:        %Ld bytes\nLast Write:  %-8s  %02u%c%02u%c%02u\nLast Access: %-8s  %02u%c%02u%c%02u\nCreated:     %-8s  %02u%c%02u%c%02u");
 
-TCHAR LIST_HEADER[] = _TEXT(" %-12.12s %c F1 Help %c Commands: BFGHINPWX %c");
+TCHAR LIST_HEADER[] = _TEXT(" %-12.12s %c F1 Help %c Commands: BFGHILNPWX %c");
 TCHAR LIST_LINE[] = _TEXT("Col %-3d  Line %-9Lu%3d%%");
 TCHAR LIST_WAIT[] = _TEXT("WAIT");
 TCHAR LIST_GOTO_TITLE[] = _TEXT(" Goto Line / Offset ");
@@ -836,6 +1008,7 @@
 TCHAR LIST_FIND_WAIT[] = _TEXT("Finding \"%.64s\"");
 TCHAR LIST_FIND_TITLE[] = _TEXT(" Find Text ");
 TCHAR LIST_FIND_TITLE_REVERSE[] = _TEXT(" Find Text (Reverse) ");
+TCHAR LIST_FIND_BTITLE_CASE[] = _TEXT(" Case-sensitive search ");
 TCHAR LIST_FIND_HEX[] = _TEXT("Hex search (Y/N)? ");
 TCHAR LIST_NOT_FOUND[] = _TEXT("Not found--press a key to continue ");
 TCHAR LIST_PRINT_TITLE[] = _TEXT(" Print ");
@@ -848,10 +1021,12 @@
 
 
 // MISC.C
+TCHAR NO_SEP[] = _TEXT("NO_SEP");
 TCHAR DESCRIPTION_FILE[144] = _TEXT("DESCRIPT.ION");
 TCHAR DESCRIPTION_SCAN[] = _TEXT("%*[ ,\t]%511[^\r\n\004\032]");
 TCHAR CONSOLE[] = _TEXT("CON");
 TCHAR DEV_CONSOLE[] = _TEXT("\\DEV\\CON");
+LPTSTR PRINTERS[] = { _TEXT("PRN"), _TEXT("LPT1"), _TEXT("LPT2"), _TEXT("LPT3"), _TEXT("\\DEV\\PRN"), _TEXT("\\DEV\\LPT1"), _TEXT("\\DEV\\LPT2"), _TEXT("\\DEV\\LPT3") };
 TCHAR YES_NO[] = _TEXT("Y/N");
 TCHAR YES_NO_ALL[] = _TEXT("Y/N/A/R");
 TCHAR BRIGHT[] = _TEXT("Bri ");
@@ -880,7 +1055,7 @@
 
 // SELECT.C
 TCHAR SELECT_HEADER[] = _TEXT("     chars %c Cursor keys select %c +Mark  -Clear %c ENTER to run %c");
-TCHAR MARKED_FILES[] = _TEXT("  Marked: %4u files  %4LuK");
+TCHAR MARKED_FILES[] = _TEXT("  Marked: %4u files  %9LuK");
 TCHAR SELECT_PAGE_COUNT[] = _TEXT("Page %2u of %2u");
 
 
@@ -898,6 +1073,7 @@
 TCHAR LBYTES_FREE[] = _TEXT("%15Lu bytes free\r\n");
 
 TCHAR CODE_PAGE[] = _TEXT("Active code page: %u\r\n");
+TCHAR COUNTRY_CODE[] = _TEXT("Current country code: %u\r\n");
 
 TCHAR LOG_IS[] = _TEXT("LOG (%s) is %s\r\n");
 
@@ -905,7 +1081,7 @@
 TCHAR LFNFOR_IS[] = _TEXT("LFNFOR is %s\r\n");
 
 TCHAR VERIFY_IS[] = _TEXT("VERIFY is %s\r\n");
-
+TCHAR IDLE_IS[] = _TEXT("IDLE detection is %s\r\n");
 
 TCHAR SETDOS_IS[] = _TEXT("ANSI=%d\r\nBRIGHTBG=%d\r\nCOMPOUND=%c\r\nDESCRIPTIONS=%u  (%s)\r\nESCAPE=%c\r\n\
 EVAL=%d%c%d\r\nEXPANSION=%s\r\nINPUT=%u\r\nMODE=%u\r\nNOCLOBBER=%u\r\nPARAMETERS=%c\r\nROWS=%u\r\nCURSOR OVERSTRIKE=%d\r\nCURSOR INSERT=%d\r\nUPPER CASE=%u\r\nVERBOSE=%u\r\nSWITCH=%c\r\nSINGLESTEP=%u\r\n");
@@ -922,7 +1098,7 @@
 TCHAR DATE_FMT[] = _TEXT("%u%*1s%u%*1s%u");
 
 TCHAR NEW_DATE[] = _TEXT("\r\nNew date (%s): ");
-TCHAR NEW_TIME[] = _TEXT("\r\nNew time (hh:mm:ss): ");
+TCHAR NEW_TIME[] = _TEXT("\r\nNew time (hh%cmm%css): ");
 TCHAR WHICH_UNKNOWN_CMD[] = _TEXT("%s is an unknown command\r\n");
 TCHAR WHICH_EXTERNAL[] = _TEXT("%s is an external : %s\r\n");
 TCHAR WHICH_EXECUTABLE_EXT[] = _TEXT("%s is an executable extension : %Fs %s\r\n");
@@ -978,6 +1154,7 @@
 
 extern TCHAR *daytbl[];
 extern TCHAR *montbl[];
+extern TCHAR *lmontbl[];
 extern TCHAR *dateformat[];
 extern TCHAR *video_type[];
 extern TCHAR *swap_mode[];
@@ -1016,6 +1193,7 @@
 extern TCHAR GLOBAL_USAGE[];
 extern TCHAR HEAD_USAGE[];
 extern TCHAR HISTORY_USAGE[];
+extern TCHAR IDLE_USAGE[];
 extern TCHAR IF_USAGE[];
 extern TCHAR IFF_USAGE[];
 extern TCHAR INKEY_USAGE[];
@@ -1042,6 +1220,7 @@
 extern TCHAR SCREEN_USAGE[];
 extern TCHAR SCRPUT_USAGE[];
 extern TCHAR SELECT_USAGE[];
+extern TCHAR SETERROR_USAGE[];
 extern TCHAR SET_USAGE[];
 extern TCHAR SWAPPING_USAGE[];
 extern TCHAR TAIL_USAGE[];
@@ -1050,6 +1229,7 @@
 extern TCHAR TIMER_USAGE[];
 extern TCHAR TITLE_USAGE[];
 extern TCHAR TOUCH_USAGE[];
+extern TCHAR TRANSIENT_USAGE[];
 extern TCHAR TREE_USAGE[];
 extern TCHAR TRUENAME_USAGE[];
 extern TCHAR WHICH_USAGE[];
@@ -1069,6 +1249,7 @@
 extern TCHAR ECHO_IS[];
 extern TCHAR LOADBTM_IS[];
 extern TCHAR PAUSE_PAGE_PROMPT[];
+extern TCHAR PAUSE_PAGE_CLEAR[];
 extern TCHAR PAUSE_PROMPT[];
 extern TCHAR DO_DO[];
 extern TCHAR DO_BY[];
@@ -1101,6 +1282,7 @@
 extern TCHAR LT[];
 extern TCHAR LE[];
 extern TCHAR NE[];
+extern TCHAR EQC[];
 
 extern TCHAR THEN[];
 extern TCHAR IFF[];
@@ -1153,7 +1335,10 @@
 extern TCHAR KBD_CAPS_LOCK[];
 extern TCHAR KBD_NUM_LOCK[];
 extern TCHAR KBD_SCROLL_LOCK[];
+extern TCHAR ENTER_STANDBY[];
+extern TCHAR TURN_MONITOR_OFF[];
 extern TCHAR REBOOT_IT[];
+extern TCHAR SHUT_IT_DOWN[];
 
 extern TCHAR START_BG_STR[];
 extern TCHAR START_DOS_STR[];
@@ -1216,7 +1401,9 @@
 extern TCHAR SET_PROGRAM[];
 extern TCHAR *SHORT_NAME;
 extern TCHAR DOS_VERSION[];
+extern TCHAR UNKVER[];
 extern TCHAR MSVER[];
+extern TCHAR LZVER[];
 extern TCHAR MS95VER[];
 extern TCHAR MS98VER[];
 extern TCHAR MSMEVER[];
@@ -1224,6 +1411,15 @@
 extern TCHAR WARPVER[];
 extern TCHAR DRVER[];
 extern TCHAR NOVVER[];
+extern TCHAR IBMVER[];
+extern TCHAR WENVER[];
+extern TCHAR XDVER[];
+extern TCHAR FDVER[];
+extern TCHAR RDVER[];
+extern TCHAR GSVER[];
+extern TCHAR RXVER[];
+extern TCHAR SDVER[];
+extern TCHAR PTSVER[];
 extern TCHAR DOS_REVISION[];
 extern TCHAR OS2_REVISION[];
 extern TCHAR DOS_LOCATION[];
@@ -1248,6 +1444,7 @@
 
 extern TCHAR MONO_MONITOR[];
 extern TCHAR COLOR_MONITOR[];
+extern TCHAR SVGA_TYPE[];
 
 extern TCHAR END_OF_FILE_STR[];
 
@@ -1260,212 +1457,316 @@
 
 
 // defines for internal variable array
-#define VAR_4VER 0
-#define VAR_IERRORLEVEL 1
-#define VAR_ALIAS 2
-#define VAR_ANSI 3
-#define VAR_APMAC 4
-#define VAR_APMBATT 5
-#define VAR_APMLIFE 6
-#define VAR_BATCH 7
-#define VAR_BATCHLINE 8
-#define VAR_BATCHNAME 9
-#define VAR_BG_COLOR 10
-#define VAR_BOOT 11
-#define VAR_BUILD 12
-#define VAR_CI 13
-#define VAR_CMDLINE 14
-#define VAR_CMDPROC 15
-#define VAR_CO 16
-#define VAR_CODEPAGE 17
-#define VAR_COLUMN 18
-#define VAR_COLUMNS 19
-#define VAR_COUNTRY 20
-#define VAR_CPU 21
-#define VAR_CWD 22
-#define VAR_CWDS 23
-#define VAR_CWP 24
-#define VAR_CWPS 25
-#define VAR_DATE 26
-#define VAR_DAY 27
-#define VAR_DISK 28
-#define VAR_DNAME 29
-#define VAR_DOS 30
-#define VAR_DOSVER 31
-#define VAR_DOW 32
-#define VAR_DOWF 33
-#define VAR_DOWI 34
-#define VAR_DOY 35
-#define VAR_DPMI 36
-#define VAR_DV 37
-#define VAR_ECHO 38
-#define VAR_ENVIRONMENT 39
-#define VAR_FG_COLOR 40
-#define VAR_HLOGFILE 41
-#define VAR_HOUR 42
-#define VAR_IDOW 43
-#define VAR_IDOWF 44
-#define VAR_ISODATE 45
-#define VAR_KBHIT 46
-#define VAR_KSTACK 47
-#define VAR_LASTDISK 48
-#define VAR_LOGFILE 49
-#define VAR_MINUTE 50
-#define VAR_MONITOR 51
-#define VAR_MONTH 52
-#define VAR_MOUSE 53
-#define VAR_NDP 54
-#define VAR_PIPE 55
-#define VAR_ROW 56
-#define VAR_ROWS 57
-#define VAR_SECOND 58
-#define VAR_SELECTED 59
-#define VAR_SHELL 60
-#define VAR_SWAPPING 61
-#define VAR_SYSERR 62
-#define VAR_TIME 63
-#define VAR_TRANSIENT 64
-#define VAR_VIDEO 65
-#define VAR_WIN 66
-#define VAR_WINTITLE 67
-#define VAR_YEAR 68
-
+enum InternalVariables {
+	VAR_4VER,
+	VAR_IERRORLEVEL,
+	VAR_ALIAS,
+	VAR_ALT,
+	VAR_ANSI,
+	VAR_APMAC,
+	VAR_APMBATT,
+	VAR_APMLIFE,
+	VAR_APPEND,
+	VAR_ASSIGN,
+	VAR_BATCH,
+	VAR_BATCHLINE,
+	VAR_BATCHNAME,
+	VAR_BATCHTYPE,
+	VAR_BDEBUGGER,
+	VAR_BG_COLOR,
+	VAR_BOOT,
+	VAR_BUILD,
+	VAR_CAPSLOCK,
+	VAR_CDROMS,
+	VAR_CI,
+	VAR_CMDLINE,
+	VAR_CMDPROC,
+	VAR_CMDSPEC,
+	VAR_CO,
+	VAR_CODEPAGE,
+	VAR_COLUMN,
+	VAR_COLUMNS,
+	VAR_COUNTRY,
+	VAR_CPU,
+	VAR_CPUSPEED,
+	VAR_CTRL,
+	VAR_CWD,
+	VAR_CWDS,
+	VAR_CWP,
+	VAR_CWPS,
+	VAR_DATE,
+	VAR_DATETIME,
+	VAR_DAY,
+	VAR_DISK,
+	VAR_DISPLAY,
+	VAR_DNAME,
+	VAR_DOS,
+	VAR_DOSVER,
+	VAR_DOW,
+	VAR_DOWF,
+	VAR_DOWI,
+	VAR_DOY,
+	VAR_DPMI,
+	VAR_DRIVER,
+	VAR_DRIVES,
+	VAR_DST,
+	VAR_DV,
+	VAR_ECHO,
+	VAR_EDITMODE,
+	VAR_EGA,
+	VAR_ENVIRONMENT,
+	VAR_EXECSTR,
+	VAR_EXPANSION,
+	VAR_FG_COLOR,
+	VAR_FONTPAGE,
+	VAR_GRAFTABL,
+	VAR_GRAPHICS,
+	VAR_HDRIVES,
+	VAR_HLOGFILE,
+	VAR_HOUR,
+	VAR_IDOW,
+	VAR_IDOWF,
+	VAR_ININAME,
+	VAR_ISODATE,
+	VAR_ISODOWI,
+	VAR_ISORDATE,
+	VAR_ISOWDATE,
+	VAR_ISOWEEK,
+	VAR_ISOWYEAR,
+	VAR_KBHIT,
+	VAR_KEYSTACKED,
+	VAR_KSTACK,
+	VAR_LALT,
+	VAR_LASTDIR,
+	VAR_LASTDISK,
+	VAR_LCTRL,
+	VAR_LOGFILE,
+	VAR_LSHIFT,
+	VAR_MACHINE,
+	VAR_MINUTE,
+	VAR_MJD,
+	VAR_MONITOR,
+	VAR_MONTH,
+	VAR_MONTHF,
+	VAR_MOUSE,
+	VAR_MSCDEX,
+	VAR_NDP,
+	VAR_NETWORK,
+	VAR_NLSFUNC,
+	VAR_NUMLOCK,
+	VAR_PIPE,
+	VAR_POWER,
+	VAR_PRINT,
+	VAR_RALT,
+	VAR_RCTRL,
+	VAR_READY,
+	VAR_ROW,
+	VAR_ROWS,
+	VAR_RSHIFT,
+	VAR_SBDSP,
+	VAR_SCROLLLOCK,
+	VAR_SECOND,
+	VAR_SHARE,
+	VAR_SHELL,
+	VAR_SHIFT,
+	VAR_SMARTDRV,
+	VAR_STARTPATH,
+	VAR_STDERR,
+	VAR_STDIN,
+	VAR_STDOUT,
+	VAR_STZN,
+	VAR_STZO,
+	VAR_SWAPPING,
+	VAR_SYSERR,
+	VAR_SYSREQ,
+	VAR_TASKMAX,
+	VAR_TASKSWITCHER,
+	VAR_TICK,
+	VAR_TIME,
+	VAR_TRANSIENT,
+	VAR_TSC,
+	VAR_TZN,
+	VAR_TZO,
+	VAR_UNIXTIME,
+	VAR_UTCDATE,
+	VAR_UTCDATETIME,
+	VAR_UTCHOUR,
+	VAR_UTCISODATE,
+	VAR_UTCMINUTE,
+	VAR_UTCSECOND,
+	VAR_UTCTIME,
+	VAR_V86,
+	VAR_VCPI,
+	VAR_VDS,
+	VAR_VERMAJOR,
+	VAR_VERMINOR,
+	VAR_VERSION,
+	VAR_VIDEO,
+	VAR_WIN,
+	VAR_WINTICKS,
+	VAR_WINTITLE,
+	VAR_YEAR
+};
+	
 // defines for variable function array
-#define FUNC_ABS 0
-#define FUNC_ALIAS 1
-#define FUNC_ALTNAME 2
-#define FUNC_ASCII 3
-#define FUNC_ATTRIB 4
-#define FUNC_CAPS 5
-#define FUNC_CDROM 6
-#define FUNC_CHAR 7
-#define FUNC_CLIP 8
-#define FUNC_CLIPW 9
-#define FUNC_COMMA 10
-#define FUNC_CONVERT 11
-#define FUNC_CRC32 12
-#define FUNC_DATE 13
-#define FUNC_DAY 14
-#define FUNC_DEC 15
-#define FUNC_DECIMAL 16
-#define FUNC_DESCRIPT 17
-#define FUNC_DEVICE 18
-#define FUNC_DIGITS 19
-#define FUNC_DISKFREE 20
-#define FUNC_DISKTOTAL 21
-#define FUNC_DISKUSED 22
-#define FUNC_DOSMEM 23
-#define FUNC_DOW 24
-#define FUNC_DOWF 25
-#define FUNC_DOWI 26
-#define FUNC_DOY 27
-#define FUNC_EMS 28
-#define FUNC_ERRTEXT 29
-#define FUNC_EVAL 30
-#define FUNC_EXECUTE 31
-#define FUNC_EXECSTR 32
-#define FUNC_EXPAND 33
-#define FUNC_EXTENSION 34
-#define FUNC_EXTENDED 35
-#define FUNC_FIELD 36
-#define FUNC_FILEAGE 37
-#define FUNC_FILECLOSE 38
-#define FUNC_FILEDATE 39
-#define FUNC_FILENAME 40
-#define FUNC_FILEOPEN 41
-#define FUNC_FILEREAD 42
-#define FUNC_FILES 43
-#define FUNC_FILESEEK 44
-#define FUNC_FILESEEKL 45
-#define FUNC_FILESIZE 46
-#define FUNC_FILETIME 47
-#define FUNC_FILEWRITE 48
-#define FUNC_FILEWRITEB 49
-#define FUNC_FINDCLOSE 50
-#define FUNC_FINDFIRST 51
-#define FUNC_FINDNEXT 52
-#define FUNC_FORMAT 53
-#define FUNC_FULLNAME 54
-#define FUNC_FUNCTION 55
-#define FUNC_IF 56
-#define FUNC_INC 57
-#define FUNC_INDEX 58
-#define FUNC_INIREAD 59
-#define FUNC_INIWRITE 60
-#define FUNC_INSERT 61
-#define FUNC_INSTR 62
-#define FUNC_INTEGER 63
-#define FUNC_LABEL 64
-#define FUNC_LEFT 65
-#define FUNC_LENGTH 66
-#define FUNC_LFN 67
-#define FUNC_LINE 68
-#define FUNC_LINES 69
-#define FUNC_LOWER 70
-#define FUNC_LPT 71
-#define FUNC_MAKEAGE 72
-#define FUNC_MAKEDATE 73
-#define FUNC_MAKETIME 74
-#define FUNC_MASTER 75
-#define FUNC_MAX 76
-#define FUNC_MIN 77
-#define FUNC_MONTH 78
-#define FUNC_MOUSE 79
-#define FUNC_NAME 80
-#define FUNC_NUMERIC 81
-#define FUNC_PATH 82
-#define FUNC_RANDOM 83
-#define FUNC_READSCR 84
-#define FUNC_READY 85
-#define FUNC_REMOTE 86
-#define FUNC_REMOVABLE 87
-#define FUNC_REPEAT 88
-#define FUNC_REPLACE 89
-#define FUNC_RIGHT 90
-#define FUNC_SEARCH 91
-#define FUNC_SELECT 92
-#define FUNC_SFN 93
-#define FUNC_STRIP 94
-#define FUNC_SUBSTR 95
-#define FUNC_TIME 96
-#define FUNC_TIMER 97
-#define FUNC_TRIM 98
-#define FUNC_TRUENAME 99
-#define FUNC_UNIQUE 100
-#define FUNC_UPPER 101
-#define FUNC_WILD 102
-#define FUNC_WORD 103
-#define FUNC_WORDS 104
-#define FUNC_XMS 105
-#define FUNC_YEAR 106
-
-#define FUNC_CEILING 107
-#define FUNC_EXETYPE 108
-#define FUNC_FLOOR 109
-#define FUNC_FSTYPE 110
-#define FUNC_GETDIR 111
-#define FUNC_GETFILE 112
-#define FUNC_GETFOLDER 113
-#define FUNC_IDOW 114
-#define FUNC_IDOWF 115
-#define FUNC_OPTION 116
-#define FUNC_PING 117
-#define FUNC_REGCREATE 118
-#define FUNC_REGQUERY 119
-#define FUNC_REGSET 120
-#define FUNC_REGSETENV 121
-#define FUNC_REXX 122
-#define FUNC_UNICHAR 123
-#define FUNC_UNICODE 124
-#define FUNC_VERINFO 125
-#define FUNC_WATTRIB 126
-#define FUNC_WINCLASS 127
-#define FUNC_WINEXENAME 128
-#define FUNC_WININFO 129
-#define FUNC_WINMEMORY 130
-#define FUNC_WINMETRICS 131
-#define FUNC_WINSTATE 132
-#define FUNC_WINSYSTEM 133
+enum InternalFunctions {
+	FUNC_ABS,
+	FUNC_AGEDATE,
+	FUNC_ALIAS,
+	FUNC_ALTNAME,
+	FUNC_ASCII,
+	FUNC_ATTRIB,
+	FUNC_AVERAGE,
+	FUNC_CAPS,
+	FUNC_CDROM,
+	FUNC_CEILING,
+	FUNC_CHAR,
+	FUNC_CLIP,
+	FUNC_CLIPW,
+	FUNC_CLUSTSIZE,
+	FUNC_CODEPAGE,
+	FUNC_COM,
+	FUNC_COMMA,
+	FUNC_COMPARE,
+	FUNC_CONVERT,
+	FUNC_COUNT,
+	FUNC_CRC32,
+	FUNC_CWD,
+	FUNC_CWDS,
+	FUNC_DATE,
+	FUNC_DATECONV,
+	FUNC_DAY,
+	FUNC_DDCSTR,
+	FUNC_DEC,
+	FUNC_DECIMAL,
+	FUNC_DESCRIPT,
+	FUNC_DEVICE,
+	FUNC_DIGITS,
+	FUNC_DIRSTACK,
+	FUNC_DISKFREE,
+	FUNC_DISKTOTAL,
+	FUNC_DISKUSED,
+	FUNC_DOSMEM,
+	FUNC_DOW,
+	FUNC_DOWF,
+	FUNC_DOWI,
+	FUNC_DOY,
+	FUNC_DRIVETYPE,
+	FUNC_EMS,
+	FUNC_ERRTEXT,
+	FUNC_EVAL,
+	FUNC_EXECUTE,
+	FUNC_EXECSTR,
+	FUNC_EXPAND,
+	FUNC_EXTENSION,
+	FUNC_EXTENDED,
+	FUNC_FIELD,
+	FUNC_FIELDS,
+	FUNC_FILEAGE,
+	FUNC_FILECLOSE,
+	FUNC_FILEDATE,
+	FUNC_FILENAME,
+	FUNC_FILEOPEN,
+	FUNC_FILEREAD,
+	FUNC_FILEREADB,
+	FUNC_FILES,
+	FUNC_FILESEEK,
+	FUNC_FILESEEKL,
+	FUNC_FILESIZE,
+	FUNC_FILETIME,
+	FUNC_FILEWRITE,
+	FUNC_FILEWRITEB,
+	FUNC_FINDCLOSE,
+	FUNC_FINDFIRST,
+	FUNC_FINDNEXT,
+	FUNC_FLOOR,
+	FUNC_FORMAT,
+	FUNC_FSTYPE,
+	FUNC_FULLNAME,
+	FUNC_FUNCTION,
+	FUNC_HDDSIZE,
+	FUNC_HISTORY,
+	FUNC_IF,
+	FUNC_INC,
+	FUNC_INDEX,
+	FUNC_INIREAD,
+	FUNC_INIWRITE,
+	FUNC_INSERT,
+	FUNC_INSTR,
+	FUNC_INTEGER,
+	FUNC_ISALNUM,
+	FUNC_ISALPHA,
+	FUNC_ISASCII,
+	FUNC_ISCNTRL,
+	FUNC_ISDIGIT,
+	FUNC_ISLOWER,
+	FUNC_ISODOWI,
+	FUNC_ISOWEEK,
+	FUNC_ISOWYEAR,
+	FUNC_ISPRINT,
+	FUNC_ISPUNCT,
+	FUNC_ISSPACE,
+	FUNC_ISUPPER,
+	FUNC_ISXDIGIT,
+	FUNC_LABEL,
+	FUNC_LCS,
+	FUNC_LEFT,
+	FUNC_LENGTH,
+	FUNC_LFN,
+	FUNC_LINE,
+	FUNC_LINES,
+	FUNC_LOWER,
+	FUNC_LPT,
+	FUNC_LTRIM,
+	FUNC_MAKEAGE,
+	FUNC_MAKEDATE,
+	FUNC_MAKETIME,
+	FUNC_MASTER,
+	FUNC_MAX,
+	FUNC_MD5,
+	FUNC_MIN,
+	FUNC_MONTH,
+	FUNC_MONTHF,
+	FUNC_MOUSE,
+	FUNC_NAME,
+	FUNC_NUMERIC,
+	FUNC_PATH,
+	FUNC_QUOTE,
+	FUNC_RANDOM,
+	FUNC_READSCR,
+	FUNC_READY,
+	FUNC_REMOTE,
+	FUNC_REMOVABLE,
+	FUNC_REPEAT,
+	FUNC_REPLACE,
+	FUNC_REVERSE,
+	FUNC_RIGHT,
+	FUNC_RTRIM,
+	FUNC_SEARCH,
+	FUNC_SELECT,
+	FUNC_SERIAL,
+	FUNC_SFN,
+	FUNC_SHA1,
+	FUNC_SIMILAR,
+	FUNC_SMBSTR,
+	FUNC_STRIP,
+	FUNC_SUBST,
+	FUNC_SUBSTR,
+	FUNC_TIME,
+	FUNC_TIMER,
+	FUNC_TRIM,
+	FUNC_TRUENAME,
+	FUNC_TRUNCATE,
+	FUNC_UNIQUE,
+	FUNC_UNQUOTE,
+	FUNC_UNQUOTES,
+	FUNC_UPPER,
+	FUNC_WILD,
+	FUNC_WORD,
+	FUNC_WORDS,
+	FUNC_XMS,
+	FUNC_YEAR
+};
 
 
 // FILECMDS.C
@@ -1520,6 +1821,7 @@
 extern TCHAR LIST_FIND_WAIT[];
 extern TCHAR LIST_FIND_TITLE[];
 extern TCHAR LIST_FIND_TITLE_REVERSE[];
+extern TCHAR LIST_FIND_BTITLE_CASE[];
 extern TCHAR LIST_FIND_HEX[];
 extern TCHAR LIST_PRINT_TITLE[];
 extern TCHAR LIST_SAVE_TITLE[];
@@ -1531,15 +1833,18 @@
 
 
 // MISC.C
+extern TCHAR NO_SEP[];
 extern TCHAR DESCRIPTION_FILE[];
 extern TCHAR DESCRIPTION_SCAN[];
 
 // extern TCHAR IFILE[];
 extern TCHAR CONSOLE[];
 extern TCHAR DEV_CONSOLE[];
+extern LPTSTR PRINTERS[];
 extern TCHAR YES_NO[];
 extern TCHAR YES_NO_ALL[];
 extern TCHAR BRIGHT[];
+extern TCHAR BLINK[];
 extern TCHAR BORDER[];
 
 
@@ -1586,6 +1891,8 @@
 extern TCHAR LFNFOR_IS[];
 
 extern TCHAR VERIFY_IS[];
+extern TCHAR IDLE_IS[];
+
 extern TCHAR KEYS_IS[];
 extern TCHAR SETDOS_IS[];
 extern TCHAR GLOBAL_DIR[];
@@ -1610,3 +1917,6 @@
 extern TCHAR WHICH_INTERNAL[];
 
 extern TCHAR CODE_PAGE[];
+extern TCHAR COUNTRY_CODE[];
+
+#endif /* DEFINE_GLOBALS */
diff -Nu d:7.501/misc.c SOURCES/misc.c
--- d:7.501/misc.c	2006-11-12 16:00:50 +0200
+++ SOURCES/misc.c	2008-12-26 09:50:42 +0200
@@ -48,7 +48,10 @@
 #include <string.h>
 
 #include "4all.h"
+#include "md5.h"
+#include "sha.h"
 
+static int _fastcall QueryIsLFN( TCHAR * );
 static LPTSTR _fastcall NextRange( TCHAR * );
 static int _fastcall GetRangeArgs( TCHAR *, RANGES * );
 static int _fastcall GetStrTime( TCHAR *, int *, int * );
@@ -56,12 +59,115 @@
 static void GetStrSize( TCHAR *, long * );
 
 static int _fastcall QueryIsRelative( TCHAR * );
+static int _near similar_char( char *, int, char *, int );
 
 
 int fNoComma = 0;
 static TCHAR szNthArgBuffer[ MAXARGSIZ+1 ];
 
 
+#define MAXSIZE 179
+#define BUFSIZE ((MAXSIZE+1)*(MAXSIZE+1))
+
+enum direction { NIL, NORTHWEST, WEST, NORTH };
+
+#pragma alloc_text( ASM_TEXT, LCS )
+
+// Longest Common Subsequence (thanks to Assoc. Prof. Bob Weems for this code!)
+LPTSTR LCS( LPTSTR string1, LPTSTR string2 )
+{
+	static TCHAR LCSstring[MAXSIZE];
+	BYTE (_far *cost)[MAXSIZE+1], (_far *backPtr)[MAXSIZE+1];
+	BYTE LCSlength, i, j, k;
+	BYTE length1 = (BYTE)strlen(string1), length2 = (BYTE)strlen(string2);
+	WORD bufsize = BUFSIZE;
+
+	if ( length1 > MAXSIZE || length2 > MAXSIZE || (cost = AllocMem(&bufsize)) == NULL || bufsize < BUFSIZE || (backPtr = AllocMem(&bufsize)) == NULL || bufsize < BUFSIZE ) {
+		LCSstring[0] = _TEXT('\0');
+		error( ERROR_NOT_ENOUGH_MEMORY, NULL );
+		goto done;
+	}
+	// string1[i] is associated with row i + 1
+	// string2[i] is associated with column i + 1
+
+	for ( i = 1; i <= length2; i++ ) {
+		for ( j = i, k = 1; j > 0 && k <= length1; j--, k++ ) {
+			if ( string1[k-1] == string2[j-1] ) {
+				cost[k][j] = (BYTE)(cost[k-1][j-1] + 1);
+				backPtr[k][j] = NORTHWEST;
+			} else if ( cost[k-1][j] >= cost[k][j-1] ) {
+				cost[k][j] = cost[k-1][j];
+				backPtr[k][j] = NORTH;
+			} else {
+				cost[k][j] = cost[k][j-1];
+				backPtr[k][j] = WEST;
+			}
+		}
+	}
+	for ( i = 2; i <= length1; i++ ) {
+		for ( j = length2, k = i; j > 0 && k <= length1; j--, k++ ) {
+			if ( string1[k-1] == string2[j-1] ) {
+				cost[k][j] = (BYTE)(cost[k-1][j-1] + 1);
+				backPtr[k][j] = NORTHWEST;
+			} else if ( cost[k-1][j] >= cost[k][j-1] ) {
+				cost[k][j] = cost[k-1][j];
+				backPtr[k][j] = NORTH;
+			} else {
+				cost[k][j] = cost[k][j-1];
+				backPtr[k][j] = WEST;
+			}
+		}
+	}
+	LCSlength = cost[length1][length2];
+	LCSstring[LCSlength] = _TEXT('\0');
+	for ( i = length1, j = length2; backPtr[i][j]; ) {
+		if ( backPtr[i][j] == NORTHWEST ) {
+			LCSstring[cost[i][j]-1] = string1[i-1];
+			i--;
+			j--;
+		} else if ( backPtr[i][j] == WEST )
+			j--;
+		else	// backPtr[i][j] == NORTH )
+			i--;
+	}
+done:	FreeMem(cost);
+	FreeMem(backPtr);
+	return LCSstring;
+}
+
+
+#pragma alloc_text( ASM_TEXT, CompareFiles )
+
+// compare the specified files; return 1 if identical, else 0
+int CompareFiles( LPTSTR pszFil1, LPTSTR pszFil2 )
+{
+	int nFH1 = -1, nFH2 = -1;
+	UINT uRead1 = UINT_MAX, uRead2 = UINT_MAX, uBufSiz = 0xFF00;
+	BYTE _far *lpszBuf = NULL;
+
+	if (( nFH1 = _sopen( pszFil1, _O_RDONLY | _O_BINARY, _SH_DENYWR )) < 0 )
+err1:		error( _doserrno, pszFil1 );
+	else if (( nFH2 = _sopen( pszFil2, _O_RDONLY | _O_BINARY, _SH_DENYWR )) < 0 )
+err2:		error( _doserrno, pszFil2 );
+	else if ( _filelength( nFH1 ) == _filelength( nFH2 )) {
+		if (( lpszBuf = AllocMem( &uBufSiz )) == NULL )
+			error( ERROR_NOT_ENOUGH_MEMORY, NULL );
+		else do {
+			if ( FileRead( nFH1, lpszBuf, uBufSiz / 2, &uRead1 ))
+				goto err1;
+			if ( FileRead( nFH2, lpszBuf + uBufSiz / 2, uBufSiz / 2, &uRead2 ))
+				goto err2;
+		} while ( uRead1 && uRead1 == uRead2 && !_fmemcmp( lpszBuf, lpszBuf + uBufSiz / 2, uRead1 ));
+	}
+	if ( nFH1 >= 0 )
+		_close( nFH1 );
+	if ( nFH2 >= 0 )
+		_close( nFH2 );
+	FreeMem( lpszBuf );
+	return !uRead1 && !uRead2;
+}
+
+
 // return the CRC32 for the specified file
 unsigned long _fastcall CRC32( LPTSTR pszFileName )
 {
@@ -119,6 +225,44 @@
 }
 
 
+#pragma alloc_text( SHARE_TEXT, MD5SHA1 )
+
+// store the MD5 or SHA1 for the specified file
+// return 0 if OK, or -1 on error
+int MD5SHA1( LPTSTR pszFileName, TCHAR ucDigest[20], int fSHA )
+{
+	static MD5_CTX context;
+	static SHA1Context context1;
+	int nFH;
+	unsigned int uBytesRead, uReadSize = 4096;
+	char _far *lpszBuffer;
+
+	if (( nFH = _sopen( pszFileName, _O_RDONLY | _O_BINARY, _SH_DENYWR )) < 0 ) {
+error:		error( _doserrno, pszFileName );
+		return -1;
+	}
+	if (( lpszBuffer = (char _far *)AllocMem( &uReadSize )) == NULL ) {
+error1:		_close( nFH );
+		goto error;
+	}
+	fSHA ? SHA1Reset( &context1 ) : MD5Init( &context );
+	do {
+		if ( FileRead( nFH, lpszBuffer, uReadSize, &uBytesRead )) {
+			FreeMem( lpszBuffer );
+			goto error1;
+		}
+		if ( fSHA )
+			SHA1Input( &context1, lpszBuffer, uBytesRead );
+		else
+			MD5Update( &context, lpszBuffer, uBytesRead );
+	} while ( uBytesRead );
+	fSHA ? SHA1Result( &context1, ucDigest ) : MD5Final( ucDigest, &context );
+	_close( nFH );
+	FreeMem( lpszBuffer );
+	return 0;
+}
+
+
 // read a single line from the file (for @filename)
 int PASCAL GetFileLine( TCHAR *pszFileName, long *plOffset, TCHAR *pszLine )
 {
@@ -157,7 +301,9 @@
 }
 
 
-int _fastcall QueryIsLFN( TCHAR *pszFilename )
+#pragma alloc_text( ASM_TEXT, QueryIsLFN )
+
+static int _fastcall QueryIsLFN( TCHAR *pszFilename )
 {
 	int n, fExt;
 
@@ -197,6 +343,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, cvtkey )
+
 // convert keystrokes
 int _fastcall cvtkey( unsigned int uKeyCode, unsigned int uContextBits )
 {
@@ -229,9 +377,7 @@
 }
 
 
-
-#pragma alloc_text( _TEXT, iswhite, isdelim, skipspace, first_arg, next_arg, last_arg, ntharg )
-
+#pragma alloc_text( SCREENIO_TEXT, iswhite )
 
 // replace RTL isspace() - we only want to check for spaces & tabs
 int _fastcall iswhite( TCHAR c )
@@ -240,6 +386,8 @@
 }
 
 
+#pragma alloc_text( _TEXT, isdelim, skipspace, first_arg, next_arg, last_arg, ntharg )
+
 // test for delimiter (" \t,")
 int _fastcall isdelim( TCHAR c )
 {
@@ -637,6 +785,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, GetMultiCharSwitch )
+
 int PASCAL GetMultiCharSwitch( TCHAR *pszLine, TCHAR *pszSwitch, TCHAR *pszOutput, int nMaxLength )
 {
 	register TCHAR *pszArg;
@@ -705,6 +855,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, QueryIsSwitch )
+
 // Scan the line for a matching switch
 int PASCAL QueryIsSwitch( LPTSTR pszLine, TCHAR cSwitch, int fAnywhere )
 {
@@ -787,13 +939,29 @@
 }
 
 
-// is the filename "CON"
+#pragma alloc_text( _TEXT, QueryIsCON )
+
+// is the filename "CON" or "\DEV\CON"?
 int _fastcall QueryIsCON( LPTSTR pszFileName )
 {
 	return (( _stricmp( pszFileName, CONSOLE ) == 0 ) || ( _stricmp( pszFileName, DEV_CONSOLE ) == 0 ));
 }
 
 
+// is the filename "[\DEV\]PRN" or "[\DEV\]LPTx" where x = 1,2,3?
+int _fastcall QueryIsPRN( LPTSTR pszFileName )
+{
+	int i;
+
+	for ( i = 0; i < 8; i++ )
+		if ( !_stricmp( pszFileName, PRINTERS[i] ))
+			return TRUE;
+	return FALSE;
+}
+
+
+#pragma alloc_text( SCREENIO_TEXT, QueryIsRelative )
+
 // test if relative range spec is composed entirely of digits
 static int _fastcall QueryIsRelative( LPTSTR pszRange )
 {
@@ -1191,39 +1359,77 @@
 		*plSize *= 1000000L;
 	else if ( *pszSize == _TEXT('M') )
 		*plSize <<= 20;
+	else if ( *pszSize == _TEXT('g') )
+		*plSize *= 1000000000L;
+	else if ( *pszSize == _TEXT('G') )
+		*plSize <<= 30;
 }
 
 
+// convert ISO ordinal day (day-of-year) to date; return 0 if OK or 1 on error
+static int DOYtoDate( UINT uYear, UINT uOrdDay, UINT *uMonth, UINT *uDay )
+{
+	static BYTE aDays[12] = { 31,0,31, 30,31,30, 31,31,30, 31,30,31 };
+	UINT i, uLeap = uYear % 4 ? 0 : 1;
+
+	if ( uOrdDay > 365 + uLeap )
+		return 1;
+	aDays[1] = 28 + uLeap;
+	for ( i = 0; uOrdDay > aDays[i]; i++ )
+		uOrdDay -= aDays[i];
+	*uDay = uOrdDay;
+	*uMonth = ++i;
+	return 0;
+}
+
 
 #pragma alloc_text( ASM_TEXT, GetStrDate )
 
 
-// return the date from a string
+// get the date from a string; return zero if successful or non-zero on error
 int GetStrDate( register LPTSTR pszDate, unsigned int *puMonth, unsigned int *puDay, unsigned int *puYear )
 {
 	register int nReturn;
 
-	// Japan or international format
-	nReturn = sscanf( pszDate, DATE_FMT, puYear, puMonth, puDay );
-
-	if (( *puYear < 1900 ) && ( gaCountryInfo.fsDateFmt != 2 )) {
+	// ISO week date format (yyyy-Www-d)
+	if ( stristr( pszDate, _TEXT("W"))) {
+		unsigned uYear, uWeek, uDay;
+		long lDays;
+		nReturn = sscanf( pszDate, _TEXT("%u%*2s%u%*1s%u"), &uYear, &uWeek, &uDay );
+		if ( nReturn == 3 && uYear > 1979 && uYear < 2100 && uWeek < 54 && uDay < 8 ) {
+			lDays = ( uYear - 1980 ) * 365 + ( uYear - 1977 ) / 4;
+			lDays += uWeek * 7 - ( lDays + 4 ) % 7 + uDay - 5;
+			MakeDateFromDays( lDays, &uYear, puMonth, puDay );
+			*puYear = uYear + 1900;
+		} else
+			return 1;
+	} else {
+		// Japan or international format
+		nReturn = sscanf( pszDate, DATE_FMT, puYear, puMonth, puDay );
 
-		if ( gaCountryInfo.fsDateFmt == 1 )	// Europe
-			nReturn = sscanf( pszDate, DATE_FMT, puDay, puMonth, puYear );
-		else 		// USA
-			nReturn = sscanf( pszDate, DATE_FMT, puMonth, puDay, puYear );
+		if ( nReturn == 2 ) {	// ISO ordinal date - DOY in puMonth
+			if ( !DOYtoDate( *puYear, *puMonth, puMonth, puDay ))
+				nReturn++; // signal OK
+		} else if (( *puYear < 1900 ) && ( gaCountryInfo.fsDateFmt != 2 )) {
+	
+			if ( gaCountryInfo.fsDateFmt == 1 )	// Europe
+				nReturn = sscanf( pszDate, DATE_FMT, puDay, puMonth, puYear );
+			else 		// USA
+				nReturn = sscanf( pszDate, DATE_FMT, puMonth, puDay, puYear );
+		}
+		if ( *puYear < 80 )
+			*puYear += 2000;
+		else if ( *puYear < 100 )
+			*puYear += 1900;
 	}
-
-	return nReturn;
-}
+	return nReturn < 3 || *puMonth > 12 || *puDay > 31 || *puYear < 1980 || *puYear > 2099;
+}	// what a terrible fault - DOS could accept dates up to 2127, but alas, it doesn't!
 
 
 // get the number of days since 1/1/80 for the specified date
 int _fastcall MakeDaysFromDate( long *plDays, LPTSTR pszDate )
 {
-	register unsigned int i;
-	unsigned int uYear = 80, uMonth = 1, uDay = 1;
-	int nReturn = 0;
+	unsigned int i, n, uYear = 80, uMonth = 1, uDay = 1;
 	DATETIME sysDateTime;
 
 	*plDays = 0L;
@@ -1235,7 +1441,6 @@
 		uYear = sysDateTime.year;
 		uMonth = sysDateTime.month;
 		uDay = sysDateTime.day;
-		nReturn = 3;
 
 	} else if (( *pszDate == _TEXT('+') ) || ( *pszDate == _TEXT('-') ) || ( QueryIsRelative( pszDate ))) {
 
@@ -1246,31 +1451,12 @@
 			*pszDate = _TEXT('+');
 		return 0;
 
-	} else
-		nReturn = GetStrDate( pszDate, &uMonth, &uDay, &uYear );
-
-	if ( uYear < 80 )
-		uYear += 2000;
-	else if ( uYear < 100 )
-		uYear += 1900;
-
-	// don't allow anything before 1/1/1980
-	if (( nReturn < 3 ) || ( uMonth > 12 ) || ( uDay > 31 ) || ( uYear > 2099 ) || ( uYear < 1980 ))
+	} else if ( GetStrDate( pszDate, &uMonth, &uDay, &uYear ))
 		return ERROR_4DOS_INVALID_DATE;
 
-	// get days for previous years
-	for ( i = 1980; ( i < uYear ); i++ )
-		*plDays += ((( i % 4 ) == 0 ) ? 366 : 365 );
-
-	// get days for previous months
-	for ( i = 1; ( i < uMonth ); i++ ) {
-		if ( i == 2 )
-			*plDays += ((( uYear % 4 ) == 0 ) ? 29 : 28 );
-		else
-			*plDays += ((( i == 4 ) || ( i == 6 ) || ( i == 9 ) || (i == 11)) ? 30 : 31);
-	}
-
-	*plDays += ( uDay - 1 );
+	n = uYear; // nYear may be changed below!
+	ISOweekDOY( &uDay, uMonth, &uYear, &i );
+	*plDays = i - 1 + ( n - 1980 ) * 365 + ( n - 1977 ) / 4;
 
 	return 0;
 }
@@ -1279,27 +1465,48 @@
 // get a date from the number of days since 1/1/80
 int MakeDateFromDays( long lDays, unsigned int *puYear, register unsigned int *puMonth, register unsigned int *puDay )
 {
+	UINT uDays;
+
 	// don't allow anything past 12/31/2099
 	if (( lDays > 43829L ) || ( lDays < 0L ))
 		return ERROR_INVALID_PARAMETER;
 
-	for ( *puYear = 80; ; (*puYear)++ ) {
+	for ( *puDay = (UINT)lDays + 1, *puYear = 80; *puDay > ( uDays = *puYear % 4 ? 365 : 366 ); (*puYear)++ )
+		*puDay -= uDays;
+	return DOYtoDate( *puYear, *puDay, puMonth, puDay );
+}
 
-		for ( *puMonth = 1; (*puMonth <= 12); (*puMonth)++ ) {
 
-			if (*puMonth == 2)
-				*puDay = (((*puYear % 4) == 0 ) ? 29 : 28);
-			else
-				*puDay = (((*puMonth == 4) || (*puMonth == 6) || (*puMonth == 9) || (*puMonth == 11)) ? 30 : 31);
+// return the ISO 8601 week number
+// (Calendar FAQ v2.9, section 7.8. "How can I calculate the week number?")
+int _near ISOweekDOY( int *day, int month, int *year, int *doy )
+{
+	int a, b, c, d, e, f, g, n, s;
 
-			if ( (LONG)*puDay <= lDays ) 
-				lDays -= *puDay;
-			else {
-				*puDay = (unsigned int)( lDays + 1 );
-				return 0;
-			}
-		}
+	a = month < 3 ? *year-1 : *year;
+	b = a / 4 - a / 100 + a / 400;
+	c = (a - 1) / 4 - (a - 1) / 100 + (a - 1) / 400;
+	s = b - c;
+	if ( month < 3 ) {
+		e = 0;
+		f = *day - 1 + 31 * (month - 1);
+	} else {
+		e = s + 1;
+		f = *day + (153 * (month - 3) + 2) / 5 + 58 + s;
 	}
+	g = (a + b) % 7;
+	d = (f + g - e) % 7;
+	n = f + 3 - d;
+	*day = d + 1;	// day of week
+	*doy = f + 1;	// day of year
+	if ( n < 0 ) {
+		(*year)--;
+		return 53 - (g - s) / 5;
+	} else if ( n > 364 + s ) {
+		(*year)++;
+		return 1;
+	} else
+		return n / 7 + 1;
 }
 
 
@@ -1387,7 +1594,7 @@
 	wcmemset( pszDrives, _TEXT('\0'), 30 );
 	for ( i = 0, n = 3; ( n <= 26 ); n++ ) {
 		pszDrives[i] = (TCHAR)( n + 64 );
-		if (( QueryDriveExists( n )) && ( QueryDriveReady( n )) && ( QueryIsCDROM( pszDrives+i ) == 0 ) && ( QueryDriveRemote( n ) == 0 ) && ( QueryDriveRemovable( n ) == 0 ))
+		if (( QueryDriveExists( n )) && ( QueryDriveReady( n )) && ( QueryIsCDROM( n ) == 0 ) && ( QueryDriveRemote( n ) == 0 ) && ( QueryDriveRemovable( n ) == 0 ))
 			i++;
 	}
 
@@ -1399,20 +1606,32 @@
 LPTSTR _fastcall gcdir( LPTSTR pszDrive, int fNoError )
 {
 	static TCHAR szCurrent[MAXFILENAME+1];
+#ifdef __WATCOMC__
+	int nDisk, nReturn, bWin95LFN;
+#else
 	int nDisk, nReturn;
+#endif
 
 	nDisk = gcdisk( pszDrive );
 	sprintf( szCurrent, FMT_ROOT, nDisk+64 );
 
 	nReturn = (unsigned int)(szCurrent + 3);
+#ifdef __WATCOMC__
+	bWin95LFN = gpIniptr->Win95LFN;
+#endif
 
 	_asm {
 		push	si
 
 			mov	dx, nDisk
 			mov	si, nReturn
+#ifdef __WATCOMC__
+			mov	bx, bWin95LFN	  ; skip Win95 call if disabled
+			cmp	bx,0
+#else
 			mov	bx, gpIniptr	  ; skip Win95 call if disabled
 			cmp	[bx].Win95LFN,0
+#endif
 			je	gcd_old
 			mov	ax, 7147h	  ; fcn 7147: get current directory (long name version)
 			stc				 ; set carry in case not supported
@@ -1476,6 +1695,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, path_part )
+
 // return the path stripped of the filename (or NULL if no path)
 LPTSTR _fastcall path_part( LPTSTR pszName )
 {
@@ -1584,6 +1805,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, ext_part )
+
 // return the file extension only
 LPTSTR _fastcall ext_part( LPTSTR pszFileName )
 {
@@ -1634,6 +1857,9 @@
 {
 	register LPTSTR pszThousands;
 
+	if ( get_variable( NO_SEP ))	// the user doesn't want separators
+		return;			// (value of NO_SEP doesn't matter)
+
 	// format a long integer by inserting commas (or other
 	// character specified by country_info.szThousandsSeparator)
 	if (( *pszNumber == _TEXT('-') ) || ( *pszNumber == _TEXT('+') ))
@@ -1645,6 +1871,16 @@
 }
 
 
+#pragma alloc_text( _TEXT, BackQuotes )
+
+// avoid "No closing quote" if an LFN has embedded backquote(s): replace with ?
+void _fastcall BackQuotes( TCHAR _far * pszFileName )
+{
+	while ( (pszFileName = _fstrchr( pszFileName, _TEXT('`') )) != NULL )
+		*pszFileName = _TEXT('?');
+}
+
+
 int _fastcall AddQuotes( LPTSTR pszFileName )
 {
 	// adjust for an LFN name with embedded whitespace
@@ -1652,6 +1888,7 @@
 	if (( *pszFileName != _TEXT('"') ) && ( strpbrk( pszFileName, " \t,=+<>|`" ) != NULL )) {
 		strins( pszFileName, _TEXT("\"") );
 		strcat( pszFileName, _TEXT("\"") );
+		BackQuotes( pszFileName );	// replace embedded `s if any
 		return 1;
 	}
 
@@ -1692,7 +1929,7 @@
 {
 
 	LPTSTR pszArg;
-	TCHAR szTemp[MAXFILENAME+1], *pszSource, *pszCurrentDir = NULLSTR, *pszName;
+	TCHAR szTemp[MAXFILENAME+32], *pszSource, *pszCurrentDir = NULLSTR, *pszName;
 	unsigned int uMode;
 
 	if ( pszFileName != NULL )
@@ -1840,7 +2077,7 @@
 // return non-zero if the specified file exists
 int _fastcall is_file( LPTSTR pszFileName )
 {
-	TCHAR szName[MAXFILENAME+1];
+	TCHAR szName[MAXFILENAME + 32];	// expanded filename
 	FILESEARCH dir;
 
 	copy_filename( szName, pszFileName );
@@ -1968,6 +2205,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, executable_ext )
+
 // check for user defined executable extension
 //   (kinda kludgy in order to support wildcards)
 TCHAR _far * _fastcall executable_ext( LPTSTR pszExtension )
@@ -2061,6 +2300,11 @@
 
 		} else if (( fWildBrackets ) && ( *fpWildName == _TEXT('[') ) && ( fWildStar == 0 )) {
 
+			if ( *fpFileName == _TEXT('[') ) {	// literal '['
+				fpWildName++;
+				fpFileName++;
+				continue;
+			}
 			// [ ] checks for a single character (including ranges)
 			if ( wild_brackets( fpWildName++, *fpFileName, TRUE ) != 0 )
 				break;
@@ -2082,7 +2326,7 @@
 
 					if (( *fpFileName == _TEXT('.') ) && ( fExtension )) {
 
-						if ( fWin95 == 0 )
+						if ( ifs_type(NULL) == 0 && ( glDirFlags & DIRFLAGS_LFN ) == 0 )
 							break;
 
 						if ( *fpWildName == _TEXT('.') ) {
@@ -2104,6 +2348,11 @@
 
 					if ( *fpWildName == _TEXT('[') ) {
 
+						if ( *fpFileName == _TEXT('[') ) {	// literal '['
+							fpWildName++;
+							fpFileName++;
+							continue;
+						}
 						// get the first matching char
 						if ( wild_brackets( fpWildName, *fpFileName, TRUE ) == 0 ) {
 
@@ -2237,12 +2486,14 @@
 //	1 - US
 //	2 - European
 //	3 - yy/mm/dd
-//	4 - yyyy/mm/dd
+//	4 - yyyy-mm-dd (ISO)
+//	5 - yyyy-Www-d (ISO week date)
+//	6 - yyyy-ddd (ISO ordinal date)
 //	0x100 - use 4-digit year
-LPTSTR FormatDate( int nMonth, int nDay, register int nYear, int nFormat )
+LPTSTR FormatDate( int nMonth, int nDay, int nYear, int nFormat )
 {
-	static TCHAR szDate[14];
-	register int i;
+	static TCHAR szDate[24];
+	int i, n;
 
 	if ( nFormat & 0x100 ) {
 		if ( nYear < 79 )
@@ -2253,7 +2504,7 @@
 
 	} else {
 		// make sure year is only 2 digits
-		if ( nFormat == 4 ) {
+		if ( nFormat >= 4 && nFormat <= 6 ) {
 			if ( nYear < 79 )
 				nYear += 2000;
 			else if ( nYear < 200 )
@@ -2268,6 +2519,21 @@
 		sprintf( szDate, _TEXT("%4u-%02u-%02u"), nYear, nMonth, nDay );
 		return szDate;
 
+	} else if ( nFormat == 5 ) {
+
+		// ISO week date = yyyy-Www-d
+		i = ISOweekDOY( &nDay, nMonth, &nYear, &i );
+		sprintf( szDate, _TEXT("%4u-W%02u-%u"), nYear, i, nDay );
+		return szDate;
+
+	} else if ( nFormat == 6 ) {
+
+		// ISO ordinal date = yyyy-ddd
+		n = nYear; // nYear may be changed below!
+		ISOweekDOY( &nDay, nMonth, &nYear, &i );
+		sprintf( szDate, _TEXT("%4u-%03u"), n, i );
+		return szDate;
+
 	} else if ((( nFormat == 0 ) && ( gaCountryInfo.fsDateFmt == 1 )) || ( nFormat == 2 )) {
 
 		// Europe = dd-mm-yy
@@ -2289,6 +2555,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, honk )
+
 // honk the speaker (but shorter & more pleasantly than COMMAND.COM)
 void honk( void )
 {
@@ -2305,6 +2573,9 @@
 }
 
 
+void _fastcall PopupEnvironment( int );
+
+#pragma alloc_text( SCREENIO_TEXT, PopupEnvironment )
 
 void _fastcall PopupEnvironment( int fAlias )
 {
@@ -2393,6 +2664,8 @@
 }
 
 
+#pragma alloc_text( _TEXT, stristr )
+
 // do a case-insensitive strstr()
 LPTSTR _fastcall stristr( LPTSTR pszStr1, LPTSTR pszStr2 )
 {
@@ -2427,6 +2700,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, strend )
+
 // return a pointer to the end of the string
 LPTSTR _fastcall strend( LPTSTR pszString )
 {
@@ -2441,6 +2716,46 @@
 }
 
 
+#pragma alloc_text( ASM_TEXT, similar_char, similar_text )
+
+// 20 bytes of stack usage on each recursion (_fastcall doesn't help)
+static int _near similar_char( char *s1, int l1, char *s2, int l2 )
+{
+	int maximum = 0, pos1 = 0, pos2 = 0, n;
+	static char *p1, *p2;
+
+	for ( p1 = s1; p1 < s1 + l1; p1 ++ ) {
+		for ( p2 = s2; p2 < s2 + l2; p2 ++ ) {
+			for ( n = 0; p1 + n < s1 + l1 && p2 + n < s2 + l2 && p1[n] == p2[n]; n++ )
+				;
+			if ( maximum < n ) {
+				maximum = n;
+				pos1 = p1 - s1;
+				pos2 = p2 - s2;
+			}
+		}
+	}
+	if ( maximum == 0 )
+		return 0;
+	n = maximum;
+	CheckFreeStack( MIN_STACK );
+	if ( pos1 && pos2)
+		n += similar_char( s1, pos1, s2, pos2 );
+	if ( pos1 + maximum < l1 && pos2 + maximum < l2 )
+		n += similar_char( s1 + pos1 + maximum, l1 - pos1 - maximum, s2 + pos2 + maximum, l2 - pos2 - maximum );
+	return n;
+}
+
+
+// String similarity percentage (thanks to the PHP group for this method!)
+int _fastcall similar_text( LPTSTR s1, LPTSTR s2 )
+{
+	return similar_char( s1, strlen(s1), s2, strlen(s2) ) * 200 / ( strlen(s1) + strlen(s2) );
+}
+
+
+#pragma alloc_text( SCREENIO_TEXT, more_page )
+
 // write a long line to STDOUT & check for screen paging
 void _fastcall more_page( TCHAR _far *pszStart, int nColumn )
 {
@@ -2476,6 +2791,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, incr_column )
+
 // increment the column counter
 void _fastcall incr_column( TCHAR cChar, int *puColumn )
 {
@@ -2486,28 +2803,40 @@
 }
 
 
-long _fastcall GetRandom( long lStart, long lEnd )
-{
-	// return random value
-	static unsigned long lRandom = 1L;
-	DATETIME sysDateTime;
-
-	// set seed to random value based on initial time
-	if ( lRandom == 1L ) {
-		QueryDateTime( &sysDateTime );
-		lRandom *= (long)( sysDateTime.seconds * sysDateTime.hundredths );
-	}
-
-	lEnd++;
-	lEnd -= lStart;
-
-	lRandom = (( lRandom * 214013L ) + 2531011L );
-	lRandom = ( lRandom << 16 ) | ( lRandom >> 16 );
+#pragma alloc_text( ASM_TEXT, GetRandom )
 
-	return (( lRandom % lEnd ) + lStart );
+// Xorshift7 RNG; period 2^256-1. Thanks to George Marsaglia,
+// Francois Panneton and Pierre L'Ecuyer for this alrorithm!
+ULONG _fastcall GetRandom( void )
+{
+	static ULONG x[8]; // Generator's state
+	static BOOL fSeeded = 0;
+	static BYTE k = 0;
+	register ULONG y, t;
+
+	if ( !fSeeded ) { // seed to hundredths of seconds since start of year
+		int i;
+		DATETIME sysDateTime;
+		QueryDateTime( &sysDateTime );	// seed to hundredths of seconds since New Year (range: 0 to 3214080000; harmless 1- to 3-day holes for short months)
+		x[0] = ((((( sysDateTime.month - 1 ) * 31L + ( sysDateTime.day - 1 )) * 24L + sysDateTime.hours ) * 60L + sysDateTime.minutes ) * 60L + sysDateTime.seconds ) * 100L + sysDateTime.hundredths;
+		for ( i = 0; i < 7; i++ ) // MSC linear congruential generator
+			x[i+1] = x[i] * 214013 + 2531011;
+		fSeeded++;
+	}
+	t = x[k+7 & 7];	t ^= t<<13; y  = t ^ t<<9;
+	t = x[k+4 & 7];		    y ^= t ^ t<<7;
+	t = x[k+3 & 7];		    y ^= t ^ t>>3;
+	t = x[k+1 & 7];		    y ^= t ^ t>>10;
+	t = x[k];	t ^= t>>7;  y ^= t ^ t<<24;
+
+	x[k++] = y;
+	k &= 7;
+	return y;
 }
 
 
+#pragma alloc_text( _TEXT, OffOn )
+
 // Return a 0 if the arg == "OFF", 1 if == "ON", -1 otherwise
 int _fastcall OffOn( LPTSTR pszToken )
 {
@@ -2521,6 +2850,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, GetCursorRange )
+
 // get cursor position request, adjust if relative, & check for valid range
 int PASCAL GetCursorRange( LPTSTR pszCursor, int *puRow, int *puColumn )
 {
@@ -2573,7 +2904,7 @@
 				SetBorderColor( nFG );
 
 				// skip the border color name
-				ntharg( pszCurrent, 0x8002 );
+				ntharg( pszCurrent, (int)0x8002 );
 			}
 		}
 
@@ -2586,6 +2917,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, set_colors )
+
 // if ANSI, send an ANSI color set sequence to the display; else, twiddle the
 //   screen attributes directly
 void _fastcall set_colors( int nColor )
@@ -2620,7 +2953,7 @@
 			break;
 
 		// skip BRIGHT or BLINK
-		pszColors = (( ntharg( pszColors, 0x8001 ) != NULL ) ? gpNthptr : NULLSTR);
+		pszColors = (( ntharg( pszColors, (int)0x8001 ) != NULL ) ? gpNthptr : NULLSTR);
 	}
 
 	// check for foreground color match
diff -Nu d:7.501/mkdos.btm SOURCES/mkdos.btm
--- d:7.501/mkdos.btm	2003-01-11 15:06:12 +0200
+++ SOURCES/mkdos.btm	2008-11-04 21:45:44 +0200
@@ -2,13 +2,13 @@
 :
 :  Compile 4DOS with MSC7
 :
-call mkproc 4dos 4dos.com msc7 dos bp Y %&
+call mkproc 4dos 4dos.com msc7 dos bp NONE %&
 :
 :  Compile BATCOMP with MSC7
 :
-: call mkproc batcomp batcomp.exe msc7 dos bp Y %&
+call mkproc batcomp batcomp.exe msc7 dos bp NONE %&
 :
 :  Compile KSTACK with MASM6
 :
-call mkproc kstack kstack.com msc7 dos bp Y %&
+call mkproc kstack kstack.com msc7 dos bp NONE %&
 
diff -Nu d:7.501/mkproc.btm SOURCES/mkproc.btm
--- d:7.501/mkproc.btm	2003-03-23 19:36:36 +0200
+++ SOURCES/mkproc.btm	2008-11-04 13:18:40 +0200
@@ -56,7 +56,7 @@
 :     Do the build; if it fails, make noise and quit
 :
 :buildit
-nmake %_basename _LANGUAGE=%_language _FAMILY=%_family %@if[%_beta == Y,_BETA=Y, ] 
+nmake /nologo /s %_basename _LANGUAGE=%_language _FAMILY=%_family %@if[%_beta == Y,_BETA=Y, ] 
 set _saveerr=%?
 
 iff exist %_objdir\savedate.dat then
diff -Nu d:7.501/mktime.c SOURCES/mktime.c
--- d:7.501/mktime.c	1970-01-01 02:00:00 +0200
+++ SOURCES/mktime.c	2007-07-03 13:37:06 +0200
@@ -0,0 +1,69 @@
+/****************************************************************************
+*
+*                            Open Watcom Project
+*
+*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
+*
+*  ========================================================================
+*
+*    This file contains Original Code and/or Modifications of Original
+*    Code as defined in and that are subject to the Sybase Open Watcom
+*    Public License version 1.0 (the 'License'). You may not use this file
+*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
+*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
+*    provided with the Original Code and Modifications, and is also
+*    available at www.sybase.com/developer/opensource.
+*
+*    The Original Code and all software distributed under the License are
+*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
+*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
+*    NON-INFRINGEMENT. Please see the License for the specific language
+*    governing rights and limitations under the License.
+*
+*  ========================================================================
+*
+* Description:  Platform independent mktime() implementation.
+*
+****************************************************************************/
+
+#include "variety.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <limits.h>
+#include "rtdata.h"
+#include "timedata.h"
+
+_WCRTLINK time_t mktime( struct tm *t )
+{
+    long        days;
+    long        seconds;
+    long        day_seconds;
+
+    seconds = __local_mktime( t, &days, &day_seconds );
+    __brktime( (unsigned long) days, (time_t) day_seconds, 0L, t );
+    tzset();
+    seconds += _RWD_timezone; /* add in seconds from GMT */
+#ifdef __LINUX__
+    if( t->tm_isdst < 0 )
+        __check_tzfile( seconds, t );
+#endif
+    /* if we are in d.s.t. then subtract __dst_adjust from seconds */
+    if( __isindst( t ) )  /* - determine if we are in d.s.t. */
+        seconds -= _RWD_dst_adjust;
+#ifdef __UNIX__               /* time_t is signed */
+    if( seconds < 0 )
+        return( ( time_t ) -1 );
+#else /* time_t is unsigned, special day check needed for 31 dec 1969 */
+    /* check for overflow; days == 75277 && seconds == 23296 returns 0, but
+       adjusted for dst may still be fine */
+    if( days >= 75279 ||
+        ( seconds >= 0 && days >= 75276 ) ||
+        ( seconds < 0 && days <= DAYS_FROM_1900_TO_1970 ) )
+        return( (time_t) -1 );
+    /* 0 is year = 206, mon = 1, mday = 7, hour = 6, min = 28, sec = 16 */
+#endif
+    return( ( time_t ) seconds );
+}
diff -Nu d:7.501/model.inc SOURCES/model.inc
--- d:7.501/model.inc	2001-12-26 11:43:26 +0200
+++ SOURCES/model.inc	2008-11-04 13:03:58 +0200
@@ -471,7 +471,6 @@
   ELSE
 % .codeseg	@filename
   ENDIF
-% assume	cs:@codeseg
 endm
 .setname	macro n0,n1,n2,n3,n4,n5,n6,n7,n8,n9
   irp $name,<n0,n1,n2,n3,n4,n5,n6,n7,n8,n9>
diff -Nu d:7.501/msc7.btm SOURCES/msc7.btm
--- d:7.501/msc7.btm	2003-07-30 07:58:08 +0200
+++ SOURCES/msc7.btm	2006-11-29 09:46:56 +0200
@@ -1,7 +1,5 @@
 :
-: Set up environment for MSC 8 and MASM 6 (Rex's system, DOS only)
+: Append RTL source header directory (for "msdos.h")
 :
-path d:\tcmd\4dos750;d:\tcmd\sasm;d:\msvc\bin;d:\masm611\bin;%path
-set lib=d:\msvc\lib;d:\tcmd\4dos750;%lib
-set include=d:\msvc\include;d:\tcmd\sasm;%include
+set include=%include;C:\VC\SOURCE\MSVCCRT\H
 set _masm=ml
Common subdirectories: d:7.501/option and SOURCES/option
Files d:7.501/option.exe and SOURCES/option.exe differ
diff -Nu d:7.501/p5speed.asm SOURCES/p5speed.asm
--- d:7.501/p5speed.asm	1970-01-01 02:00:00 +0200
+++ SOURCES/p5speed.asm	2008-12-22 20:56:08 +0200
@@ -0,0 +1,161 @@
+; ---------------------------------------------------------------------------
+; P5SPEED.ASM  TMi0SDGL R2 CPU Speed Detection Routine           Version 2.15
+;
+; Too-Much-in-0ne-So-Don't-Get-Lost(tm) Revision 2 CPU/FPU Detection Library
+; Copyright(c) 1996-2000 by B-coolWare. Written by Bobby Z.
+; -----------------------------------------------------------------------------
+;
+; This module contains P5-specific clock speed detection routine using
+; Time Stamp Counter (TSC) and RDTSC instruction. It will only work on
+; processors that support TSC. Results under NT may be inconsistent because
+; this OS handles hardware timer in a different way than Win95. Also, OS/2
+; DOS Box session without HW_TIMER set to ON may be affected.
+
+; This code is mostly borrowed from Intel's CPUINFO freeware package and
+; rewritten for assembler (and optimized for 32-bit, because this code will
+; only be invoked on at least 32-bit CPU). Some division adjustments from
+; original CPUINFO were omitted.
+
+        INCLUDE HEADER.ASH
+
+        PUBLIC  getPentiumSpeed
+        PUBLIC  TSCDisabled
+
+SAMPLING_DELAY  equ  3500        ; how many timer ticks to run the test.
+_Loops          equ  8           ; how much times to sample speed.
+
+; --- Windows detection and critical section handling
+
+IFNDEF  __32bit__
+
+isUnderWin      proc near
+        mov     ax,1600h
+        int     2Fh
+        or      al,al
+        jz      @@nowin
+        cmp     al,80h
+        jz      @@nowin
+        stc
+        ret
+@@nowin:
+        clc
+        ret
+isUnderWin      endp
+
+winStartCritical        proc near
+        push    ax
+        call    IsUnderWin
+        jnc     @@Q
+        mov     ax,1681h
+        int     2Fh
+@@Q:
+        pop     ax
+        ret
+winStartCritical        endp
+
+winEndCritical          proc near
+        push    ax
+        call    IsUnderWin
+        jnc     @@Q
+        mov     ax,1682h
+        int     2Fh
+@@Q:
+        pop     ax
+        ret
+winEndCritical          endp
+
+ENDIF
+
+; --- grabTimer reads current clock value
+
+grabTime     proc near           ; read current hardware timer value
+        mov  al,10111000b        ; Channel 2, LSB+MSB, mode 4,
+        out  43h,al              ; binary
+        in   al,61h
+        or   al,1
+        out  61h,al
+
+        in   al,42h
+        mov  ah,al
+        in   al,42h
+        xchg al,ah
+        neg  ax
+
+        ret
+grabTime     endp
+
+        .386
+
+getPentiumSpeed proc DIST USES ebx ecx edx esi
+IFNDEF  __32bit__
+        call  WinStartCritical
+ENDIF
+        call  sampleSpeed       ; sample _Loops times and get an average
+        mov   esi,eax
+        REPT  (_Loops - 2)
+        call  sampleSpeed
+        add   esi,eax
+        ENDM
+        call  sampleSpeed
+        add   eax,esi
+IFNDEF  __32bit__
+        call  WinEndCritical
+ENDIF
+        clr   edx
+        mov   ebx,_Loops
+        div   ebx
+
+        ret
+getPentiumSpeed endp
+
+sampleSpeed   proc near
+LOCAL   hiTSC : DWORD
+@@10:
+        call  grabTime
+        cmp   ax,(0FFFFh-SAMPLING_DELAY) ; ensure we're not near overflow
+        jae   @@10                       ; resample timer if so
+        mov   bx,ax
+        _rdtsc          ; get current TSC
+        mov   ecx,eax
+        mov   hiTSC,edx
+@@1:                    ; allow enough ticks to pass
+        call  grabTime
+        sub   ax,bx
+        cmp   ax,SAMPLING_DELAY
+        jb    @@1
+        mov   bx,ax     ; save ticks elapsed
+        _rdtsc
+        sub   edx,hiTSC ; high dword of cycles passed
+        mov   hiTSC,edx ; save them
+        sub   eax,ecx
+        sbb   hiTSC,0
+        mov   ecx,eax
+
+        clr   eax
+        mov   ax,bx
+        mov   ebx,100000  ; convert ticks to microseconds
+        mul   ebx
+        mov   ebx,119318
+        div   ebx
+        cmp   edx,119318/2; adjust after division
+        jb    @@2
+        inc   eax
+@@2:
+        mov   ebx,eax     ; ebx = microseconds passed
+        mov   eax,ecx     ; eax = low part of cycles passed
+        mov   edx,hiTSC   ; edx:eax = cycles passed
+        div   ebx         ; eax = cycles/ticks = clock speed in MHz
+
+        inc   eax         ; adjust after division - always
+        ret
+sampleSpeed   endp
+
+TSCDisabled   proc DIST
+        _getcr4
+        and   eax,4       ; mask out TSD bit
+        shr   eax,2       ; and shift it to position 0
+        ret
+
+TSCDisabled   endp
+
+        END
diff -Nu d:7.501/parser.c SOURCES/parser.c
--- d:7.501/parser.c	2006-11-12 16:00:50 +0200
+++ SOURCES/parser.c	2008-11-30 12:59:46 +0200
@@ -83,13 +83,20 @@
 }
 
 
-// find 4START & 4EXIT
-void _near _fastcall find_4files( LPTSTR lpszFileName )
+// find and run _4INST.BTM, 4START or 4EXIT; return NULL if not found
+LPTSTR _near _fastcall find_4files( LPTSTR lpszFileName, BOOL fInstaller )
 {
 	register LPTSTR pszSearch;
 	int nSaveErrorLevel, nSaveCallFlag;
 	TCHAR _far *lpszComspec;
 
+	if ( fInstaller ) {
+		// try to find _4INST.BTM in the 4DOS directory
+		sprintf( gszCmdline, FMT_FAR_STR, _pgmptr );
+		insert_path( gszCmdline, lpszFileName, gszCmdline );
+		goto find_it;
+	}
+
 	// first, check .INI data for FSPath (no fallback - the file
 	//   HAS to be there or it will be ignored)
 
@@ -116,7 +123,7 @@
 
 		// get startup disk for 4START and 4EXIT
 		sprintf( gszCmdline, _TEXT("%c:\\%s"), gpIniptr->BootDrive, lpszFileName );
-		pszSearch = searchpaths( gszCmdline, NULL, TRUE, NULL );
+find_it:	pszSearch = searchpaths( gszCmdline, NULL, TRUE, NULL );
 	}
 
 	if ( pszSearch != NULL ) {
@@ -143,6 +150,7 @@
 		cv.fCall = nSaveCallFlag;
 		gnErrorLevel = nSaveErrorLevel;
 	}
+	return pszSearch;
 }
 
 
@@ -831,8 +839,12 @@
 	// delete any leftover temporary pipes (DOS only)
 	killpipes( &redirect );
 
-	if ( fOptions & 1 )
-		crlf();
+	if ( fOptions & 1 ) {
+		int nRow, nCol;
+		GetCurPos( &nRow, &nCol );
+		if ( nRow || nCol || !QueryIsConsole( STDOUT ))
+			crlf();	// if screen just cleared, no LF before prompt
+	}
 
 	if ( fStep )
 		fStepOver = 0;
@@ -1482,7 +1494,8 @@
 			pszPATH += n;
 
 		// make new directory search name
-		mkdirname( szFileName, fname_part( pszFile ));
+		if ( mkdirname( szFileName, fname_part( pszFile )))
+			goto next_path;
 
 		// make sure specified drive is ready
 		if (( is_net_drive( szFileName ) == 0 ) && ( QueryDriveReady( gcdisk( szFileName )) == 0 ))
@@ -1491,6 +1504,8 @@
 }
 
 
+#pragma alloc_text( SCREENIO_TEXT, ShowPrompt )
+
 // display the DOS / OS2 command line prompt
 void ShowPrompt( void )
 {
@@ -1501,10 +1516,12 @@
 	if (( gnCurrentDisk = _getdrive()) < 0 )
 		gnCurrentDisk = 0;
 
+#ifdef SHAREWARE_VERSION
 	// Decrement command counter for restricted usage (actually increment,
 	// since it is negative)
 	if ( glExpDate < 0L )
 		glExpDate += SW_RESTRICT_CMDMUL;
+#endif
 
 	// get prompt from environment, or use default if none
 	if (( lpszPrompt = get_variable( PROMPT_NAME )) != 0L ) {
@@ -1533,6 +1550,7 @@
 
 		szTitle[ 79 ] = '\0';
 		Win95SetTitle( szTitle );
+		ServTtl( szTitle, 1 );
 	}
 }
 
@@ -1547,6 +1565,7 @@
 	DATETIME sysDateTime;
 	char _far *lpTemp;
 	char szDrive[8];
+	int iChar;
 
 	*pszBuffer = _TEXT('\0');
 	for ( ; ( *pszPrompt != _TEXT('\0') ); pszPrompt++ ) {
@@ -1554,7 +1573,11 @@
 		if (( *pszPrompt == _TEXT('$') ) && ( pszPrompt[1] )) {
 
 			// special character follows a '$'
-			switch ( _ctoupper( *(++pszPrompt ) )) {
+			switch ( iChar = _ctoupper( *(++pszPrompt ) )) {
+
+			case _TEXT('A'):	// ampersand
+				*pszBuffer++ = _TEXT('&');
+				break;
 
 			case _TEXT('B'):	// vertical bar
 				*pszBuffer++ = _TEXT('|');
@@ -1607,9 +1630,10 @@
 				// ignore $i in TCMD & 4NT
 				break;
 
-			case _TEXT('J'):	// current date, 4-year ISO format (2002-07-04)
+			case _TEXT('J'):	// current date, four-year ISO format (2002-07-04)
+			case _TEXT('K'):	// current date, ISO week date format (2002-W27-4)
 				QueryDateTime( &sysDateTime );
-				pszBuffer += sprintf( pszBuffer, FMT_STR, FormatDate( sysDateTime.month, sysDateTime.day, sysDateTime.year, 4 ));
+				pszBuffer += sprintf( pszBuffer, FMT_STR, FormatDate( sysDateTime.month, sysDateTime.day, sysDateTime.year, iChar - _TEXT('J') + 4 ));
 				break;
 
 			case _TEXT('L'):
diff -Nu d:7.501/pci.inc SOURCES/pci.inc
--- d:7.501/pci.inc	1970-01-01 02:00:00 +0200
+++ SOURCES/pci.inc	2008-12-22 20:20:28 +0200
@@ -0,0 +1,87 @@
+; Cyrix detection on 440BX chipset workaround code
+; uses PCI BIOS 2.0c+ calls to detect 440BX and apply workaround if found
+
+BX_Cyrix_Workaround_Start       proc near
+LOCAL   dev : Word
+        .386
+IFDEF   __debug__
+        push    dx
+        lea     dx, BXWAS
+        call    printDebug
+        pop     dx
+ENDIF
+        mov     ax,0B101h       ; get PCI BIOS version
+        clr     edi
+        int     1Ah
+        test    ah,ah           ; ah is set to 0 if PCI BIOS present
+        jnz     @@noPCI
+        mov     ax,0B102h       ; find PCI device
+        mov     cx,7190h        ; 82443BX id #1
+        mov     dx,8086h        ; Intel
+        clr     si              ; device 0
+        int     1Ah
+        jnc     @@Configure
+        mov     ax,0B102h       ; find PCI device
+        mov     cx,7192h        ; 82443BX id #2 (only one of these may present)
+        mov     dx,8086h        ; Intel
+        clr     si              ; device 0
+        int     1Ah
+        jc      @@noPCI
+@@Configure:
+        mov     dev,bx          ; save bus/device/function
+        mov     ax,0B108h       ; read configuration byte
+        mov     di,7Ah          ; PMSR index in configuration space
+        int     1Ah
+        jc      @@noPCI         ; error occured
+        test    cl,40h          ; bit 6 set?
+        jz      @@noPCI         ; not set, no need to reprogram
+        mov     al,cl
+        mov     ah,1            ; data read ok
+        push    ax
+        and     cl, (not 40h)   ; reset bit 6 of PMSR
+                                ; I/O port 22h data forwarded to PCI bus
+        mov     bx,dev
+        mov     ax,0B10Bh       ; write configuration byte
+        mov     di,7Ah          ; PMSR index in configuration space
+        int     1Ah
+        pop     ax              ; ah set to 1 if data read from 440BX
+                                ; al then contains original PMSR state
+        jmp     @@Q
+@@noPCI:
+        clr     ax
+@@Q:
+        ret
+BX_Cyrix_Workaround_Start       endp
+
+BX_Cyrix_Workaround_End         proc near
+LOCAL   PMSR : Byte
+IFDEF   __debug__
+        push    dx
+        lea     dx, BXWAE
+        call    printDebug
+        pop     dx
+ENDIF
+        test    ah,ah           ; on entry ah = 0|1, al = PMSR if ah = 1
+        jz      @@Q
+        mov     PMSR,al
+        mov     ax,0B102h
+        mov     cx,7190h        ; 82443BX id #1
+        mov     dx,8086h        ; Intel
+        clr     si              ; device 0
+        int     1Ah
+        jnc     @@Configure
+        mov     ax,0B102h       ; find PCI device
+        mov     cx,7192h        ; 82443BX id #2 (only one of these may present)
+        mov     dx,8086h        ; Intel
+        clr     si              ; device 0
+        int     1Ah
+        jc      @@Q
+@@Configure:
+        mov     ax,0B10Bh       ; restore configuration
+                                ; bx already has bus/device/function
+        mov     cl,PMSR
+        mov     di,7Ah          ; PMSR index in configuration space
+        int     1Ah
+@@Q:
+        ret
+BX_Cyrix_Workaround_End         endp
diff -Nu d:7.501/proto.h SOURCES/proto.h
--- d:7.501/proto.h	2006-11-12 16:00:50 +0200
+++ SOURCES/proto.h	2009-02-26 16:17:12 +0200
@@ -45,10 +45,13 @@
 
 int _near Chcp_Cmd( LPTSTR );
 
+int _near Closetray_Cmd( LPTSTR );
 int _near Cls_Cmd( LPTSTR );
+#pragma alloc_text( _TEXT, Cls_Cmd )
 int _near Cmds_Cmd( LPTSTR );
 int _near Color_Cmd( LPTSTR );
 int _near Copy_Cmd( LPTSTR );
+int _near Country_Cmd( LPTSTR );
 
 int _near Ctty_Cmd( LPTSTR );
 
@@ -69,11 +72,13 @@
 int _near EchoErr_Cmd( LPTSTR );
 int _near Echos_Cmd( LPTSTR );
 int _near EchosErr_Cmd( LPTSTR );
+int _near Ejectmedia_Cmd( LPTSTR );
 int _near Endlocal_Cmd( LPTSTR );
 int _near Eset_Cmd( LPTSTR );
 int _near Eventlog_Cmd( LPTSTR );
 int _near Except_Cmd( LPTSTR );
 int _near Exit_Cmd( LPTSTR );
+#pragma alloc_text( _TEXT, Exit_Cmd )
 int _near External( LPTSTR, LPTSTR );
 int _near Ffind_Cmd( LPTSTR );
 int _near For_Cmd( LPTSTR );
@@ -86,6 +91,7 @@
 int _near Head_Cmd( LPTSTR );
 int _near Help_Cmd( LPTSTR );
 int _near History_Cmd( LPTSTR );
+int _near Idle_Cmd( LPTSTR );
 int _near If_Cmd( LPTSTR );
 int _near Iff_Cmd( LPTSTR );
 
@@ -127,6 +133,7 @@
 int _near Scr_Cmd( LPTSTR );
 int _near Scrput_Cmd( LPTSTR );
 int _near Set_Cmd( LPTSTR );
+int _near Seterror_Cmd( LPTSTR );
 int _near Select_Cmd( LPTSTR );
 
 int _near Setdos_Cmd( LPTSTR );
@@ -143,8 +150,10 @@
 int _near Tee_Cmd( LPTSTR );
 int _near Time_Cmd( LPTSTR );
 int _near Timer_Cmd( LPTSTR );
+int _near Title_Cmd( LPTSTR );
 
 int _near Touch_Cmd( LPTSTR );
+int _near Transient_Cmd( LPTSTR );
 int _near Tree_Cmd( LPTSTR );
 int _near Truename_Cmd( LPTSTR );
 int _near Type_Cmd( LPTSTR );
@@ -187,6 +196,11 @@
 void ColorizeDirectory( DIR_ENTRY _huge *, unsigned int, int );
 int PASCAL fstrcmp( TCHAR _far *, TCHAR _far *, int );
 int PASCAL SearchDirectory( long, LPTSTR, DIR_ENTRY _huge **, unsigned int *, RANGES *, int );
+void Add32To64( t_int64 *, unsigned long );
+void Add64To64( t_int64 *, t_int64 * );
+void Subtract64From64( t_int64 *, t_int64 * );
+LPTSTR Divide64By64( t_int64 *, t_int64 *, int, int );
+LPTSTR Format64( t_int64 * );
 
 
 // ENV.C
@@ -257,11 +271,11 @@
 void PASCAL _box( int, int, int, int, int, int, int, int, int );
 int  _fastcall verify_row_col( unsigned int, unsigned int );
 
-// MD5.C
-extern void MD5Hash(char *, unsigned int, char *);
-
 // MISC.C
+LPTSTR LCS( LPTSTR, LPTSTR );
+int CompareFiles( LPTSTR, LPTSTR );
 unsigned long _fastcall CRC32( LPTSTR );
+int MD5SHA1( LPTSTR, TCHAR ucDigest[16], int fSHA );
 int PASCAL GetFileLine( LPTSTR, long *, LPTSTR );
 
 long _fastcall QuerySeekSize( int );
@@ -272,6 +286,7 @@
 int  _fastcall isdelim( TCHAR );
 int  _fastcall QueryIsNumeric( LPTSTR);
 int  _fastcall QueryIsCON( LPTSTR);
+int  _fastcall QueryIsPRN( LPTSTR);
 LPTSTR  _fastcall skipspace( LPTSTR);
 LPTSTR GetToken( LPTSTR, LPTSTR, int, int );
 LPTSTR  _fastcall first_arg( LPTSTR);
@@ -287,6 +302,7 @@
 int GetStrDate( LPTSTR, unsigned int *, unsigned int *, unsigned int * );
 int _fastcall MakeDaysFromDate(long *, LPTSTR );
 int MakeDateFromDays(long, unsigned int *, unsigned int *, unsigned int * );
+int _near ISOweekDOY( int *, int, int *, int * );
 void  _fastcall collapse_whitespace( LPTSTR, LPTSTR );
 void  _fastcall strip_leading( LPTSTR, LPTSTR );
 void  _fastcall strip_trailing( LPTSTR, LPTSTR );
@@ -303,6 +319,7 @@
 void  _fastcall copy_filename( LPTSTR, LPTSTR);
 void _fastcall AddCommas( LPTSTR );
 void _fastcall StripQuotes( LPTSTR );
+void _fastcall BackQuotes( TCHAR _far * );
 int _fastcall AddQuotes( LPTSTR );
 int _fastcall mkdirname( LPTSTR, LPTSTR );
 LPTSTR _fastcall mkfname( LPTSTR, int );
@@ -323,9 +340,10 @@
 LPTSTR _fastcall strins( LPTSTR, LPTSTR );
 LPTSTR _fastcall strend( LPTSTR );
 LPTSTR _fastcall strlast( LPTSTR );
+int _fastcall similar_text( LPTSTR, LPTSTR );
 void _fastcall more_page( TCHAR _far *, int );
 void _fastcall incr_column( TCHAR, int * );
-long _fastcall GetRandom( long, long );
+ULONG _fastcall GetRandom( void );
 int _fastcall OffOn( LPTSTR );
 int PASCAL GetCursorRange( LPTSTR, int *, int *);
 int _fastcall GetColors( LPTSTR, int );
@@ -343,15 +361,17 @@
 
 // PARSER.C
 int PASCAL DoINT2E( TCHAR _far * );
-void _near _fastcall find_4files( LPTSTR );
+LPTSTR _near _fastcall find_4files( LPTSTR, BOOL );
 int _near BatchCLI( void );
 int open_batch_file( void );
 void close_batch_file( void );
 
 int PASCAL getline( int, LPTSTR, int, int );
 int _near _fastcall command( LPTSTR, int );
+#pragma alloc_text( _TEXT, command )
 extern int _near _fastcall ContinueLine( LPTSTR );
 int _near ParseLine( LPTSTR, LPTSTR, int (_near *)(LPTSTR), unsigned int, int );
+#pragma alloc_text( _TEXT, ParseLine )
 LPTSTR PASCAL searchpaths( LPTSTR, LPTSTR, int, int * );
 void ShowPrompt( void );
 
@@ -410,7 +430,7 @@
 void _pascal ServInit( LPTSTR, INIFILE *);
 int _pascal ServExec( LPTSTR, LPTSTR, unsigned int, int, int *);
 int _pascal ServCtrl( unsigned int, int );
-void _pascal ServTtl( char _far * );
+void _pascal ServTtl( char _far *, int );
 
 // ServCtrl function codes
 #define SERV_QUIT 0
@@ -421,8 +441,8 @@
 #define SERV_AVAIL 5
 #define SERV_UREG 6
 #define SERV_SIGNAL 7
-#define SERV_SIG_DISABLE 0xFFFE	// disable signal code
-#define SERV_SIG_ENABLE 0xFFFD	// enable signal code
+#define SERV_SIG_DISABLE (-2)	// disable signal code
+#define SERV_SIG_ENABLE (-3)	// enable signal code
 
 
 // DOSCALLS.C
@@ -438,12 +458,13 @@
 void _far * PASCAL AllocMem( unsigned int *);
 void _far * PASCAL ReallocMem( void _far *, unsigned long );
 extern char _far * PASCAL AllocHigh( char _far *, unsigned long );
-void HoldSignals( void );
-void EnableSignals( void );
+void _cdecl HoldSignals( void );
+void _cdecl EnableSignals( void );
+ULONG _near GetMs( void );
 void  _fastcall SysWait( unsigned long, int );
-int PASCAL is_signed_digit( int );
-int PASCAL is_unsigned_digit( int );
-int QuerySystemRAM( void );
+int _fastcall is_signed_digit( char );
+int _fastcall is_unsigned_digit( char );
+char _far * GetDMIstring( BYTE, int );
 int ifs_type( LPTSTR );
 void  QueryDateTime( DATETIME * );
 int  SetDateTime( DATETIME * );
@@ -452,8 +473,11 @@
 #endif
 int  _fastcall SetFileDateTime( LPTSTR, int, DATETIME *, int );
 long QueryFileSize( LPTSTR, int );
+int QueryFileSize64( LPTSTR, int, t_int64 * );
 int QueryCodePage( void );
+int QueryDeviceCodePage( LPTSTR );
 LPTSTR QueryVolumeInfo( LPTSTR, LPTSTR, unsigned long *);
+int QueryDriveType( LPTSTR );
 int QueryIsANSI( void );
 int PASCAL QueryIsDevice( LPTSTR);
 LPTSTR true_name( LPTSTR, LPTSTR);
@@ -461,7 +485,6 @@
 int GetShortName( LPTSTR);
 void QueryCountryInfo( void );
 void SetOSVersion( void );
-int  _fastcall _ctoupper( int );
 int QueryDiskInfo( LPTSTR, QDISKINFO *, int );
 int QueryIsPipeName( LPTSTR );
 int UniqueFileName( LPTSTR );
@@ -469,8 +492,9 @@
 int PASCAL FileTimeToDOSTime( PFILETIME, USHORT *, USHORT * );
 void SetWin95Flags(void);
 #if _DOS
+#ifdef SHAREWARE_VERSION
 void AccessSharewareData( SHAREWARE_DATA *, int );
-void GetMachineName( LPTSTR );
+#endif
 #endif
 LPTSTR IniReadWrite( int, LPTSTR, LPTSTR, LPTSTR, LPTSTR );
 int MouseReset( void );
@@ -478,6 +502,7 @@
 
 // DOSINIT.C
 void _near InitOS( int, LPTSTR*);
+void _near ShowOS( void );
 void DisplayCopyright( void );
 
 
@@ -502,37 +527,62 @@
 
 
 // DOSUTIL.ASM -- combined ASM support for DOS and TCMD/16
+int _fastcall _ctoupper( int );
 char _pascal QuerySwitchChar( void );
+void _pascal SetSwitchChar( char );
 int _pascal QueryVerifyWrite( void );
 void _pascal SetVerifyWrite( int );
+void _far * _pascal GetIdlePtr( void );
 void _pascal CheckForBreak( void );
+int _pascal GetFontPage( void );
 int _pascal SetCodePage( int );
+int _pascal SetCountry( int );
 int _pascal DosError( int );
+void _pascal SetExtError( int );
 LPTSTR _pascal GetError( int, LPTSTR );
 void _pascal GetDOSVersion( void );
+int _pascal InstalledCheck( int );
+int _pascal PowerInstalled( void );
+BYTE _pascal NetworkInstalled( void );
+void _pascal GetMachineName( LPTSTR );
 void _pascal reset_disks( void );
 void _pascal SDFlush( void );
 int _pascal ForceDelete( LPTSTR );
 void _pascal SetIOMode( int, int );
 int _pascal _dos_createEA( LPTSTR, int, LPTSTR, int *, unsigned int, unsigned int );
 int _pascal QueryIsConsole( int );
-int QueryMouseReady( void );
+long _pascal CDIOctl( int, int );
+void _far * _pascal GetDPB( int );
+void _pascal GetHDDParams( int, LBA * );
+int _pascal GetDrivePhysUnit( int );
+int _cdecl QueryMouseReady( void );
 int _pascal QueryDriveRemovable( int );
 int _pascal QueryDriveReady( int );
 int _pascal QueryDriveExists( int );
 int _pascal QueryDriveRemote( int );
-int _pascal QueryIsCDROM( LPTSTR );
+int _pascal QueryIsCDROM( int );
 int _pascal QueryPrinterReady( int );
-unsigned int get_cpu( void );
-unsigned int get_ndp( void );
+int _pascal QuerySerialReady( int );
+int _pascal GetSBDSPver( void );
+int _pascal InV86mode( void );
+unsigned int _cdecl get_cpu( void );
+unsigned int _cdecl get_ndp( void );
+unsigned int _pascal get_cpu_brand( char * );
+int _pascal QuerySystemRAM( void );
 unsigned int _pascal get_expanded( unsigned int *);
-unsigned int get_extended( void );
-unsigned int _pascal get_xms( unsigned int *);
-int bios_key( void );
+unsigned long _cdecl get_extended( void );
+unsigned long _pascal get_xms( unsigned int *);
+unsigned int _cdecl bios_shiftstate( void );
+int _cdecl bios_kbhit( void );
+int _cdecl bios_key( void );
+int _cdecl bios_keystroke( void );
 int QueryMSDOS7( void );
 unsigned int _pascal DosBeep( unsigned int, unsigned int );
+LPTSTR _pascal GetDDCstring( int, LPTSTR );
 void _pascal GetCurPos(int *, int * );
 void _pascal SetCurPos( int, int );
+void _pascal HideCursor( void );
+int _pascal QuerySVGA( void );
 unsigned int _pascal GetVideoMode( void );
 unsigned int _pascal GetCellSize( int );
 void _pascal GetAtt( unsigned int *, unsigned int *);
@@ -558,4 +608,21 @@
 long _pascal QueryClipSize( void );
 void _pascal ReadClipData( char _far * );
 void _pascal SetClipData( char _far *, long );
-
+unsigned long _pascal Divide64By32( t_int64 *, unsigned long );
+void _pascal ShiftLeft16( t_int64 * );
+void _pascal SetTimerMode2( void );
+unsigned int _pascal GetTimer( void );
+void _pascal GetTimeStamp( t_int64 * );
+void _pascal GetTSC( t_int64 * );
+unsigned long _pascal GetWinMs( void );
+void _pascal MonitorOnOff( char );
+void _pascal SetPowerState( int );
+void _pascal RebootW9x( void );
+void _pascal RebootOS2( int );
+void _pascal Reboot( char );
+
+
+// CPUTYPE.C
+LPTSTR _pascal cpu_Type( void );
+LPTSTR _pascal fpu_Type( void );
+int _pascal cpu_Speed( void );
diff -Nu d:7.501/realcode.asm SOURCES/realcode.asm
--- d:7.501/realcode.asm	1970-01-01 02:00:00 +0200
+++ SOURCES/realcode.asm	2008-12-29 10:58:16 +0200
@@ -0,0 +1,1351 @@
+; ----------------------------------------------------------------------------
+; REALCODE.ASM - Real Mode Code for TMi0SDGL 2                    Version 2.15
+;
+; Too-Much-in-0ne-So-Don't-Get-Lost(tm) Revision 2 CPU/FPU Detection Library
+; Copyright(c) 1996-2000 by B-coolWare. Written by Bobby Z.
+; ----------------------------------------------------------------------------
+; This file contains low-level routines used in TMi0SDGL 2.
+;
+; global vars/procs/includes section -----------------------------------------
+;
+        INCLUDE HEADER.ASH
+
+;__debug__       = 1
+
+        PUBLIC  getCPUType              ; returns CPU index
+        PUBLIC  getFPUType              ; returns FPU index
+        PUBLIC  getCyrixModel           ; returns Cx486 model index
+        PUBLIC  CxCPUIDEnable           ; enables CPUID on Cyrix 5x86
+                                        ; and 6x86
+        PUBLIC  getL2CacheDesc          ; returns L2 cache descriptor for
+                                        ; Pentium Pro and Pentium II
+        PUBLIC  getCPUID                ; get CPUID values for specified lvl
+;       PUBLIC  isV86                   ; returns True if in V86 mode, False
+                                        ; otherwise
+;        PUBLIC  checkEMM386             ; detect if M$ EMM386 is present
+
+;
+; code section ---------------------------------------------------------------
+;
+
+IFDEF   __debug__
+printDebug      proc near
+        push    ax
+        mov     ah,09h
+        int     21h
+        pop     ax
+        ret
+printDebug      endp
+
+        .DATA
+
+CyrixMsg  db      'Checking for Cyrix...',13,10,'$'
+x86SLMsg  db      'Checking for x86SL...',13,10,'$'
+MSRsMsg   db      'Checking for IBM MSRS...',13,10,'$'
+BIOSMsg   db      'Checking for BIOS Extensions...',13,10,'$'
+CPUIDMsg  db      'Checking for CPUID...',13,10,'$'
+CxCPUID   db      'Enabling CPUID on Cyrix...',13,10,'$'
+BXWAS     db      'Entering Cyrix-on-440BX workaround...',13,10,'$'
+BXWAE     db      'Leaving Cyrix-on-440BX workaround...',13,10,'$'
+
+        .CODE
+ENDIF
+
+getCPUType      proc    DIST
+;
+; here's where all the low-level work done
+;
+        mov     cpu,i8088       ; assume 8088
+        call    _np check80286
+        jc      @@18x           ; not a 286+ - continue with 8x/18x/NEC
+        mov     cpu,i80286
+        call    _np check386
+        jc      @@Q             ; a 286 - stop
+        mov     cpu,i80386sx
+
+@@chkCT386:
+        call    _np checkCT38600
+        jc      @@386clones     ; AMD/Intel 386 POPAD bug detected - no need
+                                ; to check for 486+...
+        mov     cpu,ct38600
+
+@@chk486:
+        call    _np check486
+        jc      @@386clones     ; not a 486+ - check for other 386 clones
+        mov     cpu,i486sx
+
+@@cyrix:
+        call    checkCyrix      ; check if running on Cyrix CPU
+        jc      @@checkCPUID
+        mov     cpu,Cx486       ; assume Cx486
+;       call    CxCPUIDEnable   ; enable CPUID on Cx5x86 and 6x86, it's
+                                ; disabled by default. This is a bit dangerous
+                                ; but should not affect Cx486's
+        jmp     @@checkCPUID    ; try override this detection with CPUID
+
+        .386
+@@checkCPUID:
+IFDEF   __debug__
+        push    dx
+        lea     dx, CPUIDMsg
+        call    printDebug
+        pop     dx
+ENDIF
+        pushfd                  ; check if CPUID instruction is supported
+        pushfd
+        pop     eax
+        mov     ebx,eax
+        xor     eax,EF_ID       ; try flipping ID bit of EFLAGS
+        push    eax
+        popfd
+        pushfd
+        pop     eax
+        popfd
+        cmp     eax,ebx
+        jz      @@noCPUID            ; the bit was not flipped - no CPUID
+        or      extFlags,efCPUIDSupport
+        mov     eax,0C0000000h
+        _cpuid
+        cmp     eax,0C0000000h
+        jnz     @@notIDT
+        or      extFlags,efCentaurLevel ; this CPUID level only supported
+                                        ; by Centaur's WinChip
+@@notIDT:
+        clr     eax
+        _cpuid                   ; get detailed CPU info via CPUID
+        push    eax
+        and     eax,0FFFFFF00h
+        cmp     eax,000000500h   ; pre-B0 step Pentium workaround
+        pop     eax
+        jnz     @@okCPUID
+        mov     cpuid1,eax              ; simulate normal CPUID output
+        mov     _dp cpuid0,756E6547h    ; put GenuineIntel signature
+        mov     _dp cpuid0[4],49656E69h ; where it is expected to be
+        mov     _dp cpuid0[8],6C65746Eh
+        mov     _dp cpuBrand,0
+        clr     eax
+        inc     al                      ; and get feature flags
+        _cpuid
+        jmp     @@B0CPUID               ; then go on as usual
+@@okCPUID:
+        mov     _dp cpuid0,ebx
+        mov     _dp cpuid0[4],edx
+        mov     _dp cpuid0[8],ecx
+        clr     eax     ; this code assumes that every CPU implements CPUID
+        inc     al      ; at least to level 1...
+        _cpuid
+        mov     cpuid1,eax
+        and     ebx,0FFh
+        mov     cpuBrand,ebx
+@@B0CPUID:
+        mov     cpuFeatures,edx
+        test    dl,1
+        jz      @@10
+        or      extFlags,efHasFPUonChip
+@@10:
+        test    dl,10h
+        jz      @@101
+        or      extFlags,efTSCSupport
+@@101:
+        and     ax,0F00h        ; map out CPU family field
+        cmp     ah,4            ; family is 4 - 486?
+        jz      @@Q
+        mov     cpu,iPentium
+        cmp     ah,5            ; family is 5 - pentium?
+        jz      @@Q
+        mov     cpu,iPentiumPro
+        cmp     ah,6            ; family is 6 - pentium pro?
+        jz      @@Q
+        mov     cpu,iP7
+        cmp     ah,7
+        jz      @@Q
+        mov     cpu,iP8
+        jmp     @@Q
+@@18x:
+        call    _np check8018x     ; check for shift counter wrap
+        jc      @@2
+        mov     cpu,i80188
+        jmp     @@2_buf
+@@2:
+        call    _np checkNEC       ; check for true 808x rep es: lodsb bug
+        jc      @@2_buf
+        mov     cpu,necV20
+        ; this can be NEC or Intel CMOS-tech CPU, continue testing
+        call    _np check80C8x     ; check for AAD 16 undocumented opcode
+        jc      @@2_buf
+        mov     cpu,i80c88
+
+@@2_buf:
+        call    _np checkQueueSize ; detect CPU prefetch queue size to
+        jcxz    @@Q                ; distinguish 88 from 86
+        inc     cpu
+        jmp     @@Q
+
+@@386clones:
+        call    _np checkAm386
+        jc      @@chkNexGen
+        mov     cpu,am386sx
+        jmp     @@386sx
+
+@@chkNexGen:
+        call    _np checkNexGen
+        jc      @@tryBIOS
+        mov     cpu,Nx586
+        jmp     @@Q
+
+@@tryBIOS:
+        call    _np check_byBIOS  ; this routine will update cpu by itself
+        jnc     @@Q               ; and make terminal decision
+
+@@386SL:
+        mov     dh,3            ; check for 386SL
+        call    _np check_x86SL
+        jc      @@tryMSRs
+        mov     cpu,i386sl      ; 386SL - stop
+        jmp     @@Q
+
+@@tryMSRs:
+        call    _np checkIBMmsrs  ; this routine will update cpu by itself
+        jc      @@Q               ; unlike others, this routine sets CF on
+                                  ; successful detect
+@@386sx:
+        call    _np check386sx    ; distinguish SX/DX
+        jc      @@Q
+        inc     cpu
+        jmp     @@Q
+
+@@noCPUID:
+        cmp     cpu,Cx486
+        jz      @@Q
+
+        call    _np check_byBIOS  ; this routine will update cpu by itself
+        jnc     @@Q               ; and make terminal decision
+
+@@486SL:
+        mov     dh,4
+        call    check_x86SL
+        jc      @@MSRs3
+        mov     cpu,i486SL
+
+@@MSRs3:
+        call    checkIBMmsrs3     ; unlike others, this routine sets CF on
+        jc      @@Q               ; successful detect
+
+@@486sx:
+        call    check486sx
+        jc      @@Q
+        cmp     cpu,am486
+        jnz     @@1_
+        mov     cpu,am486dx
+        jmp     @@Q
+@@1_:
+        inc     cpu
+@@Q:
+        ret
+getCPUType      endp
+
+        .8086
+
+        db      13,10
+        db      'TMi0SDGL Revision 2 CPU/FPU Detection Library  Version 2.15',13,10
+        db      'Copyright(c) 1996-2000 by B-coolWare.   Written by Bobby Z.',13,10
+        db      13,10
+        db      'Simply the best...',13,10
+
+checkQueueSize  proc near
+; tests prefetch queue size on 88, 86, C88, C86, 188, 186, V20 and V30
+; returns cx = 0 -> x88, cx = 1 -> x86
+        push    es
+        push    di
+        mov     _bp cs:[@@0],41h        ; to make this routine reentrant
+        std
+        push    cs
+        pop     es
+        ldi     @@2
+        mov     al,_bp cs:[@@O1]
+        mov     cx,3
+        cli
+        rep     stosb
+        cld             ; 1
+        nop             ; 2
+        nop             ; 3
+        nop             ; 4     <- 80x88 will cut here and inc cx instruction
+@@0:    inc     cx      ; 5        will be overwritten by sti, else we'll get
+@@O1:                   ;          cx = 1, which indicates 80x86
+        sti             ; 6
+@@2:
+        sti
+        pop     di
+        pop     es
+        retn
+checkQueueSize  endp
+
+; -------------------------------
+
+check80286:
+; check for 286+
+        push    sp
+        pop     ax
+        cmp     ax,sp           ; push sp == {sp-=2, [sp]=sp} on < 80286
+        jnz     Nope            ; push sp == {[sp-2]=sp, sp-=2} on 80286+
+Yes:
+        clc
+        retn
+Nope:
+        stc
+        retn
+
+; -------------------------------
+
+check8018x:
+; check for 8018x
+        mov     cl,33
+        clr     ax
+        dec     ax
+        shl     ax,cl
+        jnz     Yes             ; 8018x chips shift only (cl mod 32) bits
+        jmp     Nope
+
+; -------------------------------
+
+checkNEC:
+; check for NEC V20/V30
+        mov     cx,2            ; test if following instruction will be
+                                ; repeated twice.
+        db      0F3h,26h,0ACh   ; rep es: lodsb
+        jcxz    Yes             ; intel non-CMOS chips do not care of rep
+        jmp     Nope            ; before segment prefix override, NEC and
+                                ; CMOS-tech ones does.
+
+; -------------------------------
+
+check80C8x:
+; derived from code provided by Alex Bachin
+        mov     ax,0102h
+        db      0D5h,10h        ; AAD 16 opcode - intel only, undocumented
+        cmp     al,12h          ; did it work?
+        jnz     Nope            ; nope - probably a NEC chip
+        jmp     Yes
+
+; -------------------------------
+
+check386:
+; check for 386+, technique is blessed by Intel
+        mov     ax,7000h
+        pushf
+        push    ax
+        popf
+        pushf
+        pop     ax
+        popf
+        and     ah,70h          ; check for flags - only 386+ has them
+        jz      Nope            ; if ah=0 than this is 286
+        jmp     Yes
+
+
+check_byBIOS:
+IFDEF   __debug__
+        push    dx
+        lea     dx, BIOSMsg
+        call    printDebug
+        pop     dx
+ENDIF
+        mov     ax,0C910h       ; PS/2 and some other BIOSes CPUID call
+        int     15h
+        jc      Nope            ; call not supported
+        cmp     ch,04
+        jz      @@a486
+        cmp     ch,33h
+        jz      @@i376
+        cmp     ch,43h
+        jz      @@i386SL
+        cmp     ch,0A3h
+        jz      @@ibm386SL
+        cmp     ch,0A4h
+        jz      @@ibm486SLC
+        cmp     ch,84h
+        jz      @@bl3
+        jmp     Nope            ; detect as usual
+@@i376:
+        mov     cpu,i376
+        jmp     Yes
+@@i386SL:
+        mov     cpu,i386sl
+        jmp     Yes
+@@ibm386SL:
+        mov     cpu,ibm386slc
+        jmp     Yes
+@@ibm486SLC:
+        test    cl,0F0h         ; 1,2 and 3 models are SLC2 and 0 is SLC
+        jnz     @@ibm486SLC2
+        mov     cpu,ibm486slc
+        jmp     Yes
+@@ibm486SLC2:
+        mov     cpu,ibm486slc2
+        jmp     Yes
+@@bl3:
+        mov     cpu,ibm486bl3
+        jmp     Yes
+@@a486:
+        cmp     cl,02           ; Am486DX2
+        jnz     Nope
+        mov     cpu,am486
+        jmp     Yes
+
+
+; -------------------------------
+
+check_x86SL:
+IFDEF   __debug__
+        push    dx
+        lea     dx, x86SLMsg
+        call    printDebug
+        pop     dx
+ENDIF
+
+; On entry: DH contains CPU family code (3 for 386, 4 for 486)
+;
+; Copyright(c) by Robert Collins
+; Adapted for TMi0SDGL by Bobby Z. Original code flow and comments preserved.
+;-----------------------------------------------------------------------------
+; The Intel386 SL and Intel486 SL have a register which allows reading the
+; CPUID.  This register is called the signature register, and lies in the On-
+; board Memory Control Unit (OMCU) at register 0x30E.  To read the signature
+; register, first we must unlock access to the OMCU, read the signature,
+; and relock access.
+;-----------------------------------------------------------------------------
+; To unlock access to the CPUPWRMODE register, we need to execute the
+; following code sequence:
+;       write 00h to port(23h)
+;       write 80h to port(22h)
+;       write 0080h to port(22h)        ; word write
+        cli
+        in      ax,22h                  ; get CPUPWRMODE register
+        xor     ax,0ffffh               ; all bits set?
+        jz      Nope                    ; yes, go split
+        in      ax,22h                  ; get CPUPWRMODE register
+        test    al,1                    ; CPUPWRMODE unlocked?
+        jz      @EnaPWRMODE             ; nope, don't try and lock it.
+
+;-----------------------------------------------------------------------------
+; The safest way to determine whether or not this is a 386 SL is to attempt
+; to lock and unlock the CPUPWRMODE register.  If the register can be locked
+; and unlocked as per 386 SL specifications, then there's a good chance that
+; this isn't some chipset that amazingly supports the same enable/disable
+; protocol.  So if we can enable and disable the CPUPWRMODE register, then
+; we'll proceed with reading the CPUID signature register.
+;-----------------------------------------------------------------------------
+; Lock the CPUPWRMODE register
+        mov     al,00                   ;
+        out     23h,al                  ;
+        mov     ax,180h                 ; will lock CPUPWRMODE register
+        out     22h,al
+        out     22h,ax                  ; now CPUPWRMODE register should be
+                                        ;  locked.
+        in      ax,22h                  ; get CPUPWRMODE register
+        test    al,1                    ; CPUPWRMODE unlocked?
+        jnz     Nope                    ; yes, go try and unlock it
+
+;-----------------------------------------------------------------------------
+; Unlock the CPUPWRMODE register
+@EnaPWRMODE:
+        mov     al,00                   ;
+        out     23h,al                  ;
+        mov     ax,80h                  ; will unlock CPUPWRMODE register
+        out     22h,al
+        out     22h,ax                  ; now CPUPWRMODE register should be
+                                        ;  unlocked.
+        in      ax,22h                  ; get CPUPWRMODE register
+        test    al,1                    ; CPUPWRMODE unlocked?
+        jz      Nope                    ; yes, go try and unlock it
+
+;-----------------------------------------------------------------------------
+; Enable the On-board Memory Configuration Unit (OMCU).  If this is an
+; Intel486 SL, then bits [4-2] are the unit configuration select bits.  If
+; this is an Intel386 SL, then bits [3-2] are the unit configuration select
+; bits.
+        and     al,not 1100b            ; clear configuration unit bits
+        and     dh,0fh                  ; only keep processor family bits
+        cmp     dh,4                    ; 486 SL?
+        jne     @@1                     ; nope
+        and     al,not 11100b           ; clear configuration unit bits
+@@1:    or      al,10b                  ; set unit enable bit
+        out     22h,ax                  ; now unit should be enabled
+
+;-----------------------------------------------------------------------------
+; Now read the CPUID signature register
+        mov     dx,030Eh                ; signature register
+        in      ax,dx                   ; get CPUID signature
+        mov     dx,ax                   ; make a copy
+
+;-----------------------------------------------------------------------------
+; Now as one final test, let's relock the CPUPWRMODE register and make sure
+; it really gets locked.  Otherwise, we'll ignore the value we just read.
+        mov     al,00                   ;
+        out     23h,al                  ;
+        mov     ax,180h                 ; will lock CPUPWRMODE register
+        out     22h,al
+        out     22h,ax                  ; now CPUPWRMODE register should be
+                                        ;  locked.
+        in      ax,22h                  ; get CPUPWRMODE register
+        test    al,1                    ; CPUPWRMODE unlocked?
+        jnz     Nope                    ; yes, go try and unlock it
+
+;-----------------------------------------------------------------------------
+; OK, must be 80386 SL, and we have CPUID in BX.
+        mov     ax,dx                   ; restore copy of CPUID
+        ror     ah,1                    ; swap nibble locations
+        ror     ah,1
+        ror     ah,1
+        ror     ah,1
+        shr     ax,1                    ; convert to standard CPUID format
+        shr     ax,1
+        shr     ax,1
+        shr     ax,1
+        jmp     Yes
+
+        .386
+
+; -------------------------------
+
+checkAm386:
+; this routine was checked by Vasiliy Sorokin. It uses UMOV
+; instruction present in Am386 chips but not found in other x86s.
+        call    checkCyrix      ; don't check on Cyrix/UMC chips
+        jnc     Nope
+        pushfd                  ; neither check if CPUID is supported
+        pushfd
+        pop     eax
+        mov     ebx,eax
+        xor     eax,EF_ID       ; try flipping ID bit of EFLAGS
+        push    eax
+        popfd
+        pushfd
+        pop     eax
+        popfd
+        cmp     eax,ebx
+        jnz     Nope            ; the bit was flipped - CPUID supported
+        pusha
+        push    ds
+        push    es
+        mov     ax,3506h
+        int     21h
+        push    es
+        push    bx
+        mov     ax,2506h
+        ldx     @@Int06
+        push    cs
+        pop     ds
+        int     21h
+        mov     dl,[bx+si]
+        db      0Fh
+        adc     al,cl
+        add     [bx+si],al
+; we get here only if UMOV succeed
+        mov     [bx+si],dl
+        pop     dx
+        pop     ds
+        mov     ax,2506h
+        int     21h
+        pop     es
+        pop     ds
+        popa
+        jmp     Yes
+@@Int06:
+        add     sp,4    ; clear the fault address from stack
+        popf
+        mov     [bx+si],dl
+        pop     dx
+        pop     ds
+        mov     ax,2506h
+        int     21h
+        pop     es
+        pop     ds
+        popa
+        jmp     Nope
+
+; -------------------------------
+
+checkCT38600:
+; check for C&T 38600
+        mov     esi,32          ; give it 32 tries
+        mov     eax,12345678h   ; load a value
+        mov     ebx,eax         ; save it for reference
+        sub     edx,edx         ; set edx+edi to point to DS:0
+        sub     edi,edi
+@@ct_loop:
+        pushad                  ; push all registers
+        popad                   ; pop all registers
+        mov     ecx,[edx+edi]   ; and do a memory access
+        cmp     eax,ebx         ; did eax changed?
+        jnz     Nope            ; YES! this is an Intel/AMD 386 - they have
+        dec     esi             ; POPAD bug: mem access after popad changes
+        jnz     @@ct_loop       ; eax contents
+        jmp     Yes             ; all 32 tries passed - should be C&T38600
+
+; -------------------------------
+
+check486:                       ; this code is blessed by Intel, donated to
+                                ; public domain by CompaQ.
+        mov     ax,sp
+        and     sp,0FFFCh       ;round down to a dword boundary
+        pushfd
+        pushfd
+        pop     edx
+        mov     ecx,edx
+        xor     edx,EF_AC       ;toggle AC bit
+        and     ecx,EF_AC
+        push    edx
+        popfd
+        pushfd
+        pop     edx
+        popfd                   ;restore original flags
+        mov     sp,ax           ;restore original stack pointer
+        and     edx,EF_AC
+
+        cmp     edx,ecx
+        jnz     Yes             ;it's a 486
+        jmp     Nope
+
+; -------------------------------
+
+        .386p
+
+check386sx:
+; check for SX version
+        mov     eax,cr0
+        mov     ecx,eax
+        xor     eax,MSW_ET      ; flipping ET bit
+        mov     cr0,eax
+        mov     eax,cr0
+        mov     cr0,ecx         ; restoring previous value of CR0
+        xor     eax,ecx         ; did it flip ok?
+        jz      Nope            ; SX chips do not allow to change bus width
+        jmp     Yes
+
+; -------------------------------
+
+        .8087
+check486sx:
+; check for SX version
+        mov     eax,cr0
+        mov     ecx,eax
+        xor     eax,MSW_NE      ; flipping NE bit
+        mov     cr0,eax
+        mov     eax,cr0
+        mov     cr0,ecx         ; restoring previous value of CR0
+        xor     eax,ecx         ; did it flip ok?
+        jnz     Yes             ; SX chips do not allow to change NE bit
+                                ; but some SX'es pass this test as DXes...
+
+        mov     _wp [bp-2],5A5Ah   ; ... so we'll do some more tests
+        fninit
+        fnstcw  _wp [bp-2]
+        mov     ax,[bp-2]
+        test    al,al
+        jnz     Nope
+        jmp     Yes
+
+; -------------------------------
+
+checkIBMmsrs    proc near
+IFDEF   __debug__
+        push    dx
+        lea     dx, MSRsMsg
+        call    printDebug
+        pop     dx
+ENDIF
+
+; the following three checkIBMmsrsX routines attempt to read IBM-specific
+; MSRs #1000, #1002 and #1004. Because RDMSR with invalid index will cause
+; exception 13 and rdmsr itself may cause exception 6 on CPU that do not
+; support it, we should be able to intercept both exceptions, thus the code
+; should run either in real mode or on CPL0.
+        smsw    ax
+        test    al,1            ; we can only do this nasty code in real mode...
+        jnz     @@Qs1
+        push    ds
+        mov     ax,350Dh
+        int     21h
+        push    es
+        push    bx
+        push    cs
+        pop     ds
+        ldx     @@trap06
+        mov     ax,250Dh        ; intercept GPF exception
+        int     21h
+        mov     ax,3506h
+        int     21h
+        push    es
+        push    bx
+        ldx     @@trap06
+        mov     ax,2506h        ; and Invalid Instruction exception
+        int     21h
+        _rdmsr  1000h
+                                ; We'll get Exception 13 if this MSR is not
+        stc                     ; valid or Exception 06 if this is not IBM386.
+        mov     cpu,ibm386slc   ; IBM 386SLC
+        jmp     @@Qs
+@@trap06:                       ; similar action is taken on both exceptions,
+        add     sp,4            ; so we don't need to setup different handlers
+        popf                    ; for each exception.
+        clc
+@@Qs:
+        pop     dx
+        pop     ds
+        pushf
+        mov     ax,2506h
+        int     21h
+        popf
+        pop     dx
+        pop     ds
+        pushf
+        mov     ax,250Dh
+        int     21h
+        popf
+        pop     ds
+@@Qs1:
+        ret
+checkIBMmsrs    endp
+
+; -------------------------------
+
+checkIBMmsrs2   proc near
+        call    _np checkIBMmsrs ; first check if this is IBM 486SLC chip
+        jnc     @@Qi
+        push    ds
+        mov     ax,350Dh        ; we don't need to intercept Exception #6 here,
+        int     21h             ; for it is proved that RDMSR instruction is
+        push    es              ; valid for current CPU. But the register we're
+        push    bx              ; trying to read may be invalid...
+        push    cs
+        pop     ds
+        ldx     @@trap0D2
+        mov     ax,250Dh
+        int     21h
+        _rdmsr  1002h           ; try to read 486SLC2 specific MSR
+        mov     cpu,ibm486slc2  ; IBM 486SLC2
+        jmp     @@Qi2
+@@trap0D2:
+        add     sp,4
+        popf
+        stc
+        mov     cpu,ibm486slc   ; IBM 486SLC
+@@Qi2:
+        pop     dx
+        pop     ds
+        pushf
+        mov     ax,250Dh
+        int     21h
+        popf
+@@Qi:
+        ret
+checkIBMmsrs2   endp
+
+; -------------------------------
+
+checkIBMmsrs3   proc near
+        call    _np checkIBMmsrs2
+        jnc     @@Qi4
+        push    ds
+        mov     ax,350Dh        ; we don't need to intercept Exception #6 here,
+        int     21h             ; for it is proved that RDMSR instruction is
+        push    es              ; valid for current CPU. But the register we're
+        push    bx              ; trying to read may be invalid...
+        push    cs
+        pop     ds
+        ldx     @@trap0D3
+        mov     ax,250Dh
+        int     21h
+        _rdmsr  1004h           ; try to read 486BL3 specific MSR
+        mov     cpu,ibm486bl3
+        jmp     @@Qi3
+@@trap0D3:
+        add     sp,4
+        popf
+        stc
+@@Qi3:
+        pop     dx
+        pop     ds
+        pushf
+        mov     ax,250Dh
+        int     21h
+        popf
+@@Qi4:
+        ret
+checkIBMmsrs3   endp
+
+; -------------------------------
+
+checkCyrix:                     ; this code provided by Cyrix Corp.
+IFDEF   __debug__
+        push    dx
+        lea     dx, CyrixMsg
+        call    printDebug
+        pop     dx
+ENDIF
+        clr     ax
+        sahf                    ; load flags, bit 1 always = 1
+        mov     ax,5
+        mov     bx,2
+        div     bl              ; do an operation that does not change flags
+        lahf                    ; get flags
+        cmp     ah,2            ; did flags changed?
+        jne     Nope            ; yes, they did - not a Cyrix CPU
+        jmp     Yes             ; didn't - Cyrix CPU
+
+; -------------------------------
+
+checkNexGen:                    ; this code provided by NexGen Corp.
+        mov     ax,5555h
+        xor     dx,dx
+        mov     cx,2
+        div     cx
+        jnz     Nope            ; Nx586 doesn't change ZF on division while
+        jmp     Yes             ; others do
+
+; ----------------------------------------------------------------------------
+; checkWeitek routine follows
+
+checkWeitek     proc near
+; check for Weitek coprocessor presence, just checking if BIOS feature flag
+; for Weitek FPU is set.
+        cmp     cpu,i80386sx
+        jb      @_1
+        .386
+        clr     eax
+        int     11h
+        test    eax,1000000h
+        .8086
+        jz      @_1
+        or      extFlags,efWeitekPresent        ; Weitek FPU present
+        jmp     @@2
+@_1:
+        and     extFlags,not efWeitekPresent
+@@2:
+        ret
+checkWeitek     endp
+
+; ----------------------------------------------------------------------------
+; checkEmulator routine follows
+
+checkEmulator   proc near
+; returns CF = 1 if FPU emulator detected, CF = 0 otherwise
+        and     extFlags,not efEmulatedFPU    ; assume no emulator
+        cmp     cpu,i80386sx   ; check for 386+ to assure that FPU emulation is
+        jb      @@2            ; possible, avoid check if not 386 or higher.
+        .286p
+        push    ax
+        smsw    ax
+        test    al,04           ; simply check fpu emulation bit in MSW
+        jz      @@01
+        or      extFlags,efEmulatedFPU
+@@01:
+        pop     ax
+@@2:
+        ret
+checkEmulator   endp
+
+        .8086
+
+; ----------------------------------------------------------------------------
+; getFPUType routine follows
+
+fnstdw  equ     db 0DFh,0E1h    ; i387SL Mobile Store Device Word
+                                ; instruction
+frinear equ     db 0DFh,0FCh    ; Cyrix/IIT undocumented FRINEAR instruction
+
+
+getFPUType      proc    DIST
+LOCAL   fpuDWord : DWORD, fpuTera : TBYTE, fpuEnv : TBYTE, fpuEnv_tail : DWORD, fpuWord : WORD
+
+; cpu variable should already have valid CPU code on entry!
+
+        mov     fpu,fpuNone     ; assume no FPU present
+        fninit
+        clr     cx
+        jmp     $+2             ; just to make sure we have enough time for
+                                ; FPU to initialize
+        mov     _wp fpuWord,5A5Ah
+        fnstsw  _wp fpuWord
+        mov     ax,_wp fpuWord
+        test    al,al
+        jnz     @@L161          ; FPU wasn't initialized - no FPU at all
+        fnstcw  _wp fpuWord     ; check the control word also
+        mov     ax,_wp fpuWord
+        and     ax,103Fh
+        cmp     ax,3Fh
+        jne     @@L161
+        mov     fpu,i8087       ; assume 8087
+        fstenv  fpuEnv
+        and     _wp fpuWord,0FF7Fh
+        fldcw   _wp fpuWord
+        fdisi
+        fstcw   _wp fpuWord
+        wait
+        test    _wp fpuWord,80h
+        jnz     @@L161
+        .286p
+        .287
+        mov     fpu,i80287      ; assume 80287
+        fninit                  ; checking if -Inf <> +Inf
+        fld1                    ; 287 erroneously claim that they are equal
+        fldz
+        fdivp   st(1),st
+        fld     st
+        fchs
+        fcompp
+        fstsw   _wp fpuWord
+        wait
+        mov     ax,_wp fpuWord
+        sahf
+        jz      @@checkIIT      ; -Inf <> +Inf -> 287XL or 387 and up
+        mov     fpu,i80387      ; assume 80387
+        cmp     cpu,i80286      ; IIT x87's cannot work with CPUs prior to 286
+        jb      @@L35           ; so we disable the test on them too.
+comment |
+; check for Intel i387SL Mobile
+; install invalid opcode trap handler
+        push    bx dx ds es
+        mov     ax,3506h
+        int     21h
+        push    es bx
+        mov     ax,2506h
+        ldx     @@trap06
+        push    cs
+        pop     ds
+        int     21h
+        mov     ax,-1
+        fninit
+        fnstdw                  ; request to store device word into ax
+; if we get at this point it should be 387SL
+        mov     bx,ax           ; save ax contents
+        pop     dx ds           ; deinstall trap handler
+        mov     ax,2506h
+        int     21h
+        pop     es ds dx bx
+        cmp     bx,-1           ; did ax change?
+        jz      @@checkIIT
+        mov     fpu,i387SLMobile
+        jmp     @@restore       ; no other FPU does this, so we can finish
+@@trap06:
+        add     sp,4            ; just deinstall handler and continue
+        popf
+        pop     dx ds
+        mov     ax,2506h
+        int     21h
+        pop     es ds dx bx
+|
+@@checkIIT:
+        fninit
+        fld     fpuDenormal
+        fadd    st(0),st        ; IIT will produce zero result while all others
+        fnstsw  ax              ; won't
+        test    al,02h
+        jnz     @@L35           ; not an IIT chip
+        cmp     fpu,i80387      ; tested as 80387?
+        jz      @@300
+        mov     fpu,iit287      ; this is IIT 2C87
+        jmp     @@L161
+@@300:
+        cmp     cpu,i486sx      ; it's a 486?
+        jb      @@301
+        mov     fpu,iit487      ; assume IIT 4C87
+        jmp     @@chkDLC
+@@301:
+        mov     fpu,iit387      ; this is IIT 3C87
+@@chkDLC:
+        fninit                  ; check for 4C87DLC
+        mov     cx,0102h
+        mov     ax,cx
+        frinear                 ; undocumented Cyrix FRINEAR instruction
+        frinear                 ; chaining two FRINEARs on IIT 4C87DLC
+        cmp     ax,cx           ; corrupts AX
+        jnz     @@3011
+        jmp     @@L161
+@@3011:
+        mov     fpu,iit487DLC
+        jmp     @@L161
+@@L35:
+; checking for Cyrix FPUs
+        fninit
+        fldpi
+        f2xm1
+        fstp    fpuDWord
+        wait
+        cmp     _wp fpuDWord[2],3FC9h
+        jne     @@L15           ; Cyrix FPUs are known to return this value
+        cmp     cpu,i80286
+        ja      @@L351
+        mov     fpu,cx287       ; this is Cyrix ?C87
+        jmp     @@L15
+@@L351:
+        cmp     cpu,i486sx
+        jb      @@L352
+        mov     fpu,cx487
+        jmp     @@L15
+@@L352:
+        mov     fpu,cx387
+@@L15:
+; testing for ULSI FPUs
+        fninit
+        fldcw   fpu_53bit_prec
+        fld     _tp fpuOp1
+        fld1
+        faddp   st(1),st
+        fstp    fpuTera
+        fnstsw  ax
+        wait
+        test    al,20h
+        jnz     @@L16
+        cmp     _bp fpuTera,0F8h
+        jnz     @@L16
+        cmp     _bp fpuTera[9],40h
+        jnz     @@L16
+        mov     fpu,ulsi387
+        cmp     cpu,i486sx
+        jb      @@L161
+        mov     fpu,ulsi487
+        jmp     @@L161
+@@L16:
+; testing for Cyrix EMC87
+        fnstcw  _wp fpuWord
+        or      _bp fpuWord[1],80h
+        fldcw   _wp fpuWord
+        fstcw   _wp fpuWord
+        wait
+        test    _bp fpuWord[1],80h
+        jz      @@L162
+        mov     fpu,cxEMC87
+        jmp     @@L161
+@@L162:
+; testing for C&T 38700
+        cmp     cpu,i80386sx
+        jb      @@L161
+        fninit
+        fldpi
+        f2xm1
+        fld1
+        fchs
+        fldpi
+        fscale
+        fstp    st(1)
+        fcompp
+        fstsw   ax
+        wait
+        sahf
+        jnz     @@L161
+        mov     fpu,ct387
+@@L161:
+        cmp     cpu,i80286      ; 286...?
+        jnz     @@30
+        cmp     fpu,i80387      ; ...and FPU tested as 387...?
+        jnz     @@30
+        mov     fpu,i80287xl    ; then assume 80287XL - tricky
+@@30:
+        cmp     cpu,i486sx
+        jae     @@302
+        cmp     cpu,i80286
+        jbe     @@302
+        fninit                  ; this test is valid for 386 only
+        fbstp   fpuTera
+        cmp     _bp fpuTera[7],0C0h     ; RapidCAD stores C0, 387 - 80
+        jnz     @@302
+        mov     cpu,RapidCAD
+        mov     fpu,rCAD
+        jmp     @@restore
+@@302:
+        cmp     cpu,i486sx      ; i486sx ?
+        jb      @@restore       ; we're done
+        cmp     cpu,i486dx
+        ja      @@31
+        jz      @@Internal      ; already know this is 486DX
+        cmp     fpu,i80387      ; 387?
+        jnz     @@33
+        mov     cpu,i486dx      ; assume 486DX or 487SX
+@@Internal:
+        mov     fpu,fpuInternal ; assume internal FPU
+        or      extFlags,efHasFPUonChip
+        jmp     @@restore
+@@33:
+        cmp     cpu,i486dx      ; 486DX with non-Intel FPU???
+        jnz     @@31
+        dec     cpu             ; then this is i486SX with non-Intel FPU.
+        jmp     @@restore
+@@31:
+        cmp     cpu,Nx586       ; Nx586?
+        jnz     @@restore
+        cmp     fpu,i80387      ; there's an 386-compatible FPU?
+        jnz     @@restore
+        mov     fpu,Nx587       ; assume Nx587 - others shouldn't work
+@@restore:
+        cmp     fpu,fpuNone     ; any 87 present?
+        jz      @@fin
+        fldenv  fpuEnv          ; yes - restore x87 environment
+@@fin:
+        .8086
+        call    _np checkWeitek  ; check for Weitek FPU presense
+        call    _np checkEmulator; check for FPU emulation
+        ret
+getFPUType      endp
+
+if 0
+; ----------------------------------------------------------------------------
+; isV86 routine follows
+;
+
+isV86   proc    DIST
+        .286p
+        smsw    ax
+        and     al,1    ; bit 1 is set if in Protected Mode, in DOS this
+                        ; automatically means V86...
+        ret
+isV86   endp
+endif
+
+; ----------------------------------------------------------------------------
+; getCyrixModel routine follows
+; method provided by Cyrix
+
+
+read_reg        macro reg
+; macro for reading CPU hidden register reg
+        pushf
+        cli
+        mov     al,reg
+        out     22h,al
+        in      al,23h
+        popf
+        endm
+
+write_reg       macro reg
+; macro for writing a value in AH to CPU hidden register reg
+        pushf
+        cli
+        mov     al,reg
+        out     22h,al
+        xchg    al,ah
+        out     23h,al
+        popf
+        endm
+
+
+CCR0    equ     0C0h
+CCR2    equ     0C2h
+CCR3    equ     0C3h
+CCR4    equ     0E8h
+DIR0    equ     0FEh
+DIR1    equ     0FFh
+DIR2    equ     0FCh    ; these two DIRs exist on the latest Cyrix chips,
+DIR3    equ     0FDh    ; but their purpose is not documented.
+
+
+INCLUDE PCI.INC
+
+
+getCyrixModel   proc    DIST    ; this method provided by Cyrix.
+LOCAL   PMSR : Word
+        call    BX_Cyrix_Workaround_Start
+        mov     PMSR,ax
+
+        clr     dx      ; dh = t1, dl = t2
+        read_reg  CCR2
+        mov     bl,al
+        xor     al,4    ; flip bit 2 of CCR2
+        mov     ah,al
+        write_reg CCR2
+        read_reg  CCR0  ; dummy read to set up bus
+        read_reg  CCR2  ; get CCR2 value
+        cmp     al,bl   ; did bit 2 flip?
+        jz      @@_1
+        inc     dh
+@@_1:
+        mov     ah,bl
+        write_reg CCR2  ; restore previous CCR2 value
+
+        read_reg  CCR3  ; read CCR3
+        mov     bl,al
+        xor     al,80h  ; flip bit 7 of CCR3
+        write_reg CCR3
+        read_reg  CCR0
+        read_reg  CCR3
+        cmp     bl,al   ; did bit 7 flip?
+        jz      @@2
+        inc     dl
+@@2:
+        mov     ah,bl
+        write_reg CCR3  ; restore CCR3
+
+        test    dl,dl   ; t2 = 0? -> DIRx not supported
+        jz      @@noDIRx
+; take additional steps for enabling DIRx access
+        read_reg  CCR3  ; get currect CCR3 value
+        mov     ah,al
+        mov     cl,al   ; save CCR3 state
+        and     ah,0Fh
+        or      ah,10h  ; set MAPEN = 0001b -> enable DIRx access
+        write_reg CCR3
+
+        read_reg  DIR0
+        mov     bl,al   ; bl = DIR0
+        read_reg  DIR1
+        mov     bh,al   ; bh = DIR1
+        mov     ah,cl
+        write_reg CCR3  ; restore CCR3
+        jmp     @@done
+@@noDIRx:
+        test    dh,dh
+        jz      @@unknown
+        mov     bx,0EFh ; EF = Cx486S_a
+        jmp     @@done
+@@unknown:
+        clr     bx      ; unknown Cyrix chip
+        dec     bl      ; return 0FFh as result
+@@done:
+        mov     ax,bx
+        push    ax
+        mov     ax,PMSR
+        call    BX_Cyrix_Workaround_End
+        pop     ax
+        ret
+getCyrixModel   endp
+
+; -------------------------------
+; CxCPUIDEnable routine follows
+
+CxCPUIDEnable   proc    DIST
+; enables EFLAGS bit 21 and CPUID instruction on Cyrix 5x86 and 6x86 CPUs
+; this code does not affect Cx486's in any way
+LOCAL   PMSR : Word
+IFDEF   __debug__
+        push    dx
+        lea     dx, CxCPUID
+        call    printDebug
+        pop     dx
+ENDIF
+        call    BX_Cyrix_Workaround_Start
+        mov     PMSR,ax
+
+        read_reg CCR3
+        mov     bl,al   ; save current CCR3 state
+        and     al,0Fh
+        or      al,10h
+        mov     ah,al
+        write_reg CCR3  ; MAPEN = 0001b
+        read_reg  CCR4   ; read CCR4
+        or      al,80h  ; set bit 7 = 1 -> CPUID enabled
+        mov     ah,al
+        write_reg CCR4  ; set new CCR4 value
+        mov     ah,bl
+        write_reg CCR3  ; restore CCR3
+
+        mov     ax,PMSR
+        call    BX_Cyrix_Workaround_End
+        ret
+CxCPUIDEnable   endp
+
+; -------------------------------
+; getCPUID routine follows
+
+        .386
+getCPUID      proc    DIST USES es di, Level: DWORD, Result: DWORD
+; support routine to get CPUID extended info at specified level, used for
+; AMD K6 extended information display. Cache info on Pentium Pro and K6 can
+; also be retrieved using this routine with Level == 2.
+        mov     eax,Level
+        _cpuid
+        les     di,[Result]
+        stosd
+        xchg    eax,ebx
+        stosd
+        xchg    eax,ecx
+        stosd
+        xchg    eax,edx
+        stosd
+        ret
+getCPUID        endp
+
+; -------------------------------
+
+checkL2Tag      proc near
+        test    al,40h
+        jnz     @@Yes
+        xchg    ah,al
+        test    al,40h
+        jz      @@No
+@@Yes:
+        and     al,0Fh
+        jmp     @@Q
+@@No:
+        mov     al,0FFh
+@@Q:
+        ret
+checkL2Tag      endp
+
+; -------------------------------
+
+getL2CacheDesc  proc DIST
+        clr     eax
+        _cpuid
+        cmp     al,1
+        ja      @@ok
+        mov     al,0FFh
+        jmp     @@Q
+@@ok:
+        mov     eax,2
+        _cpuid
+        call    checkL2Tag
+        cmp     al,0FFh
+        jnz     @@Q
+        shr     eax,16
+        call    checkL2Tag
+        cmp     al,0FFh
+        jnz     @@Q
+        mov     eax,ebx
+        call    checkL2Tag
+        cmp     al,0FFh
+        jnz     @@Q
+        shr     eax,16
+        call    checkL2Tag
+        cmp     al,0FFh
+        jnz     @@Q
+        mov     eax,ecx
+        call    checkL2Tag
+        cmp     al,0FFh
+        jnz     @@Q
+        shr     eax,16
+        call    checkL2Tag
+        cmp     al,0FFh
+        jnz     @@Q
+        mov     eax,edx
+        call    checkL2Tag
+        cmp     al,0FFh
+        jnz     @@Q
+        shr     eax,16
+        call    checkL2Tag
+@@Q:
+        ret
+getL2CacheDesc  endp
+
+COMMENT |
+checkEMM386     proc DIST
+        mov     ax,0FFA5h
+        int     67h
+        clr     al
+        cmp     ah,84h
+        jnz     @@Nope
+        inc     al
+@@Nope:
+        clr     ah
+        ret
+checkEMM386     endp
+|       ; end COMMENT
+
+; -----------------------------------------------------------------
+; that's all, folks!
+
+        END
+
+
+
+
Common subdirectories: d:7.501/release and SOURCES/release
diff -Nu d:7.501/rtdata.h SOURCES/rtdata.h
--- d:7.501/rtdata.h	1970-01-01 02:00:00 +0200
+++ SOURCES/rtdata.h	2008-10-03 20:50:58 +0200
@@ -0,0 +1,6 @@
+#define _RWD_tzname	tzname
+#define _RWD_timezone	timezone
+#define _RWD_daylight	daylight
+#define _RWD_dst_adjust	__dst_adjust
+#define _RWD_start_dst	__start_dst
+#define _RWD_end_dst	__end_dst
diff -Nu d:7.501/screenio.c SOURCES/screenio.c
--- d:7.501/screenio.c	2006-11-12 16:00:50 +0200
+++ SOURCES/screenio.c	2008-05-02 15:53:44 +0200
@@ -227,8 +227,10 @@
 		case CR:
 egots_cr_key:
 			// reset cursor shape on exit
-			if ( gpIniptr->EditMode < 2 )
+			if ( gpIniptr->EditMode < 2 ) {
+				gnEditMode = gpIniptr->EditMode;
 				SetCurSize( );
+			}
 
 			// go to EOL before CR/LF (may be multiple lines)
 			if ( fEcho )
@@ -384,7 +386,7 @@
 				if (( pszMarkStart != (LPTSTR)-1L ) && ( pszMarkStart >= pszEgetsBase ))
 					CutEgets();
 
-				if ( strlen( pszEgetsBase ) + strlen( szSource ) < nMaxLength ) {
+				if ( strlen( pszEgetsBase ) + strlen( szSource ) < (unsigned int)nMaxLength ) {
 					clearline( pszCurrentPos );
 					strins( pszCurrentPos, szSource );
 					efputs( pszCurrentPos );
@@ -1338,7 +1340,7 @@
 							// check for next character F8, F9, F10, or F12
 						} else if ( c == F12 ) {
 
-							if ( pszArg == NULL ) {
+							if ( pszArg == NULL || strlen( pszEgetsBase ) + strlen( pszArg ) >= (unsigned int)nMaxLength ) {
 								honk();
 								goto TryAgain;
 							}
@@ -1416,7 +1418,7 @@
 			}
 
 			// check for invalid or overlength entry
-			if (( c > FBIT ) || (( strlen( pszEgetsBase ) >= nMaxLength ) && (( *pszCurrentPos == _TEXT('\0') ) || ( gnEditMode ))))
+			if (( c > FBIT ) || (( strlen( pszEgetsBase ) >= (unsigned int)nMaxLength ) && (( *pszCurrentPos == _TEXT('\0') ) || ( gnEditMode ))))
 				honk();
 
 			else if (( nEditFlag & EDIT_DIGITS ) && ( isdigit( c ) == 0 ))
diff -Nu d:7.501/select.c SOURCES/select.c
--- d:7.501/select.c	2006-11-12 16:00:50 +0200
+++ SOURCES/select.c	2008-09-26 08:47:12 +0200
@@ -189,7 +189,7 @@
 
 			case 'X':       // display alternate name
 
-				if ( fWin95 == 0 )
+				if ( ifs_type( NULL ) == 0 )
 					break;
 
 			case 'Z':
@@ -248,6 +248,7 @@
 				// if LFN names with whitespace, quote them
 				if ( glDirFlags & DIRFLAGS_LFN ) {
 					szFormat = ((( _fstrpbrk( sel->sfiles[n].lpszLFN, szInvalidChars ) != 0L ) || ( strpbrk( sel->szPath, szInvalidChars ) != 0L )) ? _TEXT("%s\"%s%Fs\"%s") : _TEXT("%s%s%Fs%s") );
+					BackQuotes( sel->sfiles[n].lpszLFN );	// replace `s if any
 					sprintf( pszCmdline, szFormat, sel->pszCmdStart, sel->szPath, (( glDirFlags & DIRFLAGS_NT_ALT_NAME ) ? sel->sfiles[n].szFATName : sel->sfiles[n].lpszLFN ), sel->pszCmdTail );
 				} else {
 
@@ -263,6 +264,7 @@
 							_fstrcpy( sel->sfiles[n].szFATName + j, sel->sfiles[n].szFATName + 8 );
 					}
 
+					BackQuotes( sel->sfiles[n].szFATName );	// replace `s if any
 					sprintf( pszCmdline, _TEXT("%s%s%Fs%s"), sel->pszCmdStart, sel->szPath, sel->sfiles[n].szFATName, sel->pszCmdTail );
 				}
 
diff -Nu d:7.501/selectc.c SOURCES/selectc.c
--- d:7.501/selectc.c	2006-11-12 16:00:50 +0200
+++ SOURCES/selectc.c	2007-09-18 00:01:58 +0200
@@ -234,6 +234,7 @@
 			break;
 
 		case ESC:
+		case RIGHT_MOUSE_BUTTON:
 			MouseCursorOff();
 			return -1;
 
@@ -281,16 +282,18 @@
 
 		case CUR_UP:
 		case CUR_DOWN:
+		case WHEEL_UP:
+		case WHEEL_DOWN:
 
 			if ( c != LEFT_MOUSE_BUTTON ) {
 
 				// switch current line to normal
 				dirprint( sel, -1, sel->nDirLine, sel->uNormal );
-				if ( c != CUR_UP ) {
+				if ( c != CUR_UP && c != WHEEL_UP ) {
 
 					// move scroll bar down, beep if at end
 					if ( sel->nDirLine >= ((int)sel->uEntries - 1 )) {
-						if (c == CUR_DOWN)
+						if (c == CUR_DOWN || c == WHEEL_DOWN)
 							honk();
 					} else if (++(sel->nDirLine) > sel->nDirLast) {
 						(sel->nDirFirst)++;
@@ -551,7 +554,7 @@
 
 		if ((( glDirFlags & DIRFLAGS_LFN ) == 0 ) || ( glDirFlags & DIRFLAGS_LFN_TO_FAT )) {
 
-			nOffset += sprintf( szBuffer+nOffset, ( sel->sfiles[uLine].uAttribute & _A_SUBDIR) ? DIR_LABEL : "%9lu",sel->sfiles[uLine].ulFileSize );
+			nOffset += sprintf( szBuffer+nOffset, ( sel->sfiles[uLine].uAttribute & _A_SUBDIR) ? DIR_LABEL : "%10lu", sel->sfiles[uLine].ulFileSize );
 
 			nOffset += sprintf( szBuffer+nOffset, (( gaCountryInfo.fsTimeFmt == 0 ) ? _TEXT("  %s %2u%c%02u%c") : _TEXT("  %s  %2u%c%02u")),
 				FormatDate( sel->sfiles[ uLine ].months, sel->sfiles[uLine].days,sel->sfiles[uLine].years, 0 ),
diff -Nu d:7.501/server.asm SOURCES/server.asm
--- d:7.501/server.asm	2006-11-12 16:00:50 +0200
+++ SOURCES/server.asm	2008-10-08 14:26:30 +0200
@@ -130,12 +130,19 @@
           ; Other segments accessed
           ;
 _TEXT     segment   para public 'CODE'  ;transient portion text segment
-          extrn     __dataseg:word, DoINT2E:far
+ifndef __WATCOM__
+	  ; @TODO!!
+          extrn     __dataseg:word
+endif
+          extrn     DoINT2E:far
           extrn     BreakHandler:far
 _TEXT     ends
           ;
 _DATA     segment   para public 'DATA'  ;transient portion data segment
+ifndef __WATCOM__
+	  ; @TODO!!
           extrn     __nheap_desc:word
+endif
 _DATA     ends
           ;
 DGROUP    group     _DATA               ;define group
@@ -915,16 +922,17 @@
           exit                          ;that's all
           ;
           ;
-          ; ServTtl - Return OS/2 session title
+          ; ServTtl - Get or set OS/2 session title
           ;
           entry     ServTtl,argframe,far  ;set up entry point
           ;
+          argW      Action              ;1 = set, 2 = get
           argD      TitleBuf            ;buffer address
           ;
           pushm     si,di,ds            ;save registers
           assume    ds:nothing	;fix assumes
           les       di,TitleBuf         ;get buffer offset
-          mov       dx,2                ;get our current title
+          mov       dx,Action           ;get or set our current title
           call      OS2Tacc             ;get title into buffer
           popm      ds,di,si            ;restore registers
           exit                          ;that's all
@@ -1047,14 +1055,18 @@
           mov       es,TCodeSeg         ;get new code segment
           assume    es:_TEXT            ;fix assumes
           mov       ax,TDataSeg         ;get new data segment
+ifndef __WATCOM__
           mov       es:__dataseg,ax     ;set global DS pointer (don't adjust,
                                         ;  just set -- because it's in code
                                         ;  seg which is swapped out before
                                         ;  this value is set, so it is wrong
                                         ;  after swap in)
+endif
           mov       es,ax               ;now change to data seg
           assume    es:_DATA            ;fix assumes
+ifndef __WATCOM__
           add       es:__nheap_desc,dx  ;adjust seg in near heap descriptor
+endif
           ;
           les       di,INIDP            ;point to INI data
           assume    es:nothing          ;fix assumes
diff -Nu d:7.501/serverrs.txt SOURCES/serverrs.txt
--- d:7.501/serverrs.txt	2003-02-09 14:01:22 +0200
+++ SOURCES/serverrs.txt	2009-02-26 11:10:32 +0200
@@ -61,8 +61,9 @@
           ;
           ; 4DOS signon message
           ;
-#162 Copyright 1988-2003  Rex Conn & JP Software Inc.  All Rights Reserved
+#162 Copyright 1988-2003 Rex Conn & JP Software Inc.  Updates 2006-2009 L.I.Georgiev
 	;
+ifdef SHAREWARE_VERSION
 	if	_RT
 #166 4DOSRT.COM not correctly installed, execution cannot continue.
 #167 4DOS Runtime internal error G%d/%d, contact JP Software.
@@ -119,6 +120,7 @@
 #195 %s version %s
           ;
           endif
+endif
           ;
           db        0FFh, 0             ;end of table
           ;
diff -Nu d:7.501/setup.mak SOURCES/setup.mak
--- d:7.501/setup.mak	2001-12-26 10:43:22 +0200
+++ SOURCES/setup.mak	2008-12-25 18:41:24 +0200
@@ -82,7 +82,7 @@
 CFLAGS_ENV=$(CBASE) /AM /J /Ot /Gs /GA /GEae /G2 /W3 /Zp1
 !ENDIF
 !ELSE
-CFLAGS_ENV=$(CBASE) /AM /J /Ocs /G2 /Gs /W3 /Zp1
+CFLAGS_ENV=$(CBASE) /AM /J /Ocs /Gf /Gs /W3 /Zp1
 !ENDIF
 !ENDIF
 !ELSE
@@ -94,8 +94,8 @@
 
 # Link flags vary for each target environment
 !IF "$(ENV)" == "DOS"
-CLFLAGS=/NOD /NOE /ST:8192 /F
-ALFLAGS=/NOD /NOE
+CLFLAGS=/B /NOD /NOE /ON:N /ST:8192 /F
+ALFLAGS=/B /NOD /NOE /ON:N /T
 LNAME=LINK
 !ENDIF
 
diff -Nu d:7.501/sha-priv.h SOURCES/sha-priv.h
--- d:7.501/sha-priv.h	1970-01-01 02:00:00 +0200
+++ SOURCES/sha-priv.h	2008-07-03 20:38:06 +0200
@@ -0,0 +1,26 @@
+#ifndef _SHA_PRIVATE__H
+#define _SHA_PRIVATE__H
+/*
+ * These definitions are defined in FIPS-180-2, section 4.1.
+ * Ch() and Maj() are defined identically in sections 4.1.1,
+ * 4.1.2 and 4.1.3.
+ *
+ * The definitions used in FIPS-180-2 are as follows:
+ */
+
+#ifndef USE_MODIFIED_MACROS
+#define SHA_Ch(x,y,z)        (((x) & (y)) ^ ((~(x)) & (z)))
+#define SHA_Maj(x,y,z)       (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
+
+#else /* USE_MODIFIED_MACROS */
+/*
+ * The following definitions are equivalent and potentially faster.
+ */
+
+#define SHA_Ch(x, y, z)      (((x) & ((y) ^ (z))) ^ (z))
+#define SHA_Maj(x, y, z)     (((x) & ((y) | (z))) | ((y) & (z)))
+#endif /* USE_MODIFIED_MACROS */
+
+#define SHA_Parity(x, y, z)  ((x) ^ (y) ^ (z))
+
+#endif /* _SHA_PRIVATE__H */
diff -Nu d:7.501/sha.h SOURCES/sha.h
--- d:7.501/sha.h	1970-01-01 02:00:00 +0200
+++ SOURCES/sha.h	2008-07-03 20:32:42 +0200
@@ -0,0 +1,267 @@
+#ifndef _SHA_H_
+#define _SHA_H_
+
+/*
+ *  Description:
+ *	This file implements the Secure Hash Signature Standard
+ *	algorithms as defined in the National Institute of Standards
+ *	and Technology Federal Information Processing Standards
+ *	Publication (FIPS PUB) 180-1 published on April 17, 1995, 180-2
+ *	published on August 1, 2002, and the FIPS PUB 180-2 Change
+ *	Notice published on February 28, 2004.
+ *
+ *	A combined document showing all algorithms is available at
+ *		http://csrc.nist.gov/publications/fips/
+ *		fips180-2/fips180-2withchangenotice.pdf
+ *
+ *	The five hashes are defined in these sizes:
+ *		SHA-1		20 byte / 160 bit
+ *		SHA-224		28 byte / 224 bit
+ *		SHA-256		32 byte / 256 bit
+ *		SHA-384		48 byte / 384 bit
+ *		SHA-512		64 byte / 512 bit
+ */
+
+#ifdef __WATCOMC__
+#include <stdint.h>
+/*
+ * If you do not have the ISO standard stdint.h header file, then you
+ * must typedef the following:
+ *    name		meaning
+ *  uint64_t	     unsigned 64 bit integer
+ *  uint32_t	     unsigned 32 bit integer
+ *  uint8_t	     unsigned 8 bit integer (i.e., unsigned char)
+ *  int_least16_t    integer of >= 16 bits
+ *
+ */
+#else
+#define USE_32BIT_ONLY
+    typedef unsigned long   uint32_t;
+    typedef unsigned char   uint8_t;
+    typedef unsigned short  int_least16_t;
+#endif
+
+#ifndef _SHA_enum_
+#define _SHA_enum_
+/*
+ *  All SHA functions return one of these values.
+ */
+enum {
+    shaSuccess = 0,
+    shaNull,		/* Null pointer parameter */
+    shaInputTooLong,	/* input data too long */
+    shaStateError,	/* called Input after FinalBits or Result */
+    shaBadParam		/* passed a bad parameter */
+};
+#endif /* _SHA_enum_ */
+
+/*
+ *  These constants hold size information for each of the SHA
+ *  hashing operations
+ */
+enum {
+    SHA1_Message_Block_Size = 64, SHA224_Message_Block_Size = 64,
+    SHA256_Message_Block_Size = 64, SHA384_Message_Block_Size = 128,
+    SHA512_Message_Block_Size = 128,
+    USHA_Max_Message_Block_Size = SHA512_Message_Block_Size,
+
+    SHA1HashSize = 20, SHA224HashSize = 28, SHA256HashSize = 32,
+    SHA384HashSize = 48, SHA512HashSize = 64,
+    USHAMaxHashSize = SHA512HashSize,
+
+    SHA1HashSizeBits = 160, SHA224HashSizeBits = 224,
+    SHA256HashSizeBits = 256, SHA384HashSizeBits = 384,
+    SHA512HashSizeBits = 512, USHAMaxHashSizeBits = SHA512HashSizeBits
+};
+
+/*
+ *  These constants are used in the USHA (unified sha) functions.
+ */
+typedef enum SHAversion {
+    SHA1, SHA224, SHA256, SHA384, SHA512
+} SHAversion;
+
+/*
+ *  This structure will hold context information for the SHA-1
+ *  hashing operation.
+ */
+typedef struct SHA1Context {
+    uint32_t Intermediate_Hash[SHA1HashSize/4]; /* Message Digest */
+
+    uint32_t Length_Low;		/* Message length in bits */
+    uint32_t Length_High;		/* Message length in bits */
+
+    int_least16_t Message_Block_Index;	/* Message_Block array index */
+					/* 512-bit message blocks */
+    uint8_t Message_Block[SHA1_Message_Block_Size];
+
+    int Computed;			/* Is the digest computed? */
+    int Corrupted;			/* Is the digest corrupted? */
+} SHA1Context;
+
+/*
+ *  This structure will hold context information for the SHA-256
+ *  hashing operation.
+ */
+typedef struct SHA256Context {
+    uint32_t Intermediate_Hash[SHA256HashSize/4]; /* Message Digest */
+
+    uint32_t Length_Low;		/* Message length in bits */
+    uint32_t Length_High;		/* Message length in bits */
+
+    int_least16_t Message_Block_Index;	/* Message_Block array index */
+					/* 512-bit message blocks */
+    uint8_t Message_Block[SHA256_Message_Block_Size];
+
+    int Computed;			/* Is the digest computed? */
+    int Corrupted;			/* Is the digest corrupted? */
+} SHA256Context;
+
+/*
+ *  This structure will hold context information for the SHA-512
+ *  hashing operation.
+ */
+typedef struct SHA512Context {
+#ifdef USE_32BIT_ONLY
+    uint32_t Intermediate_Hash[SHA512HashSize/4]; /* Message Digest  */
+    uint32_t Length[4];			/* Message length in bits */
+#else /* !USE_32BIT_ONLY */
+    uint64_t Intermediate_Hash[SHA512HashSize/8]; /* Message Digest */
+    uint64_t Length_Low, Length_High;	/* Message length in bits */
+#endif /* USE_32BIT_ONLY */
+    int_least16_t Message_Block_Index;	/* Message_Block array index */
+					/* 1024-bit message blocks */
+    uint8_t Message_Block[SHA512_Message_Block_Size];
+
+    int Computed;			/* Is the digest computed?*/
+    int Corrupted;			/* Is the digest corrupted? */
+} SHA512Context;
+
+/*
+ *  This structure will hold context information for the SHA-224
+ *  hashing operation. It uses the SHA-256 structure for computation.
+ */
+typedef struct SHA256Context SHA224Context;
+
+/*
+ *  This structure will hold context information for the SHA-384
+ *  hashing operation. It uses the SHA-512 structure for computation.
+ */
+typedef struct SHA512Context SHA384Context;
+
+/*
+ *  This structure holds context information for all SHA
+ *  hashing operations.
+ */
+typedef struct USHAContext {
+    int whichSha;		/* which SHA is being used */
+    union {
+      SHA1Context sha1Context;
+      SHA224Context sha224Context; SHA256Context sha256Context;
+      SHA384Context sha384Context; SHA512Context sha512Context;
+    } ctx;
+} USHAContext;
+
+/*
+ *  This structure will hold context information for the HMAC
+ *  keyed hashing operation.
+ */
+typedef struct HMACContext {
+    int whichSha;		/* which SHA is being used */
+    int hashSize;		/* hash size of SHA being used */
+    int blockSize;		/* block size of SHA being used */
+    USHAContext shaContext;	/* SHA context */
+    unsigned char k_opad[USHA_Max_Message_Block_Size];
+			/* outer padding - key XORd with opad */
+} HMACContext;
+
+
+/*
+ *  Function Prototypes
+ */
+
+/* SHA-1 */
+extern int SHA1Reset(SHA1Context *);
+extern int SHA1Input(SHA1Context *, const uint8_t _far *bytes,
+		     unsigned int bytecount);
+extern int SHA1FinalBits(SHA1Context *, const uint8_t bits,
+			 unsigned int bitcount);
+extern int SHA1Result(SHA1Context *,
+		      uint8_t Message_Digest[SHA1HashSize]);
+
+/* SHA-224 */
+extern int SHA224Reset(SHA224Context *);
+extern int SHA224Input(SHA224Context *, const uint8_t *bytes,
+		       unsigned int bytecount);
+extern int SHA224FinalBits(SHA224Context *, const uint8_t bits,
+			   unsigned int bitcount);
+extern int SHA224Result(SHA224Context *,
+			uint8_t Message_Digest[SHA224HashSize]);
+
+/* SHA-256 */
+extern int SHA256Reset(SHA256Context *);
+extern int SHA256Input(SHA256Context *, const uint8_t *bytes,
+		       unsigned int bytecount);
+extern int SHA256FinalBits(SHA256Context *, const uint8_t bits,
+			   unsigned int bitcount);
+extern int SHA256Result(SHA256Context *,
+			uint8_t Message_Digest[SHA256HashSize]);
+
+/* SHA-384 */
+extern int SHA384Reset(SHA384Context *);
+extern int SHA384Input(SHA384Context *, const uint8_t *bytes,
+		       unsigned int bytecount);
+extern int SHA384FinalBits(SHA384Context *, const uint8_t bits,
+			   unsigned int bitcount);
+extern int SHA384Result(SHA384Context *,
+			uint8_t Message_Digest[SHA384HashSize]);
+
+/* SHA-512 */
+extern int SHA512Reset(SHA512Context *);
+extern int SHA512Input(SHA512Context *, const uint8_t *bytes,
+		       unsigned int bytecount);
+extern int SHA512FinalBits(SHA512Context *, const uint8_t bits,
+			   unsigned int bitcount);
+extern int SHA512Result(SHA512Context *,
+			uint8_t Message_Digest[SHA512HashSize]);
+
+/* Unified SHA functions, chosen by whichSha */
+extern int USHAReset(USHAContext *, SHAversion whichSha);
+extern int USHAInput(USHAContext *,
+		     const uint8_t *bytes, unsigned int bytecount);
+extern int USHAFinalBits(USHAContext *,
+			 const uint8_t bits, unsigned int bitcount);
+extern int USHAResult(USHAContext *,
+		      uint8_t Message_Digest[USHAMaxHashSize]);
+extern int USHABlockSize(enum SHAversion whichSha);
+extern int USHAHashSize(enum SHAversion whichSha);
+extern int USHAHashSizeBits(enum SHAversion whichSha);
+
+/*
+ * HMAC Keyed-Hashing for Message Authentication, RFC2104,
+ * for all SHAs.
+ * This interface allows a fixed-length text input to be used.
+ */
+extern int hmac(SHAversion whichSha, /* which SHA algorithm to use */
+    const unsigned char *text,	   /* pointer to data stream */
+    int text_len,		   /* length of data stream */
+    const unsigned char *key,	   /* pointer to authentication key */
+    int key_len,		   /* length of authentication key */
+    uint8_t digest[USHAMaxHashSize]); /* caller digest to fill in */
+
+/*
+ * HMAC Keyed-Hashing for Message Authentication, RFC2104,
+ * for all SHAs.
+ * This interface allows any length of text input to be used.
+ */
+extern int hmacReset(HMACContext *ctx, enum SHAversion whichSha,
+		     const unsigned char *key, int key_len);
+extern int hmacInput(HMACContext *ctx, const unsigned char *text,
+		     int text_len);
+
+extern int hmacFinalBits(HMACContext *ctx, const uint8_t bits,
+			 unsigned int bitcount);
+extern int hmacResult(HMACContext *ctx,
+		      uint8_t digest[USHAMaxHashSize]);
+
+#endif /* _SHA_H_ */
diff -Nu d:7.501/sha1.c SOURCES/sha1.c
--- d:7.501/sha1.c	1970-01-01 02:00:00 +0200
+++ SOURCES/sha1.c	2008-07-03 20:48:24 +0200
@@ -0,0 +1,427 @@
+/*
+ *  Description:
+ *	This file implements the Secure Hash Signature Standard
+ *	algorithms as defined in the National Institute of Standards
+ *	and Technology Federal Information Processing Standards
+ *	Publication (FIPS PUB) 180-1 published on April 17, 1995, 180-2
+ *	published on August 1, 2002, and the FIPS PUB 180-2 Change
+ *	Notice published on February 28, 2004.
+ *
+ *	A combined document showing all algorithms is available at
+ *		http://csrc.nist.gov/publications/fips/
+ *		fips180-2/fips180-2withchangenotice.pdf
+ *
+ *	The SHA-1 algorithm produces a 160-bit message digest for a
+ *	given data stream.  It should take about 2**n steps to find a
+ *	message with the same digest as a given message and
+ *	2**(n/2) to find any two messages with the same digest,
+ *	when n is the digest size in bits.  Therefore, this
+ *	algorithm can serve as a means of providing a
+ *	"fingerprint" for a message.
+ *
+ *  Portability Issues:
+ *	SHA-1 is defined in terms of 32-bit "words".  This code
+ *	uses <stdint.h> (included via "sha.h") to define 32 and 8
+ *	bit unsigned integer types.  If your C compiler does not
+ *	support 32 bit unsigned integers, this code is not
+ *	appropriate.
+ *
+ *  Caveats:
+ *	SHA-1 is designed to work with messages less than 2^64 bits
+ *	long. This implementation uses SHA1Input() to hash the bits
+ *	that are a multiple of the size of an 8-bit character, and then
+ *	uses SHA1FinalBits() to hash the final few bits of the input.
+ */
+
+#include "sha.h"
+#define USE_MODIFIED_MACROS 1
+#include "sha-priv.h"
+
+/*
+ *  Define the SHA1 circular left shift macro
+ */
+#define SHA1_ROTL(bits,word) \
+		(((word) << (bits)) | ((word) >> (32-(bits))))
+
+/*
+ * add "length" to the length
+ */
+static uint32_t addTemp;
+#define SHA1AddLength(context, length)			   \
+    (addTemp = (context)->Length_Low,			   \
+     (context)->Corrupted =				   \
+	(((context)->Length_Low += (length)) < addTemp) && \
+	(++(context)->Length_High == 0) ? 1 : 0)
+
+/* Local Function Prototypes */
+static void SHA1Finalize(SHA1Context *context, uint8_t Pad_Byte);
+static void SHA1PadMessage(SHA1Context *, uint8_t Pad_Byte);
+static void SHA1ProcessMessageBlock(SHA1Context *);
+
+/*
+ *  SHA1Reset
+ *
+ *  Description:
+ *	This function will initialize the SHA1Context in preparation
+ *	for computing a new SHA1 message digest.
+ *
+ *  Parameters:
+ *	context: [in/out]
+ *	    The context to reset.
+ *
+ *  Returns:
+ *	sha Error Code.
+ *
+ */
+int SHA1Reset(SHA1Context *context)
+{
+    if (!context)
+	return shaNull;
+
+    context->Length_Low		    = 0;
+    context->Length_High	    = 0;
+    context->Message_Block_Index    = 0;
+
+    /* Initial Hash Values: FIPS-180-2 section 5.3.1 */
+    context->Intermediate_Hash[0]   = 0x67452301;
+    context->Intermediate_Hash[1]   = 0xEFCDAB89;
+    context->Intermediate_Hash[2]   = 0x98BADCFE;
+    context->Intermediate_Hash[3]   = 0x10325476;
+    context->Intermediate_Hash[4]   = 0xC3D2E1F0;
+
+    context->Computed	= 0;
+    context->Corrupted	= 0;
+
+    return shaSuccess;
+}
+
+/*
+ *  SHA1Input
+ *
+ *  Description:
+ *	This function accepts an array of octets as the next portion
+ *	of the message.
+ *
+ *  Parameters:
+ *	context: [in/out]
+ *	    The SHA context to update
+ *	message_array: [in]
+ *	    An array of characters representing the next portion of
+ *	    the message.
+ *	length: [in]
+ *	    The length of the message in message_array
+ *
+ *  Returns:
+ *	sha Error Code.
+ *
+ */
+int SHA1Input(SHA1Context *context,
+    const uint8_t _far *message_array, unsigned length)
+{
+  if (!length)
+    return shaSuccess;
+
+  if (!context || !message_array)
+    return shaNull;
+
+  if (context->Computed) {
+    context->Corrupted = shaStateError;
+    return shaStateError;
+  }
+
+  if (context->Corrupted)
+     return context->Corrupted;
+
+  while (length-- && !context->Corrupted) {
+    context->Message_Block[context->Message_Block_Index++] =
+      (*message_array & 0xFF);
+
+    if (!SHA1AddLength(context, 8) &&
+      (context->Message_Block_Index == SHA1_Message_Block_Size))
+      SHA1ProcessMessageBlock(context);
+
+    message_array++;
+  }
+
+  return shaSuccess;
+}
+
+#if 0
+/*
+ * SHA1FinalBits
+ *
+ * Description:
+ *   This function will add in any final bits of the message.
+ *
+ * Parameters:
+ *   context: [in/out]
+ *     The SHA context to update
+ *   message_bits: [in]
+ *     The final bits of the message, in the upper portion of the
+ *     byte. (Use 0b###00000 instead of 0b00000### to input the
+ *     three bits ###.)
+ *   length: [in]
+ *     The number of bits in message_bits, between 1 and 7.
+ *
+ * Returns:
+ *   sha Error Code.
+ */
+int SHA1FinalBits(SHA1Context *context, const uint8_t message_bits,
+    unsigned int length)
+{
+  uint8_t masks[8] = {
+      /* 0 0b00000000 */ 0x00, /* 1 0b10000000 */ 0x80,
+      /* 2 0b11000000 */ 0xC0, /* 3 0b11100000 */ 0xE0,
+      /* 4 0b11110000 */ 0xF0, /* 5 0b11111000 */ 0xF8,
+      /* 6 0b11111100 */ 0xFC, /* 7 0b11111110 */ 0xFE
+  };
+  uint8_t markbit[8] = {
+      /* 0 0b10000000 */ 0x80, /* 1 0b01000000 */ 0x40,
+      /* 2 0b00100000 */ 0x20, /* 3 0b00010000 */ 0x10,
+      /* 4 0b00001000 */ 0x08, /* 5 0b00000100 */ 0x04,
+      /* 6 0b00000010 */ 0x02, /* 7 0b00000001 */ 0x01
+  };
+
+  if (!length)
+    return shaSuccess;
+
+  if (!context)
+    return shaNull;
+
+  if (context->Computed || (length >= 8) || (length == 0)) {
+    context->Corrupted = shaStateError;
+    return shaStateError;
+  }
+
+  if (context->Corrupted)
+     return context->Corrupted;
+
+  SHA1AddLength(context, length);
+  SHA1Finalize(context,
+    (uint8_t) ((message_bits & masks[length]) | markbit[length]));
+
+  return shaSuccess;
+}
+#endif
+
+/*
+ * SHA1Result
+ *
+ * Description:
+ *   This function will return the 160-bit message digest into the
+ *   Message_Digest array provided by the caller.
+ *   NOTE: The first octet of hash is stored in the 0th element,
+ *	the last octet of hash in the 19th element.
+ *
+ * Parameters:
+ *   context: [in/out]
+ *     The context to use to calculate the SHA-1 hash.
+ *   Message_Digest: [out]
+ *     Where the digest is returned.
+ *
+ * Returns:
+ *   sha Error Code.
+ *
+ */
+int SHA1Result(SHA1Context *context,
+    uint8_t Message_Digest[SHA1HashSize])
+{
+  int i;
+
+  if (!context || !Message_Digest)
+    return shaNull;
+
+  if (context->Corrupted)
+    return context->Corrupted;
+
+  if (!context->Computed)
+    SHA1Finalize(context, 0x80);
+
+  for (i = 0; i < SHA1HashSize; ++i)
+    Message_Digest[i] = (uint8_t) (context->Intermediate_Hash[i>>2]
+	      >> 8 * ( 3 - ( i & 0x03 ) ));
+
+  return shaSuccess;
+}
+
+/*
+ * SHA1Finalize
+ *
+ * Description:
+ *   This helper function finishes off the digest calculations.
+ *
+ * Parameters:
+ *   context: [in/out]
+ *     The SHA context to update
+ *   Pad_Byte: [in]
+ *     The last byte to add to the digest before the 0-padding
+ *     and length. This will contain the last bits of the message
+ *     followed by another single bit. If the message was an
+ *     exact multiple of 8-bits long, Pad_Byte will be 0x80.
+ *
+ * Returns:
+ *   sha Error Code.
+ *
+ */
+static void SHA1Finalize(SHA1Context *context, uint8_t Pad_Byte)
+{
+  int i;
+  SHA1PadMessage(context, Pad_Byte);
+  /* message may be sensitive, clear it out */
+  for (i = 0; i < SHA1_Message_Block_Size; ++i)
+    context->Message_Block[i] = 0;
+  context->Length_Low = 0;  /* and clear length */
+  context->Length_High = 0;
+  context->Computed = 1;
+}
+
+/*
+ * SHA1PadMessage
+ *
+ * Description:
+ *   According to the standard, the message must be padded to an
+ *   even 512 bits. The first padding bit must be a '1'. The last
+ *   64 bits represent the length of the original message. All bits
+ *   in between should be 0. This helper function will pad the
+ *   message according to those rules by filling the Message_Block
+ *   array accordingly. When it returns, it can be assumed that the
+ *   message digest has been computed.
+ *
+ * Parameters:
+ *   context: [in/out]
+ *     The context to pad
+ *   Pad_Byte: [in]
+ *     The last byte to add to the digest before the 0-padding
+ *     and length. This will contain the last bits of the message
+ *     followed by another single bit. If the message was an
+ *     exact multiple of 8-bits long, Pad_Byte will be 0x80.
+ *
+ * Returns:
+ *   Nothing.
+ */
+static void SHA1PadMessage(SHA1Context *context, uint8_t Pad_Byte)
+{
+  /*
+   * Check to see if the current message block is too small to hold
+   * the initial padding bits and length. If so, we will pad the
+   * block, process it, and then continue padding into a second
+   * block.
+   */
+  if (context->Message_Block_Index >= (SHA1_Message_Block_Size - 8)) {
+    context->Message_Block[context->Message_Block_Index++] = Pad_Byte;
+    while (context->Message_Block_Index < SHA1_Message_Block_Size)
+      context->Message_Block[context->Message_Block_Index++] = 0;
+
+    SHA1ProcessMessageBlock(context);
+  } else
+    context->Message_Block[context->Message_Block_Index++] = Pad_Byte;
+
+  while (context->Message_Block_Index < (SHA1_Message_Block_Size - 8))
+    context->Message_Block[context->Message_Block_Index++] = 0;
+
+  /*
+   * Store the message length as the last 8 octets
+   */
+  context->Message_Block[56] = (uint8_t) (context->Length_High >> 24);
+  context->Message_Block[57] = (uint8_t) (context->Length_High >> 16);
+  context->Message_Block[58] = (uint8_t) (context->Length_High >> 8);
+  context->Message_Block[59] = (uint8_t) (context->Length_High);
+  context->Message_Block[60] = (uint8_t) (context->Length_Low >> 24);
+  context->Message_Block[61] = (uint8_t) (context->Length_Low >> 16);
+  context->Message_Block[62] = (uint8_t) (context->Length_Low >> 8);
+  context->Message_Block[63] = (uint8_t) (context->Length_Low);
+
+  SHA1ProcessMessageBlock(context);
+}
+
+/*
+ * SHA1ProcessMessageBlock
+ *
+ * Description:
+ *   This helper function will process the next 512 bits of the
+ *   message stored in the Message_Block array.
+ *
+ * Parameters:
+ *   None.
+ *
+ * Returns:
+ *   Nothing.
+ *
+ * Comments:
+ *   Many of the variable names in this code, especially the
+ *   single character names, were used because those were the
+ *   names used in the publication.
+ */
+static void SHA1ProcessMessageBlock(SHA1Context *context)
+{
+  /* Constants defined in FIPS-180-2, section 4.2.1 */
+  const uint32_t K[4] = {
+      0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6
+  };
+  int	     t;		      /* Loop counter */
+  uint32_t   temp;	      /* Temporary word value */
+  uint32_t   W[80];	      /* Word sequence */
+  uint32_t   A, B, C, D, E;   /* Word buffers */
+
+  /*
+   * Initialize the first 16 words in the array W
+   */
+  for (t = 0; t < 16; t++) {
+    W[t]  = ((uint32_t)context->Message_Block[t * 4]) << 24;
+    W[t] |= ((uint32_t)context->Message_Block[t * 4 + 1]) << 16;
+    W[t] |= ((uint32_t)context->Message_Block[t * 4 + 2]) << 8;
+    W[t] |= ((uint32_t)context->Message_Block[t * 4 + 3]);
+  }
+  for (t = 16; t < 80; t++)
+    W[t] = SHA1_ROTL(1, W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);
+
+  A = context->Intermediate_Hash[0];
+  B = context->Intermediate_Hash[1];
+  C = context->Intermediate_Hash[2];
+  D = context->Intermediate_Hash[3];
+  E = context->Intermediate_Hash[4];
+
+  for (t = 0; t < 20; t++) {
+    temp = SHA1_ROTL(5,A) + SHA_Ch(B, C, D) + E + W[t] + K[0];
+    E = D;
+    D = C;
+    C = SHA1_ROTL(30,B);
+    B = A;
+    A = temp;
+  }
+
+  for (t = 20; t < 40; t++) {
+    temp = SHA1_ROTL(5,A) + SHA_Parity(B, C, D) + E + W[t] + K[1];
+    E = D;
+    D = C;
+    C = SHA1_ROTL(30,B);
+    B = A;
+    A = temp;
+  }
+
+  for (t = 40; t < 60; t++) {
+    temp = SHA1_ROTL(5,A) + SHA_Maj(B, C, D) + E + W[t] + K[2];
+    E = D;
+    D = C;
+    C = SHA1_ROTL(30,B);
+    B = A;
+    A = temp;
+  }
+
+  for (t = 60; t < 80; t++) {
+    temp = SHA1_ROTL(5,A) + SHA_Parity(B, C, D) + E + W[t] + K[3];
+    E = D;
+    D = C;
+    C = SHA1_ROTL(30,B);
+    B = A;
+    A = temp;
+  }
+
+  context->Intermediate_Hash[0] += A;
+  context->Intermediate_Hash[1] += B;
+  context->Intermediate_Hash[2] += C;
+  context->Intermediate_Hash[3] += D;
+  context->Intermediate_Hash[4] += E;
+
+  context->Message_Block_Index = 0;
+}
diff -Nu d:7.501/syscmds.c SOURCES/syscmds.c
--- d:7.501/syscmds.c	2006-11-12 16:00:50 +0200
+++ SOURCES/syscmds.c	2009-02-27 09:04:46 +0200
@@ -60,7 +60,7 @@
 #pragma alloc_text( MISC_TEXT, GetLogName )
 
 TCHAR gaPushdQueue[ DIRSTACKSIZE ];	// PUSHD/POPD storage area
-static TCHAR szLastDirectory[ MAXPATH ];		// last dir for "CD -"
+TCHAR szLastDirectory[ MAXPATH ];	// last dir for "CD -"
 
 
 // change the current directory
@@ -943,7 +943,7 @@
 		return ( error( ERROR_4DOS_DIR_STACK_EMPTY, NULL ));
 
 	// get last (newest) entry in queue
-	for ( pszDirectory = (char *)( end_of_env( gaPushdQueue ) - 1 ); (( pszDirectory > gaPushdQueue ) && ( pszDirectory[-1] != _TEXT('\0') )); pszDirectory-- )
+	for ( pszDirectory = (char *)(long)( end_of_env( gaPushdQueue ) - 1 ); (( pszDirectory > gaPushdQueue ) && ( pszDirectory[-1] != _TEXT('\0') )); pszDirectory-- )
 		;
 
 	// change drive and directory
@@ -1000,7 +1000,7 @@
 
 		for ( nFind = FIND_FIRST; ; nFind = FIND_NEXT ) {
 
-			if ( find_file( nFind, pszDirectory, ( 0x10L | FIND_ONLY_DIRS | FIND_RANGE | FIND_EXCLUDE ), &dir, szSource ) == NULL )
+			if ( find_file( nFind, pszDirectory, ( _A_SUBDIR | _A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH | FIND_ONLY_DIRS | FIND_RANGE | FIND_EXCLUDE ), &dir, szSource ) == NULL )
 				break;
 
 			if ( DestroyDirectory( szSource ) != 0 )
@@ -1100,7 +1100,7 @@
 			}
 
 			// write the new description
-			if (( rc = process_descriptions( szFileName, szNewDescription, ( DESCRIPTION_WRITE | DESCRIPTION_CREATE | DESCRIPTION_REMOVE | DESCRIPTION_PROCESS ))) != 0 )
+			if (( rc = process_descriptions( szFileName, szNewDescription, ( DESCRIPTION_READ | DESCRIPTION_WRITE | DESCRIPTION_CREATE | DESCRIPTION_REMOVE | DESCRIPTION_PROCESS ))) != 0 )
 				nReturn = error( rc, DESCRIPTION_FILE );
 		}
 	}
@@ -1197,6 +1197,21 @@
 }
 
 
+// set the window title
+int _near Title_Cmd( LPTSTR pszCmdLine )
+{
+	if (( pszCmdLine == NULL ) || ( *pszCmdLine == _TEXT('\0') ))
+		return ( Usage( TITLE_USAGE ));
+	else {
+		strip_leading( pszCmdLine, _TEXT(" \t=") );
+		strins( pszCmdLine, _TEXT("=") );
+		strins( pszCmdLine, TITLE_PROMPT );
+	}
+
+	return ( add_variable( pszCmdLine ));
+}
+
+
 // Set the screen colors (using ANSI or the BIOS)
 int _near Color_Cmd( LPTSTR pszCmdLine )
 {
@@ -1272,8 +1287,9 @@
 {
 	extern int fNoComma;
 
-	register LPTSTR pszArg;
-	register int fDisable = 0, i, nArg;
+	register LPTSTR pszArg, p;
+	register int fDisable = 0, nArg;
+	int i;
 
 	// display current default parameters
 	if (( pszCmdLine == NULL ) || ( *pszCmdLine == _TEXT('\0') )) {
@@ -1332,9 +1348,26 @@
 				break;
 
 			case 'C':	// C - compound command separator
-				if (( isalnum( *pszArg )) || ( *pszArg > 255 ))
+				p = &gpIniptr->CmdSep;
+				goto SetChar;
+
+			case 'E':	// E - escape character
+				p = &gpIniptr->EscChr;
+				goto SetChar;
+
+			case 'P':	// P - parameter character
+				p = &gpIniptr->ParamChr;
+SetChar:
+				if ( isalpha( *pszArg ))
 					goto setdos_error;
-				gpIniptr->CmdSep = *pszArg;
+				if ( isdigit( *pszArg )) {
+					i = 0;
+					sscanf( pszArg, FMT_INT, &i );
+					if ( (TCHAR)i == 0 )
+						goto setdos_error;
+					*p = (TCHAR)i;
+				} else
+					*p = *pszArg;
 				break;
 
 			case 'D':	// D - description enable/disable
@@ -1347,12 +1380,6 @@
 				}
 				break;
 
-			case 'E':	// E - escape character
-				if (( isalnum( *pszArg )) || ( *pszArg > 255 ))
-					goto setdos_error;
-				gpIniptr->EscChr = *pszArg;
-				break;
-
 			case 'F':	// set EVAL precision
 				SetEvalPrecision( pszArg, &(gpIniptr->EvalMin), &(gpIniptr->EvalMax) );
 				break;
@@ -1406,12 +1433,6 @@
 				gpIniptr->NoClobber = (char)atoi( pszArg );
 				break;
 
-			case 'P':	// P - parameter character
-				if ( isalnum( *pszArg ))
-					goto setdos_error;
-				gpIniptr->ParamChr = *pszArg;
-				break;
-
 			case 'R':	// R - number of screen rows
 				gpIniptr->Rows = atoi( pszArg );
 				break;
@@ -1443,12 +1464,7 @@
 					goto setdos_error;
 
 				// set the switch character
-				_asm {
-					mov	ax, 3701h
-						xor	dh, dh
-						mov	dl, byte ptr [pszArg]
-						int	21h
-				}
+				SetSwitchChar( *pszArg );
 				gpIniptr->SwChr = (TCHAR)QuerySwitchChar();
 				break;
 
@@ -1473,9 +1489,9 @@
 						if (( i = ( *pszArg - _TEXT('0') )) == 0 )
 							gpIniptr->Expansion = 0;
 						else if ( fDisable )
-							gpIniptr->Expansion |= (char)(1 << (--i));
+							gpIniptr->Expansion |= (1 << (--i));
 						else
-							gpIniptr->Expansion &= ~((char)(1 << (--i)));
+							gpIniptr->Expansion &= ~(1 << (--i));
 					}
 				}
 				break;
@@ -1496,6 +1512,17 @@
 }
 
 
+// set/clear transient mode flag
+int _near Transient_Cmd( LPTSTR pszCmdLine )
+{
+	register int nVal = OffOn( pszCmdLine );
+	if ( nVal == -1 )
+		return Usage( TRANSIENT_USAGE );
+	gnTransient = nVal;
+	return 0;
+}
+
+
 // enable/disable disk verify
 int _near Verify_Cmd( LPTSTR pszCmdLine )
 {
@@ -1843,7 +1870,8 @@
 #define TIMER_1 1
 #define TIMER_2 2
 #define TIMER_3 4
-#define TIMER_SPLIT_TIME  8
+#define TIMER_QUIET 8
+#define TIMER_SPLIT_TIME 16
 
 // Stopwatch - display # of seconds between calls
 int _near Timer_Cmd( LPTSTR pszCmdLine )
@@ -1853,7 +1881,7 @@
 	TCHAR szBuffer[16];
 
 	// get the timer number; default to /1 if none specified
-	if ( GetSwitches( pszCmdLine, _TEXT("123S"), &fTimer, 0 ) != 0 )
+	if ( GetSwitches( pszCmdLine, _TEXT("123QS"), &fTimer, 0 ) != 0 )
 		return ( Usage( TIMER_USAGE ));
 
 	if ( fTimer & TIMER_2 )
@@ -1861,7 +1889,8 @@
 	else if ( fTimer & TIMER_3 )
 		nTimerNumber = 2;
 
-	printf( TIMER_NUMBER, nTimerNumber + 1 );
+	if (( fTimer & TIMER_QUIET ) == 0 )
+		printf( TIMER_NUMBER, nTimerNumber + 1 );
 
 	if ( pszCmdLine == NULL )
 		pszCmdLine = NULLSTR;
@@ -1876,7 +1905,8 @@
 
 		QueryDateTime( &sysDateTime );
 
-		printf( TIMER_ON, gtime( gaCountryInfo.fsTimeFmt ));
+		if (( fTimer & TIMER_QUIET ) == 0 )
+			printf( TIMER_ON, gtime( gaCountryInfo.fsTimeFmt ));
 
 		// start timer - save current time
 		gaTimers[nTimerNumber].fTimer = 1;
@@ -1885,17 +1915,23 @@
 		gaTimers[nTimerNumber].uTSeconds = sysDateTime.seconds;
 		gaTimers[nTimerNumber].uTHundreds = sysDateTime.hundredths;
 
+		if ( gpIniptr->WinMode )
+			gaTimers[nTimerNumber].ulMs = GetWinMs();
+		else if (!( gnOSFlags & DOS_IS_OS2 ))
+			GetTimeStamp( &gaTimers[nTimerNumber].llClock );
+
 		MakeDaysFromDate( &(gaTimers[nTimerNumber].lDay), NULLSTR );
 
 	} else {		// timer toggled off
 
 		// check for split time; turn off timer if not
-		if (( fTimer & TIMER_SPLIT_TIME ) == 0 )
+		if (( fTimer & ( TIMER_SPLIT_TIME | TIMER_QUIET )) == 0 )
 			printf( TIMER_OFF, gtime( gaCountryInfo.fsTimeFmt ));
 
-		_timer( nTimerNumber, szBuffer );
-		printf( TIMER_ELAPSED, szBuffer );
-
+		if (( fTimer & TIMER_QUIET ) == 0 ) {
+			_timer( nTimerNumber, szBuffer );
+			printf( TIMER_ELAPSED, szBuffer );
+		}
 		if (( fTimer & TIMER_SPLIT_TIME ) == 0 )
 			gaTimers[nTimerNumber].fTimer = 0;
 	}
@@ -1907,39 +1943,65 @@
 void _fastcall _timer( int nTimerNumber, LPTSTR pszBuffer )
 {
 	int nHours = 0, nMinutes = 0, nSeconds = 0, nHundreds = 0;
+	ULONG ulTime = 0;
+	t_int64 llClock;
 	DATETIME sysDateTime;
 	LONG lSplitDay;
 
 	// save the split time
 	if ( gaTimers[nTimerNumber].fTimer != 0 ) {
-
-		QueryDateTime( &sysDateTime );
-
-		nHours = sysDateTime.hours - gaTimers[nTimerNumber].uTHours;
-		nMinutes = sysDateTime.minutes - gaTimers[nTimerNumber].uTMinutes;
-		nSeconds = sysDateTime.seconds - gaTimers[nTimerNumber].uTSeconds;
-		nHundreds = sysDateTime.hundredths - gaTimers[nTimerNumber].uTHundreds;
-
-		// adjust negative fractional times
-		if ( nHundreds < 0 ) {
-			nHundreds += 100;
-			nSeconds--;
-		}
-
-		if ( nSeconds < 0 ) {
-			nSeconds += 60;
-			nMinutes--;
-		}
-
-		if ( nMinutes < 0 ) {
-			nMinutes += 60;
-			nHours--;
+		if ( !( gnOSFlags & DOS_IS_OS2 ) ) {// OS/2 time accuracy is 31.25 ms
+			if ( gpIniptr->WinMode )
+				ulTime = ( GetWinMs() - gaTimers[nTimerNumber].ulMs ) / 10;
+			else {	// DOS
+#ifdef NATIVE_INT64
+				GetTimeStamp( &llClock );
+				llClock -= gaTimers[nTimerNumber].llClock;
+				if ( llClock < 0 )	// passed midnight
+					llClock += 0x1800B00000;
+#else
+				t_int64 llZero = { 0, 0 };
+				GetTimeStamp( &llClock );
+				Subtract64From64( &gaTimers[nTimerNumber].llClock, &llClock );
+				Subtract64From64( &llZero, &llClock );
+				if ((signed long)llClock.ulHighPart < 0 ) {
+					t_int64 llOneDay = { 0x18, 0x00B00000 };
+					Add64To64( &llClock, &llOneDay );
+				}
+#endif
+				ShiftLeft16( &llClock );
+				// 65536 * 14318180 / 12 / 100 = 781963537.066667
+				ulTime = Divide64By32( &llClock, 781963537 );
+			}
+			nHundreds = (int)( ulTime % 100 );
+			nSeconds = (int)(( ulTime /= 100 ) % 60 );
+			nMinutes = (int)(( ulTime /= 60 ) % 60 );
+			nHours = (int)( ulTime / 60 );
+		} else {
+			QueryDateTime( &sysDateTime );
+			nHours = sysDateTime.hours - gaTimers[nTimerNumber].uTHours;
+			nMinutes = sysDateTime.minutes - gaTimers[nTimerNumber].uTMinutes;
+			nSeconds = sysDateTime.seconds - gaTimers[nTimerNumber].uTSeconds;
+			nHundreds = sysDateTime.hundredths - gaTimers[nTimerNumber].uTHundreds;
+
+			// adjust negative fractional times
+			if ( nHundreds < 0 ) {
+				nHundreds += 100;
+				nSeconds--;
+			}
+			if ( nSeconds < 0 ) {
+				nSeconds += 60;
+				nMinutes--;
+			}
+			if ( nMinutes < 0 ) {
+				nMinutes += 60;
+				nHours--;
+			}
+			// check for > 24 hours elapsed
+			MakeDaysFromDate( &lSplitDay, NULLSTR );
+			if (( lSplitDay - gaTimers[nTimerNumber].lDay ) > 0 )
+				nHours += 24;
 		}
-
-		// check for > 24 hours elapsed
-		MakeDaysFromDate( &lSplitDay, NULLSTR );
-		if (( lSplitDay - gaTimers[nTimerNumber].lDay ) > 0 )
-			nHours += 24;
 	}
 
 	sprintf( pszBuffer, TIMER_SPLIT, nHours, gaCountryInfo.szTimeSeparator[0], nMinutes, gaCountryInfo.szTimeSeparator[0], nSeconds, gaCountryInfo.szDecimal[0], nHundreds);
@@ -2006,7 +2068,7 @@
 int _near Date_Cmd( LPTSTR pszCmdLine )
 {
 	unsigned int uDay, uMonth, uYear;
-	TCHAR szBuf[12];
+	TCHAR szBuf[32];
 	DATETIME sysDateTime;
 	long fDate;
 
@@ -2029,21 +2091,18 @@
 
 	for ( ; ; ) {
 
-		printf( NEW_DATE, dateformat[ gaCountryInfo.fsDateFmt ] );
+		sprintf( szBuf, NEW_DATE, dateformat[ gaCountryInfo.fsDateFmt ] );
+		printf( szBuf, gaCountryInfo.szDateSeparator[0], gaCountryInfo.szDateSeparator[0] );
 		if ( egets( szBuf, 10, EDIT_DATA | EDIT_SCROLL_CONSOLE ) == 0 )
 			break;
 got_date:
 		// valid date entry?
-		if ( GetStrDate( szBuf, &uMonth, &uDay, &uYear ) == 3 ) {
+		if ( !GetStrDate( szBuf, &uMonth, &uDay, &uYear )) {
 
 			// SetDateTime() requires date & time together
 			QueryDateTime( &sysDateTime );
 
-			if (( sysDateTime.year = uYear ) < 80 )
-				sysDateTime.year += 2000;
-			else if ( sysDateTime.year < 127 )
-				sysDateTime.year += 1900;
-
+			sysDateTime.year = uYear;
 			sysDateTime.month = (unsigned char)uMonth;
 			sysDateTime.day = (unsigned char)uDay;
 
@@ -2088,7 +2147,7 @@
 
 	for ( ; ; ) {
 
-		qputs( NEW_TIME );
+		printf( NEW_TIME, gaCountryInfo.szTimeSeparator[0], gaCountryInfo.szTimeSeparator[0] );
 		if ( egets( szBuf, 10, EDIT_DATA | EDIT_SCROLL_CONSOLE ) == 0 )
 			return 0;	// quit or no change
 got_time:
@@ -2142,6 +2201,20 @@
 }
 
 
+// display or set the country code (only for DOS 3.0+ & NT)
+int _near Country_Cmd( LPTSTR pszCmdLine )
+{
+	register int nReturn = 0;
+
+	if ( !pszCmdLine || *pszCmdLine == _TEXT('\0')) // show current country
+		printf( COUNTRY_CODE, nReturn = gaCountryInfo.nCountryID );
+
+	if ( pszCmdLine && isdigit( *pszCmdLine ) && ( nReturn = SetCountry( atoi( pszCmdLine ))) != 0 )
+		nReturn = error( nReturn, pszCmdLine );
+
+	return nReturn;
+}
+
 
 // call the external Help (4HELP.EXE)
 int _near Help_Cmd( LPTSTR pszCmdLine )
diff -Nu d:7.501/thetime.h SOURCES/thetime.h
--- d:7.501/thetime.h	1970-01-01 02:00:00 +0200
+++ SOURCES/thetime.h	2007-07-03 13:37:06 +0200
@@ -0,0 +1,59 @@
+/****************************************************************************
+*
+*                            Open Watcom Project
+*
+*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
+*
+*  ========================================================================
+*
+*    This file contains Original Code and/or Modifications of Original
+*    Code as defined in and that are subject to the Sybase Open Watcom
+*    Public License version 1.0 (the 'License'). You may not use this file
+*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
+*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
+*    provided with the Original Code and Modifications, and is also
+*    available at www.sybase.com/developer/opensource.
+*
+*    The Original Code and all software distributed under the License are
+*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
+*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
+*    NON-INFRINGEMENT. Please see the License for the specific language
+*    governing rights and limitations under the License.
+*
+*  ========================================================================
+*
+* Description:  WHEN YOU FIGURE OUT WHAT THIS FILE DOES, PLEASE
+*               DESCRIBE IT HERE!
+*
+****************************************************************************/
+
+
+#include "variety.h"
+#if defined(__OS2__) || defined(__NT__)
+    // the OS/2 and NT files are identical
+    #if defined(__SW_BM)
+
+        #include "thread.h"
+
+        #define _INITTHETIME
+        #define _THE_TIME       (__THREADDATAPTR->__The_timeP)
+
+    #else
+
+        static  struct  tm      The_time;
+        #define _INITTHETIME
+        #define _THE_TIME       The_time
+
+    #endif
+#else
+    #ifdef __NETWARE__
+        #define _INITTHETIME
+        #define _THE_TIME       (__THREADDATAPTR->__The_timeP)
+    #else
+        #define _INITTHETIME
+        static  struct  tm        The_time;
+        #define _THE_TIME         The_time
+    #endif
+#endif
diff -Nu d:7.501/timedata.h SOURCES/timedata.h
--- d:7.501/timedata.h	1970-01-01 02:00:00 +0200
+++ SOURCES/timedata.h	2007-07-03 13:37:06 +0200
@@ -0,0 +1,56 @@
+/****************************************************************************
+*
+*                            Open Watcom Project
+*
+*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
+*
+*  ========================================================================
+*
+*    This file contains Original Code and/or Modifications of Original
+*    Code as defined in and that are subject to the Sybase Open Watcom
+*    Public License version 1.0 (the 'License'). You may not use this file
+*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
+*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
+*    provided with the Original Code and Modifications, and is also
+*    available at www.sybase.com/developer/opensource.
+*
+*    The Original Code and all software distributed under the License are
+*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
+*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
+*    NON-INFRINGEMENT. Please see the License for the specific language
+*    governing rights and limitations under the License.
+*
+*  ========================================================================
+*
+* Description:  Specification of <time.h> internal interfaces.
+*
+****************************************************************************/
+
+#ifndef TIMEDATA_H_INCLUDED
+#define TIMEDATA_H_INCLUDED
+
+#include "variety.h"
+#include <time.h>
+
+extern int              __dst_adjust;
+extern struct tm        __start_dst; /* start of daylight savings */
+extern struct tm        __end_dst;   /* end of daylight savings */
+
+#define SECONDS_FROM_1900_TO_1970       2208988800UL
+#define SECONDS_PER_DAY                 ( 24 * 60 * 60UL )
+#define DAYS_FROM_1900_TO_1970          ( ( long ) ( SECONDS_FROM_1900_TO_1970 / SECONDS_PER_DAY ) )
+
+extern struct tm        *__brktime( unsigned long, time_t, long, struct tm * );
+extern time_t           __local_mktime( const struct tm *, long *, long * );
+extern int              __leapyear( unsigned );
+extern int              __isindst( struct tm * );
+extern int              __getctime( struct tm * );
+extern int              __read_tzfile( const char *tz );
+extern void             __check_tzfile( time_t t, struct tm *timep );
+
+extern short const __based(__segname("_CONST"))        __diyr[];  /* days in normal year array */
+extern short const __based(__segname("_CONST"))        __dilyr[]; /* days in leap year array */
+
+#endif
diff -Nu d:7.501/timeutil.c SOURCES/timeutil.c
--- d:7.501/timeutil.c	1970-01-01 02:00:00 +0200
+++ SOURCES/timeutil.c	2007-07-03 13:37:06 +0200
@@ -0,0 +1,250 @@
+/****************************************************************************
+*
+*                            Open Watcom Project
+*
+*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
+*
+*  ========================================================================
+*
+*    This file contains Original Code and/or Modifications of Original
+*    Code as defined in and that are subject to the Sybase Open Watcom
+*    Public License version 1.0 (the 'License'). You may not use this file
+*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
+*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
+*    provided with the Original Code and Modifications, and is also
+*    available at www.sybase.com/developer/opensource.
+*
+*    The Original Code and all software distributed under the License are
+*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
+*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
+*    NON-INFRINGEMENT. Please see the License for the specific language
+*    governing rights and limitations under the License.
+*
+*  ========================================================================
+*
+* Description:  time utility functions
+*
+****************************************************************************/
+
+#include "variety.h"
+#include <time.h>
+#include "rtdata.h"
+#include "timedata.h"
+
+static int time_less( const struct tm *t1, const struct tm *t2 );
+
+static int calc_yday( const struct tm *timetm, int year )
+{
+    struct tm   tmptm;
+    int         month_days;
+    int         first_wday;
+    int         nth_week;
+    short const *diyr;
+
+    if( timetm->tm_isdst == 0 ) { // M.m.n.d form
+        diyr = ( __leapyear( ( unsigned ) year + 1900 ) ) ? __dilyr : __diyr;
+        month_days = diyr[timetm->tm_mon + 1] - diyr[timetm->tm_mon]; 
+        tmptm.tm_sec   = 0;
+        tmptm.tm_min   = 0;
+        tmptm.tm_hour  = 0;
+        tmptm.tm_mday  = 1;
+        tmptm.tm_mon   = timetm->tm_mon;
+        tmptm.tm_year  = year;
+        tmptm.tm_isdst = 0;
+        ( void ) mktime( &tmptm );
+        first_wday = ( timetm->tm_wday - tmptm.tm_wday + 7 ) % 7;
+        if( timetm->tm_mday == 5 ) {
+            if( ( 1 + first_wday + ( timetm->tm_mday - 1 ) * 7 ) > month_days )
+                nth_week = timetm->tm_mday - 2;   // fifth req. weekday does not exist
+            else 
+                nth_week = timetm->tm_mday - 1;
+        } else 
+            nth_week = timetm->tm_mday - 1;
+        return( tmptm.tm_yday + first_wday + nth_week * 7 );
+    }
+    if( timetm->tm_isdst == 1 )  /* if Jn form */
+        return( timetm->tm_yday - 1 );
+    return( timetm->tm_yday );
+}
+
+/* determine if in souther hemisphere -> start is after end */
+static int check_order( const struct tm *start, const struct tm *end, int year )
+{
+    int start_day;
+    int end_day;
+
+    /* these quick checks should always be enough */
+    if( ( start->tm_isdst == 0 ) && ( end->tm_isdst == 0 ) ) { // M.m.n.d form
+        if( start->tm_mon > end->tm_mon ) 
+            return( 1 ); 
+        if( start->tm_mon < end->tm_mon ) 
+            return( 0 );
+    }
+    /* start/end of daylight savings time is in the same month (rare case) */
+    /* these are *expensive* calculations under NT since 2 TZ checks must be done */
+    start_day = calc_yday( start, year );
+    end_day = calc_yday( end, year );
+    if( start_day > end_day ) 
+        return( 1 );
+    return( 0 );
+}
+
+/* determine if daylight savings time */
+int __isindst( struct tm *t )
+{
+    int                 month;
+    int                 dst;
+    int                 n1;
+    int                 n2;
+    int                 month_days;
+    int                 time_check;
+    int                 south;
+    struct tm const     *start;
+    struct tm const     *end;
+    short const         *diyr;
+
+    // already determined -- if we are sure
+    if( t->tm_isdst >= 0 ) 
+        return( t->tm_isdst );
+    dst = 0;
+    // if zone doesn't have a daylight savings period
+    if( _RWD_daylight == 0 ) 
+        return( t->tm_isdst = dst );
+    //  // check for no daylight savings time rule
+    //  if( tzname[1][0] == '\0' ) {    // doesn't work since Win32 says
+    //      return( t->tm_isdst = dst );// daylight zone name = standard zone name
+    //  }
+
+    south = check_order( &_RWD_start_dst, &_RWD_end_dst, t->tm_year );
+    if( south ) {
+        // if southern hemisphere
+        // invert start and end dates and then invert return value
+        start = &_RWD_end_dst;
+        end = &_RWD_start_dst;
+    } else {
+        start = &_RWD_start_dst;
+        end = &_RWD_end_dst;
+    }
+    month = t->tm_mon;
+    diyr = ( __leapyear( ( unsigned ) t->tm_year + 1900 ) ) ? __dilyr : __diyr;
+    month_days = diyr[month + 1] - diyr[month]; 
+    time_check = 0;
+    /*
+     * M.m.n.d form
+     * m = start->tm_mon  (month 0-11)
+     * n = start->tm_mday (n'th week day 1-5)
+     * d = start->tm_wday (week day 0-6)
+     */
+    if( start->tm_isdst == 0 ) { /* if Mm.n.d form */
+        if( month > start->tm_mon ) 
+            dst = 1;                        /* assume dst for now */ 
+        else if( month == start->tm_mon ) {
+            /* calculate for current day */
+            n1 = t->tm_mday - ( t->tm_wday + 7 - start->tm_wday ) % 7;
+            /* calculate for previous day */
+            n2 = t->tm_mday - 1 - ( t->tm_wday - 1 + 7 - start->tm_wday ) % 7;
+            //  n_ stands for the day of the month that is past &&
+            //  is closest to today && is the required weekday
+            if( start->tm_mday == 5 ) {
+                if( n1 > month_days - 7 ) {
+                    dst = 1;                /* assume dst for now */
+                    if( n2 <= month_days - 7 ) 
+                        time_check = 1;
+                }
+            } else {
+                if( n1 >= 7 * ( start->tm_mday - 1 ) + 1 ) {
+                    dst = 1;                /* assume dst for now */
+                    if( n2 < 7 * ( start->tm_mday - 1 ) + 1 ) 
+                        time_check = 1;
+                }
+            }
+        }
+    } else {
+        n1 = start->tm_yday;
+        if( start->tm_isdst == 1 ) { /* if Jn form */
+            if( __leapyear( ( unsigned ) t->tm_year + 1900 ) ) {
+                if( n1 > __diyr[2] )
+                    n1++;      /* past Feb 28 */
+            }
+            n1--;
+        }
+        if( t->tm_yday >= n1 ) {
+            dst = 1;                        /* assume dst for now */
+            if( t->tm_yday == n1 )
+                time_check = 1;
+        }
+    }
+    /* if it is the day for a switch-over then check the time too */
+    if( time_check )
+        dst = !time_less( t, start );
+
+    /* if we are certain that it is before daylight saving then return */
+    if( dst == 0 ) {
+        if( south )
+            dst = south - dst;  /* invert value of dst */
+        return( t->tm_isdst = dst );
+    }
+
+    /* now see if it is after daylight saving */
+    time_check = 0;
+    if( end->tm_isdst == 0 ) { /* if Mm.n.d form */
+        if( month > end->tm_mon ) 
+            dst = 0;                        /* not dst */ 
+        else if( month == end->tm_mon ) {
+            dst = 0;
+            /* calculate for current day */
+            n1 = t->tm_mday - ( t->tm_wday + 7 - end->tm_wday ) % 7;
+            /* calculate for previous day */
+            n2 = t->tm_mday - 1 -
+                ( t->tm_wday - 1 + 7 - end->tm_wday ) % 7;
+            if( end->tm_mday == 5 ) {
+                if( n1 <= month_days - 7 ) 
+                    dst = 1; 
+                else if( n2 <= month_days - 7 ) 
+                    time_check = 1;
+            } else {
+                if( n1 < 7 * ( end->tm_mday - 1 ) + 1 ) 
+                    dst = 1; 
+                else if( n2 < 7 * ( end->tm_mday - 1 ) + 1 ) 
+                    time_check = 1;
+            }
+        }
+    } else {
+        n1 = end->tm_yday;
+        if( end->tm_isdst == 1 ) { /* if Jn form */
+            if( __leapyear( ( unsigned ) t->tm_year + 1900 ) ) {
+                if( n1 > __diyr[2] )
+                    n1++;      /* past Feb 28 */
+            }
+            n1--;
+        }
+        if( t->tm_yday >= n1 ) {
+            dst = 0;
+            if( t->tm_yday == n1 )
+                time_check = 1;
+        }
+    }
+    /* if it is the day for a switch-over then check the time too */
+    if( time_check )
+        dst = time_less( t, end );
+    if( south )
+        dst = south - dst;      /* invert value of dst */
+    return( t->tm_isdst = dst );
+}
+
+static int time_less( const struct tm *t1, const struct tm *t2 )
+{
+    int before;
+
+    before = 0;
+    if( t1->tm_hour < t2->tm_hour ) 
+        before = 1; 
+    else if( t1->tm_hour == t2->tm_hour ) {
+        if( t1->tm_min < t2->tm_min
+        ||  t1->tm_min == t2->tm_min && t1->tm_sec < t2->tm_sec )
+                before = 1;
+    }
+    return( before );
+}
diff -Nu d:7.501/tmi0sdgl.h SOURCES/tmi0sdgl.h
--- d:7.501/tmi0sdgl.h	1970-01-01 02:00:00 +0200
+++ SOURCES/tmi0sdgl.h	2008-12-29 10:51:38 +0200
@@ -0,0 +1,338 @@
+/*****************************************************************************
+ * TMi0SDGL.H   TMi0SDGL 2 C/C++ Header File                    Version 2.15
+ *
+ * Too-Much-in-0ne-So-Don't-Get-Lost(tm) Revision 2 CPU/FPU detection library
+ * Copyright(c) 1996-2000 by B-coolWare.  Written by Bobby Z.
+ *****************************************************************************
+ * defines that affect compilation:
+
+__need_fp_cpu_Speed__   enables compilation of floating point version of
+                        cpu_Speed routine. Disabled by default, for this
+                        version links in too much code.
+__DPMI__                specifies that this code is compiled to run under
+                        DPMI
+__Windows__             specifies that this code is compiled to run under
+                        Windows. Effectively the same as __DPMI__
+__Win32__               specifies that this code in compiled to run under
+                        Win32.
+*/
+
+/* uncomment this if you want floating point version of cpu_Speed to be
+   compiled.
+#define __need_fp_cpu_Speed__
+*/
+#define __No_P5Speed__ /* comment this to enable TSC speed test in TMi0SDGL */
+#define __No_87Speed__ /* comment this to enable x87 speed test in TMi0SDGL */
+#define __No_SerialN__ /* comment this to enable Pentium III serial # fetch */
+#define __No_Version__ /* comment this to enable library version function */
+
+#ifndef __TMi0SDGL_H
+#define __TMi0SDGL_H
+
+typedef unsigned char byte;
+#ifdef __Win32__
+typedef unsigned short int word;
+typedef unsigned int dword;
+typedef void * pointer;
+#else
+typedef unsigned int word;
+typedef unsigned long dword;
+typedef void far * pointer;
+#endif
+
+#ifdef __Win32__
+#define _call __stdcall
+#define _dist
+#else
+#define _call _pascal
+#endif
+
+/* extra flags */
+
+#define efHasFPUonChip  0x0001
+#define efWeitekPresent 0x0002
+#define efCPUIDSupport  0x0004
+#define efDXType        efCPUIDSupport+efHasFPUonChip
+#define efEmulatedFPU   0x0008
+#define efCentaurLevel  0x0010
+#define efTSCSupport    0x0020
+
+/* CPU type constants */
+
+#define i8088           0
+#define i8086           1
+#define i80C88          2
+#define i80C86          3
+#define i80188          4
+#define i80186          5
+#define necV20          6
+#define necV30          7
+#define i80286          8
+#define i80386SX        9
+#define i80386DX        10
+#define i386SL          11
+#define ibm386SLC       12
+#define Am386SX         13
+#define Am386DX         14
+#define CT38600         15
+#define CT38600SX       16
+#define RapidCAD        17
+#define i486SX          18
+#define i486DX          19
+#define ibm486SLC       20
+#define ibm486SLC2      21
+#define ibm486BL3       22
+#define Cx486           23
+#define umcU5S          24
+#define umcU5D          25
+#define Am486           26
+#define iPentium        27
+#define iP54C           28
+#define CxM1            29
+#define AmdK5           30
+#define Nx586           31
+#define iPentiumPro     32
+#define AmdK6           33
+#define iP7             34
+#define iP8             35
+#define CxM2            36
+#define Am486DX         37
+#define AmdK5_2         38
+#define WinChipC6       39
+#define i486SL          40
+#define AmdK7           41
+#define WinChip2        42
+#define Rise_mP6        43
+#define i376            44
+#define WinChip3        45
+#define CxIII           46
+#define MaxCPU          CxIII
+
+/* FPU type constants */
+
+#define fpuInternal     100
+#define fpuNone         0
+#define i8087           1
+#define i80287          2
+#define i80287XL        3
+#define i80387          4
+#define rCAD            5
+#define cx287           6
+#define cx387           7
+#define cx487           8
+#define cxEMC87         9
+#define iit287          10
+#define iit387          11
+#define iit487          12
+#define ct387           13
+#define ulsi387         14
+#define ulsi487         15
+#define i487sx          16
+#define Nx587           17
+#define iit487DLC       18
+#define i387SLMobile    19
+
+
+/* L2 cache size descriptors (CPUID level 2, lower nibble of descriptor) */
+#define cdNoCache       0
+#define cd128k          1
+#define cd256k          2
+#define cd512k          3
+#define cd1M            4
+#define cd2M            5
+#define cd4M            6
+
+/* Intel feature bits */
+#define ifbFPU          0x00000001
+#define ifbVME          0x00000002
+#define ifbDE           0x00000004
+#define ifbPSE          0x00000008
+#define ifbTSC          0x00000010
+#define ifbMSR          0x00000020
+#define ifbPAE          0x00000040
+#define ifbMCE          0x00000080
+#define ifbCX8          0x00000100
+#define ifbAPIC         0x00000200
+#define ifbSEP          0x00000800
+#define ifbMTRR         0x00001000
+#define ifbPGE          0x00002000
+#define ifbMCA          0x00004000
+#define ifbCMOV         0x00008000
+#define ifbPAT          0x00010000
+#define ifbPSE36        0x00020000
+#define ifbPSN          0x00040000
+#define ifbCLFLSH       0x00080000
+#define ifbDTES         0x00200000
+#define ifbACPI         0x00400000
+#define ifbMMX          0x00800000
+#define ifbFXSR         0x01000000
+#define ifbSSE          0x02000000
+#define ifbSSE2         0x04000000
+#define ifbSSNP         0x08000000
+#define ifbIA64         0x40000000
+
+typedef struct { dword eax;
+                 dword ebx;
+                 dword ecx;
+                 dword edx; } customCpuid;
+
+
+#ifdef  __LIB__
+
+typedef struct { byte Extra;
+                 byte Family;
+                 byte Model;
+                 byte Step; } cpuid1Layout;
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+ extern byte _dist _call getCPUType( void ); /* sets cpu variable to CPU code */
+ extern byte _dist _call getFPUType( void ); /* sets fpu variable to FPU code */
+ extern word _dist _call getCyrixModel( void );
+ extern word _dist _call Speed( void );
+ extern word _dist _call getPentiumSpeed( void );
+ extern byte _dist _call TSCDisabled( void );
+ extern word _dist _call getCacheSize( void );
+ extern void _dist _call CxCPUIDEnable( void );
+ extern byte _dist _call getL2CacheDesc( void );
+ extern void _dist _call getCPUID( dword Level, pointer Result );
+#ifndef __DPMI__
+ #ifndef __Windows__
+  #ifndef __Win32__
+   extern byte _dist _pascal isV86( void );
+   /* extern byte _dist _pascal checkEMM386( void ); */
+  #endif
+ #endif
+#endif
+#ifdef __cplusplus
+ }
+#endif  /* __cplusplus */
+
+char * _call cpu_Type( void );
+ /* returns cpu name */
+char * _call fpu_Type( void );
+ /* returns fpu name */
+int _call cpu_Speed( void );
+ /* returns current CPU's clock speed in MHz */
+char * _call getCPUSerialNumber( void );
+ /* returns CPU Serial Number if present or empty string otherwise */
+#ifdef __need_fp_cpu_Speed__
+float _call fcpu_Speed( void );
+ /* returns current CPU's clock speed in MHz, floating point value */
+#endif
+word _call getVersion( void );
+
+
+/* variables and constants */
+
+byte _pascal cpu = 0xFF; /* initialize cpu and fpu as 0xFF, so they will be */
+byte _pascal fpu = 0xFF; /* detected just once.                             */
+word _pascal extFlags = 0;
+byte _pascal cpuid0[12] = {0,0,0,0,0,0,0,0,0,0,0,0};
+byte _pascal zeroByte = 0; /* this is to make cpuid0 a valid C string so that
+                             we can use strncmp() on it */
+dword _pascal cpuid1 = 0L;
+dword _pascal cpuBrand = 0L;
+dword _pascal cpuFeatures = 0L;
+
+/* following constants should not be accessed from client code, they are for */
+/* internal purposes only and should not be changed.                         */
+byte _pascal fpuDenormal[10] = {1,0,0,0,0,0,0,0,0,0};
+byte _pascal fpuOp1[10] = {0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F};
+word _pascal fpu_53bit_prec = 0x02F7;
+word _pascal speedShift = 0;
+dword _pascal speedTable[MaxCPU+1] =
+                       {
+                        0x0002AD26, /* i8088 */
+                        0x0002AD26, /* i8086 */
+                        0x0002AD26, /* i80C88 */
+                        0x0002AD26, /* i80C86 */
+                        0x0000BA6F, /* i80188 */
+                        0x0000BA6F, /* i80186 */
+                        0x00008C38, /* necV20 */
+                        0x0000912C, /* necV30 */
+                        0x00006FDC, /* i80286 */
+                        0x00007480, /* i80386SX */
+                        0x00007480, /* i80386DX */
+                        0x00007480, /* i386SL */
+                        0x00007480, /* ibm386slc */
+                        0x00007415, /* Am386SX */
+                        0x00007415, /* Am386DX */
+                        0x00007480, /* CT38600 */
+                        0x00007480, /* CT38600SX */
+                        0x00007415, /* RapidCAD */
+                        0x00007480, /* i486SX */
+                        0x00007480, /* i486DX */
+                        0x00007486, /* ibm486slc */
+                        0x00007486, /* ibm486slc2 */
+                        0x00007486, /* ibm486bl3 */
+                        0x0000668A, /* Cx486 */
+                        0x00003C90, /* umcU5S */
+                        0x00003C90, /* umcU5D */
+                        0x00007480, /* Am486 */
+                        0x00007850, /* Pentium */
+                        0x00007900, /* P54C */
+                        0x00004800, /* CxM1 */
+                        0x000061D0, /* AmdK5 */
+                        0x0000792E, /* Nx586      !!! needs adjustment */
+                        0x00006BCD, /* Pentium Pro */
+                        0x00003CD2, /* AmdK6 */
+                        0x00003079, /* P7         !!! needs adjustment */
+                        0x00003079, /* P8         !!! needs adjustment */
+                        0x0000D688, /* CxM2       !!! needs adjustment */
+                        0x00007480, /* Am486DX */
+                        0x00008AC6, /* AMD K5 models 2 & 3 */
+                        0x00003900, /* WinChip C6 !!! needs adjustment */
+                        0x00007480, /* i486SL */
+                        0x00006EC0, /* AMD K7       !!! needs adjustment */
+                        0x00003CD2, /* WinChip2     !!! needs adjustment */
+                        0x00003CD2, /* Rise mP6(tm) !!! needs adjustment */
+                        0x00007480, /* i376 */
+                        0x00003CD2, /* WinChip3     !!! needs adjustment */
+                        0x0000D688  /* Cyrix III    !!! needs adjustment */
+                       };
+
+#else   /* !__LIB__ */
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+ /* define interface with library functions... */
+ extern char * _call cpu_Type( void );
+ extern char * _call fpu_Type( void );
+ extern int _call cpu_Speed( void );
+ extern int _call ncpu_Speed( void );
+ extern char * _call getCPUSerialNumber( void );
+#ifdef __need_fp_cpu_Speed__
+ extern float _call fcpu_Speed( void );
+#endif
+ extern word _call getVersion( void );
+ extern word _dist _call getCacheSize( void );
+ extern void _dist _call CxCPUIDEnable( void );
+ extern void _dist _call getCPUID( dword Level, pointer Result );
+#ifndef __DPMI__
+ #ifndef __Windows__
+  #ifndef __Win32__
+   extern byte _dist _pascal isV86( void );
+   /* extern byte _dist _pascal checkEMM386( void ); */
+  #endif
+ #endif
+#endif
+
+ /* ...and variables */
+ extern byte _pascal cpu;
+ extern byte _pascal fpu;
+ extern word _pascal extFlags;
+ extern byte _pascal cpuid0[12];
+ extern dword _pascal cpuid1;
+ extern dword _pascal cpuBrand;
+ extern dword _pascal cpuFeatures;
+
+#ifdef __cplusplus
+ }
+#endif
+
+#endif  /* __LIB__ */
+
+#endif  /* __TMi0SDGL_H */
diff -Nu d:7.501/tmi0sdgl.inc SOURCES/tmi0sdgl.inc
--- d:7.501/tmi0sdgl.inc	1970-01-01 02:00:00 +0200
+++ SOURCES/tmi0sdgl.inc	2008-12-30 09:37:50 +0200
@@ -0,0 +1,226 @@
+; -----------------------------------------------------------------------------
+; TMI0SDGL.INC - Common TMi0SDGL 2 macros and defines             Version 2.15
+;
+; Too-Much-in-0ne-So-Don't-Get-Lost(tm) Revision 2 CPU/FPU Detection Library
+; Copyright(c) 1996-2000 by B-coolWare. Written by Bobby Z.
+; -----------------------------------------------------------------------------
+;
+
+; CPU codes
+
+        i8088           equ     0       ; direct detect
+        i8086           equ     1       ; direct detect
+        i80C88          equ     2       ; direct detect
+        i80C86          equ     3       ; direct detect
+        i80188          equ     4       ; direct detect
+        i80186          equ     5       ; direct detect
+        necV20          equ     6       ; direct detect
+        necV30          equ     7       ; direct detect
+        i80286          equ     8       ; direct detect
+        i80386sx        equ     9       ; direct detect
+        i80386dx        equ     10      ; direct detect
+        i386sl          equ     11      ; direct detect
+        ibm386slc       equ     12      ; direct detect (real mode only)
+        am386sx         equ     13      ; direct detect
+        am386dx         equ     14      ; direct detect
+        ct38600         equ     15      ; direct detect
+        ct38600sx       equ     16      ; direct detect
+        RapidCAD        equ     17      ; direct detect
+        i486sx          equ     18      ; direct detect (models distinguished..)
+        i486dx          equ     19      ; direct detect (..sometimes)
+        ibm486slc       equ     20      ; direct detect (real mode only)
+        ibm486slc2      equ     21      ; direct detect (real mode only)
+        ibm486bl3       equ     22      ; direct detect (real mode only)
+        Cx486           equ     23      ; direct detect (models distinguished)
+        umcU5S          equ     24      ; direct detect (CPUID)
+        umcU5D          equ     25      ; direct detect (CPUID)
+        am486           equ     26      ; direct detect (CPUID)
+        iPentium        equ     27      ; direct detect (models distinguished)
+        iP54C           equ     28      ; direct detect (CPUID)
+        CxM1            equ     29      ; direct detect (CPUID)
+        amdK5           equ     30      ; direct detect (CPUID)
+        Nx586           equ     31      ; direct detect
+        iPentiumPro     equ     32      ; direct detect (models distinguished)
+        amdK6           equ     33      ; direct detect (CPUID)
+        iP7             equ     34      ; direct detect (CPUID)
+        iP8             equ     35      ; direct detect (CPUID)
+        CxM2            equ     36      ; direct detect (CPUID)
+        am486dx         equ     37      ; direct detect
+        amdK5_2         equ     38      ; direct detect (CPUID)
+        WinChipC6       equ     39      ; direct detect (CPUID)
+        i486sl          equ     40      ; direct detect
+        AmdK7           equ     41      ; direct detect (CPUID)
+        WinChip2        equ     42      ; direct detect (CPUID)
+        Rise_mP6        equ     43      ; direct detect (CPUID)
+        i376            equ     44      ; direct detect
+        WinChip3        equ     45      ; direct detect
+        CxIII           equ     46      ; direct detect
+
+; FPU codes
+
+        fpuInternal     equ     100
+        fpuNone         equ     0
+        i8087           equ     1
+        i80287          equ     2
+        i80287xl        equ     3
+        i80387          equ     4
+        rCAD            equ     5
+        cx287           equ     6
+        cx387           equ     7
+        cx487           equ     8
+        cxEMC87         equ     9
+        iit287          equ     10
+        iit387          equ     11
+        iit487          equ     12
+        ct387           equ     13
+        ulsi387         equ     14
+        ulsi487         equ     15
+        i487sx          equ     16      ; this is actually a 486DX
+        Nx587           equ     17
+        iit487DLC       equ     18
+        i387SLMobile    equ     19
+
+; flags
+
+        EF_AC   equ     00040000h       ; AC bit of EFLAGS
+        EF_ID   equ     00200000h       ; ID bit of EFLAGS
+        MSW_ET  equ     00000010h       ; ET bit of MSW
+        MSW_NE  equ     00000020h       ; NE bit of MSW
+
+        efHasFPUonChip  equ     0001h
+        efWeitekPresent equ     0002h
+        efCPUIDSupport  equ     0004h
+        efDXType        equ     efCPUIDSupport+efHasFPUonChip
+        efEmulatedFPU   equ     0008h
+        efCentaurLevel  equ     0010h
+        efTSCSupport    equ     0020h
+
+; macros
+
+; _CPUID - a combination macro for TASM 3.x and TASM 4.x or later
+; first don't support CPUID, second does.
+
+_cpuid   macro
+        .586
+        cpuid
+        endm
+
+; read MSR and write MSR macros
+
+_rdmsr  macro   Reg
+        .586p
+        mov     ecx,Reg
+        rdmsr
+        endm
+
+_wrmsr  macro   Reg
+        .586p
+        mov     ecx,Reg
+        wrmsr
+        endm
+
+; read TSC (time stamp counter) macro
+
+_rdtsc  macro
+IFDEF   __Use_MSR_TSC__
+        push    ecx
+        _rdmsr  10h
+        pop     ecx
+ELSE
+        .586
+        rdtsc
+ENDIF
+        endm
+
+_getcr4 macro
+        .586p
+        mov     eax,cr4
+        endm
+
+; my PDP-like command macros :)
+
+clr     macro   reg
+        sub     reg,reg
+        endm
+
+ldx     macro   value
+        mov     dx,offset value
+        endm
+
+ldi     macro   value
+        mov     di,offset value
+        endm
+
+lsi     macro   value
+        mov     si,offset value
+        endm
+
+lbx     macro   value
+        mov     bx,offset value
+        endm
+
+
+; equivalents
+
+_bp     equ     <byte ptr>      ; byte ref       (8)
+_wp     equ     <word ptr>      ; word ref       (16)
+_dp     equ     <dword ptr>     ; doubleword ref (32 or 16:16)
+_qp     equ     <qword ptr>     ; quadraword ref (32:32)
+_tp     equ     <tbyte ptr>     ; terabyte ref   (10 bytes)
+_np     equ     <near ptr>      ; near ref       (16 or 32)
+_fp     equ     <far ptr>       ; far ref        (16:16)
+_fpp    equ     <fword ptr>     ; far pm ref     (16:32)
+
+
+        .DATA                   ; data segment
+
+IFDEF   __32bit__
+ IFDEF __Windows__
+  IFNDEF __D32__
+  __Win32__ = 1
+  ENDIF
+ ENDIF
+ENDIF
+
+IFDEF __Win32__
+GLOBAL  CPU : BYTE
+GLOBAL  FPU : BYTE
+; many suggestions are made based on following variables
+GLOBAL  EXTFLAGS : WORD         ; some extra flags (see efXXXX constants)
+GLOBAL  CPUID0  : DWORD         ; Maker Id
+CPUID0  DD ?,?,?
+GLOBAL  CPUID1  : DWORD         ; CPU Submodel/Family/Model/Step
+GLOBAL  CPUBRAND : DWORD        ; CPU brand (Xeon, etc.)
+GLOBAL  CPUFEATURES : DWORD     ; CPU features
+
+; do not change following variables from your program.
+
+GLOBAL  FPUDENORMAL : TBYTE     ; is a constant
+GLOBAL  FPUOP1  : TBYTE         ; is a constant
+GLOBAL  FPU_53BIT_PREC : WORD   ; is a constant
+GLOBAL  SPEEDSHIFT : WORD       ; is a variable
+
+ELSE
+
+GLOBAL  cpu : BYTE
+GLOBAL  fpu : BYTE
+; many suggestions are made based on following variables
+GLOBAL  extFlags : WORD         ; some extra flags (see efXXXX constants)
+GLOBAL  cpuid0  : DWORD         ; Maker Id
+GLOBAL  cpuid1  : DWORD         ; CPU Submodel/Family/Model/Step
+GLOBAL  cpuBrand : DWORD        ; CPU brand (Xeon, etc.)
+GLOBAL  cpuFeatures : DWORD     ; CPU features
+
+; do not change following variables from your program.
+
+GLOBAL  fpuDenormal : TBYTE     ; is a constant
+GLOBAL  fpuOp1  : TBYTE         ; is a constant
+GLOBAL  fpu_53bit_prec : WORD   ; is a constant
+GLOBAL  speedShift : WORD       ; is a variable
+ENDIF
+
+ifdef TEXT_SEG
+        .CODE TEXT_SEG          ; code follows
+else
+        .CODE
+endif
diff -Nu d:7.501/tzset.c SOURCES/tzset.c
--- d:7.501/tzset.c	1970-01-01 02:00:00 +0200
+++ SOURCES/tzset.c	2007-07-03 13:37:06 +0200
@@ -0,0 +1,324 @@
+/****************************************************************************
+*
+*                            Open Watcom Project
+*
+*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
+*
+*  ========================================================================
+*
+*    This file contains Original Code and/or Modifications of Original
+*    Code as defined in and that are subject to the Sybase Open Watcom
+*    Public License version 1.0 (the 'License'). You may not use this file
+*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
+*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
+*    provided with the Original Code and Modifications, and is also
+*    available at www.sybase.com/developer/opensource.
+*
+*    The Original Code and all software distributed under the License are
+*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
+*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
+*    NON-INFRINGEMENT. Please see the License for the specific language
+*    governing rights and limitations under the License.
+*
+*  ========================================================================
+*
+* Description:  Platform independent tzset() implementation.
+*
+****************************************************************************/
+
+#include "variety.h"
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <time.h>
+#ifdef __NT__
+ #include <windows.h>
+#endif
+#include "rtdata.h"
+#include "timedata.h"
+#include "exitwmsg.h"
+#include "_time.h"
+
+/*
+ * TZSET - sets the values of the variables 'timezone', 'daylight'
+ *         and 'tzname' according to the setting of the environment
+ *         variable "TZ". The "TZ" variable has the format
+ *          :characters
+ *              or
+ *          <std><offset>[<dst>[<offset>]][,<start>[/<time>],<end>[/<time>]]]
+ */
+
+//#define TZNAME_MAX    128     /* defined in <limits.h> */
+
+struct tm       __start_dst = { /* start of daylight savings */
+    0, 0, 2,                    /* M4.1.0/02:00:00 default */
+    1, 3, 0,                    /* i.e., 1st Sunday of Apr */
+    0, 0, 0
+};
+
+struct tm       __end_dst = {   /* end of daylight savings */
+    0, 0, 1,                    /* M10.5.0/02:00:00 default */
+    5, 9, 0,                    /* i.e., last Sunday of Oct */
+    0, 0, 0                     /* note that this is specified*/
+};                              /* in terms of EST */
+/* i.e. 02:00 EDT == 01:00 EST*/
+
+static char     stzone[TZNAME_MAX + 1] = "EST";       /* place to store names */
+static char     dtzone[TZNAME_MAX + 1] = "EDT";       /* place to store names */
+
+_WCRTDATA char  *tzname[2] = { stzone, dtzone };
+
+_WCRTDATA long  timezone = 5L * 60L * 60L;      /* seconds from GMT */
+_WCRTDATA int   daylight = 1;                   /* d.s.t. indicator */
+int             __dst_adjust = 60 * 60;         /* daylight adjustment */
+
+static struct {
+    unsigned    cache_OS_TZ : 1;
+    unsigned    have_OS_TZ : 1;
+}               tzFlag = { 1, 0 };
+
+int __DontCacheOSTZ( void )
+/*************************/
+{
+    int old_flag;
+
+    old_flag           = tzFlag.cache_OS_TZ;
+    tzFlag.cache_OS_TZ = 0;
+    tzFlag.have_OS_TZ  = 0;
+    return( old_flag );
+}
+
+int __CacheOSTZ( void )
+/*********************/
+{
+    int old_flag;
+
+    old_flag           = tzFlag.cache_OS_TZ;
+    tzFlag.cache_OS_TZ = 1;
+    tzFlag.have_OS_TZ  = 0;
+    return( old_flag );
+}
+
+static char *parse_time( char *tz, int *val )
+/*******************************************/
+{
+    int value;
+
+    value = 0;
+    while( *tz >= '0' && *tz <= '9' ) {
+        value = value * 10 + *tz - '0';
+        ++tz;
+    }
+    *val = value;
+    return( tz );
+}
+
+static char *parse_offset( char *tz, char *name, long *offset )
+/*************************************************************/
+{
+    int         hours;
+    int         minutes;
+    int         seconds;
+    int         neg;
+    int         len;
+    char        ch;
+    char const  *tzstart;
+
+    if( *tz == ':' )
+        tz++;
+    /* remember where time zone name string begins */
+    tzstart = tz;
+    /* parse time zone name (should be 3 or more characters) */
+    /* examples:    PST8, EDT+6, Central Standard Time+7:00:00 */
+    for( ;; ) {
+        ch = *tz;
+        if( ch == '\0' )
+            break;
+        if( ch == ',' )
+            break;
+        if( ch == '-' )
+            break;
+        if( ch == '+' )
+            break;
+        if( ch >= '0' && ch <= '9' )
+            break;
+        ++tz;
+    }
+    len = tz - tzstart;
+    if( len > TZNAME_MAX )
+        len = TZNAME_MAX;
+    memcpy( name, tzstart, ( size_t ) len );
+    name[len] = '\0';
+
+    neg = 0;
+    if( ch == '-' ) {
+        neg = 1;
+        ++tz;
+    } else if( ch == '+' )
+        ++tz;
+    ch = *tz;
+    if( ch >= '0' && ch <= '9' ) {
+        hours = minutes = seconds = 0;
+        tz = parse_time( tz, &hours );
+        if( *tz == ':' ) {
+            tz = parse_time( tz + 1, &minutes );
+            if( *tz == ':' )
+                tz = parse_time( tz + 1, &seconds );
+        }
+        *offset = seconds + ( ( minutes + ( hours * 60 ) ) * 60L );
+        if( neg )
+            *offset = -*offset;
+    }
+    return( tz );
+}
+
+static char *parse_rule( char *tz, struct tm *timeptr )
+/*****************************************************/
+{
+    int         date_form;
+    int         days;
+    int         hours;
+    int         minutes;
+    int         seconds;
+
+    date_form = -1;                         /* n  0-365 */
+    if( *tz == 'J' ) { /* Jn 1-365 (no leap days) */
+        date_form = 1;
+        tz++;
+    }
+    if( *tz == 'M' ) { /* Mm.n.d n'th day of month */
+        date_form = 0;
+        tz++;
+    }
+    timeptr->tm_isdst = date_form;
+    tz = parse_time( tz, &days );
+    if( date_form != 0 )
+        timeptr->tm_yday = days;
+    else {
+        timeptr->tm_mon = days - 1;             /* 1-12 for M form */
+        if( *tz == '.' ) {
+            tz = parse_time( tz + 1, &days );   /* 1-5 for M form */
+            timeptr->tm_mday = days;
+            if( *tz == '.' ) {
+                tz = parse_time( tz + 1, &days );/* 0-6 for M form */
+                timeptr->tm_wday = days;
+            }
+        }
+        timeptr->tm_yday = 0;
+    }
+
+    hours = 2;
+    minutes = seconds = 0;
+    if( *tz == '/' ) {
+        tz = parse_time( tz + 1, &hours );
+        if( *tz == ':' ) {
+            tz = parse_time( tz + 1, &minutes );
+            if( *tz == ':' )
+                tz = parse_time( tz + 1, &seconds );
+        }
+    }
+    timeptr->tm_sec = seconds;
+    timeptr->tm_min = minutes;
+    timeptr->tm_hour = hours;
+    return( tz );
+}
+
+void __parse_tz( char * tz )
+/**************************/
+{
+    long        dayzone;
+
+    _RWD_daylight = 0;
+    tz = parse_offset( tz, stzone, &_RWD_timezone );
+    if( *tz == '\0' ) {
+        dtzone[0] = '\0';
+        return;
+    }
+    _RWD_daylight = 1;
+    dayzone = _RWD_timezone - ( 60*60 );              /* 16-aug-91 */
+    tz = parse_offset( tz, dtzone, &dayzone );
+    _RWD_dst_adjust = _RWD_timezone - dayzone;
+
+    /* parse daylight changing rules */
+    if( *tz == ',' )
+        tz = parse_rule( tz + 1, &__start_dst );
+    if( *tz == ',' ) {
+        tz = parse_rule( tz + 1, &__end_dst );
+        /* convert rule to be in terms of Standard Time */
+        /* rather than Daylight Time */
+        __end_dst.tm_hour -= _RWD_dst_adjust / 3600;
+        __end_dst.tm_min -= ( _RWD_dst_adjust / 60 ) % 60;
+        __end_dst.tm_sec -= _RWD_dst_adjust % 60;
+    }
+}
+
+static int tryOSTimeZone( const char *tz )
+/****************************************/
+{
+    if( tz == NULL ) {
+        /* calling OS can be expensive; many programs don't care */
+        if( tzFlag.cache_OS_TZ && tzFlag.have_OS_TZ )
+            return( 1 );
+        /* Assume that even if we end up not getting the TZ from OS,
+            we won't have any better luck if we try later. */
+        tzFlag.have_OS_TZ = 1;
+    } else {
+        tzFlag.have_OS_TZ = 0;
+#ifndef __LINUX__
+        return( 0 );
+#endif
+    }
+#if defined( __NT__ )
+    {
+        auto TIME_ZONE_INFORMATION  tz_info;
+        size_t                      rc;
+
+        _RWD_daylight = 1;                  // assume daylight savings supported
+        switch( GetTimeZoneInformation( &tz_info ) ) {
+        case TIME_ZONE_ID_UNKNOWN:          // returned by Windows NT/2000
+        case TIME_ZONE_ID_STANDARD:         // returned by Windows 95
+        case TIME_ZONE_ID_DAYLIGHT:
+            _RWD_timezone = ( tz_info.Bias + tz_info.StandardBias ) * 60L;
+            _RWD_dst_adjust = ( tz_info.DaylightBias - tz_info.StandardBias ) * -60L;
+            if( tz_info.DaylightBias == 0 )
+                _RWD_daylight = 0;  // daylight savings not supported
+
+            rc = wcstombs( stzone, tz_info.StandardName, TZNAME_MAX );
+            if( rc == ( size_t ) - 1 )  // cannot convert string
+                stzone[0] = '\0';
+            else  // ensure null-terminated
+                stzone[TZNAME_MAX] = '\0';
+
+            rc = wcstombs( dtzone, tz_info.DaylightName, TZNAME_MAX );
+            if( rc == ( size_t ) - 1 )  // cannot convert string
+                dtzone[0] = '\0';
+            else  // ensure null-terminated
+                dtzone[TZNAME_MAX] = '\0';
+            break;
+        default:
+            // assume Eastern (North America) time zone
+            _RWD_timezone = 5L * 60L * 60L;
+            _RWD_dst_adjust = 60L * 60L;
+        }
+        return( 1 );
+    }
+#elif defined( __LINUX__ )
+    return( __read_tzfile( tz ) );
+#else
+    return( 1 );
+#endif
+}
+
+_WCRTLINK void tzset( void )
+/**************************/
+{
+    #ifndef __NETWARE__
+    char        *tz;
+
+    tz = getenv( "TZ" );
+    if( !tryOSTimeZone( tz ) && tz != NULL )
+        __parse_tz( tz );
+    #endif
+}
diff -Nu d:7.501/variety.h SOURCES/variety.h
--- d:7.501/variety.h	1970-01-01 02:00:00 +0200
+++ SOURCES/variety.h	2008-11-04 21:19:02 +0200
@@ -0,0 +1,6 @@
+#define _WCRTLINK
+#define _WCRTDATA
+
+#pragma warning (disable: 4120)	// based/unbased mismatch
+#pragma warning (disable: 4135)	// conversion between different integral types
+#pragma warning (disable: 4756)	// overflow in constant arithmetic
diff -Nu d:7.501/version.h SOURCES/version.h
--- d:7.501/version.h	2006-11-12 16:00:50 +0200
+++ SOURCES/version.h	2009-02-26 11:09:20 +0200
@@ -30,5 +30,5 @@
 
 #include "build.h"
 
-#define VER_MAJOR 7
-#define VER_MINOR 50
+#define VER_MAJOR 8
+#define VER_MINOR (VER_BUILD-200)
diff -Nu d:7.501/win95.asm SOURCES/win95.asm
--- d:7.501/win95.asm	2006-11-12 16:00:50 +0200
+++ SOURCES/win95.asm	2008-12-18 14:20:14 +0200
@@ -91,11 +91,17 @@
 	 extrn _fmode:word
          extrn fWin95LFN:word
 
+ifdef __WATCOM__
+	 extrn __NFiles:word
+	 extrn __io_mode:byte
+else
 	 extrn _umaskval:word
 	 extrn _nfile:word
 	 extrn _osfile:byte
+endif
 
 	extrn _doserrno:word
+	extrn _osmajor:byte
 
 lasterr  dw    0
 
@@ -173,17 +179,18 @@
 
 chdir_good:
          xor   ax,ax
-         jmp   short chdir_bye
+         ret
 
 chdir_bad:
          mov   _doserrno, ax
          mov   ax, -1
-chdir_bye:
          ret
 
 _chdir	 endp
 
 
+if 0
+
 ;------------------------------------------------------------------------------
 ;
 ;    int _dos_getcwd( int disk, char *dirname );
@@ -209,14 +216,16 @@
 	jc	gcd_bad
 	;
 gcd_good:	xor	ax,ax
-	jmp	short gcd_bye
+	ret
 	;
 gcd_bad:	mov	_doserrno, ax
 	;
-gcd_bye:	ret
+	ret
 	;
 _dos_getcwd endp
 
+endif
+
 
 ;------------------------------------------------------------------------------
 ;
@@ -250,12 +259,11 @@
 	 mov   bx, attrib
 	 mov   [bx], cx		  ; store attribute byte from CX
 	 xor   ax, ax		  ; indicate successful call
-         jmp   short getatt_bye
+         ret
 
 getatt_bad:
          mov   _doserrno, ax
          mov   ax, -1
-getatt_bye:
          ret
 
 _dos_getfileattr endp
@@ -292,12 +300,11 @@
 
 setatt_good:
          xor   ax, ax
-         jmp   short setatt_bye
+         ret
 
 setatt_bad:
          mov   _doserrno, ax
          mov   ax, -1
-setatt_bye:
          ret
 
 _dos_setfileattr endp
@@ -335,12 +342,11 @@
 
 unl_good:
          xor   ax, ax
-         jmp   short unl_bye
+         ret
 
 unl_bad:
          mov   _doserrno, ax
          mov   ax, -1
-unl_bye:
          ret
 
 _unlink  endp
@@ -420,11 +426,10 @@
 rd_bad:
          mov   _doserrno, ax
          mov   ax, -1
-         jmp   short rd_bye
+         ret
 
 rd_good:
          xor   ax, ax
-rd_bye:
          ret
 
 _rmdir	 endp
@@ -467,8 +472,10 @@
 _sopen	 proc  uses bx si, filename:ptr byte, oflag:word, shflag:word, pmode:word
 	 local fileflag:byte, junk:byte
 	 xor   bx, bx
-	 mov   bl, byp shflag	  ; pickup sharing arg
-	 mov   ax, pmode	  ; copy optional permission setting
+	 cmp   _osmajor, 3	  ; DOS version 3 or later?
+	 jb    @F		  ; no, leave sharing = 0
+	 mov   bl, byp shflag	  ; yes, pickup sharing arg
+@@:	 mov   ax, pmode	  ; copy optional permission setting
 	 mov   shflag, ax	  ;   down to where _open can find it
 	 jmp   open_1		  ; join common code with _open
 _sopen	 endp
@@ -667,11 +674,21 @@
 ;	 01    file is open
 
 setflag_1:
+ifdef __WATCOM__
+	; @TODO!!
+	 cmp   bx, __NFiles	  ; is file handle within range of table?
+	 jae   toomany		  ; if not, error
+	 mov   cl, fileflag	  ; compose flag byte
+	 or    cl, 1		  ; set _READ flag
+	 mov   __io_mode[bx], cl  ; store flags
+	 
+else
 	 cmp   bx, _nfile	  ; is file handle within range of table?
 	 jae   toomany		  ; if not, error
 	 mov   cl, fileflag	  ; compose flag byte
 	 or    cl, 1		  ; indicate file is open
 	 mov   _osfile[bx], cl	  ; store flags
+endif
 
 	 mov   ax, bx		  ; set file handle for normal return
 	 ret			  ; return to external caller
@@ -686,7 +703,11 @@
 
 
 _cXENIXtoDOSmode proc
+ifdef __WATCOM__
+         mov   ax, 0		  ; _umaskval defaults to zero anyway
+else
 	 mov   ax, _umaskval	  ; get mask from _umask
+endif
 	 not   ax		  ; invert because of negative sense of mask
 	 and   ax, cx		  ; AX = bits we won't keep
 	 xor   cx, cx		  ; clear those bits in CX
@@ -797,8 +818,10 @@
 ;
 ;------------------------------------------------------------------------------
 
-Win95GetTitle proc far pascal uses ds si di, pszTitle:word
+Win95GetTitle proc far pascal uses es di cx, pszTitle:word
 
+         push	ds
+         pop	es
          mov	ax, 168Eh
          mov	di, pszTitle
          mov	cx, 255
@@ -815,8 +838,10 @@
 ;
 ;------------------------------------------------------------------------------
 
-Win95SetTitle proc far pascal uses ds di, pszTitle:word
+Win95SetTitle proc far pascal uses es di, pszTitle:word
 
+         push	ds
+         pop	es
          mov	ax, 168Eh
          mov	di, pszTitle
          mov	dx, 0
@@ -847,9 +872,12 @@
 	mov	dx, pszDrive	;point to drive name
 	mov	ax, 7303h		;extended get free space function
 	int	21h
-	mov	ax, 0		;assume OK
-	 jnc	Fat32Done		;continue if OK
-	inc	ax		;return non-zero (error)
+	 jc	Fat32Done	;return error code on error
+	mov	ax, [di]
+	sub	ax, cx		;return 0 if the structure was filled correctly
+	cmp	ax, -8		;36? (by EDR-DOS, not 44 like everybody else!)
+	 jne	Fat32Done	;no, return OK if it was 44, error otherwise
+	xor	ax, ax		;yes, no error
 Fat32Done:
 	ret
 Win95GetFAT32Info endp
diff -Nu d:7.501/window.c SOURCES/window.c
--- d:7.501/window.c	2006-11-12 16:00:50 +0200
+++ SOURCES/window.c	2007-09-18 00:01:58 +0200
@@ -105,13 +105,13 @@
 	// draw the window border (with a shadow) and clear the text area
 	_box( pwWindow->nTop, nLeft, nBottom, nRight, 1, pwWindow->nAttrib, pwWindow->nAttrib, pwWindow->fShadow, 0 );
 
-	if ( strlen( pszTitle ) >= ( nRight - ( nLeft + 1 )))
+	if ( strlen( pszTitle ) >= (unsigned int)( nRight - ( nLeft + 1 )))
 		pszTitle[ nRight - ( nLeft + 1 ) ] = _TEXT('\0');
 
 	WriteStrAtt( pwWindow->nTop, nLeft + (( ++nRight - ( nLeft + strlen( pszTitle ))) / 2 ), pwWindow->nAttrib, pszTitle );
 
 	if ( pszBottomTitle != NULL ) {
-		if ( strlen( pszBottomTitle ) >= ( nRight - ( nLeft + 1 )))
+		if ( strlen( pszBottomTitle ) >= (unsigned int)( nRight - ( nLeft + 1 )))
 			pszBottomTitle[ nRight - ( nLeft + 1 ) ] = _TEXT('\0');
 		WriteStrAtt( pwWindow->nBottom, nLeft + (( ++nRight - ( nLeft + strlen( pszBottomTitle ))) / 2 ), pwWindow->nAttrib, pszBottomTitle );
 	}
@@ -510,6 +510,7 @@
 			goto redraw;
 
 		case CUR_UP:
+		case WHEEL_UP:
 CursorUp:
 			if ( pwWin->fPopupFlags & NO_CHANGE ) {
 
@@ -528,6 +529,7 @@
 			break;
 
 		case CUR_DOWN:
+		case WHEEL_DOWN:
 CursorDown:
 			if ( pwWin->fPopupFlags & NO_CHANGE ) {
 
diff -Nu d:7.501/wrapper.c SOURCES/wrapper.c
--- d:7.501/wrapper.c	1970-01-01 02:00:00 +0200
+++ SOURCES/wrapper.c	2007-09-26 20:34:34 +0200
@@ -0,0 +1,94 @@
+/* This is a terrible, awful, ugly hack. The 4DOS library replacement
+ * routines written in assembly all use the __cdecl calling convention.
+ * Of course, code built with Watcom C uses register calling convention
+ * instead. To work around the problem without rewriting assembly code,
+ * we just create a few thunks. Not nice, not fast, but works.
+ */
+ 
+#include <stdlib.h>
+#include <stdarg.h>
+
+_WCRTLINK extern int real_write( int, const void *, int );
+#pragma aux real_write "write_";
+
+int __cdecl _write( int handle, const void *buf, int len )
+{
+    return( real_write( handle, buf, len ) );
+}
+
+
+extern int __cdecl lfn_rename( const char *, const char * );
+#pragma aux lfn_rename "_rename";
+
+_WCRTLINK int rename( const char *oldname, const char *newname )
+{
+    return( lfn_rename( oldname, newname ) );
+}
+
+
+extern int __cdecl lfn_mkdir( const char * );
+#pragma aux lfn_mkdir "__mkdir";
+
+_WCRTLINK int mkdir( const char *path )
+{
+    return( lfn_mkdir( path ) );
+}
+
+
+extern int __cdecl lfn_rmdir( const char * );
+#pragma aux lfn_rmdir "__rmdir";
+
+_WCRTLINK int rmdir( const char *path )
+{
+    return( lfn_rmdir( path ) );
+}
+
+
+extern int __cdecl lfn_chdir( const char * );
+#pragma aux lfn_chdir "__chdir";
+
+_WCRTLINK int chdir( const char *path )
+{
+    return( lfn_chdir( path ) );
+}
+
+
+extern int __cdecl lfn_remove( const char * );
+#pragma aux lfn_remove "_remove";
+
+_WCRTLINK int remove( const char *path )
+{
+    return( lfn_remove( path ) );
+}
+
+
+extern unsigned __cdecl lfn_dgfa( const char *, unsigned * );
+#pragma aux lfn_dgfa "__dos_getfileattr";
+
+_WCRTLINK unsigned _dos_getfileattr( const char *path, unsigned *attr )
+{
+    return( lfn_dgfa( path, attr ) );
+}
+
+
+extern unsigned __cdecl lfn_sgfa( const char *, unsigned );
+#pragma aux lfn_sgfa "__dos_setfileattr";
+
+_WCRTLINK unsigned _dos_setfileattr( const char *path, unsigned attr )
+{
+    return( lfn_sgfa( path, attr ) );
+}
+
+#if 0
+/* The open() and sopen() functions take a variable number of arguments.
+ * As a consequence, the Watcom library routines already use a stack calling
+ * convention very much like __cdecl. Just generate linker aliases for those.
+ *
+ * Unfortunately, the open flags are *different*, so this doesn't work!
+ * It may be possible to use _open_osfhandle() to solve this.
+ */
+ 
+#pragma alias( "_sopen_", "__sopen" )
+#pragma alias( "_open_", "__open" )
+#pragma alias( "open_", "__open" )
+#endif
diff -Nu d:7.501/xinit.inc SOURCES/xinit.inc
--- d:7.501/xinit.inc	1970-01-01 02:00:00 +0200
+++ SOURCES/xinit.inc	2007-01-30 18:01:20 +0200
@@ -0,0 +1,116 @@
+;*****************************************************************************
+;*
+;*                            Open Watcom Project
+;*
+;*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
+;*
+;*  ========================================================================
+;*
+;*    This file contains Original Code and/or Modifications of Original
+;*    Code as defined in and that are subject to the Sybase Open Watcom
+;*    Public License version 1.0 (the 'License'). You may not use this file
+;*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
+;*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
+;*    provided with the Original Code and Modifications, and is also
+;*    available at www.sybase.com/developer/opensource.
+;*
+;*    The Original Code and all software distributed under the License are
+;*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+;*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
+;*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
+;*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
+;*    NON-INFRINGEMENT. Please see the License for the specific language
+;*    governing rights and limitations under the License.
+;*
+;*  ========================================================================
+;*
+;* Description:  WHEN YOU FIGURE OUT WHAT THIS FILE DOES, PLEASE
+;*               DESCRIBE IT HERE!
+;*
+;*****************************************************************************
+
+
+include langenv.inc
+
+PNEAR   equ     0
+PFAR    equ     1
+
+xinit   macro   rtn,priority
+XI  segment word public 'DATA'
+if _MODEL and _BIG_CODE
+        db      PFAR
+        db      priority
+        dd      rtn
+else
+if _MODEL and _USE_32_SEGS
+        db      PNEAR
+        db      priority
+        dd      rtn
+if COMP_CFG_COFF EQ 1
+        dw      0
+endif
+else
+        db      PNEAR
+        db      priority
+        dw      rtn
+        dw      0
+endif
+endif
+XI      ends
+        endm
+
+xfini   macro   rtn,priority
+YI      segment word public 'DATA'
+if _MODEL and _BIG_CODE
+        db      PFAR
+        db      priority
+        dd      rtn
+else
+if _MODEL and _USE_32_SEGS
+        db      PNEAR
+        db      priority
+        dd      rtn
+if COMP_CFG_COFF EQ 1
+        dw      0
+endif
+else
+        db      PNEAR
+        db      priority
+        dw      rtn
+        dw      0
+endif
+endif
+YI      ends
+        endm
+
+;
+;    ..._PRIORITY_... constant must correspond with definition in rtinit.h file
+;
+INIT_PRIORITY_THREAD   equ 1    ; priority for thread data init
+INIT_PRIORITY_FPU      equ 2    ; priority for FPU/EMU init
+INIT_PRIORITY_RUNTIME  equ 10   ; priority for run-time initialization
+INIT_PRIORITY_EXIT     equ 16   ;
+INIT_PRIORITY_IOSTREAM equ 20   ; priority for IOSTREAM
+INIT_PRIORITY_LIBRARY  equ 32   ; default library-initialization priority
+DEF_PRIORITY           equ 32   ; ...
+INIT_PRIORITY_PROGRAM  equ 64   ; default program-initialization priority
+DTOR_PRIORITY          equ 40   ; priority for module DTOR
+FINI_PRIORITY_EXIT     equ 16   ; when exit() is called, functions between
+                                ; 255 and this are called, the rest of the
+                                ; fini routines are called from __exit().
+
+DGROUP  group   XIB,XI,XIE,YIB,YI,YIE
+
+XIB segment word public 'DATA'
+XIB ends
+XI  segment word public 'DATA'
+XI  ends
+XIE segment word public 'DATA'
+XIE ends
+
+YIB segment word public 'DATA'
+YIB ends
+YI  segment word public 'DATA'
+YI  ends
+YIE segment word public 'DATA'
+YIE ends
