  JMP Main ;Skip over TSR Code to Main Program


;==============================================================================
;NOTE: This program is written for and compiled with Eric Isaacson's A86
;      assembly language compiler, using Options +P0 -F (8086/8088 CPU and
;      no FPU).
;==============================================================================


;In DOCs:

;Can be installed without USBUHCI in memory
;Any program can modify Redirect Table itself -- does not necessarily need to
;  use INT 17h extended function (except to get the Table Address)
;A program cannot simply obtain the Table Address when it installs and assume
;  it will continue to be in the same place forever.  If it wants to
;  view/modify the table directly, it must obtain the address immediately
;  before it does anything to the table.
;Need to distribute with BOUNDTST and INKLEVEL
;User needs to check Printer Status before starting TxBlock/RxBlock/DvcID
;  just like before starting byte-at-a-time job!
;No way to "Disable" entire program, only individual devices.
;  Must Uninstall and then Reinstall/Reinitialize.
;Printers with Memory Readers: different Interface should be controlled by
;  USBDrive or similar.  Many are simply interfaces to the Printer, and
;  never make it back to the computer.
;TxBlock/RxBlock/GetDeviceID calls use DH as Timeout value.  Return Codes??
;Two "classes" of printers.  Old dot-matrix/daisy-wheel/similar-ilk printers
;  with little or no memory (memory was VERY expensive back then), but
;  start printing right away and don't stop.  Newer InkJet/LaserJet printers
;  which have comparitively a lot of memory (but not infinite), but
;  can thrash around for tens of seconds before they actually start
;  printing anything (and sometimes thrash around between pages as well).
;  Each have different kinds of timing and buffer issues to work through.
;Printers has lots of timing and buffer issues in general.  They are generally
;  handled with queues and other things which have their own sets of problems.
;  Printers also aren't all that reliable (paper jams, ink levels, paper
;  problems in general, on/off-line, protocols, etc.).  Even the latest
;  programs (Windows) don't resolve these completely and satisfactorily
;  (at least not to my complete satisfaction).  Tried to cancel jobs that
;  failed in the middle for some reason, and Windows tries to print the
;  job again next time I reboot.  Despicable.
;Some printers (mostly older) turn off right away with the power switch.  If
;  using USB-Parallel Cable with them, they don't actually become disconnected
;  in the USB sense but simply return NoPrinterInstalled status.  Similar
;  with some printers (HP) which respond to USB commands if they are plugged
;  in to power even if they are turned off (which also means they are using
;  at least a little bit of power when they are turned off).  Most all
;  modern printers don't turn off right away when you hit the power switch,
;  but spend several seconds thrashing around and apparently "cleaning"
;  things up.  Some printers may also keep printing what's in their internal
;  buffers even after a parallel cable is unplugged.  The only way to make
;  sure a printer is stopped is to unplug power (not just use the power
;  switch).  For USB printers, unplugging either end of the USB Cable will
;  cause the computer to recognize the printer as no longer there, though
;  the printer may still keep printing what's in its memory.  Lots of
;  problems trying to stop a printer gone awry, which they do quite often,
;  and what you need to do is sometimes different for each printer.  Plus,
;  Windows (and maybe other Print Spoolers also) will try to start the
;  Jobs again after you reboot!  Need to figure out how your printers work
;  and what to do when things go wrong (which they will).  Power Cables and
;  USB Cables aren't always in the most accessible locations, either (usually
;  in the back of the printer and computer where you can't see them).
;  Try to avoid wasting paper and ink, but it's not always possible.
;PRINT only prints at a DOS Prompt (INT 28h??)  Also traps INT 1Ch (indirect
;  and unreliable monoitoring of INT 08).
;I17ErrTimeout also "includes" an I17ErrIncompleteXfer.  I17ErrIncompleteXfer
;  means the packet was short, but we have no idea why.  I17ErrTimeout means
;  the packet was short because it timed out.
;For GetDeviceID calls, the calling program generally has no idea how long
;  the Device ID string might be before it is downloaded, so will typically
;  have a buffer much larger than what is actually needed.  Therefore,
;  short packet errors during transfers are not considered errors.  RXBlock
;  calls do not do this - just GetDeviceID's.
;Block Timeouts do not apply on parallel ports during RxBlock/GetDeviceID
;  calls if Device is disconnected or not IEEE 1284.4 compatible.
;  We just try for several milliseconds to wait for the Device to respond
;  appropriately and then give up (it's pointless to wait any longer).
;  We keep waiting if it's 1284.4 compatible.
;Attempt to handle multitasking correctly, but cannot be sure.
;  OS/Multitask Manager must resolve conflicts with multiple programs
;  trying to send/receive/monitor the same port at the same time -- we
;  can't do it internally.
;Seems to work pretty good for me.  But, because there are so many
;  different kinds of printers and timing issues are critical in
;  printers, you may run into a situation where it doesn't work for you.
;  May have overlooked/not seen/no accounted for some issue (probably
;  timing related) that will need to be addressed.  Hope it works
;  OK for you too.  May need to work around quirks you find.
;Added DOS LPT1 - LPT9 as viable LPT ports.  Can also do two-way communication
;  and Get Device ID, which is a huge enhancement.
;If program can print to File, just use LPT4 - LPT9 as the file name.
;  Program won't know if it's going to a file or not.  Devices (like LPTx)
;  are treated much like files in DOS, and programs usually can't tell
;  the difference (there are ways for a program to tell, but they usually
;  don't care or bother looking).
;We accept Generic IOCTL calls to change Retry count, but don't actually do
;  anything with them.
;ALL DOS-level and BIOS-level calls are redirected using LPT table,
;  so sending something like Get/Set Retry in Generic IOCTL call goes to
;  redirected port, not necessarily the one you think it is going to.
;In spite of what official Docs say, IOCtlCheck function does not always
;  return AX = 0 if function is supported.  Does always return CF clear,
;  however.
;The only reason we use buffers is because of efficiency.  Would like
;  to simulate a real parallel port (can only handle one byte at a time),
;  but USB is horribly inefficient if we send packets with only one byte
;  of data.  USB would be much slower than parallel if we did that.
;For internal copies, we stop as soon as user cancels (Esc, Ctrl-C, Ctrl-Break),
;  or there is an error (Printer Timeout or Disk/File Error).  We stop the
;  current COPY command (even if there are more files pending in a wildcard
;  filespec) as well as any additional COPY's, even if they are for different
;  printers or disks that may not have problems.
;The process of printing is unlike many other things on a computer --
;  it is hard to control.  There are lots of timing and buffer and protocol
;  issues that there is no easy way to resolve (even Windows screws things
;  up sometimes, not actually doing what you WANT it to do).
;From my experience, Epson printers have lots of problems.  If not an ink
;  problem (not printing, clogged, cleaning uses a LOT of ink), the one I had
;  stopped revealing Ink Levels after a while, even in Windows.  Don't like
;  them.  Never tried Canon (the other big-name supplier).  Have had a few
;  minor problems with HP, but nothing remotely close to the problems I've
;  had with Epson.  I will personally never buy another Epson.  Like Brother
;  so far -- emulates HP & does PostScript.
;Start/Stop Job do exactly same thing -- just wait a few seconds (up to 10)
;  for internal buffers to clear.  Does not even guarantee that the internal
;  buffers are empty (they could take more than 10 seconds to clear), and
;  does not say anything about the printer buffer.
;Cancel Job clears internal buffers, cancels any pending USB transactions
;  to send buffer data to the printer, and issues immediate soft reset.
;  The soft reset should clear out the printer buffers.
;Should be able to print to multiple printers at same time, though I
;  haven't actually tried.
;Problems with programs that print in the background (WordPerfect).  Not sure
;  why, may try to fix someday. For now, workaround is to print to file and
;  copy to printer. Could set up batch file to automate printing when WP
;  exits:
;    WP
;    IF EXIST %Temp%\*.Prn USBPrint Copy %Temp%\*.Prn LPT1:
;    IF EXIST %Temp%\*.Prn DEL %Temp%\*.Prn



COMMENT 

  At least some printers (and possibly printer cables) will have just one
  Alternate Interface, which may either be listed as Unidirectional
  or Bidirectional.  Other printers (and especially printer cables) will
  have both a Unidirectional and a Bidirectional Alternate Interface.  Some
  Printer Cables also have a third, vendor-specific Alternate Interface that
  adds a Periodic Interrupt EndPoint to the mix.

  The only standard protocol for handling a bi-directional parallel port
  without direct hardware control is the EPP BIOS, which includes a bunch of
  "extra", unnecessary functions (like multiplexing) that we don't need.
  In addition, the EPP BIOS functions are really designed around
  parallel ports, and trying to apply them to anything other
  than Parallel ports ends up not making much sense.  So, we will write
  our own protocol.

  The only 3 functions that seem to be needed, at least at this point in time,
  are Send Block of Data (instead of just sending a single character at a
  time), Receive Block of Data (receiving a single character is just
  receiving a block of data with a size of 1, so it doesn't make sense
  to have a special function for that), and Get Device ID.

  For parallel ports, the Receive mode is limited to Nibble Mode, rather
  than EPP/ECP receive mode, for simplicity reasons, even though Nibble mode
  is slower than EPP/ECP.  There is no special hardware required to support
  Nibble Mode, but ECP & ECP do require special hardware.

END COMMENT ;


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;EQUATE/STRUCTURE/MACRO DEFINITIONS
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;EQUATES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;==============================================================================
;TSR Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Size of our TSR Stack
  ;----------------------------------------------------------------------------
  StackSize EQU 256

  ;----------------------------------------------------------------------------
  ;Special Interrupt 2Fh (TSR Multiplex) Function Numbers we monitor/use
  ;----------------------------------------------------------------------------
  MuxInstallChk  EQU 0 ;Handle # Install Check
  MuxGetProgName EQU 1 ;Get Program Name
  MuxGetProgVer  EQU 2 ;Get Program Version
  MuxGetAuthor   EQU 3 ;Get Program Author


;==============================================================================
;Miscellaneous
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special Codes
  ;----------------------------------------------------------------------------
  No  EQU  0 ;Miscellaneous Yes/No tests
  Yes EQU -1 ;      "        "  "    "


;==============================================================================
;CPU Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Bit masks in the CPU Flags Register
  ;----------------------------------------------------------------------------
  CarryFlag  EQU 0001h ;Carry Flag
  ParityFlag EQU 0004h ;Parity Flag
  AuxFlag    EQU 0010h ;Auxiliary Flag
  ZeroFlag   EQU 0040h ;Zero Flag
  SignFlag   EQU 0080h ;Sign Flag
  TrapFlag   EQU 0100h ;Trap Flag
  IntFlag    EQU 0200h ;Interrupt Flag
  DirFlag    EQU 0400h ;Direction Flag
  OFFlag     EQU 0800h ;Overflow Flag


;==============================================================================
;BOUND Fix Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special CPU OpCodes needed to check for and fix BOUND Bug
  ;----------------------------------------------------------------------------
  OpCodeBOUND  EQU 62h ;BOUND OpCode (to fix the BOUND CPU Bug)

  OpCodeOper32 EQU 66h ;32-bit Operand Override Prefix
  OpCodeAddr32 EQU 67h ;32-bit Address Override Prefix

  OpCodeCS     EQU 2Eh ;CS: Segment Override Prefix
  OpCodeDS     EQU 3Eh ;DS: Segment Override Prefix
  OpCodeES     EQU 26h ;ES: Segment Override Prefix
  OpCodeSS     EQU 36h ;SS: Segment Override Prefix
  OpCodeFS     EQU 64h ;FS: Segment Override Prefix
  OpCodeGS     EQU 65h ;GS: Segment Override Prefix


;==============================================================================
;CONsole/Screen Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special ASCII Characters
  ;----------------------------------------------------------------------------
  SOH       EQU  1 ;Start-of-Header (Hollow Happy Face)
  STX       EQU  2 ;Start-of-Text (Filled Happy Face)
  BackSpace EQU  8 ;Backspace
  Tab       EQU  9 ;Tab
  LF        EQU 10 ;Line Feed
  FormFeed  EQU 12 ;FormFeed
  CR        EQU 13 ;Carriage Return
  EOF       EQU 26 ;End-of-File
  Quote2    EQU 34 ;Double quote
  Quote1    EQU 39 ;Single quote
  BackSlash EQU 92 ;BackSlash (\)

  ;----------------------------------------------------------------------------
  ;Special Keys that can be pressed during Pause routine
  ;----------------------------------------------------------------------------
  CtrlC  EQU  3 ;Control-C Keystroke
  Escape EQU 27 ;Escape Keystroke


;==============================================================================
;Keyboard BIOS Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Keyboard Data Stored at 0040:0017h
  ;----------------------------------------------------------------------------
  BIOS17RShiftP    EQU 01h ;Right Shift Pressed
  BIOS17LShiftP    EQU 02h ;Left Shift Pressed
  BIOS17EitherCtlP EQU 04h ;Either Control Pressed
  BIOS17EitherAltP EQU 08h ;Either Alt Pressed
  BIOS17ScrLockA   EQU 10h ;Scroll Lock Active
  BIOS17NumLockA   EQU 20h ;Num Lock Active
  BIOS17CapLockA   EQU 40h ;Caps Lock Active
  BIOS17InsertA    EQU 80h ;Insert Active

  BIOS17ShiftKeysMask EQU BIOS17RShiftP+BIOS17LShiftP+BIOS17EitherCtlP+BIOS17EitherAltP

  ;----------------------------------------------------------------------------
  ;Keyboard Data Stored at 0040:0018h
  ;----------------------------------------------------------------------------
  BIOS18LeftCtlP EQU 01h ;Left Control Pressed
  BIOS18LeftAltP EQU 02h ;Left Alt Pressed
  BIOS18SysReqP  EQU 04h ;Sys Req Pressed
  BIOS18PauseA   EQU 08h ;Pause State Active
  BIOS18ScrLockP EQU 10h ;Scroll Lock Pressed
  BIOS18NumLockP EQU 20h ;Num Lock Pressed
  BIOS18CapLockP EQU 40h ;Caps Lock Pressed
  BIOS18InsertP  EQU 80h ;Insert Pressed

  ;----------------------------------------------------------------------------
  ;Keyboard Data Stored at 0040:0096h
  ;----------------------------------------------------------------------------
  BIOS96E1LastTime   EQU 01h ;Last Code Read was E1h (225 - Pause)
  BIOS96E0LastTime   EQU 02h ;Last Code Read was E0h (224 - Extended Keys)
  BIOS96RightCtlP    EQU 04h ;Right Control Pressed
  BIOS96RightAltP    EQU 08h ;Right Alt Pressed
  BIOS96EnhancedKB   EQU 10h ;Enhanced Keyboard Installed
  BIOS96ForceNumLk   EQU 20h ;Force NumLock if Read-ID and Enhanced Keyboard
  BIOS961of2LastTime EQU 40h ;Last Code Read was first of two ID Codes (Pause)
  BIOS96ReadIDInProg EQU 80h ;Read-ID in progress

  ;----------------------------------------------------------------------------
  ;Keyboard Data Stored at 0040:0097h
  ;----------------------------------------------------------------------------
  BIOS97ScrLockLED EQU 01h ;Scroll Lock LED
  BIOS97NumLockLED EQU 02h ;Num Lock LED
  BIOS97CapLockLED EQU 04h ;Caps Lock LED
  BIOS97Reserved0  EQU 08h ;Reserved (0)
  BIOS97AckRcvd    EQU 10h ;ACK Received from Keyboard
  BIOS97ResendRcvd EQU 20h ;RESEND Received from Keyboard
  BIOS97LEDUpdate  EQU 40h ;LED Update in Progress
  BIOS97TxError    EQU 80h ;Keyboard Transmit Error Flag


;==============================================================================
;DOS Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;;Minimum DOS Version required to use this program
  ;----------------------------------------------------------------------------
  MinDOSVer EQU 0300h

  ;----------------------------------------------------------------------------
  ;DOS Memory Allocation Strategies
  ;----------------------------------------------------------------------------
  StrategyLowFirst     EQU 00h ;First Fit, Low Memory Only
  StrategyLowBest      EQU 01h ;Best Fit, Low Memory Only
  StrategyLowLast      EQU 02h ;Last Fit, Low Memory Only
  ;For DOS 3&4, anything >2 is Last Fit Low Memory
  ;Below are for DOS 5+ Only
  StrategyHighFirst    EQU 40h ;First Fit, High Memory Only
  StrategyHighBest     EQU 41h ;Best Fit, High Memory Only
  StrategyHighLast     EQU 42h ;Last Fit, High Memory Only
  StrategyHighLowFirst EQU 80h ;First Fit, Try High Memory then Low Memory
  StrategyHighLowBest  EQU 81h ;Best Fit, Try High Memory then Low Memory
  StrategyHighLowLast  EQU 82h ;Last Fit, Try High Memory then Low Memory

  ;----------------------------------------------------------------------------
  ;UMB Link States
  ;----------------------------------------------------------------------------
  UMBLinkNo  EQU 00h ;UMB's are not part of DOS Memory Chain
  UMBLinkYes EQU 01h ;UMB's are in DOS Memory Chain (DOS=HIGH,UMB in CONFIG.SYS)

  ;----------------------------------------------------------------------------
  ;Sizes of various DOS data structures
  ;----------------------------------------------------------------------------
  FCBSize     EQU  44 ;Size of DOS File Control Block
  CmdTailMax  EQU 128 ;Maximum size of a DOS Command Tail
  MaxPathSize EQU  64 ;Maximum Size of a DOS Path/FileName String

  ;----------------------------------------------------------------------------
  ;Special "hard-coded" DOS Device Handles.
  ;These Handles are permanently hard-coded in DOS, and are always open.
  ;There is no need to issue Find, Open, or Close calls to these
  ;  devices - you can just use them at will.
  ;----------------------------------------------------------------------------
  StdInHandle  EQU 0 ;Standard Input Device Handle
  StdOutHandle EQU 1 ;Standard Output Device Handle
  StdErrHandle EQU 2 ;Standard Error Device Handle
  StdAuxHandle EQU 3 ;Standard Auxiliary Device Handle (COM1 by default)
  StdPrnHandle EQU 4 ;Standard Printer Device Handle (LPT1 by default)

  ;----------------------------------------------------------------------------
  ;Values to return in AL from Critical Error Handler (INT 24h)
  ;----------------------------------------------------------------------------
  CritErrIgnore    EQU 00h ;Ignore Error and Continue Operation
  CritErrRetry     EQU 01h ;Retry Operation
  CritErrTerminate EQU 02h ;Terminate program
  CritErrFail      EQU 03h ;Fail System Call

  ;----------------------------------------------------------------------------
  ;Codes returned by INT 21h, Function 4400h (Get Device Information)
  ;----------------------------------------------------------------------------
  ;If bit 7 is Set (is a Device):
  DvcInfoIsStdIn    EQU 0001h ;STDIN
  DvcInfoIsStdOut   EQU 0002h ;STDOUT
  DvcInfoIsNUL      EQU 0004h ;NUL
  DvcInfoIsClock    EQU 0008h ;CLOCK$
  DvcInfoInt29h     EQU 0010h ;Uses Int 29h (Special Device)
  DvcInfoBinary     EQU 0020h ;Binary (Raw) Mode
  DvcInfoEOF        EQU 0040h ;EOF on Input
  DvcInfoIsDevice   EQU 0080h ;Is a Device (not a File)
  DvcInfoKEYB       EQU 0100h ;Unknown (set by DOS 6.2x KEYB program)
  DvcInfoOpenClose  EQU 0800h ;Supports Open/Close calls
  DvcInfoOutputBusy EQU 2000h ;Supports Output until Busy
  DvcInfoIOCTL      EQU 4000h ;Can process IOCTL requests (INT 21h, Func 4402h)

  ;If bit 7 is Clear (is a File):
  DvcInfoDriveMask    EQU 003Fh ;Drive number (0 = A:)
  DvcInfoNotWritten   EQU 0040h ;File has not been written (Dirty Buffer?)
  ;Bit 7 = Clear!
  DvcInfoInt24h       EQU 0100h ;Generate Int 24h on Errors (DOS 4 only)
  DvcInfoNotRemovable EQU 0800h ;Media Not Removable
  DvcInfoNoDateTime   EQU 4000h ;Don't set File Date/Time on Closing (DOS 3.0+)
  DvcInfoRemote       EQU 8000h ;File is Remote (DOS 3.0+)


;==============================================================================
;Standard Printer Functions Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Standard INT 17h Functions (in AH)
  ;----------------------------------------------------------------------------
  I17FSendByte   EQU 00h ;Send a Byte
  I17FInitialize EQU 01h ;Initialize (Reset) Printer
  I17FGetStatus  EQU 02h ;Get Status


;==============================================================================
;Extended Printer Function Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Extended INT 17h API Version Number
  ;NOTE: The version can NEVER be "LP" (4C50h)!
  ;----------------------------------------------------------------------------
  Int17APIVersion EQU 0001h ;API Version 0.01h

  ;----------------------------------------------------------------------------
  ;Extended INT 17h Error Codes (Returned in AX)
  ;----------------------------------------------------------------------------
  I17ErrOK             EQU 0000h ;No Error
  I17ErrBadFunction    EQU 0001h ;Bad Function Number (AL)
  I17ErrFunctionNoSupt EQU 0002h ;Function not supported on this LPT Index
  I17ErrBadIndex       EQU 0003h ;Bad Printer Index
  I17ErrBadRedirIndex  EQU 0004h ;Bad Redirection Index
  I17ErrBadSize        EQU 0005h ;Bad Block Size
  I17ErrBlockTimeout   EQU 0008h ;Block Transfer Timeout
  I17ErrIncompleteXfer EQU 0009h ;Incomplete Block Transfer

  ;----------------------------------------------------------------------------
  ;Extended INT 17h Functions (in AL, 1Bh in AH)
  ;----------------------------------------------------------------------------
  I17FInstallCheck    EQU 00h ;Installation Check
  I17FJobStart        EQU 01h ;Start a New Print Job
  I17FJobEnd          EQU 02h ;End an Existing New Print Job
  I17FJobCancel       EQU 03h ;Cancel an Existing New Print Job
  I17FRedirGoingAway  EQU 0Fh ;Program containing Redirect Table is disappearing
  I17FGetRedirTblAddr EQU 10h ;Get Address of LPT Redirection Table
  I17FGetPortRedir    EQU 11h ;Get Port Redirect Status
  I17FSetPortRedir    EQU 12h ;Set Port Redirect Status
  I17FGetDvcIDString  EQU 20h ;Get Device ID String
  I17FTxBlock         EQU 21h ;Transmit (Send) Block of Data
  I17FRxBlock         EQU 22h ;Receive Block of Data


;==============================================================================
;Parallel/Printer/EPP/ECP Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;USB Printer-specific Control Request Types
  ;----------------------------------------------------------------------------
  SRRQGetDeviceID   EQU 0 ;Get Device ID (returns IEEE 1284.4 compatible string)
  SRRQGetPortStatus EQU 1 ;Get Port Status (rtns PaperEmpty, Select, NotError)
  SRRQSoftReset     EQU 2 ;Soft Reset (Flush buffers, Reset Pipes, Clear Stalls)

  ;----------------------------------------------------------------------------
  ;IEEE 1284 Extensibility Byte Values
  ;----------------------------------------------------------------------------
  IE1284Nibble      EQU 00h ;Nibble Mode
  IE1284Byte        EQU 01h ;Byte Mode
  IE1284DvcIDNibble EQU 04h ;Get Device ID in Nibble Mode
  IE1284DvcIDByte   EQU 05h ;Get Device ID in Byte Mode
  IE1284DvcIDECP    EQU 14h ;Get Device ID in ECP Mode without RLE
  IE1284DvcIDECPRLE EQU 34h ;Get Device ID in ECP Mode with RLE
  IE1284ECP         EQU 10h ;ECP Mode without RLE
  IE1284ECPRLE      EQU 30h ;ECP Mode with RLE
  IE1284EPP         EQU 40h ;EPP Mode
  IE1284Extend      EQU 80h ;Extensibility Link

  ;----------------------------------------------------------------------------
  ;Lowest I/O Address we will use
  ;----------------------------------------------------------------------------
  MinIOAddress EQU 0400h

  ;----------------------------------------------------------------------------
  ;Size/Quantity of buffers to temporarily queue data
  ;----------------------------------------------------------------------------
  BufferSize EQU 192 ;Size of Data Buffers
  NumBuffers EQU   9 ;Number of Data Buffers

  ;----------------------------------------------------------------------------
  ;Status byte returned by Printer
  ;USB Status Call returns only bits 3, 4, and 5 (Error, Selected, & NoPaper).
  ;  It does not return Timeout, Acknowledge, or NotBusy.
  ;In addition, USB returns bit 3 as Not Error rather than Error, which is
  ;  backwards from a regular parallel port.
  ;----------------------------------------------------------------------------
  PStsTimeout     EQU 01h ;Only returned for INT 17h Function 0 (Print Char)
                          ;Calculated by INT 17h Code (software) -
                          ;  does NOT come from the I/O Port
  PStsIOError     EQU 08h ;USB Returns Not Error (backwards from PC BIOS)
  PStsSelected    EQU 10h ;Selected (On-Line)
  PStsNoPaper     EQU 20h ;Out-of-Paper
  PStsACKnowledge EQU 40h ;Hardware ACKnowledge (normally ignored)
  PStsNotBusy     EQU 80h ;Not Busy (Ready)

  ;"Combination" statuses that we need to commonly work with
  ;PStsNoBuffer    EQU PStsSelected+PStsIOError+PStsTimeout
  PStsNoBuffer    EQU PStsSelected+PStsTimeout
                      ;Out of Buffer Space (Busy)
  PStsNoPrinter   EQU PStsSelected+PStsNoPaper
                      ;No Printer Installed
  PStsNormal      EQU PStsSelected+PStsNotBusy
                      ;Normal (Installed & Ready)

  ;----------------------------------------------------------------------------
  ;Bits in I/O Ports for Parallel
  ;Base Address + 0 = Data Port (Host to Peripheral Data Byte) Read/Write
  ;Base Address + 1 = Status Port (also Reverse Mode Data Nibble), Read-Only
  ;Base Address + 2 = Control Port (Read/Write)
  ;----------------------------------------------------------------------------
   ;Bits 0-1 = Reserved
   IOStsNotIRQ    EQU 04h ;IRQ has NOT occurred
   IOStsNotError  EQU 08h ;NOT Error                (nFault)   Data1 Data5
   IOStsSelected  EQU 10h ;Device is selected       (Select)   Data2 Data6
   IOStsNoPaper   EQU 20h ;Out of Paper             (PError)   Data3 Data7
   IOStsNotACK    EQU 40h ;NOT Acknowledge          (nAck)
   IOStsBusy      EQU 80h ;Busy                     (Busy)     Data4 Data8

   IOCtlStrobe    EQU 01h ;Strobe (minimum 5æs)     (nStrobe)
   IOCtlAutoLF    EQU 02h ;Auto LineFeed            (nAutoFd)
   IOCtlNotReset  EQU 04h ;NOT Reset/Initialize     (nInit)
   IOCtlSelectIn  EQU 08h ;Select Device            (nSelectIn)
   IOCtlEnableIRQ EQU 10h ;Enable IRQ (via NotACK)
   IOCtlBiDir     EQU 20h ;Enable Bi-directional
   ;Bits 6-7 = Reserved/Unused

  ;----------------------------------------------------------------------------
   ;Peripheral Status Aliases for Nibble/EPP/ECP
  ;----------------------------------------------------------------------------
   PerStsNDataAvail      EQU IOStsNotError
   PerStsNPeriphRequest  EQU IOStsNotError
   PerStsData15          EQU IOStsNotError
   PerStsXFlag           EQU IOStsSelected
   PerStsData26          EQU IOStsSelected
   PerStsAckDataReq      EQU IOStsNoPaper
   PerStsnAckReverse     EQU IOStsNoPaper
   PerStsData37          EQU IOStsNoPaper
   PerStsPtrClk          EQU IOStsNotACK
   PerStsPeriphClk       EQU IOStsNotACK
   PerStsIntr            EQU IOStsNotACK
   PerStsPtrBusy         EQU IOStsBusy
   PerStsPeriphAck       EQU IOStsBusy
   PerStsNWait           EQU IOStsBusy
   PerStsData48          EQU IOStsBusy

  ;----------------------------------------------------------------------------
   ;Host Control Aliases for Nibble/EPP/ECP
  ;----------------------------------------------------------------------------
   HstStsHostClk         EQU IOCtlStrobe
   HstStsNWrite          EQU IOCtlStrobe
   HstStsHostBusy        EQU IOCtlAutoLF
   HstStsHostAck         EQU IOCtlAutoLF
   HstStsNDStrb          EQU IOCtlAutoLF
   HstStsNReverseRequest EQU IOCtlNotReset
   HstSts1284Active      EQU IOCtlSelectIn
   HstStsNAStrb          EQU IOCtlSelectIn


;==============================================================================
;USB Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Maximum number of Devices we can control
  ;----------------------------------------------------------------------------
  MaxDevices EQU 8

  ;----------------------------------------------------------------------------
  ;Maximum number of Printers we will allow for Redirection
  ;Normally, DOS only allows 3 Printers (LPT1 - LPT3)
  ;We will allow a maximum of 9 (LPT1 - LPT9), PRN is same as LPT1
  ;----------------------------------------------------------------------------
  MaxPrinters EQU 9

  ;----------------------------------------------------------------------------
  ;Maximum number of entries in Bad (incompatible) Device Table
  ;----------------------------------------------------------------------------
  MaxBadDevices EQU 8

  ;----------------------------------------------------------------------------
  ;Number of Block Transfer Timeout Counter Table Entries
  ;----------------------------------------------------------------------------
  NumBlockTimeouts EQU 4 ;Only needed for true parallel-port devices

  ;----------------------------------------------------------------------------
  ;General
  ;----------------------------------------------------------------------------
  Int14RequestSize EQU 64 ;Size of Int 14 USB Request Data Structure

  ;----------------------------------------------------------------------------
  ;Size of buffer to store Descriptors
  ;----------------------------------------------------------------------------
  MaxDescriptorSize EQU 200

  ;----------------------------------------------------------------------------
  ;Size of Buffer to Store Device ID String
  ;----------------------------------------------------------------------------
  DvcIDBufferSize EQU 1024

  ;----------------------------------------------------------------------------
  ;USB Descriptor Types
  ;----------------------------------------------------------------------------
  DescrTypeDevice    EQU 01h ;Device
  DescrTypeConfig    EQU 02h ;Configuration
  DescrTypeString    EQU 03h ;String
  DescrTypeInterface EQU 04h ;Interface
  DescrTypeEndPoint  EQU 05h ;EndPoint
  DescrTypeDvcQual   EQU 06h ;Device Qualifier
  DescrTypeOtherSpd  EQU 07h ;Other Speed Configuration
  DescrTypeIntfPower EQU 08h ;Interface Power
  DescrTypeOnTheGo   EQU 09h ;On-the-Go
  DescrTypeDebug     EQU 0Ah ;Debug
  DescrTypeIntfAssoc EQU 0Bh ;Interface Association
  ;Types 12 - 17 (0Ch - 11h) are added for Wireless USB
  DescrTypeWSecurity EQU 0Ch ;Wireless USB Security
  DescrTypeWKey      EQU 0Dh ;Wireless USB Key
  DescrTypeWEncrType EQU 0Eh ;Wireless USB Encryption Type
  DescrTypeWBOS      EQU 0Fh ;Wireless USB Binary-device Object Store
  DescrTypeWDvcCap   EQU 10h ;Wireless USB Device Capability
  DescrTypeWEndPtCmp EQU 11h ;Wireless USB Endpoint Companion

  ;----------------------------------------------------------------------------
  ;USB-Defined Device and Interface Classes, SubClasses, and Protocols
  ;----------------------------------------------------------------------------
  DvcClassNone        EQU 0 ;Device Class = None
  DvcSubClassNone     EQU 0 ;Device SubClass = None
  DvcProtocolNone     EQU 0 ;Device Protocol = None
  IntfClassPrinter    EQU 7 ;Interface Class = Printer
  IntfSubClassPrinter EQU 1 ;Interface SubClass = Printer
  IntfProtocolUniDir  EQU 1 ;Interface Protocol = Unidirectional
  IntfProtocolBiDir   EQU 2 ;Interface Protocol = Bidirectional

  ;----------------------------------------------------------------------------
  ;Possible Error Codes to return to calling program on completion of TD
  ;----------------------------------------------------------------------------
  TDStsOK             EQU 0000h ;ACK Received (TD completed OK / no errors)
  TDStsNAKReceived    EQU 0001h ;NAK Received
  TDStsStalled        EQU 0002h ;TD is Stalled
  TDStsTimeout        EQU 0004h ;TD has timed out (Bulk/Control)
  TDStsOverDue        EQU 0008h ;TD is OverDue (Int/Isoch)
  TDStsShortPacket    EQU 0010h ;TD Short Packet Detected
  TDStsBabbleDetected EQU 0020h ;Babble Detected
  TDStsCRCTOReceived  EQU 0040h ;CRC/TimeOut Error Received
  TDStsBitStuffError  EQU 0080h ;Rx Data contained > 6 ones in a row
  TDStsDataBuffErr    EQU 0100h ;Data Buffer Error
  TDStsControlSetup   EQU 1000h ;Error actually occurred during Control Setup
  TDStsDvcRemoved     EQU 2000h ;Device removed while TD was in progress
  TDStsLargeCallErr   EQU 8000h ;Error during Large Call

  ;----------------------------------------------------------------------------
  ;Epson Vendor & Product ID's
  ;Needed because Epson USB Printers require special handling
  ;----------------------------------------------------------------------------
  EpsonVendorID        EQU 04B8h ;Seiko Epson Corp
  ISDSmartCblMacProdID EQU 0002h ;ISD Smart Cable for Macintosh
  ISDSmartCblProdID    EQU 0003h ;ISD Smart Cable

  ;----------------------------------------------------------------------------
  ;Statuses sent by Host to USB Device Owners
  ;----------------------------------------------------------------------------
  ;Device Connect/Disconnect
  OwnerCallNewDvc   EQU 0001h ;A new Matching Device has been attached
  OwnerCallDvcDisc  EQU 0002h ;Registered Device has been disconnected
  OwnerCallDvc0Disc EQU 0003h ;Matching Unregistered Device Disconnected
  OwnerCallDontLook EQU 0007h ;Stop Looking for New Devices for ~5 seconds
  ;Device Enable/Disable/Reset/Suspend/Resume/Power
  OwnerCallDvcEnable   EQU 0008h ;Device Enabled
  OwnerCallDvcDisable  EQU 0009h ;Device Disabled
  OwnerCallDvcReset    EQU 000Ah ;Device Resetting
  OwnerCallDvcSuspend  EQU 000Bh ;Device Suspended
  OwnerCallDvcResume   EQU 000Ch ;Device Resumed
  OwnerCallDvcPwrOn    EQU 000Dh ;Device Power On
  OwnerCallDvcPwrOff   EQU 000Eh ;Device Power Off
  OwnerCallDvcPwrReset EQU 000Fh ;Device Power Reset
  ;Host Connect/Disconnect/Error
  OwnerCallNewHost     EQU 0011h ;A new Host Driver has been Installed
  OwnerCallHostDisc    EQU 0012h ;An existing Host Driver has been Uninstalled
  OwnerCallHostHWErr   EQU 0017h ;Host System/Processor Error (Host will Reset)
  ;Host Run/Stop/Reset/Suspend/Resume
  OwnerCallHostRun     EQU 0018h ;Host Running
  OwnerCallHostStop    EQU 0019h ;Host Stopped
  OwnerCallHostReset   EQU 001Ah ;Host Reset
  OwnerCallHostSuspend EQU 001Bh ;Host Suspended
  OwnerCallHostResume  EQU 001Ch ;Host Resumed
  OwnerCallHostDebug   EQU 001Dh ;Host in Debug Mode
  OwnerCallHostSST     EQU 001Eh ;Host Single-Stepped
  ;Timing Changes
  OwnerCallTimingChg   EQU 0021h ;Timing Change on Host
  ;Upstream Device Changes
  OwnerCallDvcDiscUS     EQU (OwnerCallDvcDisc OR 0080h)     ;Dvc Disc Upstream
  OwnerCallDvcEnableUS   EQU (OwnerCallDvcEnable OR 0080h)   ;Dvc Enable Upstream
  OwnerCallDvcDisableUS  EQU (OwnerCallDvcDisable OR 0080h)  ;Dvc Disable Upstream
  OwnerCallDvcResetUS    EQU (OwnerCallDvcReset OR 0080h)    ;Dvc Reset Upstream
  OwnerCallDvcSuspendUS  EQU (OwnerCallDvcSuspend OR 0080h)  ;Dvc Suspend Upstream
  OwnerCallDvcResumeUS   EQU (OwnerCallDvcResume OR 0080h)   ;Dvc Resume Upstream
  OwnerCallDvcPwrOnUS    EQU (OwnerCallDvcPwrOn OR 0080h)    ;Dvc PwrOn Upstream
  OwnerCallDvcPwrOffUS   EQU (OwnerCallDvcPwrOff OR 0080h)   ;Dvc PwrOff Upstream
  OwnerCallDvcPwrResetUS EQU (OwnerCallDvcPwrReset OR 0080h) ;Dvc PwrReset Upstream


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;STRUCTURES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;==============================================================================
;TSR Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;This is a Structure to use at the beginning of Interrupt Routines in
  ;  TSR's.  Using this header, along with the appropriate code,
  ;  will allow the installation and removal of TSR's (actually,
  ;  the redirected interrupt vectors of a TSR) in any order.
  ;Note that the real Interrupt code MUST IMMEDIATELY follow this Header!!
  ;----------------------------------------------------------------------------
  IntHdr STRUC
    HdwreRst  DB      0CBh ;Hardware Reset Routine (CBh = RETF)
    CodeJmp   DW    010EBh ;Jump to real Interrupt Handler (JMP ENDS)
    OldVector DD        ?  ;Old interrupt Vector
    Signature DW    0424Bh ;Signature for this type of Interrupt routine
    EOIFlag   DB        0  ;=80h if we issue End-of-Interrupt, else 0
    HdwreJmp  DW    0F4EBh ;Jump to Hardware Reset Routine (JMP HdwreRst)
    FutureUse DB 7 DUP (0) ;Reserved for future use
   ENDS
  IntOfst EQU OFFSET CodeJmp ;Offset from beginning of our Structure


;==============================================================================
;DOS Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Program Segment Prefix
  ;----------------------------------------------------------------------------
  PSPStruc      STRUC
    PSPDOSExit     DW       20CDh ;Int 20h Call
    PSPNextSegment DW          ?  ;Segment of First Byte of Memory beyond Program
    PSPCPMCall5    DB   6 DUP (?) ;CPM Far Call 5
    PSPInt22Addr   DD          ?  ;Stored Int 22h Handler
    PSPInt23Addr   DD          ?  ;Stored Int 23h (Ctrl-Break) Handler
    PSPInt24Addr   DD          ?  ;Stored Int 23h (Critical Error) Handler
    PSPParentPSP   DW          ?  ;Segment of Parent PSP
    PSPJFT         DB  20 DUP (?) ;Job File Table (20 File Handles)
    PSPEnvirSeg    DW          ?  ;Environment Segment for PSP
    PSPSSSPOnEntry DD          ?  ;Processes SS:SP on Entry to last Int 21h Call
    PSPJFTSize     DW          ?  ;Number of entries in JFT (default = 20)
    PSPJFTPointer  DD          ?  ;Pointer to JFT (Default = PSP:0018h)
    PSPPreviousPSP DD          ?  ;Pointer to previous PSP (Default = FFFF:FFFF)
    PSPFiller1     DB  18 DUP (?) ;Misc stuff used by SHARE, Windows, etc.
                                  ;Memory Below here available to TSR!
    PSPFiller2     DB   2 DUP (?) ;Unused in DOS <= 6.00
    PSPInt21       DW       21CDh ;Int 21h Call
    PSPRETF        DB        0CBh ;RETF Call
    PSPFiller3     DB   9 DUP (?) ;Can be used to make Extended FCB from FCB1
    PSPFCB1        DB  16 DUP (?) ;First File Control Block
    PSPFCB2        DB  16 DUP (?) ;Second File Control Block
    PSPFiller4     DB   4 DUP (?) ;Unused
    PSPCmdLineLen  DB          ?  ;Command Line Length & DTA
    PSPCmdLine     DB 127 DUP (?) ;Command Line String
   ENDS
  PSPStrucSize EQU (TYPE PSPStruc) ;Should be 256 bytes

  ;----------------------------------------------------------------------------
  ;Memory Control Block
  ;----------------------------------------------------------------------------
  MCBStruc STRUC
    MCBID              DB        ?  ;Memory Control Block ID
      MCBIDValid      EQU       'M' ;Memory Block is Valid
      MCBIDLastInList EQU       'Z' ;Memory Block is Last in List
    MCBOwnerID         DW        ?  ;PSP Segment of Owner
                                    ;   0 = Owns Self
                                    ;   6 = DR-DOS XMS UMB
                                    ;   7 = DR-DOS Excluded Upper Memory
                                    ;   8 = Belongs to DOS
                                    ;FFFx = 386Max
    MCBSize            DW        ?  ;Size in Paragraphs
    MCBFiller          DB 3 DUP (?) ;Filler
    MCBOwnerName       DB 8 DUP (?) ;Owner Name
   ENDS
  MCBStrucSize EQU (TYPE MCBStruc) ;Should be 16 bytes

  ;----------------------------------------------------------------------------
  ;Structure needed to Initialize DOS EXEC Function
  ;----------------------------------------------------------------------------
  ParamBlockStruc STRUC
    PBEnvirSegment   DW ? ;Environment Segment to use (0 = Copy Callers Segment)
    PBCmdTailPtr     DD ? ;Pointer to Command Tail
    PBFCB1Offset     DD ? ;Pointer to File Control Block #1
    PBFCB2Offset     DD ? ;Pointer to File Control Block #2
    PBSSSPOnReturn   DD ? ;Holds Childs Initial SS:SP on Return (if AL = 01)
    PBCSIPOnReturn   DD ? ;Holds Entry Point (CS:IP) on Return (if AL = 01)
   ENDS
  ParamBlockSize EQU (TYPE ParamBlockStruc) ;Size of EXEC Parameter Block

  ;----------------------------------------------------------------------------
  ;DTA (Disk Transfer Area) after Find First Matching File (INT 21h, Func 4Eh)
  ;The first several bytes of the DTA are DOS version specific, and
  ;  we don't care about that data anyway.  We only care about the data
  ;  that is documented and the same across all versions of DOS.
  ;----------------------------------------------------------------------------
  FindFirstStruc   STRUC            ;Find First Matching File
    FFVerSpecific     DB 21 DUP (0) ;DOS Version-specific Data
    FFAttribs         DB         ?  ;File Attributes
      FAttrReadOnly  EQU        01h ;Read-Only
      FAttrHidden    EQU        02h ;Hidden
      FAttrSystem    EQU        04h ;System
      FAttrVolume    EQU        08h ;Volume Label
      ;Bit 3 = Execute-only (Novell Netware)
      FAttrDirectory EQU        10h ;Directory
      FAttrArchive   EQU        20h ;Archive
      FAttrUnused    EQU        40h ;Unused
                                    ;DOS 3+ returns this bit set if file
                                    ;  is actually a character device
                                    ;DOS Window underneath Windows XP doesn't
      ;Bit 7 = Delete Pending (OpenDOS, NovellDOS)
      ;      = Shareable (Novell Netware)
   FFTime            DW         ?  ;File Creation Time
    FFDate            DW         ?  ;File Creation Date
    FFSize            DD         ?  ;File Size
    FFName            DB 13 DUP (?) ;ASCIIZ File Name & Extension
   ENDS

   FAttrToUse EQU FAttrHidden+FAttrSystem
     ;Attributes to use in DOS's Find First Matching File Function
     ;DOS ignores the Read-Only and and Archive bits, so they don't matter
   FileAttrRA  EQU (FAttrReadOnly+FAttrArchive)
     ;Attribute to use when Opening a File to Print

  ;============================================================================
  ;Structures needed to Open/Read/Write Files
  ;============================================================================

  ;----------------------------------------------------------------------------
  ;Format of data returned by a standard Find File Request
  ;----------------------------------------------------------------------------
  FindFileStruc      STRUC     ;Structure for Find File Request
    FFVaries    DB 15h DUP (0) ;Varies by DOS version/manufacturer
    FFAttribs           DB  ?  ;File attributes
    FFFileTime          DW  ?  ;File Time
    FFFileDate          DW  ?  ;File Date
    FFFileSize          DD  ?  ;File Size
    FFFileName  DB 13  DUP (0) ;ASCIIZ File Name + Extension
   ENDS
  FindFileStrucSize EQU TYPE (FindFileStruc)

  ;----------------------------------------------------------------------------
  ;Format of data returned by an LFN Find File Request
  ;----------------------------------------------------------------------------
  FindFileLFNStruc   STRUC     ;Structure for LFN Find File Request
    FLAttribs           DD  ?  ;File Attributes
                               ;  First six bits same as DOS
                               ;  Bit 8 = Temporary File
    FLCreateTime        DQ  ?  ;File Creation time, 100ns intervals since 1/1/1601
    FLAccessTime        DQ  ?  ;Last Access time
    FLModifyTime        DQ  ?  ;Last Modification time
    FLFileSizeHigh32    DD  ?  ;Size of File (High 32 bits)
    FLFileSizeLow32     DD  ?  ;Size of File (Low 32 bits)
    FLReserved          DQ  ?  ;8 bytes Reserved
    FLLongName  DB 260 DUP (0) ;Long Name (ASCIIZ)
    FLShortName DB  14 DUP (0) ;Short Name (ASCIIZ)
                               ;  Empty String if no LFN Entry available,
                               ;  use Long Name instead
   ENDS
  FindFileLFNStrucSize EQU TYPE (FindFileLFNStruc)


;==============================================================================
;Device Driver Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Device Driver Header (Standard Character Devices)
  ;This is the format of the first several bytes (offset 0) of a standard
  ;  character Device Driver file, as loaded via CONFIG.SYS.
  ;----------------------------------------------------------------------------
  DvcHdrStruc         STRUC
    DHNextHeader         DD    ?  ;Point to the Next Device Header
                                  ;  Offset = -1 if this is Last Device Header
    DHAttribs            DW    ?  ;Device Attributes
     ;Character Devices
      DHAttrCharDvc     EQU 8000h ;Is a Character Device (must be set!)
      DHAttrIOCtl       EQU 4000h ;IOCTL supported
      DHAttrOutTilBusy  EQU 2000h ;Output Until Busy supported (DOS 3.0+)
      ;Bit 12 = Reserved
      DHAttrOpenClose   EQU 0800h ;Open/Close/RemovableMedia calls supported
      ;Bits 10-8 = Reserved
      DHAttrGenIOCtlCk  EQU 0080h ;Generic IOCTL check supported (DOS 5.0+)
                                  ;  (Driver Command 25)
      DHAttrGenIOCtl    EQU 0040h ;Generic IOCTL supported (DOS 3.2+)
                                  ;  (Driver Command 19)
      ;Bit 5 = Reserved
      DHHAttrInt29h     EQU 0010h ;Device is Special (Use INT 29h for Output)
      DHAttrIsClock     EQU 0008h ;Device is CLOCK$
      DHAttrIsNul       EQU 0004h ;Device is NUL
      DHAttrIsStdOut    EQU 0002h ;Device is STDOUT
      DHAttrIsStdIn     EQU 0001h ;Device is STDIN
    DHStrategyOffset     DW    ?  ;Offset of Strategy Code Entry Point
                                  ;  Called with ES:[BX] = Request Header
    DHInterruptOffset    DW    ?  ;Offset of Interrupt Code Entry Point
    DHCDvcName           DB 8 DUP ' ' ;Device Name (Left-aligned, Blank-padded)
   ENDS
  DvcHdrStrucSize EQU (TYPE DvcHdrStruc) ;Should be 18 bytes

  DHAttrsToUse EQU DHAttrCharDvc+DHAttrOutTilBusy+DHAttrGenIOCtlCk+DHAttrGenIOCTL
                   ;Attributes we will use for our Printer Drivers


  ;============================================================================
  ;Request Headers (what the ES:[BX] sent during a Strategy Call points at)
  ;============================================================================

  ;----------------------------------------------------------------------------
  ;Structure for Request Header Needed by Device Driver Interrupt Calls.
  ;This is used to pass data back and forth between DOS and the Driver.
  ;All Requests include this Header.  Some Requests include additional
  ;  data appended to the end of the header, as detailed below.
  ;----------------------------------------------------------------------------
  RequestHdrStruc     STRUC
   RHLength              DB        ?  ;Length of Request (bytes)
   RHPAD                 DB        ?  ;Not used for Character Devices
   RHCommand             DB        ?  ;Most Recent Command sent to Driver
     RHCmdInitialize    EQU        0  ;Initialize
     RHCmdMediaCheck    EQU        1  ;Media Check
     RHCmdBuildBPB      EQU        2  ;Build BIOS Parameter Block
     RHCmdIOCtlRead     EQU        3  ;IOCtl Read (Input)
     RHCmdRead          EQU        4  ;Read (Input)
     RHCmdNDRead        EQU        5  ;Non-destructive Read (Input) No Wait
     RHCmdInputStatus   EQU        6  ;Current Input Status
     RHCmdFlushInput    EQU        7  ;Flush Input Buffers
     RHCmdWrite         EQU        8  ;Write (Output)
     RHCmdWriteVerify   EQU        9  ;Write (Output) with Verify
     RHCmdOutputStatus  EQU       10  ;Output Status
     RHCmdFlushOutput   EQU       11  ;Flush Output Buffers
     RHCmdIOCtlWrite    EQU       12  ;IOCtl Write (Output)
     RHCmdOpen          EQU       13  ;Device Open
     RHCmdClose         EQU       14  ;Device Close
     RHCmdRemovable     EQU       15  ;Removable Media
     RHCmdOutputTilBusy EQU       16  ;Output Until Busy
     RHCmdGenIOCtlV3    EQU       17  ;Generic IOCtl DOS 3
     ;18 = Illegal Function
     RHCmdGenIOCtlV4    EQU       19  ;Generic IOCtl DOS 4+
     ;20-22 = Illegal Functions
     RHCmdGetLogicalDvc EQU       23  ;Get Logical Device (DOS 3.2+)
     RHCmdSetLogicalDvc EQU       24  ;Set Logical Device (DOS 3.2+)
     RHCmdGenIOCtlCk    EQU       25  ;Generic IOCtl Check (DOS 5+)
   RHStatus              DW        ?  ;Status Code
     RHSNoError         EQU        0  ;No error
     RHSDone            EQU     0100h ;Done processing last Interrupt Call
     RHSBusy            EQU     0200h ;Driver is currently Busy
     RHSError           EQU     8000h ;Error (must be combined with Error Code
                                      ;  in low byte)
     RHSWriteProt       EQU        0  ;Write-protect Violation
     RHSUnknownUnit     EQU        1  ;Unknown Unit
     RHSDvcNotReady     EQU        2  ;Device Not Ready
     RHSUnknownCmd      EQU        3  ;Unknown Command
     RHSCRCError        EQU        4  ;CRC Error
     RHSBadRHLength     EQU        5  ;Bad Request Header Length field
     RHSSeekError       EQU        6  ;Seek Error
     RHSUnknownMedia    EQU        7  ;Unknown Media
     RHSSectorNF        EQU        8  ;Sector Not Found
     RHSOutOfPaper      EQU        9  ;Printer Out of Paper
     RHSWriteFault      EQU       10  ;Write Fault
     RHSReadFault       EQU       11  ;Read Fault
     RHSGeneralFail     EQU       12  ;General failure
     ;13-14 = Reserved
     RHSInvalidChange   EQU       15  ;Invalid Disk Change
   RHReserved            DB 8 DUP (0) ;Reserved for use by DOS
   ENDS
  RHSize EQU (TYPE RequestHdrStruc) ;Size of Header (should be 13 bytes)

  ;----------------------------------------------------------------------------
  ;Data on Entry to Initialize Function
  ;----------------------------------------------------------------------------
  RHInitInStruc    STRUC
    RHInitInHdr       DB RHSize DUP (?) ;Common Header
    RHInitInPAD       DB      5 DUP (?) ;Leave space for return values
    RHInitInCmdLine   DD             ?  ;Pointer to Command Line Arguments
    RHInitInFirstUnit DB             ?  ;First Unit Number
    RHInitInConfigErr DW             ?  ;CONFIG.SYS Error Msg Ctrl Flag (v4)
                                         ;  If <> 0, "Error in CONFIG.SYS"
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Exit from Initialize Function
  ;----------------------------------------------------------------------------
  RHInitOutStruc   STRUC
    RHInitOutHdr      DB RHSize DUP (?) ;Common Header
    RHInitOutNumUnits DB             ?  ;Number of Units
    RHInitOutLastByte DD             ?  ;Pointer to first byte of unused
                                        ;  Memory at end of Driver (where
                                        ;  next Driver can be loaded)
    RHInitOutBPBPtr   DD             ?  ;Pointer to BIOS Parameter Block(s)
                                        ;Points at an array of WORD Pointers
                                        ;   How to end the Array list?
                                        ;   BPB's are read-only!
    RHInitLogicalDrv  DB             ?  ;Logical Drive to be assigned to
                                        ;  the first unit (In or out?)
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Entry to Media Check Function
  ;  Sole purpose is to check if media has changed or not!
  ;----------------------------------------------------------------------------
  RHMediaInStruc  STRUC
    RHMediaInHdr     DB RHSize DUP (?) ;Common Header
    RHMediaInMediaID DB             ?  ;Media ID
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Exit from Media Check Function
  ;----------------------------------------------------------------------------
  RHMediaOutStruc      STRUC
    RHMediaOutHdr         DB RHSize DUP (?) ;Common Header
    RHMediaOutPAD         DB             ?  ;Don't change Media ID
    RHMediaOutChangeCode  DB             ?  ;Media Change Code
      MediaChangeNo      EQU             1  ;Media not changed
      MediaChangeYes     EQU            -1  ;Media changed
      MediaChangeUnknown EQU             0  ;Don't know/Unsure
    ;DR-DOS recommends setting a two second timer to keep the disk
    ;  as "not changed" after a successful disk access, if the disk
    ;  does not have a legitimate media change line/bit
    RHMediaOutVolNamePtr  DD             ?  ;Last Volume Name (ID) Read Pointer
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Entry to Build BIOS Parameter Block Function
  ;Called after a Media change has been detected to log the new media
  ;----------------------------------------------------------------------------
  RHBPBInStruc     STRUC
    RHBPBInHdr        DB RHSize DUP (?) ;Common Header
    RHBPBInMediaID    DB             ?  ;Media ID
    RHBPBInSectorBuff DD             ?  ;Pointer to Buffer one sector in size
                                        ;If IBM format, is first FAT Sector
                                        ;  (First byte of FAT Sector contains
                                        ;   the FAT ID)
                                        ;All Devices supported by the same
                                        ;  Driver must have the same
                                        ;  FAT Sector Number!
                                        ;If non-IBM format, can be used by the
                                        ;  driver to determine the BPB
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Exit from Build BIOS Parameter Block Function
  ;----------------------------------------------------------------------------
  RHBPBOutStruc STRUC
    RHBPBOutHdr    DB RHSize DUP (?) ;Common Header
    RHBPBOutPAD    DB      5 DUP (?) ;Don't change Media ID or Buffer Pointer
    RHBPBOutBPBPtr DD             ?  ;Pointer to BPB
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Entry to IOCtl Read & Write Functions
  ;  Data following main Header is Driver-specific
  ;----------------------------------------------------------------------------
  RHIOCtlRdWrInStruc    STRUC
    RHIOCtlRdWrInHdr       DB RHSize DUP (?) ;Common Header
    RHIOCtlRdWrInMediaID   DB             ?  ;Media ID
    RHIOCtlRdWrInXferAddr  DD             ?  ;Transfer Address
    RHIOCtlRdWrInByteCount DW             ?  ;Byte/Sector Count (Requested)
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Exit from IOCtl Read & Write Functions is Driver-specific
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;Data on Entry to Read, Write, and Write-with-Verification Functions
  ;Also includes IOCtlRead/IOCtlWrite
  ;This is also used for the Output-Til-Busy Function (Character Devices)
  ;IOCtlRead & IOCtlWrite do same thing as Read & Write, but do not do
  ;  any error checking.
  ;Write with Verify Reads back after the Write and compares values
  ;----------------------------------------------------------------------------
  RHRdWrInStruc      STRUC
    RHRdWrInInHdr       DB RHSize DUP (?) ;Common Header
    RHRdWrInMediaID     DB             ?  ;Media ID
    RHRdWrInXferAddr    DD             ?  ;Transfer Address
    RHRdWrInByteCount   DW             ?  ;Byte/Sector Count (Requested)
                                          ;For Character Device always = 1
    RHRdWrInStartSect16 DW             ?  ;Starting Sector # (16-bit)
                                          ;  Block Devices Only
                                          ;  If DOS 4+, -1 means to use
                                          ;    StartSector32
    RHRdWrInPAD         DB      4 DUP (?) ;Leave room for Volume Name (ID)
    RHRdWrInStartSect32 DD             ?  ;Starting Sector # (32-bit)
                                          ;  Block Devices Only
                                          ;  Only valid if DOS 4+ &
                                          ;    StartSector16 = -1
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Exit from Read, Write, and Write-with-Verification Functions
  ;This is also used for the Output-Til-Busy Function (Character Devices)
  ;----------------------------------------------------------------------------
  RHRdWrOutStruc    STRUC
    RHRdWrOutInHdr     DB RHSize DUP (?) ;Common Header
    RHRdWrOutPAD1      DB      5 DUP (?) ;Don't change Media ID or Xfr Addr
    RHRdWrOutByteCount DW             ?  ;Byte/Sector Count (Actual)
    RHRdWrOutPAD2      DB      2 DUP (?) ;Don't change Starting Sector
    RHRdWrOutVolumePtr DD             ?  ;Pointer to Volume Name (ID)
                                         ;Required if Device Error = 15
                                         ;  (Invalid Media Change)
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Entry to Non-Destructive Read Function is empty
  ;Character (Keyboard) Devices Only
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;Data on Exit from Non-Destructive Read Function
  ;Character (Keyboard) Devices Only
  ;Reads the character, but does not remove it from the Input Buffer
  ;----------------------------------------------------------------------------
  RHNDReadOutStruc STRUC
    RHNDReadOutHdr    DB RHSize DUP (?) ;Common Header
    RHReadOutChar     DB             ?  ;The character read from the Device
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Entry to Input Status, Output Status, Flush Input,
  ;  and Flush Output Functions is empty
  ;Character Devices Only
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;Data on Exit from Input Status, Output Status, Flush Input,
  ;  and Flush Output Functions is empty
  ;Character Devices Only
  ;Status Function tests to see if the Device is Ready (Write) or a
  ;  character is in the Buffer (Read) so that a consequent call will not
  ;  need to wait.  Returns 0 in Busy Bit if Device is Ready, 1 if
  ;  not Ready (Read/Write would need to wait).
  ;----------------------------------------------------------------------------

  ;Functions below this point require DOS 3.0+

  ;----------------------------------------------------------------------------
  ;Data on Entry to Open, Close, and Removable Media Functions is empty
  ;Removable Media Function is only for Block Devices.
  ;This informs the BIOS when a File (Block Dvc) or Device (Character Dvc)
  ;  is Opened or Closed
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;Data on Exit from Open, Close, and Removable Media Functions is empty
  ;The Removable Media Function should return 0 in the Busy Bit if the Media
  ;  is Removable, 1 in the Busy Bit if non-Removable.
  ;Removable Media Function is only for Block Devices.
  ;----------------------------------------------------------------------------

  ;============================================================================
  ;Generic I/O Related Requests
  ;============================================================================

  ;----------------------------------------------------------------------------
  ;Data on Entry to Generic IOCtl Function
  ;  DOS Function 440Ch = Generic I/O Request for Character Devices
  ;  DOS Function 440Dh = Generic I/O Request for Block Devices
  ;  Cat/Func Codes were sent by application in the CX register for Func 44h
  ;Data on entry to GenericIOCtlCk Function is same through the Category
  ;  and Function.  It does not have the SI, DI, or parameter Block fields.
  ;----------------------------------------------------------------------------
  RHGenIOCtlStruc      STRUC
    RHGenIOCtlHdr         DB RHSize DUP (?) ;Common Header
    RHGenIOCtlCategory    DB  ?  ;Category (Major) Code
     ;-------------------------------------------------------------------------
     ;Categories 00-7Fh = Microsoft
     ;-------------------------------------------------------------------------
      IOCatUnknown       EQU 00h ;Unknown (DOS 3.3+)
      IOCatCOMx          EQU 01h ;COMx
      IOCatTermReserved  EQU 02h ;Reserved for Terminal Control
      IOCatCON           EQU 03h ;CON
      IOCatKeybReserved  EQU 04h ;Reserved for Keyboard Control
      IOCatLPTx          EQU 05h ;LPTx
      IOCatEuroMouse     EQU 07h ;Mouse Control (European DOS 4.0)
      IOCatDisk          EQU 08h ;Disk Control (INT 21/440Dh)
      IOCatFAT32Disk     EQU 48h ;FAT32 Disk Control (INT 21/440Dh)
     ;-------------------------------------------------------------------------
     ;Categories 80-FFh = OEM/User-Defined
     ;-------------------------------------------------------------------------
    RHGenIOCtlFunction    DB  ?  ;Function (Minor) Code (aka Command)
     ;-------------------------------------------------------------------------
     ;Meanings of certain bits in the Command Byte
     ;-------------------------------------------------------------------------
      IOCmdMaskIgnoreErr EQU 80h ;Ignore error if unsupported
                                 ;  (else return error code)
      IOCmdMaskToDriver  EQU 40h ;Send command to Driver
                                 ;  (else intercepted by DOS)
      IOCmdMaskGetData   EQU 20h ;Gets Data (else Sends Data)
                                 ;  If both Gets and Sends, bit = 0
      IOCmdMaskCommand   EQU 1Fh ;Actual command in bits 0-4
     ;-------------------------------------------------------------------------
     ;Character Device Commands
     ;-------------------------------------------------------------------------
      IOCmdSetScreenMode EQU 40h ;Set Screen Mode (DOS 3 only)
      IOCmdGetScreenMode EQU 60h ;Get Screen Mode (DOS 3 only)
      IOCmdGetDeviceID   EQU 60h ;Get Printer Device ID (the one we've added!)
      IOCmdSetRetry      EQU 45h ;Set Printer Iteration (retry) count
      IOCmdGetRetry      EQU 65h ;Get Printer Iteration (retry) count
      IOCmdSetCodePage   EQU 4Ah ;Set (Select) Code Page
      IOCmdGetCodePage   EQU 6Ah ;Get Code Page
      IOCmdGetCodePagePr EQU 6Bh ;Get Code Page Prepare List (DOS 4+)
      IOCmdStartCodePage EQU 4Ch ;Start Code Page Preparation
      IOCmdEndCodePage   EQU 4Dh ;End Code page Preparation
      IOCmdSetDisplay    EQU 5Fh ;Set Display Info (DOS 4+)
      IOCmdGetDisplay    EQU 7Fh ;Get Display Info (DOS 4+)
    RHGenIOCtlSI          DW  ?  ;SI Register (EuroDOS and OS/2)
    RHGenIOCtlDI          DW  ?  ;DI Register (EuroDOS and OS/2)
    RHGenIOCtlParamBlkPtr DD  ?  ;Parameter Block Pointer
   ENDS

  ;----------------------------------------------------------------------------
  ;Data on Entry and Exit from Query Generic IOCtl Capability Function
  ;----------------------------------------------------------------------------
  RHGenIOCtlCkStruc      STRUC
    RHGenIOCtlCkHdr       DB RHSize DUP (?) ;Common Header
    RHGenIOCtlCkCategory  DB  ? ;Category (Major) Code
                                ;  (Same as GenericIOCtl Category Codes)
    RHGenIOCtlCkFunction  DB  ? ;Function (Minor) Code (aka Command)
                                ;  (Same as GenericIOCtl Function Codes)
    RHGenIOCtlCkPAD       DB 3 DUP (?) ;No idea what this area is for
    RHGenIOCtlCkAX        DW  ? ;Value INT 21h returns in AX when done
                                ;Set to 0 before completing call
   ENDS


  ;============================================================================
  ;Generic I/O Parameter Blocks
  ;============================================================================

  ;----------------------------------------------------------------------------
  ;Generic IOCTL Parameter Block for Get and Set Screen Mode Functions
  ;  These function may have never been implemented in a real version of DOS
  ;----------------------------------------------------------------------------
  GIOScreenModeStruc STRUC
    GIOSMDataLength DW 9 ;Length of Data
    GIOSMModeType   DB ? ;Mode Type
    GIOSMNumColors  DW ? ;Number of Colors
    GIOSMWidth      DW ? ;Width
    GIOSMHeight     DW ? ;Height
   ENDS

  ;----------------------------------------------------------------------------
  ;Generic IOCTL Parameter Block for Get Printer Device ID
  ;This is the one we have added!
  ;----------------------------------------------------------------------------
  GIOGetDeviceIDStruc STRUC
    GIODvcIDFlags        DB  ?  ;Flags
      GIOFlagShortPktOK EQU 01h ;Don't return error for Short Packet
      ;Bits 1-7 Reserved
    GIODvcIDReserved     DB  ?  ;Reserved
    GIODvcIDBuffSize     DW  ?  ;Maximum size of Buffer/Bytes Returned
    GIODvcIDBuffAddr     DD  ?  ;Buffer Address
   ENDS

  ;----------------------------------------------------------------------------
  ;Generic IOCTL Parameter Block for Get and Set Retry Iteration Count
  ;Only applies to Printers?
  ;----------------------------------------------------------------------------
  GIOIterationStruc STRUC
    GIOItCount DW ? ;Iteration Count
   ENDS

  ;----------------------------------------------------------------------------
  ;NOTE: Although technically Code Page selection and support can be
  ;        provided to either CON or PRN/LPTx Devices, it is really
  ;        virtually useless for Printers.
  ;      Code Page support for printers was provided through PRINTER.SYS,
  ;        which only supported a select few IBM ProPrinters & QuietWriters.
  ;      Many modern printers have selectable Code pages, but PRINTER.SYS
  ;        does not support them.  I'm not aware of any other
  ;        Device Drivers that support Code Pages for Printers besides
  ;        PRINTER.SYS.
  ;      We do not do anything with Code Pages in this printer program.
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;Generic IOCTL Parameter Block for Get and Set Code Page
  ;Does not normally apply to Printers
  ;----------------------------------------------------------------------------
  GIOCodePageStruc STRUC
    GIOCPDataLength DW ? ;Length of Data
    GIOCPCodePage   DW ? ;Code page ID
    GIOCPCharSets   DW ? ;Double-byte Character Sets (multiple)
   ENDS

  ;----------------------------------------------------------------------------
  ;Generic IOCTL Parameter Block for Code Page Preparation (DOS 4+)
  ;----------------------------------------------------------------------------
  GIOCodePagePrepStruc STRUC
    GIOCPPDataLength   DW ? ;Length of Data
    GIOCPPNumHWPages   DW ? ;Number of Hardware Code Pages
    GIOCPPHWPage       DW ? ;Hardware Code Page (multiple)
    GIOCPPNumPrepPages DW ? ;Number of Prepared Code Pages
    GIOCPPPrepPage     DW ? ;Prepared Code Page (multiple)
   ENDS

  ;----------------------------------------------------------------------------
  ;Generic IOCTL Parameter Block for Start Code Page Preparation
  ;----------------------------------------------------------------------------
  GIOCodePageStartStruc STRUC
    GIOCPSFlags      DW ? ;DISPLAY.SYS = 0
                          ;PRINTER.SYS
                          ;  0001h = Prepare Cartridge Selection
                          ;          Clear = Prepare Downloaded Font
    GIOCPSDatalength DW ? ;Length of Remainder of Block
    GIOCPSNumPages   DW ? ;Number of Code Pages following
    GIOCPSCodePage   DW ? ;Code Page (multiple)
   ENDS

  ;----------------------------------------------------------------------------
  ;Generic IOCTL Parameter Block for Start Code Page Preparation
  ;----------------------------------------------------------------------------
  GIOCodePageEndStruc STRUC
    GIOCPEDataLength DW ? ;Length of Data
    GIOCPECodePage   DW ? ;Code page ID (multiple?)
   ENDS

  ;----------------------------------------------------------------------------
  ;Generic IOCTL Parameter Block for Get/Set Display Information (DOS 4+)
  ;----------------------------------------------------------------------------
  GIODisplayInfoStruc STRUC
    GIODispLevel       DB    ?  ;Level (0 for DOS 4.x-6.0)
    GIODispReserved1   DB    ?  ;Reserved (0)
    GIODispDatalength  DW   14  ;Length of Following Data
    GIODispCtlFlags    DW    ?  ;Control Flags
      GIODFlagIntense EQU 0000h ;Intensity
      GIODFlagBlink   EQU 0001h ;Blinking
    GIODispModeType    DB    ?  ;Mode Type
      GIODModeText    EQU   01h ;Text Mode
      GIODModeGraph   EQU   02h ;Graphics Mode
    GIODispReserved2   DB    ?  ;Reserved
    GIODispBitsPerPix  DW    ?  ;Number of Bits per Pixel (0 = Monochrome)
    GIODispPixCols     DW    ?  ;Pixel Columns
    GIODispPixRows     DW    ?  ;Pixel Rows
    GIODispCharCols    DW    ?  ;Character Columns
    GIODispCharRows    DW    ?  ;Character Rows
   ENDS


  ;============================================================================
  ;Additional Data needed for Our Device Drivers
  ;============================================================================

  ;----------------------------------------------------------------------------
  ;Device Driver Header (additional data needed for our program)
  ;  We need additional data besides the Standard Device Driver Header
  ;----------------------------------------------------------------------------
  LPTxHdrStruc   STRUC
    LHStdHdr        DB DvcHdrStrucSize DUP (?) ;Standard Device Header
    LHLPTIndex      DB  ?  ;LPT Index (LPT Number - 1)
    LHFlags         DB  ?  ;Number of Open Counts (to return Busy status)
      LHFlagNotUs  EQU 01h ;Call is not for us (let old Device Driver handle it)
    LHRetryCount    DW  ?  ;Iteration (Retry) Counter
                           ;We store this in case a program sets it or
                           ;  asks us what it is, but we don't do anything
                           ;  with it at a functional level
    LHReqOffset     DW  ?  ;Request Header Offset
    LHReqSegment    DW  ?  ;Request Header Segment
   ENDS
  LPTxHdrStrucSize EQU (TYPE LPTxHdrStruc) ;Size of Structure


;==============================================================================
;USB/Printer Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;This structure keeps track of each of the several individual USB Devices
  ;----------------------------------------------------------------------------
  DeviceInfoStruc STRUC
    DIFlags             DB  ?  ;Misc Yes/No Flags
      DIFlagInUse      EQU 01h ;This entry currently being used?
      DIFlagResetDone  EQU 02h ;Soft Reset is Complete
      DIFlagResetError EQU 04h ;Soft Reset errored out
      DIFlagIsEpson    EQU 08h ;Printer is an Epson
      DIFlagInitEpson  EQU 10h ;Epson USB Printer needs to be initialized
    DIStatusByte        DB  ?  ;Status Flags Byte
    DIHostIndex         DB  ?  ;Host Index
    DIDvcAddress        DB  ?  ;Device Address
    DIInterfaceNum      DB  ?  ;Interface number
    DIAltInterface      DB  ?  ;Alternate Interface number
    DIEndPointIn        DB  ?  ;In End Point Number
    DIEndPointOut       DB  ?  ;Out End Point Number
    DILPTNum            DB  ?  ;LPT Number (0=Unused, 1=LPT1, etc.)
    DIFiller            DB  ?  ;To align data at even addresses
    DIRegHandle         DW  ?  ;Handle Number of Owner Registry
    DIOldIOAddress      DW  ?  ;Original I/O address we replaced in the BIOS
    DIBufferPtr         DW  ?  ;Offset of Buffer used to store data
    DIDataRtnAX         DW  ?  ;AX on return from Int 14h Requests
    DIDataRtnCX         DW  ?  ;CX on return from Int 14h Requests
    DIInt14Request      DB Int14RequestSize DUP (?) ;Int 14 Request for Device
   ENDS
  DeviceInfoStrucSize EQU (TYPE DeviceInfoStruc)

  ;----------------------------------------------------------------------------
  ;This structure keeps track of User Timeoputs for real parallel port
  ;  block transfers
  ;----------------------------------------------------------------------------
  BlockTimeoutStruc STRUC
    BTFlags             DB  ?  ;Misc Yes/No Flags
      BTFlagInUse      EQU 01h ;This entry currently being used?
    BTFiller            DB  ?  ;To align data at even addresses
    BTCounter           DW  ?  ;Block Transfer Timeout Counter
   ENDS
  BlockTimeoutStrucSize EQU (TYPE BlockTimeoutStruc)

  ;----------------------------------------------------------------------------
  ;This structure is used to temporarily store data being sent to the printers
  ;----------------------------------------------------------------------------
  BufferStruc STRUC
    BfFlags        DB  ?  ;Misc Yes/No Flags
      BfFlagInUse EQU 01h ;This entry currently being used?
      BfFlagDone  EQU 02h ;This buffer contents have been sent down the USB Bus
    BfFiller      DB  ?  ;To align data at even addresses
    BfTimer       DB  ?  ;Countdown timer; 0 = Buffer ready to send
    BfCloseID     DB  ?  ;Closure ID
    BfHandle      DW  ?  ;Bulk Transaction Handle
    BfDevicePtr   DW  ?  ;Device Info Offset this Buffer is for
    BfPrevBuffer  DW  ?  ;Previous Buffer in series
    BfNextBuffer  DW  ?  ;Next Buffer in Series
    BfNumBytes    DW  ?  ;Number of bytes currently in the buffer
    BfData        DB BufferSize DUP (0) ;The data buffer itself
   ENDS
  BufferStrucSize EQU (TYPE BufferStruc)
  BufferHdrSize   EQU (BufferStrucSize-BufferSize) ;Size of Header (no data)

  ;----------------------------------------------------------------------------
  ;This structure keeps track of Bad (incompatible) Devices
  ;----------------------------------------------------------------------------
  BadDeviceStruc    STRUC
    BDFlags            DB  ?  ;Misc Yes/No Flags
      BDFlagInUse     EQU 01h ;This entry currently being used?
    BDInterfaceNum     DB  ?  ;Interface Number of Bad Device
    BDHostIndex        DB  ?  ;Host Index of Bad Device
    BDDvcAddress       DB  ?  ;Device Address of Bad Device
    BDFiller           DB  ?  ;To align data at even addresses
    BDNewDeviceStage   DB  ?  ;Bad Device Stage
    BDNewDeviceError   DW  ?  ;Bad Device Error Code
   ENDS
  BadDeviceStrucSize EQU (TYPE BadDeviceStruc)

  ;----------------------------------------------------------------------------
  ;This is the format for a request sent to Int 14h to Send/Receive Data
  ;It contains the type of request, etc.
  ;----------------------------------------------------------------------------
  Int14RequestStruc         STRUC      ;Structure for an Int 14 Request
    I14RRequestType            DB   ?  ;Type of Request
      I14RRTHostClass         EQU  00h ;Host/System/OS Class
        I14RRTGetHostSWInfo   EQU  01h ;Get Host Software Info
        I14RRTGetHostHWInfo   EQU  02h ;Get Host Hardware Info
        I14RRTGetHostVendInfo EQU  03h ;Get Host Vendor Info
        I14RRTGetHostStatus   EQU  04h ;Get Current Host Status
        I14RRTHostRun         EQU  08h ;Start/Run/Resume Host
        I14RRTHostStop        EQU  09h ;Stop Host
        I14RRTHostReset       EQU  0Ah ;Reset Host
        I14RRTHostSuspend     EQU  0Bh ;Global Suspend Host
        I14RRTHostResume      EQU  0Ch ;Force Global Resume on Host
      I14RRTTimingClass       EQU  10h ;Frame Timing Class
        I14RRTRegTmgOwner     EQU  11h ;Register as Timing Owner
        I14RRTUnRegTmgOwner   EQU  12h ;UnRegister as Timing Owner
        I14RRTIncTiming       EQU  13h ;Increment (Slow Down) Frame Timing
        I14RRTDecTiming       EQU  14h ;Decrement (Speed Up) Frame Timing
        I14RRTChangeTiming    EQU  15h ;Change Frame Timing (by Large Amount)
      I14RRTHubClass          EQU  20h ;Hub Class
        I14RRTGetDvcHubInfo   EQU  21h ;Get Hub Info for Device
        I14RRTNewDvcConn      EQU  24h ;Hub has Detected new Device
        I14RRTDvcDisc         EQU  25h ;Device has been Disconnected
        I14RRTSendHubChar     EQU  27h ;Send Hub Characteristics to Host
        I14RRTEnableHubPort   EQU  28h ;Enable Device given Hub & Port
        I14RRTDisableHubPort  EQU  29h ;Disable Device given Hub & Port
        I14RRTResetHubPort    EQU  2Ah ;Reset Device given Hub & Port
        I14RRTSuspendHubPort  EQU  2Bh ;Suspend Device given Hub & Port
        I14RRTResumeHubPort   EQU  2Ch ;Resume Device given Hub & Port
        I14RRTPwrOnHubPort    EQU  2Dh ;Power On Device given Hub & Port
        I14RRTPwrOffHubPort   EQU  2Eh ;Power Off Device given Hub & Port
        I14RRTPwrResetHubPort EQU  2Fh ;Power Reset Device given Hub & Port
      I14RRTTPowerClass       EQU  30h ;Power Class
        I14RRTGetDvcPowerInfo EQU  31h ;Get Power Info for Device
        I14RRTGetHubPowerDraw EQU  32h ;Get Power Draw for Hub
        I14RRTPwrOnDevice     EQU  3Dh ;Power On Device given Dvc Addr
        I14RRTPwrOffDevice    EQU  3Eh ;Power Off Device given Dvc Addr
        I14RRTPwrResetDevice  EQU  3Fh ;Power Reset Device given Dvc Addr
      I14RRTDeviceClass       EQU  40h ;Device Class
        I14RRTGetDvcClassInfo EQU  41h ;Get Device Class Info
        I14RRTGetDvcVendInfo  EQU  42h ;Get Device Vendor Info
        I14RRTGetDvcStatus    EQU  43h ;Get Device Status
        I14RRTEnableDevice    EQU  48h ;Enable/Resume Device given Dvc Addr
        I14RRTDisableDevice   EQU  49h ;Disable Device given Dvc Addr
        I14RRTResetDevice     EQU  4Ah ;Reset Device given Dvc Addr
        I14RRTSuspendDevice   EQU  4Bh ;Suspend Device given Dvc Addr
        I14RRTResumeDevice    EQU  4Ch ;Resume Device given Dvc Addr
      I14RRTConfigClass       EQU  50h ;Configuration Class
        I14RRTConfigingIntf   EQU  51h ;Driver is Configuring an Interface
        I14RRTConfigIntfDone  EQU  52h ;Interface Configuration is Complete
        I14RRTSetNewConfig    EQU  58h ;Set/Change Device Config Value
      I14RRTInterfaceClass    EQU  60h ;Interface Class
        I14RRTFindRegIntf     EQU  62h ;Look for Registered Interface
        I14RRTFindUnRegIntf   EQU  63h ;Look for Unregistered Interface
        I14RRTRegIntfOwner    EQU  64h ;Register as Interface Owner
        I14RRTUnRegIntfOwner  EQU  65h ;Unregister as Interface Owner
        I14RRTIntfDontLook    EQU  68h ;Existing Interface Owner Don't Look
      I14RRTAltIntfClass      EQU  70h ;Alternate Interface Class
        I14RRTGetAltIntfInfo  EQU  71h ;Get Alternate Interface Info
      I14RRTEndPointClass     EQU  80h ;End Point Class
        I14RRTGetDataX        EQU  81h ;Get Current DataX Value
        I14RRTIncDataX        EQU  88h ;Increment/Toggle DataX Value
      I14RRTPacketClass       EQU  90h ;Packet Class
        I14RRTDoIsoch         EQU  94h ;Schedule Isochronous Transaction
        I14RRTDoInterruptPer  EQU  95h ;Schedule Periodic Interrupt
        I14RRTDoControl       EQU  96h ;Schedule Control/Setup Request
        I14RRTDoBulk          EQU  97h ;Schedule Bulk Transaction
        I14RRTDoInterrupt1T   EQU  98h ;Schedule One-Time Interrupt
        I14RRTCloseHandle     EQU  9Ch ;Close/Remove Scheduled Transaction
        I14RRTChangeIntPer    EQU  9Dh ;Change Periodicity of Interrupt
        I14RRTGetTransStatus  EQU  9Fh ;Get Status of Packet Transaction
      I14RRTMiscClass         EQU 0A0h ;Miscellaneous Class
        I14RRTLargeCallDone   EQU 0A1h ;Large (Complicated) Call Complete
        I14RRTBeepSpeaker     EQU 0AFh ;Beep the Speaker
      I14RRTInterHostClass    EQU 0E0h ;Inter-Host Communication Class
      I14RRTInternalClass     EQU 0F0h ;Host Internal/Troubleshooting Class
    I14RFlags                  DB   ?  ;Bit-level flags
      I14RFlagIn              EQU  01h ;In Direction
      I14RFlagLowSpeed        EQU  02h ;Low-Speed Device
      I14RFlagHiSpeed         EQU  04h ;High-Speed Device
      I14RFlagNoRetries       EQU  10h ;No Auto Retries for Control
      I14RFlagShortPktOK      EQU  20h ;No Retries for Short Packets
      I14RFlagSpecificFrame   EQU  40h ;Use Specific Frame Number
      I14RFlagAddrIsPhys      EQU  80h ;Data Address is Physical
    I14RHostIndex              DB   ?  ;Host Index
    I14RDeviceAddress          DB   ?  ;USB Device Address
      I14RHubAddress          EQU (OFFSET I14RDeviceAddress)
    I14REndPoint               DB   ?  ;EndPoint or Port or Alt Interface
      I14RHubPort             EQU (OFFSET I14REndPoint)
      I14RAltInterface        EQU (OFFSET I14REndPoint)
    I14RConfigValue            DB   ?  ;Configuration Value
      I14RCloseID             EQU (OFFSET I14RConfigValue)
      I14RDataX               EQU (OFFSET I14RConfigValue)
    I14RInterfaceNum           DB   ?  ;Interface Number
    I14RSearchIndex            DB   ?  ;Search Index
    I14RVendorID               DW   ?  ;Vendor ID
    I14RProductID              DW   ?  ;Product ID
    I14RDvcClass               DB   ?  ;Device Class
    I14RDvcSubClass            DB   ?  ;Device SubClass
    I14RDvcProtocol            DB   ?  ;Device Protocol
    I14RIntfClass              DB   ?  ;Interface Class
    I14RIntfSubClass           DB   ?  ;Interface SubClass
    I14RIntfProtocol           DB   ?  ;Interface Protocol
    I14RRequestHandle          DW   ?  ;Request Handle Number
    I14RPeriodicity            DW   ?  ;Interrupt Periodicity/Duration
      I14RBeepFrequency       EQU (OFFSET I14RPeriodicity)
    I14RTimeout                DW   ?  ;Transaction Time Out Value
    I14RDataAddress            DD   ?  ;Data Address
    I14RDataSize               DW   ?  ;Size of Data (Bytes)
    I14RCallBackAddr           DD   ?  ;Call Back Address (CS:IP format)
      I14RLargeCallRtnCode    EQU (OFFSET I14RCallBackAddr)
    I14RUserPktID              DW   ?  ;User Packet ID
    I14RSetupReqData           DQ   ?  ;Setup Request Data (8 bytes)
    I14RFrameTiming            DW   ?  ;Frame Timing Value (def = 12000)
      I14RFrameIndex          EQU (OFFSET I14RFrameTiming)
                                       ;Starting Frame of Isoch Schedule
    I14RIsochSchedAddr         DD   ?  ;Address of Isoch Schedule
    I14RFiller  DB (Int14RequestSize-$) DUP (0)

   ENDS

  ;----------------------------------------------------------------------------
  ;Device Request is a structure containing data required by a USB Setup Packet
  ;----------------------------------------------------------------------------
  SetupRequest           STRUC     ;Structure for a Standard Setup Pkt
    SRRequestType           DB  ?  ;Request Type
      SRRTOut              EQU 00h ;0=Out (Host to Device)
      SRRTIn               EQU 80h ;1=In (Device to Host)
      SRRTTypeMask         EQU 60h ;Mask for Type
        SRRTTypeStandard   EQU 00h ;Type 0 = Standard
        SRRTTypeClass      EQU 20h ;Type 1 = Class
        SRRTTypeVendor     EQU 40h ;Type 2 = Vendor
                                   ;Type 3 = Reserved
      SRRTRecipientMask    EQU 1Fh ;Mask for Recipient Type
        SRRTRecipDevice    EQU 00h ;Recipient Type 0 = Device
        SRRTRecipInterface EQU 01h ;Recipient Type 1 = Interface
        SRRTRecipEndPoint  EQU 02h ;Recipient Type 2 = EndPoint
        SRRTRecipOther     EQU 03h ;Recipient Type 3 = Other
                                   ;Types 4-31 = Reserved
    SRRequest               DB  ?  ;Specific Request
      SRRQGetStatus        EQU  0  ;Request  0 = Get Status
      SRRQClearFeature     EQU  1  ;Request  1 = Clear Feature
      SRRQGetState         EQU  2  ;Request  2 = Get State
      SRRQSetFeature       EQU  3  ;Request  3 = Set Feature
                                   ;Request  4 = Reserved
      SRRQSetAddress       EQU  5  ;Request  5 = Set Address
      SRRQGetDescriptor    EQU  6  ;Request  6 = Get Descriptor
      SRRQSetDescriptor    EQU  7  ;Request  7 = Set Descriptor
      SRRQGetConfig        EQU  8  ;Request  8 = Get Configuration
      SRRQSetConfig        EQU  9  ;Request  9 = Set Configuration
      SRRQGetAltInterface  EQU 10  ;Request 10 = Get Alternate Interface
      SRRQSetAltInterface  EQU 11  ;Request 11 = Set Alternate Interface
      SRRQSynchFrame       EQU 12  ;Request 12 = Synch Frame
    SRValue                 DW  ?  ;Value depends on Request Type
    SRIndex                 DW  ?  ;Index depends on Request Type
      ;If EndPoint,  Bits 3:0 = EndPoint Number
      ;              Bit    7 = 1 if IN EndPoint, 0 if OUT EndPoint
      ;              All other bits are 0
      ;If Interface, Bits 7:0 = Interface Number (low word)
      ;              All other bits are 0 (high word)
    SRLength                DW  ?  ;Length of Data (if there is Data)

   ENDS
  SetupRequestSize EQU TYPE (SetupRequest)

  ;----------------------------------------------------------------------------
  ;Format of data returned by a Get Device Descriptor
  ;----------------------------------------------------------------------------
  DeviceDescriptor   STRUC    ;Structure for a Device Descriptor
    DDLength            DB  ? ;Size of Descriptor in bytes
    DDDescType          DB DescrTypeDevice
    DDUSBRelease        DW  ? ;USB Compliance  bcd (0210h=v2.10)
    DDDvcClass          DB  ? ;Device Class (defined by USB-IF)
    DDDvcSubClass       DB  ? ;Device SubClass (defined by USB-IF)
    DDDvcProtocol       DB  ? ;Device Protocol (defined by USB-IF)
    DDMaxPktSize        DB  ? ;Max Packet Size for EndPoint 0
                              ;  MUST be 8, 16, 32, or 64
    DDVendorID          DW  ? ;Vendor ID (defined by USB-IF)
    DDProductID         DW  ? ;Product ID (defined by manufacturer)
    DDDeviceRelease     DW  ? ;Device Release Number (bcd)
    DDManufacturerIndx  DB  ? ;Index of Manufacturer String
    DDProductIndx       DB  ? ;Index of Product String
    DDSerialNumberIndx  DB  ? ;Index of Serial Number String
    DDNumConfigs        DB  ? ;Number of possible Configurations
   ENDS
  DeviceDescriptorSize EQU TYPE (DeviceDescriptor)

  ;----------------------------------------------------------------------------
  ;Format of data returned by a Get Configuration Descriptor
  ;----------------------------------------------------------------------------
  ConfigDescriptor     STRUC     ;Structure for a Config Descriptor
    CDLength              DB  ?  ;Size of Descriptor in bytes
    CDDescrType           DB DescrTypeConfig
    CDTotalLength         DW  ?  ;Total length of data returned for
                                 ;  this configuration (ALL data)
    CDNumInterfaces       DB  ?  ;Number of Interfaces in this Config
    CDConfigValue         DB  ?  ;Value to use in SetRequest to
                                 ;  set this configuration
    CDConfigurationIndx   DB  ?  ;Index of Configuration String
    CDAttributes          DB  ?  ;Configuration Attributes
      CDAttrBit7         EQU 80h ;Bit 7 must be set to 1
      CDAttrSelfPowered  EQU 40h ;Self Powered
      CDAttrRemoteWakeup EQU 20h ;Remote Wakeup Supported
      CDAttrBatteryPower EQU 10h ;Battery Powered
      ;Bits 3:0 = Reserved (0)
    CDMaxBusPower         DB  ?  ;Maximum Power Consumption FROM BUS
                                 ;  in 2mA units (*2 to get mA)
   ENDS
  ConfigDescriptorSize EQU TYPE (ConfigDescriptor)

  ;----------------------------------------------------------------------------
  ;Format of data returned by a Get Interface Descriptor
  ;----------------------------------------------------------------------------
  InterfaceDescriptor   STRUC     ;Structure for an Interface Descr
    IDLength               DB  ?  ;Size of Descriptor in bytes
    IDDescType             DB DescrTypeInterface
    IDInterfaceNumber      DB  ?  ;Interface Number (0-based Index)
    IDAlternateSetting     DB  ?  ;Value used to select this alternate
                                  ;  setting for the Interface Number
    IDNumEndPoints         DB  ?  ;Number of Interfaces, excl 0
    IDInterfaceClass       DB  ?  ;Interface Class (defined by USB-IF)
    IDInterfaceSubClass    DB  ?  ;Interface SubClass (def by USB-IF)
    IDInterfaceProtocol    DB  ?  ;Interface Protocol (def by USB-IF)
    IDInterfaceIndx        DB  ?  ;Index of Interface String
   ENDS
  InterfaceDescriptorSize EQU TYPE (InterfaceDescriptor)

  ;----------------------------------------------------------------------------
  ;Format of data returned by a Get EndPoint Descriptor
  ;----------------------------------------------------------------------------
  EndPointDescriptor    STRUC     ;Structure for an EndPoint Descr
    EDLength               DB  ?  ;Size of Descriptor in bytes
    EDDescrType            DB DescrTypeEndPoint
    EDEndPointNumber       DB  ?  ;EndPoint Number
      EDDirectionIn       EQU 80h ;Direction = In (Ignored in Control EP's)
      ;Bits 6:4 = Reserved (0)
      EDNumberMask        EQU 0Fh ;EndPoint Number (0-15)
    EDAttributes           DB  ?  ;EndPoint attributes
      ;Bits 7:6 = Reserved (0)
      EDUsageTypeMask     EQU 30h ;Bits 5:4 = Usage Type
      EDUsageTypeSft      EQU  4  ;Bits to Shift by
        EDAttrImplicitFB  EQU 20h ;2 = Implicit Feedback Data EndPoint
        EDAttrFeedback    EQU 10h ;1 = Feedback EndPoint
        EDAttrData        EQU 00h ;0 = Data EndPoint
      EDSynchTypeMask     EQU 0Ch ;Bits 3:2 = Synchronization Type
      EDSynchTypeSft      EQU  2  ;Bits to Shift By
        EDAttrSynch       EQU 0Ch ;3 = Synchronous
        EDAttrAdaptive    EQU 08h ;2 = Adaptive
        EDAttrAsynch      EQU 04h ;1 = Asynchronous
      EDAttrTransTypeMask EQU 03h ;Bits 1:0 = Transfer Type
        EDAttrInterrupt   EQU 03h ;3 = Interrupt
        EDAttrBulk        EQU 02h ;2 = Bulk
        EDAttrIsoch       EQU 01h ;1 = Isochronous
        EDAttrControl     EQU 00h ;0 = Control
    EDMaxPktSize           DW  ?  ;Max Packet Size EndPoint can handle
    EDPollInterval         DB  ?  ;Polling Interval for Data Transfers
    ;The following two bytes only appear in some Isochronous Applications
    EDRefreshRate          DB  ?  ;Refresh Rate (1-9, power of 2 mS)
    EDSynchEndPoint        DB  ?  ;Synchronization EndPoint
   ENDS
  EndPointDescriptorSize EQU TYPE (EndPointDescriptor)


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;MACROS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

  JUMP MACRO     ;Do a NEAR (SHORT) JMP instead of a Local JMP
    JMP SHORT #1
   #EM


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;TSR DATA
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;==============================================================================
;TSR Related
;==============================================================================

  ;------------------------------------------------------------------------------
  ;INT2F Data (this needs to be the first data at the top of the file)
  ;If the user does a "TYPE USBPRINT.COM" at the command line, this will
  ;  just show the program name and version, instead of sending all kinds of
  ;  annoying happy faces and BELs to the screen the way most programs do.
  ;This is also the same data that is used to test if the program is
  ;  already installed in memory.
  ;------------------------------------------------------------------------------
  NoType1:     DB               CR  ;To handle TYPE from command line
  ProgName:    DB        'USBPRINT' ;Program Name
  ProgNameLen EQU       $-ProgName  ;Length of name
  ProgVerTxt:  DB           ' 0.08' ;Program version in ASCII
  Author:      DB '  Bret Johnson' ;Authors name
  AuthorLen   EQU         $-Author  ;Length of Author
  NoType2:     DB              EOF  ;To handle TYPE from command line
  ProgVer      DW             0008h ;Program version as a word
  HandleNum    DB              0C0h ;TSR multiplex handle number

  ;------------------------------------------------------------------------------
  ;Miscellaneous Yes/No TSR Flags
  ;------------------------------------------------------------------------------
  TSRFlags         DB 00h ;Miscellaneous Yes/No Flags
    Int14ReqInUse EQU 01h ;Int 14 Request currently being used
    NoBeep        EQU 02h ;Don't Beep the Speaker
    NoParallel    EQU 04h ;Go ahead and "write over" parallel ports
    NoAutoEpson   EQU 08h ;Don't send Epson USB Init Strings Automatically
    NoBoundFix    EQU 10h ;Don't fix BOUND Bug
    RedirTblHere  EQU 20h ;We own the LPT Redirect Table


;==============================================================================
;Stack Related
;==============================================================================
  StackInUse DB 0 ;Counter to keep track of "setup stack" calls
  OldSS      DW ? ;Original Stack Segment
  OldSP      DW ? ;Original Stack Pointer
  TempBX     DW ? ;Temporary Storage for BX while setting up Stack
  TempFlags  DW ? ;Temporary Storage for Flags while setting up Stack


;==============================================================================
;Device Driver Related
;==============================================================================
  ;----------------------------------------------------------------------------
  ;LPTx Device Driver Headers for LPT1 - LPT9 & PRN
  ;----------------------------------------------------------------------------
  LPTxHeaders: DB (10 * LPTxHdrStrucSize) DUP (?)

  ;----------------------------------------------------------------------------
  ;Lookup Table to Convert Driver Request Command Codes to Code Offsets
  ;----------------------------------------------------------------------------
  DvcIntTable:
    DB RHCmdRead            ;Read (Input)
     DW DvcIntRead
    DB RHCmdInputStatus     ;Current Input Status
     DW DvcIntInputStatus
    DB RHCmdWrite           ;Write (Output)
     DW DvcIntWrite
    DB RHCmdWriteVerify     ;Write with Verification
     DW DvcIntWriteVerify
    DB RHCmdOutputStatus    ;Output Status
     DW DvcIntOutputStatus
    DB RHCmdOutputTilBusy   ;Output Until Busy
     DW DvcIntOutputTilBusy
    DB RHCmdGenIOCtlV3      ;Generic IOCtl DOS 3
     DW DvcIntGenIOCtlV3
    DB RHCmdGenIOCtlV4      ;Generic IOCtl DOS 4+
     DW DvcIntGenIOCtlV4
    DB RHCmdGenIOCtlCk      ;Generic IOCtl Check (DOS 5+)
     DW DvcIntGenIOCtlCk
   ;End of Table
    DB -1                   ;End of Table
     DW -1


;==============================================================================
;Printer Related
;==============================================================================

  ;------------------------------------------------------------------------------
  ;"Fake" I/O Address used to "reserve" Ports in the BIOS
  ;------------------------------------------------------------------------------
  IOAddress DW 0

  ;------------------------------------------------------------------------------
  ;String needed to initialize Epson USB Printers.
  ;This needs to be sent at the beginning of each Job to release the
  ;  USB Printer from "packet" mode.
  ;------------------------------------------------------------------------------
  EpsonInitStr:
    DB 0,0,0            ;3 NULs
    DB Escape, SOH
    DB '@EJL 1284.4',LF
    DB '@EJL     ',LF   ;5 Spaces
    DB Escape, '@'      ;This is the generic Epson "Reset Printer" command
  EpsonInitStrSize EQU $-EpsonInitStr


;==============================================================================
;Extended Printer Function Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Extended INT 17h Calls (this value in AL, 1Bh in AH)
  ;----------------------------------------------------------------------------
  I17ExtFuncTbl:
    DB  I17FInstallCheck    ;Installation Check
     DW InstallCheck
    DB  I17FJobStart        ;Start a New Print Job
     DW JobStart
    DB  I17FJobEnd          ;End an Existing Print Job
     DW JobEnd
    DB  I17FJobCancel       ;Cancel an Existing Print Job
     DW JobCancel
    DB  I17FGetRedirTblAddr ;Get Address of LPT Redirection Table
     DW GetRedirTblAddr
    DB  I17FRedirGoingAway  ;Program containing Redirect Table is disappearing
     DW RedirGoingAway
    DB  I17FGetPortRedir    ;Get Port Redirect Status
     DW GetPortRedirect
    DB  I17FSetPortRedir    ;Set Port Redirect Status
     DW SetPortRedirect
    DB  I17FGetDvcIDString  ;Get Device ID String
     DW GetDvcIDString
    DB  I17FTxBlock         ;Transmit (Send) a Block of Data
     DW TxBlock
    DB  I17FRxBlock         ;Receive a Block of Data
     DW RxBlock
    DB -1                   ;End of Table
     DW -1


;==============================================================================
;BOUND Fix Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;OpCode Prefixes that can be in front of a BOUND OpCode
  ;----------------------------------------------------------------------------
  OpCodePrefixTbl:
    DB OpCodeCS     ;CS: Override
    DB OpCodeDS     ;DS: Override
    DB OpCodeES     ;ES: Override
    DB OpCodeSS     ;SS: Override
    DB OpCodeFS     ;FS: Override
    DB OpCodeGS     ;GS: Override
    DB OpCodeOper32 ;32-bit Operand Override (e.g., BOUND EAX,[Word])
    DB OpCodeAddr32 ;32-bit Address Override (e.g., BOUND AX,[DWord])
    DB 0            ;End of Table


;==============================================================================
;Device Driver Related
;==============================================================================

  NULDvcHeader DD ? ;Memory Address of NUL Device Header
                    ;  (Always the first Device in the Driver Chain)


;==============================================================================
;USB Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Handle Number of New Device (Device 0) Registry
  ;----------------------------------------------------------------------------
  Reg0Handle DW -1

  ;----------------------------------------------------------------------------
  ;Int08 Countdown Timers
  ;----------------------------------------------------------------------------
  Int08Counter    DB 5 ;Countdown Timer to periodically check for new Devices
                       ;Initial Delay is 5 timer ticks (about 1/4 second)
                       ;Delays after initial one will be about 1 second
                       ;Setting to 0 Disables the program
  DontLookCounter DW 0 ;Countdown Timer to not Look for New Devices

  ;----------------------------------------------------------------------------
  ;Calls that the USB Host Driver can send to us after we're "registered"
  ;Our code is called with this function code in AX
  ;----------------------------------------------------------------------------
  OwnerCallFunctionTbl:
   ;Device Connect/Disconnect
    DB OwnerCallNewDvc        ;New Device Connected
     DW DeviceAdded
    DB OwnerCallDvcDisc       ;Existing Device Disconnected
     DW DeviceDisconnected
    DB OwnerCallDvc0Disc      ;Unregistered Device Disconnected
     DW Device0Disconnected
    DB OwnerCallDontLook      ;Don't Look for New Interface Temporarily
     DW StartDontLook
   ;Device Enable/Disable/Reset/Suspend/Resume/PwrOn/PwrOff/PwrReset
    DB OwnerCallDvcEnable     ;Device Enabled
     DW DeviceEnabled
    DB OwnerCallDvcDisable    ;Device Disabled
     DW DeviceDisabled
    DB OwnerCallDvcReset      ;Device Reset
     DW DeviceReset
    DB OwnerCallDvcSuspend    ;Device Suspend
     DW DeviceSuspend
    DB OwnerCallDvcResume     ;Device Resume
     DW DeviceResume
    DB OwnerCallDvcPwrOn      ;Device Power On
     DW DevicePowerOn
    DB OwnerCallDvcPwrOff     ;Device Power Off
     DW DevicePowerOff
    DB OwnerCallDvcPwrReset   ;Device Power Reset
     DW DevicePowerReset
   ;Host Connect/Disconnect
    DB OwnerCallNewHost       ;New Host has been Added
     DW NewHostAdded
    DB OwnerCallHostDisc      ;Existing Host Disconnected
     DW HostDisconnected
    DB OwnerCallHostHWErr     ;Host System/Processor Error
     DW HostHWErr
   ;Host Run/Stop/Reset/Suspend/Resume/Debug/SingleStep
    DB OwnerCallHostRun       ;Host Running
     DW HostRun
    DB OwnerCallHostStop      ;Host Stopped
     DW HostStop
    DB OwnerCallHostReset     ;Host Reset
     DW HostReset
    DB OwnerCallHostSuspend   ;Host Suspended
     DW HostSuspend
    DB OwnerCallHostResume    ;Host Resumed
     DW HostResume
    DB OwnerCallHostDebug     ;Host in Debug Mode
     DW HostDebug
    DB OwnerCallHostSST       ;Host Single-Stepped
     DW HostSST
   ;Timing Changes
    DB OwnerCallTimingChg     ;Host Timing Changed
     DW TimingChange
   ;Upstream Device Changes
    DB OwnerCallDvcDiscUS     ;Device Disconnect Upstream
     DW DeviceDisconnectedUS
    DB OwnerCallDvcEnableUS   ;Device Enable Upstream
     DW DeviceEnabledUS
    DB OwnerCallDvcDisableUS  ;Device Disable Upstream
     DW DeviceDisabledUS
    DB OwnerCallDvcResetUS    ;Device Reset Upstream
     DW DeviceResetUS
    DB OwnerCallDvcSuspendUS  ;Device Suspend Upstream
     DW DeviceSuspendUS
    DB OwnerCallDvcResumeUS   ;Device Resume Upstream
     DW DeviceResumeUS
    DB OwnerCallDvcPwrOnUS    ;Device Power On Upstream
     DW DevicePowerOnUS
    DB OwnerCallDvcPwrOffUS   ;Device Power Off Upstream
     DW DevicePowerOffUS
    DB OwnerCallDvcPwrResetUS ;Device Power Reset Upstream
     DW DevicePowerResetUS
   ;End of Table
    DB -1                     ;End of Table
     DW -1

  ;----------------------------------------------------------------------------
  ;Table to keep track of individual Devices
  ;----------------------------------------------------------------------------
  EVEN 2
  DeviceInfoTable:
    DB (MaxDevices*DeviceInfoStrucSize) DUP (0)

  ;----------------------------------------------------------------------------
  ;Table to keep track of "bad" (incompatible) Devices.
  ;This table will keep track of Host Indexes and Address of incompatible
  ;  Devices that we find.
  ;If we don't keep track of them, we will get caught in an endless
  ;  loop of looking at the bad one every time we check (if it happens
  ;  to be the first one), and will never skip over it and be
  ;  able to find a "good" (compatible) Device.
  ;----------------------------------------------------------------------------
  EVEN 2
  BadDeviceTable:
    DB (MaxBadDevices*BadDeviceStrucSize) DUP (0)

  ;----------------------------------------------------------------------------
  ;Table to keep track of Block Transfer Timeouts
  ;----------------------------------------------------------------------------
  EVEN 2
  BlockTimeoutTable:
    DB (NumBlockTimeouts * BlockTimeoutStrucSize) DUP (0)

  ;----------------------------------------------------------------------------
  ;Offset in InfoTable of Last Device we found (needed to print Descriptors)
  ;----------------------------------------------------------------------------
  LastDeviceFound DW DeviceInfoTable

  ;----------------------------------------------------------------------------
  ;Stage & Error Code where New Device search failed (for troubleshooting)
  ;For even stages < 200, the Error is a TD Status Error Code.
  ;  These are the ones generally caused by Devices that don't respond
  ;  like they're expected to.
  ;For odd stages < 200, the Error is an INT 14h Call Error Code.
  ;  These are generally cause by faulty code, and should not appear
  ;  in final, bug-less release of the program.
  ;For stages >= 200, the "Error" is not related to an INT 14h or TD at all.
  ;  These are other kinds of Errors, usually caused by a value in one
  ;    of the Descriptors that we don't undertand how to handle.  The
  ;    "Error Code" in these instances is usually meaningless.
  ;Categorizing the Error Codes like this allows us to easily write a more
  ;  complete and meaningful description of the Bad Device Error.  It is
  ;  still necessary to look at the source code to REALLY figure out what's
  ;  going on, but the information provided is better than just writing
  ;  the raw Error Code numbers.
  ;----------------------------------------------------------------------------
  NewDeviceStage DB ?
  NewDeviceError DW ?

  ;----------------------------------------------------------------------------
  ;Data Structures needed to issue Requests to the USB Host
  ;----------------------------------------------------------------------------
  EVEN 2
  Int14Request:
    DB Int14RequestSize DUP (0)
  Int14Request2:
    DB Int14RequestSize DUP (0)

  ;----------------------------------------------------------------------------
  ;Storage Area for Data returned by USB Descriptors and Reports
  ;----------------------------------------------------------------------------
  DvcDescrData:
    DB DeviceDescriptorSize DUP (?) ;Device Descriptor Data
  DescriptorData:
    DB MaxDescriptorSize    DUP (?) ;Cfg/Intf/EP Descriptor Data

  ;----------------------------------------------------------------------------
  ;Table to keep track of Printer Redirections
  ;0 In Table is empty Entry, Non-Zero = Redirected to LPTx
  ;----------------------------------------------------------------------------
  EVEN 2
  RedirectTable:
    DB MaxPrinters DUP (0)
  ;RedirectTable2:
  ;  DB MaxPrinters DUP (0) ;Backup while assigning ports

  ;----------------------------------------------------------------------------
  ;Table of Buffers to queue data being sent to the printers
  ;----------------------------------------------------------------------------
  EVEN 2
  BufferTable:
    DB (NumBuffers*BufferStrucSize) DUP (0)


;==============================================================================
;USB Printer-Class-Specific Control Requests
;==============================================================================
  EVEN 2

  ;----------------------------------------------------------------------------
  ;Get Device ID
  ;----------------------------------------------------------------------------
  GetDvcIDReq:
    DB SRRTIn+SRRTTypeClass+SRRTRecipInterface
    DB SRRQGetDeviceID
    DB ?   ;0-based Configuration Index
    DB 0
    DB ?   ;Alternate Interface Setting
    DB ?   ;Interface Number
    DW (DvcIDBufferSize-1)

  I14RGetDvcIDCfgIndex EQU I14RSetupReqData.SRValue[0] ;Byte
  I14RGetDvcIDAltIntf  EQU I14RSetupReqData.SRIndex[0] ;Byte
  I14RGetDvcIDIntf     EQU I14RSetupReqData.SRIndex[1] ;Byte
  I14RGetDvcIDSize     EQU I14RSetupReqData.SRLength   ;Word

  ;----------------------------------------------------------------------------
  ;Get Port Status
  ;----------------------------------------------------------------------------
  GetPortStatusReq:
    DB SRRTIn+SRRTTypeClass+SRRTRecipInterface
    DB SRRQGetPortStatus
    DW 0
    DB ?  ;0-based Interface Number
    DB 0
    DW 1  ;Byte is compatible with PC Parallel Port status
          ;  (Bit 3=NotError, 4=Selected, 5=PaperEmpty)

  I14RGetPortStatusIntf EQU I14RSetupReqData.SRIndex[0] ;Byte

  ;----------------------------------------------------------------------------
  ;Soft Reset
  ;----------------------------------------------------------------------------
  SoftResetReq:
    DB SRRTOut+SRRTTypeClass+SRRTRecipInterface
    DB SRRQSoftReset
    DW 0
    DB ?  ;0-based Interface Number
    DB 0
    DW 0

  I14RSoftResetIntf EQU I14RSetupReqData.SRIndex[0] ;Byte


;==============================================================================
;USB General-Purpose Control Requests
;==============================================================================
  EVEN 2

  ;----------------------------------------------------------------------------
  ;Get Device Descriptor
  ;----------------------------------------------------------------------------
  GetDvcDescrReq:
    DB SRRTIn+SRRTTypeStandard+SRRTRecipDevice
    DB SRRQGetDescriptor
    DB 0
    DB DescrTypeDevice
    DW 0
    DW DeviceDescriptorSize

  ;----------------------------------------------------------------------------
  ;Get Configuration Descriptor
  ;----------------------------------------------------------------------------
  GetCfgDescrReq:
    DB SRRTIn+SRRTTypeStandard+SRRTRecipDevice
    DB SRRQGetDescriptor
    DB 0 ;Configuration Value to Get (always 0?)
    DB DescrTypeConfig
    DW 0
    DW ConfigDescriptorSize ;Size will change for a Complete Config

  I14RGetCfgDescrValue EQU I14RSetupReqData.SRValue[0] ;Byte
  I14RGetCfgDescrSize  EQU I14RSetupReqData.SRLength   ;Word

  ;----------------------------------------------------------------------------
  ;Set Alternate Interface
  ;----------------------------------------------------------------------------
  SetAltIntfReq:
    DB SRRTOut+SRRTTypeStandard+SRRTRecipInterface
    DB SRRQSetAltInterface
    DB ? ;Alternate Value to set Interface to
    DB 0
    DB ? ;Interface to Set
    DB 0
    DW 0

  I14RSetAltIntfAltIntf EQU I14RSetupReqData.SRValue[0] ;Byte
  I14RSetAltIntfIntf    EQU I14RSetupReqData.SRIndex[0] ;Byte


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;TSR CODE
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

LastTSRDataByte: ;Last byte of TSR Data, First Byte of Code


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO HANDLE INT 2Fh (TSR Multiplex)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HAVE INTERRUPT 2Fh RUN THIS PROGRAM EVERY TIME IT OCCURS
;Inputs:  CS = TSR Data Area
;         AH = Function (Handle) number, C0h-FFh
;         AL = Subfunction number
;         (If MuxGetProgName): DI = 0
;Outputs: (AL = MuxInstallChk):  AL = FFh if installed
;         (AL = MuxGetProgName): ES:[DI] = Pointer to ProgName
;         (AL = MuxGetProgVer):  AX = ProgVer (Program version number, AH=Major)
;         (AL = MuxGetAuthor):   ES:[DI] = Pointer to Author
;Changes:
;------------------------------------------------------------------------------
Int2FHdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int2F:
  STI                               ;Enable Interrupts
  CMP  AH,CS:HandleNum              ;Is this our handle?
  JE   Int2FInstall                 ;If so, jump to handle it
  CMP  W CS:Int2FHdr.OldVector[2],0 ;Is the Old Vector valid?
  JE   Int2FDone                    ;If not, handle it
  JMP  D CS:Int2FHdr.OldVector      ;If so, go to the next one in the chain
Int2FDone:                          ;Invalid vector before us
  IRET

Int2FInstall:
  CMP  AL,MuxInstallChk ;Is it Install Check?
  JNZ  Int2FProgName    ;If not, try the next possibility
  MOV  AL,-1            ;Mark the flag byte
  IRET

Int2FProgName:
  CMP  AL,MuxGetProgName ;Is it Get Program Name?
  JNE  Int2FProgVer      ;If not, try the next possibility
  OR   DI,DI             ;Does DI = 0?
  JNZ >N90               ;If not, it's not for us
  MOV  ES,CS             ;If so, point ES:[DI]
  MOV  DI,ProgName       ;  at ProgName
N90:                     ;Done
  IRET

Int2FProgVer:
  CMP  AL,MuxGetProgVer ;Is it Get Program Version?
  JNE  Int2FAuthor      ;If not, try the next one
  MOV  AX,CS:ProgVer    ;If so, do it
  IRET

Int2FAuthor:
  CMP  AL,MuxGetAuthor ;Is it Get Author?
  JNE >A90             ;If not, we're done
  MOV  ES,CS           ;If so, point ES:[DI]
  MOV  DI,Author       ;  at Author
A90:                   ;Done
  IRET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO LOOK FOR NEW USB DEVICES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;CHECK AND SEE IF THERE IS A NEW DEVICE CONNECTED, AND HANDLE IT IF IT IS
;Inputs:  DS = ES = Our Data Area
;         CLD already issued
;Outputs:
;Changes: Looks for new, unowned (unconfigured) Devices
;         If one is found, it is Configured and pointed at us
;NOTES:   When we first install this program into memory, we Registered with
;           the USB Drivers that we wanted to be informed as soon as a new
;           Device was attached.  We also poll the hosts periodically for a
;           new Device, just in case we somehow missed the Host informing us.
;         Whether this is in response to the Host telling us, or whether we
;           polled to find out, this section of code is called.
;         This section of code is actually a series of short pieces of code,
;           which are disjointed in time.  One section schedules a USB Request
;           with the Host Driver, and gives the Host Driver the address
;           of the NEXT section of code to perform when the Request is
;           completed.
;         Requests sent to a USB Host can take anywhere from a few
;           milliseconds to several hundred milliseconds to complete.
;         It is very bad for a TSR to just sit around waiting for something
;           to happen, especially when it can be a long time in coming.
;         This back-and-forth approach between the Host Driver and the Device
;           Driver makes the TSR run pretty efficiently.
;------------------------------------------------------------------------------
LookForNewDevice:
  CALL FindEmptyInfoBX              ;Look for an empty Info Table Entry (BX)
  JZ  >L90                          ;If none, just quit
  TEST TSRFlags,Int14ReqInUse       ;Is the Request Structure already in use?
  JNZ >L90                          ;If so, just quit
  OR   TSRFlags,Int14ReqInUse       ;If not, mark it as in use now
  MOV  SI,Int14Request              ;Point at our Int 14 Structure
  CALL FindUnRegDevice              ;Any Unregistered Devices?
                                    ;Rtns CL=Host, CH=Addr, DL=Intf, DH=AltIntf
  JZ  >L80                          ;If none, quit
L20:                                ;Found a possible Device!
  MOV  [SI].I14RRequestType,I14RRTConfigingIntf ;Request Type = Configing
  MOV  W [SI].I14RHostIndex,CX      ;Store Host Index & Device Address
  CALL DoInt14CallSaveAllSI         ;Do it
  JNC >L30                          ;If OK, continue
  MOV  Int08Counter,2               ;If not, Look again Soon
  JMP >L80                          ;Done for now
L30:                                ;OK to Configure Interface
  MOV  NewDeviceStage,0             ;Stage
  MOV  NewDeviceError,0             ;  Zero
  OR   [BX].DIFlags,DIFlagInUse     ;Mark Info Table entry as in use
  MOV  W [BX].DIHostIndex,CX        ;Store Host Index & Device Address
  MOV  W [BX].DIInterfaceNum,DX     ;Store Interface & Alternate Interface
  MOV  [SI].I14RUserPktID,BX        ;Set User Pkt ID to Info Table Offset
  MOV  [SI].I14RRequestType,I14RRTDoControl ;Request Type = Control
  MOV  [SI].I14RInterfaceNum,DL     ;Store Interface Number
  MOV  [SI].I14REndPoint,0          ;EndPoint 0
  MOV  CX,SetAltIntfReq             ;Copy
  CALL CopySetupReqToInt14SI        ;  Request Pkt
  MOV  B [SI].I14RSetAltIntfIntf,DL          ;Store Interface in Request
  MOV  B [SI].I14RSetAltIntfAltIntf,DH       ;Store Alt Interface in Request
  MOV  W [SI].I14RCallBackAddr[0],AltIntfSet ;Go here when done
  OR   [SI].I14RFlags,I14RFlagNoRetries ;No retries
  CALL DoInt14CallAXSI              ;Do it
  JNC >L90                          ;If it worked, we're done
  MOV  NewDeviceStage,1             ;Update Stage
  CALL FinishUpBadDevice            ;If not, mark it as bad
  JMP >L90                          ;Done
L80:                                ;No New Devices
  AND  TSRFlags,(NOT Int14ReqInUse) ;Mark the request as available
L90:                                ;Done
  RET                               ;NOT RETF here!

;------------------------------------------------------------------------------
;Inputs: [BX] = Info Table Pointer
;NOTE: Some Devices will not accept a Set Alternate Interface Request,
;        so an error here does not necessarily indicate a bad Device!
;------------------------------------------------------------------------------
AltIntfSet:
  MOV  NewDeviceStage,10     ;Update Stage
  MOV  SI,Int14Request       ;Point at Int14 Request Struc
  AND  [SI].I14RFlags,(NOT I14RFlagNoRetries) ;Allow retries again
  CMP  [BX].DIAltInterface,0 ;Are we dealing with Alt Interface 0?
  JE  >I10                   ;If so, no need to check for error
  OR   AX,AX                 ;If not, did it work?
  JNZ >I70                   ;If not, Error
I10:                         ;Alt Interface set correctly
  CALL ClearDescriptorData   ;Clear out the data buffer
  MOV  CX,GetDvcDescrReq     ;Copy
  CALL CopySetupReqToInt14SI ;  Request Pkt
  MOV  W [SI].I14RDataAddress[0],DvcDescrData    ;Put data here
  MOV  W [SI].I14RCallBackAddr[0],GotDeviceDescr ;Go here when done
  CALL DoInt14CallAXSI       ;Do it
  JNC >I90                   ;If it worked, we're done
  MOV  NewDeviceStage,11     ;Update Stage
I70:                         ;Error
  CALL FinishUpBadDevice     ;Mark it as Bad
I90:                         ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Info Table Pointer
;------------------------------------------------------------------------------
GotDeviceDescr:
  MOV  NewDeviceStage,20     ;Update Stage
  JNZ >D70                   ;If Error, handle it
  MOV  SI,Int14Request       ;Point at Int14 Request Structure
  MOV  CX,GetCfgDescrReq     ;Copy
  CALL CopySetupReqToInt14SI ;  Request Pkt
  MOV  W [SI].I14RDataAddress[0],DescriptorData  ;Put data here
  MOV  W [SI].I14RCallBackAddr[0],GotConfigDescr ;Go here when done
  CALL DoInt14CallAXSI       ;Do it
  JNC >D90                   ;If it worked, we're done
  MOV  NewDeviceStage,21     ;Update Stage
D70:                         ;Error
  CALL FinishUpBadDevice     ;Mark it as Bad
D90:                         ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Info Table Pointer
;------------------------------------------------------------------------------
GotConfigDescr:
  MOV  NewDeviceStage,30     ;Update Stage
  JNZ >O70                   ;If Error, handle it
  MOV  NewDeviceStage,31     ;Update Stage
  MOV  DI,DescriptorData     ;Point at Config Descriptor Data
  MOV  SI,Int14Request       ;Point at Int14 Request Structure
  MOV  AX,[DI].CDTotalLength ;Get length of entire Descriptor
  CMP  AX,MaxDescriptorSize  ;Will it fit in our buffer?
  JAE >O70                   ;If not, error
  MOV  CX,GetCfgDescrReq     ;Copy
  CALL CopySetupReqToInt14SI ;  Request Pkt
  MOV  W [SI].I14RGetCfgDescrSize,AX ;Store the number of bytes
  MOV  W [SI].I14RCallBackAddr[0],GotCompleteConfig ;Go here when done
  CALL ClearDescriptorData   ;Clear out the data buffer
  CALL DoInt14CallAXSI       ;Do it
  JNC >O90                   ;If it worked, we're done
  MOV  NewDeviceStage,32     ;Update Stage
O70:                         ;Error
  CALL FinishUpBadDevice     ;Mark it as Bad
O90:                         ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Info Table Pointer
;------------------------------------------------------------------------------
GotCompleteConfig:
  MOV  NewDeviceStage,40                 ;Update Stage
  JNZ >C70                               ;If Error, handle it
  MOV  NewDeviceStage,200                ;Update Stage
  MOV  DI,DescriptorData                 ;Point at Cfg Descr Data
  MOV  CX,W [BX].DIInterfaceNum          ;Intf (CL) & AltIntf (CH) to look for
C10:                                     ;Loop to find Interface Descriptor
  MOV  AL,DescrTypeInterface             ;Look for an Interface
  CALL FindDescrType                     ;  Descriptor (rtns AX, DI)
  JC  >C70                               ;If none found, Error
  CMP  W [DI].IDInterfaceNumber,CX       ;Correct Interface & Alt Interface?
  JE  >C20                               ;If so, continue
  ADD  DI,AX                             ;If not, point at the next Descr
  JMP  C10                               ;Keep looking
C20:                                     ;Found the Interface Descriptor
  MOV  NewDeviceStage,201                ;Update Stage
  MOV  AL,DescrTypeEndPoint              ;Look for an End Point
  CALL FindDescrType                     ;  Descriptor (rtns AX, DI)
  JC  >C70                               ;If none found, Error
C30:                                     ;Pointed at EndPoint Descr
  MOV  NewDeviceStage,202                ;Update Stage
  MOV  AL,[DI].EDEndPointNumber          ;Get EP Address & Direction
  MOV  SI,(OFFSET DIEndPointOut)         ;Assume it's Out
  TEST AL,EDDirectionIn                  ;Is it In?
  JZ  >C35                               ;If not, continue
  DEC  SI                                ;It's In
C35:                                     ;BP contains Direction Info
  AND  AL,EDNumberMask                   ;Store the
  MOV  [BX+SI],AL                        ;  EndPoint Number
;  ADD  DI,EndPointDescriptorSize         ;Go to the Next Descriptor
  XOR  AH,AH                             ;Go to
  MOV  AL,[DI].EDLength                  ;  the next
  ADD  DI,AX                             ;  Descriptor
  CMP  [DI].DDDescType,DescrTypeEndPoint ;Is it another EndPoint Descr?
  JE   C30                               ;If so, get it's Info
  CMP  [BX].DIEndPointOut,0              ;Get a valid Out EndPoint?
  JE  >C70                               ;If not, Error
  MOV  LastDeviceFound,BX                ;Mark this as the Last Device
  MOV  SI,Int14Request                   ;Point at Int 14 Req Struc
  MOV  [SI].I14RRequestType,I14RRTRegIntfOwner    ;Register as Owner
  MOV  W [SI].I14RCallBackAddr[0],DvcOwnerFarCall ;Owner Address
  CALL DoInt14CallAXCXSI                 ;Do it
  MOV  [BX].DIRegHandle,CX               ;Store the Registry Handle
  JNC >C80                               ;If it worked, we're done
  MOV  NewDeviceStage,41                 ;Update Stage
C70:                                     ;Error (DX contains orig BX)
  CALL FinishUpBadDevice                 ;Mark it as Bad
  JMP >C90                               ;Done
C80:                                     ;Device is OK
  CALL AssignLPTNum                      ;Assign LPT Number to the Device
  CALL TestEpson                         ;Test to see if it's an Epson
  MOV  [SI].I14RRequestType,I14RRTConfigIntfDone ;Request = Done Configuring
  CALL DoInt14CallSaveAllSI              ;Do it
  CMP  Int08Counter,0                    ;Disabled?
  JE  >C85                               ;If so, quit
  MOV  Int08Counter,2                    ;Look for another Device soon
C85:                                     ;Done for now
  AND  TSRFlags,(NOT Int14ReqInUse)      ;Mark the request as available
C90:                                     ;Done
  RETF


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT FUNCTIONS NEEDED BY LOOKFORNEWDEVICE PROCESS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;FINISH UP A BAD DEVICE ENTRY
;Inputs:  BX = Info Table Offset
;         (Info Table Entry contains Device Data)
;         DS = ES = TSR Data Area
;         Int14Request (contains Host/Address/Interface Data)
;Outputs: Resets DeviceInfoTable Entry
;         Marks Int14Request as available (not in use any more)
;         Updates NewDeviceStage & NewDeviceError
;         Puts Device info in BadDevice Table
;         Issues Request to Beep the Speaker
;Changes: DI,SI
;------------------------------------------------------------------------------
FinishUpBadDevice:
  MOV  SI,Int14Request              ;Point at Int14 Request Structure
  MOV  NewDeviceError,AX            ;Store Error Code
  CALL ResetDvcEntryBX              ;Reset the Dvc Info Entry that we Reserved
  MOV  [SI].I14RRequestType,I14RRTGetDvcStatus ;Request = Get Dvc Status
                                               ;(Make sure Device is still
                                               ;  plugged in)
  CALL DoInt14CallSaveAllSI         ;Issue the Request
  JC  >B10                          ;If error (no Device), don't add to Bad Tbl
  CALL AddBadDevice                 ;Add it to Bad Table
B10:                                ;Bad Device added to table, if appropriate
  TEST TSRFlags,NoBeep              ;Are we allowed to Beep the Speaker
  JNZ >B20                          ;If not, skip down
  MOV  [SI].I14RRequestType,I14RRTBeepSpeaker ;Want to beep the Speaker
  MOV  [SI].I14RHostIndex,-1        ;Any Host
  MOV  [SI].I14RTimeout,3           ;Beep length = 3 DeciSeconds
  MOV  W [SI].I14RBeepFrequency,300 ;Frequency = 300Hz
  CALL DoInt14CallSaveAllSI         ;Do it
  MOV  [SI].I14RTimeOut,0           ;Reset Timeout Value
B20:                                ;Done Handling Beep
  MOV  [SI].I14RRequestType,I14RRTConfigIntfDone ;Request = Done Configuring
  CALL DoInt14CallSaveAllSI         ;Do it
  CMP  Int08Counter,0               ;Disabled?
  JE  >B90                          ;If so, Done
  MOV  Int08Counter,2               ;Look for another Device soon
B90:                                ;Done
  AND  TSRFlags,(NOT Int14ReqInUse) ;Mark the request as available
  RET

;------------------------------------------------------------------------------
;CLEAR OUT THE OLD DATA FROM THE DESCRIPTOR DATA BUFFER
;Inputs:  ES = TSR Data Area
;         CLD already issued
;Outputs:
;Changes: DescriptorData becomes all zeroes
;------------------------------------------------------------------------------
ClearDescriptorData:
  PUSH AX,CX,DI                 ;Save used registers
  MOV  DI,DescriptorData        ;Point at buffer
  MOV  CX,(MaxDescriptorSize/2) ;Number of words to write
  XOR  AX,AX                    ;Write zeroes
  REP  STOSW                    ;Do it
  POP  DI,CX,AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND A PARTICULAR TYPE OF DESCRIPTOR IN THE COMPLETE CONFIGURATION DESCRIPTOR
;Inputs:  DS = ES = TSR Data Area
;         [DI] = Pointer to start/middle of Configuration Descriptor
;          AL  = Descriptor Type to find
;Outputs: CF = Set if OK (Descriptor Found)
;              [DI] points at beginning of Descriptor
;               AX = Descriptor Length
;            = Clear if Error (Descriptor not found)
;              AX, DI unchanged
;Changes:
;------------------------------------------------------------------------------
FindDescrType:
  PUSH BX,SI              ;Save used registers
  MOV  SI,DI              ;Point SI at the starting Pointer
  XOR  BH,BH              ;Initialize high byte of Size to 0
Y10:                      ;Loop here to find Descriptor
  MOV  BL,[SI].DDLength   ;Put the Length in BL
  OR   BL,BL              ;Valid Descriptor?
  JZ  >Y70                ;If not, Error
  CMP  AL,[SI].DDDescType ;The Descriptor we're looking for?
  JE  >Y80                ;If so, we're done
  ADD  SI,BX              ;If not, point at next Descriptor
  CMP  SI,(DescriptorData+MaxDescriptorSize) ;Gone past the end of the buffer?
  JBE  Y10                ;If not, keep looking
Y70:                      ;Error
  STC                     ;Set Error Flag
  JMP >Y90                ;Done
Y80:                      ;OK
  MOV  DI,SI              ;Update Pointer
  MOV  AX,BX              ;Put length in AX
  CLC                     ;Set OK Flag
Y90:                      ;Done
  POP  SI,BX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHECK AND SEE IF THERE ARE ANY UNREGISTERED DEVICES
;Inputs:  DS = ES = TSR Data Area
;         [SI] = Int 14 Request Structure (mostly filled in already)
;         BadDeviceTable
;Outputs: ZF = Clear if OK (Found an Unregistered Device)
;              CL = Host Index
;              CH = Device Address
;              DL = Interface
;              DH = Alternate Interface
;            = Set if Error (No Unregistered Devices found)
;              CX = DX = 0
;Changes: Contents of [SI]
;------------------------------------------------------------------------------
FindUnRegDevice:
  MOV  [SI].I14RRequestType,I14RRTFindUnRegIntf ;Request = Find UnReg Interface
  MOV  [SI].I14RHostIndex,-1 ;Any/All Hosts
  MOV  [SI].I14RIntfProtocol,IntfProtocolBiDir ;Start with BiDirectional
  CALL FindUnRegDeviceGo     ;Any Devices?
  JNC >U90                   ;If so, we're done
  MOV  [SI].I14RIntfProtocol,IntfProtocolUniDir ;Do UniDirectional
  CALL FindUnRegDeviceGo     ;Any Devices?
  JNC >U90                   ;If so, we're done
U70:                         ;Error
  XOR  CX,CX                 ;Set Error
  XOR  DX,DX                 ;  registers
U90:                         ;Done
  OR   CX,CX                 ;Set return flag
  RET

FindUnRegDeviceGo:
  MOV  [SI].I14RSearchIndex,0 ;Start with Search Index 0
G10:                          ;Loop tohere for each Search Index
  CALL DoInt14CallCXDXSI      ;Do it (CL=Host, CH=Addr, DL=Intf, DH=AltIntf)
  JC  >G90                    ;If none found, quit
  CALL TestBadDevice          ;If one there, is it a Bad Device?
  JNC >G90                    ;If not, we've got a new Device
  INC  [SI].I14RSearchIndex   ;If so, Increment the Search Index
  JMP  G10                    ;Keep looking
G90:                          ;Done
  RET

;------------------------------------------------------------------------------
;ASSIGN AN LPT NUMBER TO A DEVICE
;Inputs:  DS = ES = TSR Data Area
;         [BX] = Device Info Table entry
;         CLD already issued
;Outputs: Sets [BX].DILPTNum as appropriate (0 if no Indexes available)
;         Saves original I/O Address, if necessary
;Changes:
;------------------------------------------------------------------------------
AssignLPTNum:
  PUSH AX,BX,CX,DX,DI,SI,ES   ;Save used registers
  MOV  SI,BX                  ;Point SI at Device Info Entry
  MOV  [SI].DILPTNum,0        ;Make sure LPT Number is 0!
  MOV  DI,0040h               ;Point ES at the
  MOV  ES,DI                  ;  BIOS Data Area
  XOR  DX,DX                  ;Start with
  MOV  DI,8                   ;  LPT1
L10:                          ;Loop to here for each parallel port entry
  CALL TestDXIsOursDS         ;Is it one of our Ports (rtns ZF/BX)?
  JNZ >L20                    ;If so, we can't use it
  CALL TestDXInUseNoRedir     ;Index already in use?
  JZ  >L40                    ;If not, use it
  TEST TSRFlags,NoParallel    ;Allowed to overwrite parallel addresses?
  JZ  >L20                    ;If not, we can't use it
  CMP  DL,2                   ;Address in BIOS Data Area (LPT1-LPT3)?
  JA  >L20                    ;If not, we can't use it
  PUSH DX                     ;Save Index
  MOV  DX,ES:[DI]             ;Is it a
  CALL TestIOAddrReal         ;  Real I/O Address?
  POP  DX                     ;Restore Index
  JNZ >L40                    ;If a Real I/O Address, use it
L20:                          ;Can't use this Index
  INC  DX                     ;Increment LPT Index Number
  INC  DI,2                   ;Point at next LPT BIOS Number
  CMP  DX,(MaxPrinters-1)     ;Done with valid Indexes yet?
  JBE  L10                    ;If not, continue testing
  JMP >L90                    ;If we've tested all Indexes, done!
L40:                          ;Use this Index (DX)
  CMP  DL,2                   ;Index in BIOS Data Area?
  JA  >L50                    ;If not, don't mess with I/O Addresses
  MOV  AX,ES:[DI]             ;Save the
  MOV  [SI].DIOldIOAddress,AX ;  old I/O Address
  MOV  AX,DX                  ;Set the
  MOV  CL,3                   ;  new
  SHL  AX,CL                  ;  (fake)
  ADD  AX,IOAddress           ;  I/O
  MOV  ES:[DI],AX             ;  address
L50:                          ;Done messing with the BIOS
  INC  DX                     ;Store the
  MOV  [SI].DILPTNum,DL       ;  LPT Number
L90:                          ;Done
  POP  ES,SI,DI,DX,CX,BX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A PRINTER IS MADE BY EPSON
;Inputs:  DS = ES = TSR Data Area
;         [BX] = Device Info Table entry
;         CLD already issued
;Outputs: Sets DIFlagIsEpson (if appropriate)
;Changes:
;------------------------------------------------------------------------------
TestEpson:
  PUSH AX,SI                                 ;Save used registers
  MOV  SI,DvcDescrData                       ;Point at Descriptor Data
  CMP  [SI].DDVendorID,EpsonVendorID         ;Is the Vendor Seiko Epson?
  JNE >P90                                   ;If not, quit
  CMP  [SI].DDProductID,ISDSmartCblProdID    ;Is it an ISD Smart Cable?
  JE  >P90                                   ;If so, it's not a Printer!
  CMP  [SI].DDProductID,ISDSmartCblMacProdID ;Is it an ISD Smart Cable for Mac?
  JE  >P90                                   ;If so, it's not a Printer!
P10:                                         ;Is Epson Device
  OR   [BX].DIFlags,(DIFlagIsEpson+DIFlagInitEpson) ;Mark it as an Epson
P90:                                         ;Done
  POP  SI,AX                                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE AN EPSON USB PRINTER, IF NECESSARY
;Inputs:   ES = TSR Data Area
;         [BX] = Device Info Entry (contains Buffer Pointer)
;         CLD already issued
;Outputs: Sends the Epson Initialization String, if necessary
;Changes:
;------------------------------------------------------------------------------
StartEpson:
  PUSH AX,BX,CX,DX,DS         ;Save used registers
  MOV  DS,ES                  ;Point DS at TSR Data Area
  TEST [BX].DIFlags,DIFlagIsEpson ;Is it an Epson Printer?
  JZ  >S90                    ;If not, don't do anything
  TEST [BX].DIFlags,DIFlagInitEpson ;If so, do we need to Initialize it?
  JZ  >S90                    ;If not, don't do anything
  TEST TSRFlags,NoAutoEpson   ;Are we supposed to handle it automatically?
  JNZ >S90                    ;If not, don't do anything
  AND  [BX].DIFlags,(NOT DIFlagInitEpson) ;Mark Initialization as complete
  XOR  DX,DX                  ;Put
  MOV  DL,[BX].DILPTNum       ;  LPT Index
  DEC  DX                     ;  in DX
  MOV  BX,EpsonInitStr        ;DS:[BX] = Initialization String to Send
  MOV  CX,EpsonInitStrSize    ;CX = Length of String
  MOV  AX,(1B00h+I17FTxBlock) ;AX = Function = Send String
  INT  17h                    ;Do it
S90:                          ;Done
  POP  DS,DX,CX,BX,AX         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS NOTIFICATIONS FROM THE HOST DRIVER REGARDING DEVICE CHANGES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE A NOTIFICATION FROM THE HOST DRIVER FOR SOMETHING RELATED TO THE DEVICE
;Inputs:  AX = Device Owner Call Code (various possibilities)
;         [BX] = Info Table Offset
;         CX, DX = Varies by exact type of call
;         DS = ES = TSR Data Area
;Outputs: Depends on Call Type
;         Calls appropriate "subfunction"
;Changes: Nearly all registers
;------------------------------------------------------------------------------
DvcOwnerFarCall:
  CLD                          ;Go forward with string functions
  MOV  DI,BX                   ;Point DI at the Info Table entry
  MOV  BX,OwnerCallFunctionTbl ;Point at the Function table to search
  CALL SearchByte2WordTblES    ;Look for the function (in AL)
  JC  >H90                     ;If invalid function, quit
  CALL BX                      ;If OK, do it
H90:
  RETF

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST SAYING THAT A NEW DEVICE HAS BEEN ADDED
;Inputs:  [DI] = Info Table Entry
;         DS = ES = TSR Data Area
;         CL = Host Index
;         CH = Device Address
;         DL = Interface
;         DH = Alternate Interface
;Outputs:
;Changes: Prompts us to look for a new Device earlier than normal
;NOTES:   Originally, this routine directly called LookForNewDevice.
;         For some reason, this did not work with some Devices (they would
;           return bad Descriptors).  This is probably due to the Devices not
;           being given enough time to "reorganize" themselves after the
;           enumeration process of the Host Driver, which downloads the same
;           descriptors we download again here.
;         So now, instead of calling LookForNewDevice directly, this routine
;           sets the Int08Counter to a small number so that we look for
;           the new Device after a small delay.  Doing it after a small
;           delay, instead of doing it immediately, seems to work better
;           (at least with some Devices).
;------------------------------------------------------------------------------
DeviceAdded:
  CMP  Int08Counter,0 ;Disabled?
  JE  >A90            ;If so, quit
  MOV  Int08Counter,2 ;If not, look for a new Device right away
A90:                  ;Done
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST SAYING THAT A DEVICE HAS BEEN DISCONNECTED
;Inputs:  [DI] = Info Table Entry
;         DS = ES = TSR Data Area
;         CL = Host Index
;         CH = Device Address
;Outputs:
;Changes: Removes Device from Configuration
;NOTES:   This is called if a REGISTERED Device has been disconnected
;------------------------------------------------------------------------------
DeviceDisconnected:
  CALL ResetDvcEntryDI ;Delete entry from our table
                       ;  (also restores I/O Address in BIOS if appropriate
                       ;  and releases all Buffers)
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST SAYING THAT AN UNREGISTERED DEVICE IS DISCO'D
;Inputs:  DS = ES = TSR Data Area
;         CL = Host Index
;         CH = Device Address
;Outputs:
;Changes:
;NOTES: This is called if an UNREGISTERED Device has been disconnected,
;         so it will NOT be in DeviceInfoTable.  It may or may not be
;         in the BadDeviceTable.
;------------------------------------------------------------------------------
Device0Disconnected:
  CALL DeleteBadDevices ;Delete the Bad Entries from our Table, if there
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST TO TEMPORARILY STOP LOOKING FOR DEVICES
;Inputs:  DS = ES = TSR Data Area
;         CL = Host Index
;         CH = Device Address
;         DL = Interface Number
;         DH = TimeOut Value to use (deciseconds)
;         DI = Device Info Table Entry
;Outputs: DontLookCounter
;Changes:
;NOTES: This should only be called if a Device-specific Driver is trying
;         to take control of an already registered device from us.
;       We actually stop looking for ALL new Interfaces, rather than just
;         the one that is being requested.
;------------------------------------------------------------------------------
StartDontLook:
  PUSH AX,BX,DX,SI        ;Save used registers
  MOV  DontLookCounter,-1 ;Start not looking
  MOV  SI,Int14Request2   ;Point at Request Structure
  CALL RlsDvcNoResetDI    ;Release the Device, don't Reset it
  MOV  AL,DH              ;Put seconds in AL
  XOR  AH,AH              ;Multiply
  MOV  BX,18206           ;  seconds
  MUL  BX                 ;  by
  MOV  BX,10000           ;  1.8206
  DIV  BX                 ;  (number of timer ticks per decisecond)
  CMP  DX,5000            ;Do we need to round up?
  JB  >S90                ;If not, continue
  INC  AX                 ;If so, round up
S90:                      ;Done
  INC  AX                 ;Add one more Timer Tick for good measure
  MOV  DontLookCounter,AX ;Store the Counter Value
  POP  SI,DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM A HOST SAYING THAT IT'S BEEN UNINSTALLED
;Inputs:  CL = USB Host Index that isn't there any more
;         DS = ES = TSR Data Area
;Outputs:
;Changes:
;------------------------------------------------------------------------------
HostDisconnected:
  PUSH BX,DI                    ;Save used registers
  MOV  DI,DeviceInfoTable       ;Point at table
  MOV  BL,MaxDevices            ;Number of table entries
D20:                            ;Loop to here for each table entry
  TEST [DI].DIFlags,DIFlagInUse ;Empty Table Entry?
  JZ  >D40                      ;If so, skip it
  CMP  [DI].DIHostIndex,CL      ;Is it the Host this Device is on?
  JNE >D40                      ;If not, skip it
  CALL ResetDvcEntryDI          ;If so, delete it from the Info Table
D40:                            ;Done with this table entry
  ADD  DI,DeviceInfoStrucSize   ;Point at the next Table Entry
  DEC  BL                       ;Decrement loop counter
  JNZ  D20                      ;If not done yet, keep looking
  POP  DI,BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE VARIOUS REQUESTS FROM THE USB HOST DRIVER ABOUT UPSTREAM CHANGES
;Inputs:  Depends on Call
;Outputs:
;Changes: We don't care about any of these calls, since they don't directly
;           affect our program.  Any critical changes to upstream devices
;           are eventually reflected to us as a call directly addressing
;           one of our Devices, which is how we handle those things.
;------------------------------------------------------------------------------
DeviceEnabled:        ;Device Enabled
DeviceDisabled:       ;Device Disabled
DeviceReset:          ;Device Reset
DeviceSuspend:        ;Device Suspended
DeviceResume:         ;Device Resumed
DevicePowerOn:        ;Device Power On
DevicePowerOff:       ;Device Power Off
DevicePowerReset:     ;Device Power Reset
NewHostAdded:         ;New Host Added
HostHWErr:            ;Host System/Processor Error
HostRun:              ;Host Running
HostStop:             ;Host Stopped
HostReset:            ;Host Reset
HostSuspend:          ;Host Suspended
HostResume:           ;Host Resumed
HostDebug:            ;Host in Debug Mode
HostSST:              ;Host Single-Stepped
TimingChange:         ;Host Timing Change
DeviceDisconnectedUS: ;Device Disconnect Upstream
DeviceEnabledUS:      ;Device Enable Upstream
DeviceDisabledUS:     ;Device Disable Upstream
DeviceResetUS:        ;Device Reset Upstream
DeviceSuspendUS:      ;Device Suspend Upstream
DeviceResumeUS:       ;Device Resume Upstream
DevicePowerOnUS:      ;Device Power On Upstream
DevicePowerOffUS:     ;Device Power Off Upstream
DevicePowerResetUS:   ;Device Power Reset Upstream
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE TO RELEASE/RESET A DEVICE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;COMPLETELY RELEASE A DEVICE THAT WE CURRENTLY OWN (POSSIBLY INCLUDING A RESET)
;Inputs:  DS = ES = TSR Data Area
;         [DI] = Device Info Entry to Release
;         [SI] = Int 14 Request to use
;Outputs: Releases Device Entry
;           Unregisters as Interface Owner
;           Resets Device (if appropriate)
;           Resets Device Info Entry
;Changes:
;------------------------------------------------------------------------------
RlsDvcNoResetDI:
  PUSH BX                            ;Save used registers
  XOR  BL,BL                         ;Mark as No Reset
  JMP >R00                           ;Do it
RlsDvcDoResetDI:
  PUSH BX                            ;Save used registers
  MOV  BL,-1                         ;Mark as a Reset
;  JMP >R00                           ;Do it
R00:
  PUSH AX                            ;Save used registers
  MOV  W [SI].I14RCallBackAddr[0],-1 ;Set CallBackAddr to nothing
  MOV  AX,W [DI].DIHostIndex         ;Copy Host Index and
  MOV  W [SI].I14RHostIndex,AX       ;  Device Address
  MOV  AX,[DI].DIRegHandle           ;Copy
  MOV  [SI].I14RRequestHandle,AX     ;  Registry Handle
  MOV  [SI].I14RRequestType,I14RRTUnRegIntfOwner ;Request = UnRegister
  CALL DoInt14CallSaveAllSI          ;Do it
  OR   BL,BL                         ;Need to Reset the Device?
  JZ  >R80                           ;If not, we're done
  MOV  [SI].I14RRequestType,I14RRTResetDevice ;Request = Reset
  CALL DoInt14CallSaveAllSI          ;Do it
R80:                                 ;Done with Host
  CALL ResetDvcEntryDI               ;Delete the Device Info Entry
  POP  AX                            ;Restore used registers
  POP  BX                            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESET A DEVICE INFO TABLE ENTRY
;Inputs:  DS = ES = TSR Data Area
;        [BX] or [DI] = Info Table Entry to reset
;         CLD already issued
;Outputs:
;Changes: Resets (clears out) Info Table Entry
;         Restores original I/O Address in BIOS Data area, if appropriate
;NOTES:   This preserves the Disabled/Enabled status of
;           the Device, so that the user does not need to worry about
;           re-setting it after a temporary Disconnect or Host Reset.
;         Unlike most routines, this one preserves Flags across the Call!
;------------------------------------------------------------------------------
ResetDvcEntryBX:
  PUSH DI              ;Save used registers
  MOV  DI,BX           ;Point DI at the Table Entry
  CALL ResetDvcEntryDI ;Reset the Entry
  POP  DI              ;Restore used registers
  RET

ResetDvcEntryDI:
  PUSH AX,BX,CX,DI,DS             ;Save used registers
  PUSHF                           ;Save flags
  CLI                             ;Disable interrupts
  CALL RlsAllBuffersDvcDI         ;Release any Buffers associated with the Dvc
  MOV  AL,ES:[DI].DILptNum        ;Get the LPT Number
  OR   AL,AL                      ;Was this even assigned an LPT Number?
  JZ  >R40                        ;If not, no need to restore it
  CMP  AL,3                       ;Was it saved in the BIOS Data Area?
  JA  >R40                        ;If not, no need to restore it
  MOV  BX,0040h                   ;Point DS
  MOV  DS,BX                      ;  at BIOS Data Area
  MOV  BL,AL                      ;Restore
  SHL  BX,1                       ;  the
  ADD  BX,6                       ;  original
  MOV  AX,ES:[DI].DIOldIOAddress  ;  I/O
  MOV  [BX],AX                    ;  Address
R40:                              ;Done restoring I/O Adress
  XOR  AX,AX                      ;Need to store zeroes
  MOV  CX,((DeviceInfoStrucSize-Int14RequestSize)/2) ;Number of words to store
  REP  STOSW                      ;Reset the reset of the table
  POPF                            ;Restore flags
  POP  DS,DI,CX,BX,AX             ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE FOR DEVICE INFO TABLE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;FIND AN EMPTY INFO TABLE ENTRY
;Inputs:  DS = ES = TSR Data Area
;Outputs: ZF = Clear if OK (found an empty Table entry)
;              [BX] = Table Entry
;            = Set if error (Table is full)
;               BX  = 0
;Changes:
;------------------------------------------------------------------------------
FindEmptyInfoBX:
  PUSH CX                       ;Save used registers
  MOV  BX,DeviceInfoTable       ;Point at first Table Entry
  MOV  CX,MaxDevices            ;Number of Table Entries
E10:                            ;Loop to here to find empty Table Entry
  TEST [BX].DIFlags,DIFlagInUse ;Empty Table entry?
  JZ  >E90                      ;If so, continue
  ADD  BX,DeviceInfoStrucSize   ;Point at next table entry
  LOOP E10                      ;Keep looking
  XOR  BX,BX                    ;Table is full!
E90:                            ;Done
  OR   BX,BX                    ;Set Return Flag
  POP  CX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF WE HAVE EVEN A SINGLE DEVICE
;Inputs:  ES = TSR Data Area
;         DeviceInfoTable
;Outputs: CF = Clear if at least one Device is installed
;            = Set if not
;Changes:
;------------------------------------------------------------------------------
GotADevice:
  PUSH CX,DI                       ;Save used registers
  MOV  DI,DeviceInfoTable          ;Point at Table
  MOV  CX,MaxDevices               ;Number of Table entries to test
G10:                               ;Loop to here for each Table Entry
  TEST ES:[DI].DIFlags,DIFlagInUse ;Valid Device here?
  JNZ >G80                         ;If so, we're done
  ADD  DI,DeviceInfoStrucSize      ;Point at next table entry
  LOOP G10                         ;Keep going
G70:                               ;No Device Installed
  STC                              ;Set No Device Flag
  JMP >G90                         ;Done
G80:                               ;At least one Device
  CLC                              ;Set OK Flag
G90:                               ;Done
  POP  DI,CX                       ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE FOR BAD DEVICE TABLE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;ADD A BAD (INCOMPATIBLE) DEVICE HOST & ADDRESS TO THE TABLE
;Inputs:  DS:[SI] = Int 14 Structure containing Bad Device Data (Host/Addr/Intf)
;Outputs: Adds Host & Address to Bad Device Table
;Changes:
;------------------------------------------------------------------------------
AddBadDevice:
  PUSH AX,BX,CX                 ;Save used registers
  PUSHF                         ;Save Flags
  CLI                           ;Disable Interrupts
  MOV  BX,BadDeviceTable        ;Point at Table
  MOV  CX,MaxBadDevices         ;Number of Entries in Table
A20:                            ;Loop here to find empty table entry
  TEST [BX].BDFlags,BDFlagInUse ;This entry already used?
  JNZ >A50                      ;If so, skip it
  OR   [BX].BDFlags,BDFlagInUse ;If not, mark it as used
  MOV  AX,W [SI].I14RHostIndex  ;Store the Host Index
  MOV  W [BX].BDHostIndex,AX    ;  & Device Address
  MOV  AL,[SI].I14RInterfaceNum ;Store the
  MOV  [BX].BDInterfaceNum,AL   ;  Interface Number
  MOV  AX,NewDeviceError        ;Store the
  MOV  [BX].BDNewDeviceError,AX ;  Error Code
  MOV  AL,NewDeviceStage        ;Store the
  MOV  [BX].BDNewDeviceStage,AL ;  New Device Stage
  JMP >A90                      ;Done
A50:                            ;Entry not Empty
  ADD  BX,BadDeviceStrucSize    ;Point at next entry
  LOOP A20                      ;Keep going until we're done
A90:                            ;Done
  POPF                          ;Restore Flags
  POP  CX,BX,AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DELETE BAD (INCOMPATIBLE) DEVICE HOSTS & ADDRESSES FROM THE TABLE
;Inputs:  CL = Host Index, CH = Address
;Outputs: Deletes Host & Address from Bad Device Table
;Changes:
;NOTES: This is called as the result a a Device Disconnect, so we need to
;         delete all Interfaces of the Device.  There will probably only
;         be one Entry per Address, but we need to check all of them.
;------------------------------------------------------------------------------
DeleteBadDevices:
  PUSH AX,BX,CX,DX,DI            ;Save used registers
  PUSHF                          ;Save Flags
  MOV  AX,CX                     ;AL = Host Index, AH = Device Address
  MOV  DL,-1                     ;Don't care about the Interface Number
  CLI                            ;Disable Interrupts
D10:                             ;Loop here for each Table Entry
  CALL FindBadDeviceEntry        ;Any entries in the Table (returns BX)?
  JC  >D90                       ;If not, we're done
  PUSH AX                        ;If so, save used registers
  XOR  AX,AX                     ;Write zeroes
  MOV  CX,(BadDeviceStrucSize/2) ;Number of words to write
  MOV  DI,BX                     ;Point DI at Table Entry
  REP  STOSW                     ;Write them
  POP  AX                        ;Restore used registers
  JMP  D10                       ;Keep looking for more Entries
D90:                             ;Done
  POPF                           ;Restore Flags
  POP  DI,DX,CX,BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COMPARE A HOST AND ADDRESS TO SEE IF IT'S IN OUR BAD DEVICE TABLE
;Inputs:  CL = Host, CH = Address, DL = Interface, DH = Alt Interface
;Outputs: CF = Set if it's a Bad Device (in the Bad Device Table)
;            = Clear if it's not in the Bad Device Table
;Changes:
;NOTES: This ignores the Alt Interface Setting (we don't care about it).
;------------------------------------------------------------------------------
TestBadDevice:
  PUSH AX,BX              ;Save used registers
  MOV  AX,CX              ;AL = Host Index, AH = Device Address
                          ;DL = Interface Number
  CALL FindBadDeviceEntry ;Is it in the Table (returns BX)?
  CMC                     ;Complement the return flag
  POP  BX,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND A MATCHING HOST/ADDRESS/INTERFACE ENTRY IN THE BAD DEVICE TABLE
;Inputs:  AL = Host Index to find
;         AH = Device Address to find
;         DL = Interface Number to find
;              if -1, we don't care about the Interface Number
;Outputs: CF = Clear if Entry Found
;              BX = Entry Offset
;            = Set if Entry not found
;              BX = Undefined
;Changes:
;------------------------------------------------------------------------------
FindBadDeviceEntry:
  PUSH CX                       ;Save used registers
  PUSHF                         ;Save flags
  MOV  BX,BadDeviceTable        ;Point at Table
  MOV  CX,MaxBadDevices         ;Number of Entries in Table
  CLI                           ;Disable Interrupts
E20:                            ;Loop here to find empty table entry
  TEST [BX].BDFlags,BDFlagInUse ;Valid Entry?
  JZ  >E50                      ;If not, skip it
  CMP  W [BX].BDHostIndex,AX    ;Do the Host Index & Device Address match?
  JNE >E50                      ;If not, skip it
  CMP  DL,-1                    ;Do we care about the Interface Number?
  JE  >E80                      ;If not, we've found it!
  CMP  [BX].BDInterfaceNum,DL   ;Does the Interface Number match?
  JE  >E80                      ;If so, we've found it!
E50:                            ;Go to next entry
  ADD  BX,BadDeviceStrucSize    ;Point at the next entry
  LOOP E20                      ;Keep looking
E70:                            ;Error
  POPF                          ;Restore Flags
  STC                           ;Set Not Found Flag
  JMP >E90                      ;Done
E80:                            ;OK
  POPF                          ;Restore Flags
  CLC                           ;Set Found Flag
E90:                            ;Done
  POP  CX                       ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO ISSUE INT 14h CALLS TO THE HOST DRIVER
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;ISSUE AN INT 14 CALL TO THE USB HOST
;Inputs:  DS:[DX] = Int 14 Request (filled with appropriate data)
;      OR DS:[DI]
;      OR DS:[SI]
;Outputs: CF = Set if error (host stalled, etc.)
;            = Clear if OK
;Changes: Sends the appropriate info to the USB Host via Int 14 call
;------------------------------------------------------------------------------
;DoInt14CallSaveAllDI:       ;Save all changed registers
;                            ;  [DI] = Int14 Structure
;  PUSH DX                   ;Save used registers
;  MOV  DX,DI                ;Point DX at the Data Offset
;  CALL DoInt14CallSaveAllDX ;Do it
;  POP  DX                   ;Restore used registers
;  RET

DoInt14CallSaveAllSI:       ;Save all changed registers
                            ;  [SI] = Int14 Structure
  PUSH DX                   ;Save used registers
  MOV  DX,SI                ;Point DX at the Data Offset
  CALL DoInt14CallSaveAllDX ;Do it
  POP  DX                   ;Restore used registers
  RET

DoInt14CallAXSI:     ;Save all changed registers except AX,
                     ;  [SI] = Int14 Structure
  PUSH DX            ;Save used registers
  MOV  DX,SI         ;Point DX at the Data Offset
  CALL DoInt14CallAX ;Do it
  POP  DX            ;Restore used registers
  RET

DoInt14CallCXSI:     ;Save all changed registers except CX
                     ;  [SI] = Int14 Structure
  PUSH DX            ;Save used registers
  MOV  DX,SI         ;Point DX at the Data Offset
  CALL DoInt14CallCX ;Do it
  POP  DX            ;Restore used registers
  RET

DoInt14CallCXDI:     ;Save all changed registers except CX
                     ;  [DI] = Int14 Structure
  PUSH DX            ;Save used registers
  MOV  DX,DI         ;Point DX at the Data Offset
  CALL DoInt14CallCX ;Do it
  POP  DX            ;Restore used registers
  RET

DoInt14CallAXCXSI:     ;Save all changed registers except AX & CX
                       ;  [SI] = Int14 Structure
  MOV  DX,SI           ;Point DX at the Data Offset
  CALL DoInt14CallAXCX ;Do it
  RET

DoInt14CallCXDXSI:     ;Save all changed registers except CX & DX
                       ;  [SI] = Int14 Structure
  MOV  DX,SI           ;Point DX at the Data Offset
  CALL DoInt14CallCXDX ;Do it
  RET

DoInt14CallSaveAllDX: ;Save all changed registers, [DX] = Int14 Structure
  PUSH AX,BX,CX,DX    ;Save registers that Int14 changes!
  CALL DoInt14Call    ;Do it
  POP  DX,CX,BX,AX    ;Restore used registers
  RET

DoInt14CallAX:
  PUSH BX,CX,DX    ;Save registers that Int14 changes, except AX!!
  CALL DoInt14Call ;Do it
  POP  DX,CX,BX    ;Restore used registers
  RET

DoInt14CallCX:
  PUSH AX,BX,DX    ;Save registers that Int14 changes, except CX
  CALL DoInt14Call ;Do it
  POP  DX,BX,AX    ;Restore used registers
  RET

DoInt14CallAXCX:
  PUSH BX,DX       ;Save registers that Int14 changes, except AX & CX
  CALL DoInt14Call ;Do it
  POP  DX,BX       ;Restore used registers
  RET

DoInt14CallCXDX:
  PUSH AX,BX       ;Save registers that Int14 changes, except CX & DX
  CALL DoInt14Call ;Do it
  POP  BX,AX       ;Restore used registers
  RET

;Int 14 returns various values in AX, BX, CX, & DX
DoInt14Call:
  STI           ;Enable Interrupts
  MOV  AX,5001h ;Set Function
  MOV  BX,'US'  ;Set
  MOV  CX,'B!'  ;  Registers
  STC           ;Preset Error Flag
  INT  14h      ;Do it
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE FOR DOS DEVICE DRIVERS TO PROCESS LPT1-LPT9 & PRN
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;DEVICE DRIVER STRATEGY CALLS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;PERFORM THE DEVICE STRATEGY ROUTINE CALL FROM DOS
;Inputs:  CS = TSR Data Area
;         ES:[BX] = Location of Request Header
;Outputs: Stores Address in appropriate Data Area
;Changes:
;NOTES: This is called by DOS, not by our program.  It needs to end in a RETF.
;------------------------------------------------------------------------------
LPT1Strategy:
  PUSH CX                   ;Save used registers
  MOV  CL,0                 ;LPT1 = Index 0
  JMP >S00                  ;Do it
LPT2Strategy:
  PUSH CX                   ;Save used registers
  MOV  CL,1                 ;LPT2 = Index 1
  JMP >S00                  ;Do it
LPT3Strategy:
  PUSH CX                   ;Save used registers
  MOV  CL,2                 ;LPT3 = Index 2
  JMP >S00                  ;Do it
LPT4Strategy:
  PUSH CX                   ;Save used registers
  MOV  CL,3                 ;LPT4 = Index 3
  JMP >S00                  ;Do it
LPT5Strategy:
  PUSH CX                   ;Save used registers
  MOV  CL,4                 ;LPT5 = Index 4
  JMP >S00                  ;Do it
LPT6Strategy:
  PUSH CX                   ;Save used registers
  MOV  CL,5                 ;LPT6 = Index 5
  JMP >S00                  ;Do it
LPT7Strategy:
  PUSH CX                   ;Save used registers
  MOV  CL,6                 ;LPT7 = Index 6
  JMP >S00                  ;Do it
LPT8Strategy:
  PUSH CX                   ;Save used registers
  MOV  CL,7                 ;LPT8 = Index 7
  JMP >S00                  ;Do it
LPT9Strategy:
  PUSH CX                   ;Save used registers
  MOV  CL,8                 ;LPT9 = Index 8
  JMP >S00                  ;Do it
PRNStrategy:
  PUSH CX                   ;Save used registers
  MOV  CL,0                 ;PRN = Index 0
;  JMP >S00                  ;Do it
S00:
  PUSHF                     ;Save flags
  STI                       ;Enable interrupts
  CLD                       ;Go forward with string functions
  PUSH AX,BX,DX,DI,SI,BP    ;Save used registers
  PUSH DS,ES                ;Save used registers
  MOV  DX,DS                ;Save original (DOS) DS
  MOV  DS,CS                ;Point DS at TSR Data Area
  MOV  BP,ES                ;Save original ES:[BX]
  MOV  SI,BX                ;  in BP:[SI]
  CALL LHIndex2Offset       ;Point DS:[DI] at our LPTx Structure
  CALL FindPrevHeader       ;Look for the Previous Device Header (ES:[BX])
  JC  >S50                  ;If none, jump to process it ourselves
  CALL TestOurFunction      ;If so, test to see if we should process it
  JNC >S50                  ;If so, go ahead and process it ourselves
S30:                        ;Let the Previous Device Handler process it
  OR   [DI].LHFlags,LHFlagNotUs ;Mark as not for us
  PUSH CS                   ;Put our
  MOV  AX,OldStrategyRtn    ;  far return address
  PUSH AX                   ;  on the stack
  PUSH W ES:[BX].DHNextHeader[2] ;Put the Old Driver's Segment on the stack
  PUSH ES:[BX].DHStrategyOffset  ;Put the Old Driver's Offset on the stack
  MOV  DS,DX                ;Call the old Driver with DS = DOS Data Segment
                            ;  (some Drivers may require this)
  MOV  ES,BP                ;Restore original
  MOV  BX,SI                ;  ES:[BX]
  RETF                      ;Call the Old Driver's Strategy Routine
OldStrategyRtn:             ;Return to here from old Driver
  JMP >S90                  ;Done
S50:                        ;We need to process the call ourselves
  MOV  [DI].LHReqSegment,BP ;Store the Request Segment
  MOV  [DI].LHReqOffset,SI  ;Store the Request Offset
S90:                        ;Done
  POP  ES,DS                ;Restore used registers
  POP  BP,SI,DI,DX,BX,AX    ;Restore used registers
  POPF                      ;Restore flags
  POP  CX                   ;Restore used registers
  RETF

;------------------------------------------------------------------------------
;TEST THE STRATEGY CALL TO SEE IF WE SHOULD PROCESS IT OURSELVES
;Inputs:  DS = TSR Data Area
;         [DI] = Our LPTx Structure
;         BP:[SI] = Request Header sent by DOS
;         ES:[BX] = Previous Device Header (guaranteed to be there)
;         Verified that there is an existing driver
;Outputs: CF = Clear if we need to process the request
;            = Set if the previous Driver should process the Request
;Changes:
;NOTES: We perform this during a Strategy call from DOS to our Driver
;         only if there is a previous Driver for the Device.  If there is
;         no previous driver, we handle things ourselves (we do not
;         even call this subroutine).
;       However, for certain functions, we need to concern ourselves
;         with the capabilities of the previous Driver to know whether
;         to pass the call on or not.
;------------------------------------------------------------------------------
TestOurFunction:
  PUSH AX,CX,DX,ES           ;Save used registers
  MOV  CX,ES:[BX].DHAttribs  ;Put previous header attributes in CX
  MOV  ES,BP                 ;Point ES:[SI] at the Request Header
  XOR  DH,DH                 ;Put the LPT Index
  MOV  DL,[DI].LHLPTIndex    ;  in DX
  CALL ConvertIndexDX        ;Convert it to a Redirected Index
  CALL TestDXIsOursDSNoBX    ;Is it a USB Printer we're controlling?
  JNZ >F80                   ;If so, we need to process it ourselves
  CALL TestDvcHdrPort        ;Is it a valid I/O address?
  JZ  >F80                   ;If not, we need to handle it ourselves
  MOV  AL,ES:[SI].RHCommand  ;Get the Command from the Request Header
  CMP  AL,RHCmdRead          ;Is it Read?
  JE  >F80                   ;If so, we need to process it ourselves
  CMP  AL,RHCmdInputStatus   ;Is it Input Status?
  JE  >F80                   ;If so, we need to process it ourselves
  CMP  AL,RHCmdWrite         ;Is it Write?
  JE  >F10                   ;If so, check further
  CMP  AL,RHCmdWriteVerify   ;If not, is it Write with Verification?
  JNE >F20                   ;If not, check other possibilities
F10:                         ;Write or Write with Verification
  CMP  ES:[SI].RHRdWrInByteCount,1 ;Is it more than one byte?
  JA  >F80                   ;If so, we need to process it ourselves
  JMP >F70                   ;If not, let the old handler process it
F20:                         ;Not Read, Write, or Input Status
  CMP  AL,RHCmdOutputTilBusy ;Is it Output Until Busy?
  JNE >F30                   ;If not, check other possibilities
  TEST CH,(DHAttrOutTilBusy SHR 8) ;If so, will the previous Driver handle it?
  JNZ >F70                   ;If so, let it handle it
  JMP >F80                   ;If not, handle it ourselves
F30:                         ;Not Output Until Busy
  CMP  AL,RHCmdGenIOCtlV3    ;Is it Generic IOCTL?
  JE  >F35                   ;If so, continue
  CMP  AL,RHCmdGenIOCtlV4    ;Is it Generic IOCTL?
  JNE >F40                   ;If not, try other possibilities
F35:                         ;Generic IOCTL
  TEST CL,DHAttrGenIOCtl     ;Will the previous Driver handle it?
  JZ  >F80                   ;If not, handle it ourselves
  JMP >F45                   ;If so, jump to test the Function
F40:                         ;Not Generic IOCTL
  CMP  AL,RHCmdGenIOCtlCk    ;Is it Generic IOCTL Check?
  JNE >F70                   ;If none of these, let the old Driver process it
  TEST CL,DHAttrGenIOCtlCk   ;If so, will the previous Driver handle it?
  JZ  >F80                   ;If not, handle it ourselves
F45:                         ;Generic IOCtl or GenIOCtlCheck
  CMP  ES:[SI].RHGenIOCtlCkCategory,IOCatLPTx ;If so, is it for a Printer?
  JNE >F70                   ;If not, let the previous Driver handle it
  CMP  ES:[SI].RHGenIOCtlCkFunction,IOCmdGetDeviceID ;If so, is it Get Dvc ID?
  JE  >F80                   ;If so, handle it ourselves
F70:                         ;Let previous Device Handler process the call
  STC                        ;Set return flag
  JMP >F90                   ;Done
F80:                         ;We need to process the call ourselves
  CLC                        ;Set return flag
F90:                         ;Done
  POP  ES,DX,CX,AX           ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;DEVICE DRIVER INTERRUPT CALLS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;PERFORM THE DEVICE STRATEGY ROUTINE CALL FROM DOS
;Inputs:  CS = TSR Data Area
;         Assumes a previous Strategy Call was issued with the Request Header!
;Outputs: Depends on Request Type (stored in Request Header)
;Changes:
;NOTES: This is called by DOS, not by our program.  It needs to end in a RETF.
;------------------------------------------------------------------------------
LPT1Interrupt:
  PUSH CX                   ;Save used registers
  MOV  CL,0                 ;LPT1 = Index 0
  JMP >I00                  ;Do it
LPT2Interrupt:
  PUSH CX                   ;Save used registers
  MOV  CL,1                 ;LPT2 = Index 1
  JMP >I00                  ;Do it
LPT3Interrupt:
  PUSH CX                   ;Save used registers
  MOV  CL,2                 ;LPT3 = Index 2
  JMP >I00                  ;Do it
LPT4Interrupt:
  PUSH CX                   ;Save used registers
  MOV  CL,3                 ;LPT4 = Index 3
  JMP >I00                  ;Do it
LPT5Interrupt:
  PUSH CX                   ;Save used registers
  MOV  CL,4                 ;LPT5 = Index 4
  JMP >I00                  ;Do it
LPT6Interrupt:
  PUSH CX                   ;Save used registers
  MOV  CL,5                 ;LPT6 = Index 5
  JMP >I00                  ;Do it
LPT7Interrupt:
  PUSH CX                   ;Save used registers
  MOV  CL,6                 ;LPT7 = Index 6
  JMP >I00                  ;Do it
LPT8Interrupt:
  PUSH CX                   ;Save used registers
  MOV  CL,7                 ;LPT8 = Index 7
  JMP >I00                  ;Do it
LPT9Interrupt:
  PUSH CX                   ;Save used registers
  MOV  CL,8                 ;LPT9 = Index 8
  JMP >I00                  ;Do it
PRNInterrupt:
  PUSH CX                   ;Save used registers
  MOV  CL,0                 ;PRN = Index 0
;  JMP >I00                  ;Do it
I00:
  PUSHF                     ;Save flags
  STI                       ;Enable interrupts
  CLD                       ;Go forward with string functions
  PUSH AX,BX,DX,DI,SI       ;Save used registers
  PUSH DS,ES                ;Save used registers
  MOV  DX,DS                ;Save original (DOS) DS
  MOV  DS,CS                ;Point DS and
  CALL LHIndex2Offset       ;Point DS:[DI] at our LPTx Structure
  TEST [DI].LHFlags,LHFlagNotUs ;Should we process the call?
  JNZ >I60                  ;If not, pass it on to the old Driver
  LES  SI,[DI].LHReqOffset  ;If so, point ES:[SI] at the Request Header
  MOV  ES:[SI].RHStatus,0   ;Initialize Return Status to 0
  MOV  AL,ES:[SI].RHCommand ;Get the Command Byte
  MOV  BX,DvcIntTable       ;Point [BX] at the Code Offset Lookup Table
  CALL SearchByte2WordTblDS ;Search for a match
  JC  >I40                  ;If no match, error
  XOR  DH,DH                ;If OK, put the LPT Index
  MOV  DL,[DI].LHLPTIndex   ;  in DX for the call
  CALL BX                   ;If OK, perform the Code
  JMP >I50                  ;Done
I40:                        ;Illegal/Unknown Command
  OR   ES:[SI].RHStatus,(RHSUnknownCmd+RHSError) ;Mark as Unknown Command Error
I50:                        ;Done processing the Request
  OR   B ES:[SI].RHStatus[1],(RHSDone SHR 8) ;Mark request as Done
  JMP >I90                  ;Done
I60:                        ;Let the old Device Handler process it
  AND  [DI].LHFlags,(NOT LHFlagNotUs) ;Mark it as for us next time
  PUSH CS                   ;Put our
  MOV  AX,OldInterruptRtn   ;  far return address
  PUSH AX                   ;  on the stack
  CALL FindPrevHeader       ;Get the Previous Device Header (ES:[BX])
  PUSH W ES:[BX].DHNextHeader[2] ;Put the Old Driver's Segment on the stack
  PUSH ES:[BX].DHInterruptOffset ;Put the Old Driver's Offset on the stack
  MOV  DS,DX                ;Call the old Driver with DS = DOS Data Segment
                            ;  (some Drivers may require this)
  RETF                      ;Call the Old Driver's Strategy Routine
OldInterruptRtn:            ;Return here from old driver
I90:                        ;Done
  POP  ES,DS                ;Restore used registers
  POP  SI,DI,DX,BX,AX       ;Restore used registers
  POPF                      ;Restore flags
  POP  CX                   ;Restore used registers
  RETF

;------------------------------------------------------------------------------
;PERFORM A DOS INPUT STATUS OR OUTPUT STATUS DEVICE DRIVER CALL
;Inputs:  DS:[DI] = LPTx Structure
;         ES:[SI] = Request Header sent by DOS
;         DX = LPT Index associated with the INT 17h call for this Port
;Outputs: Performs Function as Requested by DOS
;         Updates Request Header data as appropriate
;           (Everything except Done flag)
;Changes:
;------------------------------------------------------------------------------
DvcIntInputStatus:
DvcIntOutputStatus:
  PUSH AX                       ;Save used registers
  MOV  AH,2                     ;Function 2 (Get Status)
  INT  17h                      ;Do it
  AND  AH,(NOT PStsACKnowledge) ;Mask out the ACK bit (if it's there)
  CMP  AH,PStsNormal            ;Is it the Status Normal?
  JE  >S90                      ;If so, we're done
  OR   ES:[SI].RHStatus,(RHSError+RHSDvcNotReady) ;If not, return error
S90:                            ;Done
  POP  AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PERFORM A DOS READ OR OUTPUT TIL BUSY DEVICE DRIVER CALL
;Inputs:  DS:[DI] = LPTx Structure
;         ES:[SI] = Request Header sent by DOS
;         DX = LPT Index associated with the INT 17h call for this Port
;Outputs: Performs Function as Requested by DOS
;         Updates Request Header data as appropriate
;           (Everything except Done flag)
;Changes: Output Until Busy does the same thing as a Write Block command
;           (write multiple characters), but does not return an error if
;           all of the characters don't get sent.
;------------------------------------------------------------------------------
DvcIntOutputTilBusy:
  PUSH AX,BP                        ;Save used registers
  MOV  AL,I17FTxBlock               ;Function = Write Block
  MOV  BP,-1                        ;Don't return Incomplete Transfer Errrors
  JMP >B00                          ;Do it
DvcIntRead:
  PUSH AX,BP                            ;Save used registers
  MOV  AL,I17FRxBlock                   ;Function = Read Block
  XOR  BP,BP                            ;Mark as needing to return error
;  JMP >B00                          ;Do it
B00:
  PUSH BX,CX,DX                     ;Save used registers
  MOV  AH,1Bh                       ;Complete Call Code in AX
  MOV  CX,ES:[SI].RHRdWrInByteCount ;CX = Number of Bytes to Transfer
                                    ;DL = LPT Index, DH = Timeout
  OR   CX,CX                        ;Send 0 bytes?
  JZ  >B90                          ;If so, we're done
  PUSH DS                           ;Save used registers
  LDS  BX,ES:[SI].RHRdWrInXferAddr  ;DS:[BX] = Data Buffer
  INT  17h                          ;Do it
  POP  DS                           ;Restore used registers
  MOV  ES:[SI].RHRdWrInByteCount,CX ;Store the number of bytes Transfered
  OR   AX,AX                        ;Any errors?
  JZ  >B90                          ;If not, we're done
  MOV  BX,(RHSError+RHSWriteFault)  ;Assume Writing
  OR   BP,BP                        ;Are we Writing?
  JNZ >B20                          ;If so, continue
  MOV  BX,(RHSError+RHSReadFault)   ;Reading
B20:                                ;BX = Error Status to Use
  CMP  AL,I17ErrIncompleteXfer      ;Is it an incomplete Transfer?
  JNE >B70                          ;If not, it's a real error
  OR   BP,BP                        ;If so, do we return Incomplete Errors?
  JNZ >B90                          ;If not, we're done
B70:                                ;Write Error
  OR   ES:[SI].RHStatus,BX          ;Store the Error Code
B90:                                ;Done
  POP  DX,CX,BX                     ;Restore used registers
  POP  BP,AX                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PERFORM A DOS WRITE OR WRITE WITH VERIFICATION DEVICE DRIVER CALL
;Inputs:  DS:[DI] = LPTx Structure
;         ES:[SI] = Request Header sent by DOS
;         DX = LPT Index associated with the INT 17h call for this Port
;Outputs: Performs Function as Requested by DOS
;         Updates Request Header data as appropriate
;           (Everything except Done flag)
;Changes:
;NOTES: Write and Write with Verification do the same thing.  There's actually
;         no way to verify that a character actually got printed, so the
;         verification process is impossible to perform.  However, if DOS's
;         VERIFY flag is set, DOS always issues the Write with Verification
;         command instead of the Write command, so we need to process it.
;------------------------------------------------------------------------------
DvcIntWrite:
DvcIntWriteVerify:
  PUSH AX,BX,CX,DX,DI,BP            ;Save used registers
  PUSHF                             ;Save flags
  CLD                               ;Go forward with string functions
  XOR  DI,DI                        ;Initialize Error to nothing
  XOR  BP,BP                        ;BP = Bytes Sent Counter
  MOV  CX,ES:[SI].RHRdWrInByteCount ;CX = Number of Bytes to Transfer
                                    ;DX = LPT Index
  OR   CX,CX                        ;Send 0 bytes?
  JZ  >W90                          ;If so, we're done
  PUSH DS,SI                        ;Save used registers
  LDS  SI,ES:[SI].RHRdWrInXferAddr  ;DS:[SI] = Data Buffer
W10:                                ;Loop to here for each character
  LODSB                             ;Get the next character
  MOV  AH,I17FSendByte              ;Function = Send Byte
  INT  17h                          ;Send it
  AND  AH,(NOT PStsACKnowledge)     ;Mask out the ACK bit
  CMP  AH,PStsNormal                ;Did it work?
  JNE >W30                          ;If not, handle it
  INC  BP                           ;Increment Bytes Sent Counter
  LOOP W10                          ;If so, keep going until we're done
  JMP >W50                          ;If we've sent all the characters, quit
W30:                                ;Error sending this byte
  MOV  DI,(RHSError+RHSOutOfPaper)  ;Assume No paper
  TEST AH,PStsNoPaper               ;Is it No Paper?
  JNZ >W50                          ;If so, continue
  MOV  DI,(RHSError+RHSWriteFault)  ;If not, it's just a Write Fault
W50:                                ;Done sending bytes
  POP  SI,DS                        ;Restore used registers
W90:                                ;Done
  MOV  ES:[SI].RHRdWrInByteCount,BP ;Store the number of bytes Transferred
  OR   ES:[SI].RHStatus,DI          ;Mask in the Error
  POPF                              ;Restore used registers
  POP  BP,DI,DX,CX,BX,AX            ;Restore used registers
  RET


;DvcIntOutputTilBusy:
;  PUSH AX,BP                            ;Save used registers
;  MOV  AL,I17FTxBlock                   ;Function = Write Block
;  MOV  BP,-1                            ;Mark as not returning error
;  JMP >W00                              ;Do it
;DvcIntWrite:
;DvcIntWriteVerify:
;  PUSH AX,BP                            ;Save used registers
;  MOV  AL,I17FTxBlock                   ;Function = Write Block
;  XOR  BP,BP                            ;Mark as needing to return error
;  JMP >W00                              ;Do it
;DvcIntRead:
;  PUSH AX,BP                            ;Save used registers
;  MOV  AL,I17FRxBlock                   ;Function = Read Block
;  XOR  BP,BP                            ;Mark as needing to return error
;;  JMP >W00                              ;Do it
;W00:
;  PUSH BX,CX,DX                         ;Save used registers
;  MOV  AH,1Bh                           ;Complete Call Code in AX
;  MOV  CX,ES:[SI].RHRdWrInByteCount     ;CX = Number of Bytes to Transfer
;                                        ;DL = LPT Index, DH = Timeout
;  PUSH DS                               ;Save used registers
;  MOV  DS,W ES:[SI].RHRdWrInXferAddr[2] ;Point DS:[BX]
;  MOV  BX,W ES:[SI].RHRdWrInXferAddr[0] ;  at the Buffer
;  INT  17h                              ;Do it
;  POP  DS                               ;Restore used registers
;  MOV  ES:[SI].RHRdWrInByteCount,CX     ;Store the number of bytes Transfered
;  OR   AX,AX                            ;Any errors?
;  JZ  >W90                              ;If not, we're done
;  CMP  AL,I17ErrIncompleteXfer          ;If so, is it an incomplete Transfer?
;  JNE >W70                              ;If not, it's a real error
;  OR   BP,BP                            ;If so, do we return Incomplete Errors?
;  JNZ >W90                              ;If not, we're done
;W70:                                    ;Error
;  OR   ES:[SI].RHStatus,(RHSError+RHSGeneralFail) ;Return error
;W90:                                    ;Done
;  POP  DX,CX,BX                         ;Restore used registers
;  POP  BP,AX                            ;Restore used registers
;  RET

;------------------------------------------------------------------------------
;PERFORM A DOS GENERIC IOCTL DEVICE DRIVER CALL
;Inputs:  DS:[DI] = LPTx Structure
;         ES:[SI] = Request Header sent by DOS
;         DX = LPT Index associated with the INT 17h call for this Port
;Outputs: Performs Function as Requested by DOS
;         Updates Request Header data as appropriate
;           (Everything except Done flag)
;Changes:
;------------------------------------------------------------------------------
DvcIntGenIOCtlV3:
DvcIntGenIOCtlV4:
  PUSH AX,BX,CX,DX                      ;Save used registers
  CMP  ES:[SI].RHGenIOCtlCkCategory,IOCatLPTx ;Correct Category (LPTx)?
  JNZ >I75                              ;If not, illegal command
  MOV  AL,ES:[SI].RHGenIOCtlCkFunction  ;If so, get the specific Command
  CMP  AL,IOCmdGetDeviceID              ;Is it Get Dvc ID?
  JE  >I40                              ;If so, handle it
  CMP  AL,IOCmdGetRetry                 ;Is it Get Retry/Iteration Count?
  JE  >I30                              ;If so, handle it
  CMP  AL,IOCmdGetRetry                 ;Is it Get Retry/Iteration Count?
  JNE >I75                              ;If not, Illegal Command
I20:                                    ;Set Retry/Iteration Count
  PUSH ES                               ;Save used registers
  LES  BX,ES:[SI].RHGenIOCtlParamBlkPtr ;Point ES:[BX] at Param Block
  MOV  AX,ES:[BX].GIOItCount            ;Get the new Retry/Iteration Count
  POP  ES                               ;Restore used registers
  MOV  [DI].LHRetryCount,AX             ;Store the new Retry/Iteration Count
  JMP >I90                              ;Done
I30:                                    ;Get Retry/Iteration Count
  MOV  AX,[DI].LHRetryCount,AX          ;Get the Retry/Iteration Count
  PUSH ES                               ;Save used registers
  LES  BX,ES:[SI].RHGenIOCtlParamBlkPtr ;Point ES:[BX] at Param Block
  MOV  ES:[BX].GIOItCount,AX            ;Return the new Retry/Iteration Count
  POP  ES                               ;Restore used registers
  JMP >I90                              ;Done
I40:                                    ;Get Device ID
  MOV  AX,(1B00h+I17FGetDvcIDString)    ;Function = Get Device ID String
  PUSH DS,ES                            ;Save used registers
  LES  BX,ES:[SI].RHGenIOCtlParamBlkPtr ;Point ES:[BX] at Param Block
  MOV  CX,ES:[BX].GIODvcIDBuffSize      ;CX = Number of Bytes to Transfer
  PUSH BX                               ;Save used registers
  MOV  DS,W ES:[BX].GIODvcIDBuffAddr[2] ;Point DS:[BX]
  MOV  BX,W ES:[BX].GIODvcIDBuffAddr[0] ;  at the Buffer
                                        ;DL = LPT Index, DH = Timeout
  INT  17h                              ;Do it
  POP  BX                               ;Restore used registers
  MOV  ES:[BX].GIODvcIDBuffSize,CX      ;Store the number of bytes Transfered
  MOV  DH,ES:[BX].GIODvcIDFlags         ;Get the Parameter Block Flags
  POP  ES,DS                            ;Restore used registers
  OR   AX,AX                            ;Any errors?
  JZ  >I90                              ;If not, we're done
  TEST DH,GIOFlagShortPktOK             ;Should we return a Short Packet Error?
  JZ  >I70                              ;If so, error (it doesn't matter what
                                        ;  the error actually was)
  CMP  AL,I17ErrIncompleteXfer          ;If not, was it a Short Packet Error?
  JE  >I90                              ;If so, don't return an error
I70:                                    ;Error
  OR   ES:[SI].RHStatus,(RHSError+RHSGeneralFail) ;Return General Failure Error
  JMP >I90                              ;Done
I75:                                    ;Invalid Command
  OR   ES:[SI].RHStatus,(RHSError+RHSUnknownCmd) ;Return Invalid Command Error
I90:                                    ;Done
  POP  DX,CX,BX,AX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PERFORM A DOS GENERIC IOCTL CHECK DEVICE DRIVER CALL
;Inputs:  DS:[DI] = LPTx Structure
;         ES:[SI] = Request Header sent by DOS
;         DX = LPT Index associated with the INT 17h call for this Port
;Outputs: Performs Function as Requested by DOS
;         Updates Request Header data as appropriate
;           (Everything except Done flag)
;Changes:
;------------------------------------------------------------------------------
DvcIntGenIOCtlCk:
  PUSH AX                       ;Save used registers
  CMP  ES:[SI].RHGenIOCtlCkCategory,IOCatLPTx ;Is it for a Printer?
  JNE >K70                      ;If not, Invalid Command
  MOV  AL, ES:[SI].RHGenIOCtlFunction ;If so, get the Function
  CMP  AL,IOCmdSetRetry         ;Is it Set Retry?
  JE  >K80                      ;If so, it's valid
  CMP  AL,IOCmdGetRetry         ;Is it Get Retry?
  JE  >K80                      ;If so, it's valid
  CMP  AL,IOCmdGetDeviceID      ;Is it Get Device ID?
  JE  >K80                      ;If so, it's valid
K70:                            ;Invalid Command
  MOV  ES:[SI].RHGenIOCtlCkAX,1 ;Set AX return value to 1 (DOS will change it)
  OR   ES:[SI].RHStatus,(RHSError+RHSUnknownCmd) ;Mark as Unknown Command
  JMP >K90                      ;Done
K80:                            ;Valid Command
  MOV  ES:[SI].RHGenIOCtlCkAX,0 ;Set AX return value to 0
K90:                            ;Done
  POP  AX                       ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;SUPPORT CODE FOR DOS DEVICE DRIVER CALLS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;CONVERT AN LPTx INDEX TO A STRUCTURE POINTER
;Inputs:   CL  = LPTx Index to use
;Outputs: [DI] = Offset of LPTx Structure associated with Index
;Changes:
;------------------------------------------------------------------------------
LHIndex2Offset:
  PUSH AX                  ;Save used registers
  MOV  AL,LPTxHdrStrucSize ;Calculate the Offset
  MUL  CL                  ;  to the Structure we're looking for
  MOV  DI,LPTxHeaders      ;Add it to the
  ADD  DI,AX               ;  base offset of the Structure Table
  POP  AX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND A SPECIFIC DEVICE HEADER
;Inputs:  DS = TSR Data Area
;         CLD already issued
;         If Find First:
;           DS:[SI] = Device Header String to find
;           DS:NulDvcHeader
;         If Find Previous:
;           DS:[DI] = Offset of our LPT Device Header Structure
;Outputs: CF = Clear if OK
;              ES:[BX] = First/Previous Device Header with matching name
;            = Set if Error
;              ES:[BX] = Unchanged
;Changes:
;------------------------------------------------------------------------------
;FindFirstHeader:
;  PUSH DX,SI,BP                ;Save used registers
;  MOV  DX,ES                   ;Save original ES:[BX]
;  MOV  BP,BX                   ;  in DX:[BP]
;  LES  BX,NulDvcHeader         ;Point ES:[BX] at the first
;  LES  BX,ES:[BX].DHNextHeader ;  non-NUL Device Header
;  JMP >F00                     ;Do it
FindPrevHeader:
  PUSH DX,SI,BP                ;Save used registers
  MOV  DX,ES                   ;Save original ES:[BX]
  MOV  BP,BX                   ;  in DX:[BP]
  LEA  SI,[DI].DHCDvcName      ;Point DS:[SI] at our Device Header Name String
  LES  BX,[DI].DHNextHeader    ;Point ES:[BX] at the Previous Device Header
;  JMP >F00                     ;Do it
;F00:
  PUSH CX,DI                   ;Save used registers
  MOV  DX,ES                   ;Save original ES:[BX]
  MOV  BP,BX                   ;  in DX:[BP]
  LES  BX,NulDvcHeader         ;Point ES:[BX] at the first
  LES  BX,ES:[BX].DHNextHeader ;  non-NUL Device Header
F10:                           ;Loop to here for each Device Header
  LEA  DI,[BX].DHCDvcName      ;Point ES:[DI] at the Drivers Name String
  MOV  CX,4                    ;Test 4 words
  PUSH SI                      ;Save our name pointer
  REPE CMPSW                   ;Compare the names
  POP  SI                      ;Restore our name pointer
  JE  >F80                     ;If the names match, we've found it
  LES  BX,ES:[BX].DHNextHeader ;If not, point ES:[BX] at the Previous Header
  CMP  BX,-1                   ;Is it a valid Header?
  JNE  F10                     ;If so, continue
F70:                           ;No Device Header Found
  MOV  ES,DX                   ;Restore original
  MOV  BX,BP                   ;  ES:[BX]
  STC                          ;Set return flag
  JMP >F90                     ;Done
F80:                           ;Found
  CLC                          ;Set return flag
F90:                           ;Done
  POP  DI,CX                   ;Restore used registers
  POP  BP,SI,DX                ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO HANDLE INT 05h (PrintScreen)
;This Fixes the BOUND OpCode "Bug" by rebooting the computer if necessary
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HAVE INTERRUPT 05 (PRINTSCREEN) RUN THIS EVERY TIME IT OCCURS
;Inputs:  CS = TSR Data Area
;Outputs: Tests for and Fixes BOUND OpCode "Bug"
;         Reboots Computer if BOUND instruction is issued inadvertantly
;Changes:
;------------------------------------------------------------------------------
Int05Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int05:
  TEST CS:TSRFlags,NoBoundFix ;Are we supposed to fix the BOUND Bug?
  JNZ >F00                    ;If not, don't do anything
  CALL TestBound              ;Test for bad BOUND, reboot computer if so
F90:                          ;Not a BOUND
  IRET

F00:                           ;We don't care about the BOUND Bug
  JMP  D CS:Int05Hdr.OldVector ;Let the old vector handle it


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED TO HANDLE THE BOUND BUG
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST IF WE ARE RETURNING TO A BOUND INSTRUCTION -- IF SO, REBOOT
;Inputs:  CS = TSR Data Segment
;         Assumes nothing on stack from INT 05 except Call to this Sub!
;         DO NOT do any PUSH's before calling this routine!
;Outputs: If the return address on the Stack points at a BOUND instruction,
;           we roboot the computer
;         If not, we simply return
;Changes:
;------------------------------------------------------------------------------
TestBound:
  PUSH BP                 ;Save used registers
  MOV  BP,SP              ;Get the Stack Pointer
  PUSH AX,BX,SI,DS        ;Save used registers
  PUSHF                   ;Save flags
  CLD                     ;Go forward with string functions
  LDS  SI,SS:[BP+4]       ;[BP+0] = Saved BP
                          ;[BP+2] = Return address for our caller (Int 05)
                          ;[BP+4] = CS:IP of original program
B10:                      ;Loop to here for each OpCode Prefix
  LODSB                   ;AL = OpCode at return address
  CMP  AL,OpCodeBound     ;Is it the Bound OpCode?
  JE   Reboot             ;If so, Reboot the computer
  MOV  BX,OpCodePrefixTbl ;Point at our single-byte OpCode Prefix Table
B30:                      ;Loop to here for each table entry
  MOV  AH,CS:[BX]         ;Get the table entry
  OR   AH,AH              ;End of the Table?
  JZ  >B90                ;If so, we're not returning to a BOUND
  CMP  AL,AH              ;Is the OpCode in our Prefix Table?
  JE   B10                ;If so, keep looking for the BOUND
  INC  BX                 ;If not, point at the next Table entry
  JMP  B30                ;Keep looking
B90:                      ;Not returning to BOUND - probably a PrtScr
  POPF                    ;Restore flags
  POP  DS,SI,BX,AX        ;Restore used registers
  POP  BP                 ;Restore used registers
  RET

;-----------------------------------------------------------------------------
;REBOOT THE COMPUTER
;Inputs:  CS = TSR Data Segment
;Outputs:
;Changes: Flushes disk buffers and reboots the computer
;NOTES: Since this reboots the computer (or at least attempts to
;         reboot the computer), we don't worry about cleaning anything up
;         (like the stack or the registers).  If our reboot doesn't work
;         for some reason things will be so screwed up anyway that the user
;         will need to do a hard reboot (with the computer's power button).
;       This code is based on information from Microsoft's web site,
;         so should be OK: http://support.microsoft.com/kb/q67929/
;-----------------------------------------------------------------------------
Reboot:
  MOV  AH,0Dh        ;Function 0Dh (flush DOS & SmartDrv Disk Buffers)
  INT  21h           ;Do it (does not update directory info!)
  MOV  AX,40h        ;Point DS at
  MOV  DS,AX         ;  the BIOS data area
  MOV  W [17h],BIOS17EitherCtlP+BIOS17EitherAltP ;Set BIOS to Ctrl-Alt
  MOV  AX,4F53h      ;Function 4Fh (Translate Scan Code) w/ AL = 83 (Delete)
  STC                ;Set carry flag (needed for function 4Fh to work)
  INT  15h           ;Do it (shuts down EMM386, if Loaded)
  MOV  W [72h],1234h ;Mark memory for a Warm Boot
  JMP  0FFFFh:0000   ;Reboot!


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO HANDLE INT 08h (Timer Tick)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HAVE INTERRUPT 08 (TIMER) RUN THIS EVERY TIME IT OCCURS
;Inputs:
;Outputs: Searches for Newly attached Device
;Changes:
;NOTES: In theory, we shouldn't even need to do this since we are registering
;         and will be notified automatically if a new Device is attached.
;       We will do this just in case we miss it or are busy for some reason.
;------------------------------------------------------------------------------
Int08Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int08:
  PUSHF                          ;Call the
  CALL D CS:Int08Hdr.OldVector   ;  Old Interrupt Handler
  STI                            ;Enable interrupts
  CLD                            ;Go forward with string functions
  CALL MakeStack                 ;Set up our own Stack Space
  PUSH DI,SI,DS,ES               ;Save used registers
  MOV  DS,CS                     ;Point DS and
  MOV  ES,CS                     ;  ES at our data area
  CMP  Reg0Handle,-1             ;Are we registered with a Host yet?
  JNE >E10                       ;If so, continue
  CALL TestUSBHost               ;If not, is there a Host installed?
  JC  >E90                       ;If not, quit
  CALL InitInts                  ;If OK, Register as Device 0 Owner
  JMP >E90                       ;Done for now
E10:                             ;Registered with a Host
  MOV  DI,OFFSET Int08Counter    ;Point DI at Int08Counter
  MOV  SI,OFFSET DontLookCounter ;Point BX at DontLookCounter
  CMP  W [SI],0                  ;Need to Decrement DontLookCounter?
  JE  >E20                       ;If not, continue
  DEC  W [SI]                    ;If so, Decrement it
  JNZ >E80                       ;If not 0 yet, quit
  CMP  B [DI],0                  ;Int 08 Disabled?
  JE  >E80                       ;If so, we're done
  MOV  B [DI],1                  ;If not, look for Device right away
E20:                             ;Done with DontLookCounter
  CMP  B [DI],0                  ;Are we supposed to look yet?
  JE  >E80                       ;If not, just quit
  DEC  B [DI]                    ;Decrement the Delay Counter
  JNZ >E80                       ;If not 0 yet, quit
  MOV  B [DI],182                ;If 0, reset for next time (approx 10 seconds)
  PUSH AX,BX,CX,DX,DI,SI,BP      ;Save used registers
  CALL LookForNewDevice          ;Look for a new Device
  POP  BP,SI,DI,DX,CX,BX,AX      ;Restore used registers
E80:                             ;Done looking for new Devices
  CALL UpdateBufferTimers        ;Process Buffers for Timeouts
  CALL UpdateBlockTimers         ;Process Block Transfers for Timeouts
E90:                             ;Done
  POP  ES,DS,SI,DI               ;Restore used registers
  CALL ReturnStack               ;Restore Original Stack Space
  IRET

;------------------------------------------------------------------------------
;TEST AND SEE IF A COMPATIBLE USB HOST DRIVER IS INSTALLED
;Inputs:
;Outputs: CF = Set if error (No Host Driver Installed)
;            = Clear if OK
;Changes:
;------------------------------------------------------------------------------
TestUSBHost:
  PUSH AX,BX,CX ;Save used registers
  MOV  AX,5000h ;Function 5000h (Install Check)
  MOV  BX,'US'  ;Set
  MOV  CX,'B!'  ;  registers
  STC           ;Preset Error Flag
  INT  14h      ;Do it
  JC  >U70      ;If Error, USB Host can't be installed
  OR   AX,AX    ;Is AX Correct?
  JNZ >U70      ;If not, Error
  CMP  BX,'B!'  ;Is BX correct?
  JNE >U70      ;If not, Error
  CMP  CX,'US'  ;Is CX correct?
  JE  >U80      ;If so, it's installed
U70:            ;Not installed
  STC           ;Set Error Flag
  JMP >U90      ;Done
U80:            ;Installed
  CLC           ;Set OK flag
U90:            ;Done
  POP  CX,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE NECESSARY INTERRUPTS TO CHECK FOR A NEW DEVICE
;Inputs:  DS = ES = TSR Data Area
;Outputs: Reg0Handle
;Changes:
;------------------------------------------------------------------------------
InitInts:
  PUSH CX,DI                    ;Save used registers
I10:                            ;Register Interface 0 Owner
  MOV  DI,Int14Request          ;Point at Request Structure
  MOV  [DI].I14RRequestType,I14RRTRegIntfOwner ;Register as Owner
  MOV  [DI].I14RHostIndex,-1    ;Any/All Hosts
  MOV  [DI].I14RDeviceAddress,0 ;New Device
  MOV  W [DI].I14RCallBackAddr[0],DvcOwnerFarCall ;Code to call
  CALL DoInt14CallCXDI          ;Do it
  JC  >I90                      ;If error, quit
  MOV  Reg0Handle,CX            ;Save Registry Handle
I90:                            ;It worked
  POP  DI,CX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;UPDATE BUFFER TIMERS, SCHEDULING TIMED-OUT BUFFERS IF APPROPRIATE
;Inputs:  DS = ES = TSR Data Area
;Outputs: Buffer Timer Entries
;         If a Buffer Times out, we schedule the Bulk Transaction
;Changes:
;------------------------------------------------------------------------------
UpdateBufferTimers:
  PUSH CX,DI                    ;Save used registers
  MOV  DI,BufferTable           ;Point at the Table
  MOV  CX,NumBuffers            ;Number of Table entries
T10:                            ;Loop to here for each Table entry
  TEST [DI].BfFlags,BfFlagInUse ;Valid entry?
  JZ  >T50                      ;If not, skip it
  CMP  [DI].BfCloseID,0         ;Has it already been sent?
  JNE >T50                      ;If so, don't send it again
  CMP  [DI].BfTimer,0           ;Is it ready to send yet?
  JE  >T30                      ;If so, try to send it
  DEC  [DI].BfTimer             ;If not, decrement the Timer
  JNZ >T50                      ;If not timed out yet, keep waiting
T30:                            ;Buffer is ready to send
  CMP  [DI].BfPrevBuffer,0      ;Is there a previous buffer still pending?
  JNE >T50                      ;If so, we're done for now
  CALL SendBufferDI             ;Schedule it
T50:                            ;Done with this entry
  ADD  DI,BufferStrucSize       ;Point at the next entry
  LOOP T10                      ;Keep going until we're done
  POP  DI,CX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;UPDATE BLOCK TRANSFER TIMERS
;Inputs:  DS = ES = TSR Data Area
;Outputs: Block Transfer Timer Entries
;Changes:
;NOTES: We simply count down the timers to 0.  It is the responsibility of
;         the calling code to monitor and process things correctly when
;         the timer reaches 0.
;------------------------------------------------------------------------------
UpdateBlockTimers:
  PUSH CX,DI                    ;Save used registers
  MOV  DI,BlockTimeoutTable     ;Point [DI] at the Table
  MOV  CX,NumBlockTimeouts      ;CX = Number of Table entries
K10:                            ;Loop to here for each Table entry
  TEST [DI].BTFlags,BTFlagInUse ;Valid entry?
  JZ  >K50                      ;If not, skip it
  CMP  [DI].BTCounter,0         ;If so, has it already timed out?
  JE  >K50                      ;If so, skip it
  DEC  [DI].BTCounter           ;If not, decrement the Timer
K50:                            ;Done with this entry
  ADD  DI,BlockTimeoutStrucSize ;Point at the next entry
  LOOP K10                      ;Keep going until we're done
  POP  DI,CX                    ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO HANDLE INT 17h
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HAVE INTERRUPT 17h (PRINTER CONTROL) RUN THIS PROGRAM EVERY TIME IT OCCURS
;Inputs:
;Outputs:
;Changes:
;------------------------------------------------------------------------------
Int17Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int17:
  PUSHF                     ;Save flags
  STI                       ;Enable interrupts
  CLD                       ;Go forward with string functions
  CALL HandleInt17Ext       ;Handle Int 17h Extended Functions
  JNC >V95                  ;If handled, we're done
  CALL HandleRedirect       ;Handle a Redirect, if appropriate
  JC  >V95                  ;If handled, we're done
  CALL MakeStack            ;Set up our own Stack Space
  PUSH BX,DS,ES             ;Save used registers
  MOV  DS,CS                ;Point DS at TSR Data Area
  MOV  ES,CS                ;Point ES at TSR Data Area
  CALL TestDXIsOursES       ;Is it for one of our ports (rtns BX)?
  JZ   Int17Old             ;If not, quit
  CMP  AH,I17FGetStatus     ;Valid function number?
  JA   Int17Old             ;If not, error
  JE  >V20                  ;If Get Status Function, handle it
  OR   AH,AH                ;Is it function 1 (Initialize Port)?
  JNZ >V10                  ;If so, handle it
V00:                        ;Function 0 (Write Character AL)
  CALL StartEpson           ;Initialize Epson Printer, if needed
  CALL SendCharBX           ;Do it (returns AH = Status)
  JMP >V90                  ;Done
V10:                        ;Function 1 (Initialize Port)
  CALL RlsAllBuffersDvcBX   ;Clear out our buffers
  CALL DoSoftResetBX        ;Send Soft Reset
  OR   [BX].DIFlags,DIFlagInitEpson ;Mark as needing special Epson Init
V20:                        ;Function 2 (Get Status)
  CALL GetStatusBX          ;Get the Status (AH)
  AND  AH,(NOT PStsTimeout) ;Make sure Timeout is not set
                            ;  (Timeout only applies to Function 0)
V90:                        ;Done
  POP  ES,DS,BX             ;Restore used registers
  CALL ReturnStack          ;Restore Original Stack Space
V95:                        ;Done, don't restore registers
  POPF                      ;Restore flags
  IRET

Int17Old:
  POP  ES,DS,BX                ;Restore used registers
  CALL ReturnStack             ;Restore Original Stack Space
  CALL D CS:Int17Hdr.OldVector ;Let original handler process it
  IRET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE FOR INT 17H EXTENDED FUNCTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST FOR & HANDLE A PRINTER THAT HAS BEEN REDIRECTED
;Inputs:  CS = TSR Data Area
;         AH = INT 17h Function Number (0-2)
;         DX = LPT Index
;         Redirect Table
;Outputs: CF = Set if Printer has been redirected (Redirect has been issued)
;              Returns registers as processed by the Redirect
;            = Clear if Printer is not redirected (needs to be handled)
;Changes:
;NOTES: This Routine also does something "funny" with DX.  It needs to change
;         DX before performing the Redirection call.  "Standard" Parallel Port
;         calls do not return any values in DX, but some extended functions do.
;         Since we will not know if a call is "special" or not, we perform
;         a test.  If DX remains unchanged across the Redirection, we assume
;         it would have also remained unchanged if it were not redirected,
;         and restore the original value of DX.  If DX did change across the
;         redirection, we return the changed value of DX.
;------------------------------------------------------------------------------
HandleRedirect:
  PUSH BP                 ;Save used registers
  CMP  AH,2               ;Is it function 0-2?
  JA  >R80                ;If not, don't do anything
  CMP  DX,(MaxPrinters-1) ;Is it a legitimate Printer Index?
  JA  >R80                ;If not, don't do anything
  CALL TestIndexRedir     ;Is it Redirected?
  JNC >R80                ;If not, don't do anything
  SUB  SP,4               ;Make room in the stack for 2 words
  MOV  BP,SP              ;Use BP as the stack pointer
  MOV  SS:[BP+0],DX       ;Save original DX
  CALL ConvertIndexDX     ;Get Redirected Index (DX)
  MOV  SS:[BP+2],DX       ;Save new DX
  INT  17h                ;Perform the Function
  CMP  DX,SS:[BP+2]       ;Did DX change across the redirected call?
  JNE >R70                ;If so, leave it at the new value
  MOV  DX,SS:[BP+0]       ;If not, restore the original value
R70:                      ;Redirect has been handled
  ADD  SP,4               ;Restore original Stack Pointer
  STC                     ;Set handled flag
  JMP >R90                ;Done
R80:                      ;Not Redirected
  CLC                     ;Set not-handled flag
R90:                      ;Done
  POP  BP                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST FOR AND HANDLE INT 17h EXTENDED FUNCTIONS
;Inputs:  CS = TSR Data Area
;         AX,BX,CX,DX as issued by calling program
;Outputs: CF = Clear if it was an extended call, and has been handled
;              AX,BX,CX,DX as appropriate for return codes and values
;            = Set if not an extended call
;              AX,BX,CX,DX unchanged
;Changes:
;------------------------------------------------------------------------------
HandleInt17Ext:
  PUSH DI,BP,ES             ;Save used registers
  CMP  AH,1Bh               ;Extended function?
  JNE >X75                  ;If not, quit
  MOV  ES,CS                ;Point ES at TSR Data Area
  MOV  DI,BX                ;Save original BX value
  MOV  BX,I17ExtFuncTbl     ;See if it's a
  CALL SearchByte2WordTblES ;  valid Function (Rtns CF,BX)
  XCHG DI,BX                ;Restore original BX value
  MOV  BP,I17ErrBadFunction ;Assume invalid function
  JC  >X70                  ;If invalid function, we're done
  CALL DI                   ;Do the function
  JNC >X80                  ;If for us, we're done
  JMP >X75                  ;If not for us, quit
X70:                        ;BP contains Error Code
  MOV  AX,BP                ;Put Error code in AX
X75:                        ;We did not handle the call
  STC                       ;Set not-for-us flag
  JMP >X90                  ;Done
X80:                        ;Call is handled
  CLC                       ;Set handled flag
X90:                        ;Done
  POP  ES,BP,DI             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INT 17h EXTENDED FUNCTION - INSTALLATION CHECK
;Inputs:  ES = TSR Data Area
;         AX = Function Input value
;         BX = 'LP' (4C50h)
;         CX = 'T!' (5421h)
;         DX = -1 (for General Check) or LPT Index (for Specific Check)
;Outputs: If Valid input values and DX = -1 (General Check):
;           CF = Clear
;                AX = 0
;                BX = 'T!' (5421h)
;                CX = 'LP' (4C50h)
;                DX = Unchanged
;         If valid input values and DX is a port that we control
;           (Parallel or USB):
;           CF = Clear
;                AX = 0
;                BX = API version
;                CX,DX = Unchanged
;         If invalid values:
;           CF = Set
;                AX,BX,CX,DX = Unchanged
;Changes:
;------------------------------------------------------------------------------
InstallCheck:
  PUSH DX                 ;Save used registers
  CMP  BX,'LP'            ;Valid value in BX?
  JNE >I70                ;If not, it's not for us
  CMP  CX,'T!'            ;Valid value in CX?
  JNE >I70                ;If not, it's not for us
  CMP  DX,-1              ;General Install Check?
  JNE >I20                ;If not, try Specific Install Check
  XCHG BX,CX              ;Set return values
  JMP >I80                ;Done
I20:                      ;Not General Install Check
  CALL ConvertIndexDX     ;Convert LPT Index to Redirected Index (DX)
  CALL TestDXIsOursESNoBX ;Is it one of our USB Ports?
  JNZ >I50                ;If so, handle it
  CALL TestDXIsParallel   ;Is it a parallel port?
  JZ  >I70                ;If not, it's not for us
I50:                      ;Valid Specific Call
  MOV  BX,Int17APIVersion ;BX = API Version
  JMP >I80                ;Done
I70:                      ;Call is not for us
  STC                     ;Mark as not-for-us
  JMP >I90                ;Done
I80:                      ;Is Installation Check for one of our Ports
  XOR  AX,AX              ;Set Return value
  CLC                     ;Mark as handled
I90:                      ;Done
  POP  DX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INT 17h EXTENDED FUNCTION - GET REDIRECT TABLE ADDRESS
;Inputs:  ES = TSR Data Area
;         AX = Function Input value
;         DX = -1
;Outputs: If we own the Redirect Table and DX = -1:
;           CF = Clear (Call is Complete)
;                AX    = 0
;                CX:BX = Segment:Offset of Redirect Table
;                DX    = Unchanged
;         If we do not own the Redirect Table and DX = -1:
;           CF = Set (Call is not for us)
;                AX,BX,CX,DX = Unchanged
;         If DX <> -1:
;           CF = Clear (Call is Complete)
;                AX = Error Code (Bad Index)
;                BX,CX,DX = Unchanged
;Changes:
;------------------------------------------------------------------------------
GetRedirTblAddr:
  CMP  DX,-1                    ;Correct Index?
  JNE >T80                      ;If not, Error
  TEST ES:TSRFlags,RedirTblHere ;Do we own the Redirect Table?
  JZ  >T70                      ;If not, quit
  XOR  AX,AX                    ;Mark AX as successful
  MOV  BX,RedirectTable         ;Point BX at the Table Offset
  MOV  CX,ES                    ;Point CX at Segment
  JMP >T85                      ;Done
T70:                            ;Call is not for us
  STC                           ;Set not-for-us flag
  JMP >T90                      ;Done
T80:                            ;Invalid Index
  MOV  AX,I17ErrBadIndex        ;Set Error Code
T85:                            ;Call is complete
  CLC                           ;Set for-us flag
T90:                            ;Done
  RET

;------------------------------------------------------------------------------
;INT 17h EXTENDED FUNCTION - OWNER OF REDIRECTION TABLE IS GOING AWAY
;Inputs:  ES = TSR Data Area
;         AX = Function Input value
;         DX = -1
;         CLD already issued
;Outputs: If we currently own the Redirect Table and DX = -1:
;           CF = Set (indicating the call is not complete yet, and must be
;                  passed on to other INT 17h Owners)
;                AX,BX,CX,DX = Unchanged
;         If we do not currently own the Redirect Table and DX = -1:
;           CF = Clear (indicating the call is complete)
;                Redirect table is copied from current owner
;                TSRFlags.RedirTblHere is Set (we are now the Owner)
;                AX = 0
;                BX,CX,DX = Unchanged
;         If DX <> -1:
;           CF = Clear (Call is Complete)
;                AX = Error Code (Bad Index)
;                BX,CX,DX = Unchanged
;Changes:
;------------------------------------------------------------------------------
RedirGoingAway:
  PUSH BX,CX,DX,DI,SI,DS              ;Save used registers
  CMP  DX,-1                          ;Correct Index?
  JNE >R80                            ;If not, Error
  TEST ES:TSRFlags,RedirTblHere       ;Are we the Owner?
  JNZ >R70                            ;If so, don't do anything
  MOV  AX,(1B00h+I17FGetRedirTblAddr) ;Function = Get Address (DX = -1 already)
  INT  17h                            ;Do it (Returns BX:CX = Table Address)
  MOV  DS,CX                          ;Point DS:[SI] at
  MOV  SI,BX                          ;  the current Table
  MOV  DI,RedirectTable               ;Point ES:[DI] at our Table
  MOV  CX,MaxPrinters                 ;Number of bytes to copy
  REP  MOVSB                          ;Copy the Table to our data area
  OR   ES:TSRFlags,RedirTblHere       ;Mark us as the Owner
  XOR  AX,AX                          ;Set Return Flag
  JMP >R85                            ;Done
R70:                                  ;Call is not complete
  STC                                 ;Set incomplete flag
  JMP >R90                            ;Done
R80:                                  ;Bad Index
  MOV  AX,I17ErrBadIndex              ;Set Error Code
R85:                                  ;Call is Complete
  CLC                                 ;Set completed flag
R90:                                  ;Done
  POP  DS,SI,DI,DX,CX,BX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INT 17h EXTENDED FUNCTION - GET PORT REDIRECTION STATUS
;Inputs:  ES = TSR Data Area
;         AX = Function Input value
;         DX = LPT Index
;Outputs: If we own the Redirect Table, CF = Clear (Call is Complete)
;           If valid Input Values:
;             AX = 0
;             BX = Ultimate Redirected Port Index
;                    (if Index is Redirected to an Index that is itself
;                     Redirected, the "final" Index is Returned)
;                = DX if Port is not Redirected
;             CX,DX = Unchanged
;           If invalid Input values:
;             AX = Error Code
;             BX,CX,DX = Unchanged
;         If we don't own the Redirect Table, CF = Set (pass call to owner)
;Changes:
;------------------------------------------------------------------------------
GetPortRedirect:
  PUSH CX,DX                    ;Save used registers
  TEST ES:TSRFlags,RedirTblHere ;Are we the Table Owner?
  JZ  >G70                      ;If not, the call is not for us
  MOV  CX,I17ErrBadIndex        ;Assume Bad Index
  CMP  DX,(MaxPrinters-1)       ;Valid Index?
  JA  >G80                      ;If not, error
  XOR  CX,CX                    ;Set Error Code
  CALL GetRedirIndexDX          ;Get the Redirected Index (DX)
  MOV  BX,DX                    ;Put it in BX for the Return
  JMP >G80                      ;Done
G70:                            ;Call is not for us
  STC                           ;Set not-for-us flag
  JMP >G90                      ;Done
G80:                            ;Call is complete
  MOV  AX,CX                    ;Put Error Code in AX
  CLC                           ;Set complete flag
G90:                            ;Done
  POP  DX,CX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INT 17h EXTENDED FUNCTION - SET PORT REDIRECTION
;Inputs:  ES = TSR Data Area
;         AX = Function Input value
;         DX = LPT Index to Redirect From
;         BX = LPT Index to Redirect To
;Outputs: If we own the Redirect Table, CF = Clear (Call is Complete)
;           If valid Input Values:
;             AX = 0
;             BX,CX,DX = Unchanged
;           If invalid Input values:
;             AX = Error Code
;             BX,CX,DX = Unchanged
;         If we don't own the Redirect Table, CF = Set (pass call to owner)
;Changes:
;NOTES: This uses the same Error Code (I17ErrBadRedirIndex), whether the
;         cause of the Error is a Bad Redirection Index Number (>8),
;         or whether the cause is a Redirected Port that is itself Redirected.
;         If the user knows that the Index given was a valid number (which
;         they should), they can safely assume that the cause was a
;         double-Redirection.
;------------------------------------------------------------------------------
SetPortRedirect:
  PUSH BX,CX,DX,DI              ;Save used registers
  TEST ES:TSRFlags,RedirTblHere ;Are we the Table Owner?
  JZ  >S70                      ;If not, the call is not for us
  MOV  CX,I17ErrBadIndex        ;Assume Bad Index
  CMP  DX,(MaxPrinters-1)       ;Valid Index?
  JA  >S80                      ;If not, error
  MOV  CX,I17ErrBadRedirIndex   ;Assume Bad Redirect Index
  CMP  BX,(MaxPrinters-1)       ;Valid Index?
  JA  >S80                      ;If not, error
  MOV  DI,RedirectTable         ;Point at the Redirect Table
  CMP  BX,DX                    ;Are we Un-Redirecting?
  JE  >S20                      ;If so, no need to do the test
  CMP  B ES:[BX+DI],0           ;Is the To Index Redirected?
  JNE >S80                      ;If so, Error
S20:                            ;To Index tested for Redirection
  XCHG BX,DX                    ;BX = From Index, DX = To Index
  CMP  BX,DX                    ;Are we Un-Redirecting?
  JNE >S30                      ;If not, continue
  MOV  DL,-1                    ;If so, we need to reset to 0
S30:                            ;DL contains Redir Index to use
  INC  DL                       ;Change To Index to a Port Number
  MOV  ES:[BX+DI],DL            ;Store it
  XOR  CX,CX                    ;Set Error Code
  JMP >S80                      ;Done
S70:                            ;Call is not for us
  STC                           ;Set not-for-us flag
  JMP >S90                      ;Done
S80:                            ;Call is complete
  MOV  AX,CX                    ;Put Error Code in AX
  CLC                           ;Set complete flag
S90:                            ;Done
  POP  DI,DX,CX,BX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INT 17h EXTENDED FUNCTION - START NEW PRINT JOB
;Inputs:  ES = TSR Data Area
;         AX = Function Input value
;              (AH = 1Bh)
;              (AL = I17FJobStart, I17FJobEnd, or I17FJobCancel)
;         DX = LPT Index
;         CLD already issued
;Outputs: If valid Input Values:
;           CF = Clear (Call is Complete)
;           AX = 0
;           BX,CX,DX = Unchanged
;         If invalid Input Values:
;           CF = Set (Call is not for us)
;           AX,BX,CX,DX = Unchanged
;Changes:
;NOTES: This will process a job either from a Parallel Port or a USB Device
;         that we are controlling.  If it's not a port that we control,
;         this passes the call on as incomplete.
;------------------------------------------------------------------------------
JobStart:
JobEnd:
JobCancel:
  PUSH BX,CX,DX,DS        ;Save used registers
  MOV  DS,ES              ;Point DS at TSR Data Area
  CALL ConvertIndexDX     ;Convert LPT Index to Redirected Index
  CALL TestDXIsOursDS     ;Is it one of our USB Ports?
  JNZ >J10                ;If so, continue
  CALL TestDXIsParallel   ;Is it a Parallel Port?
  JZ  >J70                ;If not, it's not for us
J10:                      ;Is for us
  CMP  AL,I17FJobCancel   ;Is it Job Cancel?
  JE  >J40                ;If so, jump to handle it
J15:                      ;Job Start or End
  CALL WaitTilNormal10    ;If Start or End, wait for the Printer to be Normal
  JC  >J82                ;If not Normal, Error
  OR   BX,BX              ;Parallel or USB?
  JZ  >J30                ;If Parallel, handle it
J20:                      ;USB Start or End
  CMP  [BX].DIBufferPtr,0 ;Still waiting for Buffers to Clear?
  JNE  J20                ;If so, keep waiting
  JMP >J80                ;Done
J30:                      ;Parallel Start or End
  JMP >J80                ;Just quit
J40:                      ;Job Cancel
  OR   BX,BX              ;Parallel or USB?
  JNZ >J50                ;If Parallel, handle it
J45:                      ;Parallel Job Cancel
  JMP >J52                ;Jump to Reset it
J50:                      ;USB Job Cancel
  CLI                     ;Disable Interrupts
  CALL RlsAllBuffersDvcBX ;Release any pending buffers
J52:                      ;Reset Printer right now
  MOV  AH,I17FInitialize  ;Function = Initialize/Reset
  INT  17h                ;Do it
  STI                     ;Enable interrupts
  JMP >J80                ;Done
J70:                      ;Not for us
  STC                     ;Set not-for-us flag
  JMP >J90                ;Done
J80:                      ;Call is Complete, No Error
  XOR  AX,AX              ;Set Return Code
  JMP >J85                ;Done
J82:                      ;Call is Complete, Error
  MOV  AX,I17ErrBadIndex  ;Set Error Code = Bad Index
J85:                      ;Call is Complete
  CLC                     ;Set complete flag
J90:                      ;Done
  POP  DS,DX,CX,BX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WAIT FOR THE PRINTER TO BE IN A NORMAL STATUS
;Inputs:  DX = LPT Index to Wait For
;Outputs: CF = Clear if OK (Printer Normal/Ready)
;            = Set if Error (Printer Abnormal/Unavailable)
;Changes:
;NOTES: This returns immediately immediately with Error if no Printer is
;         attached.  It waits a maximum of 10 seconds if a Printer is attached,
;         but is in an abnormal status.
;------------------------------------------------------------------------------
WaitTilNormal10:
  PUSH AX,CX            ;Save used registers
  MOV  CX,1000          ;Wait a maximum of 10 seconds
Y10:                    ;Loop to here to wait for normality
  MOV  AH,I17FGetStatus ;Function = Get Status
  INT  17h              ;Do it
  CMP  AH,I17FGetStatus ;Valid Port?
  JE  >Y70              ;If not, error
  CMP  AH,PStsNoPrinter ;Is a Printer attached?
  JE  >Y70              ;If not, Error
  CMP  AH,PStsNormal    ;Is it Normal?
  JE  >Y80              ;If so, we're done
  CALL Delay10MS        ;If not, wait 10 milliseconds
  LOOP Y10              ;Test again
Y70:                    ;Error (Abnormal Status)
  STC                   ;Set return flag
  JMP >Y90              ;Done
Y80:                    ;OK (Normal Status)
  CLC                   ;Set return flag
Y90:                    ;Done
  POP  CX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INT 17h EXTENDED FUNCTION - GET DEVICE ID STRING OR TX/RX BLOCK OF DATA
;Inputs:  ES      = TSR Data Area
;         AX      = Function Input value
;                   (AH = 1Bh)
;                   (AL = I17FGetDeviceIDString, I17FTxBlock, or I17FRxBlock)
;         DS:[BX] = Buffer where Data is (or will be) stored
;         CX      = Maximum Size of Buffer or Number of Bytes to Tx
;         DL      = LPT Index
;         DH      = Timeout Value to use (seconds), 0 = use default
;Outputs: If valid Input Values:
;           CF = Clear (Call is Complete)
;           AX = 0 or I17ErrIncompleteXfer
;           CX = Number of Bytes actually transferred
;           BX,DX = Unchanged
;         If invalid Input values:
;           CF = Set (Call is not for us)
;           AX,BX,CX,DX = Unchanged
;Changes:
;NOTES: This will get/send Data either from a Parallel Port
;         or a USB Device that we are controlling.  If not, this passes
;         the call on as incomplete.
;------------------------------------------------------------------------------
TxBlock:
RxBlock:
GetDvcIDString:
  PUSH BX,DX,DI,SI,BP          ;Save used registers
  MOV  BP,DX                   ;Save original DX (need to save DH)
  XOR  DH,DH                   ;Set DH to 0
  CALL ConvertIndexDX          ;Convert LPT Index to Redirected Index
  XOR  DI,DI                   ;Assume USB Port
  CALL TestDXIsOursESNoBX      ;Is it one of our USB Ports?
  JNZ >V10                     ;If so, handle it
  DEC  DI                      ;Assume Parallel
  CALL TestDXIsParallel        ;Is it a Parallel Port?
  JZ  >V70                     ;If not, it's not for us
V10:                           ;Is for us
  MOV  SI,I17ErrBadSize        ;Assume Bad Buffer Size
  OR   CX,CX                   ;Valid Buffer Size?
  JZ  >V85                     ;If not, we're done
  XOR  SI,SI                   ;Set Error Code
  OR   DI,DI                   ;Is it USB?
  JZ  >V30                     ;If so, handle it

V20:                           ;Is Parallel Port
  MOV  DI,BX                   ;Put Buffer Pointer in DI
  CALL StartBlockTimeout       ;Start the Timeout Counter (rtns [BX])
  CMP  AL,I17FTxBlock          ;Is it Tx, Rx, or Get Device ID?
  MOV  AX,CX                   ;Save Requested Size
  JB  >V26                     ;If Get Device ID, jump to handle it
  JA  >V24                     ;If Rx Block, jump to handle it
V22:                           ;Tx Block Parallel
  CALL SendDataParallel        ;Send the Data (returns CX)
  JMP >V28                     ;Continue
V24:                           ;Rx Block Parallel
  CALL LPTIndex2IOAddrDX       ;Convert LPT Index to I/O Address (DX)
  CALL GetDataParallel         ;Get the Data (returns CX)
  JMP >V28                     ;Continue
V26:                           ;Get Device ID Parallel
  CALL LPTIndex2IOAddrDX       ;Convert LPT Index to I/O Address (DX)
  CALL GetDvcIDParallel        ;Get the Data (returns CX)
V28:                           ;Data is downloaded
  CALL ResetBlockTimeout       ;Reset the Block Timeout Entry
  JMP >V80                     ;Done

V30:                           ;Is USB Port
  MOV  DI,BX                   ;Put Buffer Pointer in DI
  CALL TestDXIsOursES          ;Get the Info Table Index (BX)
  CALL StartEpson              ;Initialize Epson Printer, if needed
  CMP  AL,I17FTxBlock          ;Is it Tx, Rx, or Get Device ID?
  MOV  DX,BP                   ;Restore original DX (DH = Timeout Seconds)
  MOV  AX,CX                   ;Save Requested Size
  JB  >V36                     ;If Get Device ID, jump to handle it
  JA  >V34                     ;If Rx Block, jump to handle it
V32:                           ;Tx Block USB
  CALL SendDataBX              ;Send the Data (returns CX)
  JMP >V38                     ;Continue
V34:                           ;Rx Block USB
  CALL GetDataBX               ;Get the Data (returns CX)
  JMP >V38                     ;Continue
V36:                           ;Get Device ID USB
  CALL GetDeviceIDBX           ;Get the Data (returns CX)
V38:                           ;Data is downloaded
  JMP >V80                     ;Done

V70:                           ;Not for us
  STC                          ;Set not-for-us flag
  JMP >V90                     ;Done
V80:                           ;Call is Complete (CF = Set if Timeout Error)
  JNC >V82                     ;If no Timeout Error, check for Incomplete Xfer
  MOV  SI,I17ErrBlockTimeout   ;If so, mark as a Timeout Error
  JMP >V85                     ;Continue
V82:                           ;Not a Timeout Error
  CMP  AX,CX                   ;Was it a complete Xfer?
  JE  >V85                     ;If so, we're done
  MOV  SI,I17ErrIncompleteXfer ;If not, mark as an Incomplete Xfer
V85:                           ;SI contains Error Code
  MOV  AX,SI                   ;Put Error Code in AX
  CLC                          ;Set complete flag
V90:                           ;Done
  POP  BP,SI,DI,DX,BX          ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;SEND (TRANSMIT) OR DOWNLOAD (RECEIVE) A BLOCK OF DATA TO/FROM A USB DEVICE
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;------------------------------------------------------------------------------
;SEND OR RECEIVE A BLOCK OF DATA TO/FROM A USB DEVICE
;Inputs:  ES      = TSR Data Area
;         DS:[DI] = Buffer where Data is (or will be) Stored
;         ES:[BX] = Info Table Entry
;         CX      = Number of Bytes to Transmit/Receive (not 0!)
;         DH      = Timeout Seconds to use (as requestd by user)
;Outputs: Sends Data From Buffer to USB Device (or Vice Versa)
;         CF = Clear if no Timeout Error
;            = Set if Timeout Error Occurred
;         CX = Number of Bytes Actually Sent
;Changes:
;NOTES: This sets a default Timeout Value for the Bulk Transaction that is
;         proportional to the number of bytes requested.  It uses a
;         Timeout of 5 seconds plus 1/2 second for every 1000 bytes
;         of data.  The user can also override the default value with
;         a value of his own (using the DH register on the initial
;         INT 17h call).
;       It is possible for the transfer to be unsuccessful and yet for some
;         or all of the data to still be transferred -- the value returned
;         in CX should be checked.
;------------------------------------------------------------------------------
SendDataBX:
  PUSH DX                        ;Save used registers
  XOR  DL,DL                     ;Mark as Send Data
  JMP >T00                       ;Do it
GetDataBX:
  PUSH DX                        ;Save used registers
  MOV  DL,-1                     ;Mark as Get Data
;  JMP >T00                       ;Do it
T00:
  PUSH AX,SI,DS                  ;Save used registers
  LEA  SI,[BX].DIInt14Request    ;Point [SI] at Local Request Structure
  MOV  W ES:[SI].I14RDataAddress[2],DS   ;Store Data Segment
  MOV  DS,ES                     ;Point DS at TSR Data Area
  MOV  W [SI].I14RDataAddress[0],DI ;Store Data Offset
  MOV  [SI].I14RDataSize,CX      ;Store Data Size
  MOV  [SI].I14RRequestType,I14RRTDoBulk ;Request = Bulk
  CALL CalcTimeoutDSecs          ;Calculate Timeout (AX Deciseconds)
  MOV  [SI].I14RTimeout,AX       ;Store it
  MOV  W [SI].I14RCallBackAddr[0],DataRtn ;Go Here when done
  MOV  [SI].I14RUserPktID,BX     ;Store Device Info Pointer in Request
  PUSH W [BX].DIHostIndex        ;Copy Host Index
  POP  W [SI].I14RHostIndex      ;  and Device Address
  MOV  [BX].DIDataRtnAX,-1       ;Initialize Local DataRtnAX to -1
  MOV  [BX].DIDataRtnCX,0        ;Initialize Local DataRtnCX to 0
  OR   DL,DL                     ;Is it Tx or Rx data?
  JNZ >T20                       ;If Rx, jump to handle it
T10:                             ;Tx Data
  MOV  [SI].I14RFlags,0          ;Direction = Out
  MOV  AL,[BX].DIEndPointOut     ;Get Out End Point
  JMP >T30                       ;Continue
T20:                             ;Rx Data
  MOV  [SI].I14RFlags,I14RFlagIn ;Direction = In
  MOV  AL,[BX].DIEndPointIn      ;Get In End Point
  OR   AL,AL                     ;Is it a 2-way Device?
  JZ  >T60                       ;If not, we're done
T30:                             ;Request Data is filled in
  MOV  [SI].I14REndPoint,AL      ;Store End Point
  CALL DoInt14CallSaveAllSI      ;Do it
  JC  >T60                       ;If error, we're done
T50:                             ;Loop to here to wait for Data
  CMP  [BX].DIDataRtnAX,-1       ;Is the transaction done yet?
  JE   T50                       ;If not, keep waiting
T60:                             ;Done with Transfer
  MOV  [SI].I14RFlags,0          ;Reset Flags
  MOV  [SI].I14RTimeout,0        ;Reset Timeout
  MOV  W [SI].I14RDataAddress[2],DS ;Restore TSR Data Segment
  MOV  CX,[BX].DIDataRtnCX       ;CX = Number of Bytes Xfered
  TEST B [BX].DIDataRtnAX,TDStsTimeout ;Did we Timeout?
  JZ  >T80                       ;If not, handle it
T70:                             ;Timeout Error
  STC                            ;Set return flag
  JMP >T90                       ;Done
T80:                             ;No Timeout
  CLC                            ;Set return flag
T90:                             ;Done
  POP  DS,SI,AX                  ;Restore used registers
  POP  DX                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs:  CS = DS = ES = TSR Data Area
;        [BX] = Local [DataRtnAX]
;------------------------------------------------------------------------------
DataRtn:
  MOV  [BX].DIDataRtnAX,AX ;Store the Error Code
  MOV  [BX].DIDataRtnCX,CX ;Store the number of Bytes Xfered
  RETF


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;DOWNLOAD THE DEVICE ID STRING FROM A USB DEVICE
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;------------------------------------------------------------------------------
;DOWNLOAD THE DEVICE ID STRING FROM A USB DEVICE
;Inputs:  ES      = TSR Data Area
;         DS:[DI] = Buffer to put the data in
;         ES:[BX] = Info Table Entry
;         CX      = Maximum Size of Buffer (should not be 0!)
;         DH      = Timeout Seconds to use (as requestd by user)
;Outputs: Fills Buffer with Data
;         CF = Clear if no Timeout Error
;            = Set if Timeout Error Occurred
;         CX = Number of Bytes Received
;            = 0 if Any Errors occurred during Transfer, other than Short Pkt
;                or Timeout
;Changes:
;NOTES: The calling program generally has no idea how long the Device ID
;         string might be before it is downloaded, so will typically have
;         a buffer much larger than what is actually needed.  Therefore,
;         a short packet during the transfer is not considered an error.
;------------------------------------------------------------------------------
GetDeviceIDBX:
  PUSH AX,SI,DS                 ;Save used registers
  LEA  SI,[BX].DIInt14Request   ;Point [SI] at Local Int 14h Req
  MOV  W ES:[SI].I14RDataAddress[2],DS ;Store Data Segment
  MOV  DS,ES                    ;Point DS at TSR Data Area
  MOV  W [SI].I14RDataAddress[0],DI ;Store Data Offset
  PUSH CX                       ;Save size for a second
  MOV  CX,GetDvcIDReq           ;Copy Request
  CALL CopySetupReqToInt14SI    ;  to Int 14h Structure
  POP  CX                       ;Restore Size
  MOV  W [SI].I14RGetDvcIDSize,CX ;Put size in the Request
  MOV  [SI].I14RRequestType,I14RRTGetDvcStatus ;Request = Get Device Status
  MOV  [SI].I14RFlags,0         ;Request Flags = 0
  MOV  [SI].I14RTimeout,0       ;Timeout = Default
  MOV  AX,W [BX].DIHostIndex    ;Copy Host Index
  MOV  W [SI].I14RHostIndex,AX  ;  and Device Address
  MOV  [SI].I14REndPoint,0      ;EndPoint 0
  MOV  AX,W [BX].DIInterfaceNum      ;Copy Interface
  XCHG AL,AH                         ;  and
  MOV  W [SI].I14RGetDvcIDAltIntf,AX ;  Alt Interface
  CALL DoInt14CallCXSI          ;Do it (Rtns CL = Config Value)
  JC  >I70                      ;If error, quit
  DEC  CL                       ;Convert Config Value to 0-based
  MOV  B [SI].I14RGetDvcIDCfgIndex,CL ;Store the Config Index
  MOV  [SI].I14RRequestType,I14RRTDoControl ;Request = Control
  MOV  W [SI].I14RCallBackAddr[0],DataRtn ;Go Here when done
  CALL CalcTimeoutDSecs         ;Calculate the Timeout (AX)
  MOV  [SI].I14RTimeout,AX      ;Store it
  MOV  [SI].I14RUserPktID,BX    ;Store Device Info Pointer in Req
  MOV  [BX].DIDataRtnAX,-1      ;Initialize completion indicator
  MOV  [BX].DIDataRtnCX,0       ;Initialize Byte Count
  CALL DoInt14CallSaveAllSI     ;Do it
  JC  >I70                      ;If error, quit
I20:                            ;Loop to here to wait for Data
  MOV  AX,[BX].DIDataRtnAX      ;Get the TD return value
  CMP  AX,-1                    ;Is the Request done yet?
  JE   I20                      ;If not, keep waiting
  MOV  CX,[BX].DIDataRtnCX      ;CX = Number of Bytes Xfered
  TEST AL,TDStsTimeout          ;Was there a Timeout Error?
  JZ  >I80                      ;If not, handle it
I70:                            ;Timeout Error
  STC                           ;Set return flag
  JMP >I90                      ;Done
I80:                            ;No Timeout
  TEST AX,(NOT TDStsShortPacket) ;Any errors (besides Short Pkt)?
  JZ  >I85                      ;If not, we're OK
  XOR  CX,CX                    ;If so, set CX to 0
I85:                            ;No error
  CLC                           ;Set return flag
I90:                            ;Done
  MOV  W [SI].I14RDataAddress[2],DS ;Restore TSR Data Segment
  MOV  [SI].I14RTimeout,0       ;Restore Default Timeout
  POP  DS,SI,AX                 ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;SEND (TRANSMIT) A BLOCK OF DATA TO A PARALLEL DEVICE
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;SEND A BLOCK OF DATA TO A PARALLEL-ATTACHED DEVICE
;Inputs:  ES = TSR Data Area
;         ES:[BX] = Block Timeout Entry (filled in)
;         DS:[DI] = Buffer where data is stored
;         CX      = Maximum Size of Buffer (should not be 0!)
;         DX      = LPT Index (NOT I/O Address!)
;         CLD Already issued
;Outputs: Sends Buffer Data to Device
;         CX = Number of Bytes Xfered
;         CF = Clear if no Timeout Error
;            = Set if Timeout Error occurred
;Changes:
;------------------------------------------------------------------------------
SendDataParallel:
  PUSH AX,BX,DX,SI,BP           ;Save used registers
  XOR  BP,BP                    ;BP = Bytes Sent Counter
  MOV  SI,DI                    ;Point DS:[SI] at the Buffer
S10:                            ;Loop to here for each byte in the Buffer
  LODSB                         ;AL = Byte to send
S20:                            ;AL contains byte to send
  CMP  ES:[BX].BTCounter,0      ;Has the Block Timed out yet?
  JE  >S70                      ;If so, we're done
  MOV  AH,I17FSendByte          ;If not, Function = Send Byte
  PUSH BX                       ;Save BX (destroyed by some Print Spoolers)
  INT  17h                      ;Do it
  POP  BX                       ;Restore BX
  AND  AH,(NOT PStsACKnowledge) ;Mask out the ACK bit (if it's there)
  CMP  AH,PStsNormal            ;Did it work?
  JNE  S20                      ;If not, keep trying with the same byte
  INC  BP                       ;Increment Byte Counter
  LOOP S10                      ;Keep going until the buffer is empty
  JMP >S80                      ;When all the bytes are sent, we're done
S70:                            ;Timeout Error
  STC                           ;Set return flag
  JMP >S90                      ;Done
S80:                            ;No Timeout Error
  CLC                           ;Set return flag
S90:                            ;Done
  MOV  CX,BP                    ;Store number of bytes sent
  POP  BP,SI,DX,BX,AX           ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;DOWNLOAD (RECEIVE) A BLOCK OF DATA FROM A PARALLEL DEVICE
;This uses Nibble Mode, and downloads either the Device ID String or whatever
;  data the Device has available (depending on the Request).
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;DOWNLOAD SOME DATA FROM A PARALLEL-ATTACHED DEVICE
;Inputs:  ES = TSR Data Area
;         ES:[BX] = Block Timeout Entry (filled in)
;         DS:[DI] = Buffer to put the data in
;         CX      = Maximum Size of Buffer (should not be 0!)
;         DX      = Base I/O Address
;Outputs: Fills Buffer with Data
;         CF = Clear if no Timeout Error
;            = Set if Timeout Error occurred
;         CX = Number of Bytes Received (0 if Error)
;Changes:
;NOTES: Peripheral devices are allowed a maximum of 35ms to respond to
;         1284 requests for the Host.  In this routine, we allow 50ms.
;       Block Timeouts, as such, don't apply to a parallel port.
;------------------------------------------------------------------------------
GetDataParallel:
  PUSH AX                    ;Save used registers
  MOV  AX,GetDataParallelGo  ;AX = Code to Call
  JMP >L00                   ;Do it
GetDvcIDParallel:
  PUSH AX                    ;Save used registers
  MOV  AX,GetDvcIDParallelGo ;AX = Code to Call
;  JMP >L00                   ;Do it
L00:
  CALL AX                    ;Call the subroutine
  JC  >L70                   ;If not 1284-compatible, don't wait for Timeout
  CMP  ES:[BX].BTCounter,0   ;If 1284-compatible, have we timed out yet?
  JE  >L70                   ;If so, quit
  OR   CX,CX                 ;If OK, did we get any data?
  JNZ >L80                   ;If so, we're done
  JMP  L00                   ;If not, keep waiting
L70:                         ;Timeout Error
  STC                        ;Set return flag
  JMP >L90                   ;Done
L80:                         ;No Timeout
  CLC                        ;Set return flag
L90:                         ;Done
  POP  AX                    ;Restore used registers
  RET

GetDataParallelGo:
  PUSH AX                        ;Save used registers
  MOV  AL,IE1284Nibble           ;Extensibility Byte = Nibble Mode
  JMP >P00                       ;Do it
GetDvcIDParallelGo:
  PUSH AX                        ;Save used registers
  MOV  AL,IE1284DvcIDNibble      ;Extensibility Byte = Get Dvc ID Nibble Mode
;  JMP >P00                       ;Doit
P00:
  PUSH DX,SI,BP                  ;Save used registers
  MOV  SI,DX                     ;Save Base Address in SI
  MOV  BP,CX                     ;Save Byte Counter in BP
  OUT  DX,AL                     ;Send it
  INC  DX,2                      ;Get the
  IN   AL,DX                     ;  Control Port Data
  MOV  CH,AL                     ;Save it in CH
  AND  AL,(NOT HstSts1284Active) ;Set 1284Active
  OR   AL,HstStsHostBusy         ;Unset HostBusy
  OUT  DX,AL                     ;Send it
  DEC  DX                        ;Point at Status Port
  MOV  CL,50                     ;Wait for a maximum of 50ms
P10:                             ;Loop to here to wait for 1284 Response
  IN   AL,DX                     ;Get the Status Port Data
  TEST AL,PerStsPtrClk           ;Is PtrClk Low?
  JNZ >P15                       ;If not, keep waiting
  NOT  AL                        ;Are nDataAvail, XFlag, and AckDataReq High?
  TEST AL,(PerStsNDataAvail+PerStsXFlag+PerStsAckDataReq)
  JZ  >P20                       ;If so, continue
P15:                             ;Keep waiting
  CALL Delay1MS                  ;Wait for 1 millisecond
  DEC  CL                        ;Decrement the Delay Counter
  JNZ  P10                       ;If we haven't waited long enough, do it again
  JMP >P70                       ;We're done (No Bytes xfered, not 1284-compat)
P20:                             ;Device is 1284-compatible!
  INC  DX                        ;Get the
  IN   AL,DX                     ;  Control Port Data
  OR   AL,HstStsHostClk          ;Set HostClk
  OUT  DX,AL                     ;Send it (Strobe Data into peripheral)
  CALL Delay2US                  ;Wait for 2 microseconds
  AND  AL,(NOT (HstStsHostClk+HstStsHostBusy)) ;Set HostClk & HostBusy
  OUT  DX,AL                     ;Send it (acknowledges 1284 to peripheral)
  DEC  DX                        ;Point at Status Port
  MOV  CL,50                     ;Wait for a maximum of 50ms
P30:                             ;Loop to here to wait for Request Acceptance
  IN   AL,DX                     ;Get the Status Port Data
  TEST AL,PerStsXFlag            ;Is XFlag High (Peripheral accepted Request)?
  JNZ >P40                       ;If so, continue
  CALL Delay1MS                  ;Wait for 1 millisecond
  DEC  CL                        ;Decrement the Delay Counter
  JNZ  P30                       ;If we haven't waited long enough, do it again
  JMP >P72                       ;We're done (No Bytes xfered)
P40:                             ;Peripheral accepted the Request
  CALL Delay5MS                  ;Wait for 5 milliseconds
  CALL GetParallelData           ;Get the Data (Fills DvcIDBuffer)
                                 ;Returns BP = Actual Number of Bytes Xfered
  INC  DX                        ;Get the
  IN   AL,DX                     ;  Control Port Data
  OR   AL,HstSts1284Active       ;Unset 1284Active (start termination sequence)
  OUT  DX,AL                     ;Send it
  DEC  DX                        ;Point at the Status Port
P50:                             ;Wait for Peripheral to respond
  IN   AL,DX                     ;Get the Status Port Data
  TEST AL,PerStsPtrClk           ;Is PtrClk low (the peripheral responded)?
  JNZ  P50                       ;If not, keep waiting
  INC  DX                        ;Get the
  IN   AL,DX                     ;  Control Port Data
  OR   AL,HstStsHostBusy         ;Unset HostBusy
  OUT  DX,AL                     ;Send it
  DEC  DX                        ;Point at the Status Port
P60:                             ;Wait for Peripheral to respond
  IN   AL,DX                     ;Get the Status Port Data
  TEST AL,PerStsPtrClk           ;Is PtrClk low (the peripherl responded)?
  JZ   P60                       ;If not, keep waiting
  INC  DX                        ;Get the
  IN   AL,DX                     ;  Control Port Data
  AND  AL,(NOT HstStsHostBusy)   ;Set HostBusy
  OUT  DX,AL                     ;Send it
  JMP >P80                       ;Done
P70:                             ;No data Xfered - Not 1284-compatible
  XOR  BP,BP                     ;Set Bytes Xfered to 0
  STC                            ;Set return flag
  JMP >P80                       ;Continue
P72:                             ;No data Xfered - Not 1284-compatible
  XOR  BP,BP                     ;Set Bytes Xfered to 0
  CLC                            ;Set return flag
P80:                             ;Done (restore original Control Port Data)
  MOV  AL,CH                     ;Restore
  LEA  DX,[SI+2]                 ;  original
  OUT  DX,AL                     ;  Control Port Data
P90:                             ;Done
  MOV  CX,BP                     ;Return CX = Number of Bytes Xfered
  POP  BP,SI,DX                  ;Restore used registers
  POP  AX                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE ACTUAL DATA (2 NIBBLES AT A TIME) FROM THE PARALLEL PORT PERIPHERAL
;Inputs:  ES = TSR Data Area
;         ES:[BX] = Block Timeout Entry (filled in)
;         DS:[DI] = Buffer to put the Data In
;         BP      = Maximum size of Buffer
;         SI      = Base I/O Address
;         Nibble Mode already set
;Outputs: Fills Buffer with data
;         BP = Actual Number of Bytes Xfered
;Changes:
;------------------------------------------------------------------------------
GetParallelData:
  PUSH AX,CX,DX  ;Save used registers
  PUSH DI,SI     ;Save used registers
  LEA  DX,[SI+1] ;Point DX at the Status Port
  MOV  SI,BP     ;Put size of Buffer in SI
  XOR  BP,BP     ;BP = Byte Counter
  OR   SI,SI     ;Any data to Transfer?
  JZ  >G90       ;If not, quit
G10:             ;Loop to here for each byte of data
  CMP  ES:[BX].BTCounter,0 ;Have we timed out?
  JE  >G90       ;If so, quit
  IN   AL,DX     ;Get the Status Port Data
  TEST AL,(PerStsAckDataReq+PerStsNDataAvail) ;Are AckDataReq & nDataAvail Low?
  JNZ >G90       ;If not, done (perhipheral has no more data)
  CALL GetNibble ;If OK, get the Low Nibble (CL)
  MOV  [DI],CL   ;Store it
  CALL GetNibble ;Get the High Nibble (in Low Nibble of CL)
  MOV  CH,4      ;Move the data
  XCHG CL,CH     ;  into the
  SHL  CH,CL     ;  high nibble
  OR   [DI],CH   ;Store it
  INC  DI        ;Update String Pointer for next time
  INC  BP        ;Increment the Byte Counter
  DEC  SI        ;Decrement the Loop Counter
  JNZ  G10       ;If buffer is not full, keep downloading
G90:             ;Done
  POP  SI,DI     ;Restore used registers
  POP  DX,CX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET A NIBBLE FROM THE PARALLEL PORT PERIPHERAL
;Inputs:  DX = Base I/O Address + 1 (Status Port)
;         Calling program has verified that the peripheral has some data!
;Outputs: CL = Nibble from Peripheral
;Changes:
;------------------------------------------------------------------------------
GetNibble:
  PUSH AX,BX,DX                ;Save used registers
B10:                           ;Loop to here to wait for Data available
  IN   AL,DX                   ;Get the Status Port Data
  TEST AL,PerStsPtrClk         ;Is the Data available yet?
  JZ   B10                     ;If not, keep waiting
  INC  DX                      ;Get the
  IN   AL,DX                   ;  Control Port Data
  OR   AL,HstStsHostBusy       ;Unset HostBusy (Initiate Transfer)
  OUT  DX,AL                   ;Send it
  DEC  DX                      ;Point at Status Port
B20:                           ;Loop to here to wait for data ready
  IN   AL,DX                   ;Get the Status Port Data
  TEST AL,PerStsPtrClk         ;Is the Data ready from the peripheral yet?
  JNZ  B20                     ;If not, keep waiting
  AND  AL,(PerStsData15+PerStsData26+PerStsData37+PerStsData48) ;Keep data bits
  MOV  CL,3                    ;Line up
  SHR  AL,CL                   ;  data bits
  TEST AL,10h                  ;  where
  JNZ >B50                     ;  they
  OR   AL,08h                  ;  belong (note that high bit is Reversed!)
B50:                           ;Low nibble of AL contains Data
  AND  AL,0Fh                  ;Mask out high Nibble
  MOV  CL,AL                   ;Put nibble in CL
  INC  DX                      ;Get the
  IN   AL,DX                   ;  Control Port Data
  AND  AL,(NOT HstStsHostBusy) ;Set HostBusy (tell peripheral we have the data)
  OUT  DX,AL                   ;Do it
  DEC  DX                      ;Point at the Status Port
B60:                           ;Loop to here to wait for peripheral handshake
  IN   AL,DX                   ;Get the Status Port Data
  TEST AL,PerStsPtrClk         ;Is PtrClk high yet (Peripheral handshake)?
  JZ   B60                     ;If not, keep waiting
  POP  DX,BX,AX                ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE TO CONVERT USER-PROVIDED TIMEOUT (SECONDS) TO OUR VALUES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;CALCULATE AND STORE A PARALLEL-PORT BLOCK TIMEOUT COUNTER
;Inputs:   ES = TSR Data Area
;          BP = Original DX (DH contains User-provided Timeout)
;          CX = Number of Bytes to Send/Receive
;Outputs:  CF = Clear if OK
;               [BX] = Block Timeout Table Entry, filled in
;             = Set if Error
;               [BX] = Undefined
;Changes:
;------------------------------------------------------------------------------
StartBlockTimeout:
  PUSH AX,CX,DX,DS              ;Save used registers
  MOV  DS,ES                    ;Point DS at TSR data Area
  MOV  DX,BP                    ;Restore original DH
  CALL CalcTimeoutTicks         ;Calculate the Timeout Ticks (AX)
  MOV  BX,BlockTimeoutTable     ;Point [BX] at the Table
  MOV  CX,NumBlockTimeouts      ;CX = Number of Table Entries
K10:                            ;Loop to here to find emptyu table entry
  TEST [BX].BTFlags,BTFlagInUse ;Entry already in use?
  JNZ >K40                      ;If so, skip it
  OR   [BX].BTFlags,BTFlagInUse ;If not, mark it as in use
  MOV  [BX].BTCounter,AX        ;Store the Timeout Value
  JMP >K80                      ;Done
K40:                            ;Table entry not available
  ADD  BX,BlockTimeoutStrucSize ;Point at the next table entry
  LOOP K10                      ;Keep looking
K70:                            ;Error
  STC                           ;Set error flag
  JMP >K90                      ;Done
K80:                            ;OK
  CLC                           ;Set return flag
K90:                            ;Done
  POP  DS,DX,CX,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESET (MARK AS UNUSED) A PARALLEL-PORT BLOCK TIMEOUT COUNTER
;Inputs:   ES  = TSR Data Area
;         [BX] = Block Timeout Table Entry
;Outputs: [BX] = Reset
;         Flags Unchanged
;Changes:
;------------------------------------------------------------------------------
ResetBlockTimeout:
  MOV  W [BX].BTFlags,0 ;Reset Flags to 0
  MOV  [BX].BTCounter,0 ;Reset Counter to 0
  RET

;------------------------------------------------------------------------------
;CALCULATE THE APPROPRIATE TIMEOUT VALUE FOR A TX/RX BLOCK CALL
;Inputs:  ES = TSR Data Area
;         CX = Number of Bytes to Send/Receive
;         DH = Timeout provided by User (0 = Use Default, else seconds)
;Outputs: AX = Appropriate value (Deciseconds or Timer Ticks)
;Changes:
;------------------------------------------------------------------------------
CalcTimeoutDSecs:
  PUSH BX     ;Save used registers
  XOR  BL,BL  ;Mark as Deciseconds
  JMP >T00    ;Do it
CalcTimeoutTicks:
  PUSH BX     ;Save used registers
  MOV  BL,-1  ;Mark as Timer Ticks
;  JMP >T00    ;Do it
T00:
  PUSH CX,DX  ;Save used registers
  MOV  AL,DH  ;Get the user-provided timeout value
  OR   AL,AL  ;Use default timeout?
  JZ  >T40    ;If so, do it
T10:          ;Use User-provided Timeout
  OR   BL,BL  ;Do we want Ticks or Deciseconds?
  JZ  >T30    ;If Deciseconds, handle it
T20:          ;User Timer Ticks
  CALL ConvertSeconds2Ticks ;Convert Seconds to Timer Ticks
  JMP >T90    ;Done
T30:          ;User Deciseconds
  MOV  DL,10  ;Convert Seconds
  MUL  DL     ;  to Deciseconds
  JMP >T90    ;Done
T40:          ;Use Default Timeout
  XOR  DX,DX  ;Divide number of bytes
  MOV  AX,200 ;  by 200
  XCHG AX,CX  ;  (5 deciseconds
  DIV  CX     ;  for every 1000 bytes)
  CMP  DX,100 ;Do we need to round up?
  JB  >T45    ;If not, continue
  INC  AX     ;If so, round up
T45:          ;Rounded up, if necessary
  ADD  AX,50  ;Add 50 deciseconds as a base
  OR   BL,BL  ;Do we want Ticks or Deciseconds?
  JZ  >T90    ;If Deciseconds, we're done
T50:          ;Default Timer Ticks (AX = Deciseconds)
  XOR  DX,DX  ;Divide Deciseconds
  MOV  CX,10  ;  by 10
  DIV  CX     ;  (convert to seconds)
  CALL ConvertSeconds2Ticks ;Convert it to Ticks
  SHL  DX,1   ;Multiply division remainder by 2
  ADD  AX,DX  ;Add it to our Tick Count
  INC  AX     ;Add a Tick for good measure
T90:          ;Done (AX contains Timeout value to use)
  POP  DX,CX  ;Restore used registers
  POP  BX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT SECONDS TO TIMER TICKS
;Inputs:  AL = Number of Seconds (0-255)
;Outputs: AX = Number of Timer Ticks
;Changes:
;------------------------------------------------------------------------------
ConvertSeconds2Ticks:
  PUSH BX,DX    ;Save used registers
  XOR  AH,AH    ;Set high byte to 0
  OR   AL,AL    ;Zero?
  JZ  >S90      ;If so, done
  MOV  BX,18206 ;Multiply by 18.206
  MUL  BX       ;  (approx number of
  MOV  BX,1000  ;  timer ticks
  DIV  BX       ;  per second)
  CMP  DX,500   ;Do we need to round up?
  JB  >S20      ;If not, continue
  INC  AX       ;If so, round it up
S20:            ;Done counting
  INC  AX       ;Add an extra Timer Tick for good measure
S90:            ;Done
  POP  DX,BX    ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE FOR REGULAR INT 17H FUNCTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SEND A CHARACTER TO A PRINTER
;Inputs:   DS = ES = TSR Data Area
;         [BX] = Device Info Table Entry
;          AL  = Character to send
;Outputs:  AH  = Correct Status Byte
;Changes:
;NOTES: This does not simply schedule a Bulk Transaction and send just one byte
;         of data to the printer across the USB Bus.  That would be very
;         inefficient -- USB is only efficient because it can send relatively
;         large packets of data at once.
;       We actually queue the data being sent to a printer, and when the queue
;         gets full or times out (approximately 1 second), we send the data.
;       We also are able to "chain" several queues together and effectively
;         make one large, circular queue, which should keep things working
;         pretty efficiently.
;------------------------------------------------------------------------------
SendCharBX:
  PUSH BX,DX,DI,SI                ;Save used registers
  PUSHF                           ;Save flags
  CLI                             ;Disable interrupts
  MOV  DL,AL                      ;Save AL
  MOV  AH,PStsNoPrinter           ;Assume no printer attached any more
  TEST [BX].DIFlags,DIFlagInUse   ;Is there still a printer attached?
  JZ  >C90                        ;If not, we're done
  MOV  SI,BX                      ;If so, point SI at Device Info entry
  MOV  DI,[SI].DIBufferPtr        ;Get the Buffer Pointer
  OR   DI,DI                      ;Any Buffer yet?
  JNZ >C20                        ;If so, continue
  CALL GetAvailBufferDIWait       ;If not, get an empty buffer
  JZ  >C70                        ;If none available, error
  MOV  [SI].DIBufferPtr,DI        ;Store Buffer Pointer in Device Info Table
  MOV  [DI].BfDevicePtr,SI        ;Store Device Info Offset in Buffer Table
C20:                              ;Have first Buffer Pointer (DI)
  CMP  [DI].BfNextBuffer,0        ;Is there a next buffer?
  JE  >C30                        ;If not, continue
  MOV  DI,[DI].BfNextBuffer       ;If so, point at the next buffer
  JMP  C20                        ;Keep going to find the last buffer
C30:                              ;Have the last Buffer Pointer (DI)
  CMP  [DI].BfTimer,0             ;Has this Buffer been scheduled?
  JNE >C50                        ;If not, we can add more bytes to it
C40:                              ;Need to start a new Buffer
  MOV  BX,DI                      ;Save current Buffer Pointer
  CALL GetAvailBufferDIWait       ;Get a new Buffer Pointer
  JZ  >C70                        ;If none available, error
  MOV  [BX].BfNextBuffer,DI       ;Store new Pointer in old Buffer
  MOV  [DI].BfPrevBuffer,BX       ;Store old Pointer in new Buffer
  MOV  [DI].BfDevicePtr,SI        ;Store Device Info Pointer in new Buffer
C50:                              ;OK to add byte to buffer
  MOV  BX,[DI].BfNumBytes         ;Add the Byte
  MOV  [BX+DI].BfData,DL          ;  to the end of the Buffer
  INC  [DI].BfNumBytes            ;Increment Byte Count
  CMP  [DI].BfNumBytes,BufferSize ;Is the Buffer full?
  JB  >C80                        ;If not, we're done
  MOV  [DI].BfTimer,0             ;Mark the buffer as ready to send
  CMP  [DI].BfPrevBuffer,0        ;Is this the first Buffer?
  JNE >C80                        ;If not, don't send it yet
  CALL SendBufferDI               ;If it is, send it down the Bus
  JMP >C80                        ;Done
C70:                              ;Error (Timeout/No Buffer available)
  MOV  AH,PStsNoBuffer            ;Set Appropriate Status
  JMP >C90                        ;Done
C80:                              ;OK
  MOV  AH,PStsNormal              ;Set Status as OK
C90:                              ;Done
  MOV  AL,DL                      ;Restore AL
  POPF                            ;Restore flags
  POP  SI,DI,DX,BX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEND THE CONTENTS OF A BUFFER TO THE PRINTER
;Inputs:  DS = ES = TSR Data Area
;         [DI] = Buffer entry to send
;Outputs:
;Changes:
;NOTES: This can be called either from Int 08 because the Timer has counted
;         down, or from Int 17h because the buffer is full, or from
;         BufferSent because the original buffer timed out and needs to
;         be reissued.  No matter where the call comes from,
;         [DI].BfTimer = 0, indicating that it is ready to send, and
;         [DI].BFPrevBuffer = 0, indicating that there is no previous buffer
;         still pending.
;------------------------------------------------------------------------------
SendBufferDI:
  PUSH AX,BX,CX,DX,DI,SI       ;Save used registers
  PUSHF                        ;Save flags
  CLI                          ;Disable interrupts
  MOV  BX,[DI].BfDevicePtr     ;Point BX at the Device Info Entry
  MOV  SI,Int14Request2        ;Point at Interrupt Request Structure
  MOV  [SI].I14RRequestType,I14RRTDoBulk ;Request = Bulk
  MOV  [SI].I14RFlags,0        ;Direction = Out
  MOV  [SI].I14RTimeout,0      ;Default Timeout
  MOV  AX,W [BX].DIHostIndex   ;Copy Host Index
  MOV  W [SI].I14RHostIndex,AX ;  and Device Address
  MOV  AL,[BX].DIEndPointOut   ;Copy
  MOV  [SI].I14REndPoint,AL    ;  End Point
  MOV  AX,[DI].BfNumBytes      ;Copy number of Bytes
  MOV  [SI].I14RDataSize,AX    ;  to send
  MOV  W [SI].I14RDataAddress[0],DI            ;Point at
  ADD  W [SI].I14RDataAddress[0],OFFSET BfData ;  the Data
  MOV  W [SI].I14RCallBackAddr[0],BufferSent   ;Where to go when done
  MOV  [SI].I14RUserPktID,DI   ;User Packet ID = Buffer Pointer
  CALL DoInt14CallCXDXSI       ;Do it
  MOV  [SI].I14RTimeout,0      ;Reset Timeout
  JC  >F90                     ;If error, try again later
  MOV  [DI].BfHandle,CX        ;Store the Handle Number
  MOV  [DI].BfCloseID,DL       ;Store the Close ID
F90:                           ;Done
  POPF                         ;Restoe flags
  POP  SI,DI,DX,CX,BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE THE END END OF A BUFFER SENT, SCHEDULING THE NEXT BUFFER IF NEEDED
;Inputs:   ES = ES = TSR Daa Area
;         [BX] = Buffer that was just sent
;Outputs: If Buffer was sent OK (no Error), this Releases the Buffer just sent,
;           making it available again.  If another buffer is in queue behind
;           this one and is ready to send, it is scheuled on the Bus.
;         If the Buffer timed out (such as happens when the Buffer
;           inside the printer gets full), this simply reschedules the
;           same Buffer onto the Bus again.
;         If the Buffer errored out for some reason other than a Timeout,
;           we do a hard reset (effectively disconnect and reconnect
;           the printer).  I don't know if that's the correct response
;           to handle an error or not, but it's what we're doing for now.
;           Hopefully, it won't cause too much consternation.
;Changes:
;NOTES: This is a a FAR CALL (Status Call) issued by the USB Host Driver,
;         so does not need to preserve registers and must end in RETF.
;       If we get an error while trying to send the packet, we reset
;         the Printer (a reset at the USB level).  There's no process
;         while printing for the printer to cancel the print job (which
;         is what we are trying to do), or for the printer driver to know
;         whether or not hte user wants to cancel the job (they will just
;         stop sending data).  Therefore, we will beep and reset the
;         printer and hope things work out for the best.
;------------------------------------------------------------------------------
BufferSent:
  CLI                          ;Disable interrupts
  JNZ >S50                     ;If Bulk Transaction error, handle it
  OR   [BX].BfFlags,BfFlagDone ;Mark transaction as completed
  MOV  DI,[BX].BfNextBuffer    ;Point at Next Buffer in Queue
  CALL ReleaseBufferBX         ;Release the Buffer
  OR   DI,DI                   ;Is there more data waiting?
  JZ  >S90                     ;If not, we're done
  CMP  [DI].BfTimer,0          ;Is the buffer ready to send yet?
  JNE >S90                     ;If not, don't send it
  CALL SendBufferDI            ;If so, send the Buffer
  JMP >S90                     ;Done
S50:                           ;Error sending data
  OR   [BX].BfFlags,BfFlagDone ;Mark transaction as completed
  MOV  DI,[BX].BfDevicePtr     ;Point DI at Device Info Entry
  LEA  SI,[DI].DIInt14Request  ;Point at Local Request Structure
  MOV  AX,W [DI].DIHostIndex   ;Copy the Host Index
  MOV  W [SI].I14RHostIndex,AX ;  and Device Address
  MOV  [SI].I14RRequestType,I14RRTBeepSpeaker ;Request = Beep Speaker
  MOV  [SI].I14RBeepFrequency,500 ;Frequency = 500 Hz
  MOV  [SI].I14RTimeout,3      ;Duration = 0.3 seconds
  CALL DoInt14CallSaveAllSI    ;Do it
  MOV  [SI].I14RTimeout,0      ;Reset Timeout
  MOV  [SI].I14RRequestType,I14RRTResetDevice ;Request = Reset Device
  MOV  W [SI].I14RCallBackAddr[0],-1 ;We don't care when it's done resetting
  CALL DoInt14CallSaveAllSI    ;Send it
S90:                           ;Done
  STI                          ;Enable interrupts
  RETF

;------------------------------------------------------------------------------
;FIND AN AVAILABLE BUFFER, WAITING A LITTLE WHILE IF NECESSARY
;Inputs:  DS = ES = TSR Data Area
;Outputs: ZF = Clear if OK
;              [DI] = Buffer Entry to use
;                     Buffer marked as in use
;                     Timer is initialized to approx 1 second
;            = Set if Error
;              DI = 0
;Changes:
;NOTES: There are LPT timeout factors for LPT1 - LPT4 in the BIOS data area
;         (0040:0078->007B), which are set at 14h (20) by default.  A value
;         of 0 in these indicates an infinite timeout (do not EVER time out).
;         I can't imagine a program ever actually wanting an infinite timeout,
;         and we won't even bother accounting for this possibility.
;       The original PC BIOS would do an internal loop the number of times
;         requested in the BIOS data area.  The code looked something
;         like this:
;             MOV  BL,[78h]       ;Put outer loop counter in BL
;          L10:                   ;Loop to here for outer loop
;             MOV  CX,-1          ;Set inner loop counter to 65535
;          L20:                   ;Loop to here for inner loop
;             IN   AL,DX          ;Get the Printer Status
;             TEST AL,PStsNotBusy ;Is it Busy?
;             JNZ >L80            ;If not, we're done
;             LOOP L20            ;If Busy, keep trying until we timeout
;             OR   BL,BL          ;Infinite timeout?
;             JZ   L10            ;If so, keep waiting
;             DEC  BL             ;Have we done the outer loop enough times?
;             JNZ  L10            ;If not, keep waiting
;          L70:                   ;Timed Out waiting for printer to unBusy
;            ...
;          L80:                   ;Printer is Ready (Not Busy)
;            ...
;        For USB printers, timeout values like these can't really be used
;          in the same way they are with I/O port access, so we will
;          ignore them.  To add a further complication, in this program,
;          we aren't actually waiting for the printer, but are instead waiting
;          for an available buffer.  So, we will simply have a fixed timeout
;          value that we will use.  If we do not have an available buffer
;          after the time has elapsed, we will return a timeout error.
;------------------------------------------------------------------------------
GetAvailBufferDIWait:
  PUSH CX               ;Save used registers
  PUSHF                 ;Save flags
  STI                   ;Enable interrupts
  XOR  DI,DI            ;Start with empty buffer
  MOV  CX,60000         ;Wait a total of 60000 ms (1 minute)
;  MOV  CX,20            ;Wait a total of 20 ms
W10:                    ;Loop to here to wait for buffer to clear
  CALL GetAvailBufferDI ;Get an available buffer (DI)
  JNZ >W90              ;If it worked, we're done
  CALL Delay1MS         ;If not, wait for 1 millisecond
  LOOP W10              ;Try it again
W90:                    ;Done
  POPF                  ;Restore flags
  OR  DI,DI             ;Set return flag
  POP CX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND AN AVAILABLE BUFFER
;Inputs:  DS = ES = TSR Data Area
;Outputs: ZF = Clear if OK
;              [DI] = Buffer Entry to use
;                     Buffer marked as in use
;                     Timer is initialized to approx 1 second
;            = Set if Error
;              DI = 0
;Changes:
;NOTES: This routine will not assign all buffers if there is more than one
;         USB printer attached.  That is, it makes sure there is at least
;         one buffer available to each USB printer.  This allows multitasking
;         and background printing to more than one printer at a time to
;         work properly.
;------------------------------------------------------------------------------
GetAvailBufferDI:
  PUSH AX,CX                    ;Save used registers
  PUSHF                         ;Save flags
  CLI                           ;Disable interrupts
  CALL CalcNumDevices           ;Calculate how many USB Devices are attached
  JZ  >B30                      ;If only one, it's OK to use all Buffers
  MOV  CX,AX                    ;If more than one, store the number of Devices
  CALL CalcAvailBuffers         ;Calculate how many empty Buffers there are
  CMP  AX,CX                    ;Are there enough Buffers available?
  JB  >B70                      ;If not, return none available
B30:                            ;OK to look for a Buffer
  MOV  DI,BufferTable           ;Point at Table
  MOV  CX,NumBuffers            ;Number of table entries
B40:                            ;Loop to here to find empty entry
  TEST [DI].BfFlags,BfFlagInUse ;This entry available?
  JZ  >B80                      ;If so, we're done
  ADD  DI,BufferStrucSize       ;If not, point at the next entry
  LOOP B40                      ;Keep looking
B70:                            ;Error
  XOR  DI,DI                    ;Set DI to 0
  JMP >B90                      ;Done
B80:                            ;OK
  OR   [DI].BfFlags,BfFlagInUse ;Mark it as in use
  MOV  [DI].BfTimer,18          ;Set Timer for approximately 1 second
B90:                            ;Done
  POPF                          ;Restore flags
  OR   DI,DI                    ;Set return flag
  POP  CX,AX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE HOW MANY USB DEVICES ARE CURRENTLY ATTACHED
;Inputs:  DS = ES = TSR Data Area
;Outputs: AX = Number of USB Devices currently attached
;         ZF = Set if AX = 1 (a single printer)
;            = Clear if AX > 1
;Changes:
;NOTES: We assume this code is called only if there is at least one printer.
;         IT does not return an error if there are no printers.
;------------------------------------------------------------------------------
CalcNumDevices:
  PUSH BX,CX                    ;Save used registers
  MOV  BX,DeviceInfoTable       ;Point at table
  MOV  CX,MaxDevices            ;Number of table entries
  XOR  AX,AX                    ;Initialize Counter
V10:                            ;Loop to here for each table entry
  TEST [BX].DIFlags,DIFlagInUse ;Empty Table Entry?
  JZ  >V20                      ;If so, skip it
  INC  AX                       ;If not, increment our Counter
V20:                            ;Done with this table entry
  ADD  BX,DeviceInfoStrucSize   ;Point at the next Table Entry
  LOOP V10                      ;Keep going until we're done
  CMP  AX,1                     ;Set return flag
  POP  CX,BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE HOW MANY BUFFERS ARE CURRENTLY AVAILABLE
;Inputs:  DS = ES = TSR Data Area
;Outputs: AX = Number of Buffers currently available
;Changes:
;------------------------------------------------------------------------------
CalcAvailBuffers:
  PUSH BX,CX                    ;Save used registers
  MOV  BX,BufferTable           ;Point at table
  MOV  CX,NumBuffers            ;Number of table entries
  XOR  AX,AX                    ;Initialize Counter
F10:                            ;Loop to here for each table entry
  TEST [BX].BfFlags,BfFlagInUse ;Empty Table Entry?
  JNZ >F20                      ;If not, skip it
  INC  AX                       ;If not, increment our Counter
F20:                            ;Done with this table entry
  ADD  BX,BufferStrucSize       ;Point at the next Table Entry
  LOOP F10                      ;Keep going until we're done
  POP  CX,BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THERE IS AN AVAILABLE BUFFER
;Inputs:  DS = ES = TSR Data Area
;Outputs: ZF = Clear if an Empty Buffer is available
;            = Set if no Buffers are available
;Changes:
;NOTES: This simply tests to see if an empty buffer is available.  It does
;         not reserve it.  As soon as this test is done, the buffer could
;         immediately become used by a background process or another process
;         in a multitasking environment.
;------------------------------------------------------------------------------
TestAvailBuffer:
  PUSH DI               ;Save used registers
  PUSHF                 ;Save flags
  CLI                   ;Disable interrupts
  CALL GetAvailBufferDI ;Look for a Buffer (returns ZF)
  JZ  >V90              ;If none available, we're done
  AND  [DI].BfFlags,(NOT BfFlagInUse) ;Mark it as not in use
  MOV  [DI].BfTimer,0   ;Reset Timer
V90:                    ;Done
  POPF                  ;Restore flags
  OR   DI,DI            ;Set return flag
  POP  DI               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RELEASE (RESET) ALL BUFFERS ASSOCIATED WITH A DEVICE
;Inputs:  DS = ES = TSR Data Area
;         [BX] = Device Info Entry to Reset Buffers for
;            or
;         [DI] = Device Info Entry to Reset Buffers for
;         CLD already issued
;Outputs: Resets all Buffers associated with Device to unused state
;Changes:
;NOTES: This MUST preserve flags!
;------------------------------------------------------------------------------
RlsAllBuffersDvcBX:
  PUSH DI                 ;Save used registers
  MOV  DI,BX              ;Point DI at the Device Info entry
  CALL RlsAllBuffersDvcDI ;Do it
  POP  DI                 ;Restore used registers
  RET

RlsAllBuffersDvcDI:
  PUSH BX                  ;Save used registers
  PUSHF                    ;Save flags
A10:                       ;Loop to here for each buffer
  MOV  BX,[DI].DIBufferPtr ;Get the Buffer Pointer
  OR   BX,BX               ;Is there a Buffer?
  JZ  >A90                 ;If not, quit
  CALL ReleaseBufferBX     ;If so, release it
  JMP  A10                 ;Keep going until we're done
A90:                       ;Done
  POPF                     ;Restore flags
  POP  BX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RELEASE (RESET) A BUFFER
;Inputs:  DS = ES = TSR Data Area
;         [BX] = Buffer to Reset
;         CLD already issued
;Outputs: Resets Buffer to unused state
;         Sets associated Device Info Entry Buffer Pointer to Next Buffer
;         If there is a Next Buffer, marks the Previous Buffer for it as 0
;Changes:
;NOTES: This MUST preserve flags!
;       This just resets the Buffer Header, but does not overwrite the data.
;         We do this just in case we perform this while a Bus transaction is
;           still in progress, and there may still be some data left to send.
;------------------------------------------------------------------------------
ReleaseBufferBX:
  PUSH AX,BX,CX,DI,SI            ;Save used registers
  PUSHF                          ;Save flags
  CLI                            ;Disable interrupts
  MOV  DI,BX                     ;Point [DI] at the Buffer
  MOV  BX,[DI].BfDevicePtr       ;Point BX at the Device Info Pointer
  MOV  AL,[DI].BfCloseID         ;Get the Close ID
  OR   AL,AL                     ;Has this data already been sent?
  JZ  >R20                       ;If not, no need to Close the Transaction
  TEST [DI].BfFlags,BfFlagDone   ;If so, has the Bus Transaction completed?
  JNZ >R20                       ;If so, don't try to Close the Bus Transaction!
  MOV  SI,Int14Request2          ;If so, point at Request Structure
  MOV  [SI].I14RRequestType,I14RRTCloseHandle ;Request = Close Handle
  MOV  [SI].I14RCloseID,AL       ;Store Close ID
  MOV  AX,[DI].BfHandle          ;Copy
  MOV  [SI].I14RRequestHandle,AX ;  Handle Number
  MOV  AL,[BX].DIHostIndex       ;Copy
  MOV  [SI].I14RHostIndex,AL     ;  Host Index
  CALL DoInt14CallSaveAllSI      ;Tell the Host to Close the Transaction
R20:                             ;Release buffer locally
  MOV  SI,[DI].BfNextBuffer      ;Point SI at the Next Buffer Pointer
  MOV  CX,(BufferHdrSize/2)      ;Number of words to write
  XOR  AX,AX                     ;Fill with zeroes
  REP  STOSW                     ;Do it
  MOV  [BX].DIBufferPtr,SI       ;Store the next Buffer in the Device Info Table
  OR   SI,SI                     ;Is there a Next Buffer?
  JZ  >R90                       ;If not, we're done
  MOV  [SI].BfPrevBuffer,0       ;If so, mark it as not having a Previous Buffer
R90:                             ;Done
  POPF                           ;Restore flags
  POP  SI,DI,CX,BX,AX            ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS A SOFT RESET REQUEST
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;ISSUE A SOFT RESET REQUEST FOR A SPECIFIC DEVICE
;Inputs:  DS = ES = TSR Data Area
;         [BX] = Device Info Table Offset of Device to Reset
;Outputs: Issues Soft Reset Request to Device
;         Updates DIFlags (ResetDone & ResetError)
;Changes:
;NOTES: In version 1.0 of the USB Printer Spec, this Request is supposed
;         to have a Recipient of Other.  In version 1.1 of the Spec, the
;         Recipient is Interface.  Depending on how old the printer
;         is, it will probably only respond to one or the other, but probably
;         will not respond to both.  We will try the new way
;         (Recipient = Interface), and if that doesn't work, will change it
;         to the old way (Recipient = Other).
;       We send the Reset request to the Printer, and monitor for errors,
;         but don't do anything special if we get an error.  Basically,
;         we just assume it works.
;------------------------------------------------------------------------------
DoSoftResetBX:
  PUSH CX,DI              ;Save used registers
  MOV  CX,45000           ;Wait up to 45 seconds
S10:                      ;Loop here to wait for Buffers to be sent
  TEST [BX].DIFlags,DIFlagInUse ;Printer still attached?
  JZ  >S90                ;If not, just quit
  CALL FindLastBufferBXDI ;Any data pending?
  JZ  >S20                ;If not, continue
  MOV  [DI].BfTimer,0     ;If so, mark last Buffer as ready to send
  CALL Delay1MS           ;Wait for 1 millisecond
  LOOP S10                ;Keep waiting for Buffers to clear
  CALL RlsAllBuffersDvcBX ;If we timed out, release all Buffers
  JMP >S90                ;Quit (there must be a problem with the Device)!
S20:                      ;No Data Pending
  AND  [BX].DIFlags,(NOT (DIFlagResetDone+DIFlagResetError)) ;Initialize Flags
  CALL DoSoftResetBXGo    ;Start things rolling
S40:                      ;Loop to here to wait for completion
  TEST [BX].DIFlags,DIFlagResetDone ;Done yet?
  JZ   S40                ;If not, keep waiting
S90:                      ;Done
  POP  DI,CX              ;Restore used registers
  RET

DoSoftResetBXGo:
  PUSH AX,CX           ;Save used registers
  MOV  CL,(SRRTOut+SRRTTypeClass+SRRTRecipInterface) ;Recipient = Interface
  MOV  AX,DoSoftReset2 ;Code to call when done
  CALL DoSoftResetGo   ;Do it
  JNC >C90             ;If OK, continue
  OR   [BX].DIFlags,(DIFlagResetDone+DIFlagResetError) ;Mark as Errored
C90:                   ;Done
  POP  CX,AX           ;Restore used registers
  RET

DoSoftReset2:
  JZ  >T80                           ;If it worked, handle it
  MOV  CL,(SRRTOut+SRRTTypeClass+SRRTRecipOther) ;Recipient = Other
  MOV  AX,DoSoftResetFinish          ;Code to call when done
  CALL DoSoftResetGo                 ;Do it
  JNC >T90                           ;If OK, continue
  OR   [BX].DIFlags,DIFlagResetError ;Mark as Errored
T80:                                 ;It's complete
  OR   [BX].DIFlags,DIFlagResetDone  ;Mark as Done
T90:                                 ;Done
  RETF

DoSoftResetFinish:
  JZ  >F90                           ;If it worked, handle it
  OR   [BX].DIFlags,DIFlagResetError ;Mark as Errored
F90:                                 ;It worked
  OR   [BX].DIFlags,DIFlagResetDone  ;Mark as Done
  RETF

;------------------------------------------------------------------------------
;Inputs:   AX  = CallBack Offset to use
;         [BX] = Device Info Table Offset (UserPacket ID)
;          CL  = SRRequest Type to use (contains correct Recipient)
;Outputs:
;Changes: AX
;------------------------------------------------------------------------------
DoSoftResetGo:
  PUSH CX,SI                         ;Save used registers
  LEA  SI,[BX].DIInt14Request        ;Point [SI] at Local Int 14h Request
  MOV  [SI].I14RRequestType,I14RRTDoControl ;Request = Control
  MOV  [SI].I14RFlags,0              ;Request Flags = 0
  MOV  [SI].I14RTimeout,0            ;Timeout = Default
  MOV  W [SI].I14RCallBackAddr[0],AX ;Code to call when done
  MOV  [SI].I14RUserPktID,BX         ;User Packet ID = Device Info Offset
  MOV  AX,W [BX].DIHostIndex         ;Copy Host Index
  MOV  W [SI].I14RHostIndex,AX       ;  and Device Address
  MOV  AL,CL                         ;Save recipient
  MOV  CX,SoftResetReq               ;Copy Request
  CALL CopySetupReqToInt14SI         ;  to Int 14h Structure
  MOV  AH,[BX].DIInterfaceNum        ;Copy
  MOV  B [SI].I14RSoftResetIntf,AH   ;  Interface
  MOV  B [SI].I14RSetupReqData[0],AL ;Set correct Recipient
  CALL DoInt14CallSaveAllSI          ;Do it
  POP  SI,CX                         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS A GET STATUS REQUEST
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET THE STATUS OF A DEVICE, ACCOUNTING FOR OUR BUFFERS
;Inputs:   DS = ES = TSR Data Area
;         [BX] = Device Info Table Offset of Device to get Status of
;Outputs: AH = Device Status
;         ZF = Set if Status is Normal
;            = Clear if not
;Changes:
;NOTES: If we're in the middle of a job, this simply returns the status
;         of available buffers (not the actual status of the printer),
;         since the "interface" to the outside world is our buffers.
;         We will wait a short amount of time for an available buffer to
;         appear before returning a status of Busy.
;       If we're not in the middle of a job, we return the actual status.
;------------------------------------------------------------------------------
GetStatusBX:
  PUSH CX                   ;Save used registers
  CMP  [BX].DIBufferPtr,0   ;Are we in the middle of a job?
  JE  >S50                  ;If not, get the real status
  MOV  AH,PStsNormal        ;Start with a normal status
;  MOV  CX,10000             ;Wait a maximum of 10000 ms (10 sec)
  MOV  CX,25                ;Wait a maximum of 25 ms
S10:                        ;Loop to here to wait for an empty buffer
  TEST [BX].DIFlags,DIFlagInUse ;Is a printer still attached?
  JNZ >S30                  ;If so, continue
S20:                        ;Printer is not longer attached
  MOV  AH,PStsNoPrinter     ;Mark status as no printer
  JMP >S90                  ;Done
S30:                        ;Printer still attached
  CALL TestAvailBuffer      ;Test for an empty buffer
  JNZ >S90                  ;If there is one, we're done
  CALL Delay1MS             ;If not, wait for 1 millisecond
  LOOP S10                  ;Try it again
  AND  AH,(NOT PStsNotBusy) ;If we've waited long enough, mark as Busy
  JMP >S90                  ;Done
S50:                        ;Not in the middle of a Job
  CALL GetRealStatusBX      ;Get the real Status (rtns AH)
  JNZ >S90                  ;If not normal, quit
  CALL GetBusyBitBXAH       ;If normal, test for available buffers
S90:                        ;Done
  CMP  AH,PStsNormal        ;Set return flag
  POP  CX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE CURRENT BUSY/NOT BUSY STATUS OF OUR BUFFERS
;Inputs:   DS = ES = TSR Data Area
;         [BX] = Device Info Table Entry to test for
;          AH  = Status Byte
;Outputs: AH PStsNotBusy bit updated with our current Buffer status
;           PHStsNotBusy = Set if there is Buffer space avaialble for
;                          at least one character to be sent
;                        = Clear if no Buffer Space currently available
;         ZF = Set if Status = Normal
;            = Clear if Status = anything other than normal
;Changes:
;NOTES: This simply tests to see if resources are available to immediately
;         send a single character to the printer.  It does not reserve any
;         of the resources that it would actually take to do it.  Therefore,
;         between the time this test is made and the request to actually sent
;         the character is made, resources could be different (either better
;         or worse) than they are now.  If we are not trying to multitask
;         more than one printer at a time, resources will always be better.
;         If we are multitasking, resources could either be better or worse.
;------------------------------------------------------------------------------
GetBusyBitBXAH:
  PUSH BX                   ;Save used registers
  PUSHF                     ;Save flags
  CLI                       ;Disable interrupts
  CALL FindLastBufferBXBX   ;Point [BX] at the Last Buffer
  JZ  >C20                  ;If none, look for an Empty Buffer
  CMP  [BX].BfTimer,0       ;If so, is it ready to send yet?
  JNE >C80                  ;If not, there's space available
C20:                        ;No space in first buffer
  CALL TestAvailBuffer      ;If so, are there any Empty Buffers?
  JNZ >C80                  ;If so, there's space available
C70:                        ;Error (no space available)
  AND  AH,(NOT PStsNotBusy) ;Mark as no space avaialble
  JMP >C90                  ;Done
C80:                        ;OK (space available)
  OR   AH,PStsNotBusy       ;Mark as OK
C90:                        ;Done
  POPF                      ;Restore flags
  CMP  AH,PStsNormal        ;Set return flag
  POP  BX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE ACTUAL STATUS OF A USB PRINTER
;Inputs:   DS = ES = TSR Data Area
;         [BX] = Device Info Table Offset of Printer to get Status of
;Outputs:  AH = Device Status
;         [BX].DIStatusByte = Status returned by Device
;          ZF = Set if Status is Normal
;             = Clear if not
;Changes:
;------------------------------------------------------------------------------
GetRealStatusBX:
  PUSH CX,DX,SI                ;Save used registers
  MOV  DL,AL                   ;Save original AL
  LEA  SI,[BX].DIInt14Request  ;Point [SI] at Local Request Structure
  MOV  [SI].I14RRequestType,I14RRTDoControl ;Request = Control
  MOV  [SI].I14RFlags,0        ;Request Flags = 0
  MOV  [SI].I14RTimeout,0      ;Timeout = Default
  MOV  AX,W [BX].DIHostIndex   ;Copy Host Index
  MOV  W [SI].I14RHostIndex,AX ;  and Device Address
  MOV  [SI].I14REndPoint,0     ;EndPoint 0
  MOV  CX,GetPortStatusReq     ;Copy Request
  CALL CopySetupReqToInt14SI   ;  to Int 14h Structure
  MOV  AL,[BX].DIInterfaceNum                          ;Copy
  MOV  B [SI].I14RGetPortStatusIntf,AL                 ;  Interface
  MOV  W [SI].I14RCallBackAddr[0],DataRtn              ;Code to call when done
  MOV  W [SI].I14RDataAddress[0],BX                    ;Where to
  ADD  W [SI].I14RDataAddress[0],(OFFSET DIStatusByte) ;  put the Data
  MOV  [SI].I14RUserPktID,BX   ;Store Device Info Pointer in Request
  MOV  [BX].DIDataRtnAX,-1     ;Initialize Done Flag
  CALL DoInt14CallSaveAllSI    ;Do it
  JC  >R70                     ;If error, handle it
R30:                           ;Loop to here to wait for completion
  MOV  AX,[BX].DIDataRtnAX     ;Get Done flag
  CMP  AX,-1                   ;Done yet?
  JE   R30                     ;If not, keep waiting
  OR   AX,AX                   ;Error?
  JZ  >R80                     ;If not, we're done
R70:                           ;Error
  MOV  AH,PStsNoPrinter        ;Set status to invalid
  JMP >R90                     ;Done
R80:                           ;Status is OK
  MOV  AH,[BX].DIStatusByte    ;Get the returned status
  XOR  AH,PStsIOError          ;Toggle I/O Error (USB is backwards)
  OR   AH,PStsNotBusy          ;Mark as not busy (USB doesn't return this)
R90:                           ;Done (AH contains status)
  MOV  AL,DL                   ;Restore original AL
  CMP  AH,PStsNormal           ;Set return flag
  POP  SI,DX,CX                ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT FUNCTIONS RELATED TO TESTING LPT INDEXES, I/O ADDRESSES, ETC.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST VALUE IN DX REGISTER TO SEE IF AN INT 17h CALL IS FOR US
;Inputs:  ES = TSR Data Area (DS = TSR Data Area if TestDXIsOursDS)
;         DX = Port number (from Int 17h call)
;Outputs: ZF = Clear if DX is one of our USB Indexes
;              [BX] = Device Info Table Entry
;               BX  = Unchanged if TestDXIsOursESNoBX
;            = Set if error (not a USB Port)
;              [BX] = 0
;               BX  = Unchanged if TestDXIsOursESNoBX
;Changes:
;------------------------------------------------------------------------------
TestDXIsOursESNoBX:
  PUSH BX             ;Save used registers
  CALL TestDXIsOursES ;Test it
  POP  BX             ;Restore used registers
  RET

TestDXIsOursDSNoBX:
  PUSH BX             ;Save used registers
  CALL TestDXIsOursDS ;Test it
  POP  BX             ;Restore used registers
  RET

TestDXIsOursDS:
  PUSH ES             ;Save used registers
  MOV  ES,DS          ;Point ES at TSR Data Area
  CALL TestDXIsOursES ;Test it
  POP  ES             ;Restore used registers
  RET

TestDXIsOursES:
  PUSH CX,DX                  ;Save used registers
  CMP  DX,(MaxPrinters-1)     ;Is DX valid?
  JA  >D70                    ;If not, error
  INC  DL                     ;Convert Index to an LPT Number
  MOV  BX,DeviceInfoTable     ;Point at Table
  MOV  CX,MaxDevices          ;Number of table entries
D10:                          ;Loop to here for each table entry
  CMP  DL,ES:[BX].DILPTNum    ;Does it match?
  JE  >D90                    ;If so, we're done
  ADD  BX,DeviceInfoStrucSize ;Point at next Table entry
  LOOP D10                    ;Keep looking until we're done
D70:                          ;Error
  XOR  BX,BX                  ;Set BX to 0
D90:                          ;Done
  OR   BX,BX                  ;Set return flag
  POP  DX,CX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN LPT INDEX TO SEE IF IT'S REDIRECTED OR NOT
;Inputs:  DX = LPT Index (as used by INT 17 Functions)
;Outputs: CF = Clear if Port is not Redirected
;            = Set if it is Redirected
;Changes:
;------------------------------------------------------------------------------
TestIndexRedir:
  PUSH AX,BX ;Save used registers
  PUSH CX,DX ;Save used registers
  MOV  AX,(1B00h+I17FGetPortRedir) ;Function = Get Port Redirect
  INT  17h   ;Do it (Returns BX)
  OR   AX,AX ;Did it work?
  JNZ >R80   ;If not, no Redirection
  CMP  DX,BX ;Redirected?
  JE  >R80   ;If not, we're done
R70:         ;Port is Redirected
  STC        ;Set redirected flag
  JMP >R90   ;Done
R80:         ;Not redirected
  CLC        ;Set not redirected flag
R90:         ;Done
  POP  DX,CX ;Restore used registers
  POP  BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A PRINTER INDEX TO ITS REDIRECTED INDEX
;Inputs:  DX = LPT Index
;Outputs: DX = "Converted" (Redirected) LPT Index
;Changes:
;------------------------------------------------------------------------------
ConvertIndexDX:
  PUSH AX,BX,CX           ;Save used registers
  CMP  DX,(MaxPrinters-1) ;Valid Index?
  JA  >X90                ;If not, quit
  MOV  AX,(1B00h+I17FGetPortRedir) ;Function = Get Port Redirect
                          ;DX = Port Index
  INT  17h                ;Do it (Returns BX = Redirected Port)
  OR   AX,AX              ;Did it work?
  JNZ >X90                ;If not, no Redirection
  MOV  DX,BX              ;If so, put redirected port in DX
X90:                      ;Done
  POP  CX,BX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A PRINTER INDEX TO ITS REDIRECTED INDEX
;Inputs:  ES = TSR Data Area
;         DX = LPT Index (already tested for validity!)
;Outputs: DX = "Converted" (Redirected) LPT Index
;              (= original DX if not Redirected)
;Changes:
;NOTE: The only function that uses this is an Extended INT 17h Function, so
;        we should be OK.  This should NOT be used by a "regular" part of the
;        Program (which should issue INT 17h Calls rather than looking
;        directly at the Redirect Table).
;------------------------------------------------------------------------------
GetRedirIndexDX:
  PUSH BX               ;Save used
I20:                    ;Find Redirected Index
  MOV  BX,RedirectTable ;Point at Redirect Table
  ADD  BX,DX            ;Point at correct table entry
  MOV  BL,ES:[BX]       ;Get the Redirection Port
  OR   BL,BL            ;Is it Redirected?
  JZ  >I90              ;If not, quit
  DEC  BL               ;If so, store the
  MOV  DL,BL            ;  Redirected Index
  JMP  I20              ;Look for a second level of Redirection
I90:                    ;Done
  POP  BX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF AN LPT INDEX IS ALREADY IN USE
;Inputs:  DX = LPT Index number to check
;         DS = TSR Data Area
;Outputs: ZF = Set if Index is not in-use yet
;            = Clear if it is in use
;Changes:
;NOTES: This simply assumes that DX is a valid Index -- it does
;         not actually test it.
;       TestDXInUseNoRedir is used by AssignLPTNum.
;       TestDXInUse can be used by any part of the program (even non-TSR).
;       TestDXInUse issues a "Get Printer Status" Request (function 2) to
;         BIOS INT 17h.  I've tested this with several different versions
;         of DOS, and issuing this with an invalid LPT Index (DX) always
;         returns with AH unchanged.  If the Index is valid, it will always
;         return AH changed to something else (usually either "No Printer" or
;         "Normal").  I would imagine it's possible for some version of
;         DOS or DOS emulator to return AH changed even for an invalid
;         LPT Index, in which case we would need to change this code.
;------------------------------------------------------------------------------
TestDXInUseNoRedir:
  PUSH AX,BX,CX,DX ;Save used registers
  PUSH DI,DS       ;Save used registers
  MOV  DI,DX       ;Save LPT Index
  MOV  AX,(1B00h+I17FGetRedirTblAddr) ;Function = Get Redirect Table Address
  MOV  DX,-1       ;Set register value
  INT  17h         ;Do it (Returns CX:BX)
  MOV  DX,DI       ;Restore original DX
  OR   AX,AX       ;Did it work?
  JZ  >U30         ;If so, continue
U10:               ;Redirect TSR is not installed yet
  CALL TestDXInUse ;Test it (returns ZF)
  JMP >U90         ;Done
U30:               ;Redirect TSR is installed
  MOV  DS,CX       ;Point DS:[BX] at the Redirect Table
  MOV  CL,[BX+DI]  ;Save Redirect of Index we're testing
  MOV  B [BX+DI],0 ;Un-Redirect Index we're testing
  CALL TestDXInUse ;Test it (returns ZF)
  MOV  [BX+DI],CL  ;Restore original Redirect
U90:               ;Done
  POP  DS,DI       ;Restore used registers
  POP  DX,CX,BX,AX ;Restore used registers
  RET

TestDXInUse:
  PUSH AX,BX,DX         ;Save used registers
  MOV  AH,I17FGetStatus ;Function = Get Port Status
  INT  17h              ;Do it
  CMP  AH,I17FGetStatus ;Did it work (Sets Return Flag)?
  POP  DX,BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A DEVICE DRIVER HEADER IS FOR A VALID I/O ADDRESS
;Inputs:  DS:[DI] = Devie Driver Header (ours)
;Outputs: ZF = Clear if [DI] is for a valid I/O Address
;            = Set if Not
;Changes:
;NOTES: This checks the redirected Index, no necessarily the original
;         Index.
;       This does not check the I/O port for reality, only for validity.
;         An invalid entry in the I/O table in the BIOS Data area will be
;         a small number (less than 100h, usually but not always 0).
;         We do not check to see if the I/O address is a real parallel
;         port or not, since we want to be compatible with other
;         Device Drivers that work the same way we do (inserting a
;         "fake" I/O address in the BIOS data area).  We want ourselves
;         to believe it's a real I/O address even if it isn't, at least
;         for this particular test.
;------------------------------------------------------------------------------
TestDvcHdrPort:
  PUSH DX                 ;Save used registers
  XOR  DH,DH              ;Get the
  MOV  DL,[DI].LHLPTIndex ;  LPT Index
  CALL ConvertIndexDX     ;Convert to Redirected Index
  CALL LPTIndex2IOAddrDX  ;Convert LPT Index to I/O Address (DX)
                          ;  (returns ZF set if invalid I/O address)
  POP  DX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF AN LPT INDEX IS ASSOCIATED WITH A REAL PARALLEL PORT
;Inputs:  DX = LPT Index (As used by Int 17h functions)
;Outputs: ZF = Clear if DX is a real Parallel Port Index
;            = Set if Not
;Changes:
;------------------------------------------------------------------------------
TestDXIsParallel:
  PUSH DX                ;Save used registers
  CALL LPTIndex2IOAddrDX ;Convert LPT Index to I/O Address (DX)
  JZ  >L90               ;If error, quit
  CALL TestIOAddrReal    ;Is it a Real I/O Address (sets ZF)?
L90:                     ;Done
  POP  DX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT AN LPT INDEX NUMBER TO A BASE I/O ADDRESS
;Inputs:  DX = LPT Index (As used by Int 17h functions)
;Outputs: ZF = Clear if OK
;              DX = Base I/O Address associated with the LPT Address
;            = Set if Error
;              DX = 0
;Changes:
;------------------------------------------------------------------------------
LPTIndex2IOAddrDX:
  PUSH AX,BX,DS  ;Save used registers
  CMP  DX,2      ;Is it an Address in the BIOS?
  JA  >X70       ;If not, error
  MOV  BX,0040h  ;Point DS at
  MOV  DS,BX     ;  BIOS Data Area
  MOV  BX,DX     ;Put the
  SHL  BX,1      ;  LPT Base Address
  MOV  DX,[BX+8] ;  in DX
  CMP  DX,0100h  ;Is it valid?
  JA  >X90       ;If so, we're done
X70:             ;Error
  XOR  DX,DX     ;Make sure DX is 0
X90:             ;Done
  OR   DX,DX     ;Set return flag
  POP  DS,BX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN SEE IF A BASE I/O ADDRESS IS REAL
;Inputs:  DX = Base I/O Address
;Outputs: ZF = Clear if OK (Address is a Real Parallel Port)
;            = Set if Error (Address is Fake, probably USB)
;Changes:
;------------------------------------------------------------------------------
TestIOAddrReal:
  PUSH AX,DX ;Save used registers
  OR   DX,DX ;Is it 0?
  JZ  >R90   ;If so, it's not Real
  INC  DX,2  ;Get the
  IN   AL,DX ;  Control Port Data
  CMP  AL,-1 ;Set the Return Flag
R90:         ;Done
  POP  DX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;POINT AT THE LAST BUFFER IN USE FOR A PARTICULAR LPT PORT
;Inputs:  [BX] = Device Info Entry to find Buffer for
;Outputs: ZF = Clear if OK (Buffer Found)
;              [DI] or [BX] = Last Buffer
;            = Set if Error (No Buffer Found)
;              DI or BX = 0
;Changes:
;------------------------------------------------------------------------------
FindLastBufferBXBX:
  PUSH DI                 ;Save used registers
  CALL FindLastBufferBXDI ;Find the Last Buffer (rtns DI & ZF)
  MOV  BX,DI              ;Put the Buffer Pointer in BX
  POP  DI                 ;Restore used registers
  RET

FindLastBufferBXDI:
  PUSHF                     ;Save flags
  CLI                       ;Disable interrupts
  MOV  DI,[BX].DIBufferPtr  ;Get the first Buffer Pointer
  OR   DI,DI                ;Is there a buffer currently in use?
  JZ  >L90                  ;If not, we're done
L10:                        ;Loop to here to find the last buffer
  CMP  [DI].BfNextBuffer,0  ;Is this the last buffer?
  JE  >L90                  ;If so, we're done
  MOV  DI,[DI].BfNextBuffer ;If not, point at the next Buffer
  JMP  L10                  ;Keep looking for the last one
L90:                        ;Done
  POPF                      ;Restore flags
  OR   DI,DI                ;Set return flag
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;MISCELLANEOUS SUPPORT FUNCTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SEARCH A BYTE-TO-WORD LOOKUP TABLE FOR A MATCH
;Inputs:  DS:[BX] = Table to search
;           or
;         ES:[BX] = table to Search
;         AL      = Byte to search for
;Outputs: CF = Clear if a byte match as found in Table
;              BX = Word from Table
;            = Set if no match found in Table
;              BX = unchanged
;Changes: Last Entry in Table (end-of-table marker) = DB -1, DW -1
;------------------------------------------------------------------------------
SearchByte2WordTblES:
  PUSH DS                   ;Save used registers
  MOV  DS,ES                ;Point DS:[BX] at the Table
  CALL SearchByte2WordTblDS ;Search the Table
  POP  DS                   ;Restore used registers
  RET

SearchByte2WordTblDS:
  PUSH AX,SI     ;Save used registers
  CLD            ;Go forward with string functions
  MOV  SI,BX     ;Put pointer in SI
  MOV  AH,AL     ;Put byte to check in AH
B10:             ;Loop to here for each table entry
  LODSB          ;Get the next table entry
  CMP  AL,-1     ;Is it possibly the end of the table?
  JNE >B20       ;If not, continue
  CMP  W [SI],-1 ;Is it actually the end of the table?
  JE  >B70       ;If so, there's no match
B20:             ;Not end of table
  CMP  AL,AH     ;Is it a match?
  JE  >B80       ;If so, handle it!
  INC  SI,2      ;If not, skip over this table entry
  JMP  B10       ;And keep looking
B70:             ;No entry found
  STC            ;Set the not found flag
  JMP >B90       ;Quit
B80:             ;Entry found [SI]
  MOV  BX,[SI]   ;Point BX at the table entry
  CLC            ;Set the found flag
B90:             ;Done
  POP  SI,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY A REQUEST (CONTROL) STRUCTURE INTO THE INT14 STRUCTURE
;Inputs:  [CX] = Request Structure to Copy
;         ES = TSR Data Area (contains both Request & Int14 Request)
;         [DI] = Int14 Request Structure to copy it to
;      or [SI] = Int14 Request Structure to copy it to
;Outputs:
;Changes: Int14 Structure contains Request Structure Data
;------------------------------------------------------------------------------
CopySetupReqToInt14SI:
  PUSH DI                    ;Save used registers
  MOV  DI,SI                 ;Put pointer in DI
  CALL CopySetupReqToInt14DI ;Copy it
  POP  DI                    ;Restore used registers
  RET

CopySetupReqToInt14DI:
  PUSH CX,DI,SI,DS                ;Save used registers
  MOV  DS,ES                      ;Point DS at TSR Data Area
  ADD  DI,OFFSET I14RSetupReqData ;Point at correct part of structure
  MOV  SI,CX                      ;Point at structure to copy
  MOV  CX,(SetupRequestSize/2)    ;Number of words to copy
  REP  MOVSW                      ;Copy it
  POP  DS,SI,DI,CX                ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO DELAY FOR A LITTLE WHILE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;DELAY FOR A SPECIFIC NUMBER OF MILLISECONDS
;Inputs:
;Outputs:
;Changes: Delays for approximately x milliseconds, doing nothing the whole time
;NOTES: Preserves Flags
;------------------------------------------------------------------------------
Delay1MS:
  PUSH AX        ;Save used registers
  MOV  AX,1      ;Delay 1 millisecond
  JMP >Y00       ;Do it
Delay5MS:
  PUSH AX        ;Save used registers
  MOV  AX,5      ;Delay 5 milliseconds
  JMP >Y00       ;Do it
Delay10MS:
  PUSH AX        ;Save used registers
  MOV  AX,10     ;Delay 5 milliseconds
;  JMP >Y00       ;Do it
Y00:
  PUSHF          ;Save flags
  STI            ;Enable interrupts
  CALL DelayMSAX ;Do it
  POPF           ;Restore flags
  POP  AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DELAY FOR A SPECIFIC NUMBER OF MICROSECONDS
;Inputs:
;Outputs:
;Changes: Delays for approximately x microseconds, doing nothing the whole time
;NOTES: Preserves Flags
;------------------------------------------------------------------------------
Delay2US:
  PUSH AX        ;Save used registers
  MOV  AX,2      ;Delay 2 microseconds
;  JMP >U00       ;Do it
;U00:
  PUSHF          ;Save flags
  STI            ;Enable interrupts
  CALL DelayUSAX ;Do it
  POPF           ;Restore flags
  POP  AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DELAY FOR A GIVEN NUMBER OF MILLISECONDS
;Inputs:  AX = number of milliseconds to wait (0-65,535)
;Outputs:
;Changes:
;------------------------------------------------------------------------------
DelayMSAX:
  PUSH AX,BX,DX  ;Save used registers
  OR   AX,AX     ;Is there anything to do?
  JZ  >D90       ;If not, just quit
  MOV  DX,1000   ;Convert
  MUL  DX        ;  to
  MOV  BX,AX     ;  microseconds (DX:BX)
D10:             ;Loop to here for each 65535 uS
  OR   DX,DX     ;Counted down high word yet?
  JZ  >D30       ;If so, handle it
  DEC  DX        ;Decrement high word
  MOV  AX,-1     ;Maximum microseconds
  JMP >D50       ;Do it
D30:             ;Counted down high word
  OR   BX,BX     ;Anything to do?
  JZ  >D90       ;If not, we're done
  MOV  AX,BX     ;Get Low Word
  XOR  BX,BX     ;Make sure it's zero next time
D50:             ;AX = Microseconds to wait
  CALL DelayUSAX ;Delay the number of microseconds specified
  JMP  D10       ;See if we need to wait some more
D90:             ;We're done
  POP  DX,BX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DELAY FOR A GIVEN NUMBER OF MICROSECONDS
;Inputs:  AX = number of microseconds to wait (0-65,535)
;Outputs:
;Changes:
;   NOTE: Delays will be slightly longer than what's asked for, never shorter.
;         Accuracy decreases with small delays or slow computers!
;------------------------------------------------------------------------------
DelayUSAX:
  PUSH AX,BX           ;Save used registers
  OR   AX,AX           ;Is there anything to do?
  JZ  >D90             ;If not, just quit
  MOV  BX,AX           ;Put it in BX
  MOV  AX,(0FFFFh/3)+1 ;Maximum time for each sub-delay
D10:                   ;Loop to here for each sub-delay
  CMP  BX,AX           ;Is it more than the maximum?
  JA  >D40             ;If so, just do the sub-delay
  MOV  AX,BX           ;If not, just do the remainder that's left
D40:                   ;Do the delay
  CALL DoDelayUS       ;Do the US Delay
  SUB  BX,AX           ;Subtract out how long we just waited
  JNZ  D10             ;If not 0 yet, do the sub-delay again
D90:                   ;We're done
  POP  BX,AX           ;Restore used registers
  RET

DoDelayUS:
  PUSH AX,BX,CX,DX ;Save used registers
  SHL  AX,1        ;Multiply by 2
  MOV  BX,11932    ;Compensate for the fact
  MUL  BX          ;  that the clock frequency
  MOV  BX,10000    ;  is actually
  DIV  BX          ;  1.19318 MHz
  MOV  DX,AX       ;Save it
  CLI              ;Disable interrupts
  CALL GetTimer    ;Get the starting timer tick counter
  MOV  CX,AX       ;Save it
D20:               ;Keep looping to here until we've waited long enough
  MOV  BX,CX       ;Get the starting timer tick counter
  CALL GetTimer    ;Get the current timer tick counter
  SUB  BX,AX       ;Calculate the elapsed time
  CMP  BX,DX       ;Has it been long enough?
  JB   D20         ;If not, keep waiting
  STI              ;Enable interrupts
D90:               ;We're done
  POP  DX,CX,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET CURRENT TIMER COUNTER FROM PORT 40h (THE CLOCK INTERRUPT)
;Inputs:
;Outputs: AX = Current timer counter word
;Changes:
;------------------------------------------------------------------------------
GetTimer:
  MOV  AL,06h ;Bits 7:6 =  00 = Timer 0
              ;Bits 5:4 =  00 = Latch Counter
              ;Bits 3:1 = 011 = Mode 3 (Square Wave)
              ;Bit    0 =   0 = Binary Counter (16 bits)
  OUT  43h,AL ;Tell the PIT what we're going to do
  IN   AL,40h ;Get LSB of timer counter
  MOV  AH,AL  ;Save it
  IN   AL,40h ;Get MSB of timer counter
  XCHG AH,AL  ;Put things in the right order
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;TROUBLESHOOTING CODE - NOT NEEDED IN PRODUCTION RELEASE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

  VideoOffsetFRow  EQU 10 ;Start at this Row (1-based)
  VideoOffsetLRow  EQU 50 ;End at this Row (1-based)
  VideoOffsetFCol  EQU 40 ;Use this Column (1-based)
  VideoOffsetFirst EQU (80*2*(VideoOffsetFRow-1))+(2*(VideoOffsetFCol-1))
  VideoOffsetLast  EQU 80*2*VideoOffsetLRow ;One past Last line of screen

  VideoOffset  DW VideoOffsetFirst ;Video Offset to use this time

;Outputs:  ES = 0B800h (Video Segment)
;          [DI] = Video Offset to use
GetVideoOffset:
  MOV  DI,0B800h                       ;Point ES at
  MOV  ES,DI                           ;  Video Memory
  MOV  DI,CS:VideoOffset               ;Point at Video Offset we want to change
  ADD  CS:VideoOffset,160              ;Go to next row for next time
  CMP  CS:VideoOffset,VideoOffsetLast  ;Gone too far yet?
  JB  >V90                             ;If not, we're done
  MOV  CS:VideoOffset,VideoOffsetFirst ;If so, reset it to the top
V90:                                   ;Video Offset updated for next time
  RET

;Inputs: DS:DI = Buffer Entry Pointer
WriteBuffer:
  PUSH AX,CX,DI,SI,ES ;Save used registers
  PUSHF               ;Save flags
  CLD                 ;Go forward with string functions
  LEA  SI,[DI].BfData ;Point SI at buffer
  CALL GetVideoOffset ;Get video offset to use (ES:DI)
  MOV  CX,BufferSize  ;Number of bytes in buffer
B10:                  ;Loop to here for each byte in buffer
  MOVSB               ;Copy the character into video memory
  XOR  B ES:[DI],077h ;Toggle the color
  INC  DI             ;Point at next character in video memory
  LOOP B10            ;Keep going until we're done
  POPF                ;Restore flags
  POP  ES,SI,DI,CX,AX ;Restore used registers
  RET

WriteAXBXCXDX:
  PUSH AX,DI,ES       ;Save used registers
  PUSHF               ;Save Flags
  CALL GetVideoOffset ;Get video offset to use (ES:DI)
  CALL WriteAXWord    ;Write AX
  MOV  AX,BX          ;Write
  CALL WriteAXWord    ;  BX
  MOV  AX,CX          ;Write
  CALL WriteAXWord    ;  CX
  MOV  AX,DX          ;Write
  CALL WriteAXWord    ;  DX
  POPF                ;Restore flags
  POP  ES,DI,AX       ;Restore used registers
  RET

WriteAXWord:
  PUSH AX,CX         ;Save used registers
  MOV  CH,4          ;Need to write 4 characters
  MOV  CL,4          ;Need to shift 4 bits at a time
W30:                 ;Loop to here for each Nibble we write
  ROL  AX,CL         ;Put bits to write in low nibble
  CALL WriteNibbleC  ;Write the Nibble
  XOR  B ES:[DI],77h ;Toggle the Color
  INC  DI            ;Skip over the Attribute Byte
  DEC  CH            ;Decrement the Loop Counter
  JNZ  W30           ;If not 0 yet, keep writing
  MOV  AL,' '        ;Write a
  STOSB              ;  Space
  XOR  B ES:[DI],77h ;Toggle the Color
  INC  DI            ;Skip over the Attribute Byte
  POP  CX,AX         ;Restore used registers
  RET

WriteAX:
  PUSH AX,CX,DI,ES    ;Save used registers
  PUSHF               ;Save Flags
  CALL GetVideoOffset ;Get video offset to use (ES:DI)
  MOV  CH,4           ;Need to write 4 characters
  MOV  CL,4           ;Need to shift 4 bits at a time
F20:                  ;Loop to here for each Nibble we write
  ROL  AX,CL          ;Put bits to write in low nibble
  CALL WriteNibbleC   ;Write the Nibble
  XOR  B ES:[DI],77h  ;Toggle the Color
  INC  DI             ;Skip over the Attribute Byte
  DEC  CH             ;Decrement the Loop Counter
  JNZ  F20            ;If not 0 yet, keep writing
  POPF                ;Restore flags
  POP  ES,DI,CX,AX    ;Restore used registers
  RET

WriteNibbleC:
  PUSH AX             ;Save used register
  AND  AL,0Fh         ;Get rid of the high nibble
  ADD  AL,'0'         ;Convert it to a number
  CMP  AL,'9'         ;Should it be a number?
  JBE >N90            ;If so, we're done
  ADD  AL,('A'-'9'-1) ;If not, convert it to a letter
N90:                  ;We're done
  STOSB               ;Write it to the string
  POP  AX             ;Restore used register
  RET                 ;We're done

  TRow EQU 50 ;Row to Toggle Color in (1-based)
  TCol EQU 80 ;Column to Toggle Color in (1-based)

ToggleColor:
  PUSH BX,DS        ;Save used registers
  PUSHF             ;Save Flags
  MOV  BX,0B800h    ;Point DS at
  MOV  DS,BX        ;  video memory
  MOV  BX,((TRow-1)*160)+((TCol-1)*2)
  INC  B [BX]       ;Change the character
  XOR  B [BX+1],77h ;Toggle the Color
  POPF              ;Restore flags
  POP  DS,BX        ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;STACK-RELATED FUNCTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;CREATE/DELETE OUR OWN STACK
;Inputs:  CS = TSR Data Area
;         StackInUse
;Outputs: Interrupts Enabled
;Changes: SS,SP to/from our stack
;------------------------------------------------------------------------------
MakeStack:
  CLI                  ;Disable interrupts
  PUSHF                ;Save
  POP  CS:TempFlags    ;  Flags
  INC  CS:StackInUse   ;Increment number-of-calls counter
  CMP  CS:StackInUse,1 ;Is this the first call?
  JNE >M90             ;If not, the stack is already in use
  MOV  CS:TempBX,BX    ;  BX in memory
  POP  BX              ;Save MakeStack's return address in BX
  MOV  CS:OldSS,SS     ;Save original SS
  MOV  CS:OldSP,SP     ;Save original SP
  MOV  SP,CS           ;Put our CS
  MOV  SS,SP           ;  into SS
  MOV  SP,LastTSRByte  ;SP = Top of Stack
  PUSH BX              ;Restore MakeStack's return address to stack
  MOV  BX,CS:TempBX    ;Restore BX from memory
M90:                   ;Done
  PUSH CS:TempFlags    ;Restore
  POPF                 ;  Flags
  STI                  ;Enable interrupts
  RET

ReturnStack:
  CLI                ;Disable interrupts
  PUSHF              ;Save
  POP  CS:TempFlags  ;  Flags
  DEC  CS:StackInUse ;Decrement number-of-calls counter
  JNZ >R90           ;If sack is still in use, quit
  MOV  CS:TempBX,BX  ;Save BX in memory
  POP  BX            ;Save MakeStack's return address in BX
  MOV  SS,CS:OldSS   ;Restore original SS
  MOV  SP,CS:OldSP   ;Restore original SP
  PUSH BX            ;Restore MakeStack's return address to stack
  MOV  BX,CS:TempBX  ;Restore BX from memory
R90:                 ;Done
  PUSH CS:TempFlags  ;Restore
  POPF               ;  Flags
  STI                ;Enable interrupts
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SPACE FOR OUR TSR STACK
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

  EVEN 16
  DB (StackSize/8) DUP ('TSRStack')


LastTSRByte:


;ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
;ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;DATA NEEDED TO INSTALL/UPDATE/SHOW STATUS (NOT NEEDED DIRECTLY IN TSR)
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;==============================================================================
;TSR Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Table of Interrupt Numbers that the TSR Intercepts
  ;First byte of each entry is the Interrupt Number
  ;Second word is the Pointer to our Interrupt Handler Code Header
  ;----------------------------------------------------------------------------
  IntNumTable:
    DB 2Fh       ;TSR Multiplex
     DW Int2FHdr
    DB 17h       ;Printer (Parallel Port) Services
     DW Int17Hdr
    DB 08h       ;Timer Tick
     DW Int08Hdr
    DB 05h       ;PrintScreen
     DW Int05Hdr
    DB 0         ;End of Table

  ;----------------------------------------------------------------------------
  ;Data needed to install as a TSR, Hooking into the Multiplex Int
  ;----------------------------------------------------------------------------
  FirstHandle DB 0 ;First available user handle for Int 2Fh


;==============================================================================
;Miscellaneous
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Miscellaneous Yes/No flags (individual bits)
  ;----------------------------------------------------------------------------
  ProgFlags        DB 00h ;Yes/No Test bits #1
    Help          EQU 01h ;User wants help?
    Uninstall     EQU 02h ;Uninstall resident program?
    InMemory      EQU 04h ;Already installed in memory?
    UseLowMemory  EQU 08h ;User does not want us in High Memory
    MemoryMoved   EQU 10h ;TSR Memory has been moved by our Auto-Code
    NoFormFeed    EQU 20h ;Don't send CR/FF's when Printing Files
    FoundSuptFile EQU 40h ;Found Support File in the Path

  ProgFlags2  DB 00h ;Yes/No Test bits #2
    DoEnvir  EQU 01h ;Parsing/Testing Environment variable
    DoStdIn  EQU 02h ;Parsing/Testing StdIn buffer
    ErrLvl   EQU 80h ;Show ErrorLevel Table

  StatusFlags     DB 00h ;Yes/No Test bits #3
    Status       EQU 01h ;Show Status
    Descriptors  EQU 02h ;Show Device/Config Descriptors Data
    BadDevices   EQU 04h ;Print Bad Device Table
    DeviceIDs    EQU 08h ;Print Device ID Strings
    PortStatuses EQU 10h ;Show Port Statuses
    Alias        EQU 20h ;Write the Alias List to the Screen

  StatusFlags2    DB 00h ;Yes/No Test bits #4
    DidReset     EQU 01h ;Reset at least one LPT Port
    DidEpson     EQU 02h ;Sent at least one Epson Init String
    DidPrints    EQU 04h ;Printed File(s)
    CopyCancel   EQU 08h ;User Cancelled COPY Print Command or Printer/Disk Err
    UserBreak    EQU 10h ;User pressed Ctrl-C/Ctrl-Break while COPYing
    DiskError    EQU 20h ;Disk (Critical) Error

  ;----------------------------------------------------------------------------
  ;Miscellaneous Strings we need to write to the screen
  ;----------------------------------------------------------------------------
  HexString: DB '0000',0
  CrLfMsg:   DB CR,LF,0
  SingleMsg: DB ' '
  NoMsg:     DB 0
  Space5Msg: DB ' '
  Space4Msg: DB ' '
  Space3Msg: DB ' '
  Space2Msg: DB ' '
  SpaceMsg:  DB ' ',0
  Dot4Msg:   DB '...'
  DotMsg:    DB '.',0


;==============================================================================
;Copy Files to Printer Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings and data to show we are not stalled
  ;----------------------------------------------------------------------------
  FaceMsg:    DB BackSpace, 1 ,0 ;Backspace, Face, End-of-String
  FaceEndMsg: DB BackSpace,' ',0 ;Backspace, Space, End-of-String

  BIOSClockLoc EQU 6Ch ;Location of Clock Timer (DWord) in the BIOS Data Area
  TimerStart    DW  ?  ;BIOS Clock Timer at start of file print

  ;----------------------------------------------------------------------------
  ;Special Interrupt Vectors we need to process while printing
  ;----------------------------------------------------------------------------
  FunkyIntTable:
    DB 1Bh       ;Ctrl-Break Handler
     DW Int1BHdr
    DB 23h       ;Ctrl-C Handler
     DW Int23Hdr
    DB 24h       ;DOS Critical Error Handler
     DW Int24Hdr
    DB 0         ;End of Table


;==============================================================================
;Pause Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings and Data needed to Pause the screen
  ;----------------------------------------------------------------------------
  PauseMsg:
    DB CR,LF
    DB ' MORE   (Esc stops Pausing, Ctrl-C stops Completely, any other Continues)',CR,0
  PauseNMsg:
    DB ' MORE                                                                    ',CR,LF,0
  PauseDMsg:
    DB '                                                                               ',CR,0
  PauseRows       DW ? ;Number of rows per screen
  PauseHeaderPtr  DW 1 ;Pointer to Header Message (start with a fake one <> 0)
  PauseHeaderSize DW 2 ;Number of lines in the Header Message
  PauseRowCount   DW 2 ;Current Row Counter


;==============================================================================
;DOS Environment Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Variables to search for our Environment Variable
  ;----------------------------------------------------------------------------
  EnvVarString:  DB 'USBPRINT='    ;Environment Variable String
  EnvVarSize    EQU $-EnvVarString ;Length of String
  EnvVarPointer  DW -1             ;Pointer to Program Environment Variable

  ;----------------------------------------------------------------------------
  ;Variables to search for an extended Command Line String
  ;This should only be valid/needed if the Command Line Size (PSP:[80h]) is 7Eh
  ;----------------------------------------------------------------------------
  CmdLineVarString:  DB 'CMDLINE='         ;Environment Variable String
  CmdLineVarSize    EQU $-CmdLineVarString ;Length of String
  CmdLineVarPointer  DW -1                 ;Pointer to Program Environment Variable


;==============================================================================
;EXEC Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Size of our program stack (in bytes)
  ;----------------------------------------------------------------------------
  ProgStackSize EQU 512

  ;----------------------------------------------------------------------------
  ;Variables to Locate and Run another Program (EXEC Child Program)
  ;----------------------------------------------------------------------------
  PathToUse:      DB MaxPathSize DUP (0) ;Path to Use
  OurPathPointer  DW -1                  ;Pointer to our Path String
  CurrentPath:    DB  0                  ;Current Path (Zero-Length ASCIIZ)
  PathVarPointer  DW -1                  ;Pointer to PATH Environment Variable
  SupportFile:    DB 'USBSUPT1.COM',0    ;Support File Name to Look for
  PathVarString1: DB 'PATH='             ;PATH Environment String Header (DOS)
  PathVarString2: DB 'Path='             ;PATH Environment String Header (NT?)
  PathVarSize    EQU $-PathVarString2    ;Length of String

  ;----------------------------------------------------------------------------
  ;Variables needed to do EXEC Call
  ;----------------------------------------------------------------------------
  CmdTailSize DB CmdTailMax-2           ;Length of command tail (Maximize it)
  CmdTail:    DB CmdTailMax DUP (CR)    ;Command Tail for EXEC Call
  ParamBlock: DB ParamBlockSize DUP (?) ;Parameter Block for EXEC Call
  FCB1:       DB FCBSize DUP (?)        ;File Control Block #1
  FCB2:       DB FCBSize DUP (?)        ;File Control Block #2
  OldSPExec   DW ?                      ;SP may be destroyed by EXEC Call

  ;----------------------------------------------------------------------------
  ;Strings needed to write Descriptor Header Information to the screen
  ;----------------------------------------------------------------------------
  HostIndexMsg:  DB 'USB HOST INDEX: ',0
  DvcAddressMsg: DB 'DEVICE ADDRESS: ',0

  ;----------------------------------------------------------------------------
  ;Strings needed to set up Command Tail for Exec Calls
  ;----------------------------------------------------------------------------
  DescriptorMsg:     DB 'Descriptor '
  DescriptorMsgAddr: DB 'xxxx:xxxx '
  DescriptorMsgHost: DB 'xxh '
  DescriptorMsgDvc:  DB 'xxh '
  DescriptorCallBk:  DB 'xxxx:xxxx'
                     DB  0

  TDStatusMsg:    DB 'TDStatusCode '
  TDStatusCode:   DB 'xxxxh '
  TDStatusCallBk: DB 'xxxx:xxxx'
                  DB 0

  Int14ErrMsg:    DB 'Int14ErrorCode '
  Int14ErrCode:   DB 'xxxxh '
  Int14ErrCallBk: DB 'xxxx:xxxx'
                  DB 0

  ;----------------------------------------------------------------------------
  ;Error Message for when the Support File is not found
  ;----------------------------------------------------------------------------
  NoSuptFileMsg:
    DB 'Error! Need Support File ',0


;==============================================================================
;Help Screen Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Data needed if the User has changed the name of the program from USBPRINT
  ;----------------------------------------------------------------------------
  RealName:
    DB 'USBPRINT',0 ;Real name of our program (MUST end in 0)
                    ;  & MUST have enough space for 8-char name
  RealNameSz DW 8   ;Size of RealName (not incl 0)

  ;----------------------------------------------------------------------------
  ;Syntax Help String (if user asks for, or otherwise needs, Help)
  ;----------------------------------------------------------------------------
  SyntaxMsgHdr:
    DB 'SYNTAX: ',0
  SyntaxMsg:
    DB '[Options]',CR,LF
    DB LF
    DB '  ?         Í Show this HELP screen',CR,LF
    DB '  A         Í Show all ALIASES for these command line Options',CR,LF
    DB '  ErrLvl    Í Show all ErrorLevels (DOS Return Codes)',CR,LF
    DB '  U         Í UNINSTALL from memory',CR,LF
    DB '  L:Y/N     Í Force installation into LOW memory (Default = No)',CR,LF
    DB '  Bound:Y/N Í Enable BOUND CPU OpCode bug patch (Default = Yes)',CR,LF
    DB LF
    DB '  S    Í Display current STATUS of program',CR,LF
    DB '  C    Í Display CONFIGURATION (& other) descriptors of last printer found',CR,LF
    DB '  I    Í Display ID strings of printers',CR,LF
    DB '  Port Í Show status(es) of all LPT Ports',CR,LF
    DB LF
    DB '  B        Í Show list of BAD (incompatible) printers found',CR,LF
    DB '  Beep:Y/N Í BEEP Speaker when bad printer is found (Default = Yes)',CR,LF
    DB LF
    DB '  D:# Í DISABLE printer index # (0-7, 255 = All)',CR,LF
    DB '  E:# Í ENABLE printer index # (0-7, 255 = All)',CR,LF
    DB LF
    DB '  R:#             Í Soft RESET (Initialize) LPT# (1-9)',CR,LF
    DB '  M:From# To#     Í ReMAP (redirect) from LPT# to LPT# (1-9)',CR,LF
    DB '  Copy FileName # Í COPY (print) filename to LPT# (1-9)',CR,LF
    DB '  FormFeed:Y/N  # Í Send FormFeed after each text file copied (Default = Yes)',CR,LF
    DB '  NoParallel:Y/N  Í Overwrite Parallel ports with USB ports (Default = No)',CR,LF
    DB '  IOAddress:#     Í Use # as "fake" base I/O Address in BIOS',CR,LF
    DB '                      (400h-FFE0h, divisible by 32 (20h), Default = Automatic)',CR,LF
    DB LF
    DB '  AutoEpson:Y/N Í Automatically send Epson USB select string (Default = Yes)',CR,LF
    DB '  SendEpson:#   Í Manually Send Epson USB select string to LPT# (1-9)'
    DB 0


;==============================================================================
;Program Status Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings needed to print the Program Status to the screen
  ;----------------------------------------------------------------------------
  StatusMsgHdr1:
    DB '        OVERALL PROGRAM STATUS',CR,LF
    DB '  ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ',CR,LF
  StatusMsgUSBHost:
    DB '  USB Host Driver Installed:    ',0
  StatusMsgBoundFix:
    DB '  Fix BOUND OpCode Bug:         ',0
  StatusMsgBeep:
    DB '  Beep for Bad Printers:        ',0
  StatusMsgParallel:
    DB '  Overwrite Parallel Ports:     ',0
  StatusMsgEpson:
    DB '  Send Epson USB Init Strings:  ',0
  StatusMsgIOAddr:
    DB '  "Fake" Base I/O Address:     ',0

  StatusMsgHdr2:
    DB LF
    DB LF
    DB '                         INDIVIDUAL USB PRINTER STATUSES',CR,LF
    DB '  ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ',CR,LF
    DB 0

  StatusMsgHdr3:
    DB '  I B E',CR,LF
    DB '  n i p',CR,LF
    DB '  d D s                  Alt',CR,LF
    DB '  e i o      Hst Dvc Itf Itf',CR,LF
    DB '  x r n Port Idx Adr Num Num                    Description',CR,LF
    DB '  Ä Ä Ä ÄÄÄÄ ÄÄÄ ÄÄÄ ÄÄÄ ÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ',CR,LF
    DB 0

  NoDeviceMsg:
    DB '  #################  No USB Printers are Currently Installed  #################',CR,LF,0
  YesMsg:      DB 'Yes',0
  NoMsgS:      DB ' No',0


;==============================================================================
;LPT Port Status Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings needed to write the Port Statuses
  ;----------------------------------------------------------------------------
  PortStatusHdr:
    DB '                           STATUS OF PARALLEL PORT(s)',CR,LF
    DB '  ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ',CR,LF
    DB '  Redirected Ports: '
    DB 0

  PortStatusHdr2:
    DB CR,LF
    DB LF
    DB LF
    DB '              N A   N I T ',CR,LF
    DB '            S o c   o O i ',CR,LF
    DB '            e t k   P E m ',CR,LF
    DB '            l B n   a r e ',CR,LF
    DB '            e u o   p r O ',CR,LF
    DB '            c s w   e o u    I/O BASE',CR,LF
    DB '            t y l   r r t    ADDRESS                  DESCRIPTION',CR,LF
    DB '           ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÙ  ÄÄÄÄÄÄÄÄÄÄ  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ',CR,LF
    DB 0

  PortStatusFtr:
    DB CR,LF
    DB '  * = Redirected Port',CR,LF
    DB '  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ',CR,LF
    DB '  Select + NoPaper = No Printer Installed',CR,LF
    DB '  Select + NotBusy = Printer Ready',CR,LF
    DB 0

  NoneMsg:       DB 'None',0
  RedirMsg:      DB ' => ',0
  Yes2Msg:       DB 'Y ',0
  No2Msg:        DB '. ',0
  FakeMsg:       DB 'fake',0
  NoPrinterMsg:  DB 'No Printer Installed',0
  UnknownPrnMsg: DB 'Unknown Printer',0
  QuestionsMsg:  DB '     ???? ',0

  DesString1:     DB 'DES:'
  DesString1Size EQU $-DesString1
  DesString2:     DB 'DESCRIPTION:'
  DesString2Size EQU $-DesString2
  MfgString1:     DB 'MFG:'
  MfgString1Size EQU $-MfgString1
  MfgString2:     DB 'MANUFACTURER:'
  MfgString2Size EQU $-MfgString2
  MdlString1:     DB 'MDL:'
  MdlString1Size EQU $-MdlString1
  MdlString2:     DB 'MODEL:'
  MdlString2Size EQU $-MdlString2


;==============================================================================
;Device ID String Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings and Data needed to Get Device ID Strings
  ;----------------------------------------------------------------------------
  DvcIDBuffer:
    DB DvcIDBufferSize DUP (0) ;Buffer to store the string in

  NoPrintersMsgID:
    DB 'There are currently no Printers with Device IDs attached to the computer.',0
  LPTMsg:
    DB 'LPT',0
  ParallelMsgID:
    DB 'Parallel Port Base I/O Address: ',0
  UnmappedMsg:
    DB 'Unmapped:',0
  HostIndexMsgID:
    DB 'USB Host Index: ',0
  DvcAddrMsg:
    DB 'Device Address: ',0
  DvcIDHdrMsg:
    DB CR,LF
    DB 'ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ'
    DB CR,LF
    DB 0


;==============================================================================
;Data needed to Print (COPY) a file to a printer
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Sizes of buffers needed to Open/Read/Write Files
  ;----------------------------------------------------------------------------
  MaxFileNameSize EQU 1024 ;Size of FileName (including Path)
  TempBufferSize  EQU 1024 ;Size of Buffer to Test LFN and to print File(s)

  ;----------------------------------------------------------------------------
  ;Access Type Bit Masks (for Open File Functions)
  ;----------------------------------------------------------------------------
  OpenFileReadOnly   EQU 0000h ;Read-Only
  OpenFileWriteOnly  EQU 0001h ;Write-Only
  OpenFileReadWrite  EQU 0002h ;Read/Write
  ;Bit 3 = Reserved (0)
  ;Sharing Mode Bit Masks (for Open File Functions)
  OpenFileCompat     EQU 0000h ;Compatibility Mode
  OpenFileDenyAll    EQU 0010h ;Prohibit Any access by others
  OpenFileDenyWrite  EQU 0020h ;Prohibit Write access by others
  OpenFileDenyRead   EQU 0030h ;Prohibit Read access by others
  OpenFileDenyNone   EQU 0040h ;No Prohibition of access by others
  OpenFileNoInherit  EQU 0080h ;File is private to current process
  ;DOS 7+, Win95+
  OpenFileNoUpdate   EQU 0100h ;Do not Update Access Time (DOS 7.0+)
  OpenFileNoBuffer   EQU 0100h ;Do not Buffer Data (Win95)
  OpenFileNoCompress EQU 0200h ;Do not Compress data
  OpenFileUseHint    EQU 0400h ;Use Alias Hint in DI
  ;Bits 11-12 Reserved
  OpenFileFAT32      EQU 1000h ;FAT32/Extended Size (DOS 7+?)
  OpenFileRtnError   EQU 2000h ;Return Error rather than issuing INT 24h
  OpenFileCommit     EQU 4000h ;Auto-Commit on Every Write


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;DATA
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

  ;----------------------------------------------------------------------------
  ;Flags we use to know whether or not a File is Text or Not
  ;----------------------------------------------------------------------------
  FileFlagNotFirstRead EQU 01h ;First Read (first bytes) of File
  FileFlagDoFormFeed   EQU 02h ;Do a CR/FF for this file

  ;----------------------------------------------------------------------------
  ;Buffer to store the File Name (ASCIIZ)
  ;----------------------------------------------------------------------------
  FileNameBuffer: DB MaxFileNameSize DUP (0)

  ;----------------------------------------------------------------------------
  ;Buffer to Test LFN Functionality & to temporarily store what we're printing
  ;----------------------------------------------------------------------------
  TempBuffer: DB TempBufferSize DUP (0) ;Stores current Dir & what's printing

  ;----------------------------------------------------------------------------
  ;Buffer for LFN Find Data calls & DTA (non-LFN) Find Data calls
  ;----------------------------------------------------------------------------
  FindFileBuffer:  DB 1024 DUP (0)
  DTABuffer       EQU OFFSET FindFileBuffer

  ;----------------------------------------------------------------------------
  ;Printer Index to use while Copying Files
  ;----------------------------------------------------------------------------
  PrintIndex DW ?

  ;----------------------------------------------------------------------------
  ;Text String at beginning of File sent to PostScript Printer
  ;----------------------------------------------------------------------------
  PSFileHdr:     DB '%!PS-Adobe-'
  PSFileHdrSize EQU $-PSFileHdr

  ;----------------------------------------------------------------------------
  ;Pointer to "Extra" Error Message (needed for certain types of Errors)
  ;----------------------------------------------------------------------------
  ExtraErrMsg DW 0 ;If not 0, need to print it as part of command-line Errors

  ;----------------------------------------------------------------------------
  ;Strings needed to Print Files to a Printer
  ;----------------------------------------------------------------------------
  FileErrMsgTbl:
    DB 01h
       DB 'Invalid Function Number.',0 ;Invalid Function Number
    DB 02h
       DB 'File not Found.',0
    DB 03h
       DB 'Path not Found.',0
    DB 04h
       DB 'No File Handles Available.',0
    DB 05h
       DB 'Access Denied.',0
    DB 06h
       DB 'Invalid Handle.',0
    DB 07h
       DB 'Memory Control Block Destroyed.',0
    DB 08h
       DB 'Insufficient Memory.',0
    DB 09h
       DB 'Invalid Memory Block Address.',0
    DB 0Ah
       DB 'Invalid Environment (usually >32K in length).',0
    DB 0Bh
       DB 'Invalid Format.',0
    DB 0Ch
       DB 'Invalid Access Code.',0
    DB 0Dh
       DB 'Invalid Data.',0
    DB 0Eh
       DB 'Reserved.',0
    DB 0Fh
       DB 'Invalid Drive.',0
    DB 10h
       DB 'Attempted to Remove Current Directory.',0
    DB 11h
       DB 'Not Same Device.',0
    DB 12h
       DB 'File Not Found.',0
    DB 56h
       DB 'Invalid Password.',0
    DB -1     ;End of
       DB -1  ;  Table

  FileErrMsgDef:
    DB 'Error Opening File',0

  PrintingMsg:
    DB 'Printing: ',0

  FFSentMsg:
    DB '{New Page}',0

  ;----------------------------------------------------------------------------
  ;Strings needed while doing COPYs to a Printer
  ;----------------------------------------------------------------------------
  PressEscMsg:
    DB CR,LF
    DB 'Press <Escape> to cancel Printing.',CR,LF
    DB LF,0

  UserCancelMsg:
    DB CR,LF
    DB LF
    DB 'Print Cancelled by User.',CR,LF
    DB LF,0

  PrinterErrMsg:
    DB CR,LF
    DB LF
    DB 'Error! Timed Out waiting for Printer.',CR,LF
    DB LF,0

  DiskErrMsg:
    DB CR,LF
    DB LF
    DB 'Error! Unable to access File.',CR,LF
    DB LF,0


;==============================================================================
;Bad Device Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings needed to print Bad Device Table to the screen
  ;----------------------------------------------------------------------------
  BadDeviceHdr:
    DB ' BAD (INCOMPATIBLE) PRINTERS',CR,LF
    DB 'ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ',CR,LF
    DB  LF
    DB 'HOST  DVC   INTF  STAGE  ERROR',CR,LF
    DB 'INDX  ADDR  NUM    NUM   CODE',CR,LF
    DB 'ÄÄÄÄ  ÄÄÄÄ  ÄÄÄÄ  ÄÄÄÄÄ  ÄÄÄÄÄ',CR,LF
    DB  0

  NoneFoundMsg:
    DB '#ÄÄ#  #ÄÄ#  None  #ÄÄÄ# #ÄÄÄ#',CR,LF,0
  BadBeepMsg:
    DB 'Beep for Bad Printers: ',0


;==============================================================================
;ErrorLevel Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;ErrorLevels, and Table for ErrorLevel Description Strings
  ;----------------------------------------------------------------------------
  ErLvlOption   EQU 1 ;Bad Option on the command line
  ErLvlMemory   EQU 2 ;Memory problem with the computer
  ErLvlUninst   EQU 3 ;Not in memory yet, can't perform Request
  ErLvlVersion  EQU 4 ;Another version of the program already installed
  ErLvlDOSVer   EQU 5 ;DOS Version too old
  ErLvlStdIn    EQU 6 ;StdIn file too big
  ErLvlNoData   EQU 7 ;No Report/Descriptor Data to Print
  ErLvlSuptFile EQU 8 ;Could not Find Support File

  ErrLvlHdr:
    DB  CR,LF
    DB '                     ERRORLEVELS (DOS RETURN CODES)',CR,LF
    DB '  ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ',CR,LF
    DB '   0 No Error.',CR,LF
    DB 0

  ErrLvlTbl:
    DB ErLvlOption
       DB "Bad Command-line Option.",0
    DB ErLvlMemory
       DB "Memory problem with the computer.",0
    DB ErLvlUninst
       DB "USBPRINT is not installed in memory yet -- can't perform Request.",0
    DB ErLvlVersion
       DB "A different version of USBPRINT is already installed in memory.",0
    DB ErLvlDOSVer
       DB "DOS must be at least version 3.00.",0
    DB ErLvlStdIn
       DB "The Redirected Input Option File (USBPRINT < InFile) is too big.",0
    DB ErLvlNoData
       DB "There is no Report or Configuration Descriptor data to write.",0
    DB ErLvlSuptFile
       DB "Could not find the required USBSUPT1.COM support file.",0
    DB -1,-1 ;End of Table


;==============================================================================
;Alias Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings needed to print Command Line Aliases to the screen
  ;----------------------------------------------------------------------------
  AliasHdrMsg:
    DB '                       ALIASES FOR COMMAND-LINE OPTIONS',CR,LF
    DB 'ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ',CR,LF
    DB 0

  YesNoHdrMsg:
    DB '       ALIASES FOR YES & NO',CR,LF
    DB 'ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ',CR,LF
    DB 0

  PrinterHdrMsg:
    DB 'ALIASES FOR PRINTER INDEXES',CR,LF
    DB 'ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ',CR,LF
    DB 0

  ;----------------------------------------------------------------------------
  ;Table needed to temporarily store Aliases.
  ;They are originally sorted in reverse alphabetical order.
  ;To write them in forward alphabetical order, we temporarily store
  ;  the String Pointers, in the original reverse order, in this table.
  ;  We then write the strings, starting with the last entry in this table
  ;  and moving backwards.
  ;The number of entries in this table must be AT LEAST as big as the largest
  ;  number of Aliases for a single command Option.  Most Options don't have
  ;  more than a dozen or so Aliases.
  ;----------------------------------------------------------------------------
  AliasSortTbl: DW 50 DUP (?) ;Table to store Alias Strings (to reverse order)


;==============================================================================
;Command-line (Parsing) Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Extra Memory Segment (used to store compressed contents of STDIN)
  ;----------------------------------------------------------------------------
  ExtraMemSegment DW ?

  ;----------------------------------------------------------------------------
  ;Data needed to Parse the command line for Options
  ;----------------------------------------------------------------------------
  ParseTest  DB Yes ;Testing the command for errors?
  ParseError DB  No ;Error while Parsing Command Line?

  ;----------------------------------------------------------------------------
  ;Various Parsing-related messages we may need to print to the screen
  ;----------------------------------------------------------------------------
  ParseCmdMsg:
    DB 'Error in the command-line Options for USBPRINT:',CR,LF,0
  ParseEnvMsg:
    DB 'Error in the Environment variable "USBPRINT":',CR,LF,0
  ParseStdInMsg:
    DB 'Error in the redirected input file ("USBPRINT < {FileName}"):',0
  ParseErrMsg:
    DB '^ Error',CR,LF,LF,0
  ParseEnvMsg2:
    DB 'Reset the Environment variable (type "SET USBPRINT=") and then',CR,LF
  ParseErrMsg2:
    DB 'Type "USBPRINT ?" for Help.',CR,LF,0
  StdInTooBigMsg:
    DB 'The redirected input file ("USBPRINT < {FileName}") is too big!',CR,LF,0

  Copyright:
    DB "USBPRINT 0.08, (C) 2007-2009, Bret E. Johnson.",CR,LF
    DB "DOS Driver for up to 8 USB Printers.",CR,LF
    DB  LF,0
  EnvMsg:
    DB 'Environment: ',0
  InstallMsg1:
    DB 'USBPRINT has been ',0
  InstallMsgAuto:
    DB 'automatically ',0
  InstallMsgHigh:
    DB 'installed into Upper Memory.',0
  InstallMsgHole:
    DB 'installed into a Low Memory "Hole".',0
  InstallMsgNorm:
    DB 'installed into Low Memory.',0
  InstallMsgLast:
    DB CR,LF
    DB 'Type "USBPRINT U" to Uninstall USBPRINT from memory.',CR,LF,0
  DOSVerMsg:
    DB 'You must be using DOS version 3.00 or later to use this program.',0
  NoEnvironMsg:
    DB 'There is no DOS Environment.',CR,LF
    DB 'There is something WEIRD going on here!',0
  ExtraMemoryMsg:
    DB 'There is not enough available memory to run this program!',0
  WrongVerMsg:
    DB 'Another version of USBPRINT was found in memory.',CR,LF
    DB 'Please UNINSTALL the other version before continuing.',0
  NoDescrDataMsg:
    DB 'There is no Descriptor Data to Write!',0
  UninstallMsg:
    DB 'USBPRINT has been Uninstalled from memory.',CR,LF,0
  NoUninstallMsg:
    DB 'Unable to Uninstall USBPRINT from memory.',CR,LF
    DB "Remove any TSR's installed after USBPRINT and try again.",CR,LF
    DB LF
    DB 'To Re-Enable USBPRINT, simply type "USBPRINT" at the command-line.',0
  ReEnabledMsg:
    DB 'USBPRINT has been Re-Enabled.',CR,LF
    DB LF,0
  UninstallErrMsg:
    DB "Can't find USBPRINT in memory.",CR,LF
    DB 'You must install it before it can be Uninstalled.',0
  UpdateMsg:
    DB 'Resident USBPRINT has been updated with new information.',0
  ResetsDoneMsg:
    DB 'Printer(s) have been Reset.',0
  EpsonsDoneMsg:
    DB 'Epson Printer(s) have been Initialized.',0
  DblRedirectMsg:
    DB 'You cannot Remap a Port to another Port that is itself Remapped.',0
  BadLPTMsg:
    DB 'No Printer is installed on that LPT Port.',0
  BadFileMsg:
    DB 'No File by that name exists.',0
  NextPortMsg:
    DB 'The first attached USB Printer will be mapped as LPT',0
  NoPortMsg:
    DB 'There are no available LPTx ports to assign to the next USB printer!',0
  BadDvcErrMsg:
    DB 'Bad Device',0
  DescrErrMsg:
    DB 'Descriptor',0
  StatusErrMsg:
    DB 'Program Status',0
  DataErrMsg:
    DB ' Data is not available until after',CR,LF
    DB '  USBPRINT has been installed into memory.',0

  ;----------------------------------------------------------------------------
  ;Strings needed to write the Command-line error message
  ;----------------------------------------------------------------------------
  MoreLeftMsg:   DB '<<-More}  ',0
  MoreRightMsg:  DB '  {More->>',0
  MoreMsgSize   EQU $-MoreRightMsg

  ;----------------------------------------------------------------------------
  ;Command Line Options with no single-character equivalents
  ;These must be in the same numerical order that we want the
  ;  Alias Option to Sort them in!
  ;----------------------------------------------------------------------------
  OptionAutoEpson  EQU  1 ;Auto-Initialize Epson Printers
  OptionBeep       EQU  2 ;Beep the speaker
  OptionNoBoundFix EQU  3 ;Fix BOUND Bug
  OptionNoParallel EQU  4 ;Overwrite Parallel Ports
  OptionCopy       EQU  5 ;Copy (Printer) File to Printer
  OptionErrLvl     EQU  6 ;Write ErrorLevel Table
  OptionIOAddress  EQU  7 ;Assign I/O Base Address
  OptionPortStatus EQU  8 ;Show Port Statuses
  OptionSendEpson  EQU  9 ;Send Init String to Epson Printer

  ;----------------------------------------------------------------------------
  ;Command Line Options
  ;----------------------------------------------------------------------------
  SwitchList:
    DB 'Help',0
    DB  0, '?'
      ; ^              Beginning-of-List Marker
      ;    ^   ^        Code(s) to use

    DB 'UseLowMemory',0
    DB 'UseLowMem',0
    DB 'UseLowerMemory',0
    DB 'UseLowerMem',0
    DB 'UseLow',0
    DB  0, 'L'

    DB 'Uninstall',0
    DB  0, 'U'

    DB 'StatusTbl',0
    DB 'StatusTable',0
    DB  0, 'S'

    DB 'StatusofPrinters',0
    DB 'StatusofPrinter',0
    DB  0, 'S'

    DB 'Status',0
    DB  0, 'S'

    DB 'Sounds',0
    DB 'Sound',0
    DB  0, OptionBeep

    DB 'SoftReset',0
    DB  0, 'R'

    DB 'ShowStatusTbl',0
    DB 'ShowStatusTable',0
    DB 'ShowStatus',0
    DB  0, 'S'

    DB 'SendFormFeeds',0
    DB 'SendFormFeed',0
    DB  0, 'F'

    DB 'SendFFs',0
    DB 'SendFF',0
    DB  0, 'F'

    DB 'SendEpsonSelectString',0
    DB 'SendEpsonSelect',0
    DB  0, OptionSendEpson

    DB 'SendEpsonInitializeString',0
    DB 'SendEpsonInitialize',0
    DB  0, OptionSendEpson

    DB 'SendEpsonInitString',0
    DB 'SendEpsonInit',0
    DB 'SendEpson',0
    DB  0, OptionSendEpson

    DB 'Reset',0
    DB  0, 'R'

    DB 'ReplaceParallelPorts',0
    DB 'ReplaceParallelPort',0
    DB 'ReplaceParallel',0
    DB  0, OptionNoParallel

    DB 'Remove',0
    DB  0, 'U'

    DB 'ReMap',0
    DB  0, 'M'

    DB 'ReDirect',0
    DB 'ReDir',0
    DB  0, 'M'

    DB 'PrinterStatusTbl',0
    DB 'PrinterStatusTable',0
    DB 'PrinterStatus',0
    DB  0, 'S'

    DB 'PrintFile',0
    DB 'Print',0
    DB  0, OptionCopy

    DB 'PortStatuses',0
    DB 'PortStatus',0
    DB 'Ports',0
    DB 'Port',0
    DB  0, OptionPortStatus

    DB 'ParallelPortStatuses',0
    DB 'ParallelPortStatus',0
    DB 'ParallelPorts',0
    DB 'ParallelPort',0
    DB  0, OptionPortStatus

    DB 'OverwriteParallelPorts',0
    DB 'OverwriteParallelPort',0
    DB 'OverwriteParallel',0
    DB  0, OptionNoParallel

    DB 'Out',0
    DB  0, 'U'

    DB 'OptionAliases',0
    DB 'OptionAlias',0
    DB  0, 'A'

    DB 'NoParallelPorts',0
    DB 'NoParallelPort',0
    DB 'NoParallel',0
    DB  0, OptionNoParallel

    DB 'Map',0
    DB  0, 'M'

    DB 'LowMemory',0
    DB 'LowMem',0
    DB 'LowerMemory',0
    DB 'LowerMem',0
    DB 'Low',0
    DB  0, 'L'

    DB 'IOBaseAddress',0
    DB 'IOBaseAddr',0
    DB 'IOBase',0
    DB 'IOAddress',0
    DB 'IOAddr',0
    DB 'IO',0
    DB  0, OptionIOAddress

    DB 'InputOutputBaseAddress',0
    DB 'InputOutputBaseAddr',0
    DB 'InputOutputBase',0
    DB 'InputOutputAddress',0
    DB 'InputOutputAddr',0
    DB 'InputOutput',0
    DB  0, OptionIOAddress

    DB 'InOutBaseAddress',0
    DB 'InOutBaseAddr',0
    DB 'InOutBase',0
    DB 'InOutAddress',0
    DB 'InOutAddr',0
    DB 'InOut',0
    DB  0, OptionIOAddress

    DB 'IntfDescriptor',0
    DB 'IntfDescr',0
    DB 'Intf',0
    DB  0, 'C'

    DB 'InterfaceDescriptor',0
    DB 'InterfaceDescr',0
    DB 'Interface',0
    DB  0, 'C'

    DB 'Initialize',0
    DB 'Init',0
    DB  0, 'R'

    DB 'IncompatiblePrintersList',0
    DB 'IncompatiblePrinterList',0
    DB 'IncompatiblePrinters',0
    DB 'IncompatiblePrinter',0
    DB 'Incompatible',0
    DB  0, 'B'

    DB 'IDStrings',0
    DB 'IDString',0
    DB 'IDs',0
    DB 'IdentificationStrings',0
    DB 'IdentificationString',0
    DB 'ID',0
    DB  0, 'I'

    DB 'Hlp',0
    DB 'H',0
    DB  0, '?'

    DB 'FormFeeds',0
    DB 'FormFeed',0
    DB  0, 'F'

    DB 'ForceLowMemory',0
    DB 'ForceLowMem',0
    DB 'ForceLowerMemory',0
    DB 'ForceLowerMem',0
    DB 'ForceLow',0
    DB  0, 'L'

    DB 'FFs',0
    DB 'FF',0
    DB  0, 'F'

    DB 'ErrorLvlTbl',0
    DB 'ErrorLvlTable',0
    DB 'ErrorLvls',0
    DB 'ErrorLvl',0
    DB 'ErrorLevelTbl',0
    DB 'ErrorLevelTable',0
    DB 'ErrorLevels',0
    DB 'ErrorLevel',0
    DB  0, OptionErrLvl

    DB 'ErrLvlTbl',0
    DB 'ErrLvlTable',0
    DB 'ErrLvls',0
    DB 'ErrLvl',0
    DB 'ErrLevelTbl',0
    DB 'ErrLevelTable',0
    DB 'ErrLevels',0
    DB 'ErrLevel',0
    DB  0, OptionErrLvl

    DB 'ErLvlTbl',0
    DB 'ErLvlTable',0
    DB 'ErLvls',0
    DB 'ErLvl',0
    DB 'ErLevelTbl',0
    DB 'ErLevelTable',0
    DB 'ErLevels',0
    DB 'ErLevel',0
    DB  0, OptionErrLvl

    DB 'EndPointDescriptor',0
    DB 'EndPointDescr',0
    DB 'EndPoint',0
    DB  0, 'C'

    DB 'EndPtDescriptor',0
    DB 'EndPtDescr',0
    DB 'EndPt',0
    DB  0, 'C'

    DB 'DvcIDStrings',0
    DB 'DvcIDString',0
    DB 'DvcIDs',0
    DB 'DvcIdentificationStrings',0
    DB 'DvcIdentificationString',0
    DB 'DvcID',0
    DB  0, 'I'

    DB 'DvcDescriptor',0
    DB 'DvcDescr',0
    DB 'Dvc',0
    DB  0, 'C'

    DB 'DeviceIDStrings',0
    DB 'DeviceIDString',0
    DB 'DeviceIDs',0
    DB 'DeviceIdentificationStrings',0
    DB 'DeviceIdentificationString',0
    DB 'DeviceID',0
    DB  0, 'I'

    DB 'DeviceDescriptor',0
    DB 'DeviceDescr',0
    DB 'Device',0
    DB  0, 'C'

    DB 'Descriptors',0
    DB 'Descriptor',0
    DB 'Descrs',0
    DB 'Descr',0
    DB  0, 'C'

    DB 'CopyFile',0
    DB 'Copy',0
    DB  0, OptionCopy

    DB 'ConfigurationDescriptor',0
    DB 'ConfigurationDescr',0
    DB 'Configuration',0
    DB  0, 'C'

    DB 'ConfigDescriptor',0
    DB 'ConfigDescr',0
    DB 'Config',0
    DB  0, 'C'

    DB 'CommandLineAliases',0
    DB 'CommandLineAlias',0
    DB  0, 'A'

    DB 'CmdLineAliases',0
    DB 'CmdLineAlias',0
    DB  0, 'A'

    DB 'BypassParallelPorts',0
    DB 'BypassParallelPort',0
    DB 'BypassParallel',0
    DB  0, OptionNoParallel

    DB 'BoundPatch',0
    DB 'BoundOpCodePatch',0
    DB 'BoundOpCodeFix',0
    DB 'BoundOpCode',0
    DB 'BoundFix',0
    DB 'Bound',0
    DB  0, OptionNoBoundFix

    DB 'Beeps',0
    DB 'Beep',0
    DB  0, OptionBeep

    DB 'BadPrintersList',0
    DB 'BadPrinterList',0
    DB 'BadPrinters',0
    DB 'BadPrinter',0
    DB 'Bad',0
    DB  0, 'B'

    DB 'AutoEpsonSelect',0
    DB 'AutoEpsonInitialize',0
    DB 'AutoEpsonInit',0
    DB 'AutoEpson',0
    DB  0, OptionAutoEpson

    DB 'Aliases',0
    DB 'Alias',0
    DB  0, 'A'

    DB 0            ;End of list

  ;----------------------------------------------------------------------------
  ;Switches for Enable/Disable Switches
  ;----------------------------------------------------------------------------
  SwitchList2:
    DB 'Global',0
    DB  0, -1,

    DB 'AllPrinters',0
    DB 'All',0
    DB  0, -1,

    DB  0            ;End of list

  ;----------------------------------------------------------------------------
  ;Switches for Yes/No Options
  ;----------------------------------------------------------------------------
  SwitchListYesNo:
    DB 'Yes',0
    DB  0, 'Y'

    DB 'True',0
    DB 'T',0
    DB  0, 'Y'

    DB 'On',0
    DB  0, 'Y'

    DB 'Off',0
    DB  0, 'N'

    DB 'No',0
    DB  0, 'N'

    DB 'False',0
    DB 'F',0
    DB  0, 'N'

    DB 'Enabled',0
    DB 'Enable',0
    DB  0, 'Y'

    DB 'Disabled',0
    DB 'Disable',0
    DB  0, 'N'

    DB '1',0
    DB  0, 'Y'

    DB '0',0
    DB  0, 'N'

    DB  0 ;End of list

  ;----------------------------------------------------------------------------
  ;TABLE OF SUBROUTINE OFFSETS TO PROCESS THE VARIOUS COMMAND LINE OPTIONS
  ;----------------------------------------------------------------------------
  SwitchTbl:
    DB  '?'
       DW DoSwitchH          ;Help
    DB  'A'
       DW DoSwitchA          ;Command Line Aliases
    DB  'B'
       DW DoSwitchB          ;Bad Device Table
    DB  'C'
       DW DoSwitchC          ;Device/Config/Interface/HID/EndPoint Descriptors
    DB  'F'
       DW DoSwitchF          ;Send CR/FF between copied files
    DB  'I'
       DW DoSwitchI          ;Print ID Strings
    DB  'L'
       DW DoSwitchL          ;Use Low Memory
    DB  'M'
       DW DoSwitchM          ;ReMap (ReDirect) Printer Port
    DB  'R'
       DW DoSwitchR          ;Reset
    DB  'S'
       DW DoSwitchS          ;Status
    DB  'U'
       DW DoSwitchU          ;Uninstall

    DB  OptionAutoEpson
       DW DoSwitchAutoEpson  ;Automatically Initialize Epson Printers
    DB  OptionBeep
       DW DoSwitchBeep       ;Beep the Speaker for Bad Printers
    DB  OptionNoBoundFix
       DW DoSwitchNoBoundFix ;BOUND CPU OpCode Patch
    DB  OptionNoParallel
       DW DoSwitchNoParallel ;Overwrite Parallel Printers
    DB  OptionCopy
       DW DoSwitchCopy       ;Copy File to Printer
    DB  OptionErrLvl
       DW DoSwitchErrLvl     ;ErrorLevel Table
    DB OptionIOAddress
       DW DoSwitchIOAddress  ;Assign I/O Base Address
    DB OptionPortStatus
       DW DoSwitchPortStatus ;Show LPT Port Statuses
    DB  OptionSendEpson
       DW DoSwitchSendEpson  ;Send Init String manually to Epson Printer

    DB  0                    ;End of Table


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;PROGRAM CODE (NOT NEEDED IN TSR)
;Needed to initialize/update/show status of TSR, but not actually needed
;  in memory while TSR is running
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;------------------------------------------------------------------------------
;INITIALIZE/UPDATE THE PROGRAM
;Inputs:
;Outputs: Lots of Stuff
;Changes: Everything
;------------------------------------------------------------------------------
Main:
  CLD                         ;Go forward with string functions
  MOV  SP,LastProgByte        ;Reset Stack Pointer
  CALL ResizeMemory           ;Resize our Memory Allocation
  CALL CopyNameToMCB          ;Copy our Program name to the MCB
  CALL SetupPauseNoHdr        ;Set up the Pause
  MOV  DX,Copyright           ;Write the
  CALL WriteZPause            ;  Copyright message
  CALL SetupExtraMem          ;Set up the Extra Memory Segment (Quits if Err)
  CALL TestMemory             ;See if we're already installed in memory
                              ;QUIT if another version is installed
  CALL GetRealName            ;Get the Real Program Name
  CALL SetupExec              ;Setup Exec Parameters
  CALL GetOurPath             ;Get the Pointer to Our Path
  CALL GetEnvVars             ;Get the Environment Variable Pointers
  CALL ParseIt                ;Parse the command line
  CALL ReleaseExtraMem        ;Release the Extra Memory Segment
  CALL ReEnable               ;Re-Enable the Program, if required
  CALL HandleReset            ;If we did Reset(s), but aren't installed, quit
  CALL HandleEpson            ;If we sent Epsons, but aren't installed, quit
  CALL HandlePrints           ;If we printed, but aren't installed, quit
  CALL DoHelp                 ;Print Help and Quit, if necessary
  CALL DoAliases              ;Print Aliases and Quit, if necessary
  CALL DoErrLvls              ;Print ErrorLevel Table and Quit, if necessary
  CALL DoPortStatuses         ;Print Port Statuses and Quit, if necessary
  CALL DoDeviceIDs            ;Print Device ID Strings and Quit, if necessary
  CALL DoUninstall            ;Uninstall and quit, if necessary
  CALL DoBadDevices           ;Print Bad Devices and Quit, if necessary
  CALL DoDescriptors          ;Print USB Descriptors and Quit, if necessary
  CALL DoStatus               ;Print Status, if necessary
  CALL TestCompatibility      ;Test for compatibility (quit if not)
  TEST ProgFlags,InMemory     ;Are we already installed in memory?
  JZ  >M50                    ;If not, install as a TSR
M40:                          ;Already installed
  MOV  DX,UpdateMsg           ;If so, point at Update message
  XOR  AL,AL                  ;Errorlevel = 0
  JMP  Exit                   ;QUIT

M50:                          ;First-time installation (install as TSR)
  CALL DelEnvironment         ;Delete environment space (don't need it now)
  CALL MoveProgramToUMB       ;Move Program to Upper Memory, if possible
   ;All Subroutines after this MUST assume ES is TSR Segment, NOT CS!!
  MOV  DS,ES                  ;Point DS at TSR Data Area
M60:                          ;Ready to install TSR
  CALL SetRedirTbl            ;Point Redirect Table at us, if needed
  CALL AssignIOAddress        ;Assign a fake I/O Address to use
  CALL InitTables             ;Initialize all Tables
  CALL WriteNextPort          ;Write the next LPT Port that will be used
                              ;  (Do before we start looking for USB Printers)
  MOV  SI,IntNumTable         ;Change the Interrupts
  CALL ChangeInts             ;  to point at us
  CALL GetNULDvcHdr           ;Get the NUL Device Header (stores in TSR)
  CALL InitLPTxHeaders        ;Initialize LPTx Device Headers
  CALL AddLPTxHeaders         ;Add Device Headers to the Chain
  MOV  DS,CS                  ;Point DS at Local Data Area

  XOR  AL,AL                  ;ErrorLevel = 0
  MOV  BX,DS                  ;Point BX at the Local Segment
  MOV  CX,ES                  ;Point CX at the TSR Segment
  MOV  DX,InstallMsg1         ;Write the first part of the
  CALL WriteZPause            ;  Install Message
  TEST ProgFlags,MemoryMoved  ;Did we move the TSR Memory?
  JZ  >M90                    ;If not, use TSR Exit
  MOV  DX,InstallMsgAuto      ;Write
  CALL WriteZPause            ;  "automatically"
  MOV  DX,InstallMsgHole      ;Assume we installed in a Low Memory Hole
  CMP  BX,CX                  ;Did we install in a UMB or a Low Memory Hole?
  JA  >M80                    ;If a Low Memory Hole, leave the message as is
  MOV  DX,InstallMsgHigh      ;If a UMB, point at Installed High message
M80:                          ;[DX] = appropriate Memory Message
  CALL WriteZPause            ;Write the Memory Message
  MOV  DX,InstallMsgLast      ;Point at the last part of the Installed Message
  JMP  Exit                   ;Done

M90:                          ;Exit Program as a TSR
  MOV  DX,InstallMsgNorm      ;Assume we're in Low Memory
  CMP  CX,0A000h              ;Are we in Low Memory?
  JB  >M95                    ;If so, continue
  MOV  DX,InstallMsgHigh      ;If not, point at the High Memory message
M95:                          ;[DX] = appropriate Memory Message to write
  CALL WriteZPause            ;Write the Memory Message
  MOV  DX,InstallMsgLast      ;Write the last part of the
  CALL WriteZPause            ;  Install Message
  MOV  DX,(LastTSRByte SHR 4) ;DX = number of TSR paragraphs
  MOV  AH,31h                 ;Function 31h (TSR), ErrorLevel in AL (0)
  INT  21h                    ;Do it

;------------------------------------------------------------------------------
;MAKE SURE THE MCB (MEMORY CONTROL BLOCK) CONTAINS OUR PROGRAM NAME
;Inputs:  DS = Local Data Area
;         DS:RealName = ASCIIZ Real Name of our program
;         CLD Already Issued
;Outputs:
;Changes: Data in MCB
;NOTES:   This makes sure that the MCB (Memory Control Block) for our
;           program contains our program name.  DOS 4+ does this
;           automatically, but DOS versions 1-3 do not.  This code
;           does not verify whihc DOS version is in use, but simply
;           fills in the MCB no matter what.
;         Our program name is needed inthe MCB to make sure other programs
;           can identify that we are installed in memory.  This code should
;           be added to all TSR's, so that memory-mapping programs
;           (like MAPMEM or ISLOADED) can tell which TSR's are installed
;           in memory.  It should also be added to all programs that
;           EXEC other programs, so that the EXEC'd program can figure out
;           who called it.
;         Programs that are not TSR's and do not EXEC other programs
;           do not need this code.
;------------------------------------------------------------------------------
CopyNameToMCB:
  PUSH CX,DI,SI,ES              ;Save used registers
  MOV  CX,DS                    ;Point ES:[DI]
  DEC  CX                       ;  at the Owners Name
  MOV  ES,CX                    ;  in the MCB
  MOV  DI,(OFFSET MCBOwnerName) ;  of our program
  MOV  SI,RealName              ;Point DS:[SI] at our Program Name
  MOV  CX,4                     ;Copy 4 words (8 bytes)
  REP  MOVSW                    ;Copy our program name to the MCB
  POP  ES,SI,DI,CX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SETUP/RELEASE AN EXTRA 64K MEMORY SEGMENT FOR OUR PROGRAM
;Inputs:  DS = Local Data Area
;Outputs: ExtraMemSegment = Segment of New Segment
;         Quits Program with Error Message if Memory Problem
;Changes:
;------------------------------------------------------------------------------
SetupExtraMem:
  PUSH AX,BX                 ;Save used registers
  MOV  BX,4096               ;Number of Paragraphs in 64k Program
  MOV  AH,4Ah                ;Service 4Ah (Modify memory allocation)
  INT  21h                   ;Do it (uses ES = Segment, BX = # Paragraphs)
  JC  >X70                   ;If Error, Quit
  MOV  AH,48h                ;Service 48h (Allocate Memory Block)
  INT  21h                   ;Do it (uses BX = # paragraphs, rtns AX = Sgmt)
  JC  >X70                   ;If Error, Quit
  MOV  CS:ExtraMemSegment,AX ;If OK, store the segment
  JMP >X90                   ;Done
X70:                         ;Error
  MOV  DX,ExtraMemoryMsg     ;Point at Error Message
  MOV  AL,ErLvlMemory        ;ErrorLevel = Memory Problem
  JMP  Exit                  ;Quit
X90:                         ;Done
  POP  BX,AX                 ;Restore used registers
  RET

ReleaseExtraMem:
  PUSH AX,BX,ES ;Save used registers
  MOV  BX,OFFSET ExtraMemSegment ;Point [BX] at the Extra Memory Segment
  CMP  W [BX],0 ;Did we already Release it?
  JE  >X90      ;If so, quit
  MOV  ES,[BX]  ;If not, ES = Segment to Remove
  MOV  AH,49h   ;Service 49h (Free Memory)
  INT  21h      ;Do it
  MOV  W [BX],0 ;Mark it as released
X90:            ;Done
  POP  ES,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RE-ENABLE THE PROGRAM IF IT WAS DISABLED DUE TO A FAILED UNINSTALL
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         DS:ProgFlags.InMemory
;         DS:ProgFlags.Uninstall
;         ES:Int08Counter (= 0 if TSR is Disabled)
;Outputs: If Installed as TSR, currently Disabled, and not Uninstalling:
;           ES:Int08Counter = 5
;         If any other status,
;           does nothing
;Changes:
;------------------------------------------------------------------------------
ReEnable:
  PUSH DX                  ;Save used registers
  TEST ProgFlags,InMemory  ;Already installed as TSR?
  JZ  >B90                 ;If not, quit
  TEST ProgFlags,Uninstall ;User wants us to Uninstall?
  JNZ >B90                 ;If so, quit
  CMP  ES:Int08Counter,0   ;Disabled?
  JNE >B90                 ;If not, quit
  MOV  ES:Int08Counter,5   ;Re-enable
  MOV  DX,ReEnabledMsg     ;Notify the user
  CALL WriteZPause         ;  about what we did
B90:                       ;Done
  POP  DX                  ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED BECAUSE WE ARE A TSR.  NEEDED TO FIND EXISTING PROGRAM
;  IN MEMORY, UNINSTALL FROM MEMORY, ETC.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;CHECK MEMORY FOR COPY OF CODE TO SEE IF PROGRAM IS ALREADY INSTALLED
;Inputs:  ProgFlags.InMemory = No
;Outputs: ES = TSR program segment, whether a TSR yet or not
;         InMemory  = Yes if program is already installed as TSR
;                   = No if not
;         HandleNum = Multiplex interrupt handle number for Interrupt 2F
;Changes:
;------------------------------------------------------------------------------
TestMemory:
  PUSH AX,BX,CX,DX        ;Save all registers that might change
  PUSH DI,SI,BP,DS        ;  (includes everything except SS & SP)
  MOV  AH,0C0h            ;Function C0, (first available user handle)
M10:                      ;Loop to here for each handle number
  CLD                     ;Go forward with string functions
  XOR  BX,BX              ;Make sure
  XOR  CX,CX              ;  all registers
  XOR  DX,DX              ;  are zero
  MOV  HandleNum,AH       ;Store the handle number
  MOV  AL,MuxInstallChk   ;Install Check Function
  INT  2Fh                ;Do it
  CMP  AL,0FFh            ;Is this function installed?
  JNE >M40                ;If not, our code can't be installed yet
M12:                      ;Test Program Name
  MOV  AH,HandleNum       ;Get the handle number back again
  MOV  AL,MuxGetProgName  ;Get Program Name
  XOR  DI,DI              ;  Function
  INT  2Fh                ;Do it
  MOV  SI,ProgName        ;Point at our name
  MOV  CX,ProgNameLen     ;Get the string length
  REPE CMPSB              ;Compare the two strings
  JNE >M50                ;If not the same, it's not us
M14:                      ;Test Author
  MOV  AH,HandleNum       ;Get the handle number back again
  MOV  AL,MuxGetAuthor    ;Get Author Function
  INT  2Fh                ;Do it (returns ES:[DI])
  MOV  SI,Author          ;Point at our name
  MOV  CX,AuthorLen       ;Get the string length
  REPE CMPSB              ;Compare the two strings
  JNE >M50                ;If no match, it's somebody elses TSR, not ours
M16:                      ;Test Program Version
  MOV  AH,HandleNum       ;Get the handle number back again
  MOV  AL,MuxGetProgVer   ;Get Program Version Function
  INT  2Fh                ;Do it
  CMP  AX,ProgVer         ;Is it the same version as us?
  JE  >M80                ;If so, we're already installed in memory
M30:                      ;A different version is installed in memory
  MOV  AL,ErLvlVersion    ;If not, ErrorLevel = Wrong version
  MOV  DX,WrongVerMsg     ;Point to error message
  JMP  Exit               ;Quit
M40:                      ;No function installed at this handle at all
  CMP  FirstHandle,0      ;Have we already located an available handle?
  JNE >M50                ;If so, just keep searching
  MOV  AH,HandleNum       ;If not, store this one
  MOV  FirstHandle,AH     ;  as the first available
M50:                      ;Increment the Handle number and try again
  MOV  DS,CS              ;Make sure another
  MOV  ES,CS              ;  Int 2F installation check routine
  MOV  AH,HandleNum       ;  hasn't changed things
  ADD  AH,1               ;Look at the next handle number
  JNC  M10                ;If still less than FFh, keep looking
  MOV  AH,FirstHandle     ;If we've searched them all, we're not in memory
  MOV  HandleNum,AH       ;  so go ahead and store our handle number
  JMP >M90                ;And we're done
M80:                      ;We've already been installed (ES contains segment)
  OR   ProgFlags,InMemory ;Mark as already installed
M90:                      ;We're done
  POP  DS,BP,SI,DI        ;Restore
  POP  DX,CX,BX,AX        ;  all registers
  RET

;------------------------------------------------------------------------------
;PRINT MESSAGE IN DX AND QUIT WITH ERRORLEVEL IN AL
;Inputs:  AL = Errorlevel to exit program with
;         CS:[DX] = Message to Print (to ERR)
;Outputs:
;Changes: Quits program
;------------------------------------------------------------------------------
Exit:
  MOV  DS,CS           ;Point DS at Segment where Error Message is Located
  CALL ReleaseExtraMem ;Release the Extra memory Segment
  OR   AL,AL           ;Was there an Error?
  JZ  >X80             ;If not, jump to handle a normal termination
  CALL BeepErr         ;If error, Beep Once
  CALL WriteZErr       ;Write message to ERR
  CALL WriteCrLfErr    ;Move down
  JMP >X90             ;Jump to quit
X80:                   ;No Error - Write to CON
  CALL WriteZPause     ;Write the message to CON
  CALL WriteCrLfPause  ;Write a New Line
X90:                   ;We're done!!
  MOV  AH,4Ch          ;Service 4Ch (terminate program)
  INT  21h             ;Do it

;------------------------------------------------------------------------------
;FINISH UP A "CAN'T PERFORM REQUEST BECAUSE WE'RE NOT INSTALLED YET" ERROR
;Inputs:  DS:[DX] = First message to Print
;Outputs: Writes Message pointed at by DS:[DX]
;         Sets Exit ErrorLevel (ErLvlUninst)
;         Writes Second Half of Error Message
;Changes: Terminates Program
;------------------------------------------------------------------------------
FinishDataErr:
  CALL WriteZErr      ;Write first part of Error Message
  MOV  AL,ErLvluninst ;ErrorLevel = not installed yet
  MOV  DX,DataErrMsg  ;Point at second part of Error Message
  JUMP Exit           ;Terminate program

;------------------------------------------------------------------------------
;UNINSTALL RESIDENT PROGRAM
;Inputs:  ES = TSR Code Segment
;Outputs:
;Changes: Attempts to Uninstall Program from memory
;         If it can't be Uninstalled, it is Disabled
;------------------------------------------------------------------------------
DoUninstall:
  TEST ProgFlags,Uninstall ;Are we supposed to Uninstall?
  JZ  >U90                 ;If not, just quit
  TEST ProgFlags,InMemory  ;If so, are we even installed yet?
  JZ  >U60                 ;If not, there's an error
  MOV  ES:Int08Counter,0   ;Disable the TSR
  CALL UnconfigureDevices  ;Disable all of the Devices that are configured
  MOV  SI,IntNumTable      ;Point at the Interrupt Address Table
  CALL CompareInts         ;Can we Uninstall the Interrupt Vectors?
  JC  >U70                 ;If not, we can't Uninstall
  MOV  AH,49h              ;If not, service 49h (Release Memory, uses ES)
  INT  21h                 ;Do it
  JC  >U70                 ;If unable to do it, quit with error
U20:                       ;OK to Restore Interrupts
  CALL UnRegDvc0Owner      ;Unregister as a Device 0 Owner
  CALL RelinquishRedirTbl  ;Relinquish Ownership of Int 17h Extended Funcs
  CALL RemoveLPTxHeaders   ;Remove our LPTx Device Drivers
  MOV  SI,IntNumTable      ;Restore Interrupts
  CALL RestoreInts         ;  back to normal
  MOV  AX,50               ;Wait a little while
  CALL DelayMSAX           ;  for things to take effect
  MOV  CX,((LastTSRByte-StackSize)/2) ;Number of Words in TSR
  XOR  DI,DI               ;Start of TSR Data Area
  XOR  AX,AX               ;Fill with Zeroes
  REP  STOSW               ;Do it
  MOV  DX,UninstallMsg     ;Point to successful uninstall message
  XOR  AL,AL               ;Errorlevel = 0
  JUMP Exit                ;QUIT
U60:                       ;Not in memory yet - can't Uninstall
  MOV  DX,UninstallErrMsg  ;Point at error message
  MOV  AL,ErLvlUninst      ;Errorlevel = Not Installed Yet
  JUMP Exit                ;QUIT
U70:                       ;Another TSR is in the way - can't Uninstall
  MOV  DX,NoUninstallMsg   ;Point at error message
  MOV  AL,ErLvlMemory      ;Errorlevel = Memory Problem
  JUMP Exit                ;QUIT
U90:                       ;No need to Uninstall
  RET

;------------------------------------------------------------------------------
;CLOSE ALL OPEN HANDLES & UNCONFIGURE DEVICES THAT WE'RE CONTROLLING
;Inputs:  ES = TSR Data Segment
;Outputs:
;Changes: Closes Open Handles, Unconfigures Devices
;------------------------------------------------------------------------------
UnconfigureDevices:
  PUSH CX,DI,SI,DS              ;Save used registers
  MOV  DS,ES                    ;Point DS at TSR Data
  MOV  SI,Int14Request          ;Point at Request Structure
  MOV  DI,DeviceInfoTable       ;Point at Table
  MOV  CX,MaxDevices            ;Number of Table Entries
G10:                            ;Loop to here for each Entry
  TEST [DI].DIFlags,DIFlagInUse ;Valid Entry?
  JZ  >G30                      ;If not, skip it
  CALL RlsDvcDoResetDI          ;Release & Reset the Device
G30:                            ;Done with this entry
  ADD  DI,DeviceInfoStrucSize   ;Point at next entry
  LOOP G10                      ;Keep going until we're done
  POP  DS,SI,DI,CX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;UNREGISTER AS A DEVICE 0 (NEW DEVICE) OWNER
;Inputs:  DS = Local Data Area
;         ES = TSR Data Segment
;Outputs:
;Changes: Unregisters as Device 0 Owner
;NOTES: We do this as a separate item from UnconfigureDevices, and perform it
;         after we've verified that we can actually Uninstall the program.
;       If we are unable to Uninstall and simply Disable ourselves, we don't
;         want to go through the bother of re-Registering as a Device 0 Owner
;         again.  We leave our Device 0 Registration in effect, but effectively
;         just ignore it until we re-Enable ourselves.
;------------------------------------------------------------------------------
UnRegDvc0Owner:
  PUSH AX,SI,DS                      ;Save used registers
  MOV  DS,ES                         ;Point DS at TSR Data
  CMP  Reg0Handle,-1                 ;Did we ever register?
  JE  >V90                           ;If not, we're done
  MOV  SI,Int14Request               ;Point at Request Structure
  MOV  W [SI].I14RCallBackAddr[0],-1 ;Set CallBackAddr to nothing
  MOV  [SI].I14RRequestType,I14RRTUnRegIntfOwner ;Unregister as owner
  MOV  [SI].I14RHostIndex,-1         ;All Hosts
  MOV  [SI].I14RDeviceAddress,0      ;Address 0 (New Connects)
  MOV  AX,Reg0Handle                 ;Handle Number
  MOV  [SI].I14RRequestHandle,AX     ;  returned by Host
  CALL DoInt14CallSaveAllSI          ;Do it
V90:                                 ;Done
  POP  DS,SI,AX                      ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO COPY DATA FROM THE REDIRECTED INPUT FILE, "COMPRESSING" IT AND
;  STORING IT IN OUR LOCAL MEMORY BUFFER.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;READ THE DATA FROM STDIN (REDIRECTED INPUT) AND STORE IT IN OUR BUFFER
;Inputs:  ExtraMemSegment
;Outputs:
;Changes: Fills up StdInBuffer
;         As data is read, multiple spaces are converted to single spaces,
;           and EOL's (CR/LF) are also changed to spaces
;         Last character of buffer is a 0
;         Quits with error message if StdIn is too big for buffer
;------------------------------------------------------------------------------
FillStdInBuffer:
  PUSH AX,DI,ES             ;Save used registers
  CALL FlushKbdBuff         ;Don't let keyboard buffer mess with File Input
  MOV  ES,ExtraMemSegment   ;Point ES:DI at
  XOR  DI,DI                ;  our Buffer
  MOV  AL,' '               ;Start the buffer
  STOSB                     ;  with a space
B10:                        ;Loop to here for each character
  CALL ReadStdInChar        ;Get the next character
  JZ  >B80                  ;If end of input, we're done
B15:                        ;AL contains the next character
  CMP  AL,EOF               ;Is it End-of-File?
  JE  >B80                  ;If so, it's the end of input
B20:                        ;Test for Comment
  CMP  AL,';'               ;Is it the start of a comment?
  JNE >B30                  ;If not, try the next possibility
  CALL SkipOverStdInComment ;If so, skip over the comment
  JC  >B80                  ;If EOF, we're done
  JMP  B10                  ;If not EOF, continue
B30:                        ;Test for String
  CMP  AL,'"'               ;Double Quote?
  JE  >B35                  ;If so, handle a string
  CMP  AL,"'"               ;Single Quote?
  JE  >B35                  ;If so, handle a string
  CMP  AL,"`"               ;Left Quote?
  JNE >B40                  ;If not, try the next possibility
B35:                        ;It's a String
  CALL GetStdInString       ;Get the rest of the String
  JC  >B80                  ;If error, just quit (Error handled later)
  JMP  B10                  ;If OK, continue
B40:                        ;Test for EOL
  CMP  AL,CR                ;Carriage Return?
  JE  >B45                  ;If so, handle it
  CMP  AL,LF                ;Carriage Return?
  JNE >B50                  ;If not, it's a regular character
B45:                        ;End of Line
  CALL AddSpace2StdInBuff   ;Add a Space to the Buffer, if needed
  JMP  B10                  ;Continue
B50:                        ;Is a regular character
  CALL AddChar2StdInBuff    ;Add the character to the buffer
  JMP  B10                  ;Continue
B80:                        ;Done, no error
  XOR  AL,AL                ;Mark the end
  STOSB                     ;  of the buffer
B90:                        ;Done
  POP  ES,DI,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER A COMMENT IN THE REDIRECTED INPUT FILE
;Inputs:  DS = Local Data Area
;         ES:[DI] = StdInBuffer
;         AL = Semicolon (the start of the Comment)
;Outputs: CF = Clear if OK (not EOF)
;            = Set if we've reached EOF
;         Quits Program with error message if Buffer gets full
;Changes:
;NOTES: This looks for either an EOF or LF character to indicate the end of
;         the comment.  If we see a CR, we simply skip it and wait for the LF
;         that should immediately follow the CR.
;       If a line ends in a CR or CR/LF combination, this will not work
;         this will not work correctly.  However, no file we work with
;         should ever be in that format.
;------------------------------------------------------------------------------
SkipOverStdInComment:
  PUSH AX                 ;Save used registers
C10:                      ;Loop to here for each character on the line
  CALL ReadStdInChar      ;Get the next character (AL)
  JZ  >C70                ;If no characters available, EOF
  CMP  AL,EOF             ;End-of-File character?
  JE  >C70                ;If so, we're done
  CMP  AL,CR              ;Carriage Return?
  JE  >C20                ;If so, End of Comment
  CMP  AL,LF              ;Line Feed?
  JNE  C10                ;If not, keep looking
C20:                      ;End of Line
  CALL AddSpace2StdInBuff ;Add a Space to the Buffer if we need it
  JMP >C80                ;Done
C70:                      ;EOF
  STC                     ;Set EOF Flag
  JMP >C90                ;Done
C80:                      ;Not EOF
  CLC                     ;Set not EOF Flag
C90:                      ;Done
  POP  AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY A STRING FROM STDIN TO THE STDINBUFFER
;Inputs:  DS = Local Data Area
;         ES:[DI] = StdInBuffer
;         AL = Quote Characer (the start of the String)
;Outputs: CF = Clear if OK (not EOF)
;            = Set if we've reached EOF (Bad String)
;         Quits Program with error message if Buffer gets full
;Changes:
;NOTES: This looks for the matching Quote Character to indicate the end of
;         the String.
;       If we find an EOF, CR, or LF in the string, we return a CF to indicate
;         a bad String.
;------------------------------------------------------------------------------
GetStdInString:
  PUSH AX                 ;Save used registers
  MOV  AH,AL              ;Save quote character
  CALL AddSChar2StdInBuff ;Add the Quote Character to the Buffer
S10:                      ;Loop to here for each character of string
  CALL ReadStdInChar      ;Get the next character (AL)
  JZ  >S70                ;If no characters available, Error
  CMP  AL,EOF             ;End-of-File character?
  JE  >S70                ;If so, Error
  CMP  AL,CR              ;Carriage Return?
  JE  >S70                ;If so, Error
  CMP  AL,LF              ;Line Feed?
  JE  >S70                ;If so, Error
  CALL AddSChar2StdInBuff ;Add the Character to the Buffer
  CMP  AL,AH              ;Is it the end-of-string character?
  JNE  S10                ;If not, keep looking
  JMP >S80                ;Done
S70:                      ;EOF (Bad String)
  STC                     ;Set EOF Flag
  JMP >S90                ;Done
S80:                      ;String is OK
  CLC                     ;Set OK flag
S90:                      ;Done
  POP  AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ A CHARACTER FROM STDIN (REDIRECTED INPUT)
;Inputs:
;Outputs: AL = Next character from StdIn
;              ZF Clear
;            = 0 if no character to get
;              ZF Set
;Changes:
;------------------------------------------------------------------------------
ReadStdInChar:
  PUSH DX      ;Save used registers
  MOV  DH,AH   ;Save original AH
  MOV  AH,06h  ;Function 06h
  MOV  DL,0FFh ;  (Direct Console Input)
  INT  21h     ;Do it (returns AL and ZF)
  MOV  AH,DH   ;Restore original AH
  POP  DX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADD A CHARACTER OR STRING CHARACTER TO THE END OF THE STDIN BUFFER
;Inputs:  DS = Local Data Area
;         ES:[DI] = StdInBuffer
;         AL = Character to add to end of Buffer
;         CLD already issued
;Outputs: Returns to calling program if Character was added OK
;         Quits Program with Error if Buffer is already full
;Changes: DI (maybe)
;------------------------------------------------------------------------------
AddSpace2StdInBuff:
  PUSH AX                ;Save used registers
  MOV  AL,' '            ;Add a Space to the Buffer
  CALL AddChar2StdInBuff ;  if we need it
  POP  AX                ;Restore used registers
  RET

AddChar2StdInBuff:
  CMP  AL,' '            ;Are we adding a space?
  JNE >B00               ;If not, just add it
  CMP  B ES:[DI-1],AL    ;If so, is there already a space?
  JNE >B00               ;If not, just add it
  JMP >B90               ;If so, we're done
AddSChar2StdInBuff:
B00:                     ;Add the character to the Buffer
  CMP  DI,65534          ;Is the Buffer full?
  JAE >B70               ;If so, Error
  STOSB                  ;If not, Store the Character
  JMP >B90               ;Done
B70:                     ;Buffer already Full
  MOV  DX,StdInTooBigMsg ;Point at error message
  MOV  AL,ErLvlStdIn     ;ErrorLevel = problem with StdIn
  JMP  Exit              ;Quit
B90:                     ;Done
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO INITIALIZE VARIOUS TABLES AND STRUCTURES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;INITIALIZE TABLES AND STRUCTURES TO THEIR APPROPRIATE VALUES
;Inputs:  ES = TSR Data Area
;         DS = Area where Int14Requests are stored that we want to configure
;Outputs:
;Changes: Various things
;------------------------------------------------------------------------------
InitTables:
  PUSH CX,DI                  ;Save used registers
  MOV  DI,Int14Request        ;Point at first Int 14 Request
  CALL InitInt14Req           ;Fill it up
  MOV  DI,Int14Request2       ;Point at second Int 14 Request
  CALL InitInt14Req           ;Fill it up
  MOV  DI,DeviceInfoTable+(OFFSET DIInt14Request) ;Point at Local Int 14 Req
  MOV  CX,MaxDevices          ;CX = Number of Local Int 14 Requests
T30:                          ;Loop to here for each Local Int 14 Request
  CALL InitInt14Req           ;Fill it up
  ADD  DI,DeviceInfoStrucSize ;Point at the next one
  LOOP T30                    ;Keep going until we're done
  POP  DI,CX                  ;Restore used registers
  RET

InitInt14Req:
  MOV  [DI].I14RDvcClass,DvcClassNone            ;Device Class
  MOV  [DI].I14RDvcSubClass,DvcSubClassNone      ;Device SubClass
  MOV  [DI].I14RDvcProtocol,DvcProtocolNone      ;Device Protocol
  MOV  [DI].I14RIntfClass,IntfClassPrinter       ;Interface Class
  MOV  [DI].I14RIntfSubClass,IntfSubClassPrinter ;Interface SubClass
  MOV  [DI].I14RIntfProtocol,-1                  ;Interface Protocol
  MOV  [DI].I14RVendorID,-1                      ;Vendor ID = Don't Care
  MOV  [DI].I14RProductID,-1                     ;Product ID = Don't Care
  MOV  W [DI].I14RDataAddress[2],ES              ;Set Segment
  MOV  W [DI].I14RCallBackAddr[2],ES             ;  Registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO HANDLE PRINTER OPTIONS IF WE DON'T INSTALL AS TSR
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;QUIT PROGRAM IF WE PERFORMED A RESET, BUT AREN'T INSTALLED IN MEMORY YET
;Inputs:  ES = TSR Code Segment
;Outputs:
;Changes: Quits Program if necessary
;------------------------------------------------------------------------------
HandleReset:
  TEST StatusFlags2,DidReset ;Did we do a Reset while Parsing?
  JZ  >R90                   ;If not, quit
  TEST ProgFlags,InMemory    ;If so, are we already in memory?
  JNZ >R90                   ;If so, quit
  MOV  DX,ResetsDoneMsg      ;Point at Reset Message
  XOR  AL,AL                 ;ErrorLevel 0
  JMP  Exit                  ;QUIT
R90:                         ;Done
  RET

;------------------------------------------------------------------------------
;QUIT PROGRAM IF WE PERFORMED AN EPSON INIT, BUT AREN'T INSTALLED IN MEMORY YET
;Inputs:  ES = TSR Code Segment
;Outputs:
;Changes: Quits Program if necessary
;------------------------------------------------------------------------------
HandleEpson:
  TEST StatusFlags2,DidEpson ;Did we do an Epson Init while Parsing?
  JZ  >E90                   ;If not, quit
  TEST ProgFlags,InMemory    ;If so, are we already in memory?
  JNZ >E90                   ;If so, quit
  MOV  DX,EpsonsDoneMsg      ;Point at Epson Message
  XOR  AL,AL                 ;ErrorLevel 0
  JMP  Exit                  ;QUIT
E90:                         ;Done
  RET

;------------------------------------------------------------------------------
;QUIT PROGRAM IF WE PRINTED FILES, BUT AREN'T INSTALLED IN MEMORY YET
;Inputs:  ES = TSR Code Segment
;Outputs:
;Changes: Quits Program if necessary
;------------------------------------------------------------------------------
HandlePrints:
  TEST StatusFlags2,DidPrints ;Did we do any Printing ("Copying")?
  JZ  >P90                    ;If not, quit
  TEST ProgFlags,InMemory     ;If so, are we already in memory?
  JNZ >P90                    ;If so, quit
  MOV  DX,NoMsg               ;Point at None Message
  XOR  AL,AL                  ;ErrorLevel 0
  JMP  Exit                   ;QUIT
P90:                          ;Done
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO SAVE/INITIALIZE/RESTORE INTERRUPT VECTORS
;THIS CODE IS NEEDED IN EVERY PROGRAM THAT INTERCEPTS INTERRUPT VECTORS.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;INITIALIZE ALL APPROPRIATE INTERRUPT VECTORS TO OUR TSR CODE
;Inputs:  ES = Data area to store Interrupt Vectors in (Presumably a UMB)
;         CS:[SI] = Interrupt Number Table to use
;         CLD Already Issued!
;Outputs:
;Changes: Various Int vectors
;------------------------------------------------------------------------------
ChangeInts:
  PUSH AX,DI,SI,DS  ;Save used registers
  MOV  DS,ES        ;Point DS at TSR Data Area
C10:                ;Loop to here for each table entry
  MOV  AL,CS:[SI]   ;Get Interrupt Number
  OR   AL,AL        ;Is it the end of the table?
  JZ  >C90          ;If so, we're done
  MOV  DI,CS:[SI+1] ;If valid, get our Code Header Offset
  CALL ChangeInt    ;Point the Interrupt at our code
  ADD  SI,3         ;Point at the next table entry
  JMP  C10          ;Keep going until we're done
C90:                ;Done with the Interrupt Table
  POP  DS,SI,DI,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHANGE INTERRUPT VECTOR TO THIS PROGRAMS INTERRUPT ROUTINE, AND SAVE THE OLD
;Inputs:  DS:[DI] = Pointer to our new interrupt header
;         AL = Interrupt number to change
;Outputs:
;Changes: Interrupt vector
;------------------------------------------------------------------------------
ChangeInt:
  PUSH AX,BX,DX,ES            ;Save used registers
  CALL InitIntHdr             ;Initialize our Interrupt Header
  MOV  AH,35h                 ;Service 35h (Get interrupt vector)
  INT  21h                    ;Do it (returns ES:BX)
  MOV  W [DI].OldVector,BX    ;Save it
  MOV  W [DI].OldVector[2],ES ;  in [DI]
  LEA  DX,[DI].CodeJmp        ;Point DS:DX at our code address
  MOV  AH,25h                 ;Service 25h (Set interrupt vector)
  INT  21h                    ;Do it
  POP  ES,DX,BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE THE DATA IN A REMOVABLE INTERRUPT VECTOR HEADER
;Inputs:  DS:[DI] = Pointer to Our Interrupt Header Structure
;Outputs:
;Changes: The Interrupt Header Data
;------------------------------------------------------------------------------
InitIntHdr:
  MOV  [DI].HdwreRst,0CBh   ;Hardware Reset Code = CBh = RETF
  MOV  [DI].CodeJmp,10EBh   ;Jump to Real Code = EBh 10h = JMP ENDS
  MOV  [DI].Signature,424Bh ;Signature for Removable Vector Header = 424Bh
  MOV  [DI].EOIFlag,0       ;We will not be issuing EOI's
  MOV  [DI].HdwreJmp,0F4EBh ;Jump to Hardware Reset = EBh F4h = JMP HdwreRst
  RET

;------------------------------------------------------------------------------
;CHECK THE INTERRUPT VECTORS TO SEE IF THEY'VE BEEN REHOOKED BY ANOTHER PROGRAM
;Inputs:  ES = TSR Data area
;         CLD Already Issued!
;Outputs: CF = Clear if Vectors are OK (We can safely Uninstall our Program)
;            = Set if at least one Vector is unchangeably rehooked
;Changes:
;------------------------------------------------------------------------------
CompareInts:
  PUSH AX,DX,SI          ;Save used registers
  MOV  SI,IntNumTable    ;Point at our interrupt number table
C10:                     ;Loop to here for each table entry
  LODSB                  ;Get the Interrupt Number
  OR   AL,AL             ;Is it the end of the table?
  JZ  >C80               ;If so, we're done
  MOV  DX,[SI]           ;If valid, get our Code Header Offset
  ADD  DX,OFFSET CodeJmp ;Add the Offset to the actual Vector Address
  CALL CompareInt        ;Has it been unchangeably rehooked?
  JC  >C70               ;If so, we can't Uninstall our Program
  INC  SI,2              ;Point at the next table entry
  JMP  C10               ;Keep going until we're done
C70:                     ;At lest one Interupt has been rehooked
  STC                    ;Set the Rehooked flag
  JMP >C90               ;We're done
C80:                     ;Vectors can be Uninstalled
  CLC                    ;Set the OK flag
C90:                     ;We're done
  POP  SI,DX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COMPARE OUR INTERRUPT ADDRESS TO MEMORY SEE IF IT'S BEEN REHOOKED
;Inputs:  ES:[DX] = Vector address to test (our TSR's address)
;         AL = Interrupt number to test
;Outputs: CF = Clear if OK to remove
;         CF = Set if rehooked and can't be removed
;Changes:
;------------------------------------------------------------------------------
CompareInt:
  PUSH BX,CX,ES ;Save used registers
  MOV  CX,ES    ;Point CX:DX at our vector
  CALL FindInt  ;Look for it (returns ES:BX and CF
  POP  ES,CX,BX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESTORE ALL INTERRUPT VECTORS BACK TO THEIR ORIGINAL STATE
;Inputs:  ES = Data Area where original Vector information is stored
;         DS:[SI] = Interrupt Nubmer Table to use
;         CLD already issued!
;Outputs:
;Changes: Various Int vectors
;------------------------------------------------------------------------------
RestoreInts:
  PUSH AX,DI,SI   ;Save used registers
R10:              ;Loop to here for each table entry
  LODSB           ;Get the Interrupt Number
  OR   AL,AL      ;Is it the end of the table?
  JZ  >R90        ;If so, we're done
  MOV  DI,[SI]    ;If valid, get our Code Header Offset
  CALL RestoreInt ;Restore Interrupt Vector back to original
  INC  SI,2       ;Point at the next table entry
  JMP  R10        ;Keep going until we're done
R90:              ;We're done
  POP  SI,DI,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESTORE INTERRUPT VECTOR TO ITS ORIGINAL PLACE
;Inputs:  ES:[DI] = Pointer to our Interrupt Header
;         AL = Interrupt number to restore
;Outputs:
;Changes: Interrupt vector back to where it belongs
;Notes:   If we got to here, nothing should have intercepted
;           an interrupt that we haven't checked for.
;         We shouldn't have to worry about running into a road-block!
;------------------------------------------------------------------------------
RestoreInt:
  PUSHF                          ;Save flags
  PUSH BX,CX,DX,SI,BP,ES         ;Save used registers
  MOV  SI,W ES:[DI].OldVector    ;Put the address we'll need to store
  MOV  BP,W ES:[DI].OldVector[2] ;  in BP:SI
  MOV  CX,ES                     ;Point CX:DX
  LEA  DX,[DI].CodeJmp           ;  at our address
  CALL FindInt                   ;Search for it (returns ES:BX)
  CLI                            ;Disable interrupts
  MOV  ES:[BX],SI                ;Store the
  MOV  ES:[BX+2],BP              ;  address
  POP  ES,BP,SI,DX,CX,BX         ;Restore used registers
  POPF                           ;Restore flags
  RET

;------------------------------------------------------------------------------
;SEARCH FOR AN INTERRUPT VECTOR ADDRESS (TO SEE IF OUR CODE CAN BE REMOVED)
;Inputs:  CX:DX = Interrupt Vector address to find (address of our TSR code)
;         AL = Interrupt number to find
;Outputs: CF = Clear if OK to remove
;           ES:BX = address where it is stored
;         CF = Set if rehooked and can't be removed
;           ES:BX = unknown state
;Changes:
;------------------------------------------------------------------------------
FindInt:
  PUSH AX                                ;Save used registers
  XOR  AH,AH                             ;Point ES:BX
  ADD  AX,AX                             ;  at the
  ADD  AX,AX                             ;  main
  MOV  BX,AX                             ;  interupt
  XOR  AX,AX                             ;  vector
  MOV  ES,AX                             ;  table
  CMP  ES:[BX],DX                        ;Is the offset the same as ours?
  JNE >F20                               ;If not, it can't be ours
  CMP  ES:[BX+2],CX                      ;Is the segment the same as ours?
  JE  >F80                               ;If so, it's ours - we're done
F20:                                     ;The main interrupt vector has changed
  LES  BX,ES:[BX]                        ;Get the current vector address
F30:                                     ;Loop for each removable interrupt
  CALL TestIntHdr                        ;Is this a removable interrupt?
  JC  >F70                               ;If not, we can't be removed
  CMP  W ES:[BX-IntOfst].OldVector,DX    ;If so, is the old offset ours?
  JNE >F50                               ;If not, keep looking
  CMP  W ES:[BX-IntOfst].OldVector[2],CX ;If so, is old segment ours?
  JNE >F50                               ;If not, keep looking
  ADD  BX,(OFFSET OldVector) - IntOfst   ;If so, ES:BX = old vector pointer
  JMP >F80                               ;And we're done
F50:                                     ;Removable, but doesn't point at us
  LES  BX,ES:[BX-IntOfst].OldVector      ;Get its old vector address
  JMP  F30                               ;And keep looking for our vector
F70:                                     ;Been rehooked and can't be removed
  STC                                    ;Set the "rehooked" flag
  JMP >F90                               ;We're done
F80:                                     ;It's not rehooked, or it's removable
  CLC                                    ;Set the "OK to remove" flag
F90:                                     ;We're done
  POP  AX                                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN INTERRUPT POINTER TO SEE IF IT'S REMOVABLE
;Inputs:  ES:BX = Interrupt Vector to test
;Outputs: CF = Set if it's not a removable vector
;            = Clear if it is removable
;Changes:
;Notes:   The references to [BX-IntOfst] instead of [BX] are because of
;           our "unusual" Interrupt Header Structure design
;         We have included the (unneeded) Hardware Reset Routine code
;           (a simple RETF) in our Header Structure for efficiency
;------------------------------------------------------------------------------
TestIntHdr:
  PUSH AX,BX,DS                      ;Save used registers
  MOV  DS,ES                         ;Point DS at the interrupt segment
  CMP  B [BX-IntOfst].CodeJmp,0EBh   ;Is the first instruction a Short JMP?
  JNE >H70                           ;If not, it's not removable
  CMP  [BX-IntOfst].Signature,0424Bh ;Is there a Removeable Interrupt Signature?
  JNE >H70                           ;If not, it's not removable
  MOV  AL,[BX-IntOfst].EOIFlag       ;Get the EOI flag
  OR   AL,AL                         ;Is it zero?
  JZ  >H10                           ;If so, continue checking
  CMP  AL,80h                        ;Is it 80h?
  JNE >H70                           ;If not, it's not removable
H10:                                 ;EOI flag is OK
  CMP  B [BX-IntOfst].HdwreJmp,0EBh  ;Is the HdwreJmp instruction a Short JMP?
  JE  >H80                           ;If so, it's removable!
H70:                                 ;Vector is not removable
  STC                                ;Set the "not removable" flag
  JMP >H90                           ;We're done
H80:                                 ;Vector is removable
  CLC                                ;Set the "removable" flag
H90:                                 ;We're done
  POP  DS,BX,AX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF AN INTERRUPT VECTOR HAS A VALID ADDRESS (other than 0)
;Inputs:  AL = Interrupt number to test
;Outputs: ZF = Set if invalid address (Segment = 0)
;            = Clear if valid address (Segment <> 0)
;Changes:
;------------------------------------------------------------------------------
TestInt:
  PUSH BX,DS      ;Save used registers
  XOR  BX,BX      ;Point DS at the
  MOV  DS,BX      ;  Interrupt Table
  MOV  BL,AL      ;Point BX
  SHL  BX,1       ;  at the Interrupt
  SHL  BX,1       ;  we're looking for
  CMP  W [BX+2],0 ;Is the Segment valid (set the return flag)?
  POP  DS,BX      ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED TO MANAGE (SETUP AND TEAR DOWN) DEVICE HEADERS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;FILL IN ALL LPTx DEVICE HEADER STRUCTURES WITH DATA
;Inputs:  DS = ES = TSR Data Area
;Outputs: Fills in all Headers
;Changes:
;------------------------------------------------------------------------------
InitLPTxHeaders:
  PUSH BX,CX           ;Save used registers
  MOV  BX,LPT1Strategy ;Point [BX] at first Strategy Code Offset
  XOR  CL,CL           ;Start with Index 0 (LPT1)
I10:                   ;Loop to here for each Structure
  CALL InitLPTxHeader  ;Initialize the Header
  ADD  BX,(LPT2Strategy-LPT1Strategy) ;Point at next Strategy Code Offset
  INC  CL              ;Increment the Index
  CMP  CL,9            ;Done all of the Structures yet?
  JBE  I10             ;If not, keep going
  POP  CX,BX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FILL IN AN INDIVIDUAL LPTx DEVICE HEADER STRUCTURE WITH DATA
;Inputs:   DS = ES = TSR Data Area
;          CL  = LPT Index to use (0-8 = LPT1-9, 9 = PRN)
;          BX  = Strategy Code Offset to use
;Outputs: Fills in Header
;Changes
;NOTES: This assumes that the offsets between the Strategy and Interrupt
;         codes routines are always the same.  That means that the
;         "headers" of the code snippets must be the same (or must at
;         least use the same number of OpCode bytes).
;       In here, we set the Attributes as we need them to be for our
;         USB-attached printers.  During installation of our Device Headers
;         into the Device Chain, we copy the attributes of the Device
;         Headers we replaced (typically LPT1-LPT3).
;       In the TSR, we only handle the new functions (TxBlock, RxBlock,
;         and GetDeviceID) that a normal LPTx Driver would not handle,
;         and pass all of the old functions on to the original Device Driver.
;       That way we do not need to worry about processing special IOCTL
;         functions that the original driver may know about but we don't.
;------------------------------------------------------------------------------
InitLPTxHeader:
  PUSH BX,CX,DI                        ;Save used registers
  CALL LHIndex2Offset                  ;Point [DI] at the appropriate Structure
  MOV  [DI].LHLPTIndex,CL              ;Store the Index in the Structure
  MOV  W [DI].DHNextHeader[0],-1       ;Initialize Next
  MOV  W [DI].DHNextHeader[2],-1       ;  Driver Pointer
  MOV  [DI].DHAttribs,DHAttrsToUse     ;Store Attributes
  MOV  [DI].DHStrategyOffset,BX        ;Store Strategy Code Offset
  ADD  BX,(LPT1Interrupt-LPT1Strategy) ;Store Interrupt
  MOV  [DI].DHInterruptOffset,BX       ;  Code Offset
  MOV  W [DI].DHCDvcName[4],'  '       ;Store the last four characters (spaces)
  MOV  W [DI].DHCDvcName[6],'  '       ;  of the Device Name
  CMP  CL,9                            ;Is it PRN (as opposed to LPTx)
  JE  >I30                             ;If so, handle it
I20:                                   ;LPTx
  MOV  W [DI].DHCDvcName[0],'PL'       ;Store the first three (LPT)
  MOV  B [DI].DHCDvcName[2],'T'        ;  characters of the Device Name
  ADD  CL,'1'                          ;Convert Index to ASCII LPT Number
  MOV  [DI].DHCDvcName[3],CL           ;Store it in the Device Name
  JMP >I90                             ;Done
I30:                                   ;PRN
  MOV  W [DI].DHCDvcName[0],'RP'       ;Store the first four (PRN )
  MOV  W [DI].DHCDvcName[2],' N'       ;  characters of the Device Name
  MOV  [DI].LHLPTIndex,0               ;Index = 0 (same as LPT1, not LPT10)
I90:                                   ;Done
  POP  DI,CX,BX                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADD/REMOVE ALL OF OUR DEVICE HEADERS TO/FROM THE DEVICE HEADER CHAIN
;Inputs:  ES = TSR Data Area
;         If AddLPTxHeaders, DS = TSR Data Area also
;Outputs:
;Changes: Device Header List in DOS
;NOTES: When DOS loads Device Drivers normally (via CONFIG.SYS), it puts
;         new Devices at the beginning of the chain, rather than the end.
;         This is so that a "new" Driver will replace the old one if
;         they have the same name (e.g., ANSI.SYS replaces the standard
;         CON Device Header with a new one).
;       We do the same thing.  This way, we can allow Rx Data requests
;         to be processed from the LPT ports.  No existing programs
;         will know about it, but it will still work if some program
;         asks about it.
;------------------------------------------------------------------------------
RemoveLPTxHeaders:
  PUSH AX                  ;Save used registers
  MOV  AX,RemoveDvcHeader  ;AX = Code Offset to Call
  JMP >H00                 ;Do it
AddLPTxHeaders:
  PUSH AX                  ;Save used registers
  MOV  AX,AddDvcHeader     ;AX = Code Offset to Call
;  JMP >H00                 ;Do it
H00:
  PUSH CX,DI               ;Save used registers
  MOV  DI,(LPTxHeaders+(9 * LPTxHdrStrucSize)) ;Point [DI] at PRN Structure
  MOV  CX,10               ;Do 10 LPT ports (PRN and LPT9 - LPT1)
A10:                       ;Loop to here for each Header
  CALL AX                  ;Add/Remove the Header for the Device Chain
  SUB  DI,LPTxHdrStrucSize ;Point at the next Header
  LOOP A10                 ;Keep going until we're done
  POP  DI,CX               ;Restore used registers
  POP  AX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADD A SINGLE DEVICE HEADER TO THE DEVICE HEADER CHAIN
;Inputs:   DS = ES = TSR Data Area
;         [DI] = Device Header to Add to the Chain
;Outputs:
;Changes: Adds Device Header to DOS Chain
;NOTES: When DOS loads Device Drivers normally (via CONFIG.SYS), it puts
;         new Devices at the beginning of the chain, rather than the end.
;         This is so that a "new" Driver will replace the old one if
;         they have the same name (e.g., ANSI.SYS replaces the standard
;         CON Device Header with a new one).
;       We do the same thing.  This way, we can allow Rx Data requests
;         to be processed from the LPT ports.  No existing programs
;         will know about it, but it will still work if some program
;         asks about it.
;       We set up our own header attributes, appropriate to our
;         particular driver, for all non-parallel printers (all LPTx's
;         that don't have a legitimate I/O address associated with them).
;------------------------------------------------------------------------------
AddDvcHeader:
  PUSH AX,BX,ES                     ;Save used registers
  CLI                               ;Disable interrupts
  LES  BX,NULDvcHeader              ;Point ES:[BX] at the NUL Device Header
  MOV  AX,W ES:[BX].DHNextHeader[0] ;Copy the next Driver Offset
  MOV  W [DI].DHNextHeader[0],AX    ;  into our Header
  MOV  AX,W ES:[BX].DHNextHeader[2] ;Copy the next Driver Segment
  MOV  W [DI].DHNextHeader[2],AX    ;  into our Header
  MOV  W ES:[BX].DHNextHeader[0],DI ;Store our Offset
  MOV  W ES:[BX].DHNextHeader[2],DS ;Store our Segment
  STI                               ;Enable interrupts
  POP  ES,BX,AX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESTORE THE DEVICE HEADER CHAIN BACK TO NORMAL
;Inputs:   ES = TSR Data Area
;         [DI] = Device Header to Remove from the Chain
;Outputs: Restores Device Driver Chain back to the way it was,
;           if it was not done already
;Changes:
;------------------------------------------------------------------------------
RemoveDvcHeader:
  PUSH AX,BX,DS,ES                  ;Save used registers
  CLI                               ;Disable interrupts
  MOV  DS,ES                        ;Point DS at TSR Data Area
  LES  BX,NULDvcHeader              ;Point ES:[BX] at the NUL Device Header
  MOV  AX,DS                        ;Put TSR Segment in AX (to compare)
R10:                                ;Loop to here to find last Device Header
  CMP  W ES:[BX].DHNextHeader[0],-1 ;Is this the Last Device Header?
  JE  >R90                          ;If so, we've already done this
  CMP  W ES:[BX].DHNextHeader[0],DI ;If not, does the offset match ours?
  JNE >R20                          ;If not, skip it
  CMP  W ES:[BX].DHNextHeader[2],AX ;Does the Segment match ours?
  JE  >R30                          ;If so, it's the one we're looking for
R20:                                ;Not the previous Device Header
  LES  BX,ES:[BX]                   ;Get the next Device Header Pointer
  JMP  R10                          ;Keep looking
R30:                                ;ES:[BX] = Device Header previous to us
  MOV  AX,W [DI].DHNextHeader[0]    ;Remove our
  MOV  W ES:[BX].DHNextHeader[0],AX ;  Driver
  MOV  AX,W [DI].DHNextHeader[2]    ;  from the
  MOV  W ES:[BX].DHNextHeader[2],AX ;  Chain
R90:                                ;Done
  STI                               ;Enable interrupts
  POP  ES,DS,BX,AX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE MEMORY ADDRESS OF THE NUL DEVICE HEADER
;Inputs:  DS = ES = TSR Data Area
;Outputs: NULDvcHeader = Address of NUL Device Header
;Changes:
;------------------------------------------------------------------------------
GetNULDvcHdr:
  PUSH AX,BX,CX ;Save used registers
  PUSH ES       ;Save used registers
  MOV  AX,3000h ;Service 30h (get DOS version number)
                ;  DOS 5.0+ requires AL = 00h, may change BX and CX
  INT  21h      ;Do it (Returns AL= Major, AH = Minor)
  XCHG AL,AH    ;Put Major Version in BH,
  MOV  BX,AX    ;  Minor Version in BL
  MOV  CX,22h   ;Assume DOS version 3.1+
  CMP  BX,030Ah ;Is it DOS version 3.1+?
  JAE >N20      ;If so, continue
  MOV  CL,28h   ;If not, assume DOS version 3.0
  CMP  BH,03h   ;Is it DOS version 3.0?
  JE  >N20      ;If so, continue
  MOV  CL,17h   ;If not, assume version 2.x
N20:            ;CX contains Offset in List of Lists
  MOV  AH,52h   ;Function 52h (Get DOS list of Lists)
  INT  21h      ;Do it (returns ES:[BX])
  ADD  BX,CX    ;Add the Offset to the NUL Device Header
  MOV  W NULDvcHeader[0],BX ;Store the Offset
  MOV  W NULDvcHeader[2],ES ;Store the Segment
  POP  ES       ;Restore used registers
  POP  CX,BX,AX ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED TO SET UP AND DO SCREEN PAUSES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SETUP PARAMETERS FOR DOING A SCREEN PAUSE (FOR PRINTING A LARGE TABLE)
;Inputs:  DS = Local Data Area
;         DS:[DX] = ASCIIZ Header to Print at top of each screen
;                   Last character of the Header MUST be an LF
;                   If SetupPauseNoHdr, we "inject" NoMsg as the Header
;Outputs: Pauses the screen with a MORE message every time it gets full
;NOTES:   If a Screen Header is really large (almost taking up the whole
;           screen itself, with little room for data), this procedure
;           may not work correctly.  This procedure does not validate
;           the size of the Header -- it simply assumes that it is a
;           "reasonable" size compared to the size of the screen.  Most
;           anything that needs a Screen Header (a long data table) will
;           only have a few lines of Header, so this should be OK as a
;           general purpose procedure.
;         After this Setup is complete (which should be near the beginning
;           of MAIN, before anything is sent to the screen), WriteZPause
;           must be called for ALL screen writing to CON:, not WriteZCon!
;         The Pausing occurs in "real time", meaning we can send things
;           to the Pause routine a byte, line, or several screens at a
;           time for processing.  Because we do it in "real time",
;           we can end up with extra MORE's and screen Headers appearing
;           on screen than are actually needed.  During a screen
;           transition (or a transition to a new Header) whether we
;           actually need to write anything or not depends on if there
;           is actually any real data coming afterward (in time), which
;           of course we don't know (since it hasn't happened yet).
;           So, we must assume there is more data to come and process the
;           MORE's and Screen Headers accordingly.  This only causes problems
;           (in the form of extraneous MORE's and Screen Headers)
;           when things happen near the bottom of the screen.
;           DOS's MORE utiltiy (and other programs of similar ilk) do not
;           process in "real time", but rather store things in a Temporary
;           File and then process the file.
;------------------------------------------------------------------------------
SetupPauseNoHdr:
  PUSH DX         ;Save used registers
  MOV  DX,NoMsg   ;Point at 0-length Message
  CALL SetupPause ;Setup the Pause
  POP  DX         ;Restore used registers
  RET

SetupPause:
  PUSH AX,BX,CX,DI,SI     ;Save used registers
  MOV  SI,OFFSET PauseHeaderPtr ;Point [SI] at PauseHeaderPtr
  CMP  W [SI],-1          ;Has the user already cancelled us?
  JE  >S90                ;If so, just quit
  CMP  W [SI],0           ;Has the user stopped pausing already?
  JE  >S85                ;If so, just write the header
  CALL TestRedir          ;Is our output redirected?
  JNC >S10                ;If not, setup our Headers
  MOV  W [SI],0           ;Mark as Redirected or Pausing Stopped/Disabled
  JMP >S85                ;Jump to write the Header and Quit
S10:                      ;Output not redirected
  CALL GetScreenRows      ;Store the number of rows
  MOV  PauseRows,AX       ;  on the screen
  CALL CountZLinesCX      ;Calculate the number of lines
  INC  CX,2               ;  in the new Header
  MOV  DI,PauseRowCount   ;Get the Current Row count
  ADD  DI,CX              ;Add the size of the new header
  SUB  DI,3               ;Adjust for Headers
  DEC  AX                 ;Will writing the new Header
  CMP  DI,AX              ;  cause a Pause event?
  JB  >S50                ;If not, handle it
S20:                      ;New Header is too big to fit on screen
  MOV  W [SI],NoMsg       ;Point Header for second page at nothing
  MOV  PauseHeaderSize,2  ;Set Pause Header Size
  PUSH CX                 ;Save New Header Size
  SUB  AX,PauseRowCount   ;Calculate how many rows to fill up the screen
  MOV  CX,AX              ;Put number of rows in CX
  INC  CX                 ;Adjust it
S30:                      ;Loop to here to fill up the screen
  CALL WriteCrLfPause     ;Write a new line
  LOOP S30                ;Keep going until we're done
  POP  CX                 ;Restore New Header Size
  CMP  W [SI],-1          ;Did the user cancel during the header transition?
  JE  >S90                ;If so, we're done
  CMP  W [SI],0           ;Did the user stop Pausing during the transition?
  JE  >S85                ;If so, just write the Header
S50:                      ;Need to adjust current Row Count
  SUB  PauseRowCount,2    ;Adjust things for the previous Header
S80:                      ;Store new Header Info
  MOV  [SI],DX            ;Store the Header Address
  MOV  PauseHeaderSize,CX ;Store the Header Size
  ADD  PauseRowCount,CX   ;Add the Header Size to the Row Count
  MOV  AX,PauseRows       ;Compensate if
  CMP  AX,PauseRowCount   ;  the new header
  JAE >S85                ;  put us past
  DEC  AX                 ;  the end
  MOV  PauseRowCount,AX   ;  of hte screen
S85:                      ;Write Header
  CALL WriteZCon          ;Write the Header
S90:                      ;We're done
  POP  SI,DI,CX,BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHECK TO SEE IF STDOUT HAS BEEN REDIRECTED
;Inputs:
;Outputs: CF = Clear if STDOUT is normal (usually the screen)
;            = Set if STDOUT been redirected
;Changes:
;------------------------------------------------------------------------------
TestRedir:
  PUSH AX,BX,DX        ;Save used registers
  MOV  AX,4400h        ;Function 4400h (Get Device Info)
  MOV  BX,StdOutHandle ;Device = STDOUT
  INT  21h             ;Do it (returns DX, changes AX)
  JC  >R80             ;If error, assume not Redirected
  AND  DL,(DvcInfoIsDevice+DvcInfoIsStdOut) ;Mask out unwanted bits
  CMP  DL,(DvcInfoIsDevice+DvcInfoIsStdOut) ;Is it still the STDOUT Device?
  JE  >R80             ;If so, it's not Redirected
R70:                   ;STDOUT has been Redirected
  STC                  ;Set the Redirected flag
  JMP >R90             ;Done
R80:                   ;STDOUT is not Redirected
  CLC                  ;Set the Not-Redirected flag
R90:                   ;Done
  POP  DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NUMBER OF VIDEO ROWS ON THE SCREEN
;Inputs:
;Outputs: AX = Number of text rows on the screen
;                (usually 25, 43, or 50)
;Changes:
;------------------------------------------------------------------------------
GetScreenRows:
  PUSH BX,CX,DS  ;Save used registers
  MOV  AX,40h    ;Point ES to
  MOV  DS,AX     ;  BIOS data area
  MOV  AH,12h    ;Function 12h (EGA Alternate Select)
  MOV  BX,0FF10h ;Subfunction (BL) 10h (Return EGA information)
                 ;  Preset unrealistic return value (BH)
  INT  10h       ;Do it (returns AX, BX, CX)
  CMP  BL,10h    ;Is the function supported (EGA or better)?
  JE  >R50       ;If not, jump to handle MDA/CGA
  CMP  BH,0FFh   ;Is the return value valid?
  JE  >R50       ;If not, jump to handle MDA/CGA
  TEST B [87h],8 ;If so, is bit 3 of the EGA information byte set?
  JNZ >R50       ;If so, EGA is not the active display
  XOR  AX,AX     ;Get # of
  MOV  AL,[84h]  ;  rows - 1
  JMP >R90       ;We're done
R50:             ;Video card is less than EGA (MDA or CGA)
  MOV  AX,24     ;Number of rows must be 25
R90:             ;We're done
  INC  AX        ;Bump the number of rows by 1
  POP  DS,CX,BX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ASCIIZ STRING(s) TO THE SCREEN, PAUSING WHEN IF NECESSARY
;Inputs:  DS:[DX] = String to write
;         PauseRows, PauseHeaderPtr, PauseHeaderSize, PauseRowCount
;         CS = Local Data Area
;Outputs: PauseRowCount
;Changes: Pauses the screen and waits for user input, if necessary
;NOTES: This should be called instead of WriteZCon every time something
;         is written during the Pausing.
;       A string can be written by WriteZCon during the pausing, as long
;         as the string does not contain a Line Feed.  Any line containing
;         a Line Feed must come through here or the Line Count will get
;         screwed up!
;------------------------------------------------------------------------------
WriteZPauseFar:
  CALL WriteZPause
  RETF

WriteZPause:
  PUSH AX,BX,CX,DX          ;Save used registers
  MOV  AX,CS:PauseHeaderPtr ;Put Header Pointer in AX
  CMP  AX,-1                ;Has the Output been cancelled by the user?
  JE  >P90                  ;If so, don't write anything at all
  OR   AX,AX                ;Is STDOUT Redirected?
  JZ  >P80                  ;If so, just write it with no Pausing
  CALL CountZLinesCX        ;Count how many Lines are in the string
  MOV  AX,CS:PauseRowCount  ;Add the new lines
  ADD  AX,CX                ;  to the current lines
  CMP  AX,CS:PauseRows      ;Will we be at or past the end of the screen?
  JB  >P70                  ;If not, just write it
  JE  >P20                  ;If at the end of the screen, handle it
  SUB  AX,CS:PauseRows      ;If not, find
  SUB  CX,AX                ;  the end of the String
  CALL FindEndOfLines       ;  we need to write ([BX])
  MOV  AL,[BX]              ;Save the character that's there now
  MOV  B [BX],0             ;Replace it with a 0
  CALL WriteZPause          ;Write it (will Pause correctly)
  MOV  [BX],AL              ;Restore original character
  MOV  DX,BX                ;Use the new string pointer
  CALL WriteZPause          ;Write it (Pausing if necessary)
  JMP >P90                  ;Done
P20:                        ;At end of screen
  CALL WriteZCon            ;Write the String
  CALL HandlePause          ;Handle the Pause (may change Pointers/Counters)
  JMP >P90                  ;We're done for now
P70:                        ;Store new Row Count
  MOV  CS:PauseRowCount,AX  ;Save the new Row Count
P80:                        ;Write the String
  CALL WriteZCon            ;Write the string
P90:                        ;Done
  POP  DX,CX,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE PAUSE LINE, AND WAIT FOR A KEYSTROKE
;Inputs:  CS = Local Data Area
;         PauseRows, PauseHeaderPtr, PauseHeaderSize, PauseRowCount
;Outputs: PauseRowCount, PauseHeaderPtr
;Changes: Pauses the screen and waits for user input, if necessary
;------------------------------------------------------------------------------
HandlePause:
  PUSH AX,BX,DX,DS        ;Save String Segment
  MOV  DS,CS              ;Point DS at our Data Segment
  MOV  BX,OFFSET PauseHeaderPtr ;Point [BX] at the Pause Header
  MOV  DX,PauseMsg        ;Write the
  CALL WriteZCon          ;  Enter a Keystroke message
  CALL FlushKbdBuff       ;Clear the keyboard buffer
L10:                      ;Loop to here to wait for a keystroke
  CALL GetKey             ;Is there a key in the keystroke buffer?
  JZ   L10                ;If not, keep waiting until there is
  MOV  DX,PauseDMsg       ;Delete the
  CALL WriteZCon          ;  MORE Message
  CMP  AL,CtrlC           ;Was the keystroke a Control-C?
  JE  >L40                ;If so, jump to handle it
  CMP  AL,Escape          ;Was the keystroke an Escape?
  JNE >L20                ;If not, just keep going
  MOV  W [BX],0           ;If so, mark us as redirected (stop Pausing)
  JMP >L90                ;And quit
L20:                      ;Continue with the Pause
  MOV  DX,PauseNMsg       ;Write the
  CALL WriteZCon          ;  MORE Replacement Line
  MOV  DX,[BX]            ;Point DX at the Header
  CALL WriteZCon          ;Write it
  MOV  AX,PauseHeaderSize ;Reset the Row Count
  MOV  PauseRowCount,AX   ;Store the new Row Count
  JMP >L90                ;We're done for now
L40:                      ;Ctrl-C (stop altogether)
  MOV  W [BX],-1          ;Mark as stopped
L90:                      ;Done
  POP  DS,DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE NUMBER OF LINES IN AN ASCIIZ STRING (COUNT CR/LF COMBINATIONS)
;Inputs:  DS:[DX] = Pointer to String to measure
;         CLD already issued
;Outputs: CX = Number of LF's in the String (may be 0)
;         ZF = Set if CX = 0
;            = Clear if CX > 0
;Changes:
;------------------------------------------------------------------------------
CountZLinesCX:
  PUSH AX,SI ;Save used registers
  MOV  SI,DX ;Put the pointer in DI
  XOR  CX,CX ;Initialize Lines Counter
Z10:         ;Loop to here for each character
  LODSB      ;Get the next character
  OR   AL,AL ;Is it the end of the string?
  JZ  >Z90   ;If so, we're done
  CMP  AL,LF ;Is it a Line Feed?
  JNE  Z10   ;If not, it's not a new line
  INC  CX    ;If so, Increment the Line Counter
  JMP  Z10   ;Keep looking
Z90:         ;We're done
  OR   CX,CX ;Set return flag
  POP  SI,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE POINTER AFTER THE FIRST SEVERAL LINES OF A STRING
;Inputs:  DS:[DX] = String to use
;         CX = Number of lines to "skip"
;         CLD already issued
;Outputs: DS:[BX] = "New" String Pointer (after the last line written)
;Changes:
;NOTES: This assumes that the string actually has MORE than the number of
;         lines in AX (it does not look for the end of an ASCIIZ string).
;------------------------------------------------------------------------------
FindEndOfLines:
  PUSH AX,CX  ;Save used registers
  PUSH DI,ES  ;Save used registers
  MOV  BX,CX  ;BX = Line Counter
  MOV  ES,DS  ;Point ES:[DI] at
  MOV  DI,DX  ;  the string
  MOV  AL,LF  ;Look for Line Feeds
  MOV  CX,-1  ;Maximize counter
L10:          ;Loop to here for each new line
  REPNE SCASB ;Look for the end-of-line character
  DEC  BX     ;Decrement the Line Counter
  JNZ  L10    ;If not 0 yet, keep looking
  MOV  BX,DI  ;Store the new string beginning
L90:          ;Done
  POP  ES,DI  ;Restore used registers
  POP  CX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FLUSH KEYBOARD BUFFER
;Inputs:
;Outputs:
;Changes: Flushes the Keyboard Buffer
;------------------------------------------------------------------------------
FlushKbdBuff:
  PUSH AX     ;Save used registers
F10:          ;Loop to here for each key
  CALL GetKey ;Get a key from the keyboard buffer
  JNZ  F10    ;If there was one, get another
  POP  AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ CHARACTER FROM THE KEYBOARD BUFFER
;Inputs:
;Outputs: AH = Keyboard scan code
;         AL = ASCII value of keypress (0 if extended ASCII)
;         AX = 0 if no key is waiting
;Changes: ZF = Set if no key in buffer (AX = 0)
;            = Clear if a key was found (AX = key)
;------------------------------------------------------------------------------
GetKey:
  MOV  AH,1  ;Service 1 (Keystroke waiting?)
  INT  16h   ;Do It
  JZ  >K10   ;If no key waiting, we're done
  XOR  AH,AH ;If a key is waiting, service 0 (Get keystroke)
  INT  16h   ;Do It
  JMP >K90   ;We're done
K10:         ;No keystroke waiting
  XOR  AX,AX ;Make sure AX=0
K90:         ;We're done
  OR   AX,AX ;Set the found/not found flag
  RET

;------------------------------------------------------------------------------
;WRITE A CR/LF TO THE CONSOLE WITH A PAUSE
;Inputs:
;Outputs: To Screen, Updates Pause Counters
;Changes:
;------------------------------------------------------------------------------
WriteCrLfPause:
  PUSH DX          ;Save used registers
  MOV  DX,CrLfMsg  ;Write a Cr/Lf to
  CALL WriteZPause ;  the Pause Device
  POP  DX          ;Restore used registers
  RET

WriteCrLfPause2:
  CALL WriteCrLfPause ;Move down
  CALL WriteCrLfPause ;  2 lines
  RET

WriteCrLfErr:
  PUSH DX         ;Save used registers
  MOV  DX,CrLfMsg ;Write a Cr/Lf to
  CALL WriteZErr  ;  the ERR Device
  POP  DX         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SOME GENERIC CODE TO WRITE STRINGS, ETC.
;THIS CODE IS NEEDED IN ALMOST EVERY PROGRAM WE WRITE.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GETS RID OF ENVIRONMENT INFORMATION - NOT NEEDED IN TSR
;Inputs:
;Outputs:
;Changes: Quits if problem releasing memory
;------------------------------------------------------------------------------
DelEnvironment:
  PUSH AX,ES            ;Save used registers
  MOV  ES,[PSPEnvirSeg] ;Point ES at the Environment Segment
  MOV  AH,49h           ;Service 49h (free up memory)
  INT  21h              ;Do it
  JNC >E90              ;If no error occurred, Quit
  MOV  DX,NoEnvironMsg  ;If error, point to message
  MOV  AL,ErLvlMemory   ;Errorlevel = Memory Problem
  JMP  Exit             ;QUIT
E90:                    ;We're done
  POP  ES,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;BEEP THE SPEAKER
;Inputs:
;Outputs: Beeps the speaker
;Changes:
;------------------------------------------------------------------------------
BeepErr:
  PUSH AX,BX    ;Save used registers
  XOR  BX,BX    ;BH = Video page = 0
  MOV  AX,0E07h ;AH = 0Eh = Function = Write TTY
                ;AL = 07h = Character to write = BEL
  INT  10h      ;Do it
  POP  BX,AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CAPITALIZE A CHARACTER (Byte)
;Inputs:  AL = character to be capitalized
;Outputs: AL = capitalized character
;Changes:
;------------------------------------------------------------------------------
Capitalize:
  CMP  AL,'a'     ;Is it less than 'a'?
  JB  >Z90        ;If so, quit
  CMP  AL,'z'     ;Is it more than 'z'?
  JA  >Z90        ;If so, quit
  SUB  AL,'a'-'A' ;If between 'a' and 'z', capitalize it
Z90:
  RET

;------------------------------------------------------------------------------
;WRITE A SPECIFIC CHARACTER OR SET OF CHARACTERS TO THE SCREEN
;Inputs:
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
WriteAL:
  PUSH DX              ;Save used registers
  MOV  DL,AL           ;Write what's in AL
  JMP >C00             ;Do it
WriteBlock:
  PUSH DX              ;Save used registers
  MOV  DL,'±'          ;Write a Block Character
  JMP >C00             ;Do it
WriteColon:
  PUSH DX              ;Save used registers
  MOV  DL,':'          ;Write a Colon
  JMP >C00             ;Do it
WriteComma:
  PUSH DX              ;Save used registers
  MOV  DL,','          ;Write a Comma
  JMP >C00             ;Do it
WriteDot:
  PUSH DX              ;Save used registers
  MOV  DX,DotMsg       ;Point at Message
  JMP >C10             ;Do it
Write4Dots:
  PUSH DX              ;Save used registers
  MOV  DX,Dot4Msg      ;Point at Message
  JMP >C10             ;Do it
WriteHexEnd:
  PUSH DX              ;Save used registers
  MOV  DL,'h'          ;Write an h
  JMP >C00             ;Do it
WriteLPTMsg:
  PUSH DX              ;Save used registers
  MOV  DX,LPTMsg       ;Point at Message
  JMP >C10             ;Do it
WriteSemiColon:
  PUSH DX              ;Save used registers
  MOV  DL,';'          ;Write a ;
  JMP >C00             ;Do it
WriteSpace:
  PUSH DX              ;Save used registers
  MOV  DX,SpaceMsg     ;Point at Message
  JMP >C10             ;Do it
Write2Spaces:
  PUSH DX              ;Save used registers
  MOV  DX,Space2Msg    ;Point at Message
  JMP >C10             ;Do it
Write3Spaces:
  PUSH DX              ;Save used registers
  MOV  DX,Space3Msg    ;Point at Message
  JMP >C10             ;Do it
Write4Spaces:
  PUSH DX              ;Save used registers
  MOV  DX,Space4Msg    ;Point at Message
  JMP >C10             ;Do it
Write5Spaces:
  PUSH DX              ;Save used registers
  MOV  DX,Space5Msg    ;Point at Message
  JMP >C10             ;Do it
WriteStar:
  PUSH DX              ;Save used registers
  MOV  DL,'*'          ;Write an aterik
  JMP >C00             ;Do it
C00:
  MOV  SingleMsg[0],DL ;Put the character in the Single Character String
  MOV  DX,SingleMsg    ;Point at Single Character String
C10:                   ;DX is pointed at String
  CALL WriteZPause     ;Write the String
  POP  DX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A YES OR NO AND THEN SOME SPACES TO THE SCREEN
;Inputs: AL/AH = Status Word to test (If WriteYesNoAL or WriteYesNoAH)
;        DL/DH = Status Word to test (If WriteYesNoDL or WriteYesNoDH)
;        BH    = Mask to test for
;Outputs: To the screen
;Changes:
;------------------------------------------------------------------------------
;WriteYesNoALBH:
;  PUSH AX         ;Save used registers
;  JMP >Y00        ;Jump to do it
WriteYesNoAHBH:
  PUSH AX         ;Save used registers
  MOV  AL,AH      ;Put test byte into AL
;  JMP >Y00        ;Jump to do it
;WriteYesNoDLBH:
;  PUSH AX         ;Save used registers
;  MOV  AL,DL      ;Put test byte into AL
;  JMP >Y00        ;Jump to do it
;WriteYesNoDHBH:
;  PUSH AX         ;Save used registers
;  MOV  AL,DH      ;Put test byte into AL
;;  JMP >Y00        ;Jump to do it
Y00:
  PUSH DX         ;Save used registers
  MOV  DX,Yes2Msg ;Assume Yes
  TEST AL,BH      ;Is it Yes?
  JNZ >Y20        ;If so, write Yes
  MOV  DX,No2Msg  ;If not, write No
Y20:              ;[DX] = String to write
  CALL WriteZCon  ;Write it
  POP  DX         ;Restore used registers
  POP  AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE SOME SPACES TO THE SCREEN
;Inputs:  CL = Number of spaces to write
;         SpaceMsg
;Outputs: To the screen
;Changes:
;------------------------------------------------------------------------------
WriteSpaces:
  PUSH CX,DX       ;Save used registers
  OR   CL,CL       ;Should we write 0 spaces?
  JZ  >S90         ;If so, we're done
  XOR  CH,CH       ;If OK, change it to a word
  MOV  DX,SpaceMsg ;Point at the message
S10:               ;Loop to here for each space
  CALL WriteZPause ;Write the space
  LOOP S10         ;Keep going until we're done
S90:               ;We're done
  POP  DX,CX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT NIBBLE, BYTE, OR WORD TO HEX CHARACTER STRING, AND WRITE IT
;Inputs:  AL/AX = Nibble/Byte/Word to be written
;         CLD must be set already!
;Outputs: Writes to the Screen
;Changes: HexString
;------------------------------------------------------------------------------
;WriteNibbleHex:
;  PUSH BX             ;Save used registers
;  MOV  BX,3           ;Need to start of offset 3 in string
;  JMP >H00            ;Jump to do it
;WriteByteHex:
;  PUSH BX             ;Save used registers
;  MOV  BX,2           ;Need to start of offset 2 in string
;  JMP >H00            ;Jump to do it
WriteWordHex:
  PUSH BX             ;Save used registers
  XOR  BX,BX          ;Need to start of offset 0 in string
;  JMP >H00            ;Jump to do it
;H00:                  ;Start converting the strings
  PUSH DX,DI          ;Save used registers
  MOV  DI,HexString   ;Point DS:[DI] at HexString
  MOV  DX,DI          ;Point DS:[DX] at HexString
  CALL Word2HexString ;Convert the entire Word to a String
  ADD  DX,BX          ;Point DX at the beginning of where we write
  CALL WriteZPause    ;Write it
  POP  DI,DX          ;Restore used registers
  POP  BX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A BYTE OR WORD TO A HEXADECIMAL STRING (2 OR 4 CHARACTERS)
;Inputs:  AX = Word to Convert to a Hex String
;         DS = Local Data Area
;         CLD already issued
;Outputs: DS:[DI]
;Changes: DI
;------------------------------------------------------------------------------
Byte2HexString:
  PUSH AX,ES            ;Save used registers
  MOV  ES,DS            ;Point ES:[DI] at the String
  CALL Word2HexString10 ;Convert it
  POP  ES,AX            ;Restore used registers
  RET

Word2HexString:
  PUSH AX,BX,ES         ;Save used registers
  MOV  BX,AX            ;Save original Word
  MOV  ES,DS            ;Point ES:[DI] at
  CALL Word2HexString00 ;Convert it
  POP  ES,BX,AX         ;Restore used registers
  RET

Word2HexString00:
  MOV  AL,BH            ;Convert High Byte
  CALL Word2HexString10 ;  to ASCII
  MOV  AL,BL            ;Work with Low Byte
Word2HexString10:       ;Convert Byte to ASCII
  AAM  10h              ;Separate Low & High Nibbles
  XCHG AH,AL            ;Put High Nibble in AL
  CALL Word2HexString20 ;Convert High Nibble to ASCII
  XCHG AH,AL            ;Work with Low Nibble
Word2HexString20:       ;Convert Nibble to ASCII
  ADD  AL,90h           ;Convert BCD
  DAA                   ;  to Decimal
  ADC  AL,40h           ;Convert Decimal
  DAA                   ;  to ASCII
  STOSB                 ;Store the Nibble
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE OR WORD TO THE SCREEN AS A DECIMAL
;Inputs:  AL/AX = Byte/Word to Write
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteByteMin:
  PUSH AX,BX         ;Save used registers
  XOR  AH,AH         ;Make sure high byte is 0
  MOV  BH,1          ;Mark as doing minimum
  JMP >W00           ;Do it
;WriteWordMin:
;  PUSH AX,BX         ;Save used registers
;  MOV  BH,1          ;Mark as doing minimum
;  JMP >W00           ;Do it
ByteToString:
  PUSH AX,BX         ;Save the original word & BP
  XOR  AH,AH         ;Make sure high byte is 0
  XOR  BH,BH         ;BH = No Minimum, Byte
  JMP >W00           ;Jump to start the loop
WordToString:
  PUSH AX,BX         ;Save the original word
  MOV  BH,2          ;BP = No Minimum, Word
W00:                 ;Do a word or a byte
  PUSH CX,DX,SI      ;Save used registers
  MOV  SI,SingleMsg  ;Point at the single character message
  XOR  BL,BL         ;Test for first non-zero character is false
  MOV  CX,10000      ;First divisor is 10,000
W20:                 ;Loop to here for each character
  XOR  DX,DX         ;High word of Dividend = 0
  DIV  CX            ;Divide DX:AX by current divisor
  OR   AX,AX         ;Is this a non-zero character?
  JNZ >W30           ;If so, we need to write it
  OR   BL,BL         ;Has there already been a non-zero character?
  JNZ >W30           ;If so, we need to write it
  CMP  CX,1          ;Is this the last character?
  JE  >W30           ;If so, we need to write it
  TEST BH,1          ;Are we doing a minimum?
  JNZ >W40           ;If not, don't write anything
  MOV  AL,' '        ;Assume a space
  TEST BH,2          ;Doing a word?
  JNZ >W35           ;If so, write the space
  CMP  CX,100        ;If not, doing the hundreds character?
  JBE >W35           ;If so, write the space
  JMP >W40           ;If not, don't write anything
W30:                 ;We need to write this character
  INC  BL            ;Test for first non-zero character is true
  ADD  AL,'0'        ;Convert the Number to ASCII
W35:                 ;Write the character
  MOV  [SI],AL       ;Write the
  CALL WriteZPauseSI ;  character
W40:                 ;Skip this character - just make it a space
  CMP  CX,1          ;Was this the last division to do?
  JE  >W90           ;If so, we're done
  MOV  AX,DX         ;If not, start next loop with remainder of division
  PUSH AX            ;Save register for a second
  XOR  DX,DX         ;So dividend won't be messed up
  MOV  AX,CX         ;Want to divide divisor in CX
  MOV  CX,10         ;Want to divide by 10
  DIV  CX            ;Divide it
  MOV  CX,AX         ;Store it back in CX
  POP  AX            ;Restore register
  JMP  W20           ;And do it again
W90:                 ;We're done
  POP  SI,DX,CX      ;Restore used registers
  POP  BX,AX         ;Restore original word & BP
  RET

;;------------------------------------------------------------------------------
;;WRITE A BYTE OR WORD TO THE SCREEN AS A DECIMAL, LEFT ALIGNED
;;Inputs:  AL = Byte to Write
;;Outputs:
;;Changes:
;;------------------------------------------------------------------------------
;WriteByteMinSpaces:
;  CALL WriteByteMin ;Write the byte
;  CMP  AL,100       ;Did we write three numerals?
;  JAE >S90          ;If so, we're done
;  CALL WriteSpace   ;If not, write a space
;  CMP  AL,10        ;Did we write two numerals?
;  JAE >S90          ;If so, we're done
;  CALL WriteSpace   ;If not, write a space
;S90:                ;Done
;  RET

;------------------------------------------------------------------------------
;SEARCH A BYTE-TO-STRING LOOKUP TABLE FOR A MATCHING ENTRY
;Inputs:  DS:[BX] = Table to search
;         AL      = Byte to search for
;         CLD already issued
;Outputs: CF = Clear if a byte match as found in table
;              BX = Pointer to the String
;            = Set if no match found in table
;              BX = unchanged
;Changes:
;NOTES: Last Entry in Table (end-of-table marker) = DW -1
;------------------------------------------------------------------------------
SearchByte2StringTbl:
  PUSH AX,SI            ;Save used registers
  CLD                   ;Go forward with string functions
  MOV  SI,BX            ;Put pointer in SI
  MOV  AH,AL            ;Put byte to check in AH
S10:                    ;Loop to here for each table entry
  LODSB                 ;Get the next table entry
  CMP  AL,-1            ;Is it possibly the end of the table?
  JNE >S20              ;If not, continue
  CMP  B [SI],-1        ;Is it actually the end of the table?
  JE  >S70              ;If so, there's no match
S20:                    ;Not end of table
  CMP  AL,AH            ;Is it a match?
  JE  >S80              ;If so, handle it!
  CALL SkipOverStringSI ;If not, skip over the string
  JMP  S10              ;And keep looking
S70:                    ;No entry found
  STC                   ;Set the not found flag
  JMP >S90              ;Quit
S80:                    ;Entry found [SI]
  MOV  BX,SI            ;Point BX at the String
  CLC                   ;Set the found flag
S90:                    ;Done
  POP  SI,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER AN ASCIIZ STRING
;Inputs:  DS:[SI] = ASCIIZ String to Skip Over
;Outputs:
;Changes: [SI] points at character after the 0
;------------------------------------------------------------------------------
SkipOverStringSI:
  PUSH CX            ;Save used registers
  CALL CalcStrSizeSI ;Calculate the size of the string
  ADD  SI,CX         ;Add it to the pointer
  INC  SI            ;Skip over the 0
  POP  CX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LENGTH OF AN ASCIIZ STRING
;Inputs:  DS:[SI] = ASCIIZ String to work with
;Outputs: CX = Length of String
;         ZF = Set if string is 0 length
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
CalcStrSizeSI:
  PUSH DX            ;Save used registers
  MOV  DX,SI         ;Calculate the
  CALL CalcStrSizeDX ;  length of the string
  POP  DX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE AN ASCIIZ STRING, POINTED AT BY SI, TO PAUSE
;Inputs:  DS:[SI] = ASCIIZ String to Write
;Outputs: To Screen (CON)
;Changes:
;------------------------------------------------------------------------------
WriteZPauseSI:
  PUSH DX          ;Save used registers
  MOV  DX,SI       ;Write the
  CALL WriteZPause ;  string
  POP  DX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ASCIIZ STRING TO CON OR TO ERR
;Inputs:  DS:[DX] = Pointer to string
;         CS = Local Data Area
;Outputs: Writes the string to CON or ERR
;Changes:
;------------------------------------------------------------------------------
WriteZCon:                  ;Write to CON
  CMP  CS:PauseHeaderPtr,-1 ;Should we write anything?
  JE  >Z90                  ;If not, just quit
  PUSH BX                   ;Save used register
  MOV  BX,StdOutHandle      ;Write to STDOUT
  JMP >Z00                  ;Jump to do it
WriteZErr:                  ;Write to ERR
  PUSH BX                   ;Save used register
  MOV  BX,StdErrHandle      ;Write to STDERR
Z00:
  PUSH AX,CX                ;Save used registers
  CALL CalcStrSizeDX        ;Calculate the size of the string (returns CX)
  JZ  >Z80                  ;If nothing to write, just quit
  MOV  AH,40h               ;Function 40h (Write to Device)
  INT  21h                  ;Do it
Z80:                        ;We're done
  POP  CX,AX                ;Restore used registers
  POP  BX                   ;Restore used register
Z90:                        ;We're done
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LENGTH OF AN ASCIIZ STRING
;Inputs:  DS:[DX] = Pointer to the string
;Outputs: CX = Length of the string
;         ZF = Set if string is 0 length
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
CalcStrSizeDX:
  PUSH AX,DI  ;Save used registers
  PUSH ES     ;Save used registers
  MOV  ES,DS  ;Point ES:[DI]
  MOV  DI,DX  ; at the string
  XOR  AL,AL  ;Look for a 0
  MOV  CX,-1  ;Start with max count for REPNE
  REPNE SCASB ;Find the end of the string
  NOT  CX     ;Calculate the size
  DEC  CX     ;  of the string (sets ZF)
  POP  ES     ;Restore used registers
  POP  DI,AX  ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PARSE THE COMMAND LINE FOR SWITCHES, AND PRINT ERRORS.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PARSE THE COMMAND LINE FOR SWITCHES
;Inputs:
;Outputs: All kinds of stuff!
;Changes:
;------------------------------------------------------------------------------
ParseIt:
  CALL FixCmdLineCR    ;Replace CR at end of Command Line with a 0
  CALL FillStdInBuffer ;Copy redirected input to our buffer, if needed
                       ;  Quits if error
  MOV  ParseTest,Yes   ;Test input strings for errors
  CALL ParseThings     ;Do all input strings
  MOV  ParseTest,No    ;Parse string for real
  CALL ParseThings     ;Do all input strings
P90:
  RET

ParseThings:
  PUSH SI                       ;Save used registers
  MOV  SI,EnvVarPointer         ;Point at our Environment Variable
  CMP  SI,-1                    ;Is there an Environment Variable to parse?
  JE  >P30                      ;If no, skip it
  OR   ProgFlags2,DoEnvir       ;Mark as doing the Environment
  CMP  ParseTest,Yes            ;Just doing the Test Run?
  JE  >P20                      ;If so, don't write the variable contents yet
  MOV  DX,EnvMsg                ;Write the first part of the
  CALL WriteZPause              ;  environment message to the screen
  CALL WriteEnvCon              ;Write the environment variable contents
  CALL WriteCrLfPause2          ;Move down
P20:                            ;Do the Environment Variable
  CALL ParseCmdLine             ;Parse the Environment (quits if Error)
P30:                            ;Do StdIn
  AND  ProgFlags2,(NOT DoEnvir) ;Mark as doing Command Line
  OR   ProgFlags2,DoStdIn       ;Parse the
  XOR  SI,SI                    ;  StdIn buffer
  CALL ParseCmdLine             ;  Quit if error
  AND  ProgFlags2,(NOT DoStdIn) ;  is found
  MOV  SI,81h                   ;Assume "real" Command Line
  CMP  CmdLineVarPointer,-1     ;Have a CMDLINE Environment variable?
  JE  >P50                      ;If not, just do regular command line
  MOV  SI,CmdLineVarPointer     ;If so, point at the variable
P50:                            ;Pointed at Command Line Tail
  CALL ParseCmdLine             ;Parse Command Line
  POP  SI                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PARSE THE COMMAND LINE FOR SWITCHES
;Inputs:  ParseTest
;         [SI] = Option String to Parse
;Outputs:
;Changes: SI
;------------------------------------------------------------------------------
ParseCmdLine:
  PUSH AX             ;Save used registers
P10:                  ;Look for the next switch
  CALL IsSpaceOrEOX   ;Look for a valid character
  JZ  >P90            ;If EOL, we're done
  CMP  AL,'/'         ;Is it a slash?
  JE  >P20            ;If so, jump to handle it
  CMP  AL,'-'         ;Is it a dash?
  JE  >P20            ;If so, jump to handle it
  DEC  SI             ;If not, point back at the first character
  JMP >P30            ;Continue
P20:                  ;It's a slash or a dash
  CALL IsSpaceOrEOL   ;Look for a valid switch character
  JZ  >P70            ;If no character, there's an error
P30:                  ;Look for the switch
  CALL GetSwitch      ;See if it matches one of our switches
  JNZ  P10            ;If a match, look for the next switch
P70:                  ;Error - tell the user where it was
  CALL WriteCmdErr    ;Display the error for the user
  MOV  AL,ErLvlOption ;ErrorLevel = Bad Option on command line
  MOV  DX,NoMsg       ;Point at an empty message
  JMP  Exit           ;Print error message and quit
P90:                  ;We're done
  POP  AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE SWITCH CHARACTERS, AND DO WHATEVER IT IS THEY'RE ASKING
;Inputs:  DS:[SI] = Command line pointer
;Outputs: Lots of stuff!!!
;         ParseError
;         ZF = Set if Error
;            = Clear if OK
;Changes:
;------------------------------------------------------------------------------
GetSwitch:
  PUSH AX,BX,DI,BP         ;Save used registers
  MOV  BX,SwitchList       ;Point at the list of switch code words
  CALL GetCode             ;See if its a match
  JNC >S10                 ;If so, jump to test it
  CALL GetNextChar         ;If not, it's a single character
  CALL Capitalize          ;Capitalize it
S10:                       ;We have a Switch to test!
  MOV  BX,SwitchTbl        ;Point at the Table of Offsets
S20:                       ;Loop to here for each table entry
  MOV  AH,[BX]             ;Get the switch from our table?
  OR   AH,AH               ;Is it the end of the table?
  JZ  >S70                 ;If so, there's an error
  CMP  AL,AH               ;If a valid entry, is it a match?
  JE  >S30                 ;If so, jump to handle it
  ADD  BX,3                ;If not, point at the next table entry
  JMP  S20                 ;And keep looking
S30:                       ;It's a match from the table
  MOV  DI,OFFSET ProgFlags ;Point [DI] at ProgFlags
  MOV  BP,OFFSET TSRFlags  ;Point [BP] at TSRFlags
  MOV  AH,ParseTest        ;Pass the "Testing" flag
  OR   AH,AH               ;Set the ZF for Testing
  CALL W [BX+1]            ;Do the Switch stuff
  JMP >S90                 ;And quit
S70:                       ;There's an error
  MOV  ParseError,Yes      ;Mark the error flag
S90:                       ;We're done
  CMP  ParseError,Yes      ;Set/Clear the error flag
  POP  BP,DI,BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Display Help (Syntax) Message
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchH:
  OR   B [DI],Help ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Display ErrorLevel Table
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchErrLvl:
  OR   B [DI+1],ErrLvl ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Display list of Command-line (Option) Aliases
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
DoSwitchA:
  OR   B [DI+2],Alias ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Uninstall Program from Memory
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchU:
  OR   B [DI],Uninstall ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Install Program in Lower Memory, even if Upper Memory is available
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchL:
  PUSH AX                   ;Save used registers
  MOV  AL,UseLowMemory      ;Bit mask to use
  CALL DoSwitchWithYNPrgFwd ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Display Program Status
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchS:
  OR   B [DI+2],Status ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display Status of LPT Ports
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchPortStatus:
  OR   B [DI+2],PortStatuses ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display Device ID's of Printers
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchI:
  OR   B [DI+2],DeviceIDs ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display list of Bad Devices
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchB:
  OR   B [DI+2],BadDevices ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display USB Descriptors of Last Device found
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchC:
  OR   B [DI+2],Descriptors ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Beep Speaker when "Bad" Devices are discovered
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchBeep:
  PUSH AX                   ;Save used registers
  MOV  AL,NoBeep            ;Bit mask to use
  CALL DoSwitchWithYNTsrRvs ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Send CR/FF after each copied file
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchF:
  PUSH AX                   ;Save used registers
  MOV  AL,NoFormFeed        ;Bit mask to use
  CALL DoSwitchWithYNPrgRvs ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Overwrite Parallel Ports with USB Ports
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchNoParallel:
  PUSH AX                   ;Save used registers
  MOV  AL,NoParallel        ;Bit mask to use
  CALL DoSwitchWithYNTsrFwd ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Automatically send Epson Initialization String to Printers
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchAutoEpson:
  PUSH AX                   ;Save used registers
  MOV  AL,NoAutoEpson       ;Bit mask to use
  CALL DoSwitchWithYNTsrRvs ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Enable/Disable CPU BOUND OpCode Patch
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchNoBoundFix:
  PUSH AX                   ;Save used registers
  MOV  AL,NoBoundFix        ;Bit mask to use
  CALL DoSwitchWithYNTsrRvs ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ReMap (Redirect) LPT Port
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchM:
  PUSH BX,DX,DI,ES         ;Save used registers
  CALL GetLPT4Switch       ;Get the From Index (DX)
  JC  >L75                 ;If Error, quit
  MOV  BX,DX               ;Store the From Index
  CALL GetLPT4Switch       ;Get the To Index (DX)
  JC  >L75                 ;If Error, quit
  XCHG BX,DX               ;DX = From Index, BX = To Index
  CALL GetRedirTblAddrESDI ;Point ES:[DI] at the Redirect Table
L30:                       ;ES:[DI] points at the Table (not necesarily our ES!)
  CMP  BX,DX               ;Are we Un-Redirecting?
  JE  >L40                 ;If so, no need to do the test
  CMP  B ES:[BX+DI],0      ;Is the To Index Redirected?
  JNE >L70                 ;If so, Error
L40:                       ;To Index tested for Redirection
  OR   AH,AH               ;Just the Test Run?
  JNZ >L90                 ;If so, we're done
  XCHG BX,DX               ;BX = From Index, DX = To Index
  CMP  BX,DX               ;Are we Un-Redirecting?
  JNE >L50                 ;If not, continue
  MOV  DL,-1               ;If so, we need to reset to 0
L50:                       ;DL contains Redir Port to use
  INC  DL                  ;Change To Index to a Port Number
  MOV  ES:[BX+DI],DL       ;Store it
  JMP >L90                 ;Done
L70:                       ;Error, Double-Redirect
  MOV  ExtraErrMsg,DblRedirectMsg ;Point at Extra Error Message
L75:                       ;Error
  MOV  ParseError,Yes      ;Mark as an Error
L90:                       ;Done
  POP  ES,DI,DX,BX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Assign I/O Base Address
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchIOAddress:
  PUSH AX              ;Save used registers
  CALL SkipColonEquals ;Skip Colon/Equals (if there)
  CALL GetNumber       ;If not, see if it's a number
  JC  >J70             ;If not, error
J20:                   ;Got a number
  CMP  AX,MinIOAddress ;Is it too small?
  JB  >J70             ;If so, error
  TEST AL,1Fh          ;Is it evenly divisible by 32?
  JNZ >J70             ;If not, error
  CMP  ParseTest,Yes   ;Just the Test Run?
  JE  >J90             ;If so, just quit
  MOV  ES:IOAddress,AX ;If not, store it
  JMP >J90             ;Done
J70:                   ;Error
  MOV  ParseError,Yes  ;Mark as an error
J90:                   ;Done
  POP  AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Manually Send Epson Initialization String to Printer
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchSendEpson:
  PUSH AX,BX,CX,DX,DI        ;Save used registers
  CALL GetLPT4Switch         ;Get the LPT Index (DX)
  JC  >E70                   ;If error, handle it
  OR   AH,AH                 ;Just the Test Run?
  JNZ >E90                   ;If so, just quit
  MOV  DI,EpsonInitStr       ;Point at string
  MOV  CX,EpsonInitStrSize   ;Number of Bytes in string
E10:                         ;Loop to here for each byte in string
  MOV  AL,[DI]               ;Get the next character of the string
  INC  DI                    ;Increment String Pointer for next time
  MOV  AH,I17FSendByte       ;Function = Send Character
  INT  17h                   ;Send it
  LOOP E10                   ;Keep going until we're done
  OR   StatusFlags2,DidEpson ;Mark as having done it
  JMP >E90                   ;Done
E70:                         ;Error
  MOV  ParseError,Yes        ;Mark as an Error
E90:                         ;Done
  POP  DI,DX,CX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Soft Reset
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchR:
  PUSH AX,BX,DX              ;Save used registers
  CALL GetLPT4Switch         ;Get the LPT Index (DX)
  JC  >R70                   ;If Error, Handle it
  OR   AH,AH                 ;Just the Test Run?
  JNZ >R90                   ;If so, quit
  MOV  AH,I17FInitialize     ;Function = Soft Reset/Initialize
  INT  17h                   ;Do it
  OR   StatusFlags2,DidReset ;Mark as having done a Reset
  JMP >R90                   ;Done
R70:                         ;Error
  MOV  ParseError,Yes        ;Mark as an Error
R90:                         ;Done
  POP  DX,BX,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Copy File to Printer
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchCopy:
  PUSH AX,BX,DX                 ;Save used registers
  CALL GetFileName              ;Get the FileName (FileNameBuffer)
  JZ  >C75                      ;If Error, done
  OR   AH,AH                    ;Just the Test Run?
  JZ  >C20                      ;If not, we've already tested FileNames
  CALL PrintFiles               ;If so, test for valid FileNames
  CMP  ParseError,Yes           ;Was there an error?
  JE  >C72                      ;If so, quit
C20:                            ;FileName(s) OK
  CALL GetLPT4Switch            ;Get the LPT Index (DX)
  JC  >C75                      ;If error, quit
  MOV  AH,I17FGetStatus         ;Get the
  INT  17h                      ;  Printer Status
  AND  AH,(NOT PStsACKnowledge) ;Mask out the ACKnowledge bit
  CMP  AH,PStsNormal            ;Is the status normal?
  JNE >C70                      ;If not, Error
  MOV  PrintIndex,DX            ;Store the Printer Index
  CALL PrintFiles               ;Print the File(s)
  OR   StatusFlags2,DidPrints   ;Mark us as having Printed
  JMP >C90                      ;Done
C70:                            ;Error, Invalid LPT
  MOV  ExtraErrMsg,BadLPTMsg    ;Point at bad LPT Message
  JMP >C75                      ;Continue
C72:                            ;Error, bad Filename
  MOV  ExtraErrMsg,BadFileMsg   ;Point at bad File Message
C75:                            ;Error
  MOV  ParseError,Yes           ;Mark as an Error
C90:                            ;Done
  POP  DX,BX,AX                 ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT ROUTINES FOR PARSING COMMAND LINE OPTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET A YES/NO OPTION FOR A COMMAND-LINE SWITCH
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK
;              ZF = Set if No
;                   AL = 0 (No)
;                 = Clear if Yes
;                   AL = -1 (Yes)
;            = Set if Error
;              AL = 0
;Changes:
;------------------------------------------------------------------------------
GetYesNo4Switch:
  PUSH BX,CX              ;Save used registers
  MOV  CH,AH              ;Save original AH
  CALL SkipColonEquals    ;Skip Colon/Equals (if there)
  MOV  BX,SwitchListYesNo ;Point at the list of code words
  CALL GetCode            ;See if its a match
  JNC >Y20                ;If so, jump to test it
  CALL GetNextChar        ;If not, get a single character
  JZ  >Y70                ;If end-of-line, error
  CALL Capitalize         ;Capitalize it
Y20:                      ;Got a character
  CMP  AL,'Y'             ;Is it Yes?
  JE  >Y40                ;If so, handle it
  CMP  AL,'N'             ;Is it No?
  JNE >Y70                ;If not, error
Y30:                      ;No
  XOR  AL,AL              ;If so, make it No
  JMP >Y80                ;Done
Y40:                      ;Yes
  MOV  AL,Yes             ;Mark it as a Yes
  JMP >Y80                ;Done
Y70:                      ;Error
  XOR  AL,AL              ;Set AL to 0
  STC                     ;Set Error Flag
  JMP >Y90                ;Done
Y80:                      ;OK
  OR   AL,AL              ;Set Zero Flag for Return
  CLC                     ;Set OK Flag
Y90:                      ;Done
  MOV  AH,CH              ;Restore original AH
  POP  CX,BX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A SWITCH WITH A YES/NO OPTION
;Inputs:  [SI] = Command Line Pointer
;         ES = TSR Data Area
;         DS = Local Data Area
;         AL = Bit mask to Set/Unset
;         AH = ParseTest status
;Outputs: Sets/Unsets bit in ES:TSRFlags or DS:ProgFlags as appropriate
;Changes:
;NOTES: If we are changing the resident (TSR) part of the program
;         (ES:TSRFlags), we do not actually change anything unless
;         ParseTest is set to No.  If we are changing the transient
;         part of the program (DS:ProgFlags), we change it no matter
;         what ParseTest is set to.
;       Forward and Reverse refer to Forward and Reverse Logic.  With
;         Forward Logic, if the user says Yes, we set the particular bit
;         to 1.  With Reverse Logic, when the user says Yes, we set
;         to bit to 0.
;------------------------------------------------------------------------------
DoSwitchWithYNTsrRvs:
  PUSH CX                  ;Save used registers
  MOV  CL,-1               ;Mark as Reverse Logic
  JMP >Y000                ;Jump to do ES:TSRFlags
DoSwitchWithYNTsrFwd:
  PUSH CX                  ;Save used registers
  XOR  CL,CL               ;Mark as Forward Logic
  JMP >Y000                ;Jump to do ES:TSRFlags
DoSwitchWithYNPrgRvs:
  PUSH CX                  ;Save used registers
  MOV  CL,-1               ;Mark as Reverse Logic
  JMP >Y001                ;Jump to do DS:ProgFlags
DoSwitchWithYNPrgFwd:
  PUSH CX                  ;Save used registers
  XOR  CL,CL               ;Mark as Forward Logic
  JMP >Y001                ;Jump to do DS:ProgFlags
Y000:                      ;ES:TSRFlags
  PUSH BX                  ;Save used registers
  MOV  BX,OFFSET TSRFlags  ;Point at TSR Flags
  JMP >Y00                 ;Do it
Y001:                      ;DS:ProgFlags
  PUSH BX                  ;Save used registers
  MOV  BX,OFFSET ProgFlags ;Point at TSR Flags
;  JMP >Y00                 ;Do it
Y00:
  PUSH AX                  ;Save used registers
  MOV  CH,AL               ;Save Bit Mask to set
  CALL GetYesNo4Switch     ;Get the Yes/No parameter (AL)
  JC  >Y70                 ;If error, handle it
  OR   AL,AL               ;Is it Yes?
  JNZ >Y20                 ;If so, jump to handle it
Y10:                       ;No
  OR   CL,CL               ;Is it Forward Logic?
  JZ  >Y40                 ;If so, jump to handle it
  JMP >Y50                 ;If not, jump to handle Reverse Logic
Y20:                       ;Yes
  OR   CL,CL               ;Is it Forward Logic?
  JZ  >Y50                 ;If so, jump to handle it
Y40:                       ;Unset the Bit
  NOT  CH                  ;Need to Unset
  CMP  BX,LastTSRByte      ;Is it for ProgFlags?
  JAE >Y45                 ;If so, jump to handle it
Y42:                       ;Unset ES:TSRFlags
  OR   AH,AH               ;Just the Test Run?
  JNZ >Y90                 ;If so, quit
  AND  ES:[BX],CH          ;Unset the appropriate flag
  JMP >Y90                 ;Done
Y45:                       ;Unset DS:ProgFlags
  AND  [BX],CH             ;Unset the appropriate flag
  JMP >Y90                 ;Done
Y50:                       ;Set the Bit
  CMP  BX,LastTSRByte      ;Is it for ProgFlags?
  JAE >Y55                 ;If so, jump to handle it
Y52:                       ;Set ES:TSRFlags
  OR   AH,AH               ;Just the Test Run?
  JNZ >Y90                 ;If so, quit
  OR   ES:[BX],CH          ;Set the appropriate flag
  JMP >Y90                 ;Done
Y55:                       ;Set DS:ProgFlags
  OR   [BX],CH             ;Set the appropriate flag
  JMP >Y90                 ;Done
Y70:                       ;Error
  MOV  ParseError,Yes      ;Mark as an Error
Y90:                       ;Done
  POP  AX                  ;Restore used registers
  POP  BX                  ;Restore used registers
  POP  CX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;REPLACE THE CARRIAGE RETURN AT THE END OF THE CMD LINE TAIL WITH A 0
;Inputs:  CS = DS = PSP Segment
;Outputs:
;Changes: Last Byte of Command Tail
;------------------------------------------------------------------------------
FixCmdLineCR:
  PUSH AX,CX,DI,ES   ;Save used registers
  MOV  AL,CR         ;Look for a CR
  MOV  CX,7Fh        ;Maximize Byte Counter
  MOV  ES,DS         ;Point ES:[DI]
  MOV  DI,81h        ;  at the Command Line Tail
  REPNE SCASB        ;Look for the CR
  MOV  B ES:[DI-1],0 ;Replace the CR with a 0
  POP  ES,DI,CX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT CHARACTER FROM THE ENVIRONMENT OR COMMAND LINE
;Inputs:  [SI] = Pointer (Command Line or Environment)
;Outputs: AL = The next character
;         ZF = Set if End-Of-Line (Character = ASCII 0)
;            = Clear if "real" character
;Changes: SI
;------------------------------------------------------------------------------
GetNextChar:
  PUSH DS                   ;Save used registers
  TEST ProgFlags2,DoStdIn   ;Are we doing StdIn?
  JNZ >N20                  ;If so, jumpto handleit
  TEST ProgFlags2,DoEnvir   ;Are we doing the Program Environment Variable?
  JNZ >N10                  ;If so, handle it
  CMP  CmdLineVarPointer,-1 ;Need to use the CMDLINE Environment variable?
  JE  >N90                  ;If not, just do the "real" command line
N10:                        ;Get next character from the Environment
  MOV  DS,[PSPEnvirSeg]     ;Point at the Environment Segment
  JMP >N90                  ;Continue
N20:                        ;StdIn
  MOV  DS,ExtraMemSegment   ;Point DS at the correct Segment
N90:                        ;DS:[SI] points at the next character
  LODSB                     ;Get the character from the "real" command line
  OR   AL,AL                ;Set ZF if EOL
  POP  DS                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER SPACES TO FIND THE NEXT LEGITIMATE CHARACTER, TESTING FOR EOL
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: ZF = Set if EOL
;               AL  = Unchanged
;              [SI] = End-of-Line Character
;            = Clear if not EOL
;               AL  = First non-space character
;              [SI] = Character AFTER the next non-space character
;Changes:
;------------------------------------------------------------------------------
IsSpaceOrEOX:
  CALL IsSpaceOrEOL ;Skip over the spaces
  JZ  >X90          ;If end-of-line, we're done
  CALL GetNextChar  ;If not, get the next character
  OR   AL,AL        ;Set return flag
X90:                ;Done
  RET

;------------------------------------------------------------------------------
;SKIP OVER SPACES TO FIND LEGITIMATE CHARACTERS, AND TEST FOR EOL
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: ZF = Set if EOL
;            = Clear if legitimate character
;              [SI] = The Next non-Space Character
;Changes:
;------------------------------------------------------------------------------
IsSpaceOrEOL:
  PUSH AX          ;Save used registers
L10:               ;Loop to here to skip over spaces
  CALL GetNextChar ;Get the next character
  CMP  AL,' '      ;Is it a space?
  JE   L10         ;If so, get the next character
  CMP  AL,Tab      ;Is it a Tab?
  JE   L10         ;If so, get the next character
  DEC  SI          ;If not, point back at the character
  OR   AL,AL       ;Set EOL flag
  POP  AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER A COLON OR EQUALS, IF THERE
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: CF = Clear if Colon or Equals was found (and skipped)
;              [SI] = First non-Space Character after the Colon/Equals
;            = Set if No Colon or Equals was found
;              [SI] = First non-Space Character after where we were looking
;Changes:
;------------------------------------------------------------------------------
SkipColonEquals:
  PUSH AX           ;Save used registers
  CALL IsSpaceOrEOX ;Skip over the Spaces
  JZ  >Q75          ;If End-of-Line, nothing to get
  CMP  AL,':'       ;Is it a Colon?
  JE  >Q80          ;If so, we're done
  CMP  AL,'='       ;Is it an equals?
  JE  >Q80          ;If so, we're done
Q70:                ;No Colon/Equals Found
  DEC  SI           ;Point back at the character
Q75:                ;[SI] correct
  STC               ;Set return flag
  JMP >Q90          ;Done
Q80:                ;Colon/Equals Found
  CALL IsSpaceOrEOL ;Go to the next character
  CLC               ;Set return flag
Q90:                ;Done
  POP  AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A CODE WORD FROM THE COMMAND LINE TO A BYTE FROM THE LOOKUP TABLE
;Inputs:  DS:[SI] = Command Line Pointer
;         DS:[BX] = List to Test
;Outputs: CF = Clear if a match was found
;              AL = Entry from Table
;              [SI] = Next character after the Code Match
;         CF = Set if no match found (error)
;              AL = Unchanged
;              SI = Unchanged
;Changes: SI if valid match found
;------------------------------------------------------------------------------
GetCode:
  PUSH BX,DX         ;Save used registers
  MOV  DX,AX         ;Save AX in case there's no match
C10:                 ;Loop to here for each list of words
  CMP  B [BX],0      ;Are we at the end of our table?
  JE  >C80           ;If so, we couldn't find a match
  XOR  AH,AH         ;Assume it's a match
  PUSH SI            ;Save our command line pointer for a second
C20:                 ;Loop to here for each character in a word
  CALL GetNextChar   ;Get the next character
  CALL Capitalize    ;Capitalize it
  CALL CmpALBXNoCase ;Is it a match?
  JZ  >C30           ;If so, handle it
  INC  AH            ;If not, mark us as no match
C30:                 ;The character is tested
  INC  BX            ;Point at the next character in our test word
  CMP  B [BX],0      ;Are we at the end of the word?
  JNE  C20           ;If not, keep going until we're done
  INC  BX            ;Point at the next word or code list
  OR   AH,AH         ;Was it a match?
  JZ  >C50           ;If so, jump to handle it
  POP  SI            ;If not, restore our command line pointer
  CMP  B [BX],0      ;Is this the end of our word list?
  JNE  C10           ;If not, just test the next word
  INC  BX,2          ;If so, skip over the codes
  JMP  C10           ;Keep going until we're done with our list
C50:                 ;We've found a match!
  POP  AX            ;Lose our original command line pointer
  DEC  BX            ;Point back at the end-of-word marker
C60:                 ;Loop to here to find the end-of-list
  MOV  AX,[BX]       ;Get the next two characters in our list
  INC  BX            ;Point at the next character for next time
  OR   AX,AX         ;Is this the start of our code list?
  JNE  C60           ;If not, keep looking
  INC  BX            ;If so, point at the character we're looking for
  MOV  DL,[BX]       ;Get the character from the table
  CLC                ;Mark our OK flag
  JMP >C90           ;And we're done
C80:                 ;No match found
  STC                ;Mark us as no match
C90:                 ;We're done
  MOV  AX,DX         ;Set AX to the correct value
  POP  DX,BX         ;Restore used registers
  RET

CmpALBXNoCase:
  PUSH AX         ;Save used registers
  CALL Capitalize ;Capitalize AL
  MOV  AH,AL      ;Store it in AH
  MOV  AL,[BX]    ;Get [BX]
  CALL Capitalize ;Capitalize it
  CMP  AL,AH      ;Compare AL & [BX]
  POP  AX         ;Restore used registers
  RET

;;------------------------------------------------------------------------------
;;TEST AND SEE IF A PRINTER IS ATTACHED TO AN LPT INDEX
;;Inputs:  DX = LPT Index to test
;;Outputs: ZF = Set if OK (a printer is attached, on-line, and not in error)
;;            = Clear if Error (No Printer, or Printer in Error)
;;Changes:
;;------------------------------------------------------------------------------
;TestDXPrinter:
;  PUSH AX,BX,DX         ;Save used registers
;  MOV  AH,I17FGetStatus ;Function = Get Status
;  INT  17h              ;Do it
;  CMP  AH,PStsNormal    ;Set return flag
;  POP  DX,BX,AX         ;Restore used registers
;  RET

;------------------------------------------------------------------------------
;GET POINTER (ES:[DI]) TO THE REDIRECT TABLE
;Inputs:  ES = Our TSR Data Area
;Outputs: ES:[DI] = Pointer to Redirect Table
;Changes:
;NOTES: This may change ES, if we are not the Owner of the Redirect Table!
;------------------------------------------------------------------------------
GetRedirTblAddrESDI:
  PUSH AX,BX,CX,DX      ;Save used registers
  MOV  AX,(1B00h+I17FGetRedirTblAddr) ;Function = Get Table Address
  MOV  DX,-1            ;Set register value
  INT  17h              ;Do it
  OR   AX,AX            ;Did it work?
  JNZ >A30              ;If not, point at our Table
  MOV  ES,CX            ;Point ES at the Segment
  MOV  DI,BX            ;Point DI at the Offset
  JMP >A90              ;Done
A30:                    ;Need to use our Table
  MOV  DI,RedirectTable ;Point at our Table
A90:                    ;Done
  POP  DX,CX,BX,AX      ;Restore used registers
  RET

;;------------------------------------------------------------------------------
;;CONVERT TIMER TICKS TO SECONDS
;;Inputs:  AX = Number of Timer Ticks
;;Outputs: AX = Number of Seconds (0-255)
;;Changes:
;;NOTES: This simply returns the truncated number of whole seconds, leaving
;;         out the number of partial seconds.
;;       In this particular program, AH should always be 0 on return
;;         since we are always dealing with delays of 255 seconds or less.
;;------------------------------------------------------------------------------
;ConvertTicks2Seconds:
;  PUSH BX,DX    ;Save used registers
;  OR   AX,AX    ;Is it 0?
;  JZ  >T90      ;If so, we're done
;  DEC  AX       ;Subtract 1
;  MOV  BX,1000  ;Divide
;  MUL  BX       ;  by
;  MOV  BX,18206 ;  18.206
;  DIV  BX       ;  (ticks per second)
;  CMP  DX,9103  ;Need to round up?
;  JB  >T90      ;If not, we're done
;  INC  AL       ;If so, round up
;T90:            ;Done
;  POP  DX,BX    ;Restore used registers
;  RET

;------------------------------------------------------------------------------
;GET AN LPT NUMBER FOR A COMMAND-LINE SWITCH
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK
;              DX = LPT Index (0-127, as used by Int 17h Functions)
;            = Set if Error
;              DX = -1
;Changes:
;------------------------------------------------------------------------------
GetLPT4Switch:
  PUSH AX,BX           ;Save used registers
  CALL SkipColonEquals ;Skip Colon/Equals (if there)
  CALL GetLPTNum       ;Get the LPT Number (DX)
  JNZ >L80             ;If OK, we're done
  CALL GetDecimal      ;If not, see if it's a number
  JC  >L70             ;If not, error
L20:                   ;Got a number
  OR   AX,AX           ;Is it too small?
  JZ  >L70             ;If so, error
  CMP  AX,MaxPrinters  ;Is it too big?
  JA  >L70             ;If so, error
  MOV  DX,AX           ;Put Port Index
  DEC  DX              ;  in DX
  JMP >L80             ;Done
L70:                   ;Error
  MOV  DX,-1           ;Set DX to Invalid Number
  STC                  ;Set Error Flag
  JMP >L90             ;Done
L80:                   ;OK
  CLC                  ;Set OK Flag
L90:                   ;Done
  POP  BX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET AN LPT NUMBER FROM THE COMMAND LINE
;Inputs:  SI = Command-line Pointer
;Outputs: ZF = Clear if OK
;                DX = LPT Index
;              Set if Error
;                DX = -1
;         ParseError = Yes if appropriate
;Changes: SI
;------------------------------------------------------------------------------
GetLPTNum:
  PUSH AX             ;Save used registers
  MOV  DX,-1          ;Assume Error
  CALL IsSpaceOrEOX   ;Get the Next character
  JZ  >N90            ;If EOL, Error
  CALL Capitalize     ;Capitalize it
  CMP  AL,'P'         ;Possible PRN?
  JNE >N30            ;If not, handle possible LPT
  CALL GetNextChar    ;Is the
  CALL Capitalize     ;  next character
  CMP  AL,'R'         ;  an R?
  JNE >N70            ;If not, Error
  CALL GetNextChar    ;Is the
  CALL Capitalize     ;  next character
  CMP  AL,'N'         ;  an N?
  JNE >N70            ;If not, Error
  XOR  DX,DX          ;If so, it's LPT1
  JMP >N50            ;Look for a Colon
N30:                  ;Possible LPT
  CMP  AL,'L'         ;L?
  JNE >N80            ;If not, we're done
  CALL GetNextChar    ;Is the
  CALL Capitalize     ;  next character
  CMP  AL,'P'         ;  an P?
  JNE >N70            ;If not, Error
  CALL GetNextChar    ;Is the
  CALL Capitalize     ;  next character
  CMP  AL,'T'         ;  an T?
  JNE >N70            ;If not, Error
  CALL GetNextChar    ;Get the next character
  CALL IsNumber       ;Is it a Number?
  JC  >N70            ;If not, error
  OR   AL,AL          ;Is it 0?
  JZ  >N70            ;If so, Error
  DEC  SI             ;If OK, point back at the Number
  CALL GetDecimal     ;Get the Number
  CMP  AX,MaxPrinters ;Is it too big?
  JA  >N70            ;If so, Error
  MOV  DX,AX          ;If OK, store
  DEC  DX             ;  the LPT Number
N50:                  ;Look for a Colon
  CALL GetNextChar    ;Get the next character
  CMP  AL,':'         ;Is it a Colon?
  JE  >N90            ;If so, we're done
  JMP >N80            ;If not, point back at the character
N70:                  ;Error!
  MOV  ParseError,Yes ;Mark as an Error
  JMP >N90            ;Done
N80:                  ;Done, need to point back at character
  DEC  SI             ;Point back at the previous character
N90:                  ;Done
  CMP  DX,-1          ;Set return flag
  POP  AX             ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO GET A NUMBER FROM A STRING (HEX OR DECIMAL)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET A NUMBER FROM A STRING (CAN BE DECIMAL OR HEX)
;Inputs:  [SI] = String Pointer
;Outputs: CF = Clear if we got a valid number
;              AX = Number
;            = Set if Error (no number found)
;              AX = 0
;Changes: SI points at next byte after the number
;NOTES: A Hex String must start with '0x' and/or end in 'H'!
;------------------------------------------------------------------------------
GetNumber:
  CALL IsSpaceOrEOL ;Skip past spaces
  JZ  >N70          ;If End-of-Line, Error
  CALL TestForHex   ;Is it a Hex Number?
  JC  >N20          ;If not, try a decimal
  CALL Test0xPrefix ;Skip over the 0x (C-style) prefix, if there
  CALL GetHex       ;If so, get it
  JNC >N80          ;If OK, we're done
  JMP >N70          ;If not, Error
N20:                ;Not Hex
  CALL GetDecimal   ;Try a Decimal
  JNC >N80          ;If OK, we're done
N70:                ;Error
  DEC  SI           ;Point back at the first character
  STC               ;Set Error Flag
  JMP >N90          ;Done
N80:                ;OK
  CLC               ;Set OK Flag
N90:                ;Done
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII STRING TO SEE IF IT IS A HEX STRING (ENDS IN H)
;Inputs:  [SI] = String to test
;Outputs: CF = Clear if it is a Hex String
;            = Set if Error (not a Hex String)
;Changes:
;NOTES: A valid Hex String will contain numerals 0-9, A-F, and Underscores,
;         and will end in an H.  It cannot contain spaces.
;------------------------------------------------------------------------------
TestForHex:
  PUSH AX,SI        ;Save used registers
  CALL Test0xPrefix ;Test for the 0x (C-style) prefix (changes SI)
  JNC >H80          ;If so, it's Hex
  CALL GetNextChar  ;Get the
  DEC  SI           ;  first character
  CALL IsHexNumber  ;A valid Hex Number?
  JC  >H70          ;If not, Error
H40:                ;Loop to here for each character
  CALL GetNextChar  ;Get the next character
  CALL IsHexNumber  ;A valid Hex Number?
  JNC  H40          ;If so, keep looking
  CMP  AL,'_'       ;An Underscore?
  JZ   H40          ;If so, keep looking
  CALL IsHexEnd     ;End of the Hex Number?
  JZ  >H80          ;If so, we're done
H70:                ;Not Hex
  STC               ;Set error Flag
  JMP >H90          ;Done
H80:                ;Is Hex
  CLC               ;Set OK Flag
H90:                ;Done
  POP  SI,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST FOR A 0x (C-STYLE) HEX PREFIX
;Inputs:  [SI] = String to test
;Outputs: CF = Set if not a 0x Prefix
;              SI unchanged
;            = Clear if not a 0x Prefix
;              [SI] = Character after the 0x
;Changes:
;------------------------------------------------------------------------------
Test0xPrefix:
  PUSH AX,BX       ;Save used registers
  MOV  BX,SI       ;Save original Pointer
  CALL GetNextChar ;Get the next character
  CMP  AL,'0'      ;Is it a 0?
  JNE >X70         ;If not, it's not a Prefix
X20:               ;Loop to here to skip over all zeroes
  CALL GetNextChar ;Get the next charcter
  CMP  AL,'0'      ;Is it another 0?
  JE   X20         ;If so, keep skipping the zeroes
  CALL Capitalize  ;If not, capitalize it
  CMP  AL,'X'      ;Is it an X?
  JNE >X70         ;If not, it's not a 0x Prefix
  CALL GetNextChar ;Get the next charcter
  CALL IsHexNumber ;Is it a Hex Number?
  JNC >X80         ;If so, it's a 0x Prefix
X70:               ;Not a 0x Prefix
  MOV  SI,BX       ;Restore original pointer
  STC              ;Set return flag
  JMP >X90         ;Done
X80:               ;Is a 0x Prefix
  DEC  SI          ;Point back at the first hex number
  CLC              ;Set return flag
X90:               ;Done
  POP  BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT SERIES OF HEX CHARACTERS, AND CONVERT THEM TO A NUMBER
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK
;              AX = Character string converted to a number, ?? if not
;            = Set if Error
;              AX = Unchanged
;Changes:
;NOTES: The string can either have an H at the end or not, and this code
;         will work.
;------------------------------------------------------------------------------
GetHex:
  PUSH BX,CX,DX     ;Save used registers
  MOV  DX,AX        ;Save original AX
  XOR  BX,BX        ;Start with zero
  MOV  CX,4         ;CL = bits to shift by, CH = Character Counter
  XOR  AH,AH        ;Set High byte to 0
D10:                ;Loop to here for each character
  CALL GetNextChar  ;Get the next character
  CALL IsHexNumber  ;A valid Hex Number?
  JNC >D20          ;If so, continue
  CMP  AL,'_'       ;If no, is it an Underscore?
  JE  >D45          ;If so, keep looking
  JMP >D50          ;If not, we're done
D20:                ;Valid Hex Number
  INC  CH           ;Increment the character counter
  SHL  BX,CL        ;Make room for the New Nibble
  JNC >D40          ;If we're not too big yet, keep going
  DEC  SI           ;If too big, Point back at bad character
  JMP >D70          ;Error
D40:                ;OK to add in new Nibble
  ADD  BX,AX        ;Add in the new Nibble
D45:                ;Done with this character
  JMP  D10          ;Jump to get next character
D50:                ;Done getting string
  DEC  SI           ;Point back at the bad character
  OR   CH,CH        ;Any valid characters at all?
  JZ  >D70          ;If not, error
  CALL GetNextChar  ;Is the next character
  CALL IsHexEnd     ;  an H?
  JZ  >D80          ;If so, we're done
  DEC  SI           ;If not, point back at the non-H
  JMP >D80          ;Done
D70:                ;There was an error
  MOV  AX,DX        ;Restore original AX
  STC               ;Mark the error flag
  JMP >D90          ;And quit
D80:                ;We have a good number
  MOV  AX,BX        ;Put the value where it belongs
  CLC               ;Mark the OK flag
D90:                ;We're done
  POP  DX,CX,BX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT SERIES OF NUMERIC CHARACTERS, AND CONVERT THEM TO A NUMBER
;Inputs:  [SI] = Command Line Pointer
;Outputs: AX = decimal character string converted to a number, ?? if not
;         CF = Clear if AX is OK
;            = Set if no decimal found
;Changes: SI points at character after the number
;------------------------------------------------------------------------------
GetDecimal:
  PUSH BX,CX,DX     ;Save used registers
  XOR  AX,AX        ;Start with zero
  XOR  BX,BX        ;  "    "    "   - accumulator
  MOV  CX,10        ;CX = multiplier & digit limit comparer
  CALL IsSpaceOrEOX ;Skip over the spaces
  JZ  >D70          ;If EOL, Error
  SUB  AL,'0'       ;If not, convert it to a number
  CMP  AL,9         ;Is it really a number?
  JA  >D70          ;If not, there's an error
  DEC  SI           ;If so, step back to the number
D10:                ;Loop to here for each character
  CALL GetNextChar  ;Get the next character
  SUB  AL,'0'       ;Change it to 0-9 range
  XOR  AH,AH        ;Extend byte to word
  CMP  AX,CX        ;Is it a digit?
  JAE >D80          ;If not, we're done
  CMP  BX,6553      ;Is our number getting too big?
  JB  >D20          ;If not, jump to store it
  CMP  AL,5         ;If so, will this number make it too big?
  JA  >D70          ;If so, there's an error
D20:                ;Add the digit to our number
  XCHG AX,BX        ;Swap accumulation into AX, new digit into BX
  MUL  CX           ;Multiply the previous accumulation by 10
  ADD  BX,AX        ;Add in the new digit
  JMP  D10          ;Jump to get next character
D70:                ;There was an error
  STC               ;Mark the error flag
  JMP >D90          ;And quit
D80:                ;We have a good number
  DEC  SI           ;Point back at the non-number
  MOV  AX,BX        ;Put the value where it belongs
  CLC               ;Mark the OK flag
D90:                ;We're done
  POP  DX,CX,BX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A HEX NUMERAL (BETWEEN 0 AND F)
;Inputs:  AL = ASCII Character to Test
;Outputs: CF = Clear if it is a Number
;              AL = ASCII Code converted to a real Number
;            = Set if Error (not a Number)
;              AL = Unchanged
;Changes:
;------------------------------------------------------------------------------
IsHexNumber:
  PUSH BX          ;Save used registers
  MOV  BL,AL       ;Save the character in case we need to restore it
  CALL IsNumber    ;A Decimal Number?
  JNC >H85         ;If so, we're done
  CALL Capitalize  ;If not, Capitalize it
  CMP  AL,'A'      ;A Hex Number?
  JB  >H70         ;If not, Error
  CMP  AL,'F'      ;A Hex Number?
  JBE >H80         ;If so, handle it
H70:               ;Not a Number
  MOV  AL,BL       ;Restore original character
  STC              ;Set Error Flag
  JMP >H90         ;Done
H80:               ;A Number > 9
  SUB  AL,('A'-10) ;Convert it to a real number
  JMP >H90         ;Done
H85:               ;OK (is a Number)
  CLC              ;Set OK Flag
H90:               ;Done
  POP  BX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A NUMERAL (BETWEEN 0 AND 9)
;Inputs:  AL = ASCII Character to Test
;Outputs: CF = Clear if it is a Number
;              AL = ASCII Code converted to a real Number
;            = Set if Error (not a Number)
;              AL = Unchanged
;Changes:
;------------------------------------------------------------------------------
IsNumber:
  CMP  AL,'0' ;A Number?
  JB  >N70    ;If not, Error
  CMP  AL,'9' ;A Number?
  JBE >N80    ;If so, handle it
N70:          ;Not a Number
  STC         ;Set Error Flag
  JMP >N90    ;Done
N80:          ;A number
  SUB  AL,'0' ;Convert it to a real number
  CLC         ;Set OK Flag
N90:          ;Done
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A PARTICULAR CHARACTER
;Inputs:  AL = ASCII Character to Test
;Outputs: ZF = Set if it is the appropriate character
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
IsHexEnd:
  PUSH AX         ;Save used registers
  CALL Capitalize ;Capitalize the Character
  CMP  AL,'H'     ;See if it matches
  POP  AX         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE THE TELL THE USER WHERE THE COMMAND LINE ERROR OCCURRED
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE THE COMMAND LINE OR ENVIRONMENT ERROR INFORMATION TO THE SCREEN
;Inputs:  [SI] = Command line Pointer (if Command Line)
;              = StdIn Buffer Pointer (if StdIn String)
;              = Environment Pointer (if Environment Variable)
;         ProgFlags2.DoEnvir, DoStdIn
;Outputs:
;Changes: Writes information to screen
;------------------------------------------------------------------------------
WriteCmdErr:
  PUSH AX,BX,CX,DX        ;Save used registers
  PUSH DI,SI,BP           ;Save used registers
  CALL FindBadChar        ;Find the actual bad character in the string (SI)
  CALL SetupCmdErrStrings ;Set up the String Pointers and Sizes
                          ;DI:[AX] = Command Line String
                          ;DS:[BX] = Program name at beginning of String
                          ;    CX  = Size of BX String
                          ;DS:[DX] = Header String
                          ;DS:[BP] = Footer String
  CALL WriteZErr          ;Write the Header
  CALL WriteCrLfErr       ;Move
  CALL WriteCrLfErr       ;  down
  SUB  SI,AX              ;Calculate the number
  ADD  CX,SI              ;  of spaces
  DEC  CX                 ;  to write
  CALL WriteCmdString     ;Write the Command-line String (may modify CX)
  CALL WriteCrLfErr       ;Move down
  MOV  B SingleMsg[0],' ' ;Want to write spaces
  MOV  DX,SingleMsg       ;Point at the string
E60:                      ;Loop to here to write each space (number in CX)
  CALL WriteZErr          ;Write the space
  LOOP E60                ;Keep writing them until we're done
  MOV  DX,ParseErrMsg     ;Write the Pointer Part
  CALL WriteZErr          ;  of the Error Message
  MOV  DX,ExtraErrMsg     ;Point at the Extra Error Message (if there is one)
  OR   DX,DX              ;Is there a message?
  JZ  >E90                ;If not, quit
  CALL WriteZErr          ;If so, write it
  CALL WriteCrLfErr       ;Move down
  CALL WriteCrLfErr       ;Move down
E90:                      ;Done
  MOV  DX,BP              ;Write the last part
  CALL WriteZErr          ;  of the message
  POP  BP,SI,DI           ;Restore used registers
  POP  DX,CX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GO BACKWARDS IN AN ERRORED OPTION STRING TO INDICATE TO USER WHERE ERROR WAS
;Inputs:  SI = Option String Pointer (Environment, StdIn, or Command Line)
;                where error was found
;Outputs: SI = Options String Pointer, adjusted to point at a "Real" character
;Changes:
;------------------------------------------------------------------------------
FindBadChar:
  PUSH AX          ;Save used registers
  DEC  SI          ;Go back 1 character to start
B10:               ;Loop to here to find a legitimate character
  CALL GetNextChar ;Get the character
  JZ  >B40         ;If end-of-line, keep going back
  CMP  AL,' '      ;Is it a space?
  JNE >B90         ;If not, we're done
B40:               ;Need to keep going back
  SUB  SI,2        ;Go back to the previous character
  JMP  B10         ;Keep looking
B90:               ;Done
  POP  AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SET UP THE STRING POINTERS AND SIZES TO BE ABLE TO WRITE THE COMMAND ERROR
;Inputs:  DS = Local Data Area
;Outputs: DI:[AX] = Command-line String to write
;         DS:[DX] = First Error Message (Header) to write
;         DS:[BX] = Second message to write (first part of Command string)
;             CX  = Number of Bytes to add to String Size
;         DS:[BP] = Third message to write (Footer)
;Changes:
;------------------------------------------------------------------------------
SetupCmdErrStrings:
  TEST ProgFlags2,DoEnvir   ;Working with the Environment?
  JNZ >S40                  ;If so, handle it
  TEST ProgFlags2,DoStdIn   ;Working with StdIn?
  JNZ >S50                  ;If so, handle it
S10:                        ;Command Line
  MOV  AX,81h               ;DI:[AX] =
  MOV  DI,DS                ;  Command-line Tail
  MOV  BX,RealName          ;DS:[BX] = Program Name
  MOV  CX,RealNameSz        ;CX = Size of [BX] String
  CMP  CmdLineVarPointer,-1 ;Real Command Line?
  JE  >S30                  ;If so, continue
S20:                        ;CMDLINE Environment Variable
  MOV  DI,[PSPEnvirSeg]     ;DI:[AX] =
  MOV  AX,CmdLineVarPointer ;  CMDLINE
  SUB  AX,CmdLineVarSize    ;  Environment Variable
S30:                        ;Have Command-line parameters set up
  MOV  DX,ParseCmdMsg       ;DS:[DX] = Header String
  MOV  BP,ParseErrMsg2      ;DS:[BP] = Footer String
  JMP >S90                  ;Done
S40:                        ;Environment
  MOV  DI,[PSPEnvirSeg]     ;DI:[AX] =
  MOV  AX,EnvVarPointer     ;  USBKEYB
  SUB  AX,EnvVarSize        ;  Environment Variable
  MOV  BX,NoMsg             ;DS:[BX] = Second message to write
  XOR  CX,CX                ;CX = Size of [BX] String
  MOV  DX,ParseEnvMsg       ;DS:[DX] = Header String
  MOV  BP,ParseEnvMsg2      ;DS:[BP] = Footer String
  JMP >S90                  ;Done
S50:                        ;StdIn
  MOV  DI,ExtraMemSegment   ;DI:[AX] =
  XOR  AX,AX                ;  StdIn Buffer
  MOV  BX,NoMsg             ;DS:[BX] = Second message to write
  XOR  CX,CX                ;CX = Size of [BX] String
  MOV  DX,ParseStdInMsg     ;DS:[DX] = Header String
  MOV  BP,ParseErrMsg2      ;DS:[BP] = Footer String
S90:                        ;Done
  RET

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF THE COMMAND STRING, WITH MORE MESSAGES AS NEEDED
;Inputs:  CS = DS = Local Data Area
;         DS:[BX] = First String to write (may not be needed!)
;         DI:[AX] = Second String (main part) to write
;             CX  = Number of Spaces to write at beginning (if normal)
;Outputs: CX = Adjusted number of spaces to write
;Changes:
;------------------------------------------------------------------------------
WriteCmdString:
  PUSH AX,BX,DX,DI,SI      ;Save used registers
  PUSH BP,DS,ES            ;Save used registers
  MOV  BP,CX               ;Save the original Space Counter in BP
  MOV  ES,DI               ;Save the second string Pointer
  MOV  SI,AX               ;  in ES:[SI]
  MOV  DX,BX               ;Save the length
  CALL CalcStrSizeDX       ;  of the first string
  MOV  DI,CX               ;  in DI
  MOV  DS,ES               ;Save the length
  CALL CalcStrSizeSI       ;  of the second string
  MOV  AX,CX               ;  in AX
  CMP  BP,70               ;Are there too many spaces to fit on one line?
  JBE >G20                 ;If not, continue
G10:                       ;Need to lop off the beginning
  SUB  BP,DI               ;We will not be
  XOR  DI,DI               ;  writing the
  MOV  BX,NoMsg            ;  first string
  CMP  BP,70               ;Are there still too many spaces to fit?
  JBE >G20                 ;If not, continue
  MOV  BX,MoreLeftMsg      ;Point at the More Message
  ADD  BP,MoreMsgSize      ;Compensate number of spaces for More Message
  MOV  DI,60               ;We want the number of spaces to be 60
  SUB  DI,BP               ;Calculate how far into the Second string
  NEG  DI                  ;  we need to start to accomplish that
  MOV  BP,59               ;BP = New Number of Spaces
  ADD  SI,DI               ;  where we need to start writing
  SUB  AX,DI               ;  of second string
  MOV  DI,MoreMsgSize      ;DI = Size of new first string (More Message)
G20:                       ;Beginning of line is accounted for
  MOV  DS,CS               ;Write the
  MOV  DX,BX               ;  first
  CALL WriteZErr           ;  string
  MOV  DS,ES               ;Point DS:[DX] at the
  MOV  DX,SI               ;  second string
  ADD  DI,AX               ;Calculate total length of both strings
  CMP  DI,79               ;Will it fit on one line?
  JBE >G40                 ;If so, continue
  MOV  BX,(80-MoreMsgSize) ;Calculate how many characters
  SUB  BX,DI               ;  of the second string
  ADD  BX,AX               ;  we need to write
  MOV  AL,[SI+BX]          ;Save the old character in the string
  MOV  B [SI+BX],0         ;Convert it to an end-of-string character
  CALL WriteZErr           ;Write the truncated string
  MOV  [SI+BX],AL          ;Restore the original character of the string
  MOV  DS,CS               ;Write the
  MOV  DX,MoreRightMsg     ;  More Message
G40:                       ;Write last message
  CALL WriteZErr           ;Write it
G90:                       ;Done
  MOV  CX,BP               ;Return CX = number of spaces to write
  POP  ES,DS,BP            ;Restore used registers
  POP  SI,DI,DX,BX,AX      ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;MISCELLANEOUS COMMAND-LINE RELATED STUFF
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET OUR REAL PROGRAM NAME
;Inputs:
;Outputs: RealName, RealNameSz
;Changes:
;------------------------------------------------------------------------------
GetRealName:
  PUSH AX,CX,DI,SI      ;Save used registers
  PUSH DS,ES            ;Save used registers
  MOV  DS,[PSPEnvirSeg] ;Point DS and ES
  MOV  ES,DS            ;  at the environment segment
  XOR  DI,DI            ;Point at the beginning of Environment variable list
  MOV  CX,-1            ;Max out the count limiter
  XOR  AX,AX            ;Need to look for a double 0
N10:                    ;Loop to here to skip over environment variables
  REPNE SCASB           ;Look for the end of this environment variable
  CMP  B [DI],0         ;Is it the end of the variable list (double zero)?
  JNE  N10              ;If not, keep skipping over environment variables
  CMP  W [DI+1],0       ;If so, is there at least one string after the env?
  JE  >N90              ;If not, we're done
  LEA  SI,[DI+3]        ;If so, point DS:[SI] at the True Name
  MOV  ES,CS            ;Point ES (for ES:[DI]) at our local data
N20:                    ;Loop to here to skip over drive/path info
  MOV  DI,RealName      ;Point at the beginning of our data area
  XOR  CX,CX            ;Start the length counter at 0
N30:                    ;Loop to here for each character in the name
  LODSB                 ;Get the next character of the name
  CMP  AL,'.'           ;Is it a dot?
  JE  >N40              ;If so, we may have the name
  CMP  AL,BackSlash     ;Is it a path separator?
  JE   N20              ;If so, start looking for the name again
  CALL Capitalize       ;If part of a name, capitalize the character
  STOSB                 ;Store it in our data area
  INC  CX               ;Increment the size counter
  JMP  N30              ;And keep looking for more characters
N40:                    ;We may have the name
  LODSB                 ;Get the next character of the name
  OR   AL,AL            ;End of the name?
  JZ  >N50              ;If so, it really was our program name
  CMP  AL,BackSlash     ;Was it a Directory with a dotted name?
  JE   N20              ;If so, keep looking for a file name
  JMP  N40              ;If not, keep looking for the end of the name
N50:                    ;Have the name
  XOR  AL,AL            ;Store
  STOSB                 ;  a 0
  MOV  CS:RealNameSz,CX ;Store the Size
N90:                    ;We're done
  POP  ES,DS            ;Restore used registers
  POP  SI,DI,CX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE POINTERS TO THE ENVIRONMENT VARIABLES WE NEED
;Inputs:  CS = DS = Local Data Area (also PSP Data Area)
;Outputs: Various Environment Pointers
;Changes:
;------------------------------------------------------------------------------
GetEnvVars:
  PUSH BX,CX,SI                    ;Save used registers
  MOV  SI,PathVarString1           ;Get
  MOV  BX,OFFSET PathVarPointer    ;  the
  MOV  CX,PathVarSize              ;  PATH
  CALL GetEnvVarPointer            ;  Pointer
  JNZ >V20                         ;If OK, continue
  MOV  SI,PathVarString2           ;If no, try
  CALL GetEnvVarPointer            ;  "Path" instead of "PATH"
V20:                               ;Get Program Variable
  MOV  SI,EnvVarString             ;Get
  MOV  BX,OFFSET EnvVarPointer     ;  our
  MOV  CX,EnvVarSize               ;  Program Variable
  CALL GetEnvVarPointer            ;  Pointer
V50:                               ;Get CMDLINE string
  CMP  B [80h],7Eh                 ;Is command line size maxed out?
  JB  >V90                         ;If not, don't worry about CMDLINE Env Var
  MOV  SI,CmdLineVarString         ;Get
  MOV  BX,OFFSET CmdLineVarPointer ;  the
  MOV  CX,CmdLineVarSize           ;  CMDLINE
  CALL GetEnvVarPointer            ;  Pointer
  CALL AdjustCmdLine               ;Compensate CMDLINE Pointer for Program Name
V90:                               ;Done
  POP  SI,CX,BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE POINTER TO AN ENVIRONMENT VARIABLE
;Inputs:   CS = DS = Local Data Area (also contains PSP)
;         [BX] = Where to store the Pointer at
;          CX  = Length of String
;         [SI] = Environment Variable String to Look for (ends in =)
;Outputs: ZF = Set if Error (Variable not found)
;               [BX] = -1
;             = Clear if OK (variable was found)
;               [BX] = Pointer to String (in Environment Segment, NOT PSP!!)
;Changes:
;------------------------------------------------------------------------------
GetEnvVarPointer:
  PUSH AX,CX,SI,BP      ;Save used registers
  PUSH DS,ES            ;Save used registers
  MOV  W [BX],-1        ;Default = -1 (does not exist)
  MOV  ES,[PSPEnvirSeg] ;ES:[DI] =
  XOR  DI,DI            ;  Environment Variable List
  MOV  DX,CX            ;Save the Size
  MOV  BP,SI            ;Save the original Pointer
  XOR  AL,AL            ;Need to look for 0's
V10:                    ;Loop to here for each Environment variable
  MOV  CX,DX            ;CX = Number of bytes to test
  MOV  SI,BP            ;DS:[SI] = String to Test for
  REPE CMPSB            ;Is it a match?
  JZ   >V30             ;If so, continue
  MOV  CX,-1            ;Max out the count limiter
  REPNE SCASB           ;Look for the end of this environment variable
  CMP  B ES:[DI],AL     ;End of Environment?
  JNE  V10              ;If not, keep looking
  JMP >V90              ;If so, no variable
V30:                    ;Found it!
  MOV  [BX],DI          ;Store the Pointer
V90:                    ;Done
  CMP  W [BX],-1        ;Set return flag
  POP  ES,DS            ;Restore used registers
  POP  BP,SI,CX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADJUST THE CMDLINE ENVIRONMENT VARIABLE POINT TO POINT AT THE COMMAND TAIL
;Inputs:  DS = Local Data Area (and PSP Segment)
;         CmdLineVarPtr (-1 if does not exist)
;           Unadjusted for Program Path/Name
;Outputs: CmdLineVarPtr
;           Adjusted (Program Path/Name skipped over to leave Command Tail)
;Changes:
;NOTES: The CMDLINE environment variable, which is only set by SOME
;         versions of DOS, contains the entire contents of the command
;         line.  The "entire contents" includes our executable file name
;         (including the path, if it was provided), but does not include
;         the redirection and/or piping parameters.
;       This routine skips over the executable file name part and simply
;         points at the command tail (the "Options" part of the command line).
;       The CMDLINE variable is used by some versions of DOS (such as 4DOS/NDOS
;         and DOS 95) to allow the command-line to be longer than the 126
;         characters normally allowed by DOS.
;------------------------------------------------------------------------------
AdjustCmdLine:
  PUSH AX,DX,SI,DS             ;Save used registers
  MOV  SI,CmdLineVarPointer    ;[SI] = CMDLINE environment variable contents
  CMP  SI,-1                   ;Anything there?
  JE  >J90                     ;If not, no need for changes
  MOV  DL,"/"                  ;Assume Get SwitchChar function is unsupported
  MOV  AX,3700h                ;Function 3700h (Get DOS SwitchChar)
  INT  21h                     ;Do it (returns DL)
  MOV  DS,[PSPEnvirSeg]        ;DS:[SI] = CMDLINE contents
J10:                           ;Loop to here to skip initial spaces & tabs
  LODSB                        ;Get the next character
  CMP  AL,' '                  ;Space?
  JE   J10                     ;If so, keep skipping
  CMP  AL,Tab                  ;Tab?
  JE   J10                     ;If so, keep skipping
J20:                           ;Skipped initial Tabs & Spaces
  DEC  SI                      ;Point back at the first character
  XOR  AH,AH                   ;Assume no quotes
  CMP  AL,Quote2               ;Double Quote (part of LFN Path & File Name)?
  JNE >J30                     ;If not, continue
  MOV  AH,AL                   ;If so, mark as a quote
  INC  SI                      ;Update the Pointer
J30:                           ;Loop to here for each character
  LODSB                        ;Get next character
  OR   AH,AH                   ;Are we looking for a Quoted Path/File Name?
  JZ  >J40                     ;If not, continue
J35:                           ;Looking for the Closing Quote
  CMP  AL,AH                   ;Is it the Closing Quote?
  JNE >J50                     ;If not, keep looking
  JMP >J85                     ;If so, we're done
J40:                           ;Not a Quoted Path/File Name
  OR   AL,AL                   ;End of variable?
  JE  >J80                     ;If so, handle it
  CMP  AL,' '                  ;Space?
  JE  >J80                     ;If so, we're done
  CMP  AL,Tab                  ;Tab?
  JE  >J80                     ;If so, we're done
  CMP  AL,'/'                  ;Slash?
  JE  >J80                     ;If so, we're done
  CMP  AL,DL                   ;SwitchChar?
  JE  >J80                     ;If so, we're done
J50:                           ;Not end-of-name
  JMP  J30                     ;Keep looking
J80:                           ;[SI-1] = CMDLINE Pointer
  DEC  SI                      ;Point at beginning of string
J85:                           ;[SI] = New CMDLINE Pointer
  MOV  CS:CmdLineVarPointer,SI ;Store it
J90:                           ;Done
  POP  DS,SI,DX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE ENVIRONMENT VARIABLE CONTENTS TO THE SCREEN
;Inputs:  EnvVarPointer (-1 if no Environment variable exists)
;Outputs:
;Changes: Writes to CON or ERR
;------------------------------------------------------------------------------
WriteEnvCon:
  CMP  EnvVarPointer,-1 ;Is there even an Environment variable to write?
  JE  >W90              ;If not, we're done
  PUSH DX,DS            ;Save used registers
  MOV  DX,EnvVarPointer ;Point at the
  SUB  DX,EnvVarSize    ;  beginning of the Variable
  MOV  DS,[PSPEnvirSeg] ;Point at the Environment Segment
  CALL WriteZPause      ;Write it
  POP  DS,DX            ;Restore used registers
W90:                    ;We're done
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO WRITE SPECIAL MESSAGES TO THE SCREEN (HELP, STATUS, ETC.)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;Write the Next LPT Port Number that will be used by a USB Printer
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;PRINT THE NEXT (FIRST) LPTx PORT NUMBER THAT WILL BE ASSIGNED TO A USB PRINTER
;Inputs:  DS = ES = TSR Data Area
;         CS = Local Data Area
;Outputs: Writes appropriate Message to the screen
;Changes:
;------------------------------------------------------------------------------
WriteNextPort:
  PUSH AX,BX,DX,DS,ES    ;Save used registers
  CALL CopyTSRData2Local ;Copy the TSR Data to our local data area
  MOV  DS,CS             ;Point DS & ES at the local data area
  MOV  ES,CS             ;  (to fool the TSR Code)
  MOV  BX,(DeviceInfoTable+((MaxDevices-1)*DeviceInfoStrucSize))
                         ;Point [BX] at an empty Device Info Table entry
  CALL AssignLPTNum      ;Assign LPT Number, using TSR Code
  MOV  AL,[BX].DILPTNum  ;Get the assigned LPT Number
  CALL ResetDvcEntryBX   ;Restore things back to original
  OR   AL,AL             ;Is there a valid Port to assign?
  JZ  >P70               ;If not, handle it
P20:                     ;Valid LPT Port
  MOV  DX,NextPortMsg    ;Write the
  CALL WriteZPause       ;  Header
  CALL WriteByteMin      ;Write the LPT Number
  CALL WriteDot          ;Write a Period
  JMP >P90               ;Done
P70:                     ;No Ports available
  MOV  DX,NoPortMsg      ;Write the
  CALL WriteZPause       ;  No LPTx available message
P90:                     ;Done
  CALL WriteCrLfPause    ;Move down
  POP  ES,DS,DX,BX,AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY THE CONTENTS OF THE TSR DATA AREA TO OUR LOCAL DATA AREA
;Inputs:  DS = ES = TSR Data Area
;         CS = Local Data Area
;         CLD already issued
;Outputs: Copies data so that we can modify/change it without affecting the TSR
;Changes:
;------------------------------------------------------------------------------
CopyTSRData2Local:
  PUSH CX,DI,SI ;Save used registers
  PUSH DS,ES    ;Save used registers
  MOV  SI,ES    ;SI = TSR Segment
  MOV  DI,CS    ;DI = Local Segment
  CMP  DI,SI    ;Are they the same (were we unable to relocate to a UMB)?
  JE  >C90      ;If so, we don't need to do anything
  MOV  DS,SI    ;If not, point DS:[SI]
  MOV  SI,100h  ;  at the beginning of the TSR Data
  MOV  ES,DI    ;If not, point ES:[DI]
  MOV  DI,SI    ;  at the beginning of our local TSR Data
  MOV  CX,((LastTSRDataByte-100h+1)/2) ;CX = Number of words to copy
  REP  MOVSW    ;Copy the data
C90:            ;Done
  POP  ES,DS    ;Restore used registers
  POP  SI,DI,CX ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;Write Program Help Message
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;PRINT THE SYNTAX HELP MESSAGE AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;Outputs: Writes Help Message to the screen
;Changes: Quits program
;------------------------------------------------------------------------------
DoHelp:
  TEST ProgFlags,Help  ;Does the user want help?
  JZ  >H90             ;If not, we're done
  MOV  DX,SyntaxMsgHdr ;Write the first part
  CALL WriteZPause     ;  of the Help Message
  MOV  DX,RealName     ;Write the
  CALL WriteZPause     ;  Real Program Name
  CALL WriteSpace      ;Write a space
  MOV  DX,SyntaxMsg    ;Point at the last part of the Help Message
  XOR  AL,AL           ;ErrorLevel = 0
  JMP  Exit            ;Quit
H90:                   ;No need to do help
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE BAD DEVICE LIST
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;PRINT THE BAD DEVICE TABLE AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;         ES = TSR Data Area
;Outputs: Writes contents of Bad Device Table to the screen
;Changes: Quits program
;         Lots of Registers
;------------------------------------------------------------------------------
DoBadDevices:
  TEST StatusFlags,BadDevices ;Does the user want the Bad Device List?
  JZ  >B000                   ;If not, we're done
  TEST ProgFlags,InMemory     ;Are we installed in memory yet?
  JNZ >B00                    ;If so, continue
  MOV  DX,BadDvcErrMsg        ;If not, point at the first part of Error Message
  JMP  FinishDataErr          ;Terminate program
B000:
  RET

B00:                               ;Write it
  MOV  DX,BadBeepMsg               ;Write the
  CALL WriteZPause                 ;  Beep Header
  MOV  DX,YesMsg                   ;Assume Yes
  TEST ES:TSRFlags,NoBeep          ;Is it Yes?
  JZ  >B05                         ;If so, continue
  MOV  DX,NoMsgS                   ;If not, point at No Message
B05:                               ;Have Beep Status Message
  CALL WriteZPause                 ;Write the Beep Status
  CALL WriteCrLfPause2             ;Move down
  MOV  DX,BadDeviceHdr             ;Write the
  CALL WriteZPause                 ;  Header
  CALL TestSupportFile             ;Look for the Support File in the Path
  XOR  BL,BL                       ;Start Bad Counter at 0
  MOV  SI,BadDeviceTable           ;Point at Bad Table
  MOV  CX,MaxBadDevices            ;Number of Table Entries
B10:                               ;Loop to here for each table entry
  TEST ES:[SI].BDFlags,BDFlagInUse ;Valid Entry?
  JZ  >B40                         ;If not, skip it
  INC  BL                          ;Increment Bad Counter
  CALL WriteSpace                  ;Write
  MOV  AL,ES:[SI].BDHostIndex      ;  the
  CALL ByteToString                ;  Host Index
  CALL Write3Spaces                ;Write
  MOV  AL,ES:[SI].BDDvcAddress     ;  the
  CALL ByteToString                ;  Device Address
  CALL Write3Spaces                ;Write
  MOV  AL,ES:[SI].BDInterfaceNum   ;  the
  CALL ByteToString                ;  Interface Number
  CALL WriteBadStage               ;Write the Stage details
B40:                               ;Go to next entry
  ADD  SI,BadDeviceStrucSize       ;Point at next Entry
  LOOP B10                         ;Keep going until we're done
  OR   BL,BL                       ;Were there any Bad Devices?
  JNZ >B70                         ;If so, we're done
  MOV  DX,NoneFoundMsg             ;If not, write
  CALL WriteZPause                 ;  "None Found" Message
B70:                               ;Done
  MOV  DX,NoMsg                    ;Write nothing when done
  XOR  AL,AL                       ;ErrorLevel=0
  JMP  Exit                        ;And QUIT

;------------------------------------------------------------------------------
;WRITE THE BAD STAGE INFORMATION TO THE SCREEN
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [SI] = Bad Device Table Entry
;                Already checked for Validity (BDFlagInUse = True)
;                Host Index, Device Address, & Interface Number alread written
;Outputs: Write Try, Stage, and Error Code Numbers to the Table
;Changes:
;------------------------------------------------------------------------------
WriteBadStage:
  PUSH AX,CX                       ;Save used registers
  CALL Write2Spaces                ;Move over
  XOR  AH,AH                       ;Write the
  MOV  AL,ES:[SI].BDNewDeviceStage ;  Stage
  CALL WordToString                ;  Number
  CALL Write2Spaces                ;Move over
  MOV  CX,ES:[SI].BDNewDeviceError ;Write the
  CALL WriteBadError               ;  Error Code
  CALL WriteCrLfPause              ;Move down
  POP  CX,AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE ERROR CODE ND APPROPRIATE DESCRIPTION TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         AL = Stage Number
;         CX = Error Code to write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteBadError:
  PUSH AX,DX            ;Save used registers
  XCHG AX,CX            ;AX = Error Code, CL = Stage
  CALL WriteWordHex     ;Write the Error Code
  CALL WriteHexEnd      ;Write an h
  CMP  CL,200           ;Is the stage more than 200?
  JAE >E90              ;If so, the Error Code is meaningless
  CALL WriteSpace       ;Move over
  TEST ProgFlags,FoundSuptFile ;Is there a Support File in the Path?
  JNZ >E20              ;If so, continue
E10:                    ;No Support File
  MOV  DX,NoSuptFileMsg ;If not, write first part
  CALL WriteZPause      ;  of Error Message
  MOV  DX,SupportFile   ;Write the Support
  CALL WriteZPause      ;  File Name
  JMP >E90              ;Done
E20:                    ;OK to call support File
  TEST CL,1             ;Is it even (TD Status) or odd (Int 14h Error)?
  JZ  >E50              ;If Even, jump to handle it
E40:                    ;Int 14h Error Code (Stage is Odd)
  CALL WriteInt14Err    ;Write the Int 14h Error Code
  JMP >E90              ;Done
E50:                    ;TD Status Code (Stage is Even)
  CALL WriteTDStsErr    ;Write the TD Status Error Code
E90:                    ;Done
  POP  DX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE TD STATS OR INT 14H ERROR DESCRIPTION TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         AX = TD Status Code to write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteTDStsErr:
  PUSH BX,CX,DX           ;Save used registers
  MOV  BX,TDStatusCode    ;[BX] = Where to write Code Number
  MOV  CX,TDStatusCallBk  ;[CX] = Where to write Screen-writing Address
  MOV  DX,TDStatusMsg     ;[DX] = Start of command-tail string
  JMP >R00                ;Do it
WriteInt14Err:
  PUSH BX,CX,DX           ;Save used registers
  MOV  BX,Int14ErrCode    ;[BX] = Where to write Code Number
  MOV  CX,Int14ErrCallBk  ;[CX] = Where to write Screen-writing Address
  MOV  DX,Int14ErrMsg     ;[DX] = Start of command-tail string
;  JMP >R00               ;Do it
R00:
  PUSH AX                 ;Save used registers
  CALL WriteWordToString  ;Write the Error Code to our string
  MOV  BX,CX              ;Write our
  MOV  AX,CS              ;  screen-writing
  MOV  CX,WriteZPauseFar  ;  code address
  CALL WriteSegmentOffset ;  to the string
  MOV  BX,DX              ;Copy our String
  CALL CopyToCmdTail      ;  to the Command Tail String
  CALL DoExec             ;Write the Description
  POP  AX                 ;Restore used registers
  POP  DX,CX,BX           ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE PROGRAM/DEVICE STATUS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE CURRENT STATUS TO THE SCREEN
;Inputs:  ES = TSR Data Area
;         Status (Flag)
;Outputs: Writes a bunch of stuff to the screen if Status Flag is True
;Changes:
;------------------------------------------------------------------------------
DoStatus:
  TEST StatusFlags,Status ;Need to to anything?
  JZ  >S000               ;If not, quit
  TEST ProgFlags,InMemory ;Are we installed in memory yet?
  JNZ >S00                ;If so, go ahead and do it
  MOV  DX,StatusErrMsg    ;If not, point at the first part of Error Message
  JMP  FinishDataErr      ;Terminate program
S000:
  RET

S00:                          ;Need to do Status
  PUSH AX,BX,CX,DX            ;Save used registers
  MOV  DX,StatusMsgHdr1
  CALL WriteZPause            ;Write Registered with USB Host Status
  MOV  DX,YesMsg
  CMP  ES:Reg0Handle,-1
  JNE >S20
  MOV  DX,NoMsgS
S20:
  CALL WriteZPause
  CALL WriteCrLfPause
  MOV  AL,ES:TSRFlags         ;Work with TSRFlags
  MOV  DX,StatusMsgBoundFix   ;Write BOUND Fix Enabled Status
  CALL WriteZPause
  MOV  AH,NoBoundFix
  CALL WriteYesNoRvs
  MOV  DX,StatusMsgBeep       ;Write Beep Status
  CALL WriteZPause
  MOV  AH,NoBeep
  CALL WriteYesNoRvs
  MOV  DX,StatusMsgParallel   ;Write Parallel Port Override Status
  CALL WriteZPause
  MOV  AH,NoParallel
  CALL WriteYesNoFwd
  MOV  DX,StatusMsgEpson      ;Write Epson Init String Status
  CALL WriteZPause
  MOV  AH,NoAutoEpson
  CALL WriteYesNoRvs
  MOV  DX,StatusMsgIOAddr     ;Write "Fake" Base I/O Address
  CALL WriteZPause
  MOV  AX,ES:IOAddress
  CALL WriteWordHex
  CALL WriteHexEnd
  CALL WriteCrLfPause
  MOV  DX,StatusMsgHdr2       ;Write Individual Printer Statuses
  CALL WriteZPause
  CALL GotADevice             ;Any Devices Installed?
  JNC >S40                    ;If so, jump to write them
  MOV  DX,NoDeviceMsg         ;If no, write
  CALL WriteZPause            ;  the "No Devices" message
  JMP >S90                    ;Done
S40:                          ;At least one device is installed
  MOV  DX,StatusMsgHdr3       ;Write
  CALL WriteZPause            ;  the Header
  MOV  BX,DeviceInfoTable     ;Point at the Table
  XOR  CL,CL                  ;Start at Index 0
S50:                          ;Loop to here for each table entry
  CALL DoIndividualStatus     ;Write the Status
  ADD  BX,DeviceInfoStrucSize ;Point at next Table entry
  INC  CL                     ;Increment Index
  CMP  CL,MaxDevices          ;Done all of them yet?
  JB   S50                    ;If not, keep doing it
S90:                          ;Done
  CALL WriteCrLfPause         ;Write a New Line
  POP  DX,CX,BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE STATUS OF AN INDIVIDUAL DEVICE TO THE SCREEN
;Inputs:  CL = Device Index
;         [BX] = Device Info Table Pointer
;         ES = TSR Data Area
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoIndividualStatus:
  PUSH AX,DX                       ;Save used registers
  CALL Write2Spaces                ;Write the Index
  MOV  AL,CL
  CALL WriteByteMin
  TEST ES:[BX].DIFlags,DIFlagInUse ;Valid Device?
  JZ  >I90                         ;If not, we're done
  CALL WriteSpace                  ;Write BiDirectional Status
  MOV  AL,ES:[BX].DIEndPointIn
  MOV  AH,-1
  CALL WriteYNFwd
  MOV  AL,ES:[BX].DIFlags          ;Write Epson Status
  MOV  AH,DIFlagIsEpson
  CALL WriteYNFwd
  MOV  AL,ES:[BX].DILPTNum         ;Write the LPT Number
  OR   AL,AL
  JNZ >I30
  CALL Write4Dots
  JMP >I35
I30:
  CALL WriteLPTMsg
  CALL WriteByteMin
I35:
  CALL WriteSpace                  ;Write Host Index
  MOV  AL,ES:[BX].DIHostIndex
  CALL ByteToString
  CALL WriteSpace                  ;Write Device Address
  MOV  AL,ES:[BX].DIDvcAddress
  CALL ByteToString
  CALL WriteSpace                  ;Write Interface Number
  MOV  AL,ES:[BX].DIInterfaceNum
  CALL ByteToString
  CALL WriteSpace                  ;Write Alternate Interface Number
  MOV  AL,ES:[BX].DIAltInterface
  CALL ByteToString
  CALL WriteSpace                  ;Write Manufacturer & Model
  MOV  DL,ES:[BX].DILptNum
  DEC  DL
  XOR  DH,DH
  CALL WriteMfgModel
I90:                               ;Done
  CALL WriteCrLfPause              ;Start a new line
  POP  DX,AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A YES OR NO STATUS AS A STRING, FOLLOWED BY A CR/LF
;Inputs:  AL = Byte to test
;         AH = Test Mask
;Outputs: Writes "Yes" or " No" depending on bit mask
;Changes:
;------------------------------------------------------------------------------
WriteYesNoFwd:
  PUSH AX             ;Save used registers
  JMP >Y00            ;Do it
WriteYesNoRvs:
  PUSH AX             ;Save used registers
  NOT  AL             ;Reverse
;  JMP >Y00            ;Do it
Y00:
  PUSH DX             ;Save used registers
  MOV  DX,YesMsg      ;Assume the bit is set (Write Yes)
  TEST AL,AH          ;Is the bit set?
  JNZ >Y30            ;If so, write Yes
  MOV  DX,NoMsgS      ;If not, write No
Y30:                  ;DX points at Yes/No String
  CALL WriteZPause    ;Write the String
  CALL WriteCrLfPause ;Write a new line
  POP  DX             ;Restore used registers
  POP  AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A YES OR NO STATUS AS A Y OR DOT, FOLLOWED BY A SPACE
;Inputs:  AL = Byte to test
;         AH = Test Mask
;Outputs: Writes "Y " or ". " depending on bit mask
;Changes:
;------------------------------------------------------------------------------
WriteYNFwd:
  PUSH AX                 ;Save used registers
;  JMP >Y00                ;Do it
;WriteYNRvs:
;  PUSH AX                 ;Save used registers
;  NOT  AL                 ;Reverse
;  JMP >Y00                ;Do it
;Y00:
  PUSH DX                 ;Save used registers
  MOV  B SingleMsg[0],'Y' ;Assume the bit is set (Write Y)
  TEST AL,AH              ;Is the bit set?
  JNZ >Y30                ;If so, write Yes
  MOV  B SingleMsg[0],'.' ;If not, write a Dot
Y30:                      ;DX points at string to write
  MOV  DX,SingleMsg       ;Write the
  CALL WriteZPause        ;  String
  CALL WriteSpace         ;Write a space
  POP  DX                 ;Restore used registers
  POP  AX                 ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE LPT PORT STATUSES
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE CURRENT PORT STATUS TO THE SCREEN
;Inputs:  ES = TSR Data Area
;         StatusFlags.PortStatuses
;Outputs: Writes a bunch of stuff to the screen if Flag is True
;Changes:
;------------------------------------------------------------------------------
DoPortStatuses:
  TEST StatusFlags,PortStatuses ;Does the user want to see the Port Statuses?
  JNZ >P00                      ;If so, do it
  RET

P00:
  MOV  DX,PortStatusHdr   ;Write the
  CALL WriteZPause        ;  Header
  CALL WriteRedirects     ;Write the Port Redirects
  MOV  DX,PortStatusHdr2  ;Write the
  CALL WriteZPause        ;  Header
  XOR  DX,DX              ;Start with LPT1
P10:                      ;Loop to here for each Port
  MOV  CX,DX              ;Save Port Number in CX
  MOV  AH,I17FGetStatus   ;Function = Get Status
  INT  17h                ;Do it
  CMP  AH,I17FGetStatus   ;Anything installed?
  JE  >P50                ;If not, skip it
  MOV  BL,AH              ;Save Status in BL
  CALL Write2Spaces       ;Move over
  CALL WriteRedirectSym   ;Write Redirect Symbol, if needed
  CALL WriteLPTxMsgSpaces ;Write the LPTx
  CALL Write2Spaces       ;Move over
  MOV  BH,PStsSelected    ;Write the
  CALL WriteYesNoAHBH     ;  Selected Status
  MOV  BH,PStsNotBusy     ;Write the
  CALL WriteYesNoAHBH     ;  Not Busy Status
  MOV  BH,PStsACKnowledge ;Write the
  CALL WriteYesNoAHBH     ;  Acknowledge Status
  CALL Write2Spaces       ;Move over
  MOV  BH,PStsNoPaper     ;Write the
  CALL WriteYesNoAHBH     ;  No Paper Status
  MOV  BH,PStsIOError     ;Write the
  CALL WriteYesNoAHBH     ;  I/O Error Status
  MOV  BH,PStsTimeout     ;Write the
  CALL WriteYesNoAHBH     ;  Timeout Status
  CALL Write2Spaces       ;Move over
  CALL WriteIOAddr        ;Write the I/O Address
  CALL Write2Spaces       ;Move over
  CMP  BL,PStsNoPrinter   ;Is there even a Printer installed?
  JNE >P30                ;If so, handle it
  MOV  DX,NoPrinterMsg    ;If not, write
  CALL WriteZCon          ;  No Printer
  JMP >P40                ;Continue
P30:                      ;Printer installed
  MOV  DX,CX              ;Load the Index into DX
  CALL WriteMfgModelRedir ;Download and write the Manufacturer & Model
                          ;  Allowing for Redirections
P40:                      ;Done writing Description
  CALL WriteCrLfPause     ;Start a new line
P50:                      ;Done with this Port
  MOV  DX,CX              ;Get Index back again
  INC  DX                 ;Point at next Port
  CMP  DX,MaxPrinters     ;Done all of the Ports yet?
  JB   P10                ;If not, keep going
  MOV  DX,PortStatusFtr   ;Write the
  CALL WriteZPause        ;  Footer Message
  MOV  DX,NoMsg           ;Write nothing when done
  XOR  AL,AL              ;ErrorLevel=0
  JMP  Exit               ;And QUIT

;------------------------------------------------------------------------------
;WRITE THE PORT REDIRECTS
;Inputs:  ES = TSR Data Area
;         CLD already issued
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
WriteRedirects:
  PUSH AX,BX,CX,DX    ;Save used registers
  PUSH SI,ES          ;Save used registers
  MOV  AX,(1B00h+I17FGetRedirTblAddr) ;Function = Get Redirect Table Address
  MOV  DX,-1          ;Set Register Value
  INT  17h            ;Do it
  OR   AX,AX          ;Did it work?
  JNZ >R80            ;If not, just quit
  MOV  ES,CX          ;Point ES:[SI]
  MOV  SI,BX          ;  at the Redirect Table
  XOR  AH,AH          ;Start Counter at 0
  MOV  CL,1           ;Start with LPT1
  MOV  DX,RedirMsg    ;Point at the Redirect Pointer String
R10:                  ;Loop tohere for each Table Entry
  MOV  AL,ES:[SI]     ;Get the next table entry
  OR   AL,AL          ;This Port Redirected?
  JZ  >R50            ;If not, skip it
  OR   AH,AH          ;First Entry?
  JZ  >R20            ;If so, continue
  CALL WriteComma     ;If not, write a comma
  CALL WriteSpace     ;  and a space
R20:                  ;Handled extra spaces as needed
  INC  AH             ;Increment Counter
  XCHG AL,CL          ;Write the
  CALL WriteLPTMsg    ;  From
  CALL WriteByteMin   ;  Port
  CALL WriteZPause    ;Write Pointer
  XCHG AL,CL          ;Write the
  CALL WriteLPTMsg    ;  To
  CALL WriteByteMin   ;  Port
R50:                  ;Done with this entry
  INC  SI             ;Point at next entry
  INC  CL             ;Increment LPT Number
  CMP  CL,MaxPrinters ;Done with Table yet?
  JBE  R10            ;If not, keep looking
R80:                  ;Done writing
  OR   AH,AH          ;Any ports redirected?
  JNZ >R90            ;If so, we're done
  MOV  DX,NoneMsg     ;If not,
  CALL WriteZPause    ;  write None
R90:                  ;Done
  POP  ES,SI          ;Restore used registers
  POP  DX,CX,BX,AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A REDIRECTED SYMBOL (>) OR A SPACE FOR A PORT
;Inputs:  ES = TSR Data Area
;         DX = LPT Index
;Outputs: Writes a space if Port is not Redirected
;                a star  if Port is Redirected
;Changes:
;------------------------------------------------------------------------------
WriteRedirectSym:
  PUSH AX,BX,CX,DX ;Save used registers
  MOV  AX,(1B00h+I17FGetPortRedir) ;Function = Get Port Redirect
                   ;DX = Port Index
  INT  17h         ;Do it (Retrunes BX = Redirected Port)
  OR   AX,AX       ;Did it work?
  JNZ >Y80         ;If not, no Redirection
  CMP  BX,DX       ;Is it Redirected?
  JE  >Y80         ;If not, handle it
Y70:               ;Port Redirected
  CALL WriteStar   ;Write Redirected symbol
  JMP >Y90         ;Done
Y80:               ;Port not Redirected
  CALL WriteSpace  ;Write a Space
Y90:               ;Done
  POP  DX,CX,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE AN I/O ADDRESS FOR THE PORT STATUS TABLE
;Inputs:  DX = LPT Index
;Outputs: Depending on Address, Writes fake, I/O Address, or ????
;Changes:
;------------------------------------------------------------------------------
WriteIOAddr:
  PUSH AX,DX             ;Save used registers
  CALL ConvertIndexDX    ;Convert it to a Redirected Index
  CMP  DX,2              ;Is the address in the BIOS Data Area?
  JBE >I20               ;If so, continue
  MOV  DX,QuestionsMsg   ;If not,
  CALL WriteZPause       ;  write Question Marks
  JMP >I90               ;Done
I20:                     ;Address is in BIOS Data Area
  CALL LPTIndex2IOAddrDX ;Get the Base I/O Address
  MOV  AX,DX             ;Put it in AX
  CALL TestIOAddrReal    ;Is it a Real Address?
  JNZ >I30               ;If a real address, handle it
  MOV  DX,FakeMsg        ;Write that
  CALL WriteZCon         ;  it's Fake
  JMP >I40               ;Continue
I30:                     ;Address is real
  CALL Write4Spaces      ;Write Spaces
I40:                     ;Have fake address handled
  CALL WriteSpace        ;Move over
  OR   AX,AX             ;Is it Address 0?
  JNZ >I50               ;If not, go ahead and write it
  CALL Write5Spaces      ;If so, just write some spaces
  JMP >I90               ;Done
I50:                     ;Write the Address
  CALL WriteWordHex      ;Write the Address
  CALL WriteHexEnd       ;Write the "h"
I90:                     ;Done
  POP  DX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE MANUFACTURER AND MODEL OF A PRINTER
;Inputs:  ES = TSR Data Area
;         DS = Local Data Area
;         DX = LPT Index (as used by INT 17h)
;Outputs: Writes Description field of Device ID string to the screen, if avail
;           else Writes Manufacturer & Model fields
;           else Writes "Unknown Printer"
;Changes: DvcIDBuffer
;NOTES: If WriteMfgModelRedir, we actually get the ID String of the REDIRECTED
;         Printer, not necessarily the Printer actually attached to the Port.
;------------------------------------------------------------------------------
WriteMfgModelRedir:
  PUSH DX             ;Save used registers
  CALL ConvertIndexDX ;Convert Index to a Redirected Index
  CALL WriteMfgModel  ;Write it
  POP  DX             ;Restore used registers
  RET

WriteMfgModel:
  PUSH AX,BX,CX,DX,DI,SI        ;Save used registers
  MOV  AH,I17FGetStatus         ;Function = Get Status
  INT  17h                      ;Do it
  CMP  AH,PStsNormal            ;Is the Status Normal?
  JNE >G70                      ;If not, write Unknown
  CALL GetDeviceIDStringNoRedir ;Get the Device ID String
  JZ  >G70                      ;If error, handle it
  CALL CvtSColons2Zeroes        ;Convert semicolons to zeroes
  JC  >G70                      ;If empty string, handle unknown printer
  MOV  SI,DesString1            ;Write
  MOV  CX,DesString1Size        ;  the
  CALL WriteDvcIDComponent      ;  Description
  JNC >G90                      ;If it worked, we're done
  MOV  SI,DesString2            ;Write
  MOV  CX,DesString2Size        ;  the alternate
  CALL WriteDvcIDComponent      ;  Description
  JNC >G90                      ;If it worked, we're done
G30:                            ;No Description Field
  MOV  SI,MfgString1            ;Write
  MOV  CX,MfgString1Size        ;  the
  CALL WriteDvcIDComponent      ;  Manufacturer
  JNC >G40                      ;If it worked, continue
  MOV  SI,MfgString2            ;Write
  MOV  CX,MfgString2Size        ;  the alternate
  CALL WriteDvcIDComponent      ;  Manufacturer
  JC  >G70                      ;If it didn't work, Error
G40:                            ;Done with manufacturer
  CALL WriteSpace               ;Write a Space
  MOV  SI,MdlString1            ;Write
  MOV  CX,MdlString1Size        ;  the
  CALL WriteDvcIDComponent      ;  Model
  JNC >G90                      ;If it worked, we're done
  MOV  SI,MdlString2            ;Write
  MOV  CX,MdlString2Size        ;  the alternate
  CALL WriteDvcIDComponent      ;  Model
  JMP >G90                      ;Done
G70:                            ;Error (No Device ID String available)
  MOV  DX,UnknownPrnMsg         ;Write the
  CALL WriteZPause              ;  Unknown message
G90:                            ;Done
  POP  SI,DI,DX,CX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF A DEVICE ID COMPONENT
;Inputs:  DS = Local Data Area
;         SI = Device ID Component Label String
;         CX = Length of string
;         CLD already issued
;Outputs: CF = Clear if OK
;              Contents of Component written to screen
;            = Set if Error (could not find Component Message)
;              Nothing written
;Changes:
;------------------------------------------------------------------------------
WriteDvcIDComponent:
  PUSH AX,BX,CX,DX        ;Save used registers
  PUSH DI,SI,ES           ;Save used registers
  MOV  ES,DS              ;Point ES at local data area
  MOV  AX,CX              ;Save String length
  MOV  BX,SI              ;Save String Pointer
  MOV  SI,(DvcIDBuffer+2) ;Point at Buffer
C10:                      ;Loop to here for each Component
  CMP  B [SI],0           ;End of the buffer?
  JE  >C70                ;If so, error
  MOV  CX,AX              ;Get String Length
  MOV  DI,BX              ;Get String Pointer
  REPE CMPSB              ;Compare the strings
  JZ  >C50                ;If a match, we've found it!
  CALL SkipOverStringSI   ;If not, skip over the string
  JMP  C10                ;Keeplooking
C50:                      ;SI points at the string
  MOV  DX,SI              ;Write the
  CALL WriteZPause        ;  String
  JMP >C80                ;Done
C70:                      ;Error
  STC                     ;Set Error Flag
  JMP >C90                ;Done
C80:                      ;OK
  CLC                     ;Set OK Flag
C90:                      ;Done
  POP  ES,SI,DI           ;Restore used registers
  POP  DX,CX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE "LPTn:" TO THE SCREEN, POSSIBLY FOLLOWED BY SOME SPACES
;Inputs:  DX = LPT Index Number
;         DS = Local Data Area
;Outputs: LPT#: to the screen
;Changes:
;------------------------------------------------------------------------------
WriteLPTXMsgSpaces:
  CALL WriteLPTXMsg ;Write the LPTx:
  CMP  DX,98        ;Is it more than LPT99?
  JA  >S90          ;If so, continue
  CALL WriteSpace   ;If not, move over one space
  CMP  DX,8         ;Is it more than LPT9?
  JA  >S90          ;If so, continue
  CALL WriteSpace   ;If not, move over one space
S90:                ;Done
  RET

WriteLPTxMsg:
  PUSH AX,DX        ;Save used registers
  MOV  AL,DL        ;Put LPT Number
  INC  AL           ;  in AL
  CALL WriteLPTMsg  ;Write LPT
  CALL WriteByteMin ;Write the Number
  CALL WriteColon   ;Write a Colon
  POP  DX,AX        ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE DEVICE ID STRING(S)
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;GET AND WRITE THE DEVICE ID STRINGS FROM ALL DEVICES
;Inputs:  ES = TSR Data Area
;         DS = Local (non-TSR Data Area)
;Outputs: Downloads and writes string(s) to the screen
;Changes:
;------------------------------------------------------------------------------
DoDeviceIDs:
  TEST StatusFlags,DeviceIDs       ;Does the user want to see the Device ID's?
  JNZ >I00                         ;If so, do it
  RET

I00:
  XOR  CH,CH                       ;CH = Number of Printers Found
  XOR  DX,DX                       ;Start with LPT1
I10:                               ;Loop to here for each LPT Port
  MOV  AH,I17FGetStatus            ;Function = Get Status
  INT  17h                         ;Do it
  CMP  AH,PStsNormal               ;Is the Status Normal?
  JNE >I20                         ;If not, skip it
  CALL GetDeviceIDStringNoRedir    ;Attempt to download the Device ID String
  JZ  >I20                         ;If error, skip it
  INC  CH                          ;Increment Device Counter
  CALL WriteDeviceID               ;Write it
I20:                               ;Skip to next one
  INC  DX                          ;Increment LPT Number
  CMP  DX,MaxPrinters              ;Done with LPT Numbers Yet?
  JBE  I10                         ;If not, keep looking
I30:                               ;Done with mapped Devices
  MOV  DX,-1                       ;Mark as unmapped
  MOV  DI,DeviceInfoTable          ;Point at Table
  MOV  CL,MaxDevices               ;Number of table entries
I40:                               ;Loop to here for each Table entry
  TEST ES:[DI].DIFlags,DIFlagInUse ;Valid entry?
  JZ  >I50                         ;If not, skip it
  CMP  ES:[DI].DILPTNum,0          ;Is it mapped?
  JNE >I50                         ;If so, skip it (it's already done)
  INC  CH                          ;Increment Device counter
  CALL WriteDeviceID               ;Write it
I50:                               ;Go to next Table entry
  ADD  DI,DeviceInfoStrucSize      ;Point at next entry
  DEC  CL                          ;Decrement Loop Counter
  JNZ  I40                         ;If not done yet, keep looking
  OR   CH,CH                       ;Did we find any Devices?
  JNZ >I90                         ;If so, we're done
  CALL BeepErr                     ;Beep the speaker
  MOV  DX,NoPrintersMsgID          ;Write the
  CALL WriteZPause                 ;  error message
I90:                               ;Done
  MOV  DX,NoMsg                    ;Write nothing when done
  XOR  AL,AL                       ;ErrorLevel=0
  JMP  Exit                        ;And QUIT

;------------------------------------------------------------------------------
;WRITE A DEVICE ID STRING (WITH HEADER) TO THE SCREEN
;Inputs:  ES = TSR Data Area
;         DS = Local Data Area
;         DX = LPT Index (as used by Int 17h), -1 if Unmapped USB Device
;         DI = Device Info Table Entry if USB Device
;         DvcIDBuffer contains Device ID String
;Outputs: To screen
;Changes
;------------------------------------------------------------------------------
WriteDeviceID:
  PUSH AX,BX,CX,DX             ;Save used registers
  CALL WriteCrLfPause          ;Write a new line
  CMP  DX,-1                   ;Unmapped USB Device?
  JNE >W20                     ;If not, handle a mapped Device
W10:                           ;Is unmapped USB Device
  PUSH DX                      ;Save used registers
  MOV  DX,UnmappedMsg          ;Write the
  CALL WriteZPause             ;  Unmapped Message
  POP  DX                      ;Restore used registers
  CALL Write3Spaces            ;Move over
  MOV  BX,DI                   ;Put Dvc Info Pointer in BX
  JMP >W40                     ;Continue
W20:                           ;Device is mapped
  CALL WriteLPTxMsg            ;Write LPT#:
  CALL Write3Spaces            ;Move over
  CALL TestDXIsOursES          ;Convert Index to Dvc Info Offset if USB (BX)
  CALL LPTIndex2IOAddrDX       ;Convert Index to I/O Address (DX)
  CALL TestIOAddrReal          ;Is it Parallel or USB?
  JZ  >W40                     ;If USB, jump to handle it
W30:                           ;Device is Parallel
  MOV  AX,DX                   ;Save I/O Address
  MOV  DX,ParallelMsgID        ;Write the
  CALL WriteZPause             ;  Parallel Message
  CALL WriteWordHex            ;Write the I/O Address
  CALL WriteHexEnd             ;Write the h
  JMP >W50                     ;Jump to write the String
W40:                           ;Device is USB (BX = Device Info Table Entry)
  MOV  DX,HostIndexMsgID       ;Write
  CALL WriteZPause             ;  the
  MOV  AL,ES:[BX].DIHostIndex  ;  Host
  CALL WriteByteMin            ;  Index
  CALL Write2Spaces            ;Move over
  MOV  DX,DvcAddrMsg           ;Write
  CALL WriteZPause             ;  the
  MOV  AL,ES:[BX].DIDvcAddress ;  Device
  CALL WriteByteMin            ;  Address
W50:                           ;Write the String
  MOV  DX,DvcIDHdrMsg          ;Write the
  CALL WriteZCon               ;  separator line
  CALL WriteDeviceIDString     ;Write the ID String
  POP  DX,CX,BX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE DEVICE ID STRING FROM A DEVICE
;Inputs:  ES   = TSR Data Area
;         DS   = Local (non-TSR Data Area)
;
;Outputs: Downloads and writes string to the screen
;Changes:
;------------------------------------------------------------------------------
WriteDeviceIDString:
  PUSH CX,DX,DI,SI        ;Save used registers
  CALL CvtSColons2Zeroes  ;Convert semicolons to zeroes
  MOV  SI,(DvcIDBuffer+2) ;Point at string
V20:                      ;Loop to here for each substring
  CMP  B [SI],0           ;End of the string?
  JE  >V90                ;If so, we're done
  CALL Write2Spaces       ;Write an indent
  CALL WriteZPauseSI      ;Write the String
  CALL SkipOverStringSI   ;Move to the next string
  CALL WriteSemiColon     ;Write a semicolon
  CALL WriteCrLfPause     ;Start a new line
  JMP  V20                ;Keep writing
V90:                      ;Done
  CALL WriteCrLfPause     ;Write a new line
  POP  SI,DI,DX,CX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERTS ALL SEMICOLONS IN THE DEVICE ID STRING TO ASCII ZEROES
;Inputs:  DS = Local Data Segment
;         DvcIDBuffer filled with String Data
;         CLD already issued
;Outputs: Changes Semicolons to Zeroes
;Changes:
;NOTES: Device ID strings are supposed to have a big-endian word at the
;         beginning (the first two bytes) that contains the String Length,
;         followed by the ASCII string.  Unfortunately, some Devices return
;         an incorrect value for the size.  I don't know if they return 0,
;         a size too big, or a size too small.  In any case, we can't depend
;         on the size being correct and therefore can't use it at all.
;         Instead, we must look at the string itself.
;       In addition, some Devices do not return a final semicolon at
;         the end of the string.  We aloso handle that in this code.
;------------------------------------------------------------------------------
CvtSColons2Zeroes:
  PUSH AX,CX,DI,SI,ES     ;Save used registers
  MOV  ES,DS              ;Point ES at the Local Data Area
  MOV  SI,(DvcIDBuffer+2) ;Calculate the size
  CALL CalcStrSizeSI      ;  of the string (CX)
  JZ  >Z70                ;If no string, error
  MOV  DI,SI              ;If OK, point ES:[DI] at the string
  MOV  AL,';'             ;Look for the Semicolons
Z30:                      ;Loop to here for each semicolon
  REPNE SCASB             ;Look for a semicolon
  MOV  B [DI-1],0         ;Replace the semicolon with a zero
  JCXZ >Z80               ;If end-of-string, quit
  JMP  Z30                ;Keep going
Z70:                      ;Error (no string)
  STC                     ;Set error flag
  JMP >Z90                ;Done
Z80:                      ;OK
  CLC                     ;Set OK Flag
Z90:                      ;Done
  POP  ES,SI,DI,CX,AX     ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;DOWNLOAD THE DEVICE ID STRING FROM DEVICE
;IF A USB DEVICE, THIS SENDS A "GET DEVICE ID STRING" CONTROL REQUEST
;IF A PARALLEL DEVICE, THIS DOWNLOADS THE STRING WITH IEEE 1284 NIBBLE MODE.
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;------------------------------------------------------------------------------
;DOWNLOAD THE DEVICE ID STRING FROM A DEVICE
;Inputs:  ES = TSR Data Area
;         DS = Local Data Area
;         DX = LPT Index (as used by INT 17h)
;Outputs: ZF = Clear if OK
;              DS:DvcIDBuffer contains Device ID String
;            = Set if Error
;              DS:DvcIDBuffer contains all zeroes
;Changes:
;------------------------------------------------------------------------------
GetDeviceIDStringNoRedir:
  PUSH AX,BX,CX,DX,BP              ;Save used registers
  CALL TSRInstallCheck             ;TSR even installed?
  JZ  >S10                         ;If so, continue
  CALL GetDeviceIDString           ;If not, just get the ID String
  JMP >S90                         ;Done
S10:                               ;TSR is installed
  MOV  AX,(1B00h+I17FGetPortRedir) ;Function = Get Redirect
                                   ;DX = LPT Index
  INT  17h                         ;Do it (returns BX)
  MOV  BP,BX                       ;Save Redirected Port
  MOV  AX,(1B00h+I17FSetPortRedir) ;Function = Set Redirect
  MOV  BX,DX                       ;BX = No Redirection)
                                   ;DX = LPT Index
  INT  17h                         ;Do it
  CALL GetDeviceIDString           ;Get the string
  PUSHF                            ;Save return flag
  MOV  AX,(1B00h+I17FSetPortRedir) ;Function = Set Redirect
  MOV  BX,BP                       ;BX = Original Redirection
                                   ;DX = LPT Index
  INT  17h                         ;Do it (returns BX)
  POPF                             ;Restore return flag
S90:                               ;Done
  POP  BP,DX,CX,BX,AX              ;Restore used registers
  RET

GetDeviceIDString:
  PUSH AX,BX,CX,DX,DI         ;Save used registers
  CALL ClearDvcIDBuffer       ;Fill the buffer with zeroes
  MOV  AH,I17FGetStatus       ;Function = Get Status
  INT  17h                    ;Do it
  CMP  AH,PStsNormal          ;Is the Status Normal?
  JNE >V90                    ;If not, error
  MOV  AX,(1B00h+I17FGetDvcIDString) ;Function = Get Device ID
  MOV  BX,DvcIDBuffer         ;DS:[BX] = Buffer Pointer
  MOV  CX,(DvcIDBufferSize-1) ;CX = Size of Buffer
                              ;DX = LPT Index
  CALL TSRInstallCheck        ;Is an Extended Int 17h TSR Installed?
  JNZ >V30                    ;If not, do it ourselves
  CALL IndexInstallCheck      ;Is it Installed for our port?
  JNZ >V90                    ;If not, we're done
  INT  17h                    ;Do it
  JMP >V90                    ;Done
V30:                          ;No TSR Installed
  CALL TestDXIsParallel       ;Is it a Parallel Port?
  JZ  >V90                    ;If not, we can't handle it
  MOV  DI,BX                  ;Put Buffer Pointer in DI
  CALL LPTIndex2IOAddrDX      ;Convert LPT Index to I/O Address (DX)
  CALL GetDvcIDParallel       ;Get the Data (uses, DS:DI, CX, DX)
V90:                          ;String is downloaded
  CMP  B DvcIDBuffer[2],0     ;Set the Return flag
  POP  DI,DX,CX,BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF AN EXTENDED INT 17h TSR IS INSTALLED
;Inputs:
;Outputs: ZF = Set if TSR is Installed
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
TSRInstallCheck:
  PUSH AX,BX,CX,DX ;Save used registers
  MOV  AX,(1B00h+I17FInstallCheck) ;Function = Install Check
  MOV  BX,'LP'     ;Set
  MOV  CX,'T!'     ;  register
  MOV  DX,-1       ;  values
  INT  17h         ;Do it
  OR   AX,AX       ;Is it installed?
  JNZ >I90         ;If not, we're done
  CMP  BX,'T!'     ;Is it installed?
  JNE >I90         ;If not, we're done
  CMP  CX,'LP'     ;Is it installed?
I90:               ;Done
  POP  DX,CX,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF AN EXTENDED INT 17h TSR IS INSTALLED FOR A PARTICULAR INDEX
;Inputs:  DX = LPT Index to Check
;Outputs: ZF = Set if TSR is Installed
;            = Clear if not
;Changes:
;NOTES: The TSR Returns BX = API Version, but we don't care about that for now.
;------------------------------------------------------------------------------
IndexInstallCheck:
  PUSH AX,BX,CX,DX ;Save used registers
  MOV  AX,(1B00h+I17FInstallCheck) ;Function = Install Check
  MOV  BX,'LP'     ;Set
  MOV  CX,'T!'     ;  register values
  INT  17h         ;Do it
  OR   AX,AX       ;Is it installed?
  POP  DX,CX,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FILL THE DEVICE ID BUFFER WITH ZEROES
;Inputs:  ES = TSR Data Area
;         DS = Local (non-TSR Data Area)
;Outputs: Resets (Clears) DvcIDBuffer
;Changes:
;------------------------------------------------------------------------------
ClearDvcIDBuffer:
  PUSH AX,CX,DI,ES            ;Save used registers
  MOV  ES,DS                  ;Point ES:[DI]
  MOV  DI,DvcIDBuffer         ;  at the buffer
  MOV  CX,(DvcIDBufferSize/2) ;Number of words to write
  XOR  AX,AX                  ;Write Zeroes
  REP  STOSW                  ;Do it
  POP  ES,DI,CX,AX            ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE COMMAND-LINE ALIASES
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;PRINT THE COMMAND LINE ALIASES AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;Outputs: Writes Aliases to the screen
;Changes: Quits program
;------------------------------------------------------------------------------
DoAliases:
  TEST StatusFlags,Alias  ;Does user want to see the Aliases?
  JZ  >A95                ;If not, we're done
  PUSH BX,DX,SI           ;Save used registers

  CALL WriteCrLfPause     ;Move down
  MOV  DX,AliasHdrMsg     ;Set up
  CALL SetupPause         ;  the Header
  MOV  SI,SwitchList      ;Point at Tbl of Aliases
  MOV  BX,'?'+('Z' SHL 8) ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNoNum   ;Write the Aliases
  MOV  BX,1+(31 SHL 8)    ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNoNum   ;Write the Aliases
  CALL WriteCrLfPause2    ;Move down

  MOV  DX,PrinterHdrMsg   ;Set up
  CALL SetupPause         ;  the Header
  MOV  SI,SwitchList2     ;Point at Tbl of Aliases
  MOV  BX,255+(255 SHL 8) ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNum     ;Write the Aliases
  CALL WriteCrLfPause2    ;Move down

  MOV  DX,YesNoHdrMsg     ;Set up
  CALL SetupPause         ;  the Header
  MOV  SI,SwitchListYesNo ;Point at Table of Aliases
  MOV  BX,'N'+('Y' SHL 8) ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNoNum   ;Write the Aliases

A90:                      ;Done
  POP  SI,DX,BX           ;Restore used registers
  MOV  DX,NoMsg           ;Don't write anything
  XOR  AL,AL              ;ErrorLevel = 0
  JMP  Exit               ;Quit
A95:                      ;No need to write Aliases
  RET

;------------------------------------------------------------------------------
;WRITE THE LIST OF SWITCH CHARACTERS TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         BL = Minimum Value to look for in the Table
;         DH = Maximum Value to look for in the Table
;         SI = Switch List ("Code Word") Table
;Outputs: Writes List of Switch Characters to the Screen
;Changes:
;NOTES:   Sets CH =  0 if we write Blocks for Switches < " "
;                 = -1 if we write numbers for the all Switches (0-255)
;                 = -2 if we subtract 128 from the numbers (128-255)
;------------------------------------------------------------------------------
;DoAliasesGoNum80h:
;  PUSH CX               ;Save used registers
;  MOV  CH,2             ;Mark as writing Numbers, needing to subtract 128
;  JMP >G00              ;Continue
DoAliasesGoNum:
  PUSH CX               ;Save used registers
  MOV  CH,1             ;Mark as writing Numbers, not needing to modify
  JMP >G00              ;Continue
DoAliasesGoNoNum:
  PUSH CX               ;Save used registers
  XOR  CH,CH            ;Mark as not writing Numbers
;  JMP >G00              ;Continue
G00:
  PUSH AX,DI            ;Save used registers
  MOV  DI,AliasSortTbl  ;Point at the Alias Sort Table
  MOV  AL,BL            ;Start with the Lower Limit
G10:                    ;Loop to here for each Alias
  CALL GetAliasPointers ;Get the Alias Pointers
  JZ  >G60              ;If none for this entry, go to the next one
G20:                    ;Have at least one valid Alias
  CALL WriteCrLfPause   ;If valid, move down
  OR   CH,CH            ;Writing Single characters?
  JNZ >G40              ;If not, handle full numbers
  MOV  CL,78            ;Write this many characters per line
  CMP  AL,' '           ;Is there a valid single-character equivalent?
  JB  >G30              ;If not, don't write it
  CALL WriteAL          ;If so, write it
  JMP >G50              ;Continue
G30:                    ;Not a writable character
  CALL WriteBlock       ;Write a Block Character
  JMP >G50              ;Continue
G40:                    ;Need to write Numbers
  MOV  CL,76            ;Write this many characters per line
  PUSH AX               ;Save the number for a second
  CMP  CH,2             ;Do we need to modify the Number?
  JNE >G45              ;If not, continue
  AND  AL,(NOT 80h)     ;Subtract 128 from it
G45:                    ;Write the Number
  CALL ByteToString     ;Write the Switch as a Number
  POP  AX               ;Restore the Number
G50:                    ;Done writing single character
  CALL WriteAliases     ;Write the Alias List
G60:                    ;Done with this Code
  CMP  AL,BH            ;Have we done the whole list yet?
  JE  >G90              ;If so, we're done
  INC  AL               ;If not, go to the next possibility
  JMP  G10              ;Keep going until we're done
G90:                    ;Done
  POP  DI,AX            ;Restore used registers
  POP  CX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET STRING POINTERS FOR ALL ALIASES FOR A SINGLE CHARACTER OPTION
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;          AL  = Switch Table entry to look for (not 0)
;         [SI] = Switch Table to look through, sorted backwards
;         [DI] = Alias Sort Table
;Outputs:  ZF = Clear if OK
;               [DI] = Filled with String Pointers, sorted backwards
;                      Last Entry is always a 0
;             = Set if no matches found
;                      First Entry is 0
;Changes:
;------------------------------------------------------------------------------
GetAliasPointers:
  PUSH AX,BX,CX,DX      ;Save used registers
  PUSH DI,SI            ;Save used registers
  MOV  CX,DI            ;Sve original pointer
P10:                    ;Loop to here for each Table Entry
  MOV  DX,SI            ;Save beginning Alias Pointer
P20:                    ;Loop to here to find the end of an Alias List Entry
  CMP  B [SI],0         ;End of Alias List?
  JE  >P30              ;If so, handle it
  CALL SkipOverStringSI ;If not, skip over the string
  JMP  P20              ;Keep looking
P30:                    ;End of Alias List Entry
  MOV  BX,SI            ;Save End-of-Entry Pointer
  CMP  AL,[SI+1]        ;Is this entry a match?
  JNE >P50              ;If not, go to the next one
  MOV  SI,DX            ;Point at Alias String
P40:                    ;Loop to here for each Alias String
  CMP  B [SI],0         ;End of the entry?
  JE  >P50              ;If so, we're done
  MOV  [DI],SI          ;If not, store it in the sort table
  INC  DI,2             ;Update the Table Pointer
  CALL SkipOverStringSI ;Skip over the string
  JMP  P40              ;Keep going until we have all of the strings
P50:                    ;Done with this entry
  MOV  SI,BX            ;Get End-of-Entry Pointer
  INC  SI,2             ;Skip over End-of-Entry stuff
  CMP  B [SI],0         ;End of Table?
  JNE  P10              ;If not, keep looking
P90:                    ;Done
  MOV  W [DI],0         ;Make sure last entry is a 0
  CMP  CX,DI            ;Set return flag
  POP  SI,DI            ;Restore used registers
  POP  DX,CX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ALL ALIAS STRINGS FOR A SINGLE CHARACTER OPTION
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = Alias String Pointer Table (Sorted backwards)
;                  Last Entry is a 0
;          CL  = Number of characters left available to write on first line
;                 (76 if Writing Numbers, 78 if Writing Characters)
;         CLD already issued
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteAliases:
  PUSH AX,BX,CX,DX    ;Save used registers
  PUSH DI,SI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at the Local Data Area
  MOV  BL,CL          ;BL = Character Countdown Measurer
  MOV  BH,CL          ;BH = Original Counter
  MOV  DX,DI          ;Save start-of-table Pointer
  MOV  CX,-1          ;Maximize counter
  XOR  AX,AX          ;Find the last
  REPNE SCASW         ;  entry in
  SUB  DI,4           ;  the Table
W10:                  ;Loop to here for each Alias String
  CMP  DI,DX          ;Are we done writing?
  JB  >W90            ;If so, quit
  MOV  SI,[DI]        ;Get the next string
  DEC  DI,2           ;Update the table pointer
  CALL CalcStrSizeSI  ;See how long the string is
  OR   BL,BL          ;Is the character counter down to 0?
  JZ  >W20            ;If so, we need to reset it
  CMP  CL,BL          ;Is this string too long to fit on this line?
  JB  >W40            ;If not, go ahead and write it
W20:                  ;Need to start a new line
  CALL WriteCrLfPause ;Start a new line
  PUSH CX             ;Save String Size for a second
  MOV  CL,79          ;Calculate how many
  SUB  CL,BH          ;  spaces to write
  CALL WriteSpaces    ;Write the spaces
  POP  CX             ;Restore String Size
  MOV  BL,BH          ;Reset the character counter
W40:                  ;Write the Alias String
  SUB  BL,CL          ;Update the
  DEC  BL             ;  character counter
  CALL WriteSpace     ;Write a Space
  CALL WriteZPauseSI  ;Write the string
  JMP  W10            ;Keep writing
W90:                  ;Done
  CALL WriteCrLfPause ;Move down
  POP  ES,SI,DI       ;Restore used registers
  POP  DX,CX,BX,AX    ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE THE ERRORLEVEL TABLE
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE ERRORLEVEL TABLE TO THE SCREEN AND QUIT
;Inputs:  CS = DS = Local Data Area
;Outputs: Writes ErrorLevel Table to the Screen
;Changes: Quits Program
;         Several registers
;------------------------------------------------------------------------------
DoErrLvls:
  TEST ProgFlags2,ErrLvl    ;Does the user want to see the ErrorLevels?
  JZ  >V95                  ;If not quit
  MOV  DX,ErrLvlHdr         ;Write the
  CALL SetupPause           ;  Table Header
  MOV  AL,1                 ;Start with ErrorLevel 1
V10:                        ;Loop to here for each table entry
  MOV  BX,ErrLvlTbl         ;Table to search
  CALL SearchByte2StringTbl ;Valid ErrorLevel?
  JC  >V50                  ;If not, keep looking
  CALL WriteSpace           ;Move Over
  CALL ByteToString         ;If valid, write the Number
  CALL WriteSpace           ;Write a space
  MOV  DX,BX                ;Write the
  CALL WriteZPause          ;  Description String
  CALL WriteCrLfPause       ;Write a New Line
V50:                        ;Done with this entry
  INC  AL                   ;Increment ErrorLevel
  JNZ  V10                  ;If not rolled over yet, keep looking
V90:                        ;Done
  MOV  DX,NoMsg             ;Don't write anything
  XOR  AL,AL                ;ErrorLevel = 0
  JMP  Exit                 ;Quit
V95:                        ;No need to write Aliases
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE DEVICE/CONFIG DESCRIPTORS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE DESCRIPTORS OF THE LAST DEVICE TO THE SCREEN, IF NECESSARY
;Inputs:  ES:DescriptorData
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoDescriptors:
  TEST StatusFlags,Descriptors ;Does the user want to see the Descriptors?
  JZ  >D000                    ;If not, quit
  TEST ProgFlags,InMemory      ;Are we installed in memory yet?
  JNZ >D00                     ;If so, go ahead and do it
  MOV  DX,DescrErrMsg          ;If not, point at first part of Error Message
  JMP  FinishDataErr           ;Terminate program
D000:
  RET

D00:
  CALL TestLastDevice          ;Anything to do (quits if not)?
  MOV  DI,ES:LastDeviceFound   ;Get Info Table Pointer
  MOV  AX,ES                   ;Write the address
  MOV  CX,DvcDescrData         ;  of the Descriptor Data
  MOV  BX,DescriptorMsgAddr    ;  to the
  CALL WriteSegmentOffset      ;  Command Line Parameters
  MOV  BX,DescriptorMsgHost    ;Write
  MOV  AL,ES:[DI].DIHostIndex  ;  the
  CALL WriteByteToString       ;  Host Index
  INC  BX                      ;  and the
  MOV  AL,ES:[DI].DIDvcAddress ;  Device Address
  CALL WriteByteToString       ;  to the string
  MOV  AX,CS                   ;Write our
  MOV  CX,WriteZPauseFar       ;  Call-Back Address
  MOV  BX,DescriptorCallBk     ;  to the
  CALL WriteSegmentOffset      ;  Command Tail String
  MOV  BX,DescriptorMsg        ;Copy our String
  CALL CopyToCmdTail           ;  to the Command Tail String
  CALL DoExec                  ;Write the Descriptors
  MOV  DX,NoMsg                ;Write nothing
  XOR  AL,AL                   ;ErrorLevel = 0
  JMP  Exit                    ;Quit


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE NEEDED TO WRITE USB DESCRIPTORS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST AND SEE IF WE CAN PRINT A DESCRIPTOR (LASTDEVICEFOUND & SUPPORTFILE)
;Inputs:  ES = TSR Data Area
;         LastDeviceFound
;Outputs: Quits program if error
;         Initializes PathToUse, Prints Header if OK
;Changes:
;------------------------------------------------------------------------------
TestLastDevice:
  PUSH AX,DX,SI                    ;Save used registers
  MOV  SI,ES:LastDeviceFound       ;Get the Device Pointer that this is for
  TEST ES:[SI].DIFlags,DIFlagInUse ;Device still there?
  JNZ >L10                         ;If so, continue
  MOV  DX,NoDescrDataMsg           ;Point at Error Message
  MOV  AL,ErLvlNoData              ;ErrorLevel = No Data
  JMP  Exit                        ;Quit
L10:                               ;Have some Data
  CALL TestSupportFile             ;Look for the Support File in the Path
  JNZ >L20                         ;If found, continue
  MOV  DX,NoSuptFileMsg            ;If not, write first part
  CALL WriteZErr                   ;  of Error Message
  MOV  DX,SupportFile              ;Write the
  CALL WriteZErr                   ;  File Name
  JMP  Exit                        ;Quit

L20:                               ;Everything is OK
  MOV  DX,HostIndexMsg             ;Write
  CALL WriteZPause                 ;  the
  MOV  AL,ES:[SI].DIHostIndex      ;  Host
  CALL ByteToString                ;  Index
  CALL WriteCrLfPause              ;Write a new line
  MOV  DX,DvcAddressMsg            ;Write
  CALL WriteZPause                 ;  the
  MOV  AL,ES:[SI].DIDvcAddress     ;  Device
  CALL ByteToString                ;  Address
  CALL WriteCrLfPause2             ;Write 2 new lines
L90:                               ;Done
  POP  SI,DX,AX                    ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO TEST AND SEE IF THE COMPUTER IS COMPATIBLE OR NOT.
;TESTS DOS VERSION, HARDWARE INSTALLED, ETC. AS APPROPRIATE TO MAKE SURE
;  WE DON'T DO SOMETHING THAT COULD CRASH THE COMPUTER.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST THE COMPUTER TO SEE IF IT'S COMPATIBLE (CPU, DOS VERSION, WHATEVER)
;Inputs:  InMemory
;Outputs: Quits the program if Computer is Incompatible
;         Returns if Computer is OK
;         Stores all kinds of values in memory variables
;Changes:
;------------------------------------------------------------------------------
TestCompatibility:
  PUSH AX,DX              ;Save used registers
  TEST ProgFlags,InMemory ;Are we already installed?
  JNZ >C90                ;If so, no need to test again
  MOV  AL,ErLvlDOSVer     ;Assume incorrect
  MOV  DX,DOSVerMsg       ;  DOS Version
  CALL TestDOSVer         ;  new enough?
  JNC >C90                ;If not, we're OK
C70:                      ;The computer is incompatible for some reason
  JMP  Exit               ;Quit!
C90:                      ;The computer is compatible!
  POP  DX,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST THE CURRENT DOS VERSION
;Inputs:  MinDOSVer (EQUate)
;Outputs: CF = Clear if DOS version >= MinDOSVer
;         CF = Set if DOS version < MinDOSVer
;Changes:
;------------------------------------------------------------------------------
TestDOSVer:
  PUSH AX,BX,CX     ;Save used registers
  MOV  AX,3000h     ;Service 30h (get DOS version number)
                    ;  DOS 5.0 requires AL = 00h, may change BX and CX
  INT  21h          ;Do it (Returns AL= Major, AH = Minor)
  XCHG AL,AH        ;Swap Major and Minor versions for testing
  CMP  AX,MinDOSVer ;Is the version new enough?
  JAE >D80          ;If so, it's OK
D70:                ;DOS is older than the minimum
  STC               ;Set the "too old" flag
  JMP >D90          ;We're done
D80:                ;DOS is >= the minimum
  CLC               ;Set the OK flag
D90:                ;We're done
  POP  CX,BX,AX     ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO ASSUME/RELINQUISH OWNERSHIP OF THE REDIRECT TABLE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;ASSUME OWNERSHIP OF THE REDIRECT TABLE, IF APPROPRIATE
;Inputs:  DS = ES = TSR Data Area
;         Our TSR is not installed yet!
;Outputs: TSRFlags.RedirTblHere set if we are first Extended INT 17h TSR
;Changes:
;NOTES: This is called during Program Installation, before we have assumed
;         control of INT 17h.
;------------------------------------------------------------------------------
SetRedirTbl:
  CALL TSRInstallCheck       ;Another Extend INT 17h TSR already installed?
  JZ  >R90                   ;If so, don't do anything
  OR   TSRFlags,RedirTblHere ;If not, we're the Table Owner
R90:                         ;Done
  RET

;------------------------------------------------------------------------------
;RELINQUICH OWNERSHIP OF THE REDIRECT TABLE
;Inputs:  ES = TSR Data Area
;Outputs: If we are the current Owner:
;           Issues INT 17h Extended Request notifying other TSR's of Uninstall
;           Marks us as no longer the Owner
;         If not the current Owner:
;           Does nothing
;Changes:
;NOTES: This is called during Program UnInstallation, before we have
;         relinquished control of INT 17h.
;------------------------------------------------------------------------------
RelinquishRedirTbl:
  PUSH AX,BX,CX,DX                    ;Save used registers
  TEST ES:TSRFlags,RedirTblHere       ;Are we the Owner?
  JZ  >R90                            ;If not, we're done
  MOV  AX,(1B00h+I17FRedirGoingAway)  ;Function = Owner is Uninstalling
  MOV  DX,-1                          ;Set Register Value
  INT  17h                            ;Do it
                                      ;  If we are only TSR, AX=unchanged
                                      ;  If another TSR is now the Owner, AX=0
  AND  ES:TSRFlags,(NOT RedirTblHere) ;Mark us as no longer the Owner
R90:                                  ;Done
  POP  DX,CX,BX,AX                    ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO FIND AN AVAILABLE IO ADDRESS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;FIND AN AVAILABLE I/O ADDRESS SPACE TO USE
;Inputs:  DS = ES = TSR Data Area
;Outputs: IOAddress (if not already filled in)
;Changes:
;------------------------------------------------------------------------------
AssignIOAddress:
  PUSH AX               ;Save used registers
  CMP  IOAddress,0      ;Is an address already assigned?
  JNE >I90              ;If so, we're done
  MOV  AX,24            ;Size of Address Space needed (in Bytes)
  CALL FindAvailIOSpace ;Find an available I/O Space Base Address
  MOV  IOAddress,AX     ;Store it
I90:                    ;Done
  POP  AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND AN AVAILABLE I/O SPACE
;Inputs:  AX = Number of Bytes of I/O Space needed
;Outputs: AX = I/O Space that appears free (all 1's)
;Changes:
;NOTES: This code looks for an I/O Space of all 1's, and then attempts to
;         change the Code to all 0's.  If it is a truly free (available)
;         I/O Space, the change to all 0's will not work since there is
;         no Device "attached" to the I/O Space to store the changes.
;         If the change DOES work, the space is not really available, and
;         we change it back to all 1's again and keep looking.
;         Hopefully, us messing with a "live" I/O Space like this won't
;         screw up the Device the I/O Space is controlling.
;       This does not return an error flag, since we should always
;         be able to find an I/O Range to use.  We also do not check the
;         validity of AX on entry.  A "bad" value in AX could cause us
;         all kinds of grief!
;       This code will "round up" the number of bytes to a multiple
;         of 32, and will always align the I/O Base Address with a
;         32-byte paragraph boundary.
;------------------------------------------------------------------------------
FindAvailIOSpace:
  PUSH CX,DX,DI            ;Save used registers
  OR   AX,AX               ;AX = 0?
  JNZ >O10                 ;If not, assume it's OK
  INC  AX                  ;If so, make it a 1
O10:                       ;AX > 0
  ADD  AX,31               ;Round up
  MOV  CL,5                ;  number of bytes needed
  SHR  AX,CL               ;  to a multiple of 32
  DEC  CL                  ;  and convert nubmer of Bytes
  SHL  AX,CL               ;  to number of Words
  MOV  CX,AX               ;Save the Counter
  MOV  DI,MinIOAddress     ;Load starting address
O20:                       ;Loop to here for each I/O Space
  CALL TestIOSpaceForAll1s ;Is the I/O Space filled with ones?
  JC  >O60                 ;If not, keep looking
  CLI                      ;Disable interrupts
  CALL FillIOSpaceWith0s   ;If so, try to fill it with 0s'
  CALL TestIOSpaceForAll1s ;Is the I/O Space still filled with ones?
  JNC >O90                 ;If so, we have our I/O Space!
  CALL FillIOSpaceWith1s   ;If not, fill it back up with ones again!
O60:                       ;Not a valid I/O Space
  STI                      ;Enable Interrupts
  ADD  DI,32               ;Point at the next I/O Space
  JMP  O20                 ;Keep looking
O90:                       ;Have our Address Space (DI)
  STI                      ;Enable Interrupts
  MOV  AX,DI               ;Put the I/O Address in AX for the Return
  POP  DI,DX,CX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ATTEMPT TO FILL I/O SPACE WITH ALL ZEROES OR ALL ONES
;Inputs:  DI = Base I/O Address
;         CX = Number of Words in I/O Space
;Outputs: Attempts to Write All 0's or All 1's to an I/O Space
;Changes:
;------------------------------------------------------------------------------
FillIOSpaceWith0s:
  PUSH AX    ;Save used registers
  XOR  AX,AX ;Fill with Zeroes
  JMP >F00   ;Do it
FillIOSpaceWith1s:
  PUSH AX    ;Save used registers
  MOV  AX,-1 ;Fill with All Ones
;  JMP >F00   ;Do it
F00:
  PUSH CX,DX ;Save used registers
  MOV  DX,DI ;Put Base (Starting) I/O Address in DX
F10:         ;Loop to here for each I/O Address
  OUT  DX,AX ;Write the Next Word
  INC  DX,2  ;Point at the next I/O Address
  LOOP F10   ;Keep going until we're done
  POP  DX,CX ;Restore used registers
  POP  AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHECK AND SEE IF AN I/O SPACE IS FILLED WITH ONES
;Inputs:  DI = Base I/O Address
;         CX = Number of Words in I/O Space
;Outputs: CF = Clear if I/O Space is filled with ones
;            = Set if not all ones
;Changes:
;------------------------------------------------------------------------------
TestIOSpaceForAll1s:
  PUSH AX,CX,DX ;Save used registers
  MOV  DX,DI    ;Put Base (Starting) I/O Address in DX
A10:            ;Loop to here for each I/O Address
  IN   AX,DX    ;Get the Next Word
  CMP  AX,-1    ;Is it all ones?
  JNE >A70      ;If not, we're done
  INC  DX,2     ;Point at the next I/O Address
  LOOP A10      ;Keep going until we're done
  JMP >A80      ;It's all ones!
A70:            ;Not all Ones
  STC           ;Set return flag
  JMP >A90      ;Done
A80:            ;All Ones
  CLC           ;Set Return Flag
A90:            ;Done
  POP  DX,CX,AX ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO SET UP COMMAND TAIL WITH PROPER PARAMETERS FOR EXEC CALL
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE A SEGMENT:OFFSET COMBINATION TO A STRING VARIABLE
;Inputs:   AX  = Segment to Write
;          CX  = Offset to Write
;         [BX] = String to Write to
;Outputs: Converts AX:CX to a Hex String and stores at [BX]
;Changes:
;------------------------------------------------------------------------------
WriteSegmentOffset:
  PUSH AX,DI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at Local Data Area
  MOV  DI,BX          ;Point DI at String
  CALL Word2HexString ;Store the Segment
  MOV  AL,':'         ;Store the
  STOSB               ;  Colon
  MOV  AX,CX          ;Store
  CALL Word2HexString ;  the Offset
  POP  ES,DI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A WORD AS HEX TO A STRING
;Inputs:   AX  = Word to Write
;         [BX] = String to write to
;Outputs:
;Changes: BX
;------------------------------------------------------------------------------
WriteWordToString:
  PUSH AX,DI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at Local Data Area
  MOV  DI,BX          ;Point DI at String
  CALL Word2HexString ;Store the Word
  MOV  AL,'h'         ;Write the
  STOSB               ;  'h'
  ADD  BX,5           ;Update Pointer
  POP  ES,DI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE AS HEX TO A STRING
;Inputs:   AL  = Byte to Write
;         [BX] = String to write to
;Outputs:
;Changes: BX
;------------------------------------------------------------------------------
WriteByteToString:
  PUSH AX,DI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at Local Data Area
  MOV  DI,BX          ;Point DI at String
  CALL Byte2HexString ;Store the Byte
  MOV  AL,'h'         ;Write the
  STOSB               ;  'h'
  ADD  BX,3           ;Update Pointer
  POP  ES,DI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY A STRING INTO THE COMMAND TAIL
;Inputs:  [BX] = ASCIIZ String to Copy
;Outputs: To CmdTail
;Changes:
;------------------------------------------------------------------------------
CopyToCmdTail:
  PUSH AX,CX,DX,DI,SI,ES ;Save used registers
  MOV  ES,DS             ;Point ES at Local Data Area
  MOV  CX,(CmdTailMax/2) ;Number of Words to Copy
  MOV  AX,CR+(CR SHL 8)  ;Fill with CR's
  MOV  DI,CmdTail        ;Point at Command Tail
  PUSH DI                ;Save Pointer
  REP  STOSW             ;Fill the Command Tail
  POP  DI                ;Restore Pointer
  MOV  DX,BX             ;Calculate number of bytes
  CALL CalcStrSizeDX     ;  to copy
  MOV  CmdTailSize,CL    ;Store the Command Tail Size
  MOV  SI,BX             ;Copy the string
  REP  MOVSB             ;  to the Command Tail
  POP  ES,SI,DI,DX,CX,AX ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO EXEC ANOTHER PROGRAM
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SETUP PARAMETERS TO BE ABLE TO PERFORM THE EXEC FUNCTION
;Inputs:
;Outputs:
;Changes: Lots of stuff
;------------------------------------------------------------------------------
SetupExec:
  PUSH AX,SI                       ;Save used registers
  MOV  SI,ParamBlock               ;Point at Parameter Block
  MOV  AX,CS                       ;Use our data segment
  MOV  [SI].PBEnvirSegment,0       ;Use Copy of our Environment
  MOV  W [SI].PBCmdTailPtr[0],OFFSET CmdTailSize
  MOV  W [SI].PBCmdTailPtr[2],AX   ;Command Tail Pointer
  MOV  W [SI].PBFCB1Offset[0],FCB1
  MOV  W [SI].PBFCB1Offset[2],AX   ;FCB #1 Pointer
  MOV  W [SI].PBFCB2Offset[0],FCB2
  MOV  W [SI].PBFCB2Offset[2],AX   ;FCB #2 Pointer
  POP  SI,AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PERFORM THE EXEC FUNCTION
;Inputs:  ParamBlock set up with appropriate data
;         CmdTail/CmdTailSize set up with appropriate Info
;         PathToUse contains Child Program to Call
;         DS = Our data Area
;Outputs: CF = Clear if Program Returned ErrorLevel 0
;Changes: Performs EXEC Function
;------------------------------------------------------------------------------
DoExec:
  PUSH ES            ;Save used register
  MOV  ES,DS         ;Point ES at our Data Area
  PUSH AX,BX,CX,DX   ;Save all registers
  PUSH DI,SI,BP      ;Save all registers
  MOV  OldSPExec,SP  ;Save the Stack Pointer (may be destroyed by Call)
  MOV  DX,PathToUse  ;DS:[DX] = Child Program to Run
  MOV  BX,ParamBlock ;ES:BX = Parameter Block
  MOV  AX,4B00h      ;Function 4B00h (Load and Execute child program)
  INT  21h           ;Do it (May Destroy BX & DX)
  JC  >X70           ;If Error, quit
X00:                 ;When the Child Program Exits, here we are!
  CLD                ;Go forward with string functions
  CLI                ;Disable interrupts
  MOV  DS,CS         ;Restore
  MOV  ES,DS         ;  all
  MOV  SS,CS         ;  Segments
  MOV  SP,OldSPExec  ;Restore Stack Pointer
  STI                ;Enable interrupts
  MOV  AH,4Dh        ;Function 4Dh (Get ErrorLevel)
  INT  21h           ;Do it (Returns AH = Term Type, AL = ErrorLevel)
  OR   AL,AL         ;ErrorLevel 0?
  JZ  >X80           ;If so, it was OK
X70:                 ;Error
  STC                ;Set Error Flag
  JMP >X90           ;Done
X80:                 ;OK
  CLC                ;Set OK Flag
X90:                 ;Done
  POP  BP,SI,DI      ;Restore all registers
  POP  DX,CX,BX,AX   ;Restore all registers
  POP  ES            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;LOOK FOR THE SUPPORT FILE SOMEWHERE IN THE PATH
;Inputs:  DS = Local Data Area
;         SupportFile
;         ProgFlags.FoundSuptFile = False
;Outputs: ZF = Clear if Support File Found
;              ProgFlags.FoundSuptFile = True
;Outputs: ZF = Set if Support File Not Found
;              ProgFlags.FoundSuptFile = False
;Changes:
;------------------------------------------------------------------------------
TestSupportFile:
  PUSH DI,SI                ;Save used registers
  MOV  SI,OFFSET ProgFlags  ;Point [SI] at ProgFlags
  MOV  DI,SupportFile       ;Look for the
  CALL FindSupportFile      ;  Support File
  JC  >S90                  ;If not found, quit
  OR   B [SI],FoundSuptFile ;If found, mark it as found
S90:                        ;Done
  TEST B [SI],FoundSuptFile ;Set return flag
  POP  SI,DI                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE LOCATION OF THE SUPPORT FILE
;Inputs:  [DI] = FIleName to Look for
;Outputs: CF = Clear if OK (File Found)
;              PathToUse = Path & FileName Concatenated Together
;            = Set if Error (File not Found)
;              PathToUse = Undefined
;Changes: Various Path pointer Registers (OurPathPointer, PathVarPointer, etc.)
;------------------------------------------------------------------------------
FindSupportFile:
  PUSH AX,SI,DS,ES       ;Save used registers
F10:                     ;Do Our Path
  MOV  SI,OurPathPointer ;Point SI at our Path pointer
  CMP  SI,-1             ;Valid?
  JE  >F20               ;If not, skip it
  MOV  AX,[PSPEnvirSeg]  ;Point ES at
  MOV  ES,AX             ;  Environment Segment
  CALL CopyPathName      ;Copy it
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F20:                     ;Do Current Path
  MOV  ES,CS             ;Point ES at us
  MOV  SI,CurrentPath    ;If not, try the Current Path
  CALL CopyPathName      ;Copy it
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F30:                     ;Do Environment PATH
  MOV  SI,PathVarPointer ;SI = Environment PATH Pointer
  CMP  SI,-1             ;Is it valid?
  JE  >F70               ;If not, we're done
  MOV  AX,[PSPEnvirSeg]  ;Point ES at Path
  MOV  ES,AX             ;  (Environment) Segment
F35:                     ;Loop to here for each element in PATH
  CALL CopyPathName      ;Copy the PATH element
  JC  >F70               ;If End of Path, we're done
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F40:                     ;Loop to here to skip over PATH Element
  MOV  AL,ES:[SI]        ;Get next character
  INC  SI                ;Increment Pointer
  OR   AL,AL             ;End of PATH?
  JZ  >F70               ;If so, we're done
  CMP  AL,';'            ;End of PATH Element?
  JNE  F40               ;If not, Keep looking
  JMP  F35               ;Try the next Element
F70:                     ;Error
  STC                    ;Set Error Flag
  JMP >F90               ;Done
F80:                     ;Found our File
  CLC                    ;Set OK flag
F90:                     ;Done
  POP  ES,DS,SI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEE IF THE SUPPORT FILE EXISTS
;Inputs:  PathToUse
;Outputs: CF = Clear if OK (File Found)
;            = Set if Error (File not Found)
;Changes:
;------------------------------------------------------------------------------
FindFile:
  PUSH AX,BX,CX,DX   ;Save used registers
  PUSH DS,ES         ;Save used registers
  MOV  AH,2Fh        ;Function 2Fh (Get DTA Address)
  INT  21h           ;Do it (returns ES:BX)
  MOV  AH,1Ah        ;Function 1Ah (Set DTA Address)
  MOV  DX,FCB1       ;DS:DX = New DTA Address
  INT  21h           ;Do it
  MOV  AX,4E00h      ;Function 4Eh (Find First Matching File)
  MOV  CX,FAttrToUse ;Search for any file, including Hidden
  MOV  DX,PathToUse  ;DS:DX = ASCIIZ FileName to search for
  INT  21h           ;Do it (returns CF)
  PUSHF              ;Save return flag
  MOV  DS,ES         ;Point DS:DX
  MOV  DX,BX         ;  at the old DTA
  MOV  AH,1Ah        ;Function 1Ah (Set DTA Address)
  INT  21h           ;Do it
  POPF               ;Restore return flag
  POP  ES,DS         ;Restore used registers
  POP  DX,CX,BX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CREATE A COMPLETE PATH NAME GIVEN A PATH AND A FILE NAME
;Inputs:  ES:[SI] = Path name to Copy
;         DS:[DI] = FileName to Append to the Path
;Outputs: PathToUse = Path & File Concatenated Together
;NOTES: The Path String can either end with a 0 (ASCIIZ String) or a SemiColon
;         (the way strings are stored in the PATH Environment variable).
;       This code will properly handle an empty Path String, which will
;         simply set PathToUse to the FileName.
;       The FileName must be an ASCIIZ String.
;------------------------------------------------------------------------------
CopyPathName:
  PUSH AX,BX,CX,DI,SI,DS,ES  ;Save used registers
  PUSH DS                    ;Point ES
  PUSH ES                    ;  at our data,
  POP  DS                    ;  DS at
  POP  ES                    ;  Path Data
  MOV  BX,DI                 ;Save File Name Pointer
  XOR  AX,AX                 ;Fill with Zeroes
  MOV  CX,(MaxPathSize/2)    ;Number of Words to Write
  MOV  DI,PathToUse          ;Where to write them
  PUSH DI                    ;Save Pointer
  REP  STOSW                 ;Reset the Buffer
  POP  DI                    ;Restore Pointer
  XOR  CL,CL                 ;Start String Length Counter at 0
N10:                         ;Loop to here for each character in Path
  LODSB                      ;Get next character
  OR   AL,AL                 ;End of Path?
  JZ  >N20                   ;If so, do Filename
  CMP  AL,';'                ;End of Path (Environment PATH)?
  JE  >N20                   ;If so, do FileName
  INC  CL                    ;Increment String Length Counter
  STOSB                      ;If not, store the character
  JMP  N10                   ;Keep going
N20:                         ;Done with Path
  OR   CL,CL                 ;Any characters at all in the Path?
  JZ  >N30                   ;If so, is Current Path, and don't want backslash!
  CMP  B ES:[DI-1],Backslash ;Path ends in a Backslash?
  JE  >N30                   ;If so, it's OK
  MOV  AL,Backslash          ;If not, store
  STOSB                      ;  a Backslash
N30:                         ;Path is OK
  MOV  DS,ES                 ;Point DS:[SI]
  MOV  SI,BX                 ;  at the File Name
N40:                         ;Loop to here for each character in File name
  LODSB                      ;Get next character
  OR   AL,AL                 ;End of File Name?
  JZ  >N90                   ;If so, we're done
  STOSB                      ;If not, store it
  JMP  N40                   ;Keepgoing
N90:                         ;Done
  POP  ES,DS,SI,DI,CX,BX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE PATH THAT OUR PROGRAM IS IN
;Inputs:
;Outputs: OurPathPointer = Pointer to Our Path String (in Environment Segment)
;                        = -1 if we couldn't find our own Path
;Changes:
;------------------------------------------------------------------------------
GetOurPath:
  PUSH AX,CX,DI,SI,DS,ES    ;Save used registers
  MOV  AX,[PSPEnvirSeg]     ;Point DS & ES
  MOV  DS,AX                ;  at the
  MOV  ES,AX                ;  Environment segment
  XOR  DI,DI                ;Point at the beginning of Environment list
  MOV  CX,-1                ;Max out the count limiter
  XOR  AX,AX                ;Need to look for a double 0
U10:                        ;Loop to here to skip over Environment vars
  REPNE SCASB               ;Look for the end of this environment variable
  CMP  [DI],AL              ;Is it the end of the variable list (double 0)?
  JNE  U10                  ;If not, keep skipping over Environment vars
  CMP  [DI+1],AX            ;If so, is there a string after the Envir?
  JE  >U70                  ;If not, we're done
  ADD  DI,3                 ;Point DI and SI at the
  MOV  SI,DI                ;  True Name
  MOV  CS:OurPathPointer,DI ;Store the Pointer
U20:                        ;Loop to here to find the end of the PATH
  LODSB                     ;Get the next character of the name
  CMP  AL,':'               ;Is it a Colon?
  JE  >U30                  ;If so, possible end-of-path
  CMP  AL,Backslash         ;Is it backslash?
  JE  >U30                  ;If so, possible end-of-path
  OR   AL,AL                ;End of File Name?
  JZ  >U50                  ;If so, we're done
  JMP >U40                  ;If not, keep looking
U30:                        ;Update end-of-path Pointer
  MOV  DI,SI                ;Save possible end-of-path pointer
U40:                        ;Not end-of-path yet
  JMP  U20                  ;Keep looking
U50:                        ;At end of Path
  CMP  DI,CS:OurPathPointer ;Was there a real path?
  JE  >U70                  ;If not, error
  MOV  B [DI],0             ;If OK, put 0 at end of Path
  JMP >U90                  ;Done
U70:                        ;No Path
  MOV  CS:OurPathPointer,-1 ;Set Pointer
U90:                        ;Done
  POP  ES,DS,SI,DI,CX,AX    ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO AUTOMATICALLY MOVE THE PROGRAM INTO UPPER MEMORY
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TRY TO ALLOCATE A UMB, AND COPY THE PROGRAM TO THE UMB SEGMENT
;Inputs:  DS = ES = Current Data Segment
;Outputs: ES = New Data Segment (in UMB or Low Memory Hole)
;              If no UMB or Low Memory Hole is available, ES remains unchanged
;         Entire TSR Portion of Program is copied to new Segment
;Changes:
;------------------------------------------------------------------------------
MoveProgramToUMB:
  PUSH AX,BX,CX,DX,DI,SI      ;Save used registers
  MOV  AX,DS                  ;Save original Data Segment
  CMP  AX,0A000h              ;Already in Upper Memory?
  JAE >U90                    ;If so, just quit
  TEST ProgFlags,UseLowMemory ;Does user want us in Low Memory?
  JNZ >U90                    ;If so, just quit
  MOV  BX,(LastTSRByte SHR 4) ;Number of Paragraphs to Allocate
  CALL AllocateUMBDOS         ;Try to get a UMB from DOS (Returns ES)
  JZ  >U90                    ;If it didn't work, quit
  MOV  DX,ES                  ;Save new Segment
  PUSH DS                     ;Save data Segment
  MOV  AX,DS                  ;Point DS
  DEC  AX                     ;  at current
  MOV  DS,AX                  ;  MCB
  MOV  AX,ES                  ;Point ES
  DEC  AX                     ;  at new
  MOV  ES,AX                  ;  MCB
  MOV  SI,OFFSET MCBOwnerName ;Copy
  MOV  DI,SI                  ;  the
  MOV  CX,4                   ;  Owner
  REP  MOVSW                  ;  Name
  POP  DS                     ;Restore Data Segment
  MOV  ES:[MCBOwnerID],DX     ;Make itself the Owner
  MOV  AH,26h                 ;Function 26h (Create new PSP, DX = Segment)
  INT  21h                    ;Do it
  MOV  ES,DX                  ;Point ES at new Segment again
  ADD  DX,BX                  ;Calculate where next Segment will be
  MOV  ES:[PSPNextSegment],DX ;Store it in the PSP
  MOV  CL,3                   ;Calculate
  SHL  BX,CL                  ;  number
  MOV  CX,BX                  ;  of words
  SUB  CX,(PSPStrucSize/2)    ;  to Copy
  MOV  SI,PSPStrucSize        ;SI = Old Data
  MOV  DI,SI                  ;DI = New Data
  REP  MOVSW                  ;Copy Program to new Segment
  OR   ProgFlags,MemoryMoved  ;Mark memory as having been moved
U90:                          ;Done
  POP  SI,DI,DX,CX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TRY TO ALLOCATE A UMB THROUGH DOS
;Inputs:  BX = Number of Paragraphs to Allocate
;Outputs: ZF = Clear if OK
;              ES = Segment of Allocated UMB
;            = Set if Error
;              ES = Unchanged
;Changes:
;NOTES: Allocating USB's through DOS normally requires a
;         DOS=HIGH,UMB line in CONFIG.SYS
;------------------------------------------------------------------------------
AllocateUMBDOS:
  PUSH AX,BX,CX,DX   ;Save used registers
  PUSH DI,SI         ;Save used registers
  MOV  CX,ES         ;Save original ES
  MOV  DI,BX         ;Save Number of Paragraphs to Allocate
  MOV  AX,5800h      ;Function 5800h (Get Memory Allocation Strategy)
  INT  21h           ;Do it (returns AX)
  JC  >D90           ;If error, quit
  MOV  SI,AX         ;If OK, save it
  MOV  AX,5802h      ;Function 5802h (Get UMB Link State - DOS 5+ Only)
  INT  21h           ;Do it (Returns AL)
  JC  >D90           ;If error, quit
  MOV  DL,AL         ;If OK, Save it
  MOV  BX,UMBLinkYes ;Enable USB's in DOS Memory Chain
  MOV  AX,5803h      ;Function 5803h (Set UMB Link State)
  INT  21h           ;Do it
  JC  >D90           ;If error, quit
  MOV  BX,StrategyHighLowBest ;Strategy = Try High, then Low, Best Fit
  MOV  AX,5801h      ;Do
  INT  21h           ;  it
  JC  >D80           ;If error, quit
D20:                 ;Strategy is set
  MOV  BX,DI         ;BX = # of Paragraphs to Allocate
  MOV  AH,48h        ;Function 48h (Allocate Memory)
  INT  21h           ;Do it (returns AX = Segment)
  JC  >D80           ;If error, quit
  MOV  ES,AX         ;If OK, put Segment in ES
  CMP  AX,0A000h     ;Is it really a UMB?
  JAE >D80           ;If so, continue
  MOV  DI,CS         ;If not, is it a memory "hole" lower in memory
  CMP  AX,DI         ;  than we are (from a previously removed TSR)?
  JB  >D80           ;If so, continue
  MOV  AH,49h        ;Function 49h (Free Memory, Segment in ES)
  INT  21h           ;Do it
  MOV  ES,CX         ;Restore original ES
D80:                 ;Restore original UMB Link State & Strategy
  XOR  BH,BH         ;Restore
  MOV  BL,DL         ;  original
  MOV  AX,5803h      ;  USB
  INT  21h           ;  Link State
  MOV  BX,SI         ;Restore original
  MOV  AX,5801h      ;  Memory Allocation
  INT  21h           ;  Strategy
D90:                 ;Done
  MOV  AX,ES         ;Set
  CMP  CX,AX         ;  Return Flag
  POP  SI,DI         ;Restore used registers
  POP  DX,CX,BX,AX   ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO COPY (PRINT) FILES TO A PRINTER
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET THE FILENAME FROM THE COMMAND LINE
;Inputs:  ES = TSR Data Area
;         SI = Command Line Pointer
;         CLD already issued
;Outputs: ZF = Clear if OK
;              FileNameBuffer contains FileName (may be LFN)
;            = Set if Error
;              FileNameBuffer Cleared
;Changes:
;NOTES: For this particular program, if we reach the end-of-line
;         while getting the file name, it is an error.
;       This is because the file name must be followed by an
;         LPT Port Number.  We check that here instead of checking
;         it later.
;       If we try to use this code for some other program, it may be
;         OK to have the file name at the end of the line.
;------------------------------------------------------------------------------
GetFileName:
  PUSH AX,CX,DI,ES            ;Save used registers
  MOV  ES,DS                  ;Point ES at Local (non-TSR) Data Area
  CALL ClearFileNameBuff      ;Reset the File Name Buffer
  MOV  DI,FileNameBuffer      ;Point at FileName Buffer
  MOV  CX,(MaxFileNameSize-1) ;Maximum File Name size
  XOR  AH,AH                  ;AH = Quote status
  CALL IsSpaceOrEOX           ;Find the first character of the FileName
  JZ  >F70                    ;If EOL, Error
  CMP  AL,'"'                 ;Is it a Double Quote?
  JE  >F10                    ;If so, handle it
  CMP  AL,"'"                 ;Is it a Single Quote?
  JE  >F10                    ;If so, handle it
  CMP  AL,"`"                 ;Is it a Left Quote?
  JE  >F10                    ;If so, handle it
  DEC  SI                     ;If none of these, point back at the character
  JMP >F20                    ;Get the Name
F10:                          ;First character of name is a quote
  MOV  AH,AL                  ;Store the Quote Character in AH
F20:                          ;Loop to here for each character in FileName
  CALL GetNextChar            ;Get the Next Character
  JZ  >F70                    ;If End-of-Line, Error
  OR   AH,AH                  ;Are there quotes around the Name?
  JNZ >F30                    ;If so, handle it
  CMP  AL,' '                 ;End of Name?
  JE  >F90                    ;If so, we're done
  JMP >F40                    ;If not, store it and keep looking
F30:                          ;Quotes areound the FileName
  CMP  AL,AH                  ;Is it the final quote?
  JE  >F90                    ;If so, we're done
F40:                          ;Character is part of FileName
  STOSB                       ;Store the Character in the FIleName
  LOOP F20                    ;If not full, keep looking for more characters
F70:                          ;Error
  CALL ClearFileNameBuff      ;Reset the File Name Buffer
F90:                          ;Done
  CMP  B FileNameBuffer[0],0  ;Set the Return Flag
  POP  ES,DI,CX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY (PRINT) FILE(S) SPECIFIED ON THE COMMAND LINE
;Inputs:  DS = Local (non-TSR) Data Area
;         ES = TSR Data Area
;         FileNameBuffer contains FileName Spec specified by the User
;         PrintIndex
;Outputs: Prints File(s) as specified
;Changes:
;------------------------------------------------------------------------------
PrintFiles:
  PUSH AX,BX,CX,DX       ;Save used registers
  PUSH DI,SI,BP,ES       ;Save used registers
  MOV  ES,DS             ;Point ES at local Data Area
  CALL ChangeFunkyInts   ;Point Funky Interrupts at us
  TEST StatusFlags2,CopyCancel ;Have we cancelled/errored previously?
  JNZ >P901              ;If so, just quit
  CALL FlushKbdBuff      ;Flush out the Keyboard Buffer
  CALL MoveDTA           ;Move the Disk Transfer Area
                         ;  (need to preserve the Command Line Tail)
  CALL GetPathEndPtr     ;Get the Path EndName Pointer (BP)
  CALL TestLFN           ;Long File Names supported?
  JNC >P40               ;If so, do everything with LFN
P10:                     ;LFN not supported
  MOV  AX,4E01h          ;Function 4Eh (Find First File, Prepend APPEND)
  MOV  CX,FileAttrRA     ;Maximum Attributes RA
  MOV  DX,FileNameBuffer ;DS:DX = FileName String (ASCIIZ)
  INT  21h               ;Do it (Fills DTA)
  JC  >P70               ;If Error, Quit
  CMP  ParseTest,Yes     ;Just the Test Run?
  JE  >P90               ;If so, we're done
  PUSH DX                ;Save used registers
  MOV  DX,PressEscMsg    ;Write the "Press Escape to Cancel Printing"
  CALL WriteZErr         ;  message to the screen
  POP  DX                ;Restore used registers
  CALL WriteFileReg      ;Write the File
P20:                     ;Loop to here for each additional File
  TEST StatusFlags2,CopyCancel ;Was the last file cancelled?
  JNZ >P90               ;If so, quit
  MOV  AH,4Fh            ;Function 4Fh (Find Next File)
  INT  21h               ;Do it (uses DTA, updates DTA)
  JC  >P90               ;If no more files, we're done
  CALL WriteFileReg      ;Write the File
  JMP  P20               ;Keep looking
P901:                    ;To avoid JMP > 128
  JMP >P90               ;Done
P40:                     ;LFN supported
  MOV  AX,714Eh          ;Function 714Eh (Find First File LFN)
  MOV  CX,FileAttrRA     ;Max Attributes RA, Min Attributes None
  MOV  DX,FileNameBuffer ;DS:DX= FileName String (ASCIIZ)
  MOV  SI,1              ;Use DOS Date/Time Format (don't really care)
  MOV  DI,FindFileBuffer ;ES:DI = Find File buffer
  STC                    ;Preset Error Flag
  INT  21h               ;Do it (Returns AX = Handle, CX = UniCode Flags)
  JC  >P70               ;If Error, Quit
  MOV  BX,AX             ;Save Search Handle
  CMP  ParseTest,Yes     ;Just the Test Run?
  JE  >P80               ;If so, we're done
  PUSH DX                ;Save used registers
  MOV  DX,PressEscMsg    ;Write the "Press Escape to Cancel Printing"
  CALL WriteZErr         ;  message to the screen
  POP  DX                ;Restore sued registers
  CALL WriteFileLFN      ;Write the File
P50:                     ;Loop to here for each additional LFN File
  TEST StatusFlags2,CopyCancel ;Was the last file cancelled?
  JNZ >P80               ;If so, quit
  MOV  AX,714Fh          ;Function 714Fh (Find Next File LFN)
                         ;BX = Handle, SI = Date/Time Format, ES:DI = Bfr
  STC                    ;Preset Error Flag
  INT  21h               ;Do it  (Returns AX = New handle???)
  JC  >P80               ;If no more files, we're done
  CALL WriteFileLFN      ;Write the File
  JMP  P50               ;Keep looking
P70:                     ;Error
  OR   StatusFlags2,CopyCancel ;Mark as cancelled
  CALL GetFileErrMsg     ;Point ExtraErrMsg at the correct String
  MOV  ParseError,Yes    ;Mark as an Error
  JMP >P90               ;Done
P80:                     ;Close LFN Search
  MOV  AX,71A1h          ;Function 71A1h (Close LFN Search)
                         ;BX = Handle
  INT  21h               ;Do it
P90:                     ;Done
  CALL RestoreFunkyInts  ;Point Funky Interrupts at original handlers
  POP  ES,BP,SI,DI       ;Restore used registers
  POP  DX,CX,BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;OPEN AND PRINT THE FILE FOUND
;Inputs:  DS = ES = Local Data Area
;         BP = PathEndPtr
;         PrintIndex
;         FileNameBuffer
;         DTABuffer/FindFileBuffer
;         CLD already issued
;Outputs: Writes "Printing" message followed by File Name to screen
;         Opens and Writes the File to Printer (indicated by PrinterIndex)
;Changes: FileNameBuffer
;------------------------------------------------------------------------------
WriteFileLFN:
  PUSH CX,SI             ;Save used registers
  MOV  CH,-1             ;Mark as LFN
  MOV  SI,OFFSET FindFileBuffer.FLLongName ;Point at the Long Name
  JMP >L00               ;Do it
WriteFileReg:
  PUSH CX,SI             ;Save used registers
  XOR  CH,CH             ;Mark as Short Name
  MOV  SI,OFFSET DTABuffer.FFFileName ;Point at the Name
;  JMP >L00               ;Do it
L00:
  PUSH AX,BX,DX,DI       ;Save used registers
  MOV  DX,PrintingMsg    ;Write the
  CALL WriteZErr         ;  Printing Message
  MOV  DX,SI             ;Write the
  CALL WriteZErr         ;  File Name
  CALL StartFace         ;Write the Status Start Message
  MOV  DI,BP             ;Point at the FileName part of Path
L10:                     ;Loop to here for each char in Name
  MOVSB                  ;Copy the Character
  CMP  B [SI-1],0        ;Was it the last character?
  JNE  L10               ;If not, keep copying
  OR   CH,CH             ;LFN's?
  JNZ >L30               ;If so, jump to handle it
L20:                     ;Short Names
  MOV  AH,3Dh            ;Function 3Dh (Open File)
  MOV  AL,OpenFileReadOnly+OpenFileDenyWrite ;Open as Read-Only, no changes
  MOV  CL,FileAttrRA     ;Max Attribs RA
  MOV  DX,FileNameBuffer ;DS:[DX] = File Name
  INT  21h               ;Do it
  JC  >L70               ;If Error, handle it
  JMP >L40               ;If OK, jump to Print it
L30:                     ;LFN
  MOV  AX,716Ch          ;Function 716Ch (Create/Open File)
  MOV  BX,OpenFileReadOnly+OpenFileDenyWrite ;Open as Read-Only, no changes
  MOV  CX,FileAttrRA     ;Max Attribs RA, Min Attribs None
  MOV  DX,1              ;Function = Open Existing File
  MOV  SI,FileNameBuffer ;DS:[SI] = File Name
  XOR  DI,DI             ;DI = Alias Hint
  STC                    ;Preset Error Flag
  INT  21h               ;Do it
  JC  >L70               ;If Error, handle it
L40:                     ;File is Opened (AX = Handle)
  MOV  BX,AX             ;Put Handle in BX
  CALL PrintIt           ;Print the File
  MOV  AH,3Eh            ;Function 3Eh (Close File)
                         ;BX = Handle
  INT  21h               ;Do it
  JMP >L90               ;Done
L70:                     ;Error Opening File (AX = Error Code)
  OR   StatusFlags2,CopyCancel ;Mark as cancelled/error
  CALL BeepErr           ;Beep the Speaker
  CALL WriteCrLfPause    ;Write a New Line
  CALL Write2Spaces      ;Move over
  CALL GetFileErrMsg     ;Write
  MOV  DX,ExtraErrMsg    ;  the
  CALL WriteZPause       ;  Error
  MOV  ExtraErrMsg,0     ;  Message
L90:                     ;Done
  CALL WriteCrLfPause    ;Write a New Line
  POP  DI,DX,BX,AX       ;Restore used registers
  POP  SI,CX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PRINT THE CONTENTS OF AN OPEN FILE
;Inputs:  DS = ES = Local Data Area
;         BX = File Handle (File already Opened)
;         PrintIndex
;         CLD already issued
;Outputs:
;Changes: TempBuffer
;------------------------------------------------------------------------------
PrintIt:
  PUSH AX,BX,CX,DX             ;Save used registers
  PUSH DI,SI,BP                ;Save used registers
  MOV  DI,BX                   ;Save File Handle
  XOR  BP,BP                   ;Set FirstRead to No & TextFile to No
P10:                           ;Loop to here to Print each filled Buffer
  MOV  AH,3Fh                  ;Function 3Fh (Read from File)
  MOV  BX,DI                   ;BX = Handle
  MOV  CX,TempBufferSize       ;CX = Number of bytes to read
  MOV  DX,TempBuffer           ;DS:[DX] = Buffer to store data
  INT  21h                     ;Do it
  JC  >P70                     ;If error, handle it
  OR   AX,AX                   ;Done reading File?
  JZ  >P80                     ;If so, we're done
  MOV  CX,AX                   ;Put number of bytes in CX
  CALL TestFormFeed            ;Test for Form Feed (BP)
  MOV  SI,DX                   ;Point [SI] at the Buffer
  MOV  DX,PrintIndex           ;DX = Printer Index to use
P30:                           ;Loop to here to print each character
  LODSB                        ;Get character to Print
  CALL PrintChar               ;Try to Print it
  JC  >P90                     ;If there was a problem, quit
  LOOP P30                     ;Keep going until we're done
  JMP  P10                     ;Keep going until EOF
P70:                           ;Error
  OR   StatusFlags2,CopyCancel ;Mark as cancelled
  CALL StopFace                ;Erase our Status (Face) Message
  CALL WriteCrLfErr            ;Move down
  MOV  DX,Space2Msg            ;Move
  CALL WriteZErr               ;  over
  CALL GetFileErrMsg           ;Write
  MOV  DX,ExtraErrMsg          ;  the
  CALL WriteZPause             ;  Error
  MOV  ExtraErrMsg,0           ;  Message
  CALL WriteCrLfPause2         ;Move down
  JMP >P90                     ;Done
P80:                           ;Send CR/FF if needed
  CALL StopFace                ;Erase the Status Message
  MOV  DX,PrintIndex           ;DX = Printer Index
  TEST BP,FileFlagDoFormFeed   ;Need to send a CR/FF?
  JZ  >P90                     ;If not, we're done
  MOV  AL,CR                   ;Print a
  CALL PrintChar               ;  Carriage Return
  JC  >P90                     ;If there was a problem, quit
  MOV  AL,FormFeed             ;Print a
  CALL PrintChar               ;  Form Feed
  MOV  DX,FFSentMsg            ;Tell the user
  CALL WriteZErr               ;  what we did
P90:                           ;Done
  POP  BP,SI,DI                ;Restore used registers
  POP  DX,CX,BX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PRINT A SINGLE CHARACTER TO THE PRINTER (INSIDE A COPY COMMAND)
;Inputs:  AL = Character to Print
;         DX = PrintIndex
;Outputs: Sends character to printer (using INT 17h)
;         CF = Clear if character was sent
;            = Set if Error, or user cancelled during the print
;              If unprinted, appropriate error message is written to screen
;                and StatusFlags2.CopyCancel is set
;Changes:
;NOTES: This will keep trying to send the character to the printer
;         for as long as 45 secoNds before giving up and assuming the printer
;         will never work.
;       This updates the Face Message, and also appropriately stops the
;         Face Message if there is an error or the user cancels.
;------------------------------------------------------------------------------
PrintChar:
  PUSH AX,BX,CX,DX,DI    ;Save used registers
  MOV  BX,OFFSET StatusFlags2 ;Point [BX] at StatusFlags2
  MOV  AH,I17FSendByte   ;Function = Print Character
  MOV  DI,AX             ;Save the character to print & Function
  MOV  CX,45000          ;Time out after 45 seconds
C10:                     ;Loop to here if character doesn't print
  TEST B [BX],DiskError  ;Was there a Disk Error?
  JNZ >C65               ;If so, handle it
  TEST B [BX],UserBreak  ;Did the user press Ctrl-C or Ctrl-Break?
  JNZ >C60               ;If so, handle it
  CALL GetKey            ;Did the user press the keyboard?
  JZ  >C20               ;If not, go ahead and print it
  CMP  AL,Escape         ;Is it Escape?
  JE  >C60               ;If so, handle a user cancellation
  CMP  AL,CtrlC          ;Is it Ctrl-C?
  JE  >C60               ;If so, handle a user cancellation
  JMP  C10               ;If not, see if another key is waiting
C20:                     ;OK to try and print the character
  CALL UpdateFace        ;Update the Status
  MOV  AX,DI             ;Try to print the character
  INT  17h               ;  (uses AX & DX, may destroy BX)
  CMP  AH,PStsNormal     ;Printer Normal (character printed OK)?
  JE  >C80               ;If so, we're done
  CMP  AH,PStsNoPrinter  ;If not, is the Printer Disconnected/Off-Line?
  JE  >C70               ;If so, quit
  CALL Delay1MS          ;If not, wait for 1 millisecond
  LOOP C10               ;Try it again
  JMP >C70               ;If we've tried long enough already, Error
C60:                     ;User cancelled the print
  MOV  AX,(1B00h+I17FJobCancel) ;Function = Job Cancel
  INT  17h               ;Do it
  MOV  DX,UserCancelMsg  ;Point at error message
  JMP >C75               ;Continue
C65:                     ;Disk/File Error
  MOV  DX,DiskErrMsg     ;Point at error message
  JMP >C75               ;Continue
C70:                     ;Printer timed out
  MOV  DX,PrinterErrMsg  ;Point at error message
C75:                     ;User Cancelled, Printer Timeout, or Disk Error
  CALL FlushKbdBuff      ;Clear out the keyboard buffer
  CALL StopFace          ;Erase our Status (Face) message
  OR   B [BX],CopyCancel ;Mark as cancelled
  CALL WriteZPause       ;Write the Error Message
  STC                    ;Set Error flag
  JMP >C90               ;Done
C80:                     ;OK
  CLC                    ;Set OK flag
C90:                     ;Done
  POP  DI,DX,CX,BX,AX    ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE NEEDED TO COPY (PRINT) FILES TO A PRINTER
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO HANDLE SPECIAL KEYSTROKES AND ERRORS WHILE PRINTING
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;CHANGE AND PROCESS "FUNKY" INTERRUPTS
;Inputs:  DS = ES = Local Data Area
;         CLD already issued
;Outputs: Certain Interrupt Vectors
;Changes:
;------------------------------------------------------------------------------
ChangeFunkyInts:
  PUSH SI               ;Save used registers
  MOV  SI,FunkyIntTable ;Point DS:[SI] at the Table of Interrupt Vectors
  CALL ChangeInts       ;Change them
  POP  SI               ;Restore used registers
  RET

RestoreFunkyInts:
  PUSH SI               ;Save used registers
  MOV  SI,FunkyIntTable ;Point DS;[SI] at the Table of Interrupt Vectors
  CALL RestoreInts      ;Restore them
  POP  SI               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INT 1Bh (Ctrl-Break) Handler
;------------------------------------------------------------------------------
Int1BHdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code
Int1B:
  OR   CS:StatusFlags2,UserBreak ;Mark as a Break Received
  IRET

;------------------------------------------------------------------------------
;INT 23h (Ctrl-C) Handler
;------------------------------------------------------------------------------
Int23Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code
Int23:
  OR   CS:StatusFlags2,UserBreak ;Mark as a Break Received
  IRET

;------------------------------------------------------------------------------
;INT 24h (DOS Critical Error) Handler
;------------------------------------------------------------------------------
Int24Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code
Int24:
  OR   CS:StatusFlags2,DiskError ;Mark as a Disk Error
  MOV  AL,CritErrFail            ;Return a Failure Result
  IRET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO HANDLE FILE NAMES AND PATHS WHILE PRINTING
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;MOVE THE DISK TRANSFER AREA TO A NEW LOCATION
;Inputs:  DS = Local (non-TSR) Data Area
;         DTABuffer
;Outputs:
;Changes:
;NOTES: The DTA and the Command-line arguments are both stored at the same
;         address (PSP:80h).  If we do any File Functions (Open/Read/etc.),
;         DOS uses the DTA to store File Information, which will destroy
;         our command-line arguments.  So, we either need to be completely
;         done processing the command-line before we do any file functions,
;         or we need to copy the command-line arguments to a new location,
;         or we need to relocate the DTA.  Pre-processing the entire
;         command-line is not a viable option here, so we either need to
;         relocate the command-line arguments or relocate the DTA.
;         Relocating the DTA is less memory-intensive and is pretty simple
;         to do, so that is our choice.
;------------------------------------------------------------------------------
MoveDTA:
  PUSH AX,DX        ;Save used registers
  MOV  AH,1Ah       ;Function 1Ah (Set Disk Transfer Area Address)
  MOV  DX,DTABuffer ;Point DS:DX at the New Address
  INT  21h          ;Do it
  POP  DX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESET THE FILENAME BUFFER TO ALL ZEROES
;Inputs:  DS = ES = Local (non-TSR) Data Area
;         CLD Already issued
;Outputs: Clears FileNameBuffer
;Changes:
;NOTES: This routine preserves flags!
;------------------------------------------------------------------------------
ClearFileNameBuff:
  PUSH AX,CX,DI               ;Save used registers
  PUSHF                       ;Save flags
  MOV  DI,FileNameBuffer      ;Point ES:DI at the Buffer
  MOV  CX,(MaxFileNameSize/2) ;Number of words to write
  XOR  AX,AX                  ;Write zeroes
  REP  STOSW                  ;Clear the Buffer
  POPF                        ;Restore Flags
  POP  DI,CX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THE OS SUPPORTS LONG FILE NAMES
;Inputs:  DS = ES = Local (non-TSR) Data Area
;Outputs: CF = Clear if System Supports LFN
;            = Set if no Support
;Changes: FileNameBuffer (Resets to 0)
;------------------------------------------------------------------------------
TestLFN:
  PUSH AX,DX,SI      ;Save used registers
  MOV  AX,7147h      ;Function 7147h (LFN Get Current Directory)
  XOR  DL,DL         ;Current Drive
  MOV  SI,TempBuffer ;DS:[SI] = Buffer to store Name in
  STC                ;Preset Error Flag
  INT  21h           ;Do it (returns CF)
  POP  SI,DX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE POINTER TO THE END OF THE PATH PART OF THE FILE NAME
;Inputs:  DS = ES = Local (non-TSR) Data Area
;         CLD already issued
;Outputs: BP = One byte past end of Path Part of FileName
;              (where to start copying File Name to)
;Changes:
;------------------------------------------------------------------------------
GetPathEndPtr:
  PUSH AX,SI             ;Save used registers
  MOV  SI,FileNameBuffer ;Point at FileName
  MOV  BP,SI             ;Start there (Assume no Path)
P10:                     ;Loop to here for each character in File Name
  LODSB                  ;Get the next character
  OR   AL,AL             ;End of FileName?
  JZ  >P90               ;If so, we're done
  CMP  AL,':'            ;Is it a Colon (end of Drive letter)?
  JE  >P40               ;If so, change our Pointer
  CMP  AL,BackSlash      ;Is it a BackSlash (end of Directory)?
  JNE >P50               ;If not, keep looking
P40:                     ;SI points at possible end-of-path
  MOV  BP,SI             ;Store the Pointer
P50:                     ;Go to next character
  JMP  P10               ;Keep looking
P90:                     ;Done
  POP  SI,AX             ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO CONVERT DOS FILE ERROR CODES TO ASCII DESCRIPTION MESSAGED
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;POINT AT THE CORRECT FILE ERROR MESSAGE
;Inputs:  DS = ES = Local (non-TSR) Data Area
;         CLD already issued
;         AX = Error Code
;Outputs: ExtraErrMsg (Pointer to the Extra Error Message)
;Changes:
;------------------------------------------------------------------------------
GetFileErrMsg:
  PUSH AX,SI            ;Save used registers
  MOV  SI,FileErrMsgTbl ;Point at Table of Error Messages
  OR   AH,AH            ;Is high byte 0?
  JNZ >M50              ;If not, just use the default message
  MOV  AH,AL            ;Store the Error Code in AH
M10:                    ;Loop to here for each Table Entry
  LODSB                 ;Get the Error Code from the Table
  CMP  AL,-1            ;End of the Table?
  JE  >M50              ;If so, use the Default Message
  CMP  AL,AH            ;Is it a match?
  JE  >M90              ;If so, we're done
  CALL SkipOverStringSI ;If not, skip over the String
  JMP  M10              ;Keep looking
M50:                    ;Unknown Error - Use Default Message
  MOV  SI,FileErrMsgDef ;Point at Default Error Message
M90:                    ;SI points at Error Message
  MOV  ExtraErrMsg,SI   ;Store the Pointer
  POP  SI,AX            ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO PROCESS AND WRITE THE FLASHING FACE CHARACTER WHILE PRINTING
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;START, STOP, OR UPDATE THE FACE CHARACTER (PRINTING INDICATOR)
;Inputs:  DS = ES = Local Data Area
;         TimerStart
;         FaceMsg
;Outputs:
;Changes: May change TimerStart and/or FaceMsg
;NOTE: We don't necesarily always start with the same face (Open or Closed),
;        but simply toggle between the two of them
;------------------------------------------------------------------------------
UpdateFace:
  PUSH AX,BX,DX      ;Save used registers
  CALL GetBIOSTimer  ;Get the current BIOS Clock Timer (AX)
  MOV  DX,AX         ;Save it momentarily
  SUB  AX,TimerStart ;How long has it been?
  CMP  AX,12         ;Has it been 12 Timer Ticks yet (about 2/3 seconds)?
  JB  >F90           ;If not, don't do anything
  MOV  TimerStart,DX ;If so, make this our new starting Timer
  JMP >F20           ;Jump to write the new face

StartFace:
  PUSH AX,BX,DX      ;Save used registers
  CALL GetBIOSTimer  ;Get the BIOS Clock Timer (AX)
  MOV  TimerStart,AX ;Save it
  MOV  DX,Space2Msg  ;Write 2 spaces
  CALL WriteZErr     ;  to ERR
  CALL GetCursor     ;Get the current cursor position (DX)
  OR   DL,DL         ;Is it Column 0?
  JNZ >F20           ;If not, it's OK
  MOV  DX,SpaceMsg   ;If so, we've rolled to a new line, and
  CALL WriteZErr     ;  need to add an extra space
F20:                 ;End-of-screen-line issues handled
  MOV  DX,FaceMsg    ;Point at the Face Message
  CALL WriteZErr     ;Write it
F30:                 ;Write Message and Update Face Message
  MOV  BX,DX         ;Point [BX] at
  INC  BX            ;  the Face character
  DEC  B [BX]        ;Decrement Face Character ASCII Code
  JNZ >F90           ;If not 0, it's 1 (hollow face) and it's OK
  MOV  B [BX],2      ;If not, it was 1, so make it 2 (filled face)
F90:                 ;Done
  POP  DX,BX,AX      ;Restore used registers
  RET

StopFace:
  PUSH DX            ;Save used registers
  MOV  DX,FaceEndMsg ;Overwite the Face
  CALL WriteZErr     ;  with a Space
  POP  DX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE LOWER WORD OF THE CLOCK TIMER IN THE BIOS DATA AREA
;Inputs:
;Outputs: AX = Lower word of BIOS Clock Timer
;Changes:
;------------------------------------------------------------------------------
GetBIOSTimer:
  PUSH DS                ;Save used registers
  MOV  AX,40h            ;Point DS at the
  MOV  DS,AX             ;  BIOS Data Area
  MOV  AX,[BIOSClockLoc] ;Get the Lowr Word of the Clock Timer
  POP  DS                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ OR SET CURSOR POSITION
;Inputs:  DH = Cursor Row (if setting position)
;         DL = Cursor Column (if setting position)
;Outputs: DH = Cursor Row
;         DL = Cursor Column
;Changes:
;------------------------------------------------------------------------------
GetCursor:
  PUSH AX       ;Save used register
  XOR  AH,AH    ;Flag for Get Cursor
;  JMP >C00      ;Do it
;PutCursor:
;  PUSH AX       ;Save used register
;  MOV  AH,-1    ;Flag for PutCursor
;C00:
  PUSH BX,CX,DS ;Save used registers
  PUSHF         ;Save flags
  CLI           ;Disable interrupts
  MOV  BX,40h   ;Point DS at
  MOV  DS,BX    ;  the BIOS data area
  MOV  BX,50h   ;Offset of the cursor locations
  XOR  CX,CX    ;Compensate
  MOV  CL,[62h] ;  for the
  ADD  BX,CX    ;  video
  ADD  BX,CX    ;  page
  OR   AH,AH    ;Are we getting the cursor?
  JNZ >C90      ;If not, just store it
  MOV  DX,[BX]  ;Get the cursor location
C90:
  MOV  [BX],DX  ;Store the cursor location
  POPF          ;Restore flags
  POP  DS,CX,BX ;Restore used registers
  POP  AX       ;Restore used register
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO PROCESS THE FORM-FEED BETWEEN FILES (FOR WILDCARD FILE NAMES)
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;TEST AND SEE IF WE NEED TO SEND A CR/FF AFTER PRINTING A FILE
;Inputs:  DS = ES = TSR Data Area
;         BP = File Flags
;         CX = Number of Bytes in Buffer
;         CLD already issued
;Outputs: BP = Updated File Flags
;Changes:
;NOTES: This will flag a CR/FF if it believes the file is a Text File, rather
;         than a Graphics File.  This code believes a file is Text if it is
;         very small (<20 bytes), or if the first several bytes of the file
;         do not contain any printer control characters (ASCII code < 32)
;         other than CR's and LF's, and the file does not begin with
;         a PostScript Header.
;       This should be a fairly accurate (though simple) test, since most
;         Graphics Files have some sort of Escape Sequence
;         (usually starting with an {Escape}E or {Escape}@) right at the
;         beginning of the file, and are also usually fairly large files.
;       If you, for some obscure reason, want to send a PostScript file
;         (which is actually a Text File) to a non-PostScript Printer,
;         it will not automatically get the CR/FF at the end of it.
;------------------------------------------------------------------------------
TestFormFeed:
  PUSH AX,CX,DI,SI             ;Save used registers
  TEST BP,FileFlagNotFirstRead ;First bytes of this file?
  JNZ >F90                     ;If not, we're done
  TEST ProgFlags,NoFormFeed    ;Do we even care about Form Feeds?
  JNZ >F90                     ;If not, we're done
  CMP  CX,20                   ;Is the file at least 20 bytes long?
  JBE >F80                     ;If not, assume it's Text
  MOV  SI,TempBuffer           ;Point SI at the first bytes of the File
  MOV  CX,10                   ;Test first 10 characters
F20:                           ;Loop to here to look for control characters
  LODSB                        ;Get the next character
  CMP  AL,' '                  ;Is it a Control Character?
  JAE >F30                     ;If not, keep looking
  CMP  AL,CR                   ;Is it a CR?
  JE  >F30                     ;If so, keep looking
  CMP  AL,LF                   ;Is it a Line Feed?
  JNE >F90                     ;If not, assume it's not Text
F30:                           ;Not a control character
  LOOP F20                     ;Keep testing the file
  MOV  SI,TempBuffer           ;Point SI at the first bytes of the File
  MOV  DI,PSFileHdr            ;Point DI at the PostScript File Header
  MOV  CX,PSFileHdrSize        ;Number of bytes to test
  REPE CMPSB                   ;Is it a PostScript File?
  JCXZ >F90                    ;If so, it's not Text
F80:                           ;Do CR/FF at end of File
  OR   BP,FileFlagDoFormFeed   ;Mark as needing to do it
F90:                           ;Done
  OR   BP,FileFlagNotFirstRead ;Mark as not the First time any more
  POP  SI,DI,CX,AX             ;Restore used registers
  RET


;;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;;TEMPORARY TEST CODE AND DATA - NOT NEEDED IN FINAL RELEASE OF PROGRAM
;;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;
;  IOCtlPString: DB 'LPT2',0
;
;  IOCtlParamBlock: ;GetDeviceID IOCTL Parameter Block
;    IOCtlFlags      DB 01h ;Don't return error for Short Packet
;    IOCtlReserved   DB 0
;    IOCtlSize       DW 1024
;    IOCtlPtrOffset  DW IOCTLDvcIDBuffer
;    IOCtlPtrSegment DW ?
;
;  IOCTLDvcIDBuffer: DB 1024 DUP (0)
;
;TestIOCtlCk:
;  PUSH AX,BX,CX,DX         ;Save used registers
;  MOV  AX,3D12h            ;Service 3D (Open Device), with read/write access
;                           ;  no sharing allowed
;  MOV  DX,IOCtlPString     ;Point at ES:[DX] at Device Name
;  INT  21h                 ;Open it (Returns AX = Handle)
;  JC  >T80                 ;If error, quit
;  MOV  BX,AX               ;Put Handle in BX
;  MOV  AX,4410h            ;Function 4410h (Query Generic IOCTL Capabilities)
;                           ;BX = Device Handle
;  MOV  CH,IOCatLPTx        ;Category = LPTx
;  MOV  CL,IOCmdGetDeviceID ;Function = Get Device ID String
;;  MOV  CL,65h              ;Function = Get Device ID String
;  INT  21h                 ;Do it
;  PUSHF                    ;Save CF
;  MOV  AH,3Eh              ;Service 3Eh (Close File)
;  INT  21h                 ;Do it
;  POPF                     ;Restore CF
;  JMP >T90                 ;Done
;T80:                       ;OK
;  CLC                      ;Set return flag
;T90:                       ;Done
;  POP  DX,CX,BX,AX         ;Restore used registers
;  RET
;
;TestIOCtl:
;  PUSH AX,BX,CX,DX,DI,SI   ;Save used registers
;  MOV  AX,3D12h            ;Service 3D (Open Device), with read/write access
;                           ;  no sharing allowed
;  MOV  DX,IOCtlPString     ;Point at ES:[DX] at Device Name
;  INT  21h                 ;Open it (Returns AX = Handle)
;  JC  >C80                 ;If error, quit
;  MOV  BX,AX               ;Put Handle in BX
;  MOV  AX,440Ch            ;Function 440Ch (Generic IOCTL)
;                           ;BX = Device Handle
;  MOV  CH,IOCatLPTx        ;Category = LPTx
;  MOV  CL,IOCmdGetDeviceID ;Function = Get Device ID String
;  MOV  IOCTLPtrSegment,DS  ;Store our Segment in the Parameter Block
;  MOV  DX,IOCtlParamBlock  ;Point DS:[DX] at the Parameter Block
;  INT  21h                 ;Do it
;  PUSHF                    ;Save CF
;  MOV  AH,3Eh              ;Service 3Eh (Close File)
;  INT  21h                 ;Do it
;  POPF                     ;Restore CF
;  JMP >C90                 ;Done
;C80:                       ;OK
;  CLC                      ;Set OK flag
;C90:                       ;Done
;  POP  SI,DI,DX,CX,BX,AX   ;Restore used registers
;  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SPACE AND CODE TO PROCESS OUR PROGRAM STACK
;  This code and must be physically at the END of the Program,
;    but must be one of the FIRST procedures called by the Program.
;  In addition, the Stack Pointer (SP) must be set properly
;    (to LastProgByte - 2) BEFORE this code is called.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;RESIZE OUR MEMORY ALLOCATION TO THE MINIMUM SIZE NEEDED
;Inputs:  SP = LastProgByte - 2
;         ES = Local Segment
;Outputs: Rellocates Memory to the minimum size required to run the program
;Changes:
;------------------------------------------------------------------------------
ResizeMemory:
  PUSH AX,BX  ;Save used registers
  MOV  AH,4Ah ;Function 4Ah (Resize Memory Block pointed at by ES)
  MOV  BX,(LastProgByte SHR 4) ;BX = Number of Paragraphs to Resize to
  INT  21h    ;Do it
  POP  BX,AX  ;Restore used registers
  RET

  EVEN 16
  DB (ProgStackSize/8) DUP ('PrgStack')

LastProgByte:
