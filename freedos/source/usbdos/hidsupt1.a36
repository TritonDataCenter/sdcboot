  JMP Main ;Skip over Data to Main Program


;==============================================================================
;NOTE: This program is written for and compiled with Eric Isaacson's A386
;      assembly language compiler, using Options +P3 -F (80386+ CPU and
;      no FPU).
;==============================================================================

;Changes in version 0.06
;  Corrected Report Descriptor issues
;  Added Button Descriptions to #32 (was #20)


;Look for CMDLINE variable
;UsagePage in MSMouse is a Word, not a Byte
;  Usage Pages FF00-FFFF are Vendor Defined!


;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
;EQUATE/STRUCTURE/MACRO DEFINITIONS
;‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹

;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;EQUATES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;==============================================================================
;Miscellaneous
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special Codes
  ;----------------------------------------------------------------------------
  No  EQU  0 ;Miscellaneous Yes/No tests
  Yes EQU -1 ;      "        "  "    "


;==============================================================================
;CPU Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Bit masks in the CPU Flags Register
  ;----------------------------------------------------------------------------
  CarryFlag  EQU 0001h ;Carry Flag
  ParityFlag EQU 0004h ;Parity Flag
  AuxFlag    EQU 0010h ;Auxiliary Flag
  ZeroFlag   EQU 0040h ;Zero Flag
  SignFlag   EQU 0080h ;Sign Flag
  TrapFlag   EQU 0100h ;Trap Flag
  IntFlag    EQU 0200h ;Interrupt Flag
  DirFlag    EQU 0400h ;Direction Flag
  OFFlag     EQU 0800h ;Overflow Flag


;==============================================================================
;CONsole/Screen Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special ASCII Characters
  ;----------------------------------------------------------------------------
  Tab       EQU  9 ;Tab
  LF        EQU 10 ;Line Feed
  FormFeed  EQU 12 ;FormFeed
  CR        EQU 13 ;Carriage Return
  EOF       EQU 26 ;End-of-File
  Quote2    EQU 34 ;Double quote
  Quote1    EQU 39 ;Single quote
  BackSlash EQU 92 ;BackSlash (\)

  ;----------------------------------------------------------------------------
  ;Special Keys that can be pressed during Pause routine
  ;----------------------------------------------------------------------------
  CtrlC  EQU  3 ;Control-C Keystroke
  Escape EQU 27 ;Escape Keystroke


;==============================================================================
;DOS Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;;Minimum DOS Version required to use this program
  ;----------------------------------------------------------------------------
  MinDOSVer EQU 0300h

  ;----------------------------------------------------------------------------
  ;Sizes of various DOS data structures
  ;----------------------------------------------------------------------------
  FCBSize     EQU  44 ;Size of DOS File Control Block
  CmdTailMax  EQU 128 ;Maximum size of a DOS Command Tail
  MaxPathSize EQU  64 ;Maximum Size of a DOS Path/FileName String

  ;----------------------------------------------------------------------------
  ;Special "hard-coded" DOS Device Handles.
  ;These Handles are permanently hard-coded in DOS, and are always open.
  ;There is no need to issue Find, Open, or Close calls to these
  ;  devices - you can just use them at will.
  ;----------------------------------------------------------------------------
  StdInHandle  EQU 0 ;Standard Input Device Handle
  StdOutHandle EQU 1 ;Standard Output Device Handle
  StdErrHandle EQU 2 ;Standard Error Device Handle
  StdAuxHandle EQU 3 ;Standard Auxiliary Device Handle (COM1 by default)
  StdPrnHandle EQU 4 ;Standard Printer Device Handle (LPT1 by default)

  ;----------------------------------------------------------------------------
  ;Codes returned by INT 21h, Function 4400h (Get Device Information)
  ;----------------------------------------------------------------------------
  ;If bit 7 is Set (is a Device):
  DvcInfoIsStdIn    EQU 0001h ;STDIN
  DvcInfoIsStdOut   EQU 0002h ;STDOUT
  DvcInfoIsNUL      EQU 0004h ;NUL
  DvcInfoIsClock    EQU 0008h ;CLOCK$
  DvcInfoInt29h     EQU 0010h ;Uses Int 29h (Special Device)
  DvcInfoBinary     EQU 0020h ;Binary (Raw) Mode
  DvcInfoEOF        EQU 0040h ;EOF on Input
  DvcInfoIsDevice   EQU 0080h ;Is a Device (not a File)
  DvcInfoKEYB       EQU 0100h ;Unknown (set by DOS 6.2x KEYB program)
  DvcInfoOpenClose  EQU 0800h ;Supports Open/Close calls
  DvcInfoOutputBusy EQU 2000h ;Supports Output until Busy
  DvcInfoIOCTL      EQU 4000h ;Can process IOCTL requests (INT 21h, Func 4402h)

  ;If bit 7 is Clear (is a File):
  DvcInfoDriveMask    EQU 003Fh ;Drive number (0 = A:)
  DvcInfoNotWritten   EQU 0040h ;File has not been written (Dirty Buffer?)
  ;Bit 7 = Clear!
  DvcInfoInt24h       EQU 0100h ;Generate Int 24h on Errors (DOS 4 only)
  DvcInfoNotRemovable EQU 0800h ;Media Not Removable
  DvcInfoNoDateTime   EQU 4000h ;Don't set File Date/Time on Closing (DOS 3.0+)
  DvcInfoRemote       EQU 8000h ;File is Remote (DOS 3.0+)


;==============================================================================
;Program Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Size of our program stack (in bytes)
  ;We need a relatively large stack, since some of our code is recursive
  ;  and therefore can use quite a bit of stack space.
  ;----------------------------------------------------------------------------
  ProgStackSize EQU 512

  ;----------------------------------------------------------------------------
  ;ErrorLevels
  ;----------------------------------------------------------------------------
  ErLvlDOSVer EQU 1 ;DOS Version too old
  ErLvlNo386  EQU 2 ;Not a 386+ CPU

  ;----------------------------------------------------------------------------
  ;Flags Byte at beginning of most Tables
  ;With this Flag at the beginning of each Table, the underlying code knows how
  ;  to parse out the Table "automatically."  This makes the "high-level" code
  ;  easier to write, since it doesn't need to concern itself with how each
  ;  individual Table is layed out.  The high-level code just calls a single
  ;  Table-parsing routine that handles all of the details.
  ;----------------------------------------------------------------------------
  TblFlagByte      EQU 00h ;Table Index is a Byte
  TblFlagWord      EQU 01h ;Table Index is a Word (not a Byte)
  TblFlagHasOffset EQU 02h ;Table Has an Offset after the String(s)
   ;Need TblFlagBitMap?

  ;----------------------------------------------------------------------------
  ;Maximum number of "Push Global States" Allowed while Printing Report Descr
  ;----------------------------------------------------------------------------
  NumReportPushes EQU 4 ;Maximum number of Push Global Reports Allowed

  ;----------------------------------------------------------------------------
  ;Flags needed to write Bytes/Words/DWords from Tables
  ;----------------------------------------------------------------------------
  WriteByteMinFlag   EQU 01h ;Write in Minimum Space
  WriteByteWordFlag  EQU 02h ;Writing a Word (not a Byte)
  WriteByteDWordFlag EQU 04h ;Writing a DWord (not a Byte or Word)


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;STRUCTURES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;==============================================================================
;DOS/CPU Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Program Segment Prefix (PSP)
  ;----------------------------------------------------------------------------
  PSPStruc      STRUC
    PSPDOSExit     DW       20CDh ;Int 20h Call
    PSPNextSegment DW          ?  ;Segment of First Byte of Memory beyond Program
    PSPCPMCall5    DB   6 DUP (?) ;CPM Far Call 5
    PSPInt22Addr   DD          ?  ;Stored Int 22h Handler
    PSPInt23Addr   DD          ?  ;Stored Int 23h (Ctrl-Break) Handler
    PSPInt24Addr   DD          ?  ;Stored Int 23h (Critical Error) Handler
    PSPParentPSP   DW          ?  ;Segment of Parent PSP
    PSPJFT         DB  20 DUP (?) ;Job File Table (20 File Handles)
    PSPEnvirSeg    DW          ?  ;Environment Segment for PSP
    PSPSSSPOnEntry DD          ?  ;Processes SS:SP on Entry to last Int 21h Call
    PSPJFTSize     DW          ?  ;Number of entries in JFT (default = 20)
    PSPJFTPointer  DD          ?  ;Pointer to JFT (Default = PSP:0018h)
    PSPPreviousPSP DD          ?  ;Pointer to previous PSP (Default = FFFF:FFFF)
    PSPFiller1     DB  18 DUP (?) ;Misc stuff used by SHARE, Windows, etc.
                                  ;Memory Below here available to TSR!
    PSPFiller2     DB   2 DUP (?) ;Unused in DOS <= 6.00
    PSPInt21       DW       21CDh ;Int 21h Call
    PSPRETF        DB        0CBh ;RETF Call
    PSPFiller3     DB   9 DUP (?) ;Can be used to make Extended FCB from FCB1
    PSPFCB1        DB  16 DUP (?) ;First File Control Block
    PSPFCB2        DB  16 DUP (?) ;Second File Control Block
    PSPFiller4     DB   4 DUP (?) ;Unused
    PSPCmdLineLen  DB          ?  ;Command Line Length & DTA
    PSPCmdLine     DB 127 DUP (?) ;Command Line String
   ENDS
  PSPStrucSize EQU (TYPE PSPStruc) ;Should be 256 bytes

  ;----------------------------------------------------------------------------
  ;Memory Control Block (MCB)
  ;----------------------------------------------------------------------------
  MCBStruc STRUC
    MCBID              DB        ?  ;Memory Control Block ID
      MCBIDValid      EQU       'M' ;Memory Block is Valid
      MCBIDLastInList EQU       'Z' ;Memory Block is Last in List
    MCBOwnerID         DW        ?  ;PSP Segment of Owner
                                    ;   0 = Owns Self
                                    ;   6 = DR-DOS XMS UMB
                                    ;   7 = DR-DOS Excluded Upper Memory
                                    ;   8 = Belongs to DOS
                                    ;FFFx = 386Max
    MCBSize            DW        ?  ;Size in Paragraphs
    MCBFiller          DB 3 DUP (?) ;Filler
    MCBOwnerName       DB 8 DUP (?) ;Owner Name
   ENDS
  MCBStrucSize EQU (TYPE MCBStruc) ;Should be 16 bytes


;==============================================================================
;USB Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;This is the structure for a Global State "Stack" Item while Parsing a
  ;  Report Descriptor.
  ;Report Descriptors can have a "Push Global State" and a "Pop Global State"
  ;  in them, which actually needs to save several items (those here in this
  ;  Structure, to be specific).
  ;In the documentation describing Report Descriptors, it references Global,
  ;  Main, Global, & Local Items, but the definition of the PUSH/POP actually
  ;  only refers to Global Items.  So, it is unclear whether a PUSH is supposed
  ;  to really save everything (which is what we do here), or just save truly
  ;  Global Items (which is a smaller subset of this particular Structure).
  ;I haven't yet ran across a real Device which uses the PUSH/POP functions,
  ;  so it's hard to say whether this program is correct or not.  If it is
  ;  incorrect, obviously we'll need to make some changes!!
  ;----------------------------------------------------------------------------
  ReportItemStruc STRUC
    Collection      DB ?
    Delimiter       DB ? ;1 = Open Set, 2 = Close Set
;    UsagePage       DB ?
    UsagePage       DW ?
    UnitExponent    DB ?
    FillerByte      DB ?

    DesignatorIndex DD ?
    DesignatorMin   DD ?
    DesignatorMax   DD ?
    LogicalMin      DD ?
    LogicalMax      DD ?
    PhysicalMin     DD ?
    PhysicalMax     DD ?
    ReportCount     DD ?
    ReportSize      DD ?
    ReportID        DD ?
    StringIndex     DD ?
    StringMin       DD ?
    StringMax       DD ?
    Units           DD ?
    Usage           DD ?
    UsageMin        DD ?
    UsageMax        DD ?
   ENDS
  ReportItemSize EQU TYPE ReportItemStruc


;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
;DATA
;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ

;==============================================================================
;Miscellaneous Strings we need to write to the screen
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Help Message to write on Errors.
  ;This MUST also be the first Data at the top of the File.  If it is, the user
  ;  can simply do a "TYPE USBSUPT1.COM" and get the Help Screen, without even
  ;  needing to execute the Program.
  ;------------------------------------------------------------------------------
  Copyright:
    DB CR
    DB 'HIDSUPT1 0.06, (C) 2007-2009, Bret E. Johnson.',CR,LF
    DB LF,0

  HelpMsg:
    DB 'This program is designed as a Support Program, to be called from',CR,LF
    DB '  "inside" some of my other USB-related Programs.  Because it is designed',CR,LF
    DB '  to called from "inside" another program, it does not have all of the',CR,LF
    DB '  nice things that a "real", stand-alone program should have.',CR,LF
    DB '  However it does contain a lot of useful/interesting tidbits of information.',CR,LF
    DB LF
    DB "I should warn you that if you're not pretty familiar with the technical",CR,LF
    DB '  details of how USB in general, and Human Interface Devices in particular,',CR,LF
    DB '  work, this information may actually confuse you more than it helps you,',CR,LF
    DB "  but it's still there for your viewing pleasure.",CR,LF
    DB LF
    DB 'If the Option asks for number(s) to be entered (#), they can generally be',CR,LF
    DB '  entered in decimal (0-65535) or in hexadecimal (0h-FFFFh).  The exception',CR,LF
    DB '  to this is #Segment:#Offset, which must ALWAYS be in hexadecimal.',CR,LF
    DB '  If you leave number(s) out, ALL possible values will usually be displayed.',CR,LF
    DB LF
    DB 'If running from inside another program (if not running from the command-line),',CR,LF
    DB '  the number(s) can be followed with a hex call-back address (#Segment:#Offset)',CR,LF
    DB '  to which the output will be written.  See HIDSUPT1.DOC for details.',CR,LF
    DB LF
    DB LF
    DB 'HID (HUMAN INTERFACE DEVICE) PHYSICAL AND REPORT DESCRIPTORS:',CR,LF
    DB '  PhysicalBias       #Bias',CR,LF
    DB '  PhysicalDesignator #Designator',CR,LF
    DB '  PhysicalQualifier  #Qualifier',CR,LF
    DB '  PhysicalDescriptor #Segment:#Offset',CR,LF
    DB '  ReportCollection   #Collection',CR,LF
    DB '  ReportDelimiter    #Delimiter',CR,LF
    DB '  ReportTag          #Tag',CR,LF
    DB '  ReportDescriptor   #Segment:#Offset',CR,LF
    DB '  UsagePage          #UsagePage',CR,LF
    DB '  Usage              #UsagePage #Usage',CR,LF
    DB 0
    DB EOF

  ;----------------------------------------------------------------------------
  ;Incompatibility Strings we may write to the screen
  ;----------------------------------------------------------------------------
  DOSVerMsg:
    DB 'You must be using DOS version 3.00 or later to use this program.',0
  No386Msg:
    DB 'The CPU in the computer must be at least an 80386.',0

  ;----------------------------------------------------------------------------
  ;Our Progran Name as an ASCIIZ String (9 characters long)
  ;----------------------------------------------------------------------------
  RealName: DB 'HIDSUPT1',0

  ;----------------------------------------------------------------------------
  ;Various Strings needed to print numbers and such to the screen
  ;----------------------------------------------------------------------------
  HexString: DB '0000_0000',0
  CrLfMsg:   DB CR,LF,0
  SingleMsg: DB ' '
  NoMsg:     DB 0
  Space3Msg: DB ' '
  Space2Msg: DB ' '
  SpaceMsg:  DB ' ',0

  CommaSpaceMsg:    DB ', ',0
  QuestionsMsg:     DB '???',0
  UnknownXMsg:      DB 'Unknown!',0
  EqualsSpaceMsg:   DB '= ',0
  VendorDefinedMsg: DB '(Vendor-Defined)',0

  ;----------------------------------------------------------------------------
  ;Strings and Data needed to Pause the screen
  ;----------------------------------------------------------------------------
  PauseMsg:
    DB CR,LF
    DB ' MORE   (Esc stops Pausing, Ctrl-C stops Completely, any other Continues)',CR,0
  PauseNMsg:
    DB ' MORE                                                                    ',CR,LF,0
  PauseDMsg:
    DB '                                                                               ',CR,0
  PauseRows       DW ? ;Number of rows per screen
  PauseHeaderPtr  DW 1 ;Pointer to Header Message (start with a fake one <> 0)
  PauseHeaderSize DW 2 ;Number of lines in the Header Message
  PauseRowCount   DW 2 ;Current Row Counter


;==============================================================================
;Alias Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings needed to print Command Line Aliases to the screen
  ;----------------------------------------------------------------------------
  AliasHdrMsg:
    DB '                   ALIASES FOR COMMAND-LINE OPTIONS',CR,LF
    DB 'ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
    DB 0

  ;----------------------------------------------------------------------------
  ;Table needed to temporarily store Aliases.
  ;They are originally sorted in reverse alphabetical order.
  ;To write them in forward alphabetical order, we temporarily store
  ;  the String Pointers, in the original reverse order, in this table.
  ;  We then write the strings, starting with the last entry in this table
  ;  and moving backwards.
  ;The number of entries in this table must be AT LEAST as big as the largest
  ;  number of Aliases for a single command Option.  Most Options don't have
  ;  more than a dozen or so Aliases.
  ;----------------------------------------------------------------------------
  AliasSortTbl: DW 50 DUP (?) ;Table to store Alias Strings (to reverse order)


;==============================================================================
;Miscellaneous Data
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Number of Spaces to Indent while printing things
  ;----------------------------------------------------------------------------
  Indent DB ?


;==============================================================================
;Data needed to determine who our Parent Program is
;==============================================================================

  ;----------------------------------------------------------------------------
  ;ASCIIZ Name of our Parent (the name stored in the MCB for our Parents PSP)
  ;----------------------------------------------------------------------------
  ParentName: DB 9 DUP (0)

  ;----------------------------------------------------------------------------
  ;Is our Parent a DOS Shell?
  ;----------------------------------------------------------------------------
  ParentIsShell DB No

  ;----------------------------------------------------------------------------
  ;CallBack Address that may be provided by another program
  ;An offset of -1 (the first word) indicates an invalid address
  ;----------------------------------------------------------------------------
  CallBackAddr DD -1

  ;----------------------------------------------------------------------------
  ;Table of possible DOS Shell programs (COMMAND.COM or equivalents)
  ;Must be capitalized, 8 characters ASCIIZ (not including 0 at end) max
  ;More things could be added to this table if they are discovered;
  ;  e.g., if FreeDOS or DR DOS or ... use a Shell Name other than COMMAND
  ;----------------------------------------------------------------------------
  DOSShellTbl:
    DB 'COMMAND',0 ;Standard DOS
    DB 'CMD',0     ;Windows NT & IBM OS/2
    DB 'NDOS',0    ;Norton Shell (from Norton Utilities)
    DB '4DOS',0    ;4DOS
    DB '4NT',0     ;4NT
    DB '4OS2',0    ;4OS2
    DB 0           ;End of Table


;==============================================================================
;Data Needed to Process the Command Line
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Data needed to Parse the command line for Options
  ;----------------------------------------------------------------------------
  ParseError DB No ;Error while Parsing Command Line?

  ;----------------------------------------------------------------------------
  ;Codes for different Command-Line Switches
  ;NOTE: The numerical order here is what the Alias Option uses to sort things.
  ;----------------------------------------------------------------------------
  AliasSwitch              EQU  1
  PhysicalBiasSwitch       EQU  2
  PhysicalDescrSwitch      EQU  3
  PhysicalDesignatorSwitch EQU  4
  PhysicalQualifierSwitch  EQU  5
  ReportCollectionSwitch   EQU  6
  ReportDelimiterSwitch    EQU  7
  ReportDescrSwitch        EQU  8
  ReportTagSwitch          EQU  9
  UsageSwitch              EQU 10
  UsagePageSwitch          EQU 11

  ;----------------------------------------------------------------------------
  ;Command Line Options
  ;----------------------------------------------------------------------------
  SwitchList:
    DB 'UsagePage',0
    DB  0, UsagePageSwitch

    DB 'Usage',0
    DB  0, UsageSwitch

    DB 'RptTag',0
    DB  0, ReportTagSwitch

    DB 'RptDescriptor',0
    DB 'RptDescr',0
    DB  0, ReportDescrSwitch

    DB 'RptDelimiter',0
    DB  0, ReportDelimiterSwitch

    DB 'RptCollection',0
    DB  0, ReportCollectionSwitch

    DB 'ReportTag',0
    DB  0, ReportTagSwitch

    DB 'ReportDescriptor',0
    DB 'ReportDescr',0
    DB  0, ReportDescrSwitch

    DB 'ReportDelimiter',0
    DB  0, ReportDelimiterSwitch

    DB 'ReportCollection',0
    DB  0, ReportCollectionSwitch

    DB 'PhysicalQualifier',0
    DB  0, PhysicalQualifierSwitch

    DB 'PhysicalDesignator',0
    DB  0, PhysicalDesignatorSwitch

    DB 'PhysicalDescriptor',0
    DB 'PhysicalDescr',0
    DB  0, PhysicalDescrSwitch

    DB 'PhysicalBias',0
    DB  0, PhysicalBiasSwitch

    DB 'OptionAliases',0
    DB 'OptionAlias',0
    DB  0, AliasSwitch

    DB 'CommandLineAliases',0
    DB 'CommandLineAlias',0
    DB  0, AliasSwitch

    DB 'CmdLineAliases',0
    DB 'CmdLineAlias',0
    DB  0, AliasSwitch

    DB 'Aliases',0
    DB 'Alias',0
    DB  0, AliasSwitch

    DB  0 ;End of list

  ;----------------------------------------------------------------------------
  ;Table of Subroutine Offsets to Process the Various Command Line Options
  ;----------------------------------------------------------------------------
  SwitchTbl:
    DB AliasSwitch
       DW DoSwitchAlias
    DB PhysicalBiasSwitch
       DW DoSwitchPhysicalBias
    DB PhysicalDescrSwitch
       DW DoSwitchPhysicalDescr
    DB PhysicalDesignatorSwitch
       DW DoSwitchPhysicalDesignator
    DB PhysicalQualifierSwitch
       DW DoSwitchPhysicalQualifier
    DB ReportCollectionSwitch
       DW DoSwitchReportCollection
    DB ReportDelimiterSwitch
       DW DoSwitchReportDelimiter
    DB ReportDescrSwitch
       DW DoSwitchReportDescr
    DB ReportTagSwitch
       DW DoSwitchReportTag
    DB UsageSwitch
       DW DoSwitchUsage
    DB UsagePageSwitch
       DW DoSwitchUsagePage
    DB 0 ;End of Table


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;HID (Human Interface Device) related Tables
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;==============================================================================
;Strings and Tables Needed to Process HID Physical Descriptors
;NOTE: I've never actualy seen a Device that had a Physical Descriptor, so
;        the processing performed here is based on my interpretation of the
;        USB specification, with no "real-world" experience to base it on.
;==============================================================================
  PhysicalDescrMsg:
    DB 'USB HID (HUMAN INTERFACE DEVICE) PHYSICAL DESCRIPTOR',CR,LF
    DB 'ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
    DB 0

  DesignatorMsg:
    DB 'Designator  Raw',CR,LF
    DB '  Index     Data   Effort        Description',CR,LF
    DB 'ƒƒƒƒƒƒƒƒƒƒ  ƒƒƒƒƒ  ƒƒƒƒƒƒ  ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ',CR,LF
    DB 0

  PreferenceMsg: DB 'Preference = ',0
  BiasMsg:       DB 'Bias = ',0

  ;----------------------------------------------------------------------------
  ;HID Physical Descriptors
  ;Last updated 2002/07/31
  ;----------------------------------------------------------------------------
  PhysicalBiasTbl:
    DB TblFlagByte ;High 3 Bits of Info Byte, Low 5 bits = Preference #
    DB (00h SHL 5), 'None',0
    DB (01h SHL 5), 'Right Hand',0
    DB (02h SHL 5), 'Left Hand',0
    DB (03h SHL 5), 'Both Hands',0
    DB (04h SHL 5), 'Either Hand',0
    DB (05h SHL 5), '?',0
    DB (06h SHL 5), '?',0
    DB (07h SHL 5), '?',0
    DB  0 , -1 ;End of Table

  PhysicalTbl:        ;Physical Designators
    DB TblFlagByte
    DB 00h, 'None',0
    DB 01h, 'Hand',0
    DB 02h, 'Eyeball',0
    DB 03h, 'Eyebrow',0
    DB 04h, 'Eyelid',0
    DB 05h, 'Ear',0
    DB 06h, 'Nose',0
    DB 07h, 'Mouth',0
    DB 08h, 'Upper Lip',0
    DB 09h, 'Lower Lip',0
    DB 0Ah, 'Jaw',0
    DB 0Bh, 'Neck',0
    DB 0Ch, 'Upper Arm',0
    DB 0Dh, 'Elbow',0
    DB 0Eh, 'Forearm',0
    DB 0Fh, 'Wrist',0
    DB 10h, 'Palm',0
    DB 11h, 'Thumb',0
    DB 12h, 'Index Finger',0
    DB 13h, 'Middle Finger',0
    DB 14h, 'Ring Finger',0
    DB 15h, 'Little Finger',0
    DB 16h, 'Head',0
    DB 17h, 'Shoulder',0
    DB 18h, 'Hip',0
    DB 19h, 'Waist',0
    DB 1Ah, 'Thigh',0
    DB 1Bh, 'Knee',0
    DB 1Ch, 'Calf',0
    DB 1Dh, 'Ankle',0
    DB 1Eh, 'Foot',0
    DB 1Fh, 'Heel',0
    DB 20h, 'Ball of Foot',0
    DB 21h, 'Big Toe',0
    DB 22h, 'Second Toe',0
    DB 23h, 'Third Toe',0
    DB 24h, 'Fourth Toe',0
    DB 25h, 'Little Toe',0
    DB 26h, 'Brow',0
    DB 27h, 'Cheek',0
    DB  0 , -1 ;End of Table

  PhysicalQualTbl:
    DB TblFlagByte         ;High 3 Bits of Flags Byte, Low 5 Bits = Effort #
    DB (01h SHL 5), 'Right',0
    DB (02h SHL 5), 'Left',0
    DB (03h SHL 5), 'Both',0
    DB (04h SHL 5), 'Either',0
    DB (05h SHL 5), 'Center of',0
    DB  0 , -1 ;End of Table


;==============================================================================
;Strings & Tables needed to Process HID Report Descriptors
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special Data Needed to Process an HID Report Descriptor
  ;Unlike most other Reports, an HID Report Descriptor is EXTREMELY complicated
  ;  to process, because it must be processed in a strictly linear,
  ;  top-to-bottom fashion.  This is because it must maintain a "history",
  ;  and exactly what any particular piece of data may mean nearly always
  ;  depends on what data was processed earlier in the Report.
  ;Simply processing and HID Report Descriptor as we do here (to simply give
  ;  a "description" of what things mean), while cumbersome, is not really
  ;  all that complicated.
  ;I pity the person who tries to create a truly generic HID Device Driver,
  ;  that would truly work with ANY HID Device ever made, using all of the
  ;  functionality that the Device could offer.  I don't even think it would
  ;  be possible to do.  We'll probably forever continue to need special,
  ;  device-unique drivers for every Operating System and Device that anyone
  ;  ever creates.  A sad state of affairs, unless you're Microsoft (every
  ;  manufacturer will write a driver for Windows, but almost no manufacturers
  ;  will write drivers for anything else).
  ;----------------------------------------------------------------------------
  EVEN 2
  ReportItems:
    DB (ReportItemSize * NumReportPushes) DUP 0

  ReportDescrHdr:
    DB '              USB HID (HUMAN INTERFACE DEVICE) REPORT DESCRIPTOR               ',CR,LF
    DB 'ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
    DB 0
  MultiplyMsg:
    DB ' * ',0 ;Multiplication between factors in Units
  ExponentMsg:
    DB '^',0   ;Exponent for factors in Units


  ;----------------------------------------------------------------------------
  ;Tables To Parse HID Report Descriptors
  ;Last Updated 2002/07/31
  ;----------------------------------------------------------------------------
  ReportTagTbl:
    DB TblFlagByte+TblFlagHasOffset
  ;Main Items
    DB  80h, 'INPUT:           ',0
              DW DoInput
    DB  90h, 'OUTPUT:          ',0
              DW DoOutput
    DB 0B0h, 'FEATURE:         ',0
              DW DoFeature
    DB 0A0h, 'Collection:      ',0
              DW DoCollection
    DB 0C0h, 'End Collection   ',0
              DW DoEndCollection
  ;Global Items
    DB  04h, 'Usage Page:      ',0
              DW DoUsagePage
    DB  14h, 'Logical Min:     ',0
              DW DoLogicalMin
    DB  24h, 'Logical Max:     ',0
              DW DoLogicalMax
    DB  34h, 'Physical Min:    ',0
              DW DoPhysicalMin
    DB  44h, 'Physical Max:    ',0
              DW DoPhysicalMax
    DB  54h, 'Unit Exponent:   ',0
              DW DoUnitExponent
    DB  64h, 'Units:           ',0
              DW DoUnits
    DB  74h, 'Report Size:     ',0
              DW DoReportSize
    DB  84h, 'Report ID:       ',0
              DW DoReportID
    DB  94h, 'Report Count:    ',0
              DW DoReportCount
    DB 0A4h, 'Push Global State',0
              DW DoPushGlobal
    DB 0B4h, 'Pop Global State ',0
              DW DoPopGlobal
  ;Local Items
    DB  08h, 'Usage:           ',0
              DW DoUsage
    DB  18h, 'Usage Min:       ',0
              DW DoUsageMin
    DB  28h, 'Usage Max:       ',0
              DW DoUsageMax
    DB  38h, 'Designator Index:',0
              DW DoDesignatorIndex
    DB  48h, 'Designator Min:  ',0
              DW DoDesignatorMin
    DB  58h, 'Designator Max:  ',0
              DW DoDesignatorMax
    DB  78h, 'String Index:    ',0
              DW DoStringIndex
    DB  88h, 'String Min:      ',0
              DW DoStringMin
    DB  98h, 'String Max:      ',0
              DW DoStringMax
    DB 0A8h, 'Delimiter:       ',0
              DW DoDelimiter
  ;Other
    DB 0FCh, 'Long Data:       ',0
              DW DoLongData
    DB   0 , -1 ;End of Table


  ;----------------------------------------------------------------------------
  ;First Entry is First Nibble of a Unit Entry (the System)
  ;Next 7 Entries are for each of the seven remaining nibbles of the Unit factors
  ;Each Entry (Nibble), other than the first one, is a signed exponent (-8 to +7)
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;Some Useful Unit/Unit Exponent Combinations:
  ;These come from the USB Power Device Class Specification
  ;
  ; Description  Unit       Unit Exp
  ; -----------  ---------  --------
  ; Volt         00F0D121h         7
  ; Ampere       00100001h         0
  ; Hertz        0000F001h         0
  ; Second       00001001h         0
  ; Watt         0000D121h         7
  ; Kelvin       00010001h         0
  ; Amp-Second   00101001h         0
  ;----------------------------------------------------------------------------
  UnitsTbl:
    DB 01h                 ;SI Linear
       DB 'centimeters',0
       DB 'grams',0
       DB 'seconds',0
       DB 'kelvin',0
       DB 'amperes',0
       DB 'candelas',0
       DB  0               ;Nibble 7 = Reserved
    DB 02h                 ;SI Rotational
       DB 'radians',0
       DB 'grams',0
       DB 'seconds',0
       DB 'kelvin',0
       DB 'amperes',0
       DB 'candelas',0
       DB  0               ;Nibble 7 = Reserved
    DB 03h                 ;English Linear
       DB 'inches',0
       DB 'slugs',0
       DB 'seconds',0
       DB 'farenheit',0
       DB 'amperes',0
       DB 'candelas',0
       DB  0               ;Nibble 7 = Reserved
    DB 04h                 ;English Rotational
       DB 'degrees',0
       DB 'slugs',0
       DB 'seconds',0
       DB 'farenheit',0
       DB 'amperes',0
       DB 'candelas',0
       DB  0               ;Nibble 7 = Reserved
    DB 0Fh                 ;Vendor-defined
       DB '{length}',0
       DB '{mass}',0
       DB '{time}',0
       DB '{tempurature}',0
       DB '{current}',0
       DB '{light intensity}',0
       DB '{vendor}',0
    DB  0     ;End of
       DB  -1 ;  Table

  ;----------------------------------------------------------------------------
  ;Lookup Table for Collection Types
  ;----------------------------------------------------------------------------
  CollectionTbl:
    DB TblFlagByte
    DB 00h, 'Physical',0
    DB 01h, 'Application',0
    DB 02h, 'Logical',0
    DB  0 , -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;Lookup Table for Delimiter Types
  ;----------------------------------------------------------------------------
  DelimiterTbl:
    DB TblFlagByte
    DB 01h, 'Open Set',0
    DB 02h, 'Close Set',0
    DB  0 , -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;Lookup Table for Input/Output/Feature Items
  ;First Entry of Table is a Word, and is a Bit-Mask
  ;First String is what to write if Bit is 0, Second String if Bit is 1
  ;----------------------------------------------------------------------------
  InOutFeatureTbl:
  ;First Line
    DW 0001h
       DB 'Data',0
       DB 'Constant',0
    DW 0002h
       DB 'Array',0
       DB 'Variable',0
    DW 0004h
       DB 'Absolute',0
       DB 'Relative',0
  ;Second Line
    DW 0008h
       DB 'No_Wrap',0
       DB 'Wrap',0
    DW 0010h
       DB 'Linear',0
       DB 'Non_Linear',0
    DW 0020h
       DB 'Preferred_State',0
       DB 'No_Preferred_State',0
  ;Third Line
    DW 0040h
       DB 'No_Null_State',0
       DB 'Null_State',0
    DW 0080h
       DB 'Non_Volatile',0
       DB 'Volatile',0
    DW 0100h
       DB 'Bit_Field',0
       DB 'Buffered',0


  ;----------------------------------------------------------------------------
  ;HID Usage Pages
  ;NOTE: Usage pages FF00h - FFFFh are Vendor Defined
  ;----------------------------------------------------------------------------
  UsagePageTbl:
;    DB  TblFlagByte+TblFlagHasOffset
    DB  TblFlagWord+TblFlagHasOffset
;    DB  01h, 'Generic Desktop',0
    DW  0001h
        DB 'Generic Desktop',0
        DW GenericDeskTopTbl
;    DB  02h, 'Simulation Controls',0
    DW  0002h
        DB 'Simulation Controls',0
        DW SimulationCtlTbl
;    DB  03h, 'Virtual Reality Controls',0
    DW  0003h
        DB 'Virtual Reality Controls',0
        DW VirtualRealityTbl
;    DB  04h, 'Sport Controls',0
    DW  0004h
        DB 'Sport Controls',0
        DW SportCtlTbl
;    DB  05h, 'Game Controls',0
    DW  0005h
        DB 'Game Controls',0
        DW GameCtlTbl
;    DB  06h, 'Generic Device Controls',0
    DW  0006h
        DB 'Generic Device Controls',0
        DW GenericControlTbl
;    DB  07h, 'Keyboard/Keypad',0
    DW  0007h
        DB 'Keyboard/Keypad',0
        DW KeyboardTbl
;    DB  08h, 'LEDs (Light Emitting Diodes)',0
    DW  0008h
        DB 'LEDs (Light Emitting Diodes)',0
        DW LEDTbl
;    DB  09h, 'Buttons',0
    DW  0009h
        DB 'Buttons',0
        DW ButtonTbl
;    DB  0Ah, 'Ordinal',0
    DW  000Ah
        DB 'Ordinal',0
        DW OrdinalTbl
;    DB  0Bh, 'Telephony',0
    DW  000Bh
        DB 'Telephony',0
        DW TelephonyTbl
;    DB  0Ch, 'Consumer Device',0
    DW  000Ch
        DB 'Consumer Device',0
        DW ConsumerTbl
;    DB  0Dh,  'Digitizer',0
    DW  000Dh
        DB  'Digitizer',0
        DW DigitizerTbl
;    DB  0Fh, 'Physical Intf Dvc (Force Feedback)',0
    DW  000Fh
        DB 'Physical Intf Dvc (Force Feedback)',0
        DW PIDTbl
;    DB  10h, 'UniCode',0
    DW  0010h
        DB 'UniCode',0
        DW 0
;    DB  14h, 'AlphaNumeric Display',0
    DW  0014h
        DB 'AlphaNumeric Display',0
        DW AlphaNumericTbl
;    DB  40h, 'Medical Instruments',0
    DW  0040h
        DB 'Medical Instruments',0
        DW MedicalTbl
;    DB  80h, 'Monitor',0
    DW  0080h
        DB 'Monitor',0
        DW MonitorTbl
;    DB  81h, 'Monitor Enumerated Values',0
    DW  0081h
        DB 'Monitor Enumerated Values',0
        DW MonitorVESACmdTbl
;    DB  82h, 'Monitor VESA Virtual Controls',0
    DW  0082h
        DB 'Monitor VESA Virtual Controls',0
        DW MonitorVESAVCTbl
;    DB  83h, 'Monitor Reserved',0
    DW  0083h
        DB 'Monitor Reserved',0
        DW 0
;    DB  84h, 'Power Device (Power Page 1)',0
    DW  0084h
        DB 'Power Device (Power Page 1)',0
        DW PowerDeviceTbl
;    DB  85h, 'Battery System (Power Page 2)',0
    DW  0085h
        DB 'Battery System (Power Page 2)',0
        DW BatterySystemTbl
;    DB  86h, 'Power Page 3 (Reserved)',0
    DW  0086h
        DB 'Power Page 3 (Reserved)',0
        DW 0
;    DB  87h, 'Power Page 4 (Reserved)',0
    DW  0087h
        DB 'Power Page 4 (Reserved)',0
        DW 0
;    DB  8Ch, 'Point-of-Sale Bar Code Scanner',0
    DW  008Ch
        DB 'Point-of-Sale Bar Code Scanner',0
        DW POSBarCodeTbl
;    DB  8Dh, 'Point-of-Sale Weight Device (Scale)',0
    DW  008Dh
        DB 'Point-of-Sale Weight Device (Scale)',0
        DW POSWeightTbl
;    DB  8Eh, 'Point-of-Sale Magnetic Stripe Reader',0
    DW  008Eh
        DB 'Point-of-Sale Magnetic Stripe Reader',0
        DW POSMagStripeTbl
;    DB  8Fh, 'Point-of-Sale Reserved',0
    DW  008Fh
        DB 'Point-of-Sale Reserved',0
        DW 0
;    DB  90h, 'Camera Control',0
    DW  0090h
        DB 'Camera Control',0
        DW 0
;    DB  91h, 'Arcade and Coin-Op Devices',0
    DW  0091h
        DB 'Arcade and Coin-Op Devices',0
        DW 0
;    DB 0F0h, 'Cash Device',0
    DW 000F0h
        DB 'Cash Device',0
        DW CashDeviceTbl
;    DB 0FFh, 'Vendor Specific',0
    DW 000FFh
        DB 'Vendor Specific',0
        DW 0
;    DB   0 , -1 ;End of Table
    DW   0 , -1 ;End of Table


  ;----------------------------------------------------------------------------
  ;HID Usages
  ;----------------------------------------------------------------------------
  GenericDesktopTbl: ;Taken from USB HID Usage Tables v1.12 2005-01-21
    DB  TblFlagByte
    DB  00h, 'None/Unknown/Not Applicable',0
    DB  01h, 'Pointer',0
    DB  02h, 'Mouse',0
    DB  04h, 'Joystick',0
    DB  05h, 'GamePad',0
    DB  06h, 'Keyboard',0
    DB  07h, 'KeyPad',0
    DB  08h, 'Multi-Axis Controller',0
    DB  09h, 'Tablet PC System Controls',0
    DB  30h, 'X-axis',0
    DB  31h, 'Y-axis',0
    DB  32h, 'Z-axis',0
    DB  33h, 'Rotation around X-axis',0
    DB  34h, 'Rotation around Y-axis',0
    DB  35h, 'Rotation around Z-axis',0
    DB  36h, 'Slider',0
    DB  37h, 'Dial',0
    DB  38h, 'Wheel',0
    DB  39h, 'Hat-Switch',0
    DB  3Ah, 'Counted Buffer',0
    DB  3Bh, 'Byte Count',0
    DB  3Ch, 'Wakeup on Motion',0
    DB  3Dh, 'Start',0
    DB  3Eh, 'Select',0
    DB  40h, 'X-Axis Vector',0
    DB  41h, 'Y-Axis Vector',0
    DB  42h, 'Z-Axis Vector',0
    DB  43h, 'X-Axis Vector, Relative to Body',0
    DB  44h, 'Y-Axis Vector, Relative to Body',0
    DB  45h, 'Z-Axis Vector, Relative to Body',0
    DB  46h, 'Non-Directional Vector',0
    DB  47h, 'Feature Notification',0
    DB  48h, 'Resolution Multiplier',0
    DB  80h, 'System Control (not a key)',0
    DB  81h, 'System Power Down',0
    DB  82h, 'System Sleep',0
    DB  83h, 'System Wake Up',0
    DB  84h, 'System Menu Context',0
    DB  85h, 'System Menu Main',0
    DB  86h, 'System Menu Application',0
    DB  87h, 'System Menu Help',0
    DB  88h, 'System Menu Exit',0
    DB  89h, 'System Menu Select',0
    DB  8Ah, 'System Menu Right',0
    DB  8Bh, 'System Menu Left',0
    DB  8Ch, 'System Menu Up',0
    DB  8Dh, 'System Menu Down',0
    DB  8Eh, 'System Cold Restart',0
    DB  8Fh, 'System Warm Restart',0
    DB  90h, 'Direction-Pad Up',0
    DB  91h, 'Direction-Pad Down',0
    DB  92h, 'Direction-Pad Right',0
    DB  93h, 'Direction-Pad Left',0
    DB 0A0h, 'System Dock',0
    DB 0A1h, 'System Undock',0
    DB 0A2h, 'System Setup',0
    DB 0A3h, 'System Break',0
    DB 0A4h, 'System Debugger Break',0
    DB 0A5h, 'Application Break',0
    DB 0A6h, 'Application Debugger Break',0
    DB 0A7h, 'System Speaker Mute',0
    DB 0A8h, 'System Hibernate',0
    DB 0B0h, 'System Display Invert Colors',0
    DB 0B1h, 'System Display Internal Only',0
    DB 0B2h, 'System Display External Only',0
    DB 0B3h, 'System Display Both',0
    DB 0B4h, 'System Display Dual',0
    DB 0B5h, 'System Display Toggle Internal/External',0
    DB 0B6h, 'System Display Swap Primary/Secondary',0
    DB 0B7h, 'System Display LCD Autoscale',0
    DB   0 , -1 ;End of Table

  SimulationCtlTbl: ;Taken from USB HID Usage Tables v1.12 2005-01-21
    DB  TblFlagByte
    DB  00h, 'None/Unknown/Not Applicable',0
    DB  01h, 'Flight Simulation Device',0
    DB  02h, 'Automobile Simulation Device',0
    DB  03h, 'Tank Simulation Device',0
    DB  04h, 'Spaceship Simulation Device',0
    DB  05h, 'Submarine Simulation Device',0
    DB  06h, 'Sailing Simulation Device',0
    DB  07h, 'Motorcycle Simulation Device',0
    DB  08h, 'Sports Simulation Device',0
    DB  09h, 'Airplane Simualtion Device',0
    DB  0Ah, 'Helicopter Simulation Device',0
    DB  0Bh, 'Magic Carpet Simulation Device',0
    DB  0Ch, 'Bicycle Simulation Device',0
    DB  20h, 'Flight Control Stick',0
    DB  21h, 'Flight Stick',0
    DB  22h, 'Cyclic Control',0
    DB  23h, 'Cyclic Trim',0
    DB  24h, 'Flight Yoke',0
    DB  25h, 'Track Control',0
    DB 0B0h, 'Aileron',0
    DB 0B1h, 'Aileron Trim',0
    DB 0B2h, 'Anti-Torque Control',0
    DB 0B3h, 'Autopilot Enable',0
    DB 0B4h, 'Chaff Release',0
    DB 0B5h, 'Collective Control',0
    DB 0B6h, 'Dive Break',0
    DB 0B7h, 'Electronic Countermeasures',0
    DB 0B8h, 'Elevator',0
    DB 0B9h, 'Elevator Trim',0
    DB 0BAh, 'Rudder',0
    DB 0BBh, 'Throttle',0
    DB 0BCh, 'Flight Communications',0
    DB 0BDh, 'Flare Release',0
    DB 0BEh, 'Landing Gear',0
    DB 0BFh, 'Toe Break',0
    DB 0C0h, 'Trigger',0
    DB 0C1h, 'Weapons Arm',0
    DB 0C2h, 'Weapons Select',0
    DB 0C3h, 'Wing Flaps',0
    DB 0C4h, 'Accelerator',0
    DB 0C5h, 'Brake',0
    DB 0C6h, 'Clutch',0
    DB 0C7h, 'Shifter',0
    DB 0C8h, 'Steering',0
    DB 0C9h, 'Turret Direction',0
    DB 0CAh, 'Barrel Elevation',0
    DB 0CBh, 'Dive Plane',0
    DB 0CCh, 'Ballast',0
    DB 0CDh, 'Bicycle Crank',0
    DB 0CEh, 'Handle Bars',0
    DB 0CFh, 'Front Brake',0
    DB 0D0h, 'Rear Brake',0
    DB   0 , -1 ;End of Table

  VirtualRealityTbl: ;Taken from USB HID Usage Tables v1.12 2005-01-21
    DB TblFlagByte
    DB 00h, 'None/Unknown/Not Applicable',0
    DB 01h, 'Belt',0
    DB 02h, 'Body Suit',0
    DB 03h, 'Flexor',0
    DB 04h, 'Glove',0
    DB 05h, 'Head Tracker',0
    DB 06h, 'Head Mounted Display',0
    DB 07h, 'Hand Tracker',0
    DB 08h, 'Oculometer',0
    DB 09h, 'Vest',0
    DB 0Ah, 'Animatronic Device',0
    DB 20h, 'Stereo Enable',0
    DB 21h, 'Display Enable',0
    DB  0 , -1 ;End of Table

  SportCtlTbl: ;Taken from USB HID Usage Tables v1.12 2005-01-21
    DB TblFlagByte
    DB 00h, 'None/Unknown/Not Applicable',0
    DB 01h ,'Baseball Bat',0
    DB 02h, 'Golf Club',0
    DB 03h, 'Rowing Machine',0
    DB 04h, 'Treadmill',0
    DB 30h, 'Oar',0
    DB 31h, 'Slope',0
    DB 32h, 'Rate',0
    DB 33h, 'Stick Speed',0
    DB 34h, 'Stick Face Angle',0
    DB 35h, 'Stick Heel/Toe',0
    DB 36h, 'Stick Follow Through',0
    DB 47h, 'Stick Tempo',0
    DB 38h, 'Stick Type',0
    DB 39h, 'Stick Height',0
    DB 50h, 'Putter',0
    DB 51h, '1 Iron',0
    DB 52h, '2 Iron',0
    DB 53h, '3 Iron',0
    DB 54h, '4 Iron',0
    DB 55h, '5 Iron',0
    DB 56h, '6 Iron',0
    DB 57h, '7 Iron',0
    DB 58h, '8 Iron',0
    DB 59h, '9 Iron',0
    DB 5Ah, '10 Iron',0
    DB 5Bh, '11 Iron',0
    DB 5Ch, 'Sand Wedge',0
    DB 5Dh, 'Loft Wedge',0
    DB 5Eh, 'Power Wedge',0
    DB 5Fh, '1 Wood',0
    DB 60h, '3 Wood',0
    DB 61h, '5 Wood',0
    DB 62h, '7 Wood',0
    DB 63h, '9 Wood',0
    DB  0 , -1 ;End of Table

  GameCtlTbl: ;Taken from USB HID Usage Tables v1.12 2005-01-21
    DB TblFlagByte
    DB 00h, 'None/Unknown/Not Applicable',0
    DB 01h, '3D Game Controller',0
    DB 02h, 'Pinball Device',0
    DB 03h, 'Gun Device',0
    DB 20h, 'Point-of-View',0
    DB 21h, 'Turn Right/Left',0
    DB 22h, 'Pitch Forward/Backward',0 ;Pitch Right/Left??
    DB 23h, 'Roll Right/Left',0
    DB 24h, 'Move Right/Left',0
    DB 25h, 'Move Forward/Backward',0
    DB 26h, 'Move Up/Down',0
    DB 27h, 'Lean Right/Left',0
    DB 28h, 'Lean Forward/Backward',0
    DB 29h, 'Height of Point-of-View',0
    DB 2Ah, 'Flipper',0
    DB 2Bh, 'Secondary Flipper',0
    DB 2Ch, 'Bump',0
    DB 2Dh, 'New Game',0
    DB 2Eh, 'Shoot Ball',0
    DB 2Fh, 'Player',0
    DB 30h, 'Gun Bolt',0
    DB 31h, 'Gun Clip',0
    DB 32h, 'Gun Selector',0
    DB 33h, 'Gun Single Shot',0
    DB 34h, 'Gun Burst Shot',0
    DB 35h, 'Gun Automatic Shot',0
    DB 36h, 'Gun Safety',0
    DB 37h, 'Gamepad Fire/Jump',0
    DB 38h, 'Gamepad Fun',0
    DB 39h, 'Gamepad Trigger',0
    DB  0 , -1 ;End of Table

  GenericControlTbl: ;Taken from USB HID Usage Tables v1.12 2005-01-21
    DB TblFlagByte
    DB 00h, 'None',0
    DB 20h, 'Battery Strength',0
    DB 21h, 'Wireless Channel',0
    DB 22h, 'Wireless ID',0
    DB 23h, 'Discover Wireless Control',0
    DB 24h, 'Security Code Character Entered',0
    DB 25h, 'Security Code Character Erased',0
    DB 26h, 'Security Code Cleared',0
    DB  0 , -1 ;End of Table

  KeyboardTbl: ;Taken from USB HID Usage Tables v1.12 2005-01-21
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'Roll Over Error (not a key)',0
    DB  02h, 'POST Failure (not a key)',0
    DB  03h, 'Undefined Error (not a key)',0
    DB  04h, 'Aa',0
    DB  05h, 'Bb',0
    DB  06h, 'Cc',0
    DB  07h, 'Dd',0
    DB  08h, 'Ee',0
    DB  09h, 'Ff',0
    DB  0Ah, 'Gg',0
    DB  0Bh, 'Hh',0
    DB  0Ch, 'Ii',0
    DB  0Dh, 'Jj',0
    DB  0Eh, 'Kk',0
    DB  0Fh, 'Ll',0
    DB  10h, 'Mm',0
    DB  11h, 'Nn',0
    DB  12h, 'Oo',0
    DB  13h, 'Pp',0
    DB  14h, 'Qq',0
    DB  15h, 'Rr',0
    DB  16h, 'Ss',0
    DB  17h, 'Tt',0
    DB  18h, 'Uu',0
    DB  19h, 'Vv',0
    DB  1Ah, 'Ww',0
    DB  1Bh, 'Xx',0
    DB  1Ch, 'Yy',0
    DB  1Dh, 'Zz',0
    DB  1Eh, '1!',0
    DB  1Fh, '2@',0
    DB  20h, '3#',0
    DB  21h, '4$',0
    DB  22h, '5%',0
    DB  23h, '6^',0
    DB  24h, '7&',0
    DB  25h, '8*',0
    DB  26h, '9(',0
    DB  27h, '0)',0
    DB  28h, 'Enter',0
    DB  29h, 'Escape',0
    DB  2Ah, 'BackSpace',0
    DB  2Bh, 'Tab',0
    DB  2Ch, 'Space',0
    DB  2Dh, '-_',0
    DB  2Eh, '=+',0
    DB  2Fh, '[{',0
    DB  30h, ']}',0
    DB  31h, '\|',0
    DB  32h, 'Non-US #~',0
    DB  33h, ';:',0
    DB  34h, "'",'"',0
    DB  35h, '`~',0
    DB  36h, ',<',0
    DB  37h, '.>',0
    DB  38h, '/?',0
    DB  39h, 'Caps Lock',0
    DB  3Ah, 'F1',0
    DB  3Bh, 'F2',0
    DB  3Ch, 'F3',0
    DB  3Dh, 'F4',0
    DB  3Eh, 'F5',0
    DB  3Fh, 'F6',0
    DB  40h, 'F7',0
    DB  41h, 'F8',0
    DB  42h, 'F9',0
    DB  43h, 'F10',0
    DB  44h, 'F11',0
    DB  45h, 'F12',0
    DB  46h, 'Print Screen',0
    DB  47h, 'Scroll Lock',0
    DB  48h, 'Pause',0
    DB  49h, 'Grey Insert',0
    DB  4Ah, 'Grey Home',0
    DB  4Bh, 'Grey PageUp',0
    DB  4Ch, 'Grey Delete',0
    DB  4Dh, 'Grey End',0
    DB  4Eh, 'Grey PageDown',0
    DB  4Fh, 'Grey Right',0
    DB  50h, 'Grey Left',0
    DB  51h, 'Grey Down',0
    DB  52h, 'Grey Up',0
    DB  53h, 'Num Lock/Clear',0
    DB  54h, 'KeyPad /',0
    DB  55h, 'KeyPad *',0
    DB  56h, 'KeyPad -',0
    DB  57h, 'KeyPad +',0
    DB  58h, 'KeyPad Enter',0
    DB  59h, 'End & 1',0
    DB  5Ah, 'Down & 2',0
    DB  5Bh, 'PageDown & 3',0
    DB  5Ch, 'Left & 4',0
    DB  5Dh, 'KeyPad 5',0
    DB  5Eh, 'Right & 6',0
    DB  5Fh, 'Home & 7',0
    DB  60h, 'Up & 8',0
    DB  61h, 'PageUp & 9',0
    DB  62h, 'Insert & 0',0
    DB  63h, 'Delete & .',0
    DB  64h, 'Non-US \| (102nd Key)',0
    DB  65h, 'Mouse Menu (Application)',0
    DB  66h, 'Power (not a key)',0
    DB  67h, 'KeyPad =',0
    DB  68h, 'F13',0
    DB  69h, 'F14',0
    DB  6Ah, 'F15',0
    DB  6Bh, 'F16',0
    DB  6Ch, 'F17',0
    DB  6Dh, 'F18',0
    DB  6Eh, 'F19',0
    DB  6Fh, 'F20',0
    DB  70h, 'F21',0
    DB  71h, 'F22',0
    DB  72h, 'F23',0
    DB  73h, 'F24',0
    DB  74h, 'Execute',0
    DB  75h, 'Help',0
    DB  76h, 'Menu',0
    DB  77h, 'Select',0
    DB  78h, 'Stop',0
    DB  79h, 'Again',0
    DB  7Ah, 'Undo',0
    DB  7Bh, 'Cut',0
    DB  7Ch, 'Copy',0
    DB  7Dh, 'Paste',0
    DB  7Eh, 'Find',0
    DB  7Fh, 'Mute',0
    DB  80h, 'Volume Up',0
    DB  81h, 'Volume Down',0
    DB  82h, 'Locking Caps Lock',0
    DB  83h, 'Locking Num Lock',0
    DB  84h, 'Locking Scroll Lock',0
    DB  85h, 'KeyPad ,',0
    DB  86h, 'KeyPad = (AS/400)',0
    DB  87h, 'International 1',0
    DB  88h, 'International 2',0
    DB  89h, 'International 3',0
    DB  8Ah, 'International 4',0
    DB  8Bh, 'International 5',0
    DB  8Ch, 'International 6',0
    DB  8Dh, 'International 7 (Byte Mode Toggle)',0
    DB  8Eh, 'International 8',0
    DB  8Fh, 'International 9',0
    DB  90h, 'LANG 1 (Hangul/English, Korea)',0
    DB  91h, 'LANG 2 (Hanja Conversion, Korea)',0
    DB  92h, 'LANG 3 (Katakana, Japan)',0
    DB  93h, 'LANG 4 (Hiragana, Japan)',0
    DB  94h, 'LANG 5 (Zenkaku/Hnakaku, Japan)',0
    DB  95h, 'LANG 6',0
    DB  96h, 'LANG 7',0
    DB  97h, 'LANG 8',0
    DB  98h, 'LANG 9',0
    DB  99h, 'Alternate Erase',0
    DB  9Ah, 'System Request/Attention',0
    DB  9Bh, 'Cancel',0
    DB  9Ch, 'Clear',0
    DB  9Dh, 'Prior',0
    DB  9Eh, 'Return',0
    DB  9Fh, 'Separator',0
    DB 0A0h, 'Out',0
    DB 0A1h, 'Open',0
    DB 0A2h, 'Clear/Again',0
    DB 0A3h, 'CrSel/Props',0
    DB 0A4h, 'ExSel',0
    DB 0B0h, 'Keypad 00',0
    DB 0B1h, 'Keypad 000',0
    DB 0B2h, 'Keypad Thousands Separator',0
    DB 0B3h, 'Keypad Decimal Separator',0
    DB 0B4h, 'Keypad Currency Unit',0
    DB 0B5h, 'Keypad Currency Sub-unit',0
    DB 0B6h, 'Keypad (',0
    DB 0B7h, 'Keypad )',0
    DB 0B8h, 'Keypad {',0
    DB 0B9h, 'Keypad }',0
    DB 0BAh, 'Keypad Tab',0
    DB 0BBh, 'Keypad Backspace',0
    DB 0BCh, 'Keypad A',0
    DB 0BDh, 'Keypad B',0
    DB 0BEh, 'Keypad C',0
    DB 0BFh, 'Keypad D',0
    DB 0C0h, 'Keypad E',0
    DB 0C1h, 'Keypad F',0
    DB 0C2h, 'Keypad XOR',0
    DB 0C3h, 'Keypad ^',0
    DB 0C4h, 'Keypad %',0
    DB 0C5h, 'Keypad <',0
    DB 0C6h, 'Keypad >',0
    DB 0C7h, 'Keypad &',0
    DB 0C8h, 'Keypad &&',0
    DB 0C9h, 'Keypad |',0
    DB 0CAh, 'Keypad ||',0
    DB 0CBh, 'Keypad :',0
    DB 0CCh, 'Keypad #',0
    DB 0CDh, 'Keypad Space',0
    DB 0CEh, 'Keypad @',0
    DB 0CFh, 'Keypad !',0
    DB 0D0h, 'Keypad Memory Store',0
    DB 0D1h, 'Keypad Memory Recall',0
    DB 0D2h, 'Keypad Memory Clear',0
    DB 0D3h, 'Keypad Memory Add',0
    DB 0D4h, 'Keypad Memory Subtract',0
    DB 0D5h, 'Keypad Memory Multiply',0
    DB 0D6h, 'Keypad Memory Divide',0
    DB 0D7h, 'Keypad +/-',0
    DB 0D8h, 'Keypad Clear',0
    DB 0D9h, 'Keypad Celar Entry',0
    DB 0DAh, 'Keypad Binary',0
    DB 0DBh, 'Keypad Octal',0
    DB 0DCh, 'Keypad Decimal',0
    DB 0DDh, 'Keypad Hexadecimal',0
    DB 0E0h, 'Left Control',0
    DB 0E1h, 'Left Shift',0
    DB 0E2h, 'Left Alt',0
    DB 0E3h, 'Left Windows (Left GUI)',0
    DB 0E4h, 'Right Control',0
    DB 0E5h, 'Right Shift',0
    DB 0E6h, 'Right Alt (AltGr)',0
    DB 0E7h, 'Right Windows (Right GUI)',0
    DB   0 , -1 ;End of Table

  LEDTbl: ;Taken from USB HID Usage Tables v1.12 2005-01-21
    DB TblFlagByte
    DB 00h, 'None/Unknown/Not Applicable',0
    DB 01h, 'Num Lock',0
    DB 02h, 'Caps Lock',0
    DB 03h, 'Scroll Lock',0
    DB 04h, 'Compose',0
    DB 05h, 'Kana',0
    DB 06h, 'Power',0
    DB 07h, 'Shift',0
    DB 08h, 'Do Not Disturb',0
    DB 09h, 'Mute',0
    DB 0Ah, 'Tone Enable',0
    DB 0Bh, 'High Cut Filter',0
    DB 0Ch, 'Low Cut Filter',0
    DB 0Dh, 'Equalizer Enable',0
    DB 0Eh, 'Sound Field On',0
    DB 0Fh, 'Surround Field On',0
    DB 10h, 'Repeat',0
    DB 11h, 'Stereo',0
    DB 12h, 'Sampling Rate Detect',0
    DB 13h, 'Spinning',0
    DB 14h, 'CAV',0
    DB 15h, 'CLV',0
    DB 16h, 'Recording Format Detect',0
    DB 17h, 'Off-Hook',0
    DB 18h, 'Ring',0
    DB 19h, 'Message Waiting',0
    DB 1Ah, 'Data Mode',0
    DB 1Bh, 'Battery Operation',0
    DB 1Ch, 'Battery OK',0
    DB 1Dh, 'Battery Low',0
    DB 1Eh, 'Speaker',0
    DB 1Fh, 'Head Set',0
    DB 20h, 'Hold',0
    DB 21h, 'Microphone',0
    DB 22h, 'Coverage',0
    DB 23h, 'Night Mode',0
    DB 24h, 'Send Calls',0
    DB 25h, 'Call Pickup',0
    DB 26h, 'Conference',0
    DB 27h, 'Stand-by',0
    DB 28h, 'Camera On',0
    DB 29h, 'Camera Off',0
    DB 2Ah, 'On Line',0
    DB 2Bh, 'Off Line',0
    DB 2Ch, 'Busy',0
    DB 2Dh, 'Ready',0
    DB 2Eh, 'Paper Out',0
    DB 2Fh, 'Paper Jam',0
    DB 30h, 'Remote',0
    DB 31h, 'Forward',0
    DB 32h, 'Reverse',0
    DB 33h, 'Stop',0
    DB 34h, 'Rewind',0
    DB 35h, 'Fast Forward',0
    DB 36h, 'Play',0
    DB 37h, 'Pause',0
    DB 38h, 'Record',0
    DB 39h, 'Error',0
    DB 3Ah, 'Usage Selected Indicator',0
    DB 3Bh, 'Usage In Use Indicator',0
    DB 3Ch, 'Usage Multi-mode Indicator',0
    DB 3Dh, 'Indicator On',0
    DB 3Eh, 'Indicator Flash',0
    DB 3Fh, 'Indicator Slow Blink',0
    DB 40h, 'Indicator Fast Blink',0
    DB 41h, 'Indicator Off',0
    DB 42h, 'Flash On Time',0
    DB 43h, 'Slow Blink On Time',0
    DB 44h, 'Slow Blink Off Time',0
    DB 45h, 'Fast Blink On Time',0
    DB 46h, 'Fast Blink Off Time',0
    DB 47h, 'Usage Color Indicator',0
    DB 48h, 'Indicator Red',0
    DB 49h, 'Indicator Green',0
    DB 4Ah, 'Indicator Amber',0
    DB 4Bh, 'Generic Indicator',0
    DB 4Ch, 'System Suspend',0
    DB 4Dh, 'External Power Connected',0
    DB  0 , -1 ;End of Table

  ButtonTbl: ;Taken from USB HID Usage Tables v1.12 2005-01-21
    DB TblFlagByte
    DB 00h, 'None/Unknown/Not Applicable',0
    DB 01h, 'Button #1 (Primary)',0
    DB 02h, 'Button #2 (Secondary)',0
    DB 03h, 'Button #3 (Tertiary)',0
    DB 04h, 'Button #4 (Quaternary)',0
    DB 05h, 'Button #5 (Quinary)',0
    DB 06h, 'Button #6 (Senary)',0
    DB 07h, 'Button #7 (Septenary)',0
    DB 08h, 'Button #8 (Octonary)',0
    DB 09h, 'Button #9 (Nonary)',0
    DB 0Ah, 'Button #10 (Denary)',0
    DB 0Bh, 'Button #11',0
    DB 0Ch, 'Button #12 (Duodenary)',0
    DB 0Dh, 'Button #13',0
    DB 0Eh, 'Button #14',0
    DB 0Fh, 'Button #15',0
    DB 10h, 'Button #16',0
    DB 11h, 'Button #17',0
    DB 12h, 'Button #18',0
    DB 13h, 'Button #19',0
    DB 14h, 'Button #20 (Vigenary)',0
    DB 15h, 'Button #21',0
    DB 16h, 'Button #22',0
    DB 17h, 'Button #23',0
    DB 18h, 'Button #24',0
    DB 19h, 'Button #25',0
    DB 1Ah, 'Button #26',0
    DB 1Bh, 'Button #27',0
    DB 1Ch, 'Button #28',0
    DB 1Dh, 'Button #29',0
    DB 1Eh, 'Button #30',0
    DB 1Fh, 'Button #31',0
    DB 20h, 'Button #32',0
    DB  0 , -1 ;End of Table

  OrdinalTbl: ;Taken from USB HID Usage Tables v1.12 2005-01-21
    DB TblFlagByte
    DB 00h, 'None/Unknown/Not Applicable',0
    DB 01h, 'Instance #1 (Primary)',0
    DB 02h, 'Instance #2 (Secondary)',0
    DB 03h, 'Instance #3 (Tertiary)',0
    DB 03h, 'Instance #4 (Quaternary)',0
    DB 03h, 'Instance #5 (Quinary)',0
    DB 03h, 'Instance #6 (Senary)',0
    DB 03h, 'Instance #7 (Septenary)',0
    DB 03h, 'Instance #8 (Octonary)',0
    DB 03h, 'Instance #9 (Nonary)',0
    DB 03h, 'Instance #10 (Denary)',0
    DB 03h, 'Instance #11',0
    DB 03h, 'Instance #12 (Duodenary)',0
    DB 03h, 'Instance #13',0
    DB 03h, 'Instance #14',0
    DB 03h, 'Instance #15',0
    DB 03h, 'Instance #16',0
    DB 03h, 'Instance #17',0
    DB 03h, 'Instance #18',0
    DB 03h, 'Instance #19',0
    DB 03h, 'Instance #20 (Vigenary)',0
    DB  0 , -1 ;End of Table

  TelephonyTbl: ;Taken from USB HID Usage Tables v1.12 2005-01-21
    DB  TblFlagByte
    DB  00h, 'None/Unknown/Not Applicable',0
    DB  01h, 'Phone',0
    DB  02h, 'Answering Machine',0
    DB  03h, 'Message Controls',0
    DB  04h, 'Handset',0
    DB  05h, 'Headset',0
    DB  06h, 'Telephony Key Pad',0
    DB  07h, 'Programmable Button',0
    DB  20h, 'Hook Switch',0
    DB  21h, 'Flash',0
    DB  22h, 'Feature',0
    DB  23h, 'Hold',0
    DB  24h, 'Redial',0
    DB  25h, 'Transfer',0
    DB  26h, 'Drop',0
    DB  27h, 'Park',0
    DB  28h, 'Forward Calls',0
    DB  29h, 'Alternate Function',0
    DB  2Ah, 'Line',0
    DB  2Bh, 'Speaker Phone',0
    DB  2Ch, 'Conference',0
    DB  2Dh, 'Ring Enable',0
    DB  2Eh, 'Ring Select',0
    DB  2Fh, 'Phone Mute',0
    DB  30h, 'Caller ID',0
    DB  31h, 'Send',0
    DB  50h, 'Speed Dial',0
    DB  51h, 'Store Number',0
    DB  52h, 'Recall Number',0
    DB  53h, 'Phone Directory',0
    DB  70h, 'Voice Mail',0
    DB  71h, 'Screen Calls',0
    DB  72h, 'Do Not Disturb',0
    DB  73h, 'Message',0
    DB  74h, 'Answer On/Offf',0
    DB  90h, 'Inside Dial Tone',0
    DB  91h, 'Outside Dial Tone',0
    DB  92h, 'Inside Ring Tone',0
    DB  93h, 'Outside Ring Tone',0
    DB  94h, 'Priority Ring Tone',0
    DB  95h, 'Inside Ringback',0
    DB  96h, 'Priority Ringback',0
    DB  97h, 'Line Busy Tone',0
    DB  98h, 'Recorder Tone',0
    DB  99h, 'Call Waiting Tone',0
    DB  9Ah, 'Confirmation Tone 1',0
    DB  9Bh, 'Confirmation Tone 2',0
    DB  9Ch, 'Tones Off',0
    DB  9Dh, 'Outside Ringback',0
    DB  9Eh, 'Ringer',0
    DB 0B0h, 'Phone Key 1',0
    DB 0B1h, 'Phone Key 2',0
    DB 0B3h, 'Phone Key 3',0
    DB 0B4h, 'Phone Key 4',0
    DB 0B5h, 'Phone Key 5',0
    DB 0B6h, 'Phone Key 6',0
    DB 0B7h, 'Phone Key 7',0
    DB 0B8h, 'Phone Key 8',0
    DB 0B9h, 'Phone Key 9',0
    DB 0BAh, 'Phone Key *',0
    DB 0BBh, 'Phone Key #',0
    DB 0BCh, 'Phone Key A',0
    DB 0BDh, 'Phone Key B',0
    DB 0BEh, 'Phone Key C',0
    DB 0BFh, 'Phone Key D',0
    DB   0 , -1 ;End of Table

  ConsumerTbl: ;Taken from USB HID Usage Tables v1.12 2005-01-21
    DB  TblFlagWord
    DW 0000h
       DB 'None/Unknown/Not Applicable',0
    DW 0001h
       DB 'Consumer Control',0
    DW 0002h
       DB 'Numeric Key Pad',0
    DW 0003h
       DB 'Programmable Buttons',0
    DW 0004h
       DB 'Microphone',0
    DW 0005h
       DB 'Headphone',0
    DW 0006h
       DB 'Graphic Equalizer',0
    DW 0020h
       DB '+10',0
    DW 0021h
       DB '+100',0
    DW 0022h
       DB 'AM/PM',0
    DW 0030h
       DB 'Power',0
    DW 0031h
       DB 'Reset',0
    DW 0032h
       DB 'Sleep',0
    DW 0033h
       DB 'Sleep After',0
    DW 0034h
       DB 'Sleep Mode',0
    DW 0035h
       DB 'Illumination',0
    DW 0036h
       DB 'Function Buttons',0
    DW 0040h
       DB 'Menu',0
    DW 0041h
       DB 'Menu Pick',0
    DW 0042h
       DB 'Menu Up',0
    DW 0043h
       DB 'Menu Down',0
    DW 0044h
       DB 'Menu Left',0
    DW 0045h
       DB 'Menu Right',0
    DW 0046h
       DB 'Menu Escape',0
    DW 0047h
       DB 'Menu Value Increase',0
    DW 0048h
       DB 'Menu Value Decrease',0
    DW 0060h
       DB 'Data on Screen',0
    DW 0061h
       DB 'Closed Caption',0
    DW 0062h
       DB 'Closed Caption Select',0
    DW 0063h
       DB 'VCR/TV',0
    DW 0064h
       DB 'Broadcast Mode',0
    DW 0065h
       DB 'Snapshot',0
    DW 0066h
       DB 'Still',0
    DW 0080h
       DB 'Selection',0
    DW 0081h
       DB 'Assign Selection',0
    DW 0082h
       DB 'Mode Step',0
    DW 0083h
       DB 'Recall Last',0
    DW 0084h
       DB 'Enter Channel',0
    DW 0085h
       DB 'Order Movie',0
    DW 0086h
       DB 'Channel',0
    DW 0087h
       DB 'Media Selection',0
    DW 0088h
       DB 'Media Select Computer',0
    DW 0089h
       DB 'Media Select TV',0
    DW 008Ah
       DB 'Media Select WWW',0
    DW 008Bh
       DB 'Media Select DVD',0
    DW 008Ch
       DB 'Media Select Telephone',0
    DW 008Dh
       DB 'Media Select Program Guide',0
    DW 008Eh
       DB 'Media Select Video Phone',0
    DW 008Fh
       DB 'Media Select Games',0
    DW 0090h
       DB 'Media Select Messages',0
    DW 0091h
       DB 'Media Select CD',0
    DW 0092h
       DB 'Media Select VCR',0
    DW 0093h
       DB 'Media Select Tuner',0
    DW 0094h
       DB 'Quit',0
    DW 0095h
       DB 'Help',0
    DW 0096h
       DB 'Media Select Tape',0
    DW 0097h
       DB 'Media Select Cable',0
    DW 0098h
       DB 'Media Select Satellite',0
    DW 0099h
       DB 'Media Select Security',0
    DW 009Ah
       DB 'Media Select Home',0
    DW 009Bh
       DB 'Media Select Call',0
    DW 009Ch
       DB 'Channel Increment',0
    DW 009Dh
       DB 'Channel Decrement',0
    DW 009Eh
       DB 'Media Select SAP',0
    DW 00A0h
       DB 'VCR Plus',0
    DW 00A1h
       DB 'Once',0
    DW 00A2h
       DB 'Daily',0
    DW 00A3h
       DB 'Weekly',0
    DW 00A4h
       DB 'Monthly',0
    DW 00B0h
       DB 'Play',0
    DW 00B1h
       DB 'Pause',0
    DW 00B2h
       DB 'Record',0
    DW 00B3h
       DB 'Fast Forward',0
    DW 00B4h
       DB 'Rewind',0
    DW 00B5h
       DB 'Scan Next Track',0
    DW 00B6h
       DB 'Scan Previous Track',0
    DW 00B7h
       DB 'Stop',0
    DW 00B8h
       DB 'Eject',0
    DW 00B9h
       DB 'Random Play',0
    DW 00BAh
       DB 'Select Disc',0
    DW 00BBh
       DB 'Enter Disc',0
    DW 00BCh
       DB 'Repeat',0
    DW 00BDh
       DB 'Tracking',0
    DW 00BEh
       DB 'Track Normal',0
    DW 00BFh
       DB 'Slow Tracking',0
    DW 00C0h
       DB 'Frame Forward',0
    DW 00C1h
       DB 'Frame Back',0
    DW 00C2h
       DB 'Mark',0
    DW 00C3h
       DB 'Clear Mark',0
    DW 00C4h
       DB 'Repeat from Mark',0
    DW 00C5h
       DB 'Return to Mark',0
    DW 00C6h
       DB 'Search Mark Forward',0
    DW 00C7h
       DB 'Search Mark Backward',0
    DW 00C8h
       DB 'Counter Reset',0
    DW 00C9h
       DB 'Show Counter',0
    DW 00CAh
       DB 'Tracking Increment',0
    DW 00CBh
       DB 'Tracking Decrement',0
    DW 00CCh
       DB 'Stop/Eject',0
    DW 00CDh
       DB 'Play/Pause',0
    DW 00CEh
       DB 'Play/Skip',0
    DW 00E0h
       DB 'Volume',0
    DW 00E1h
       DB 'Balance',0
    DW 00E2h
       DB 'Mute',0
    DW 00E3h
       DB 'Bass',0
    DW 00E4h
       DB 'Treble',0
    DW 00E5h
       DB 'Bass Boost',0
    DW 00E6h
       DB 'Surround Mode',0
    DW 00E7h
       DB 'Loudness',0
    DW 00E8h
       DB 'MPX',0
    DW 00E9h
       DB 'Volume Increment',0
    DW 00EAh
       DB 'Volume Decrement',0
    DW 00F0h
       DB 'Speed Select',0
    DW 00F1h
       DB 'Playback Speed',0
    DW 00F2h
       DB 'Standard Play',0
    DW 00F3h
       DB 'Long Play',0
    DW 00F4h
       DB 'Extended Play',0
    DW 00F5h
       DB 'Slow',0
    DW 0100h
       DB 'Fan Enable',0
    DW 0101h
       DB 'Fan Speed',0
    DW 0102h
       DB 'Light Enable',0
    DW 0103h
       DB 'Light Illumination Level',0
    DW 0104h
       DB 'Climate Control Enable',0
    DW 0105h
       DB 'Room Temperature',0
    DW 0106h
       DB 'Security Enable',0
    DW 0107h
       DB 'Fire Alarm',0
    DW 0108h
       DB 'Police Alarm',0
    DW 0109h
       DB 'Proximity Alarm',0
    DW 010Ah
       DB 'Motion Alarm',0
    DW 010Bh
       DB 'Duress Alarm',0
    DW 010Ch
       DB 'Holdup Alarm',0
    DW 010Dh
       DB 'Medical Alarm',0
    DW 0150h
       DB 'Balance Right',0
    DW 0151h
       DB 'Balance Left',0
    DW 0152h
       DB 'Bass Increment',0
    DW 0153h
       DB 'Bass Decrement',0
    DW 0154h
       DB 'Treble Increment',0
    DW 0155h
       DB 'Treble Decrement',0
    DW 0160h
       DB 'Speaker System',0
    DW 0161h
       DB 'Channel Left',0
    DW 0162h
       DB 'Channel Right',0
    DW 0163h
       DB 'Channel Center',0
    DW 0164h
       DB 'Channel Front',0
    DW 0165h
       DB 'Channel Center Front',0
    DW 0166h
       DB 'Channel Side',0
    DW 0167h
       DB 'Channel Surround',0
    DW 0168h
       DB 'Channel Low Frequency Enhancement',0
    DW 0169h
       DB 'Channel Top',0
    DW 016Ah
       DB 'Channel Unknown',0
    DW 0170h
       DB 'Sub-Channel',0
    DW 0171h
       DB 'Sub-Channel Increment',0
    DW 0172h
       DB 'Sub-Channel Decrement',0
    DW 0173h
       DB 'Alternate Audio Increment',0
    DW 0174h
       DB 'Alternate Audio Decrement',0
    DW 0180h
       DB 'Application Launch Buttons',0
    DW 0181h
       DB 'AL Launch Button Configuration Tool',0
    DW 0182h
       DB 'AL Launch Button Configuration',0
    DW 0183h
       DB 'AL Consumer Control Configuration',0
    DW 0184h
       DB 'AL Word Processor',0
    DW 0185h
       DB 'AL Text Editor',0
    DW 0186h
       DB 'AL Spreadsheet',0
    DW 0187h
       DB 'AL Graphics Editor',0
    DW 0188h
       DB 'AL Presentation App',0
    DW 0189h
       DB 'AL Database App',0
    DW 018Ah
       DB 'AL Email Reader',0
    DW 018Bh
       DB 'AL Newsreader',0
    DW 018Ch
       DB 'AL Voicemail',0
    DW 018Dh
       DB 'AL Contacts/Address Book',0
    DW 018Eh
       DB 'AL Calendar/Schedule',0
    DW 018Fh
       DB 'AL Task/Project Manager',0
    DW 0190h
       DB 'AL Log/Jounal/Timecard',0
    DW 0191h
       DB 'AL Checkbook/Finance',0
    DW 0192h
       DB 'AL Calculator',0
    DW 0193h
       DB 'AL A/V Capture/Playback',0
    DW 0194h
       DB 'AL Local Machine Browser',0
    DW 0195h
       DB 'AL LAN/WAN Browser',0
    DW 0196h
       DB 'AL Internet Browser',0
    DW 0197h
       DB 'AL Remote Networking/ISP Connect',0
    DW 0198h
       DB 'AL Network Conference',0
    DW 0199h
       DB 'AL Network Chat',0
    DW 019Ah
       DB 'AL Telephony/Dialer',0
    DW 019Bh
       DB 'AL Logon',0
    DW 019Ch
       DB 'AL Logoff',0
    DW 019Dh
       DB 'AL Logon/Logoff',0
    DW 019Eh
       DB 'AL Terminal Local/Screensaver',0
    DW 019Fh
       DB 'AL Control Panel',0
    DW 01A0h
       DB 'AL Command Line Processor/Run',0
    DW 01A1h
       DB 'AL Process/Task Manager',0
    DW 01A2h
       DB 'AL Select Task/Application',0
    DW 01A3h
       DB 'AL Next Task/Application',0
    DW 01A4h
       DB 'AL Previous Task/Application',0
    DW 01A5h
       DB 'AL Preemptive Halt Task/Application',0
    DW 01A6h
       DB 'AL Integrated Help Center',0
    DW 01A7h
       DB 'AL Documents',0
    DW 01A8h
       DB 'AL Thesaurus',0
    DW 01A9h
       DB 'AL Dictionary',0
    DW 01AAh
       DB 'AL Desktop',0
    DW 01ABh
       DB 'AL Spell Check',0
    DW 01ACh
       DB 'AL Grammar Check',0
    DW 01ADh
       DB 'AL Wireless Status',0
    DW 01AEh
       DB 'AL Keyboard Layout',0
    DW 01AFh
       DB 'AL Virus Protection',0
    DW 01B0h
       DB 'AL Encryption',0
    DW 01B1h
       DB 'AL Screen Saver',0
    DW 01B2h
       DB 'AL Alarms',0
    DW 01B3h
       DB 'AL Clock',0
    DW 01B4h
       DB 'AL File Browser',0
    DW 01B5h
       DB 'AL Power Status',0
    DW 01B6h
       DB 'AL Image Browser',0
    DW 01B7h
       DB 'AL Audio Browser',0
    DW 01B8h
       DB 'AL Movie Browser',0
    DW 01B9h
       DB 'AL Digital Rights Manager',0
    DW 01BAh
       DB 'AL Digital Wallet',0
    DW 01BCh
       DB 'AL Instant Messaging',0
    DW 01BDh
       DB 'AL OEM Features/Tips/Tutorial Browser',0
    DW 01BEh
       DB 'AL OEM Help',0
    DW 01BFh
       DB 'AL Online Community',0
    DW 01C0h
       DB 'AL Entertainment Content Browser',0
    DW 01C1h
       DB 'AL Online Shopping Browser',0
    DW 01C2h
       DB 'AL SmartCard Information/Help',0
    DW 01C3h
       DB 'AL Market Monitor/Finance Browser',0
    DW 01C4h
       DB 'AL Customized Corporate News Browser',0
    DW 01C5h
       DB 'AL Online Activity Browser',0
    DW 01C6h
       DB 'AL Research/Search Browser',0
    DW 01C7h
       DB 'AL Audio Player',0
    DW 0200h
       DB 'Generic GUI Application Controls',0
    DW 0201h
       DB 'AC New',0
    DW 0202h
       DB 'AC Open',0
    DW 0203h
       DB 'AC Close',0
    DW 0204h
       DB 'AC Exit',0
    DW 0205h
       DB 'AC Maximize',0
    DW 0206h
       DB 'AC Minimize',0
    DW 0207h
       DB 'AC Save',0
    DW 0208h
       DB 'AC Print',0
    DW 0209h
       DB 'AC Properties',0
    DW 021Ah
       DB 'AC Undo',0
    DW 021Bh
       DB 'AC Copy',0
    DW 021Ch
       DB 'AC Cut',0
    DW 021Dh
       DB 'AC Paste',0
    DW 021Eh
       DB 'AC Select All',0
    DW 021Fh
       DB 'AC Find',0
    DW 0220h
       DB 'AC Find and Replace',0
    DW 0221h
       DB 'AC Search',0
    DW 0222h
       DB 'AC Go To',0
    DW 0223h
       DB 'AC Home',0
    DW 0224h
       DB 'AC Back',0
    DW 0225h
       DB 'AC Forward',0
    DW 0226h
       DB 'AC Stop',0
    DW 0227h
       DB 'AC Refresh',0
    DW 0228h
       DB 'AC Previous Link',0
    DW 0229h
       DB 'AC Next Link',0
    DW 022Ah
       DB 'AC Bookmarks',0
    DW 022Bh
       DB 'AC History',0
    DW 022Ch
       DB 'AC Subscriptions',0
    DW 022Dh
       DB 'AC Zoom In',0
    DW 022Eh
       DB 'AC Zoom Out',0
    DW 022Fh
       DB 'AC Zoom',0
    DW 0230h
       DB 'AC Full Screen View',0
    DW 0231h
       DB 'AC Normal View',0
    DW 0232h
       DB 'AC View Toggle',0
    DW 0233h
       DB 'AC Scroll Up',0
    DW 0234h
       DB 'AC Scroll Down',0
    DW 0235h
       DB 'AC Scroll',0
    DW 0236h
       DB 'AC Pan Left',0
    DW 0237h
       DB 'AC Pan Right',0
    DW 0238h
       DB 'AC Pan',0
    DW 0239h
       DB 'AC New Window',0
    DW 023Ah
       DB 'AC Tile Horizontally',0
    DW 023Bh
       DB 'AC Tile Vertically',0
    DW 023Ch
       DB 'AC Format',0
    DW 023Dh
       DB 'AC Edit',0
    DW 023Eh
       DB 'AC Bold',0
    DW 023Fh
       DB 'AC Italics',0
    DW 0240h
       DB 'AC Underline',0
    DW 0241h
       DB 'AC Strikethrough',0
    DW 0242h
       DB 'AC Subscript',0
    DW 0243h
       DB 'AC Superscript',0
    DW 0244h
       DB 'AC All Caps',0
    DW 0245h
       DB 'AC Rotate',0
    DW 0246h
       DB 'AC Resize',0
    DW 0247h
       DB 'AC Flip Horizontal',0
    DW 0248h
       DB 'AC Flip Vertical',0
    DW 0249h
       DB 'AC Mirror Horizontal',0
    DW 024Ah
       DB 'AC Mirror Vertical',0
    DW 024Bh
       DB 'AC Font Select',0
    DW 024Ch
       DB 'AC Font Color',0
    DW 024Dh
       DB 'AC Font Size',0
    DW 024Eh
       DB 'AC Justify Left',0
    DW 024Fh
       DB 'AC Justify Center Horizontal',0
    DW 0250h
       DB 'AC Justify Right',0
    DW 0251h
       DB 'AC Justify Block Horizontal',0
    DW 0252h
       DB 'AC Justify Top',0
    DW 0253h
       DB 'AC Justify Center Vertical',0
    DW 0254h
       DB 'AC Justify Bottom',0
    DW 0255h
       DB 'AC Justify Block Vertical',0
    DW 0256h
       DB 'AC Indent Decrease',0
    DW 0257h
       DB 'AC Indent Increase',0
    DW 0258h
       DB 'AC Numbered List',0
    DW 0259h
       DB 'AC Restart Numbering',0
    DW 025Ah
       DB 'AC Bulleted List',0
    DW 025Bh
       DB 'AC Promote',0
    DW 025Ch
       DB 'AC Demote',0
    DW 025Dh
       DB 'AC Yes',0
    DW 025Eh
       DB 'AC No',0
    DW 025Fh
       DB 'AC Cancel',0
    DW 0260h
       DB 'AC Catalog',0
    DW 0261h
       DB 'AC Buy/Checkout',0
    DW 0262h
       DB 'AC Add to Cart',0
    DW 0263h
       DB 'AC Expand',0
    DW 0264h
       DB 'AC Expand All',0
    DW 0265h
       DB 'AC Collapse',0
    DW 0266h
       DB 'AC Collapse All',0
    DW 0267h
       DB 'AC Print Preview',0
    DW 0268h
       DB 'AC Paste Special',0
    DW 0269h
       DB 'AC Insert Mode',0
    DW 026Ah
       DB 'AC Delete',0
    DW 026Bh
       DB 'AC Lock',0
    DW 026Ch
       DB 'AC Unlock',0
    DW 026Dh
       DB 'AC Protect',0
    DW 026Eh
       DB 'AC Unprotect',0
    DW 026Fh
       DB 'AC Attach Comment',0
    DW 0270h
       DB 'AC Delete Comment',0
    DW 0271h
       DB 'AC View Comment',0
    DW 0272h
       DB 'AC Select Word',0
    DW 0273h
       DB 'AC Select Sentence',0
    DW 0274h
       DB 'AC Select Paragraph',0
    DW 0275h
       DB 'AC Select Column',0
    DW 0276h
       DB 'AC Select Row',0
    DW 0277h
       DB 'AC Select Table',0
    DW 0278h
       DB 'AC Select Object',0
    DW 0279h
       DB 'AC Redo/Repeat',0
    DW 027Ah
       DB 'AC Sort',0
    DW 027Bh
       DB 'AC Sort Ascending',0
    DW 027Ch
       DB 'AC Sort Descending',0
    DW 027Dh
       DB 'AC Filter',0
    DW 027Eh
       DB 'AC Set Clock',0
    DW 027Fh
       DB 'AC View Clock',0
    DW 0280h
       DB 'AC Select Time Zone',0
    DW 0281h
       DB 'AC Edit Time Zones',0
    DW 0282h
       DB 'AC Set Alarm',0
    DW 0283h
       DB 'AC Clear Alarm',0
    DW 0284h
       DB 'AC Snooze Alarm',0
    DW 0285h
       DB 'AC Reset Alarm',0
    DW 0286h
       DB 'AC Synchronize',0
    DW 0287h
       DB 'AC Send/Receive',0
    DW 0288h
       DB 'AC Send To',0
    DW 0289h
       DB 'AC Reply',0
    DW 028Ah
       DB 'AC Reply All',0
    DW 028Bh
       DB 'AC Forward Message',0
    DW 028Ch
       DB 'AC Send',0
    DW 028Dh
       DB 'AC Attach File',0
    DW 028Eh
       DB 'AC Upload',0
    DW 028Fh
       DB 'AC Download (Save Target As)',0
    DW 0290h
       DB 'AC Set Borders',0
    DW 0291h
       DB 'AC Insert Row',0
    DW 0292h
       DB 'AC Insert Column',0
    DW 0293h
       DB 'AC Insert File',0
    DW 0294h
       DB 'AC Insert Picture',0
    DW 0295h
       DB 'AC Insert Object',0
    DW 0296h
       DB 'AC Insert Symbol',0
    DW 0297h
       DB 'AC Save and Close',0
    DW 0298h
       DB 'AC Rename',0
    DW 0299h
       DB 'AC Merge',0
    DW 029Ah
       DB 'AC Split',0
    DW 029Bh
       DB 'AC Distribute Horizontally',0
    DW 029Ch
       DB 'AC Distribute Vertically',0
    DW    0   ;End of
       DB -1  ;  Table

  DigitizerTbl: ;Taken from USB HID Usage Tables v1.12 2005-01-21
    DB TblFlagByte
    DB 00h, 'None/Unknown/Not Applicable',0
    DB 01h, 'Digitizer',0
    DB 02h, 'Pen',0
    DB 03h, 'Light Pen',0
    DB 04h, 'Touch Screen',0
    DB 05h, 'Touch Pad',0
    DB 06h, 'White Board',0
    DB 07h, 'Coordinate Measuring Machine',0
    DB 08h, '3D Digitizer',0
    DB 09h, 'Stereo Plotter',0
    DB 0Ah, 'Articulated Arm',0
    DB 0Bh, 'Armature',0
    DB 0Ch, 'Multiple Point Digitizer',0
    DB 0Dh, 'Free Space Wand',0
    DB 20h, 'Stylus',0
    DB 21h, 'Puck',0
    DB 22h, 'Finger',0
    DB 30h, 'Tip Pressure',0
    DB 31h, 'Barrel Pressure',0
    DB 32h, 'In Range',0
    DB 33h, 'Touch',0
    DB 34h, 'Untouch',0
    DB 35h, 'Tap',0
    DB 36h, 'Quality',0
    DB 37h, 'Data Valid',0
    DB 38h, 'Transducer Index',0
    DB 39h, 'Tablet Function Keys',0
    DB 3Ah, 'Program Change Keys',0
    DB 3Bh, 'Battery Strength',0
    DB 3Ch, 'Invert',0
    DB 3Dh, 'X Tilt',0
    DB 3Eh, 'Y Tilt',0
    DB 3Fh, 'Azimuth',0
    DB 40h, 'Altitude',0
    DB 41h, 'Twist',0
    DB 42h, 'Tip Switch',0
    DB 43h, 'Secondary Tip Switch',0
    DB 44h, 'Barrel Switch',0
    DB 45h, 'Eraser',0
    DB 46h, 'Tablet Pick',0
    DB  0 , -1 ;End of Table

  PIDTbl:  ;Taken from USB PID Spec v1.0 1999-09-08
    DB  TblFlagByte
    DB  00h, 'None/Unknown/Not Applicable',0
    DB  01h, 'Physical Interface Device',0
    DB  20h, 'Normal',0
    DB  21h, 'Set Effect Report',0
    DB  22h, 'Effect Block Index',0
    DB  23h, 'Parameter Block Offset',0
    DB  24h, 'ROM Flag',0
    DB  25h, 'Effect Type',0
    DB  26h, 'ET Constant Force',0
    DB  27h, 'ET Ramp',0
    DB  28h, 'ET Custom Force Data',0
    DB  30h, 'ET Square',0
    DB  31h, 'ET Sine',0
    DB  32h, 'ET Triangle',0
    DB  33h, 'ET Sawtooth Up',0
    DB  34h, 'ET Sawtooth Down',0
    DB  40h, 'ET Spring',0
    DB  41h, 'ET Damper',0
    DB  42h, 'ET Inertia',0
    DB  43h, 'ET Friction',0
    DB  50h, 'Duration',0
    DB  51h, 'Sample Period',0
    DB  52h, 'Gain',0
    DB  53h, 'Trigger Button',0
    DB  54h, 'Trigger Repeat Interval',0
    DB  55h, 'Axes Enable',0
    DB  56h, 'Direction Enable',0
    DB  57h, 'Direction',0
    DB  58h, 'Type Specific Block Offset',0
    DB  59h, 'Block Type',0
    DB  5Ah, 'Set Envelope Report',0
    DB  5Bh, 'Attack Level',0
    DB  5Ch, 'Attack Time',0
    DB  5Dh, 'Fade Level',0
    DB  5Eh, 'Fade Time',0
    DB  5Fh, 'Set Condition Report',0
    DB  60h, 'CP Offset',0
    DB  61h, 'Positive Coefficient',0
    DB  62h, 'Negative Coefficient',0
    DB  63h, 'Positive Saturation',0
    DB  64h, 'Negative Saturation',0
    DB  65h, 'Dead Band',0
    DB  66h, 'Download Force Sample',0
    DB  67h, 'Isoch Custom Force Enable',0
    DB  68h, 'Custom Force Data Report',0
    DB  69h, 'Custom Force Data',0
    DB  6Ah, 'Custom Force Vendor Defined Data',0
    DB  6Bh, 'Set Custom Force Report',0
    DB  6Ch, 'Custom Force Data Offset',0
    DB  6Dh, 'Sample Count',0
    DB  6Eh, 'Set Periodic Report',0
    DB  6Fh, 'Offset',0
    DB  70h, 'Magnitude',0
    DB  71h, 'Phase',0
    DB  72h, 'Period',0
    DB  73h, 'Set Constant Force Report',0
    DB  74h, 'Set Ramp Force Report',0
    DB  75h, 'Ramp Start',0
    DB  76h, 'Ramp End',0
    DB  77h, 'Effect Operation Report',0
    DB  78h, 'Effect Operation',0
    DB  79h, 'Op Effect Start',0
    DB  7Ah, 'Op Effect Start Solo',0
    DB  7Bh, 'Op Effect Stop',0
    DB  7Ch, 'Loop Count',0
    DB  7Dh, 'Device Gain Report',0
    DB  7Eh, 'Device Gain',0
    DB  7Fh, 'PID Pool Report',0
    DB  80h, 'RAM Pool Size',0
    DB  81h, 'ROM Pool Size',0
    DB  82h, 'ROM Effect Block Count',0
    DB  83h, 'Simultaneous Effects Max',0
    DB  84h, 'Pool Alignment',0
    DB  85h, 'PID Pool Move Report',0
    DB  86h, 'Move Source',0
    DB  87h, 'Move Destination',0
    DB  88h, 'Move Length',0
    DB  89h, 'PID Block Load Report',0
    DB  8Bh, 'Block Load Status',0
    DB  8Ch, 'Block Load Success',0
    DB  8Dh, 'Block Load Full',0
    DB  8Eh, 'Block Load Error',0
    DB  8Fh, 'Block Handle',0
    DB  90h, 'PID Block Free Report',0
    DB  91h, 'Type Specific Block Handle',0
    DB  92h, 'PID State Report',0
    DB  94h, 'Effect Playing',0
    DB  95h, 'PID Device Control Report',0
    DB  96h, 'PID Device Control',0
    DB  97h, 'DC Enable Actuators',0
    DB  98h, 'DC Disable Actuators',0
    DB  99h, 'DC Stop All Effects',0
    DB  9Ah, 'DC Device Reset',0
    DB  9Bh, 'DC Device Pause',0
    DB  9Ch, 'DC Device Continue',0
    DB  9Fh, 'Device Paused',0
    DB 0A0h, 'Actuators Enabled',0
    DB 0A4h, 'Safety Switch',0
    DB 0A5h, 'Actuator Override Switch',0
    DB 0A6h, 'Actuator Power',0
    DB 0A7h, 'Start Delay',0
    DB 0A8h, 'Parameter Block Size',0
    DB 0A9h, 'Device Managed Pool',0
    DB 0AAh, 'Shared Parameter Blocks',0
    DB 0ABh, 'Create New Effect Report',0
    DB 0ACh, 'RAM Pool Available',0
    DB   0 , -1 ;End of Table

  AlphaNumericTbl: ;Taken from USB HID Usage Tables v1.12 2005-01-21
    DB TblFlagByte
    DB 00h, 'None/Unknown/Not Applicable',0
    DB 01h, 'AlphaNumeric Display',0
    DB 02h, 'Bitmapped Display',0
    DB 20h, 'Display Attributes Report',0
    DB 21h, 'ASCII Character Set',0
    DB 22h, 'Data Read Back',0
    DB 23h, 'Font Read Back',0
    DB 24h, 'Display Control Report',0
    DB 25h, 'Clear Display',0
    DB 26h, 'Display Enable',0
    DB 27h, 'Screen Saver Delay',0
    DB 28h, 'Screen Saver Enable',0
    DB 29h, 'Vertical Scroll',0
    DB 2Ah, 'Horizontal Scroll',0
    DB 2Bh, 'Character Report',0
    DB 2Ch, 'Display Data',0
    DB 2Dh, 'Display Status',0
    DB 2Eh, 'Stat Not Ready',0
    DB 2Fh, 'Stat Ready',0
    DB 30h, 'Err Not a loadable Character',0
    DB 31h, 'Err Font Data Cannot Be Read',0
    DB 32h, 'Cursor Position Report',0
    DB 33h, 'Row',0
    DB 34h, 'Column',0
    DB 35h, 'Rows',0
    DB 36h, 'Columns',0
    DB 37h, 'Cursor Pixel Positioning',0
    DB 38h, 'Cursor Mode',0
    DB 39h, 'Cursor Enable',0
    DB 3Ah, 'Cursor Blink',0
    DB 3Bh, 'Font Report',0
    DB 3Ch, 'Font Data',0
    DB 3Dh, 'Character Width',0
    DB 3Eh, 'Character Height',0
    DB 3Fh, 'Character Spacing Horizontal',0
    DB 40h, 'Character Spacing Vertical',0
    DB 41h, 'Unicode Character Set',0
    DB 42h, 'Font 7-Segment',0
    DB 43h, '7-Segment Direct Map',0
    DB 44h, 'Font 14-Segment',0
    DB 45h, '14-Segment Direct Map',0
    DB 46h, 'Display Brightness',0
    DB 47h, 'Display Contrast',0
    DB 48h, 'Character Attribute',0
    DB 49h, 'Attribute Readback',0
    DB 4Ah, 'Attribute Data',0
    DB 4Bh, 'Character Attribute Enhance',0
    DB 4Ch, 'Character Attribute Underline',0
    DB 4Dh, 'Character Attribute Blink',0
    DB 80h, 'Bitmap Size X',0
    DB 81h, 'Bitmap Size Y',0
    DB 83h, 'Bit Depth Format',0
    DB 84h, 'Display Orientation',0
    DB 85h, 'Palette Report',0
    DB 86h, 'Palette Data Size',0
    DB 87h, 'Palette Data Offset',0
    DB 88h, 'Palette Data',0
    DB 8Ah, 'Blit Report',0
    DB 8Bh, 'Blit Rectangle X1',0
    DB 8Ch, 'Blit Rectangle Y1',0
    DB 8Dh, 'Blit Rectangle X2',0
    DB 8Eh, 'Blit Rectangle Y2',0
    DB 8Fh, 'Blit Data',0
    DB 90h, 'Soft Button',0
    DB 91h, 'Soft Button ID',0
    DB 92h, 'Soft Button Side',0
    DB 93h, 'Soft Button Offset 1',0
    DB 94h, 'Soft Button Offset 2',0
    DB 95h, 'Soft Button Report',0
    DB  0 , -1 ;End of Table

  MedicalTbl: ;Taken from USB HID Usage Tables v1.12 2005-01-21
    DB  TblFlagByte
    DB  00h, 'None/Unknown/Not Applicable',0
    DB  01h, 'Medical Ultrasound',0
    DB  20h, 'VCR/Acquisition',0
    DB  21h, 'Freeze/Thaw',0
    DB  22h, 'Clip Store',0
    DB  23h, 'Update',0
    DB  24h, 'Next',0
    DB  25h, 'Save',0
    DB  26h, 'Print',0
    DB  27h, 'Microphone Enable',0
    DB  40h, 'Cine',0
    DB  41h, 'Transmit Power',0
    DB  42h, 'Volume',0
    DB  43h, 'Focus',0
    DB  44h, 'Depth',0
    DB  60h, 'Soft Step - Primary',0
    DB  61h, 'Soft Step - Secondary',0
    DB  70h, 'Depth Gain Compensation',0
    DB  80h, 'Zoom Select',0
    DB  81h, 'Zoom Adjust',0
    DB  82h, 'Spectral Doppler Mode Select',0
    DB  83h, 'Spectral Doppler Adjust',0
    DB  84h, 'Color Doppler Mode Select',0
    DB  85h, 'Color Doppler Adjust',0
    DB  86h, 'Motion Mode Select',0
    DB  87h, 'Motion Mode Adjust',0
    DB  88h, '2-D Mode Select',0
    DB  89h, '2-D Mode Adjust',0
    DB 0A0h, 'Soft Control Select',0
    DB 0A1h, 'Soft Control Adjust',0
    DB   0 , -1 ;End of Table

  MonitorTbl:
    DB TblFlagByte
    DB 00h, 'None/Unknown/Not Applicable',0
    DB 01h, 'Monitor Control',0
    DB 02h, 'EDID (Extended Display Identification Data)',0
    DB 03h, 'VDIF (VESA Display Information Format)',0
    DB 04h, 'VESA Version',0
    DB 05h, 'On-Screen Display',0
    DB 06h, 'AutoSize Center',0
    DB 07h, 'Polarity Horizontal Sync',0
    DB 08h, 'Polarity Vertical Sync',0
    DB 09h, 'Sync Type',0
    DB 0Ah, 'Screen Position',0
    DB 0Bh, 'Horizontal Frequency',0
    DB 0Ch, 'Vertical Frequency',0
    DB  0 , -1 ;End of Table

  MonitorVESACmdTbl:
    DB  TblFlagByte
    DB  00h, 'None/Unknown/Not Applicable',0
    DB  01h, 'Settings',0
    DB  02h, 'Degauss',0
    DB   0 , -1 ;End of Table

  MonitorVESAVCTbl:
    DB  TblFlagByte
    DB  00h, 'None/Unknown/Not Applicable',0
    DB  01h, 'Degauss',0
    DB  10h, 'Brightness',0
    DB  12h, 'Contrast',0
    DB  16h, 'Red Video Gain',0
    DB  18h, 'Green Video Gain',0
    DB  1Ah, 'Blue Video Gain',0
    DB  1Ch, 'Focus',0
    DB  20h, 'Horizontal Position',0
    DB  22h, 'Horizontal Size',0
    DB  24h, 'Horizontal Pincushion',0
    DB  26h, 'Horizontal Pincushion Balance',0
    DB  28h, 'Horizontal Misconvergence',0
    DB  2Ah, 'Horizontal Linearity',0
    DB  2Ch, 'Horizontal Linearity Balance',0
    DB  30h, 'Vertical Position',0
    DB  32h, 'Vertical Size',0
    DB  34h, 'Vertical Pincushion',0
    DB  36h, 'Vertical Pincushion Balance',0
    DB  38h, 'Vertical Misconvergence',0
    DB  3Ah, 'Vertical Linearity',0
    DB  3Ch, 'Vertical Linearity Balance',0
    DB  40h, 'Parallelogram Balance (Key Distortion)',0
    DB  42h, 'Trapezoidal Distortion (Key)',0
    DB  44h, 'Tilt (Rotation)',0
    DB  46h, 'Top Corner Distortion Control',0
    DB  48h, 'Top Corner Distortion Balance',0
    DB  4Ah, 'Bottom Corner Distortion Control',0
    DB  4Ch, 'Bottom Corner Distortion Balance',0
    DB  56h, 'Horizontal Moire',0
    DB  58h, 'Vertical Moire',0
    DB  5Eh, 'Input Level Select (ENum)',0
    DB  60h, 'Input Source Select (ENum)',0
    DB  62h, 'Stereo Mode',0
    DB  6Ch, 'Red Video Black Level',0
    DB  6Eh, 'Green Video Black Level',0
    DB  70h, 'Blue Video Black Level',0
    DB 0A2h, 'Auto Size Center (ENum)',0
    DB 0A4h, 'Polarity Horizontal Synch (ENum)',0
    DB 0A6h, 'Polarity Vertical Synch (ENum)',0
    DB 0A8h, 'Synch Type (ENum)',0
    DB 0AAh, 'Screen Orientation (ENum)',0
    DB 0ACh, 'Horizontal Frequency in Hz',0
    DB 0AEh, 'Vertical Frequency in 0.01 Hz',0
    DB 0B0h, 'Settings',0
    DB 0CAh, 'On Screen Display (ENum)',0
    DB 0D4h, 'Stereo Mode (ENum)',0
    DB   0 , -1 ;End of Table

  PowerDeviceTbl:
    DB  TblFlagByte
    DB  00h, 'Undefined',0
    DB  01h, 'Name (integer)',0
    DB  02h, 'Present Status',0
    DB  03h, 'Changed Status',0
    DB  04h, 'UPS',0
    DB  05h, 'Power Supply',0
    DB  10h, 'Battery System',0
    DB  11h, 'Battery System ID',0
    DB  12h, 'Battery',0
    DB  13h, 'Battery ID',0
    DB  14h, 'Charger',0
    DB  15h, 'Charger ID',0
    DB  16h, 'Power Converter',0
    DB  17h, 'Power Converter ID',0
    DB  18h, 'Outlet System',0
    DB  19h, 'Outlet System ID',0
    DB  1Ah, 'Input',0
    DB  1Bh, 'Input ID',0
    DB  1Ch, 'Output',0
    DB  1Dh, 'Output ID',0
    DB  1Eh, 'Flow',0
    DB  1Fh, 'Flow ID',0
    DB  20h, 'Outlet',0
    DB  21h, 'Outlet ID',0
    DB  22h, 'Gang',0
    DB  23h, 'Gang ID',0
    DB  24h, 'Sink (Power Summary?)',0
    DB  25h, 'Sink (Power Summary?) ID',0
    DB  30h, 'Voltage',0
    DB  31h, 'Current',0
    DB  32h, 'Frequency',0
    DB  33h, 'Apparent Power',0
    DB  34h, 'Active Power',0
    DB  35h, 'Percent Load',0
    DB  36h, 'Temperature',0
    DB  37h, 'Humidity',0
    DB  38h, 'Bad Count',0
    DB  40h, 'Config Voltage',0
    DB  41h, 'Config Current',0
    DB  42h, 'Config Frequency',0
    DB  43h, 'Config Apparent Power',0
    DB  44h, 'Config Active Power',0
    DB  45h, 'Config Percent Load',0
    DB  46h, 'Config Temperature',0
    DB  47h, 'Config Humidity',0
    DB  50h, 'Switch On Control',0
    DB  51h, 'Switch Off Control',0
    DB  52h, 'Toggle Control',0
    DB  53h, 'Low Voltage Transfer',0
    DB  54h, 'High Voltage Transfer',0
    DB  55h, 'Delay Before Reboot',0
    DB  56h, 'Delay Before Startup',0
    DB  57h, 'Delay Before Shutdown',0
    DB  58h, 'Test',0
    DB  59h, 'Module Reset',0
    DB  5Ah, 'Audible Alarm Control',0
    DB  60h, 'Present',0
    DB  61h, 'Good',0
    DB  62h, 'Internal Failure',0
    DB  63h, 'Voltage Out Of Range',0
    DB  64h, 'Frequency Out Of Range',0
    DB  65h, 'Overload',0
    DB  66h, 'Over Charged',0
    DB  67h, 'Over Temperature',0
    DB  68h, 'Shutdown Requested',0
    DB  69h, 'Shutdown Imminent',0
    DB  6Ah, 'Reserved',0
    DB  6Bh, 'Switch On/Off',0
    DB  6Ch, 'Switchable',0
    DB  6Dh, 'Used',0
    DB  6Eh, 'Boost',0
    DB  6Fh, 'Buck',0
    DB  70h, 'Initialized',0
    DB  71h, 'Tested',0
    DB  72h, 'Awaiting Power',0
    DB  73h, 'Communication Lost',0
    DB 0FDh, 'Manufacturer (integer)',0
    DB 0FEh, 'Product (integer)',0
    DB 0FFh, 'Serial Number (integer)',0
    DB   0 , -1 ;End of Table

  BatterySystemTbl:
    DB  TblFlagByte
    DB  00h, 'Undefined',0
    DB  01h, 'SMB Battery Mode',0
    DB  02h, 'SMB Battery Status',0
    DB  03h, 'SMB Alarm Warning',0
    DB  04h, 'SMB Charger Mode',0
    DB  05h, 'SMB Charger Status',0
    DB  06h, 'SMB Charger Spec Info',0
    DB  07h, 'SMB Selector State',0
    DB  08h, 'SMB Selector Presets',0
    DB  09h, 'SMB Selector Info',0
    DB  10h, 'Optional Mfg Function 1',0
    DB  11h, 'Optional Mfg Function 2',0
    DB  12h, 'Optional Mfg Function 3',0
    DB  13h, 'Optional Mfg Function 4',0
    DB  14h, 'Optional Mfg Function 5',0
    DB  15h, 'Connection to SMBus',0
    DB  16h, 'Output Connection',0
    DB  17h, 'Charger Connection',0
    DB  18h, 'Battery Insertion',0
    DB  19h, 'Use Next',0
    DB  1Ah, 'OK to Use',0
    DB  1Bh, 'Battery Supported',0
    DB  1Ch, 'SelectorRevision',0
    DB  1Dh, 'Charging Indicator',0
    DB  28h, 'Manufacturer Access',0
    DB  29h, 'Remaining Capacity Limit',0
    DB  2Ah, 'Remaining Time Limit',0
    DB  2Bh, 'At Rate',0
    DB  2Ch, 'Capacity Mode',0
    DB  2Dh, 'Broadcast To Charger',0
    DB  2Eh, 'Primary Battery',0
    DB  2Fh, 'Charge Controller',0
    DB  40h, 'Terminate Charge',0
    DB  41h, 'Terminate Discharge',0
    DB  42h, 'Below Remaining Capacity Limit',0
    DB  43h, 'Remaining Time Limit Expired',0
    DB  44h, 'Charging',0
    DB  45h, 'Discharging',0
    DB  46h, 'Fully Charged',0
    DB  47h, 'Fully Discharged',0
    DB  48h, 'Conditioning Flag',0
    DB  49h, 'At Rate OK',0
    DB  4Ah, 'SMB Error Code',0
    DB  4Bh, 'Need Replacement',0
    DB  60h, 'At Rate Time To Full',0
    DB  61h, 'At Rate Time To Empty',0
    DB  62h, 'Average Current',0
    DB  63h, 'Max Error',0
    DB  64h, 'Relative State Of Charge',0
    DB  65h, 'Absolute State Of Charge',0
    DB  66h, 'Remaining Capacity',0
    DB  67h, 'Full Charge Capacity',0
    DB  68h, 'Run Time To Empty',0
    DB  69h, 'Average Time To Empty',0
    DB  6Ah, 'Average Time To Full',0
    DB  6Bh, 'Cycle Count',0
    DB  80h, 'Batt. Pack Model Level',0
    DB  81h, 'Internal Charge Controller',0
    DB  82h, 'Primary Battery Support',0
    DB  83h, 'Design Capacity',0
    DB  84h, 'Specification Info',0
    DB  85h, 'Manufacturer Date',0
    DB  86h, 'Serial Number',0
    DB  87h, 'Manufacturer Name (integer)',0
    DB  88h, 'Device Name (integer)',0
    DB  89h, 'Device Chemistry (integer)',0
    DB  8Ah, 'Manufacturer Data (integer)',0
    DB  8Bh, 'Rechargeable',0
    DB  8Ch, 'Warning Capacity Limit',0
    DB  8Dh, 'Capacity Granularity 1',0
    DB  8Eh, 'Capacity Granularity 2',0
    DB  8Fh, 'OEM Information (integer)',0
    DB 0C0h, 'Inhibit Charge',0
    DB 0C1h, 'Enable Polling',0
    DB 0C2h, 'Reset To Zero',0
    DB 0D0h, 'AC Present',0
    DB 0D1h, 'Battery Present',0
    DB 0D2h, 'Power Fail',0
    DB 0D3h, 'Alarm Inhibited',0
    DB 0D4h, 'Thermistor Under Range',0
    DB 0D5h, 'Thermistor Hot',0
    DB 0D6h, 'Thermistor Cold',0
    DB 0D7h, 'Thermistor Over Range',0
    DB 0D8h, 'Voltage Out Of Range',0
    DB 0D9h, 'Current Out Of Range',0
    DB 0DAh, 'Current Not Regulated',0
    DB 0DBh, 'Voltage Not Regulated',0
    DB 0DCh, 'Master Mode',0
    DB 0F0h, 'Charger Selector Support',0
    DB 0F1h, 'Charger Spec Ref',0
    DB 0F2h, 'Level 2',0
    DB 0F3h, 'Level 3',0
    DB   0 , -1 ;End of Table

  POSBarCodeTbl: ;Taken from USB POS Usage Tables v1.02 2001-03-05
    DB  TblFlagWord
    DW 0000h
       DB 'Undefined',0
    DW 0001h
       DB 'Bar Code Badge Reader',0
    DW 0002h
       DB 'Bar Code Scanner',0
    DW 0003h
       DB 'Dumb Bar Code Scanner',0
    DW 0004h
       DB 'Cordless Scanner Base',0
    DW 0005h
       DB 'Bar Code Scanner Cradle',0
    DW 0010h
       DB 'Attribute Report',0
    DW 0011h
       DB 'Settings Report',0
    DW 0012h
       DB 'Scanned Data Report',0
    DW 0013h
       DB 'Raw Scanned Data Report',0
    DW 0014h
       DB 'Trigger Report',0
    DW 0015h
       DB 'Status Report',0
    DW 0016h
       DB 'UPC/EAN Control Report',0
    DW 0017h
       DB 'EAN 2/3 Label Control Report',0
    DW 0018h
       DB 'Code 39 Control Report',0
    DW 0019h
       DB 'Interleaved 2 of 5 Control Report',0
    DW 001Ah
       DB 'Standard 2 of 5 Control Report',0
    DW 001Bh
       DB 'MSI Plessey Control Report',0
    DW 001Ch
       DB 'Codabar Control Report',0
    DW 001Dh
       DB 'Code 128 Control Report',0
    DW 001Eh
       DB 'Misc 1D Control Report',0
    DW 001Fh
       DB '2D Control Report',0
    DW 0030h
       DB 'Aiming/Pointer Mode',0
    DW 0031h
       DB 'Bar Code Present Sensor',0
    DW 0032h
       DB 'Class 1A Laser',0
    DW 0033h
       DB 'Class 2 Laser',0
    DW 0034h
       DB 'Heater Present',0
    DW 0035h
       DB 'Contact Scanner',0
    DW 0036h
       DB 'Electronic Article Surveillance Notification',0
    DW 0037h
       DB 'Constant Electronic Article Surveillance',0
    DW 0038h
       DB 'Error Indication',0
    DW 0039h
       DB 'Fixed Beeper',0
    DW 003Ah
       DB 'Good Decode Indication',0
    DW 003Bh
       DB 'Hands Free Scanning',0
    DW 003Ch
       DB 'Intrinsically Safe',0
    DW 003Dh
       DB 'Klasse Eins Laser',0
    DW 003Eh
       DB 'Long Range Scanner',0
    DW 003Fh
       DB 'Mirror Speed Control',0
    DW 0040h
       DB 'Not On File Indication',0
    DW 0041h
       DB 'Programmable Beeper',0
    DW 0042h
       DB 'Triggerless',0
    DW 0043h
       DB 'Wand',0
    DW 0044h
       DB 'Water Resistant',0
    DW 0045h
       DB 'Multi-Range Scanner',0
    DW 0046h
       DB 'Proximity Sensor',0
    DW 004Dh
       DB 'Fragment Decoding',0
    DW 004Eh
       DB 'Scanner Read Confidence',0
    DW 004Fh
       DB 'Data Prefix',0
    DW 0050h
       DB 'Prefix AIMI',0
    DW 0051h
       DB 'Prefix None',0
    DW 0052h
       DB 'Prefix Proprietary',0
    DW 0055h
       DB 'Active Time',0
    DW 0056h
       DB 'Aiming Laser Pattern',0
    DW 0057h
       DB 'Bar Code Present',0
    DW 0058h
       DB 'Beeper State',0
    DW 0059h
       DB 'Laser On Time',0
    DW 005Ah
       DB 'Laser State',0
    DW 005Bh
       DB 'Lockout Time',0
    DW 005Ch
       DB 'Motor State',0
    DW 005Dh
       DB 'Motor Timeout',0
    DW 005Eh
       DB 'Power On Reset Scanner',0
    DW 005Fh
       DB 'Prevent Read of Barcodes',0
    DW 0060h
       DB 'Initiate Barcode Read',0
    DW 0061h
       DB 'Trigger State',0
    DW 0062h
       DB 'Trigger Mode',0
    DW 0063h
       DB 'Trigger Mode Blinking Laser On',0
    DW 0064h
       DB 'Trigger Mode Continuous Laser On',0
    DW 0065h
       DB 'Trigger Mode Laser on while Pulled',0
    DW 0066h
       DB 'Trigger Mode Laser stays on after Trigger release',0
    DW 006Dh
       DB 'Commit Parameters to NVM',0
    DW 006Eh
       DB 'Parameter Scanning',0
    DW 006Fh
       DB 'Parameters Changed',0
    DW 0070h
       DB 'Set parameter default values',0
    DW 0075h
       DB 'Scanner In Cradle',0
    DW 0076h
       DB 'Scanner In Range',0
    DW 007Ah
       DB 'Aim Duration',0
    DW 007Bh
       DB 'Good Read Lamp Duration',0
    DW 007Ch
       DB 'Good Read Lamp Intensity',0
    DW 007Dh
       DB 'Good Read LED',0
    DW 007Eh
       DB 'Good Read Tone Frequency',0
    DW 007Fh
       DB 'Good Read Tone Length',0
    DW 0080h
       DB 'Good Read Tone Volume',0
    DW 0082h
       DB 'No Read Message',0
    DW 0083h
       DB 'Not on File Volume',0
    DW 0084h
       DB 'Powerup Beep',0
    DW 0085h
       DB 'Sound Error Beep',0
    DW 0086h
       DB 'Sound Good Read Beep',0
    DW 0087h
       DB 'Sound Not On File Beep',0
    DW 0088h
       DB 'Good Read When to Write',0
    DW 0089h
       DB 'GRWTI After Decode',0
    DW 008Ah
       DB 'GRWTI Beep/Lamp after transmit',0
    DW 008Bh
       DB 'GRWTI No Beep/Lamp use at all',0
    DW 0091h
       DB 'Bookland EAN',0
    DW 0092h
       DB 'Convert EAN 8 to 13 Type',0
    DW 0093h
       DB 'Convert UPC A to EAN-13',0
    DW 0094h
       DB 'Convert UPC-E to A',0
    DW 0095h
       DB 'EAN-13',0
    DW 0096h
       DB 'EAN-8',0
    DW 0097h
       DB 'EAN-99 128_Mandatory',0
    DW 0098h
       DB 'EAN-99 P5/128_Optional',0
    DW 009Ah
       DB 'UPC/EAN',0
    DW 009Bh
       DB 'UPC/EAN Coupon Code',0
    DW 009Ch
       DB 'UPC/EAN Periodicals',0
    DW 009Dh
       DB 'UPC-A',0
    DW 009Eh
       DB 'UPC-A with 128 Mandatory',0
    DW 009Fh
       DB 'UPC-A with 128 Optional',0
    DW 00A0h
       DB 'UPC-A with P5 Optional',0
    DW 00A1h
       DB 'UPC-E',0
    DW 00A2h
       DB 'UPC-E1',0
    DW 00A9h
       DB 'Periodical',0
    DW 00AAh
       DB 'Periodical Auto-Discriminate +2',0
    DW 00ABh
       DB 'Periodical Only Decode with +2',0
    DW 00ACh
       DB 'Periodical Ignore +2',0
    DW 00ADh
       DB 'Periodical Auto-Discriminate +5',0
    DW 00AEh
       DB 'Periodical Only Decode with +5',0
    DW 00AFh
       DB 'Periodical Ignore +5',0
    DW 00B0h
       DB 'Check',0
    DW 00B1h
       DB 'Check Disable Price',0
    DW 00B2h
       DB 'Check Enable 4 digit Price',0
    DW 00B3h
       DB 'Check Enable 5 digit Price',0
    DW 00B4h
       DB 'Check Enable European 4 digit Price',0
    DW 00B5h
       DB 'Check Enable European 5 digit Price',0
    DW 00B7h
       DB 'EAN Two Label',0
    DW 00B8h
       DB 'EAN Three Label',0
    DW 00B9h
       DB 'EAN 8 Flag Digit 1',0
    DW 00BAh
       DB 'EAN 8 Flag Digit 2',0
    DW 00BBh
       DB 'EAN 8 Flag Digit 3',0
    DW 00BCh
       DB 'EAN 13 Flag Digit 1',0
    DW 00BDh
       DB 'EAN 13 Flag Digit 2',0
    DW 00BEh
       DB 'EAN 13 Flag Digit 3',0
    DW 00BFh
       DB 'Add EAN 2/3 Label Definition',0
    DW 00C0h
       DB 'Clear all EAN 2/3 Label Definitions',0
    DW 00C3h
       DB 'Codabar',0
    DW 00C4h
       DB 'Code 128',0
    DW 00C7h
       DB 'Code 39',0
    DW 00C8h
       DB 'Code 93',0
    DW 00C9h
       DB 'Full ASCII Conversion',0
    DW 00CAh
       DB 'Interleaved 2 of 5',0
    DW 00CBh
       DB 'Italian Pharmacy Code',0
    DW 00CCh
       DB 'MSI/Plessey',0
    DW 00CDh
       DB 'Standard 2 of 5 IATA',0
    DW 00CEh
       DB 'Standard 2 of 5',0
    DW 00D3h
       DB 'Transmit Start/Stop',0
    DW 00D4h
       DB 'Tri-Optic',0
    DW 00D5h
       DB 'UCC/EAN-128',0
    DW 00D6h
       DB 'Check Digit',0
    DW 00D7h
       DB 'Check Digit Disable',0
    DW 00D8h
       DB 'Check Digit Enable Interleaved 2 of 5 OPCC',0
    DW 00D9h
       DB 'Check Digit Enable Interleaved 2 of 5 USS',0
    DW 00DAh
       DB 'Check Digit Enable Standard 2 of 5 OPCC',0
    DW 00DBh
       DB 'Check Digit Enable Standard 2 of 5 USS',0
    DW 00DCh
       DB 'Check Digit Enable One MSI Plessey',0
    DW 00DDh
       DB 'Check Digit Enable Two MSI Plessey',0
    DW 00DEh
       DB 'Check Digit Codabar Enable',0
    DW 00DFh
       DB 'Check Digit Code 39 Enable',0
    DW 00F0h
       DB 'Transmit Check Digit',0
    DW 00F1h
       DB 'Disable Check Digit Transmit',0
    DW 00F2h
       DB 'Enable Check Digit Transmit',0
    DW 00FBh
       DB 'Symbology Identifier 1',0
    DW 00FCh
       DB 'Symbology Identifier 2',0
    DW 00FDh
       DB 'Symbology Identifier 3',0
    DW 00FEh
       DB 'Decoded Data',0
    DW 00FFh
       DB 'Decode Data Continued',0
    DW 0100h
       DB 'Bar Space Data',0
    DW 0101h
       DB 'Scanner Data Accuracy',0
    DW 0102h
       DB 'Raw Data Polarity',0
    DW 0103h
       DB 'Polarity Inverted Bar Code',0
    DW 0104h
       DB 'Polarity Normal Bar Code',0
    DW 0106h
       DB 'Minimum Length to Decode',0
    DW 0107h
       DB 'Maximum Length to Decode',0
    DW 0108h
       DB 'First Discrete Length to Decode',0
    DW 0109h
       DB 'Second Discrete Length to Decode',0
    DW 010Ah
       DB 'Data Length Method',0
    DW 010Bh
       DB 'DL Method Read any',0
    DW 010Ch
       DB 'DL Method Check in Range',0
    DW 010Dh
       DB 'DL Method Check for Discrete',0
    DW 0110h
       DB 'Aztec Code',0
    DW 0111h
       DB 'BC412',0
    DW 0112h
       DB 'Channel Code',0
    DW 0113h
       DB 'Code 16',0
    DW 0114h
       DB 'Code 32',0
    DW 0115h
       DB 'Code 49',0
    DW 0116h
       DB 'Code One',0
    DW 0117h
       DB 'Colorcode',0
    DW 0118h
       DB 'Data Matrix',0
    DW 0119h
       DB 'MaxiCode',0
    DW 011Ah
       DB 'MicroPDF',0
    DW 011Bh
       DB 'PDF-417',0
    DW 011Ch
       DB 'PosiCode',0
    DW 011Dh
       DB 'QR Code',0
    DW 011Eh
       DB 'SuperCode',0
    DW 011Fh
       DB 'UltraCode',0
    DW 0120h
       DB 'USD-5 (Slug Code)',0
    DW 0121h
       DB 'VeriCode',0
    DW    0   ;End of
       DB -1  ;  Table

  POSWeightTbl: ;Taken from USB POS Usage Tables v1.02 2001-03-05
    DB TblFlagByte
    DB 00h, 'Undefined',0
    DB 01h, 'Weighing Device',0
    DB 20h, 'Scale Device',0
    DB 21h, 'Scale Class I Metric',0
    DB 22h, 'Scale Class I Metric',0
    DB 23h, 'Scale Class II Metric',0
    DB 24h, 'Scale Class III Metric',0
    DB 25h, 'Scale Class IIIL Metric',0
    DB 26h, 'Scale Class IV Metric',0
    DB 27h, 'Scale Class III English',0
    DB 28h, 'Scale Class IIIL English',0
    DB 29h, 'Scale Class IV English',0
    DB 2Ah, 'Scale Class Generic',0
    DB 30h, 'Scale Attribute Report',0
    DB 31h, 'Scale Control Report',0
    DB 32h, 'Scale Data Report',0
    DB 33h, 'Scale Status Report',0
    DB 34h, 'Scale Weight Limit Report',0
    DB 35h, 'Scale Statistics Report',0
    DB 40h, 'Data Weight',0
    DB 41h, 'Data Scaling',0
    DB 50h, 'Weight Unit',0
    DB 51h, 'Weight Unit Milligram',0
    DB 52h, 'Weight Unit Gram',0
    DB 53h, 'Weight Unit Kilogram',0
    DB 54h, 'Weight Unit Carats',0
    DB 55h, 'Weight Unit Taels',0
    DB 56h, 'Weight Unit Grains',0
    DB 57h, 'Weight Unit Pennyweights',0
    DB 58h, 'Weight Unit Metric Ton',0
    DB 59h, 'Weight Unit Avoir Ton',0
    DB 5Ah, 'Weight Unit Troy Ounce',0
    DB 5Bh, 'Weight Unit Ounce',0
    DB 5Ch, 'Weight Unit Pound',0
    DB 60h, 'Calibration Count',0
    DB 61h, 'Re-Zero Count',0
    DB 70h, 'Scale Status',0
    DB 71h, 'Scale Status Fault',0
    DB 72h, 'Scale Status Stable at Center of Zero',0
    DB 73h, 'Scale Status In Motion',0
    DB 74h, 'Scale Status Weight Stable',0
    DB 75h, 'Scale Status Under Zero',0
    DB 76h, 'Scale Status Over Weight Limit',0
    DB 77h, 'Scale Status Requires Calibration',0
    DB 78h, 'Scale Status Requires Re-zeroing',0
    DB 80h, 'Zero Scale',0
    DB 81h, 'Enforced Zero Return',0
    DB  0 , -1 ;End of Table

  POSMagStripeTbl: ;Taken from USB POS Usage Tables v1.02 2001-03-05
    DB TblFlagByte
    DB 00h, 'Undefined',0
    DB 01h, 'MSR Device Read-Only',0
    DB 11h, 'Track 1 Length',0
    DB 12h, 'Track 2 Length',0
    DB 13h, 'Track 3 Length',0
    DB 14h, 'Track JIS Length',0
    DB 20h, 'Track Data',0
    DB 21h, 'Track 1 Data',0
    DB 22h, 'Track 2 Data',0
    DB 23h, 'Track 3 Data',0
    DB 24h, 'Track JIS Data',0
    DB  0 , -1 ;End of Table

  CashDeviceTbl:
    DB  TblFlagByte
    DB  00h, 'Undefined',0
    DB 0F1h, 'Cash Drawer',0
    DB 0F2h, 'Cash Drawer Number',0
    DB 0F3h, 'Cash Drawer Set',0
    DB 0F4h, 'Cash Drawer Status',0
    DB   0 , -1 ;End of Table


;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
;CODE
;‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹

;------------------------------------------------------------------------------
;DO THE PROGRAM THING!
;Inputs:
;Outputs: Lots of Stuff
;Changes: Everything
;------------------------------------------------------------------------------
Main:
  CLD                    ;Go forward with string functions
  MOV  SP,LastProgByte   ;Reset Stack Pointer
  CALL ResizeMemory      ;Resize our Memory Allocation
  CALL CopyNameToMCB     ;Copy our Program name to the MCB
  CALL SetupPauseNoHdr   ;Set up the Pause
  CALL TestParentShell   ;See if our Parent is a DOS Command Shell
  JNZ >M10               ;If not, don't write the Copyright
  MOV  DX,Copyright      ;If so, write the
  CALL WriteZPause       ;  Copyright message
M10:                     ;Copyright written, if appropriate
  CALL TestCompatibility ;Test for compatibility, quit if Error
  CALL ParseCmdLine      ;Do what the user wants, quit if Error
  XOR  AL,AL             ;ErrorLevel = 0
  MOV  DX,NoMsg          ;Write Nothing afterwards
;  JMP  Exit              ;QUIT

;------------------------------------------------------------------------------
;PRINT MESSAGE IN DX AND QUIT WITH ERRORLEVEL IN AL
;Inputs:  AL = Errorlevel to exit program with
;         DS:[DX] = Message to Print (to ERR)
;Outputs:
;Changes: Quits program
;------------------------------------------------------------------------------
Exit:
  OR   AL,AL       ;Was there an Error?
  JZ  >X80         ;If not, jump to handle a normal termination
  CALL BeepErr     ;If error, Beep Once
  CALL WriteZErr   ;Write message to ERR
  MOV  DX,CrLfMsg  ;Write a
  CALL WriteZErr   ;  new line
  JMP >X90         ;Jump to quit
X80:               ;No Error - Write to CON
  CALL WriteZPause ;Write the message to CON
X90:               ;We're done!!
  MOV  AH,4Ch      ;Service 4Ch (terminate program)
  INT  21h         ;Do it

;------------------------------------------------------------------------------
;MAKE SURE THE MCB (MEMORY CONTROL BLOCK) CONTAINS OUR PROGRAM NAME
;Inputs:  DS = Local Data Area
;         DS:RealName = ASCIIZ Real Name of our program
;         CLD Already Issued
;Outputs:
;Changes: Data in MCB
;NOTES:   This makes sure that the MCB (Memory Control Block) for our
;           program contains our program name.  DOS 4+ does this
;           automatically, but DOS versions 1-3 do not.  This code
;           does not verify whihc DOS version is in use, but simply
;           fills in the MCB no matter what.
;         Our program name is needed inthe MCB to make sure other programs
;           can identify that we are installed in memory.  This code should
;           be added to all TSR's, so that memory-mapping programs
;           (like MAPMEM or ISLOADED) can tell which TSR's are installed
;           in memory.  It should also be added to all programs that
;           EXEC other programs, so that the EXEC'd program can figure out
;           who called it.
;         Programs that are not TSR's and do not EXEC other programs
;           do not need this code.
;------------------------------------------------------------------------------
CopyNameToMCB:
  PUSH CX,DI,SI,ES              ;Save used registers
  MOV  CX,DS                    ;Point ES:[DI]
  DEC  CX                       ;  at the Owners Name
  MOV  ES,CX                    ;  in the MCB
  MOV  DI,(OFFSET MCBOwnerName) ;  of our program
  MOV  SI,RealName              ;Point DS:[SI] at our Program Name
  MOV  CX,4                     ;Copy 4 words (8 bytes)
  REP  MOVSW                    ;Copy our program name to the MCB
  POP  ES,SI,DI,CX              ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO DETERMINE WHO OUR PARENT PROGRAM IS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;COPY THE CAPITALIZED NAME OF OUR PARENT PROGRAM TO A LOCAL STRING (PARENTNAME)
;Inputs:  ParentIsShell = No
;Outputs: ParentIsShell = Yes if Parent Program has a Shell Name
;                         ZF = Set
;                       = No if Parent Program does not have a Shell Name
;                         ZF = Clear
;Changes:
;------------------------------------------------------------------------------
TestParentShell:
  PUSH AX,BX,DI,SI       ;Save used registers
  CALL GetParentNameCaps ;Get our Parents Capitalized Name
  JZ  >S80               ;If invalid, assume we're at a command-line
  MOV  SI,DOSShellTbl    ;Point at our table of Shell Names
S10:                     ;Loop to here for each table entry
  MOV  DI,ParentName     ;Point DI at our Parents Name
  MOV  BX,SI             ;Save the current table pointer
  CMP  B [BX],0          ;End of the Table?
  JE  >S90               ;If so, it's not a Command Shell
S20:                     ;Loop to here for each character in the string
  MOV  AL,[BX]           ;Get the next table character
  OR   AL,AL             ;End of the table string?
  JZ  >S40               ;If so, handle it
S30:                     ;Not end of table string
  CMP  AL,[DI]           ;Does the character match?
  JNE >S60               ;If not, try the next table entry
  INC  BX                ;If so, increment
  INC  DI                ;  our Pointers
  JMP  S20               ;and keep testing
S40:                     ;End of our table string
  CMP  B [DI],0          ;End of the Parents Name string?
  JE  >S80               ;If so, it's a match
S60:                     ;Not a match
  CALL SkipOverStringSI  ;Point at the next table entry
  JMP  S10               ;Keep going until we're done
S80:                     ;Is a Command Shell
  MOV  ParentIsShell,Yes ;Store the result for later
S90:                     ;Done
  CMP  ParentIsShell,Yes ;Set the return flag
  POP  SI,DI,BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY THE CAPITALIZED NAME OF OUR PARENT PROGRAM TO A LOCAL STRING (PARENTNAME)
;Inputs:  ES = Local Data Area
;         CLD already issued
;Outputs: ParentName
;         ZF = Clear if ParentName is valid (greater than 0 length)
;            = Set if Invalid (0-length, such as under the DOSBox program)
;Changes:
;------------------------------------------------------------------------------
GetParentNameCaps:
  PUSH AX,CX,DI,SI,DS         ;Save used registers
  MOV  AX,[PSPParentPSP]      ;Point DS at
  DEC  AX                     ;  the MCB of our
  MOV  DS,AX                  ;  Parents PSP
  MOV  SI,OFFSET MCBOwnerName ;Point DS:[SI] at the Owners name
  MOV  DI,ParentName          ;Point ES:[DI] at our storage area
  MOV  CX,8                   ;Copy 8 bytes
P10:                          ;Loop to here for each character
  LODSB                       ;Get the next byte
  CALL Capitalize             ;Capitalize it
  STOSB                       ;Store it
  LOOP P10                    ;Keep going until we're done
  CMP  ES:B ParentName[0],0   ;Set return flag
  POP  DS,SI,DI,CX,AX         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PARSE THE COMMAND LINE FOR SWITCHES AND OPTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PARSE THE COMMAND LINE FOR A SWITCH
;Inputs:
;Outputs:
;Changes:
;------------------------------------------------------------------------------
ParseCmdLine:
  PUSH AX,SI        ;Save used registers
  MOV  SI,81h       ;Point at command line tail
P10:                ;Look for the next switch
  CALL IsSpaceOrEOL ;Look for a valid character
  JZ  >P70          ;If End-of-Line, Error
  CALL GetSwitch    ;See if it matches one of our switches
  JNZ >P90          ;If a match, look for the next switch
P70:                ;Error
  MOV  DX,HelpMsg   ;Write the
  CALL WriteItDX    ;  Help Message
  MOV  DX,NoMsg     ;Write nothing
  XOR  AL,AL        ;ErrorLevel 0
  JMP  Exit         ;Print error message and quit
P90:                ;We're done
  POP  SI,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE SWITCH CHARACTERS, AND DO WHATEVER IT IS THEY'RE ASKING
;Inputs:  DS:[SI] = Command line pointer
;Outputs: Lots of stuff!!!
;         ZF = Set if Error
;            = Clear if OK
;Changes:
;------------------------------------------------------------------------------
GetSwitch:
  PUSH AX,BX          ;Save used registers
  MOV  BX,SwitchList  ;Point at the list of switch code words
  CALL GetCode        ;See if its a match
  JC  >S70            ;If not, error
  MOV  BX,SwitchTbl   ;Point at the Table of Offsets
  CALL Byte2WordTbl   ;Look for the Code Offset to perform
  JC  >S70            ;If not found, error
  CALL BX             ;If Found, perform the Code
  MOV  DX,NoMsg       ;Write nothing when done
  JMP >S90            ;And quit
S70:                  ;There's an error
  MOV  ParseError,Yes ;Mark the error flag
S90:                  ;We're done
  CMP  ParseError,Yes ;Set/Clear the error flag
  POP  BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;LOOK FOR A MATCHING ENTRY IN A BYTE-TO-WORD LOOKUP TABLE
;Inputs:      AL  = Byte to look for in the Table
;         DS:[BX] = Table to Look in
;         CDL already issued
;Outputs: CF = Clear if OK (Byte was found in the Table)
;              BX = Word from the Table
;            = Set if Error (Byte was not found in the Table)
;              BX = Unchanged
;Changes:
;NOTES: The end of the table is mark by a 0 byte.  The first byte of the
;         table can also be a 0, however, since the 0 is only looked for
;         starting with the second table entry.
;------------------------------------------------------------------------------
Byte2WordTbl:
  PUSH AX,SI    ;Save used registers
  MOV  AH,AL    ;Save original value we need to look for
  MOV  SI,BX    ;Point DS:[SI] at the Table
W10:            ;Loop to here for each table entry
  LODSB         ;Get the next byte from the table
  CMP  AL,AH    ;Is it the one we're looking for?
  JE  >W80      ;If so, we're done
  INC  SI,2     ;If not, skip over the word
  CMP  B [SI],0 ;End of the table?
  JNE  W10      ;If not, keep looking
W70:            ;No match
  STC           ;Set not-found flag
  JMP >W90      ;Done
W80:            ;Found it
  MOV  BX,[SI]  ;Set BX for the return
  CLC           ;Set found-it flag
W90:            ;Done
  POP  SI,AX    ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO GET A NUMBER FROM A STRING (HEX OR DECIMAL)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET A NUMBER FROM A STRING (CAN BE DECIMAL OR HEX)
;Inputs:  [SI] = String Pointer
;Outputs: CF = Clear if we got a valid number
;              AX = Number
;            = Set if Error (no number found)
;              AX = 0
;Changes: SI points at next byte after the number
;NOTES: A Hex String must start with '0x' and/or end in 'H'!
;------------------------------------------------------------------------------
GetNumber:
  PUSH BX           ;Save used registers
  MOV  BX,AX        ;Save original AX
  CALL IsSpaceOrEOL ;Skip past spaces
  JZ  >N70          ;If End-of-Line, Error
  CALL TestForHex   ;Is it a Hex Number?
  JC  >N20          ;If not, try a decimal
  CALL Test0xPrefix ;Skip over the 0x (C-style) prefix, if there
  CALL GetHex       ;If so, get it
  JNC >N80          ;If OK, we're done
  JMP >N70          ;If not, Error
N20:                ;Not Hex
  CALL GetDecimal   ;Try a Decimal
  JNC >N80          ;If OK, we're done
N70:                ;Error
  MOV  AX,BX        ;Restore original AX
  STC               ;Set Error Flag
  JMP >N90          ;Done
N80:                ;OK
  CLC               ;Set OK Flag
N90:                ;Done
  POP  BX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII STRING TO SEE IF IT IS A HEX STRING (ENDS IN H)
;Inputs:  [SI] = String to test
;Outputs: CF = Clear if it is a Hex String
;            = Set if Error (not a Hex String)
;Changes:
;NOTES: A valid Hex String will contain numerals 0-9, A-F, and Underscores,
;         and will end in an H.  It cannot contain spaces.
;------------------------------------------------------------------------------
TestForHex:
  PUSH AX,SI        ;Save used registers
  CALL Test0xPrefix ;Test for the 0x (C-style) prefix (changes SI)
  JNC >H80          ;If so, it's Hex
  MOV  AL,B [SI]    ;Get the first character
  CALL IsHexNumber  ;A valid Hex Number?
  JC  >H70          ;If not, Error
H10:                ;Loop to here for each character
  LODSB             ;Get the next character
  CALL IsHexNumber  ;A valid Hex Number?
  JNC  H10          ;If so, keep looking
  CMP  AL,'_'       ;An Underscore?
  JZ   H10          ;If so, keep looking
  CALL IsHexEnd     ;End of the Hex Number?
  JZ  >H80          ;If so, we're done
H70:                ;Not Hex
  STC               ;Set error Flag
  JMP >H90          ;Done
H80:                ;Is Hex
  CLC               ;Set OK Flag
H90:                ;Done
  POP  SI,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST FOR A 0x (C-STYLE) HEX PREFIX
;Inputs:  [SI] = String to test
;Outputs: CF = Set if not a 0x Prefix
;              SI unchanged
;            = Clear if not a 0x Prefix
;              [SI] = Character after the 0x
;Changes:
;------------------------------------------------------------------------------
Test0xPrefix:
  PUSH AX,BX       ;Save used registers
  MOV  BX,SI       ;Save original Pointer
  LODSB            ;Get the next character
  CMP  AL,'0'      ;Is it a 0?
  JNE >X70         ;If not, it's not a Prefix
X20:               ;Loop to here to skip over all zeroes
  LODSB            ;Get the next charcter
  CMP  AL,'0'      ;Is it another 0?
  JE   X20         ;If so, keep skipping the zeroes
  CALL Capitalize  ;If not, capitalize it
  CMP  AL,'X'      ;Is it an X?
  JNE >X70         ;If not, it's not a 0x Prefix
  LODSB            ;Get the next charcter
  CALL IsHexNumber ;Is it a Hex Number?
  JNC >X80         ;If so, it's a 0x Prefix
X70:               ;Not a 0x Prefix
  MOV  SI,BX       ;Restore original pointer
  STC              ;Set return flag
  JMP >X90         ;Done
X80:               ;Is a 0x Prefix
  DEC  SI          ;Point back at the first hex number
  CLC              ;Set return flag
X90:               ;Done
  POP  BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT SERIES OF HEX CHARACTERS, AND CONVERT THEM TO A NUMBER
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK
;              AX = Character string converted to a number, ?? if not
;            = Set if Error
;              AX = Unchanged
;Changes:
;NOTES: The string can either have an H at the end or not, and this code
;         will work.
;------------------------------------------------------------------------------
GetHex:
  PUSH BX,CX,DX    ;Save used registers
  MOV  DX,AX       ;Save original AX
  XOR  BX,BX       ;Start with zero
  MOV  CX,4        ;CL = bits to shift by, CH = Character Counter
  XOR  AH,AH       ;AH = 0
D10:               ;Loop to here for each character
  LODSB            ;Get the next character
  CALL IsHexNumber ;A valid Hex Number?
  JNC >D20         ;If so, continue
  CMP  AL,'_'      ;If not, is it an Underscore?
  JZ  >D45         ;If so, keep looking
  JMP >D50         ;If not, we're done
D20:               ;Valid Hex Number
  INC  CH          ;Increment the character counter
  SHL  BX,CL       ;Make room for the New Nibble
  JNC >D40         ;If we're not too big yet, keep going
  DEC  SI          ;If too big, Point back at bad character
  JMP >D70         ;Error
D40:               ;OK to add in new Nibble
  ADD  BX,AX       ;Add in the new Nibble
D45:               ;Done with this character
  JMP  D10         ;Jump to get next character
D50:               ;Done getting string
  DEC  SI          ;Point back at the bad character
  OR   CH,CH       ;Any valid characters at all?
  JZ  >D70         ;If not, error
  LODSB            ;Is the next character
  CALL IsHexEnd    ;  an H?
  JZ  >D80         ;If so, we're done
  DEC  SI          ;If not, point back at the non-H
  JMP >D80         ;Done
D70:               ;There was an error
  MOV  AX,DX       ;Restore original AX
  STC              ;Mark the error flag
  JMP >D90         ;And quit
D80:               ;We have a good number
  MOV  AX,BX       ;Put the value where it belongs
  CLC              ;Mark the OK flag
D90:               ;We're done
  POP  DX,CX,BX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT SERIES OF NUMERIC CHARACTERS, AND CONVERT THEM TO A NUMBER
;Inputs:  [SI] = Command Line Pointer
;Outputs: AX = decimal character string converted to a number, ?? if not
;         CF = Clear if AX is OK
;            = Set if no decimal found
;Changes: SI points at character after the number
;------------------------------------------------------------------------------
GetDecimal:
  PUSH BX,CX,DX     ;Save used registers
  XOR  AX,AX        ;Start with zero
  XOR  BX,BX        ;  "    "    "   - accumulator
  MOV  CX,10        ;CX = multiplier & digit limit comparer
  CALL IsSpaceOrEOX ;Skip over the spaces
  JZ  >D70          ;If EOL, Error
  SUB  AL,'0'       ;If not, convert it to a number
  CMP  AL,9         ;Is it really a number?
  JA  >D70          ;If not, there's an error
  DEC  SI           ;If so, step back to the number
D10:                ;Loop to here for each character
  LODSB             ;Get the next character
  SUB  AL,'0'       ;Change it to 0-9 range
  XOR  AH,AH        ;Extend byte to word
  CMP  AX,CX        ;Is it a digit?
  JAE >D80          ;If not, we're done
  CMP  BX,6553      ;Is our number getting too big?
  JB  >D20          ;If not, jump to store it
  CMP  AL,5         ;If so, will this number make it too big?
  JA  >D70          ;If so, there's an error
D20:                ;Add the digit to our number
  XCHG AX,BX        ;Swap accumulation into AX, new digit into BX
  MUL  CX           ;Multiply the previous accumulation by 10
  ADD  BX,AX        ;Add in the new digit
  JMP  D10          ;Jump to get next character
D70:                ;There was an error
  STC               ;Mark the error flag
  JMP >D90          ;And quit
D80:                ;We have a good number
  DEC  SI           ;Point back at the non-number
  MOV  AX,BX        ;Put the value where it belongs
  CLC               ;Mark the OK flag
D90:                ;We're done
  POP  DX,CX,BX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A HEX NUMERAL (BETWEEN 0 AND F)
;Inputs:  AL = ASCII Character to Test
;Outputs: CF = Clear if it is a Number
;              AL = ASCII Code converted to a real Number
;            = Set if Error (not a Number)
;              AL = Unchanged
;Changes:
;------------------------------------------------------------------------------
IsHexNumber:
  PUSH BX          ;Save used registers
  MOV  BL,AL       ;Save the character in case we need to restore it
  CALL IsNumber    ;A Decimal Number?
  JNC >H85         ;If so, we're done
  CALL Capitalize  ;If not, Capitalize it
  CMP  AL,'A'      ;A Hex Number?
  JB  >H70         ;If not, Error
  CMP  AL,'F'      ;A Hex Number?
  JBE >H80         ;If so, handle it
H70:               ;Not a Number
  MOV  AL,BL       ;Restore original character
  STC              ;Set Error Flag
  JMP >H90         ;Done
H80:               ;A Number > 9
  SUB  AL,('A'-10) ;Convert it to a real number
  JMP >H90         ;Done
H85:               ;OK (is a Number)
  CLC              ;Set OK Flag
H90:               ;Done
  POP  BX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A NUMERAL (BETWEEN 0 AND 9)
;Inputs:  AL = ASCII Character to Test
;Outputs: CF = Clear if it is a Number
;              AL = ASCII Code converted to a real Number
;            = Set if Error (not a Number)
;              AL = Unchanged
;Changes:
;------------------------------------------------------------------------------
IsNumber:
  CMP  AL,'0' ;A Number?
  JB  >N70    ;If not, Error
  CMP  AL,'9' ;A Number?
  JBE >N80    ;If so, handle it
N70:          ;Not a Number
  STC         ;Set Error Flag
  JMP >N90    ;Done
N80:          ;A number
  SUB  AL,'0' ;Convert it to a real number
  CLC         ;Set OK Flag
N90:          ;Done
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A PARTICULAR CHARACTER
;Inputs:  AL = ASCII Character to Test
;Outputs: ZF = Set if it is the appropriate character
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
IsHexEnd:
  PUSH AX         ;Save used registers
  MOV  AH,'H'     ;Compare with H
  CALL Capitalize ;Capitalize the Character
  CMP  AL,AH      ;See if it matches
  POP  AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER SPACES TO FIND THE NEXT LEGITIMATE CHARACTER, TESTING FOR EOL
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: ZF = Set if EOL
;               AL  = Unchanged
;              [SI] = End-of-Line Character
;            = Clear if not EOL
;               AL  = First non-space character
;              [SI] = Character AFTER the next non-space character
;Changes:
;------------------------------------------------------------------------------
IsSpaceOrEOX:
  CALL IsSpaceOrEOL ;Skip over the spaces
  JZ  >X90          ;If end-of-line, we're done
  LODSB             ;If not, get the next character
  OR   AL,AL        ;Set return flag
X90:                ;Done
  RET

;------------------------------------------------------------------------------
;SKIP OVER SPACES TO FIND LEGITIMATE CHARACTERS, AND TEST FOR EOL
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: ZF = Set if EOL
;            = Clear if legitimate character
;              [SI] = The Next non-Space Character
;Changes:
;------------------------------------------------------------------------------
IsSpaceOrEOL:
  PUSH AX     ;Save used registers
L10:          ;Loop to here to skip over spaces
  LODSB       ;Get the next character
  CMP  AL,' ' ;Is it a space?
  JE   L10    ;If so, get the next character
  CMP  AL,Tab ;Is it a Tab?
  JE   L10    ;If so, get the next character
  DEC  SI     ;If not, point back at the character
  CMP  AL,CR  ;Set EOL flag
  POP  AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A CODE WORD FROM THE COMMAND LINE TO A WORD FROM THE LOOKUP TABLE
;Inputs:  DS:[SI] = Command Line Pointer
;         DS:[BX] = List to Test
;Outputs: CF = Clear if a match was found
;              AL = Entry from Table
;              [SI] = Next character after the Code Match
;         CF = Set if no match found (error)
;              AL = Unchanged
;              SI = Unchanged
;Changes: SI if valid match found
;------------------------------------------------------------------------------
GetCode:
  PUSH BX,DX         ;Save used registers
  MOV  DX,AX         ;Save AX in case there's no match
C10:                 ;Loop to here for each list of words
  CMP  B [BX],0      ;Are we at the end of our table?
  JE  >C80           ;If so, we couldn't find a match
  XOR  AH,AH         ;Assume it's a match
  PUSH SI            ;Save our command line pointer for a second
C20:                 ;Loop to here for each character in a word
  LODSB              ;Get the next character
  CALL Capitalize    ;Capitalize it
  CALL CmpALBXNoCase ;Is it a match?
  JZ  >C30           ;If so, handle it
  INC  AH            ;If not, mark us as no match
C30:                 ;The character is tested
  INC  BX            ;Point at the next character in our test word
  CMP  B [BX],0      ;Are we at the end of the word?
  JNE  C20           ;If not, keep going until we're done
  INC  BX            ;Point at the next word or code list
  OR   AH,AH         ;Was it a match?
  JZ  >C50           ;If so, jump to handle it
  POP  SI            ;If not, restore our command line pointer
  CMP  B [BX],0      ;Is this the end of our word list?
  JNE  C10           ;If not, just test the next word
  INC  BX,2          ;If so, skip over the codes
  JMP  C10           ;Keep going until we're done with our list
C50:                 ;We've found a match!
  POP  AX            ;Lose our original command line pointer
  DEC  BX            ;Point back at the end-of-word marker
C60:                 ;Loop to here to find the end-of-list
  MOV  AX,[BX]       ;Get the next two characters in our list
  INC  BX            ;Point at the next character for next time
  OR   AX,AX         ;Is this the start of our code list?
  JNE  C60           ;If not, keep looking
  INC  BX            ;If so, point at the character we're looking for
  MOV  DL,[BX]       ;Get the character from the Table
  CLC                ;Mark our OK flag
  JMP >C90           ;And we're done
C80:                 ;No match found
  STC                ;Mark us as no match
C90:                 ;We're done
  MOV  AX,DX         ;Set AX to the correct value
  POP  DX,BX         ;Restore used registers
  RET

CmpALBXNoCase:
  PUSH AX         ;Save used registers
  CALL Capitalize ;Capitalize AL
  MOV  AH,AL      ;Store it in AH
  MOV  AL,[BX]    ;Get [BX]
  CALL Capitalize ;Capitalize it
  CMP  AL,AH      ;Compare AL & [BX]
  POP  AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;BEEP THE SPEAKER
;Inputs:
;Outputs: Beeps the speaker
;Changes:
;------------------------------------------------------------------------------
BeepErr:
  PUSH AX,BX    ;Save used registers
  XOR  BX,BX    ;BH = Video page = 0
  MOV  AX,0E07h ;AH = 0Eh = Function = Write TTY
                ;AL = 07h = Character to write = BEL
  INT  10h      ;Do it
  POP  BX,AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CAPITALIZE A CHARACTER (Byte)
;Inputs:  AL = character to be capitalized
;Outputs: AL = capitalized character
;Changes:
;------------------------------------------------------------------------------
Capitalize:
  CMP  AL,'a'     ;Is it less than 'a'?
  JB  >C90        ;If so, quit
  CMP  AL,'z'     ;Is it more than 'z'?
  JA  >C90        ;If so, quit
  SUB  AL,'a'-'A' ;If between 'a' and 'z', capitalize it
C90:
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO GET "SPECIAL" VALUES FROM THE COMMAND-LINE (INDENTS, ADDRESSES, ETC.)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET THE CALL BACK ADDRESS FROM THE COMMAND-LINE, IF THERE
;Inputs:  [SI] = Command-Line Pointer
;         CallBackAddr = -1
;         ParentIsShell
;Outputs: CF = Clear if OK (got a valid Address)
;                CallBackAddr = Address (converted to a number) if
;                                 ParentShell = No
;            = Set if Error (invalid address format)
;                CallBackAddr = -1 in Offset if none or invalid address,
;                                 or ParentIsShell = Yes,
;                                 or anything follows the address
;Changes: SI
;------------------------------------------------------------------------------
GetCallBackAddr:
  PUSH AX,BX,CX,ES          ;Save used registers
  MOV  CX,SI                ;Save original command-line pointer
  CMP  ParentIsShell,Yes    ;Are we being run from the command-line?
  JE  >C75                  ;If so, don't bother looking for a call-back addr
  CALL IsSpaceOrEOL         ;Skip over the spaces
  JZ  >C75                  ;If end-of-line, no Call-Back Address provided
  CALL GetSegmentOffset     ;Look for a Segment:Offset (returns CF, ES:BX)
  JC  >C75                  ;If none found, no call-back address provided
  CALL IsSpaceOrEOL         ;If valid, is there anything else following it?
  JNZ >C70                  ;If so, error
  MOV  W CallBackAddr[0],BX ;If everything's OK, store the Offset
  MOV  W CallBackAddr[2],ES ;Store the Segment
  JMP >C80                  ;Done
C70:                        ;Error
  MOV  ParseError,Yes       ;Mark as an Error
C75:                        ;No Address/Invalid format
  MOV  SI,CX                ;Restore original command-line pointer
  STC                       ;Set error flag
  JMP >C90                  ;Done
C80:                        ;OK
  CLC                       ;Set OK flag
C90:                        ;Done
  POP  ES,CX,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT SERIES OF CHARACTERS, AND CONVERT THEM TO A SEGMENT:OFFSET
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK
;              ES:BX = Segment:Offset string converted to numbers
;            = Set if Error
;              ES:BX Unchanged
;Changes:
;------------------------------------------------------------------------------
GetSegmentOffset:
  PUSH AX,CX,DX     ;Save used registers
  MOV  CX,ES        ;Save original ES
  MOV  DX,BX        ;Save original BX
  CALL IsSpaceOrEOL ;Skip past the spaces
  JZ  >O70          ;If End of Line, Error
  CALL GetHex       ;Get the Segment
  JC  >O70          ;If error, quit
  MOV  ES,AX        ;If OK, store the Segment
  CALL IsSpaceOrEOX ;Skip over spaces
  JZ  >O70          ;If End of Line, Error
  CMP  AL,':'       ;Is it a Colon?
  JNZ >O70          ;If not, error
  CALL IsSpaceOrEOL ;Skip past the spaces
  JZ  >O70          ;If End of Line, Error
  CALL GetHex       ;Get the Offset
  JC  >O70          ;If error, quit
  MOV  BX,AX        ;If OK, store the Offset
  JMP >O80          ;Done
O70:                ;Error
  MOV  ES,CX        ;Restore original ES
  MOV  BX,DX        ;Restore original BX
  STC               ;Set error flag
  JMP >O90          ;Done
O80:                ;OK
  CLC               ;Set OK flag
O90:                ;Done
  POP  DX,CX,AX     ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PERFORM COMMAND LINE SWITCHES AND OPTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;Switches which involve straightforward table and/or sub-table lookups.
;The tables are simple byte-to-string or word-to-string lookup tables.
;Depending on the number of command-line parameters provided and the exact
;  characteristics of the data, these may either print a single table entry,
;  an entire table, or an entire table and its related sub-tables.
;
;Inputs:  DS:[SI] = Command-line Pointer
;------------------------------------------------------------------------------
DoSwitchPhysicalBias:
  MOV  BX,PhysicalBiasTbl   ;Table to Search
  JMP >S00                  ;Do it
DoSwitchPhysicalDesignator:
  MOV  BX,PhysicalTbl       ;Table to Search
  JMP >S00                  ;Do it
DoSwitchPhysicalQualifier:
  MOV  BX,PhysicalQualTbl   ;Table to Search
  JMP >S00                  ;Do it
DoSwitchReportCollection:
  MOV  BX,CollectionTbl     ;Table to Search
  JMP >S00                  ;Do it
DoSwitchReportDelimiter:
  MOV  BX,DelimiterTbl      ;Table to Search
  JMP >S00                  ;Do it
DoSwitchReportTag:
  MOV  BX,ReportTagTbl      ;Table to Search
  JMP >S00                  ;Do it
DoSwitchUsage:
  MOV  BX,UsagePageTbl      ;Table to Search
  JMP >S01                  ;Do it
DoSwitchUsagePage:
  MOV  BX,UsagePageTbl      ;Table to Search
;  JMP >S00                  ;Do it
S00:                        ;No SubTables
  PUSH CX                   ;Save used registers
  XOR  CL,CL                ;Do no SubTables
  JMP >S10                  ;Do it
S01:                        ;1 SubTable
  PUSH CX                   ;Save used registers
  MOV  CL,1                 ;Do 1 SubTable
  JMP >S10                  ;Do it
S02:                        ;2 SubTables
  PUSH CX                   ;Save used registers
  MOV  CL,2                 ;Do 2 SubTables
;  JMP >S10                  ;Do it
S10:
  CALL DoSwitchGeneral      ;Handle it
  POP  CX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Switches to decipher "non-standard" Descriptors or Structures.
;This processes "non-standard USB Descriptors, which do not have the
;  first two bytes of a Descriptor Size and Descriptor Type.  For now,
;  that only includes HID Report and Physical Descriptors.  Because
;  HID Report and Physical Descriptors do not include a size as part
;  of the Description, we process them until we come to a value of
;  0 where there shouldn't be one.  We do not ask the user for a
;  size as a parameter.
;In addition, this will process other types of structures (not
;  necessarily Descriptors).  The structures may either be of a
;  fixed length, or may be marked by a special ending byte/word
;  (usually a 0 or a -1 where it wouldn't make sense to have one).
;This requires a Segment:Offset as an input parameter, which is the
;  memory address of a downloaded (or created) Descriptor/Structure.
;  This will not process multiple Descriptors or Structures, since in
;  general it has no idea where one might end and the other start.
;
;Inputs:  DS:[SI] = Command-line Pointer
;------------------------------------------------------------------------------
DoSwitchPhysicalDescr:
  PUSH DI                    ;Save used registers
  MOV  DI,WritePhysicalDescr ;Code to Call
  JMP >D00                   ;Do it
DoSwitchReportDescr:
  PUSH DI                    ;Save used registers
  MOV  DI,WriteReportDescr   ;Code to Call
;  JMP >D00                   ;Do it
D00:
  PUSH BX,ES                 ;Save used registers
  CALL GetSegmentOffset      ;Get Data Pointer from command line (ES:BX)
  JC  >D70                   ;If error, Quit
  CALL GetCallBackAddr       ;If OK, look for a Call-Back Address
  CALL IsSpaceOrEOL          ;Is there anything after this on the command-line?
  JNZ >D70                   ;If so, error
D40:                         ;Have the command-line parameters
  CALL DI                    ;Do it
  JMP >D90                   ;Done
D70:                         ;Error
  MOV  ParseError,Yes        ;Mark as error
D90:                         ;Done
  POP  ES,BX                 ;Restore used registers
  POP  DI                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Switch to write our Command-line Aliases.
;This is not actually a USB-related Option, just an Option related
;  to our program itself.
;Unlike the other Options, we will not allow the user to provide a
;  call-back Address to write this to.  We always write this
;  directly to STDOUT.
;------------------------------------------------------------------------------
DoSwitchAlias:
  CALL IsSpaceOrEOL   ;Is there anything after this on the command-line?
  JNZ >A70            ;If so, error
  CALL DoAliases      ;If not, do it
  JMP >A90            ;Done
A70:                  ;Error
  MOV  ParseError,Yes ;mark as an error
A90:                  ;Done
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE REQUIRED TO PERFORM THE ALIAS SWITCH
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PRINT THE COMMAND LINE ALIASES AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;Outputs: Writes Aliases to the screen
;Changes: Quits program
;------------------------------------------------------------------------------
DoAliases:
  PUSH BX,DX,SI         ;Save used registers
  CALL WriteCrLf        ;Move down
  MOV  DX,AliasHdrMsg   ;Set up
  CALL SetupPause       ;  the Header
  MOV  SI,SwitchList    ;Point at Tbl of Aliases
  MOV  BX,1+(40h SHL 8) ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNoNum ;Write the Aliases
A90:                    ;Done
  POP  SI,DX,BX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE LIST OF SWITCH CHARACTERS TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         BL = Minimum Value to look for in the Table
;         DH = Maximum Value to look for in the Table
;         SI = Switch List ("Code Word") Table
;Outputs: Writes List of Switch Characters to the Screen
;Changes:
;NOTES:   Sets CH =  0 if we write Blocks for Switches < " "
;                 = -1 if we write numbers for the all Switches (0-255)
;                 = -2 if we subtract 128 from the numbers (128-255)
;------------------------------------------------------------------------------
;DoAliasesGoNum80h:
;  PUSH CX               ;Save used registers
;  MOV  CH,2             ;Mark as writing Numbers, needing to subtract 128
;  JMP >G00              ;Continue
;DoAliasesGoNum:
;  PUSH CX               ;Save used registers
;  MOV  CH,1             ;Mark as writing Numbers, not needing to modify
;  JMP >G00              ;Continue
DoAliasesGoNoNum:
  PUSH CX               ;Save used registers
  XOR  CH,CH            ;Mark as not writing Numbers
;  JMP >G00              ;Continue
G00:
  PUSH AX,DI            ;Save used registers
  MOV  DI,AliasSortTbl  ;Point at the Alias Sort Table
  MOV  AL,BL            ;Start with the Lower Limit
G10:                    ;Loop to here for each Alias
  CALL GetAliasPointers ;Get the Alias Pointers
  JZ  >G60              ;If none for this entry, go to the next one
G20:                    ;Have at least one valid Alias
  CALL WriteCrLf        ;If valid, move down
  OR   CH,CH            ;Writing Single characters?
  JNZ >G40              ;If not, handle full numbers
  MOV  CL,78            ;Write this many characters per line
;  CMP  AL,' '           ;Is there a valid single-character equivalent?
;  JB  >G30              ;If not, don't write it
;  CALL WriteAL          ;If so, write it
;  JMP >G50              ;Continue
;G30:                    ;Not a writable character
  CALL WriteBlock       ;Write a Block Character
  JMP >G50              ;Continue
G40:                    ;Need to write Numbers
  MOV  CL,76            ;Write this many characters per line
  PUSH AX               ;Save the number for a second
  CMP  CH,2             ;Do we need to modify the Number?
  JNE >G45              ;If not, continue
  AND  AL,(NOT 80h)     ;Subtract 128 from it
G45:                    ;Write the Number
  CALL ByteToString     ;Write the Switch as a Number
  POP  AX               ;Restore the Number
G50:                    ;Done writing single character
  CALL WriteAliases     ;Write the Alias List
G60:                    ;Done with this Code
  CMP  AL,BH            ;Have we done the whole list yet?
  JE  >G90              ;If so, we're done
  INC  AL               ;If not, go to the next possibility
  JMP  G10              ;Keep going until we're done
G90:                    ;Done
  POP  DI,AX            ;Restore used registers
  POP  CX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET STRING POINTERS FOR ALL ALIASES FOR A SINGLE CHARACTER OPTION
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;          AL  = Switch Table entry to look for (not 0)
;         [SI] = Switch Table to look through, sorted backwards
;         [DI] = Alias Sort Table
;Outputs:  ZF = Clear if OK
;               [DI] = Filled with String Pointers, sorted backwards
;                      Last Entry is always a 0
;             = Set if no matches found
;                      First Entry is 0
;Changes:
;------------------------------------------------------------------------------
GetAliasPointers:
  PUSH AX,BX,CX,DX      ;Save used registers
  PUSH DI,SI            ;Save used registers
  MOV  CX,DI            ;Sve original pointer
P10:                    ;Loop to here for each Table Entry
  MOV  DX,SI            ;Save beginning Alias Pointer
P20:                    ;Loop to here to find the end of an Alias List Entry
  CMP  B [SI],0         ;End of Alias List?
  JE  >P30              ;If so, handle it
  CALL SkipOverStringSI ;If not, skip over the string
  JMP  P20              ;Keep looking
P30:                    ;End of Alias List Entry
  MOV  BX,SI            ;Save End-of-Entry Pointer
  CMP  AL,[SI+1]        ;Is this entry a match?
  JNE >P50              ;If not, go to the next one
  MOV  SI,DX            ;Point at Alias String
P40:                    ;Loop to here for each Alias String
  CMP  B [SI],0         ;End of the entry?
  JE  >P50              ;If so, we're done
  MOV  [DI],SI          ;If not, store it in the sort table
  INC  DI,2             ;Update the Table Pointer
  CALL SkipOverStringSI ;Skip over the string
  JMP  P40              ;Keep going until we have all of the strings
P50:                    ;Done with this entry
  MOV  SI,BX            ;Get End-of-Entry Pointer
  INC  SI,2             ;Skip over End-of-Entry stuff
  CMP  B [SI],0         ;End of Table?
  JNE  P10              ;If not, keep looking
P90:                    ;Done
  MOV  W [DI],0         ;Make sure last entry is a 0
  CMP  CX,DI            ;Set return flag
  POP  SI,DI            ;Restore used registers
  POP  DX,CX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ALL ALIAS STRINGS FOR A SINGLE CHARACTER OPTION
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = Alias String Pointer Table (Sorted backwards)
;                  Last Entry is a 0
;          CL  = Number of characters left available to write on first line
;                 (76 if Writing Numbers, 78 if Writing Characters)
;         CLD already issued
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteAliases:
  PUSH AX,BX,CX,DX   ;Save used registers
  PUSH DI,SI,ES      ;Save used registers
  MOV  ES,DS         ;Point ES at the Local Data Area
  MOV  BL,CL         ;BL = Character Countdown Measurer
  MOV  BH,CL         ;BH = Original Counter
  MOV  DX,DI         ;Save start-of-table Pointer
  MOV  CX,-1         ;Maximize counter
  XOR  AX,AX         ;Find the last
  REPNE SCASW        ;  entry in
  SUB  DI,4          ;  the Table
W10:                 ;Loop to here for each Alias String
  CMP  DI,DX         ;Are we done writing?
  JB  >W90           ;If so, quit
  MOV  SI,[DI]       ;Get the next string
  DEC  DI,2          ;Update the table pointer
  CALL CalcStrSizeSI ;See how long the string is
  OR   BL,BL         ;Is the character counter down to 0?
  JZ  >W20           ;If so, we need to reset it
  CMP  CL,BL         ;Is this string too long to fit on this line?
  JB  >W40           ;If not, go ahead and write it
W20:                 ;Need to start a new line
  CALL WriteCrLf     ;Start a new line
  PUSH CX            ;Save String Size for a second
  MOV  CL,79         ;Calculate how many
  SUB  CL,BH         ;  spaces to write
  CALL WriteSpaces   ;Write the spaces
  POP  CX            ;Restore String Size
  MOV  BL,BH         ;Reset the character counter
W40:                 ;Write the Alias String
  SUB  BL,CL         ;Update the
  DEC  BL            ;  character counter
  CALL WriteSpace    ;Write a Space
  CALL WriteItSI     ;Write the string
  JMP  W10           ;Keep writing
W90:                 ;Done
  CALL WriteCrLf     ;Move down
  POP  ES,SI,DI      ;Restore used registers
  POP  DX,CX,BX,AX   ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS AN HID REPORT DESCRIPTOR
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PRINT REPORT DESCRIPTOR, WITH DESCRIPTIONS, TO THE SCREEN
;Inputs:  ES:[BX] = Report Descriptor to Write
;         DS = Local Data Area
;Outputs: Writes Report Descriptor, with Descriptions, to the Screen
;Changes:
;NOTE: This assumes that the terminator for the Descriptor is a DB 0
;        where the next Report Tag would be.  It does not need a length
;        on the input.
;      This also does not check for errors.  It will print all kinds of
;        weird/confusing/misleading things to the screen if it is not
;        looking at a real Report Descriptor.
;------------------------------------------------------------------------------
WriteReportDescr:
  PUSH AX,BX,CX,EDX      ;Save used registers
  PUSH DI,SI             ;Save used registers
  MOV  DX,ReportDescrHdr ;Write the
  CALL WriteItDX         ;  Header
  MOV  SI,BX             ;Point ES:[SI] at the Descriptor
  CALL ResetReportItems  ;Clear out the Report Items Table
  MOV  DI,ReportItems    ;Point at the Report Item Table
P10:                     ;Loop to here for each Line of Report Descr
  CALL GetNextReportTag  ;Get Next Report Tag (returns AL, CX, EDX)
  JC  >P90               ;If none found, quit
  CALL WriteReportTagRaw ;If OK, write the Raw Bytes
  MOV  BX,ReportTagTbl   ;Write the
  CALL SearchTblWrite    ;  Description
  JC  >P50               ;If unknown, handle it
  OR   BX,BX             ;Any follow-up Code to Perform?
  JZ  >P60               ;If not, we're done
  CALL WriteSpace        ;If so, write a Space
  CALL BX                ;Perform the Code
  JMP >P60               ;Go to next one
P50:                     ;Unknown description
  CALL WriteQuestion     ;Write a Question Mark
P60:                     ;Go to next Report Tag
  CALL WriteCrLf         ;Write a New Line
  JMP  P10               ;Go to next one
P90:                     ;Done
  POP  SI,DI             ;Restore used registers
  POP  EDX,CX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESET (CLEAR OUT) THE REPORT ITEMS TABLE
;Inputs:  DS = Data Area
;         ReportItems Table
;Outputs: Resets all items in Report Items Table to 0
;Changes:
;------------------------------------------------------------------------------
ResetReportItems:
  PUSH AX,CX,DI,ES    ;Save used registers
  MOV  CX,((ReportItemSize * NumReportPushes)/2) ;Number of words to write
  XOR  AX,AX          ;Store zeroes
  MOV  ES,DS          ;Point ES:[DI]
  MOV  DI,ReportItems ;  at the Table
  REP  STOSW          ;Fill it with zeroes
  POP  ES,DI,CX,AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET NEXT REPORT TAG AND DATA FROM THE REPORT DESCRIPTOR
;Inputs:  ES:[SI] = Next Report Tag to Get
;Outputs: CF = Clear if OK (Report Tag <> 0)
;              AL = Report Tag (without Size)
;               CX = Number of bytes following Tag (lower 2 bits of Tag)
;              EDX = Data Following Tag
;            = Set if Error
;              AL = CX = EDX = 0
;Changes: ES:[SI] = Report Tag for next time
;------------------------------------------------------------------------------
GetNextReportTag:
  PUSH DS           ;Save used registers
  MOV  DS,ES        ;Point DS at the Report Descriptor Area
  XOR  CX,CX        ;Initialize CX
  XOR  EDX,EDX      ;Initialize EDX
  LODSB             ;Get the next Report Tag
  OR   AL,AL        ;End of Report Descriptor?
  JZ  >T70          ;If so, quit
  MOV  CL,AL        ;Set CX to
  AND  CL,03h       ;  Data Size
  AND  AL,(NOT 03h) ;Mask data Size out of AL
  OR   CL,CL        ;0 Bytes of Data?
  JZ  >T80          ;If so, we're done
  CMP  CX,2         ;If not, 1, 2 or 4 bytes of data?
  JE  >T20          ;If 2 bytes, handle it
  JA  >T30          ;If 4 bytes, handle it
T10:                ;1 Byte of Data
  MOV  DL,B [SI]    ;Get Data
  JMP >T80          ;Done
T20:                ;2 Bytes of Data
  MOV  DX,W [SI]    ;Get Data
  JMP >T80          ;Done
T30:                ;4 Bytes of Data
  INC  CX           ;Convert Actual Data Size from 3 to 4
  MOV  EDX,D [SI]   ;Get Data
  JMP >T80          ;Done
T70:                ;Error
  STC               ;Set error flag
  JMP >T90          ;Done
T80:                ;OK
  ADD  SI,CX        ;Point at the next Report Tag
  CLC               ;Set OK Flag
T90:                ;Done
  POP  DS           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE REPORT TAG AND DATA TO THE SCREEN
;Inputs:   AL = Report Tag to Write (without Size)
;          CX = Number of Data Bytes following Tag
;         EDX = Data Following Tag
;Outputs: Writes "Raw" Data to Screen
;Changes:
;------------------------------------------------------------------------------
WriteReportTagRaw:
  PUSH AX,BX,CX     ;Save used registers
  PUSH EDX,SI       ;Save used registers
  ADD  AL,CL        ;Add the Size back in
  CMP  CL,4         ;  to the true
  JNE >W10          ;  original
  DEC  AL           ;  Report Size
W10:                ;AL contains original Report Tag
  MOV  BL,CL        ;BL = Number of Data Bytes
  MOV  BH,4         ;BH = Number of
  SUB  BH,BL        ;  "Blank" Data Bytes
  CALL WriteByteHex ;Write the Report Tag
  CALL WriteSpace   ;Write a Space
  OR   BL,BL        ;Any Real Bytes?
  JE  >W50          ;If not, jump to write Unreal bytes
W20:                ;Loop to here for each Real Data Byte
  MOV  AL,DL        ;If so, write
  CALL WriteByteHex ;  the Data Byte
  SHR  EDX,8        ;Put next data byte in DL
  CALL WriteSpace   ;Write a space
  DEC  BL           ;Decrement Real Byte Counter
  JNZ  W20          ;If not 0 yet, keep writing
W40:                ;Write unreal Bytes
  CMP  BH,0         ;Need to write an unreal byte?
  JE  >W80          ;If not, we're done
W50:                ;Loop to here for each unreal data byte
  CALL Write3Spaces ;Write some spaces
  DEC  BH           ;Decrement Unreal Byte Counter
  JNZ  W50          ;If not 0 yet, keep writing
W80:                ;Done writing raw bytes
  CALL DoIndent     ;Indent appropriately
  POP  SI,EDX       ;Restore used registers
  POP  CX,BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A USAGE PAGE REPORT TAG
;Inputs:  CX      = Data Size from Descriptor
;         EDX     = Data DWord
;         DS:[DI] = Current DWord Storage Area
;Outputs: Updates appropriate DWord, Writes Data to Screen
;Changes:
;------------------------------------------------------------------------------
DoUsagePage:
  PUSH AX,BX               ;Save used registers
;Need to save old Usage Page?
;  MOV  AL,DL               ;Put Usage Page in AL
  MOV  AX,DX               ;Put Usage Page in AL
;  MOV  [DI].UsagePage,AL   ;Store it
  MOV  [DI].UsagePage,AX   ;Store it
  MOV  BX,UsagePageTbl     ;Write the
  CALL SearchTblWrite      ;  Usage Page
  JNC >P90                 ;If OK, we're done
;  CALL WriteByteMin        ;If not, just write the Number
  CALL WriteWordMinHex     ;If not, just write the Number
  CMP  AX,0FF00h           ;Is it in the Vendor-specific Range?
  JB  >P90                 ;If not, jsut leave it at the Number
  CALL WriteSpace          ;If so, move over
  PUSH DX                  ;Write
  MOV  DX,VendorDefinedMsg ;  the
  CALL WriteItDX           ;  Vendor Defined
  POP  DX                  ;  Message
P90:                       ;Done
  POP  BX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A USAGE, USAGE MIN, OR USAGE MAX REPORT TAG
;Inputs:  CX      = Data Size from Descriptor
;         EDX     = Data DWord
;         DS:[DI] = Current DWord Storage Area
;Outputs: Updates appropriate DWord, Writes Data to Screen
;Changes:
;------------------------------------------------------------------------------
DoUsage:
  PUSH BP                 ;Save used registers
  MOV  BP,OFFSET Usage    ;Point at Data DWord
  JMP >U00                ;Do it
DoUsageMin:
  PUSH BP                 ;Save used registers
  MOV  BP,OFFSET UsageMin ;Point at Data DWord
  JMP >U00                ;Do it
DoUsageMax:
  PUSH BP                 ;Save used registers
  MOV  BP,OFFSET UsageMax ;Point at Data DWord
;  JMP >U00                ;Do it
U00:
  PUSH AX,BX,DX           ;Save used registers
  MOV  DS:[DI+BP],EDX     ;Store new value
;  CALL UpdateOldDWord     ;Update the DWord
;  MOV  AL,[DI].UsagePage  ;Get Current Usage Page
  MOV  AX,[DI].UsagePage  ;Get Current Usage Page
  MOV  BX,UsagePageTbl    ;Point at the Usage Page Table
  CALL SearchTblNoWrite   ;Find the Usage Page (returns BX)
  JC  >U70                ;If error, just write the Number
  OR   BX,BX              ;Anything to write?
  JZ  >U70                ;If not, just write the Number
  MOV  AX,DX              ;Write
  CALL SearchTblWrite     ;  the Usage
  JNC >U90                ;Done
U70:                      ;Error (Not In Table)
  MOV  AX,DX              ;Get Usage Number
  CALL WriteWordMinHex    ;Write it
U90:                      ;Done
  POP  DX,BX,AX           ;Restore used registers
  POP  BP                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A COLLECTION REPORT TAG
;Inputs:  CX      = Data Size from Descriptor
;         EDX     = Data DWord
;         DS:[DI] = Current DWord Storage Area
;Outputs: Updates appropriate DWord, Writes Data to Screen
;Changes:
;------------------------------------------------------------------------------
DoCollection:
  PUSH AX,BX              ;Save used registers
;Need to save old Collection?
  ADD  Indent,2           ;Add some more Indentation for Next Time
  MOV  AL,DL              ;Put Collection Type in AL
  MOV  [DI].Collection,AL ;Store it
  MOV  BX,CollectionTbl   ;Write the
  CALL SearchTblWrite     ;  Collection Type
  CALL WriteCrLf          ;Write a Blank Line
  POP  BX,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE AN END COLLECTION REPORT TAG
;Inputs:  CX      = Data Size from Descriptor
;         EDX     = Data DWord
;         DS:[DI] = Current DWord Storage Area
;Outputs: Updates appropriate DWord, Writes Data to Screen
;Changes:
;------------------------------------------------------------------------------
DoEndCollection:
  SUB  Indent,2  ;Decrease the Indentation
  JNC >L20       ;If not below 0, continue
  MOV  Indent,0  ;If below 0, just make it 0
L20:             ;Indent OK
  CALL WriteCrLf ;Write a blank line
;Need to Restore Saved Collection?
  RET

;------------------------------------------------------------------------------
;HANDLE A DELIMITER REPORT TAG
;Inputs:  CX      = Data Size from Descriptor
;         EDX     = Data DWord
;         DS:[DI] = Current DWord Storage Area
;Outputs: Updates appropriate DWord, Writes Data to Screen
;Changes:
;NOTES: We don't really need to store the Delimiter, but will do it anyway.
;       This will make the PSUH/POP Structure an even nubmer of bytes, which
;         makes things easier and faster
;------------------------------------------------------------------------------
DoDelimiter:
  PUSH AX,BX             ;Save used registers
  MOV  AL,DL             ;Put Delimiter Type in AL
  MOV  [DI].Delimiter,AL ;Store it
D10:                     ;Check for Open Set
  CMP  AL,1              ;Is it Open Set?
  JNE >D20               ;If not, try Close Set
  ADD  Indent,2          ;If so, Add some more Indentation for Next Time
  JMP >D40               ;Continue
D20:                     ;Check for Close Set
  CMP  AL,2              ;Is it Close Set?
  JNE >D40               ;If not, we're done
  SUB  Indent,2          ;If so, Decrease Indentation for Next Time
;  JMP >D40               ;Continue
D40:                     ;Indent is handled
  MOV  BX,DelimiterTbl   ;Write the
  CALL SearchTblWrite    ;  Delimiter Type
  CALL WriteCrLf         ;Write a Blank Line
  POP  BX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A PUSH GLOBAL STATE REPORT TAG
;Inputs:  CX      = Data Size from Descriptor
;         EDX     = Data DWord
;         DS:[DI] = Current DWord Storage Area
;Outputs: Copies current Global State to New Global State
;         Updates [DI] to point at new Global State
;Changes:
;------------------------------------------------------------------------------
DoPushGlobal:
  PUSH CX,SI,ES              ;Save used registers
  MOV  ES,DS                 ;Point ES at local Data Area
  ADD  Indent,2              ;Add some more Indentation for Next Time
  MOV  SI,DI                 ;Point at old (current) Global Data
  MOV  CX,(ReportItemSize/2) ;Number of Words to Write
  ADD  DI,ReportItemSize     ;Point DI at new Global State Area
  REP  MOVSW                 ;Copy the Items
  MOV  DI,SI                 ;Point DI at the New Data Area
  CALL WriteCrLf             ;Write a blank line
  POP  ES,SI,CX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A POP GLOBAL STATE REPORT TAG
;Inputs:  CX      = Data Size from Descriptor
;         EDX     = Data DWord
;         DS:[DI] = Current DWord Storage Area
;Outputs: Updates [DI] to point at old (previous) Global State
;Changes:
;------------------------------------------------------------------------------
DoPopGlobal:
  SUB  Indent,2          ;Decrease the Indentation
  SUB  DI,ReportItemSize ;Point at old (previous) Global State Table
  CALL WriteCrLf         ;Write a blank line
  RET

;------------------------------------------------------------------------------
;HANDLE AN INPUT, OUTPUT, OR FEATURE REPORT TAG
;Inputs:  CX      = Data Size from Descriptor
;         EDX     = Data DWord
;         DS:[DI] = Current DWord Storage Area
;         Indent
;Outputs: Updates appropriate DWord, Writes Data to Screen
;Changes:
;------------------------------------------------------------------------------
DoInput:
DoOutput:
DoFeature:
  PUSH AX,BX,CX,SI        ;Save used registers
  MOV  SI,InOutFeatureTbl ;Point at Lookup Table
  MOV  CL,33              ;CL = Number of
  ADD  CL,Indent          ;  Indent Spaces to write
  MOV  BL,3               ;Write three lines
T10:                      ;Loop to here for each Line
  MOV  BH,3               ;Write three attributes per line
  CMP  BL,3               ;Is this the first line?
  JE  >T20                ;If so, don't do the Indent
  CALL WriteSpaces        ;Write the Indent
T20:                      ;Indent Handled, if needed
  LODSW                   ;Get next Table Entry
  TEST AX,DX              ;This Bit Set?
  JNZ >T40                ;If so, jump to write the second string
T30:                      ;Write first string
  CALL WriteItSISkip      ;Write and skip over the First String
  JMP >T50                ;Continue
T40:                      ;Write second string
  CALL SkipOverStringSI   ;Skip Over the First String
  CALL WriteItSI          ;Write the Second String
T50:                      ;Done with this Attribute
  CALL SkipOverStringSI   ;Skip over the second string
  DEC  BH                 ;Decrement Attribute Counter
  JZ  >T60                ;If done with this line, jump to handle it
  CALL Write2Spaces       ;If not done with line yet, move over
  JMP  T20                ;Keep writing
T60:                      ;Done with this line
  CALL WriteCrLf          ;Move down
  DEC  BL                 ;Decrement Line Counter
  JNZ  T10                ;If not dne yet, keep writing
T90:                      ;Done
  POP  SI,CX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A UNITS REPORT TAG
;Inputs:  CX      = Data Size from Descriptor
;         EDX     = Data DWord
;         DS:[DI] = Current DWord Storage Area
;Outputs: Updates appropriate DWord, Writes Data to Screen
;Changes:
;------------------------------------------------------------------------------
DoUnits:
  PUSH EAX,EBX,CX,DX      ;Save used registers
  PUSH SI,BP              ;Save used registers
  MOV  EBX,EDX            ;Put DWOd in EBX
  MOV  BP,OFFSET Units    ;Update the
  MOV  DS:[DI+BP],EDX     ;Store new value
;  CALL UpdateOldDWord     ;  Old DWord
  MOV  SI,UnitsTbl        ;Point at the Table
  MOV  AH,BL              ;Get the System Nibble
  AND  AH,0Fh             ;  from the DWord
U10:                      ;Loop to here to find System
  LODSB                   ;Get the byte fromthe Table
  OR   AL,AL              ;End of Table?
  JNZ >U15                ;If not, continue
  CMP  B [SI],-1          ;End of Table?
  JE  >U70                ;If so, Error
U15:                      ;Valid table Entry
  CMP  AL,AH              ;Is it a match?
  JE  >U20                ;If so, continue
  MOV  CX,7               ;Need to skip 7 strings
U18:                      ;Loop to here to skip each string
  CALL SkipOverStringSI   ;Skip the String
  LOOP U18                ;Keep going until we're done
  JMP  U10                ;Go to the next table entry
U20:                      ;It's a match
  MOV  CL,7               ;Need to test 7 Nibbles
  XOR  CH,CH              ;CH = Exponent Counter
U30:                      ;Loop to here for each Nibble
  SHR  EBX,4              ;Put the
  MOV  AL,BL              ;  next nibble
  AND  AL,0Fh             ;  in AH
  OR   AL,AL              ;Any exponent Here?
  JZ  >U60                ;If not, skip it
  CMP  B [SI],0           ;Valid String?
  JE  >U60                ;If not, skip it
  OR   CH,CH              ;Is this the first exponent?
  JZ  >U35                ;If so, no need for a star
  MOV  DX,MultiplyMsg     ;If not, write a
  CALL WriteItDX          ;  multiply symbol
U35:                      ;Done with multiply symbol
  INC  CH                 ;Increment the Exponent Counter
  CALL WriteItSI          ;Write the String
  CMP  AL,1               ;Need an exponent symbol?
  JE  >U60                ;If not, continue
  MOV  DX,ExponentMsg     ;If so, write the
  CALL WriteItDX          ;  exponent symbol
  CALL WriteNibbleInteger ;Write the Exponent
U60:                      ;Done with this Nibble
  CALL SkipOverStringSI   ;Skip over teh String
  DEC  CL                 ;Decrement Loop Counter
  JNZ  U30                ;If not 0 yet, keep looking
  OR   CH,CH              ;Did we do anything?
  JNZ >U90                ;If so, we're done
U70:                      ;Just write the DWord
  MOV  EAX,EDX            ;Just write the
  CALL WriteDWordMinHex   ;  DWord
U90:                      ;Done
  POP  BP,SI              ;Restore used registers
  POP  DX,CX,EBX,EAX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A LONG DATA REPORT TAG
;Inputs:  CX      = Data Size from Descriptor
;         EDX     = Data DWord
;         ES:[SI] = Report Pointer
;         DS:[DI] = Current DWord Storage Area
;Outputs: Updates appropriate DWord, Writes Data to Screen
;Changes: SI
;NOTE: Unlike other Report Tag Handlers, this will actually change the
;        Pointer [SI].  We will assume this does not need to "update"
;        an old DWord or anything like that, since this can actually
;        have up to 255 bytes of data (probably a string).  As far as
;        I know, nobody has ever used the Long Data Tag for anything in
;        a real Device, so exactly how this will work is up for debate.
;        For now, we'll just print the raw data.
;------------------------------------------------------------------------------
DoLongData:
  PUSH AX            ;Save used registers
  CMP  CL,2          ;Is it a size of 2 (it had better be!!)
  JNE >L70           ;If not, Error
  MOV  AX,DX         ;If so, get the Tag (AL)
  XCHG AL,AH         ;  and Actual Data Size (AH)
  CALL WriteByteHex  ;Write the Tag
  CALL WriteHexEnd   ;Write the 'h'
  CALL WriteColon    ;Write a colon
L20:                 ;Loop to here for each Data Byte
  OR   AH,AH         ;Any Data left?
  JZ  >L90           ;If not, we're done
  DEC  AH            ;If so, decrement the Byte Counter
  MOV  AL,ES:[SI]    ;Get the next Byte
  INC  SI            ;Increment the Pointer
  CALL WriteSpace    ;Write a Space
  CALL WriteByteHex  ;Write the Byte
  CALL WriteHexEnd   ;Write the 'h'
  JMP  L20           ;Keep going
L70:                 ;Error
  CALL WriteQuestion ;Write a Question Mark
L90:                 ;Done
  POP  AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A UNIT EXPONENT REPORT TAG
;Inputs:  CX      = Data Size from Descriptor
;         EDX     = Data DWord
;         DS:[DI] = Current DWord Storage Area
;Outputs: Updates appropriate DWord, Writes Data to Screen
;Changes:
;NOTE: This assumes a Unit Exponent will always be between -128 and +127
;        (a single byte), and ignores bytes 1-3 of the DWord.  If an
;        Exponent is ever bigger than that (very unlikely), we'll need
;        to change our code!
;------------------------------------------------------------------------------
DoUnitExponent:
  PUSH AX                   ;Save used registers
  MOV  AL,DL                ;Get the low byte of the exponent
  MOV  [DI].UnitExponent,AL ;Save it
  CALL WriteByteInteger     ;Write it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REPORT TAG THAT UPDATES A SIMPLE "STORED" DATA DWORD
;Inputs:  CX      = Data Size from Descriptor
;         EDX     = Data DWord
;         DS:[DI] = Current DWord Storage Area
;Outputs: Updates appropriate DWord, Writes Data to Screen
;Changes:
;------------------------------------------------------------------------------
DoDesignatorIndex:
  PUSH BP                        ;Save used registers
  MOV  BP,OFFSET DesignatorIndex ;Point at Data DWord
  JMP >D10                       ;Do it
DoDesignatorMin:
  PUSH BP                        ;Save used registers
  MOV  BP,OFFSET DesignatorMin   ;Point at Data DWord
  JMP >D10                       ;Do it
DoDesignatorMax:
  PUSH BP                        ;Save used registers
  MOV  BP,OFFSET DesignatorMax   ;Point at Data DWord
  JMP >D10                       ;Do it
DoLogicalMin:
  PUSH BP                        ;Save used registers
  MOV  BP,OFFSET LogicalMin      ;Point at Data DWord
  JMP >D20                       ;Do it
DoLogicalMax:
  PUSH BP                        ;Save used registers
  MOV  BP,OFFSET LogicalMax      ;Point at Data DWord
  JMP >D20                       ;Do it
DoPhysicalMin:
  PUSH BP                        ;Save used registers
  MOV  BP,OFFSET PhysicalMin     ;Point at Data DWord
  JMP >D20                       ;Do it
DoPhysicalMax:
  PUSH BP                        ;Save used registers
  MOV  BP,OFFSET PhysicalMax     ;Point at Data DWord
  JMP >D20                       ;Do it
DoReportCount:
  PUSH BP                        ;Save used registers
  MOV  BP,OFFSET ReportCount     ;Point at Data DWord
  JMP >D10                       ;Do it
DoReportSize:
  PUSH BP                        ;Save used registers
  MOV  BP,OFFSET ReportSize      ;Point at Data DWord
  JMP >D10                       ;Do it
DoReportID:
  PUSH BP                        ;Save used registers
  MOV  BP,OFFSET ReportID        ;Point at Data DWord
  JMP >D10                       ;Do it
DoStringIndex:
  PUSH BP                        ;Save used registers
  MOV  BP,OFFSET StringIndex     ;Point at Data DWord
  JMP >D10                       ;Do it
DoStringMin:
  PUSH BP                        ;Save used registers
  MOV  BP,OFFSET StringMin       ;Point at Data DWord
  JMP >D10                       ;Do it
DoStringMax:
  PUSH BP                        ;Save used registers
  MOV  BP,OFFSET StringMax       ;Point at Data DWord
  JMP >D10                       ;Do it

D00:                             ;Write DWord in Hex
  MOV  DS:[DI+BP],EDX            ;Store new value
;  CALL UpdateOldDWord            ;Update the DWord
  CALL WriteNewDWordHex          ;Write it in Hex
  POP  BP                        ;Restore used registers
  RET

D10:                             ;Write DWord in Decimal
  MOV  DS:[DI+BP],EDX            ;Store new value
;  CALL UpdateOldDWord            ;Update the DWord
  CALL WriteNewDWordDecimal      ;Write it in Decimal
  POP  BP                        ;Restore used registers
  RET

D20:                             ;Write DWord in Hex, Decimal, & Integer
  MOV  DS:[DI+BP],EDX            ;Store new value
;  CALL UpdateOldDWord            ;Update the DWord
  CALL WriteNewDWordHex          ;Write it in Hex
  CALL Write2Spaces              ;Move over
  CALL WriteNewDWordDecimal      ;Write it in Decimal
  CALL Write2Spaces              ;Move ove
  CALL WriteNewDWordInteger      ;Write it as an Integer
  POP  BP                        ;Restore used registers
  RET

;;------------------------------------------------------------------------------
;;UPDATE AND OLD DWORD IN MEMORY WITH THE NEW VALUE
;;Inputs:  DS:[DI+BP] = Old Dword to Update
;;         EDX        = New DWord
;;          CX        = Number of Bytes in DWord (0, 1, 2, or 4)
;;Outputs: Updates [DI]
;;------------------------------------------------------------------------------
;UpdateOldDWord:
;  PUSH EAX            ;Save used registers
;  MOV  EAX,DS:[DI+BP] ;Get Old DWord
;  OR   CL,CL          ;Anything to Change?
;  JZ  >O90            ;If not, we're done
;  CMP  CL,2           ;Is it 1, 2 or 4 bytes?
;  JE  >O20            ;If 2 Bytes, Handle it
;  JA  >O30            ;If 4 bytes, Handle it
;O10:                  ;Data is 1 byte
;  MOV  AL,DL          ;Copy the first byte
;  JMP >O90            ;Done
;O20:                  ;Data is 2 bytes
;  MOV  AX,DX          ;Copy the first two bytes
;  JMP >O90            ;Done
;O30:                  ;Data is 4 bytes
;  MOV  EAX,EDX        ;Copy all four bytes
;O90:                  ;EAX contains new DWord
;  MOV  DS:[DI+BP],EAX ;Store it for next time
;  POP  EAX            ;Restore used registers
;  RET

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF A NEW DWORD DATA TO THE SCREEN
;Inputs:  DS:[DI+BP] = DWord to Write
;Outputs: Writes to Screen
;Changes:
;NOTES: This writes a Byte, Word, or DWord, whichever is appropriate
;------------------------------------------------------------------------------
WriteNewDWordDecimal:    ;Write as Decimal
  PUSH BX                ;Save used registers
  XOR  BL,BL             ;Mark as Decimal
  JMP >W00               ;Do it
WriteNewDWordInteger:    ;Write as an Integer
  PUSH BX                ;Save used registers
  MOV  BL,-1             ;Mark as Integer
  JMP >W00               ;Do it
WriteNewDWordHex:        ;Write as Hex
  PUSH BX                ;Save used registers
  MOV  BL,1              ;Mark as Hex
;  JMP >W00               ;Do it
W00:
  PUSH EAX               ;Save used registers
  MOV  EAX,DS:[DI+BP]    ;Get DWord
  OR   BL,BL             ;Write as a Decimal?
  JNZ >W20               ;If not, try next possibility
W10:                     ;Write as Decimal
  CALL WriteDWordMin     ;Write as Decimal
  JMP >W90               ;Done
W20:                     ;Not Decimal
  CMP  BL,1              ;Write as Hex?
  JNE >W30               ;If not, try next possibility
  CALL WriteDWordMinHex  ;Write as Hex
  JMP >W90               ;Done
W30:                     ;Not Hex - Do Integer
  TEST EAX,0FFFF_FF00h   ;More than a Byte can Handle?
  JNZ >W33               ;If so, skip down
  CALL WriteByteInteger  ;Write the Byte
  JMP >W90               ;Done
W33:                     ;More than a Byte can Handle
  TEST EAX,0FFFF_0000h   ;More than a Word can Handle?
  JNZ >W36               ;If so, skip down
  CALL WriteWordInteger  ;Write the Word
  JMP >W90               ;Done
W36:                     ;More than a Word can Handle
  CALL WriteDWordInteger ;Write teh DWord
W90:                     ;Done
  POP  EAX               ;Restore used registers
  POP  BX                ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS AN HID PHYSICAL DESCRIPTOR
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PRINT PHYSICAL DESCRIPTOR, WITH DESCRIPTIONS, TO THE SCREEN
;Inputs:  ES:[BX] = Report Descriptor to Write
;         DS = Local Data Area
;Outputs: Writes Physical Descriptor, with Descriptions, to the Screen
;Changes:
;NOTE: This assumes that the terminator for the Descriptor is a DW 0
;        where the next Physical Designator/Qualifier/Effort Word would be.
;        It does not need a length on the input.
;      This also does not check for errors.  It could print some
;        weird/confusing/misleading things to the screen if it is not
;        looking at a real Physical Descriptor.
;------------------------------------------------------------------------------
WritePhysicalDescr:
  PUSH AX,BX,CX,SI         ;Save used registers
  MOV  DX,PhysicalDescrMsg ;Write the
  CALL WriteItDX           ;  Header
  MOV  SI,BX               ;Point ES:[SI] at the Descriptor
  MOV  AL,ES:[SI]          ;Get the Info Byte
  INC  SI                  ;Increment Pointer
  CALL WritePhysInfoByte   ;Write the Bias & Preference
  CALL WriteCrLf2          ;Move down
  MOV  DX,DesignatorMsg    ;Initialize the
  CALL SetupPause          ;  Header
P10:                       ;Loop to here for each Designator Index
  CMP  W ES:[SI],0         ;Valid Data?
  JE  >P90                 ;If not, we're done
  MOV  CL,7                ;Write some
  CALL WriteSpaces         ;  spaces
  MOV  AL,CH               ;Write
  CALL WriteByteHex        ;  the
  CALL WriteHexEnd         ;  Index
  CALL Write2Spaces        ;Write some spaces
  MOV  AX,ES:[SI]          ;Write
  CALL WriteWordHex        ;  the
  CALL WriteHexEnd         ;  Raw Data
  MOV  CL,5                ;Write some
  CALL WriteSpaces         ;  spaces
  CALL WriteEffort         ;Write Effort
  CALL Write2Spaces        ;Write some spaces
  CALL WritePhysWord       ;Write Description & Qualifier
  CALL WriteCrLf           ;Write a New Line
  INC  CH                  ;Increment Index
  INC  SI,2                ;Increment Pointer
  JMP  P10                 ;Keep Looking
P90:                       ;Done
  POP  SI,CX,BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A PHYSICAL DESCRIPTOR BIAS/PREFERENCE TO THE SCREEN
;Inputs:  AL = Physical Info Byte to write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WritePhysInfoByte:
  PUSH AX,BX,DX           ;Save used registers
  MOV  AH,AL              ;Save Preference
  CALL WriteByteHex       ;Write the
  CALL WriteHexEnd        ;  Raw Data Byte
  CALL WriteColon         ;Write a Colon
  CALL Write2Spaces       ;Move over
  MOV  DX,BiasMsg         ;Write the
  CALL WriteItDX          ;  Bias Message
  AND  AL,(NOT 1Fh)       ;Mask out the Preference
  MOV  BX,PhysicalBiasTbl ;Point at the Bias Table
  CALL SearchTblWrite     ;Write the Bias
  CALL WriteCommaSpace    ;Write a Comma & a Space
  MOV  DX,PreferenceMsg   ;Write the
  CALL WriteItDX          ;  Preference Message
  MOV  AL,AH              ;Get Preference back again
  AND  AL,01Fh            ;Mask out the Bias
  CALL WriteByteMin       ;Write the Preference
  POP  DX,BX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A PHYSICAL DESCRIPTOR DESIGNATOR/QUALIFIER/EFFORT WORD TO THE SCREEN
;Inputs:  AX = Physical Descriptor Word to write
;              (AL = Designator, AH = Qualifier & Effort)
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WritePhysWord:
  PUSH AX,BX,CX,DX        ;Save used registers
  MOV  CX,AX              ;Save original data
P10:                      ;Write Qualifier
  MOV  AL,CH              ;Get Qualifier
  AND  AL,(NOT 1Fh)       ;Mask out Effort
  MOV  BX,PhysicalQualTbl ;Point at Physical Qualifier Table
  CALL SearchTblWrite     ;Write the Qualifier
  JC  >P20                ;If none, no need to a space
  CALL WriteSpace         ;Write a Space
P20:                      ;Write Designator
  MOV  AL,CL              ;Get the Designator
  MOV  BX,PhysicalTbl     ;Point at Physical Designator Table
  CALL SearchTblWrite     ;Write the Designator
  JNC >P30                ;If OK, continue
  CALL WriteQuestion      ;Write a Question Mark
P30:                      ;Write Effort
  POP  DX,CX,BX,AX        ;Restore used registers
  RET

WriteEffort:
  PUSH AX           ;Save used registers
  MOV  AL,AH        ;Put Effort in AL
  AND  AL,1Fh       ;Mask out Qualifier
  CALL ByteToString ;Write it
  POP  AX           ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE TO SEARCH THROUGH AND/OR PRINT ONE OF THE LOOKUP TABLES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SEARCH A STRING OR STRING-AND-OFFSET TABLE FOR A MATCH, AND MAYBE WRITE STRING
;Inputs:  DS:[BX] = Table to Search In
;         AL/AX = Byte/Word to Look for
;Outputs: CF = Clear if OK (Byte/Word Found)
;              Writes String to Screen
;              If String and Code Table, BX = Offset From Table
;              If String-Only Table, BX = 0
;            = Set if Error (Byte not found)
;              BX = 0
;Changes:
;------------------------------------------------------------------------------
SearchTblNoWrite:
  PUSH BP                  ;Save used registers
  XOR  BP,BP               ;Mark as not needing to write
  JMP >S00                 ;Do it
SearchTblWrite:
  PUSH BP                  ;Save used registers
  MOV  BP,-1               ;Mark as needing to write
;  JMP >S00                 ;Do it
S00:
  PUSH AX,CX,DX,SI         ;Save used registers
  OR   BX,BX               ;Valid Table?
  JZ  >S70                 ;If not, error
  MOV  CL,[BX]             ;Save Table Flags
  MOV  SI,BX               ;Point SI at
  INC  SI                  ;  the Table
  MOV  DX,AX               ;Put test-for-word in DX
  TEST CL,TblFlagWord      ;A Word Table?
  JNZ >S10                 ;If so, continue
  XOR  DH,DH               ;If not, high byte
  XOR  AH,AH               ;  is 0
S10:                       ;Loop to here for each Table Entry
  TEST CL,TblFlagWord      ;A Word Table?
  JNZ >S20                 ;If so, handle it
  LODSB                    ;Get the Byte
  JMP >S30                 ;Continue
S20:                       ;Getting a Word
  LODSW                    ;Get the Word
S30:                       ;Have the Table Index
  OR   AX,AX               ;End of Table?
  JNZ >S35                 ;If not, continue
  CMP  B [SI],-1           ;End of table?
  JE  >S70                 ;If so, Error (no match)
S35:                       ;Valid table Entry
  CMP  AX,DX               ;Is it a match?
  JNE >S40                 ;If not, go to the next one
  OR   BP,BP               ;Are we supposed to write the string?
  JZ  >S37                 ;If not, skip the writing part
  CALL WriteItSI           ;Write the String
S37:                       ;Done writing
  XOR  BX,BX               ;Assume Table has no Offset
  TEST CL,TblFlagHasOffset ;Does the Table Have an Offset?
  JZ  >S80                 ;If not, we're done
  CALL SkipOverStringSI    ;If so, skip over the String
  MOV  BX,[SI]             ;Put the Offset in BX
  JMP >S80                 ;Done
S40:                       ;Not a match
  CALL SkipOverStringSI    ;Skip over the String
  TEST CL,TblFlagHasOffset ;Does the Table have an Offset?
  JZ  >S50                 ;If not, continue
  INC  SI,2                ;If so, skip over the Offset
S50:                       ;Done testing this Table Entry
  JMP  S10                 ;Keep looking
S70:                       ;Error
  XOR  BX,BX               ;Set return Flag
  STC                      ;Set error flag
  JMP >S90                 ;Done
S80:                       ;OK
  CLC                      ;Set OK Flag
S90:                       ;Done
  POP  SI,DX,CX,AX         ;Restore used registers
  POP  BP                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE AN ENTIRE STRING OR STRING-AND-CODE TABLE TO THE SCREEN, POSS W/ SUBTABLES
;Inputs:  [BX] = Table To Write
;         CL   = Maximum number of SubTables to write (0 = No Subs, etc.)
;                (If WriteTblAndSubs)
;Outputs: Writes Entire Table to Screen, possibly with the SubTables Also
;Changes: Indent
;------------------------------------------------------------------------------
WriteTblAndSubs:
  PUSH CX                  ;Save used registers
;  JMP >W00                 ;Do it
;WriteTbl:
;  PUSH CX                  ;Save used registers
;  XOR  CL,CL               ;Mark as not needing to write SubTables
;;  JMP >W00                 ;Do it
;W00:
  PUSH AX,BX,DX,SI         ;Save used registers
  MOV  CH,[BX]             ;Save Table Flags
  MOV  SI,BX               ;Point SI at
  INC  SI                  ;  the Table
W10:                       ;Loop to here for each Table Entry
  MOV  DH,4                ;Amount to Increase Indent
  TEST CH,TblFlagWord      ;Doing a Word?
  JNZ >W20                 ;If so, handle it
  LODSB                    ;Get next Table Entry
  OR   AL,AL               ;End of Table?
  JNZ >W15                 ;If not, continue
  CMP  B [SI],-1           ;End of table?
  JE  >W90                 ;If so, Quit
W15:                       ;Valid Table Entry
  CALL DoIndent            ;Handle the Indent
  CALL WriteByteHex        ;Write the Table Value
  JMP >W30                 ;Continue
W20:                       ;Do a Word
  ADD  DH,2                ;Increase Indent some more
  LODSW                    ;Get next Table Entry
  OR   AX,AX               ;End of Table?
  JNZ >W25                 ;If not, continue
  CMP  B [SI],-1           ;End of table?
  JE  >W90                 ;If so, Quit
W25:                       ;Valid Table Entry
  CALL DoIndent            ;Handle the Indent
  CALL WriteWordHex        ;Write the Table Value
W30:                       ;Done writing Index
  CALL WriteHexEnd         ;Write the 'h'
  CALL WriteSpace          ;Write a Space
  CALL WriteItSI           ;Write the String
  CALL SkipOverStringSI    ;Skip over the String
  TEST CH,TblFlagHasOffset ;Does the Table have an Offset?
  JZ  >W40                 ;If not, continue
  INC  SI,2                ;If so, skip over the Offset
  OR   CL,CL               ;Do we need to write the Offset Table?
  JZ  >W40                 ;If not, continue
  CMP  W [SI-2],0          ;Is it a vlaid Index?
  JE  >W40                 ;If not, we're done
  CALL WriteCrLf           ;If so, start a new line
  PUSH BX                  ;Save used registers
  MOV  BX,[SI-2]           ;Point at the SubTable
  ADD  Indent,DH           ;Add in the appropriate Indent
  DEC  CL                  ;Decrement SubTable Counter
  CALL WriteTblAndSubs     ;Write the SubTable, and it's SubTables
  INC  CL                  ;Increment SubTable Counter
  SUB  Indent,DH           ;Restore the original Indent
  POP  BX                  ;Restore used registers
  JMP >W45                 ;Go to next Entry
W40:                       ;Done with this Table Entry
  CALL WriteCrLf           ;Start a new line
W45:                       ;Keep going, no new Line
  JMP  W10                 ;Keep going
W90:                       ;Done
  POP  SI,DX,BX,AX         ;Restore used registers
  POP  CX                  ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE NEEDED TO PRINT VARIOUS TABLES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE A "GENERAL" PRINT TABLE SWITCH (PRINT SUBTABLES)
;Inputs:  [BX] = Starting Table to Search/Write
;         CL = Maximum Number of SubTables to Search/Write
;              0 = No SubTables, 1 = Table + 1 SubTable, etc.
;         [SI] = Command Line (Parameter) Pointer
;Outputs: Writes appropriate things to the screen
;Changes: SI
;------------------------------------------------------------------------------
DoSwitchGeneral:
  PUSH AX,BX,CX,DX       ;Save used registers
  OR   BX,BX             ;Valid Table Offset?
  JZ  >G30               ;If not, just write the number and quit
  MOV  CH,[BX]           ;Get the Table characteristics
  CALL GetCallBackAddr   ;Look for a Call-Back Address
  JNC >G60               ;If found (no regular parameter provided), handle it
  CALL GetNumber         ;If not found, look for a Parameter (AX)
  JNC >G05               ;If found, continue
  CALL IsSpaceOrEOL      ;If not, anything else on the command-line?
  JNZ >G70               ;If so, error
  JMP >G60               ;If not, write the whole table
G05:                     ;We have a number
  OR   CL,CL             ;Is this the last (Sub)Table to Handle?
  JNZ >G40               ;If not, handle it
  CALL GetCallBackAddr   ;If so, look for a Call-back address
  JNC >G10               ;If found, continue
  CALL IsSpaceOrEOL      ;If not found, anything else on the command-line?
  JNZ >G70               ;If so, error
G10:                     ;We have a single parameter to write
  PUSH BX                ;If so, save the Table Pointer
  CALL SearchTblNoWrite  ;See if it's in the Table
  POP  BX                ;Restore the Table Pointer
  JC  >G30               ;If no match, Handle it
G20:                     ;Is a match
  CALL WriteWordEquals   ;Write the number and equals (if at Command Line)
  CALL SearchTblWrite    ;Write the Description
  JMP >G90               ;Done
G30:                     ;No match in the Table
  CALL WriteWordUnknownX ;Write the number followed by " = Unknown!"
  JMP >G90               ;Done
G40:                     ;Have valid Parameter, but not at end of SubTables
  CALL SearchTblNoWrite  ;Look for a match in the Table (returns [BX])
  JNC >G80               ;If OK, Look in the SubTable
G50:                     ;Loop to here to find the last Parameter
  DEC  CL                ;Decrement the SubTable Counter
  CALL GetNumber         ;Get the next Parameter
  JC  >G90               ;If error, we're done
  OR   CL,CL             ;Is this the last Parameter we need?
  JNZ  G50               ;If not, keep looking
  CALL WriteWordUnknownX ;Write the number followed by " = Unknown!"
  JMP >G90               ;Done
G60:                     ;Invalid (empty) Parameter
  CALL WriteTblAndSubs   ;Write all Tables and SubTables
  JMP >G90               ;Done
G70:                     ;Error
  MOV  ParseError,Yes    ;Mark as an Error
  JMP >G90               ;Done
G80:                     ;Go to the SubTable
  DEC  CL                ;Decrement SubTable Level
  CALL DoSwitchGeneral   ;Handle the SubTable
G90:                     ;Done
  POP  DX,CX,BX,AX       ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO TEST THE COMPUTER FOR MINIMUM COMPATIBILITY (DOS VERSION, ETC)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST THE COMPUTER TO SEE IF IT'S COMPATIBLE (CPU, DOS VERSION, WHATEVER)
;Inputs:  InMemory
;Outputs: Quits the program if Computer is Incompatible
;         Returns if Computer is OK
;         Stores all kinds of values in memory variables
;Changes:
;------------------------------------------------------------------------------
TestCompatibility:
  PUSH AX,DX          ;Save used registers
  MOV  AL,ErLvlDOSVer ;Assume incorrect
  MOV  DX,DOSVerMsg   ;  DOS Version
  CALL TestDOSVer     ;  new enough?
  JC  >C70            ;If not, quit
  MOV  AL,ErLvlNo386  ;Assume CPU is
  MOV  DX,No386Msg    ;  not 386+
  CALL Test80386      ;Is the CPU at least an 80386?
  JNC >C90            ;If not, quit
C70:                  ;The computer is incompatible for some reason
  JMP  Exit           ;Quit!
C90:                  ;The computer is compatible!
  POP  DX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST THE CURRENT DOS VERSION
;Inputs:  MinDOSVer (EQUate)
;Outputs: CF = Clear if DOS version >= MinDOSVer
;         CF = Set if DOS version < MinDOSVer
;Changes:
;------------------------------------------------------------------------------
TestDOSVer:
  PUSH AX,BX,CX     ;Save used registers
  MOV  AX,3000h     ;Service 30h (get DOS version number)
                    ;  DOS 5.0 requires AL = 00h, may change BX and CX
  INT  21h          ;Do it (Returns AL= Major, AH = Minor)
  XCHG AL,AH        ;Swap Major and Minor versions for testing
  CMP  AX,MinDOSVer ;Is the version new enough?
  JAE >D80          ;If so, it's OK
D70:                ;DOS is older than the minimum
  STC               ;Set the "too old" flag
  JMP >D90          ;We're done
D80:                ;DOS is >= the minimum
  CLC               ;Set the OK flag
D90:                ;We're done
  POP  CX,BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THE CPU IS AN 80386+ (CAN HANDLE 32-BIT INSTRUCTIONS)
;Inputs:
;Outputs: CF = Clear if the CPU is an 80386+
;            = Set if CPU is not an 80386+
;Changes:
;------------------------------------------------------------------------------
Test80386:
  PUSH AX,BX     ;Save used registers
  PUSHF          ;Save flags
  CALL Test8086  ;Is it an 8086?
  JNC >E70       ;If so, it can't be an 80386
  MOV  BX,0F000h ;Flags mask for testing (these bits always clear on 80286)
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  OR   AX,BX     ;Try to set the
  PUSH AX        ;  four high bits
  POPF           ;  of the flags
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  TEST AX,BX     ;Are any of the four high bits set?
  JNZ >E80       ;If so, it's not an 80286 - it must be an 80386+
E70:             ;It's not an 80386
  POPF           ;Restore flags
  STC            ;Set the not 80386 flag
  JMP >E90       ;We're done
E80:             ;It is an 80386
  POPF           ;Restore flags
  CLC            ;Set the 80386 flag
E90:             ;We're done
  POP  BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THE CPU IS AN 8086/8088
;Inputs:
;Outputs: CF = Clear if the CPU is an 8086/8088
;            = Set if not at 8086/8088
;Changes:
;NOTE: Unlike the other CPU tests, this is not a "greater than or equal to".
;      The CPU must be EXACTLY an 8086/8088, or this returns with CF set.
;------------------------------------------------------------------------------
Test8086:
  PUSH AX,BX     ;Save used registers
  PUSHF          ;Save flags
  MOV  BX,0F000h ;Flags mask for testing (these bits always set on 8086/8088)
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  AND  AX,0FFFh  ;Try to clear the
  PUSH AX        ;  four high bits
  POPF           ;  of the flags
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  AND  AX,BX     ;Are the four high bits
  CMP  AX,BX     ;  of the flags set?
  JE  >E80       ;If so, it's an 8086/8088
  POPF           ;Restore flags
E70:             ;It is not an 8086/8088
  STC            ;Set the not 8086/8088 flag
  JMP >E90       ;We're done
E80:             ;It is an 8086/8088
  POPF           ;Restore flags
  CLC            ;Set the 8086/8088 flag
E90:             ;We're done
  POP  BX,AX     ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO SET UP COMMAND TAIL WITH PROPER PARAMETERS FOR EXEC CALL
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE A SEGMENT:OFFSET COMBINATION TO A STRING VARIABLE
;Inputs:   AX  = Segment to Write
;          CX  = Offset to Write
;         [BX] = String to Write to
;Outputs: Converts AX:CX to a Hex String and stores at [BX]
;Changes:
;------------------------------------------------------------------------------
CopySegmentOffset:
  PUSH AX,DI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at Local Data Area
  MOV  DI,BX          ;Point DI at String
  CALL Word2HexString ;Store the Segment
  MOV  AL,':'         ;Store the
  STOSB               ;  Colon
  MOV  AX,CX          ;Store
  CALL Word2HexString ;  the Offset
  POP  ES,DI,AX       ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO WRITE STRINGS AND NUMBERS TO THE SCREEN
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE A BYTE OR WORD IN HEX, FOLLOWED BY " = Unknown!"
;Inputs:  AL, AX = Byte/Word to Write
;         ParentIsShell
;Outputs: If ParentIsShell = Yes, writes number followed by " = Unknown"
;         If ParentIsShell = No,  just writes "Unknown!"
;Changes:
;------------------------------------------------------------------------------
WriteWordUnknownX:
  CALL WriteWordEquals ;Write number and equals (if at command-line)
  CALL WriteUnknownX   ;Write "Unknown!"
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE OR WORD IN HEX, FOLLOWED BY " = "
;Inputs:  AL, AX = Byte/Word to Write
;         ParentIsShell
;Outputs: Writes to Screen if ParentIsShell = Yes
;         Does nothing if ParentIsShell = No
;Changes:
;------------------------------------------------------------------------------
WriteWordEquals:
  CMP  ParentIsShell,Yes ;Are we at the Command-line?
  JNE >Q90               ;If not, don't write it
  CALL WriteWordMinHex   ;Write the byte/word in hex
  CALL WriteSpace        ;Move over
  CALL WriteEqualsSpace  ;Write "= "
Q90:                     ;Done
  RET

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF A WORD OR DWORD IN THE MINIMUM SPACE POSSIBLE (AS HEX)
;Inputs:  AL/AX/EAX = Byte/Word/DWord to Write
;Outputs: Writes to Screen
;Changes:
;NOTES: This writes a Byte, Word, or DWord, whichever is appropriate
;------------------------------------------------------------------------------
WriteDWordMinHex:
  CMP  EAX,0FFFFh    ;More than a Word can handle?
  JA  >M40           ;If so, write the DWord
WriteWordMinHex:
  CMP  EAX,0FFh      ;More than a Byte can handle?
  JA  >M20           ;If so, jump to handle more than a byte
  CALL WriteByteHex  ;Write the Byte
  JMP >M90           ;Done
M20:                 ;More than a Byte
  CALL WriteWordHex  ;Write the Word
  JMP >M90           ;Done
M40:                 ;More than a Word
  CALL WriteDWordHex ;Write the DWord
M90:                 ;Done
  CALL WriteHexEnd   ;Write the 'h'
  RET

;------------------------------------------------------------------------------
;CONVERT BYTE, WORD, OR DWORD TO HEX CHARACTER STRING, AND WRITE IT
;Inputs:  AL/AX = Nibble/Byte/Word to be written
;         CLD must be set already!
;Outputs: Writes to the Screen
;Changes: HexString
;------------------------------------------------------------------------------
;WriteNibbleHex:
;  PUSH BX             ;Save used registers
;  MOV  BX,8           ;Need to start of offset 8 in string
;  JMP >H00            ;Jump to do it
WriteByteHex:
  PUSH BX             ;Save used registers
  MOV  BX,7           ;Need to start of offset 7 in string
  JMP >H00            ;Jump to do it
WriteWordHex:
  PUSH BX             ;Save used registers
  MOV  BX,5           ;Need to start of offset 5 in string
  JMP >H00            ;Jump to do it
WriteDWordHex:
  PUSH BX             ;Save used registers
  XOR  BX,BX          ;Need to start of offset 0 in string
;  JMP >H00            ;Jump to do it
H00:                  ;Start converting the strings
  PUSH DX,DI          ;Save used registers
  MOV  DI,HexString   ;Point DS:[DI] at HexString
  MOV  DX,DI          ;Point DS:[DX] at HexString
  ROR  EAX,16         ;Convert the High Word
  CALL Word2HexString ;  to a String
  INC  DI             ;Skip over the Underscore
  ROR  EAX,16         ;Convert the Low Word
  CALL Word2HexString ;  to a String
  ADD  DX,BX          ;Point DX at the beginning of where we write
  CALL WriteItDX      ;Write it
  POP  DI,DX          ;Restore used registers
  POP  BX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A BYTE OR WORD TO A HEXADECIMAL STRING (2 OR 4 CHARACTERS)
;Inputs:  AX = Word to Convert to a Hex String
;         DS = Local Data Area
;         CLD already issued
;Outputs: DS:[DI]
;Changes: DI
;------------------------------------------------------------------------------
Word2HexString:
  PUSH AX,BX,ES         ;Save used registers
  MOV  BX,AX            ;Save original Word
  MOV  ES,DS            ;Point ES:[DI] at
  CALL Word2HexString00 ;Convert it
  POP  ES,BX,AX         ;Restore used registers
  RET

Word2HexString00:
  MOV  AL,BH            ;Convert High Byte
  CALL Word2HexString10 ;  to ASCII
  MOV  AL,BL            ;Work with Low Byte
Word2HexString10:       ;Convert Byte to ASCII
  AAM  10h              ;Separate Low & High Nibbles
  XCHG AH,AL            ;Put High Nibble in AL
  CALL Word2HexString20 ;Convert High Nibble to ASCII
  XCHG AH,AL            ;Work with Low Nibble
Word2HexString20:       ;Convert Nibble to ASCII
  ADD  AL,90h           ;Convert BCD
  DAA                   ;  to Decimal
  ADC  AL,40h           ;Convert Decimal
  DAA                   ;  to ASCII
  STOSB                 ;Store the Nibble
  RET

;Byte2HexString:
;  PUSH AX,ES            ;Save used registers
;  MOV  ES,DS            ;Point ES:[DI] at the String
;  CALL Word2HexString10 ;Convert it
;  POP  ES,AX            ;Restore used registers
;  RET

;------------------------------------------------------------------------------
;WRITE A NIBBLE/BYTE/WORD/DWORD AS AN INTEGER TO THE SCREEN
;Inputs:  AL/AX/EAX = Nibble/Byte/Word/DWORD to write
;Outputs: Writes to Con
;Changes:
;------------------------------------------------------------------------------
WriteNibbleInteger:
  PUSH EAX           ;Save used registers
  TEST AL,08h        ;Negative number?
  JZ  >B00           ;If not, continue
  OR   AL,0F0h       ;If so, make the entire byte negative
  JMP >B00           ;Continue
WriteByteInteger:
  PUSH EAX           ;Save used registers
B00:
  CBW                ;Sign-extend Byte to Word
  JMP >O00           ;Continue
WriteWordInteger:
  PUSH EAX           ;Save used registers
O00:
  CWDE               ;Sign-extend Word to DWord
  JMP >I00           ;Continue
WriteDWordInteger:
  PUSH EAX           ;Save used registers
I00:
  OR   EAX,EAX       ;Is it Zero or Negative?
  JZ  >I40           ;If zero, don't write anything
  JS  >I20           ;If negative, jump to handle it
  CALL WritePlus     ;Write a Plus Sign
  JMP >I40           ;Continue
I20:                 ;Is negative
  CALL WriteMinus    ;Write a minus sign
  NOT  EAX           ;Convert it
  INC  EAX           ;  to a positive number
I40:                 ;Have negativity accounted for
  CALL WriteDWordMin ;Write the Number
  POP  EAX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE/WORD/DWORD TO THE SCREEN AS A DECIMAL
;Inputs:  AL/AX/EAX = Byte/Word/DWord to Write
;Outputs:
;Changes:
;NOTES: If ByteToString, WordToString, or DWordToString, fills front
;         of string with spaces, and does NOT include any commas.
;       If WriteByteMin, WriteWordMin, or WriteDWordMin, does NOT
;         include spaces at front, and includes comma separators
;------------------------------------------------------------------------------
WriteByteMin:
  PUSH EAX,BX                ;Save used registers
  XOR  AH,AH                 ;Make sure high byte is 0
  JMP >O00                   ;Continue
WriteWordMin:
  PUSH EAX,BX                ;Save used registers
O00:
  AND  EAX,0000_FFFFh        ;Make sure High Word is 0
  JMP >D00                   ;Continue
WriteDWordMin:
  PUSH EAX,BX                ;Save used registers
D00:
  MOV  BH,WriteByteMinFlag   ;Mark as doing minimum
  JMP >W00                   ;Do it

ByteToString:
  PUSH EAX,BX                ;Save used registers
  XOR  AH,AH                 ;Make sure high byte is 0
  XOR  BH,BH                 ;BH = No Minimum, Byte
;  JMP >O01                   ;Continue
;WordToString:
;  PUSH EAX,BX                ;Save used registers
;  MOV  BH,WriteByteWordFlag  ;BH = No Minimum, Word
O01:
  AND  EAX,0000_FFFFh        ;Make sure High Word is 0
;  JMP >D01                   ;Continue
;DWordToString:
;  PUSH EAX,BX                ;Save used registers
;  MOV  BH,WriteByteDWordFlag ;BH = No Minimum, DWord
D01:
W00:                         ;Do a word or a byte
  PUSH ECX,EDX,SI            ;Save used registers
  MOV  SI,SingleMsg          ;Point at the single character message
  XOR  BL,BL                 ;Test for first non-zero character is false
  MOV  ECX,1000000000        ;First divisor is 1,000,000,000
W20:                         ;Loop to here for each character
  XOR  EDX,EDX               ;High word of Dividend = 0
  DIV  ECX                   ;Divide EDX:EAX by current divisor
  OR   EAX,EAX               ;Is this a non-zero character?
  JNZ >W30                   ;If so, we need to write it
  OR   BL,BL                 ;Has there already been a non-zero character?
  JNZ >W30                   ;If so, we need to write it
  CMP  ECX,1                 ;Is this the last character?
  JE  >W30                   ;If so, we need to write it
  TEST BH,WriteByteMinFlag   ;Are we doing a minimum?
  JNZ >W40                   ;If not, don't write anything
  MOV  AL,' '                ;Assume a space
  TEST BH,WriteByteDWordFlag ;Writing a DWord?
  JNZ >W35                   ;If so, write the space
  TEST BH,WriteByteWordFlag  ;Doing a Word?
  JZ  >W25                   ;If not, handle a Byte
  CMP  ECX,10000             ;If so, doing the ten-thousands character?
  JBE >W35                   ;If so, write the space
  JMP >W40                   ;If not, don't write anything
W25:                         ;Doing a Byte
  CMP  ECX,100               ;Doing the hundreds character?
  JBE >W35                   ;If so, write the space
  JMP >W40                   ;If not, don't write anything
W30:                         ;We need to write this character
  INC  BL                    ;Test for first non-zero character is true
  ADD  AL,'0'                ;Convert the Number to ASCII
W35:                         ;Write the character
  MOV  [SI],AL               ;Write the
  CALL WriteItSI             ;  character
  CMP  AL,' '                ;Should we write a comma or a space?
  JE  >W36                   ;If a space, continue
  MOV  AL,','                ;If not, mark as a comma
W36:                         ;AL contains space or Comma
  MOV  [SI],AL               ;Store it in the String
  CMP  ECX,1000000000        ;Need to write the space or comma?
  JE  >W38                   ;If so, jump to write it
  CMP  ECX,1000000           ;Need to write the space or comma?
  JE  >W38                   ;If so, jump to write it
  CMP  ECX,1000              ;Need to write the space or comma?
  JNE >W40                   ;If not, continue
W38:                         ;Need to write a Space or Comma Separator
  CALL WriteItSI             ;Write the space or Comma
W40:                         ;Done writing the Character
  CMP  ECX,1                 ;Was this the last division to do?
  JE  >W90                   ;If so, we're done
  MOV  EAX,EDX               ;If not, start next loop with remainder of division
  PUSH EAX                   ;Save register for a second
  XOR  EDX,EDX               ;So dividend won't be messed up
  MOV  EAX,ECX               ;Want to divide divisor in ECX
  MOV  ECX,10                ;Want to divide by 10
  DIV  ECX                   ;Divide it
  MOV  ECX,EAX               ;Store it back in ECX
  POP  EAX                   ;Restore register
  JMP  W20                   ;And do it again
W90:                         ;We're done
  POP  SI,EDX,ECX            ;Restore used registers
  POP  BX,EAX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DO THE APPROPRIATE INDENTATION
;Inputs:  DS:Indent = Number of Spaces to Indent
;Outputs: Writes an appropriate number of spaces to the screen
;Changes:
;------------------------------------------------------------------------------
DoIndent:
  PUSH CX          ;Save used registers
  MOV  CL,Indent   ;Write the
  CALL WriteSpaces ;  Indent Spaces
  POP  CX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE SOME SPACES TO THE SCREEN
;Inputs:  CL = Number of spaces to write
;         SpaceMsg
;Outputs: To the screen
;Changes:
;------------------------------------------------------------------------------
WriteSpaces:
  PUSH CX,DX       ;Save used registers
  OR   CL,CL       ;Should we write 0 spaces?
  JZ  >S90         ;If so, we're done
  XOR  CH,CH       ;If OK, change it to a word
  MOV  DX,SpaceMsg ;Point at the message
S10:               ;Loop to here for each space
  CALL WriteItDX   ;Write the space
  LOOP S10         ;Keep going until we're done
S90:               ;We're done
  POP  DX,CX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A SPECIFIC CHARACTER OR SET OF CHARACTERS TO THE SCREEN
;Inputs:
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
WriteBlock:
  PUSH DX                ;Save used registers
  MOV  DL,'±'            ;Write a Block Character
  JMP >C00               ;Do it
WriteColon:
  PUSH DX                ;Save used registers
  MOV  DL,':'            ;Write a Colon
  JMP >C00               ;Do it
WriteCommaSpace:
  PUSH DX                ;Save used registers
  MOV  DX,CommaSpaceMsg  ;Point at Message
  JMP >C10               ;Do it
WriteCrLf:
  PUSH DX                ;Save used registers
  MOV  DX,CrLfMsg        ;Point at Message
  JMP >C10               ;Do it
WriteHexEnd:
  PUSH DX                ;Save used registers
  MOV  DL,'h'            ;Write an h
  JMP >C00               ;Do it
WriteMinus:
  PUSH DX                ;Save used registers
  MOV  DL,'-'            ;Write a Minus
  JMP >C00               ;Do it
WritePlus:
  PUSH DX                ;Save used registers
  MOV  DL,'+'            ;Write a Plus
  JMP >C00               ;Do it
WriteQuestion:
  PUSH DX                ;Save used registers
  MOV  DL,'?'            ;Write a ?
  JMP >C00               ;Do it
WriteEqualsSpace:
  PUSH DX                ;Save used registers
  MOV  DX,EqualsSpaceMsg ;Point at Message
  JMP >C10               ;Do it
WriteSpace:
  PUSH DX                ;Save used registers
  MOV  DX,SpaceMsg       ;Point at Message
  JMP >C10               ;Do it
Write2Spaces:
  PUSH DX                ;Save used registers
  MOV  DX,Space2Msg      ;Point at Message
  JMP >C10               ;Do it
Write3Spaces:
  PUSH DX                ;Save used registers
  MOV  DX,Space3Msg      ;Point at Message
  JMP >C10               ;Do it
WriteUnknownX:
  PUSH DX                ;Save used registers
  MOV  DX,UnknownXMsg    ;Point at Message
  JMP >C10               ;Do it
C00:
  MOV  SingleMsg[0],DL   ;Put the character in the Single Character String
  MOV  DX,SingleMsg      ;Point at Single Character String
C10:                     ;DX is pointed at String
  CALL WriteItDX         ;Write the String
  POP  DX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ASCIIZ STRING TO CON OR TO ERR
;Inputs:  DS:[DX] = Pointer to string
;         CS = Local Data Area
;Outputs: Writes the string to CON or ERR
;Changes:
;------------------------------------------------------------------------------
WriteZCon:                  ;Write to CON
  CMP  CS:PauseHeaderPtr,-1 ;Should we write anything?
  JE  >Z90                  ;If not, just quit
  PUSH BX                   ;Save used register
  MOV  BX,StdOutHandle      ;Write to STDOUT
  JMP >Z00                  ;Jump to do it
WriteZErr:                  ;Write to ERR
  PUSH BX                   ;Save used register
  MOV  BX,StdErrHandle      ;Write to STDERR
Z00:
  PUSH AX,CX                ;Save used registers
  CALL CalcStrSizeDX        ;Calculate the size of the string (returns CX)
  JZ  >Z80                  ;If nothing to write, just quit
  MOV  AH,40h               ;Function 40h (Write to Device)
  INT  21h                  ;Do it
Z80:                        ;We're done
  POP  CX,AX                ;Restore used registers
  POP  BX                   ;Restore used register
Z90:                        ;We're done
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LENGTH OF AN ASCIIZ STRING
;Inputs:  DS:[SI] = ASCIIZ String to wrok with
;Outputs: CX = Length of String
;         ZF = Set if string is 0 length
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
CalcStrSizeSI:
  PUSH DX            ;Save used registers
  MOV  DX,SI         ;Calculate the
  CALL CalcStrSizeDX ;  length of the string
  POP  DX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LENGTH OF AN ASCIIZ STRING
;Inputs:  DS:[DX] = Pointer to the string
;Outputs: CX = Length of the string
;         ZF = Set if string is 0 length
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
CalcStrSizeDX:
  PUSH AX,DI  ;Save used registers
  PUSH ES     ;Save used registers
  MOV  ES,DS  ;Point ES:[DI]
  MOV  DI,DX  ; at the string
  XOR  AL,AL  ;Look for a 0
  MOV  CX,-1  ;Start with max count for REPNE
  REPNE SCASB ;Find the end of the string
  NOT  CX     ;Calculate the size
  DEC  CX     ;  of the string (sets ZF)
  POP  ES     ;Restore used registers
  POP  DI,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP TO THE END OF AN ASCIIZ STRING
;Inputs:  DS:[SI] = ASCIIZ String to Skip Over
;Outputs: [SI]    = Next Byte After String
;Changes:
;------------------------------------------------------------------------------
SkipOverStringSI:
  PUSH CX,DX         ;Save used registers
  MOV  DX,SI         ;Calculate the size
  CALL CalcStrSizeDX ;  of the string (CX, does not include the Zero)
  INC  CX            ;Compensate for the Zero
  ADD  SI,CX         ;Add it to the Pointer
  POP  DX,CX         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO WRITE OUR OUTPUT, EITHER TO PAUSE OR TO THE USER-PROVIDED ADDRESS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE AN ASCIIZ STRING POINTED AT BY DS:[SI], THEN SKIP OVER THE STRING
;Inputs:  DS:[SI] = ASCIIZ String to Write
;Outputs: To Pause or to user-provided Code Address
;         [SI] points to next character after the string
;Changes:
;------------------------------------------------------------------------------
WriteItSISkip:
  CALL WriteItSI        ;Write the string
  CALL SkipOverStringSI ;Skip over the string
  RET

;------------------------------------------------------------------------------
;WRITE AN ASCIIZ STRING, POINTED AT BY SI, TO PAUSE OR TO PROVIDED CALL-BACK
;Inputs:  DS:[SI] = ASCIIZ String to Write
;Outputs: To Pause or to user-provided Code Address
;Changes:
;------------------------------------------------------------------------------
WriteItSI:
  PUSH DX        ;Save used registers
  MOV  DX,SI     ;Write the
  CALL WriteItDX ;  string
  POP  DX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE OUR OUTPUT TO PAUSE, OR TO THE PROVIDED CALL-BACK ADDRESS
;Inputs:  DS:[DX] = ASCIIZ String to Write
;         CalloBackAddr (-1 in Offset if invalid)
;Outputs: Either to Pause, or to the call-back address
;Changes:
;------------------------------------------------------------------------------
WriteItDX:
  CMP  W CallBackAddr[0],-1 ;Is there a valid call-back address?
  JE  >W50                  ;If not, write to Pause
  CMP  ParentIsShell,Yes    ;Double-check whether we are at a command-line
                            ;  (we shouldn't need to do this, but will anyway)
  JE  >W50                  ;If so, write to Pause
  PUSH AX,BX,CX,DX,DI,SI    ;Save
  PUSH BP,DS,ES             ;  all registers
  CALL D CallBackAddr       ;If not, call the provided code address
  POP  ES,DS,BP             ;Restore
  POp  SI,DI,DX,CX,BX,AX    ;  all registers
  JMP >W90                  ;Done
W50:                        ;Write to Pause
  CALL WriteZPause          ;Write to Pause
W90:                        ;Done
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED TO SET UP AND DO SCREEN PAUSES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SETUP PARAMETERS FOR DOING A SCREEN PAUSE (FOR PRINTING A LARGE TABLE)
;Inputs:  DS = Local Data Area
;         DS:[DX] = ASCIIZ Header to Print at top of each screen
;                   Last character of the Header MUST be an LF
;                   If SetupPauseNoHdr, we "inject" NoMsg as the Header
;Outputs: Pauses the screen with a MORE message every time it gets full
;NOTES:   If a Screen Header is really large (almost taking up the whole
;           screen itself, with little room for data), this procedure
;           may not work correctly.  This procedure does not validate
;           the size of the Header -- it simply assumes that it is a
;           "reasonable" size compared to the size of the screen.  Most
;           anything that needs a Screen Header (a long data table) will
;           only have a few lines of Header, so this should be OK as a
;           general purpose procedure.
;         After this Setup is complete (which should be near the beginning
;           of MAIN, before anything is sent to the screen), WriteZPause
;           must be called for ALL screen writing to CON:, not WriteZCon!
;         The Pausing occurs in "real time", meaning we can send things
;           to the Pause routine a byte, line, or several screens at a
;           time for processing.  Because we do it in "real time",
;           we can end up with extra MORE's and screen Headers appearing
;           on screen than are actually needed.  During a screen
;           transition (or a transition to a new Header) whether we
;           actually need to write anything or not depends on if there
;           is actually any real data coming afterward (in time), which
;           of course we don't know (since it hasn't happened yet).
;           So, we must assume there is more data to come and process the
;           MORE's and Screen Headers accordingly.  This only causes problems
;           (in the form of extraneous MORE's and Screen Headers)
;           when things happen near the bottom of the screen.
;           DOS's MORE utiltiy (and other programs of similar ilk) do not
;           process in "real time", but rather store things in a Temporary
;           File and then process the file.
;------------------------------------------------------------------------------
SetupPauseNoHdr:
  PUSH DX         ;Save used registers
  MOV  DX,NoMsg   ;Point at 0-length Message
  CALL SetupPause ;Setup the Pause
  POP  DX         ;Restore used registers
  RET

SetupPause:
  PUSH AX,BX,CX,DI,SI     ;Save used registers
  MOV  SI,OFFSET PauseHeaderPtr ;Point [SI] at PauseHeaderPtr
  CMP  W [SI],-1          ;Has the user already cancelled us?
  JE  >S90                ;If so, just quit
  CMP  W [SI],0           ;Has the user stopped pausing already?
  JE  >S85                ;If so, just write the header
  CALL TestRedir          ;Is our output redirected?
  JNC >S10                ;If not, setup our Headers
  MOV  W [SI],0           ;Mark as Redirected or Pausing Stopped/Disabled
  JMP >S85                ;Jump to write the Header and Quit
S10:                      ;Output not redirected
  CALL GetScreenRows      ;Store the number of rows
  MOV  PauseRows,AX       ;  on the screen
  CALL CountZLinesCX      ;Calculate the number of lines
  INC  CX,2               ;  in the new Header
  MOV  DI,PauseRowCount   ;Get the Current Row count
  ADD  DI,CX              ;Add the size of the new header
  SUB  DI,3               ;Adjust for Headers
  DEC  AX                 ;Will writing the new Header
  CMP  DI,AX              ;  cause a Pause event?
  JB  >S50                ;If not, handle it
S20:                      ;New Header is too big to fit on screen
  MOV  W [SI],NoMsg       ;Point Header for second page at nothing
  MOV  PauseHeaderSize,2  ;Set Pause Header Size
  PUSH CX                 ;Save New Header Size
  SUB  AX,PauseRowCount   ;Calculate how many rows to fill up the screen
  MOV  CX,AX              ;Put number of rows in CX
  INC  CX                 ;Adjust it
S30:                      ;Loop to here to fill up the screen
  CALL WriteCrLf          ;Write a new line
  LOOP S30                ;Keep going until we're done
  POP  CX                 ;Restore New Header Size
  CMP  W [SI],-1          ;Did the user cancel during the header transition?
  JE  >S90                ;If so, we're done
  CMP  W [SI],0           ;Did the user stop Pausing during the transition?
  JE  >S85                ;If so, just write the Header
S50:                      ;Need to adjust current Row Count
  SUB  PauseRowCount,2    ;Adjust things for the previous Header
S80:                      ;Store new Header Info
  MOV  [SI],DX            ;Store the Header Address
  MOV  PauseHeaderSize,CX ;Store the Header Size
  ADD  PauseRowCount,CX   ;Add the Header Size to the Row Count
  MOV  AX,PauseRows       ;Compensate if
  CMP  AX,PauseRowCount   ;  the new header
  JAE >S85                ;  put us past
  DEC  AX                 ;  the end
  MOV  PauseRowCount,AX   ;  of hte screen
S85:                      ;Write Header
  CALL WriteZCon          ;Write the Header
S90:                      ;We're done
  POP  SI,DI,CX,BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHECK TO SEE IF STDOUT HAS BEEN REDIRECTED
;Inputs:
;Outputs: CF = Clear if STDOUT is normal (usually the screen)
;            = Set if STDOUT been redirected
;Changes:
;------------------------------------------------------------------------------
TestRedir:
  PUSH AX,BX,DX        ;Save used registers
  MOV  AX,4400h        ;Function 4400h (Get Device Info)
  MOV  BX,StdOutHandle ;Device = STDOUT
  INT  21h             ;Do it (returns DX, changes AX)
  JC  >R80             ;If error, assume not Redirected
  AND  DL,(DvcInfoIsDevice+DvcInfoIsStdOut) ;Mask out unwanted bits
  CMP  DL,(DvcInfoIsDevice+DvcInfoIsStdOut) ;Is it still the STDOUT Device?
  JE  >R80             ;If so, it's not Redirected
R70:                   ;STDOUT has been Redirected
  STC                  ;Set the Redirected flag
  JMP >R90             ;Done
R80:                   ;STDOUT is not Redirected
  CLC                  ;Set the Not-Redirected flag
R90:                   ;Done
  POP  DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NUMBER OF VIDEO ROWS ON THE SCREEN
;Inputs:
;Outputs: AX = Number of text rows on the screen
;                (usually 25, 43, or 50)
;Changes:
;------------------------------------------------------------------------------
GetScreenRows:
  PUSH BX,CX,DS  ;Save used registers
  MOV  AX,40h    ;Point ES to
  MOV  DS,AX     ;  BIOS data area
  MOV  AH,12h    ;Function 12h (EGA Alternate Select)
  MOV  BX,0FF10h ;Subfunction (BL) 10h (Return EGA information)
                 ;  Preset unrealistic return value (BH)
  INT  10h       ;Do it (returns AX, BX, CX)
  CMP  BL,10h    ;Is the function supported (EGA or better)?
  JE  >R50       ;If not, jump to handle MDA/CGA
  CMP  BH,0FFh   ;Is the return value valid?
  JE  >R50       ;If not, jump to handle MDA/CGA
  TEST B [87h],8 ;If so, is bit 3 of the EGA information byte set?
  JNZ >R50       ;If so, EGA is not the active display
  XOR  AX,AX     ;Get # of
  MOV  AL,[84h]  ;  rows - 1
  JMP >R90       ;We're done
R50:             ;Video card is less than EGA (MDA or CGA)
  MOV  AX,24     ;Number of rows must be 25
R90:             ;We're done
  INC  AX        ;Bump the number of rows by 1
  POP  DS,CX,BX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ASCIIZ STRING(s) TO THE SCREEN, PAUSING WHEN IF NECESSARY
;Inputs:  DS:[DX] = String to write
;         PauseRows, PauseHeaderPtr, PauseHeaderSize, PauseRowCount
;         CS = Local Data Area
;Outputs: PauseRowCount
;Changes: Pauses the screen and waits for user input, if necessary
;NOTES: This should be called instead of WriteZCon every time something
;         is written during the Pausing.
;       A string can be written by WriteZCon during the pausing, as long
;         as the string does not contain a Line Feed.  Any line containing
;         a Line Feed must come through here or the Line Count will get
;         screwed up!
;------------------------------------------------------------------------------
WriteZPauseFar:
  CALL WriteZPause
  RETF

WriteZPause:
  PUSH AX,BX,CX,DX          ;Save used registers
  MOV  AX,CS:PauseHeaderPtr ;Put Header Pointer in AX
  CMP  AX,-1                ;Has the Output been cancelled by the user?
  JE  >P90                  ;If so, don't write anything at all
  OR   AX,AX                ;Is STDOUT Redirected?
  JZ  >P80                  ;If so, just write it with no Pausing
  CALL CountZLinesCX        ;Count how many Lines are in the string
  MOV  AX,CS:PauseRowCount  ;Add the new lines
  ADD  AX,CX                ;  to the current lines
  CMP  AX,CS:PauseRows      ;Will we be at or past the end of the screen?
  JB  >P70                  ;If not, just write it
  JE  >P20                  ;If at the end of the screen, handle it
  SUB  AX,CS:PauseRows      ;If not, find
  SUB  CX,AX                ;  the end of the String
  CALL FindEndOfLines       ;  we need to write ([BX])
  MOV  AL,[BX]              ;Save the character that's there now
  MOV  B [BX],0             ;Replace it with a 0
  CALL WriteZPause          ;Write it (will Pause correctly)
  MOV  [BX],AL              ;Restore original character
  MOV  DX,BX                ;Use the new string pointer
  CALL WriteZPause          ;Write it (Pausing if necessary)
  JMP >P90                  ;Done
P20:                        ;At end of screen
  CALL WriteZCon            ;Write the String
  CALL HandlePause          ;Handle the Pause (may change Pointers/Counters)
  JMP >P90                  ;We're done for now
P70:                        ;Store new Row Count
  MOV  CS:PauseRowCount,AX  ;Save the new Row Count
P80:                        ;Write the String
  CALL WriteZCon            ;Write the string
P90:                        ;Done
  POP  DX,CX,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE PAUSE LINE, AND WAIT FOR A KEYSTROKE
;Inputs:  CS = Local Data Area
;         PauseRows, PauseHeaderPtr, PauseHeaderSize, PauseRowCount
;Outputs: PauseRowCount, PauseHeaderPtr
;Changes: Pauses the screen and waits for user input, if necessary
;------------------------------------------------------------------------------
HandlePause:
  PUSH AX,BX,DX,DS        ;Save String Segment
  MOV  DS,CS              ;Point DS at our Data Segment
  MOV  BX,OFFSET PauseHeaderPtr ;Point [BX] at the Pause Header
  MOV  DX,PauseMsg        ;Write the
  CALL WriteZCon          ;  Enter a Keystroke message
  CALL FlushKbdBuff       ;Clear the keyboard buffer
L10:                      ;Loop to here to wait for a keystroke
  CALL GetKey             ;Is there a key in the keystroke buffer?
  JZ   L10                ;If not, keep waiting until there is
  MOV  DX,PauseDMsg       ;Delete the
  CALL WriteZCon          ;  MORE Message
  CMP  AL,CtrlC           ;Was the keystroke a Control-C?
  JE  >L40                ;If so, jump to handle it
  CMP  AL,Escape          ;Was the keystroke an Escape?
  JNE >L20                ;If not, just keep going
  MOV  W [BX],0           ;If so, mark us as redirected (stop Pausing)
  JMP >L90                ;And quit
L20:                      ;Continue with the Pause
  MOV  DX,PauseNMsg       ;Write the
  CALL WriteZCon          ;  MORE Replacement Line
  MOV  DX,[BX]            ;Point DX at the Header
  CALL WriteZCon          ;Write it
  MOV  AX,PauseHeaderSize ;Reset the Row Count
  MOV  PauseRowCount,AX   ;Store the new Row Count
  JMP >L90                ;We're done for now
L40:                      ;Ctrl-C (stop altogether)
  MOV  W [BX],-1          ;Mark as stopped
L90:                      ;Done
  POP  DS,DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE NUMBER OF LINES IN AN ASCIIZ STRING (COUNT CR/LF COMBINATIONS)
;Inputs:  DS:[DX] = Pointer to String to measure
;         CLD already issued
;Outputs: CX = Number of LF's in the String (may be 0)
;         ZF = Set if CX = 0
;            = Clear if CX > 0
;Changes:
;------------------------------------------------------------------------------
CountZLinesCX:
  PUSH AX,SI ;Save used registers
  MOV  SI,DX ;Put the pointer in DI
  XOR  CX,CX ;Initialize Lines Counter
Z10:         ;Loop to here for each character
  LODSB      ;Get the next character
  OR   AL,AL ;Is it the end of the string?
  JZ  >Z90   ;If so, we're done
  CMP  AL,LF ;Is it a Line Feed?
  JNE  Z10   ;If not, it's not a new line
  INC  CX    ;If so, Increment the Line Counter
  JMP  Z10   ;Keep looking
Z90:         ;We're done
  OR   CX,CX ;Set return flag
  POP  SI,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE POINTER AFTER THE FIRST SEVERAL LINES OF A STRING
;Inputs:  DS:[DX] = String to use
;         CX = Number of lines to "skip"
;         CLD already issued
;Outputs: DS:[BX] = "New" String Pointer (after the last line written)
;Changes:
;NOTES: This assumes that the string actually has MORE than the number of
;         lines in AX (it does not look for the end of an ASCIIZ string).
;------------------------------------------------------------------------------
FindEndOfLines:
  PUSH AX,CX  ;Save used registers
  PUSH DI,ES  ;Save used registers
  MOV  BX,CX  ;BX = Line Counter
  MOV  ES,DS  ;Point ES:[DI] at
  MOV  DI,DX  ;  the string
  MOV  AL,LF  ;Look for Line Feeds
  MOV  CX,-1  ;Maximize counter
L10:          ;Loop to here for each new line
  REPNE SCASB ;Look for the end-of-line character
  DEC  BX     ;Decrement the Line Counter
  JNZ  L10    ;If not 0 yet, keep looking
  MOV  BX,DI  ;Store the new string beginning
L90:          ;Done
  POP  ES,DI  ;Restore used registers
  POP  CX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FLUSH KEYBOARD BUFFER
;Inputs:
;Outputs:
;Changes: Flushes the Keyboard Buffer
;------------------------------------------------------------------------------
FlushKbdBuff:
  PUSH AX     ;Save used registers
F10:          ;Loop to here for each key
  CALL GetKey ;Get a key from the keyboard buffer
  JNZ  F10    ;If there was one, get another
  POP  AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ CHARACTER FROM THE KEYBOARD BUFFER
;Inputs:
;Outputs: AH = Keyboard scan code
;         AL = ASCII value of keypress (0 if extended ASCII)
;         AX = 0 if no key is waiting
;Changes: ZF = Set if no key in buffer (AX = 0)
;            = Clear if a key was found (AX = key)
;------------------------------------------------------------------------------
GetKey:
  MOV  AH,1  ;Service 1 (Keystroke waiting?)
  INT  16h   ;Do It
  JZ  >K10   ;If no key waiting, we're done
  XOR  AH,AH ;If a key is waiting, service 0 (Get keystroke)
  INT  16h   ;Do It
  JMP >K90   ;We're done
K10:         ;No keystroke waiting
  XOR  AX,AX ;Make sure AX=0
K90:         ;We're done
  OR   AX,AX ;Set the return flag
  RET

;------------------------------------------------------------------------------
;WRITE MULTIPLE CR/LF's TO THE SCREEN
;Inputs:
;Outputs: To Screen, Updates Pause Counters
;Changes:
;------------------------------------------------------------------------------
WriteCrLf2:
  CALL WriteCrLf ;Move down
  CALL WriteCrLf ;  2 lines
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SPACE AND CODE TO PROCESS OUR PROGRAM STACK
;  This code and must be physically at the END of the Program,
;    but must be one of the FIRST procedures called by the Program.
;  In addition, the Stack Pointer (SP) must be set properly
;    (to LastProgByte - 2) BEFORE this code is called.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;RESIZE OUR MEMORY ALLOCATION TO THE MINIMUM SIZE NEEDED
;Inputs:  SP = LastProgByte - 2
;         ES = Local Segment
;Outputs: Rellocates Memory to the minimum size required to run the program
;Changes:
;------------------------------------------------------------------------------
ResizeMemory:
  PUSH AX,BX  ;Save used registers
  MOV  AH,4Ah ;Function 4Ah (Resize Memory Block pointed at by ES)
  MOV  BX,(LastProgByte SHR 4) ;BX = Number of Paragraphs to Resize to
  INT  21h    ;Do it
  POP  BX,AX  ;Restore used registers
  RET

  EVEN 16
  DB (ProgStackSize/8) DUP ('PrgStack')

LastProgByte:
