  JMP Main ;Skip over TSR Code to Main Program


;==============================================================================
;NOTE: This program is written for and compiled with Eric Isaacson's A386
;      assembly language compiler, using Options +P3 -F (80386+ CPU and
;      no FPU).
;==============================================================================


;Do Bulk Reset call for SanDisk drives after Media Not Installed error?
;Contact Davis when implemented


;At least on old computer, after uninstalling USBDRIVE, INT 13h disk numbers
;  do not disappear (if Disks = 8).  Is there some sort of cache on INT 13h
;  disk numbers that we need to flush when we uninstall?

;Make sure we return appropriate number of bytes/sectors sent on Device
;  Drive calls when there is an error

;Olympus Voice Recorder doesn't respond to Inquiry.  In BIOS boot, some data
;  is read (LED flashes) but is never assigned a drive letter.  Could be
;  because of 2kB Sector Size?

;Need new INT 13h Function to list/test Drive letters associated with
;  Drive Number?  Also one to convert LBA to CHS & Vice Versa?
;Need new Device Driver function to return Disk Info for Drive Letter
;  (INT 13h Disk Number, Partition Sector/Index Number, POS, Start Sector Num,
;   Num Sectors, etc.)?  Return values in both LBA & CHS?

;Separate "media installed" test program -- Issue INT 25h call to drive letter
;  to read sector 0, return ErrorLevel.  Also allow "wait until it is inserted"
;  option, which will display "Please insert a disk into drive X:", Escape
;  to exit, max time before insertion, etc.  Maybe max time = 0 won't display
;  message at all, and any other time will?  Defatult time = 0 or 5 seconds?
;  TestDrv X: Wait:#   Optional : after the X

;Option to download & Display any Sector?


;IN DOCS:

;Does not Support INT 2Fh/ Functions 08xxh (DRIVER.SYS support).  Requires
;  significant amount of memory, rarely used, and is information essentially
;  duplicated elsewhere.  Most of the same information can be gleaned from
;  CDS & DPB, the "official" DOS tables.
;If not installed yet, Descr, & BadDevices Options are
;  ignored and program is just installed into memory.
;Drives store all kinds of wierd CHS values, which may or may not work with
;  INT 13h functions, and may not agree with actual disk size (even if disk
;  size is small enough (<8.4GB) to work with INT 13h.  In addition, CHS
;  (and bytes per sector) are stored in several different places, and they may
;  not necessarily all agree with each other.  The CHS values shown in the
;  status table are copied from the SCSI descriptors, and then tested for
;  validity and correctness.  If valid and correct, they are simply stored.
;  If invalid or incorrect, they are adjusted and stored.
;  When testing CHS values on input to INT 13h, we just test to make sure
;  the calculate Sector (LBA) is within the Disk Parameters.  We don't
;  compare anything to our stored values.  The stored values are simply a
;  reference that can be used to help you figure things out, and may not
;  agree with the actual INT 13h Functions.  Using LBA instead of CHS is a
;  much better way to do things.
;MBR does not contain information about sectors per track or heads, but only
;  contains starting cylinder/sector & LBA for each partition (not for the
;  entire disk).  VBR contains Heads & Sectors per Track, so combined they
;  have all the details for a particular partition but not for the entire
;  disk.  In addition, I'm not sure it would be safe to assume all VBR's
;  on the same disk contain exactly the same Heads & Sectors per Track as
;  all of the other VBR's, nor would I lay odds that even if they were all
;  the same that they would actually be correct.  In addition, Floppy Drives
;  don't have MBR's, only VBR's, so the Cylinders & Sectors Per Track aren't
;  stored anywhere directly on the disk.  The actual disk geometry (CHS)
;  has to come from outside the MBR & VBR (using the low-level bus-specific
;  functions).
;Since this allows you to add/remove drives "on-the'fly", you need to be
;  careful while in other programs.  Some check Disk Status at the beginning
;  and don't bother checking after that (they assume nothing will change, or
;  don't understand removable hard drives).  Adding or removing disks may
;  not get recognized by the program, and replacing one disk with another
;  can wreak all kinds of havoc that can totally destory data or render a
;  disk unusable (especially in an FDISK or PART type program).  You need
;  to be really, really careful.
;What a frustrating process!!  Many USB Devices don't support various SCSI
;  requests that they really should support (WriteVerify, Seek, etc.).  The
;  fact that they don't support these basic functions makes it REALLY hard
;  to tell when my code is screwed up vs. when the Device isn't doing what
;  you expect it to do (and what it SHOULD do).  Again, what frustration.
;  I've been chasing my tail for weeks trying to figure out why I couldn't
;  write to the disk.  I thought I tested the Write vs. WriteVerify already,
;  but I must have had something else wrong at the time.
;There are way too many possibilities for disk options.  Normally, disks are
;  installed at boot time, and "special" disks are installed in CONFIG.SYS.
;  DOS will reject any disks (at boot time) that it doesn't like for some
;  reason (like it's too big).  In addition, MS-DOS vrsion numbers don't
;  necessarily match other vendors version numbers in terms of capabilities.
;  We install as a TSR, after DOS has already "filtered" everything, so we
;  need to apply the "filter" ourselves.  Problem is, different filters
;  apply to different process.  E.g, the 8.4 GB size limit is a function of
;  INT 13h BIOS calls, which we don't use for DOS-level access (through the
;  Device Driver or INT 25h/Int 26h calls).  If programs use DOS calls to
;  access files, they won't care if the partitions actually lie within the
;  the first 8.4 GB or not.  The only programs that will have a problem are
;  the ones that use old-style INT 13h BIOS calls.  Also, some versions of DOS
;  may be able to USE any size of disk (as long as FAT16/FAT32 limitations
;  are followed), even though they may not necessarily be able to format
;  the disk.  It all gets way too convoluted and complicated.  So, we'll
;  leave things largely to the user to sort out.  If using an older version
;  of DOS, do some testing to make sure everything works OK.  You can end
;  up destroying data if you write to an "incompatible" disk.  E.g., DOS 3
;  is theoretically limited to 32MB (FAT14), but actually uses FAT16 so
;  might actually work with drives up to 128MB (this program requires DOS 4,
;  so I've never actually tested it).  DOS 4 is supposedly limited to
;  128MB, but should be able to access 2GB partitions.  DOS 7 OSR2 is
;  supposedly limited to 32 GB, but should be able to access 2TB.  Etc.
;  DOS 7.1 is supposedly limited to 128 GB, but seems to work fine on a
;  500 GB disk.
;INT 13h Send SCSI Request Function
;  SCB size is automatically determined from Command Group (6/10/12), though
;    max size is set at 16 bytes.  May need to change code if we need to
;    send a size other thatn 6/10/12.
;COMPLETELY Dynamic disk & drive assignments, no way to "remember"
;  previous drive/disk assignments like Windows/Linux.
;Drive letters cannot be assigned (or even reserved) without media, since
;  disks (even removable ones) can have multiple partitions and there's no
;  way of knowing how many drive letters will be needed ahead of time.
;  Different concept than what you're used to in DOS, which normally only
;  assigns drive letters at boot time which can't change (except for
;  Network and CD-ROM drives).
;For disks with removable media (floppies, card readers), it may take
;  several seconds to recognize a media insertion/removal/change and
;  assign or unassign a drive letter.  Time will vary depending on how many
;  empty media carriers there are and how quickly devices respond to polls,
;  but can vary between almost instantaneous to many tens of seconds.
;Can't speed up process by manually trying to access the drive because drive
;  letters are assigned dynamically, so you can't "force' a drive access
;  until it is assigned to a physical device.
;Dynamic disk assignments can be very confusing and, at times, frustrating.
;  This is mostly because it's not what you're used to, not necessarily
;  because it's a bad thing.  Once you get used to it, you will probably
;  like it better than the way DOS normally works (only assigning drive
;  letters at boot time or when you ask them to change by installing
;  some program).  It is conceptually more like floppy drives, but floppies
;  are assigned drive letters by where the disk is, wheras here we assign
;  drive letters by when the disk is inserted.
;A lot of modern "DOS" programs aren't actually DOS, but use DPMI (or other)
;  protected mode server.  In protected mode, programs are generally expected
;  to provide their own hardware support.  Even though a lot of programmers
;  seem to be doing it, I believe they are digging themselves a hole where
;  they won't be able to use new hardware.
;High-level formats (non-Floppies) use value stored in INT 1Eh (floppy
;  parameters) at program insallation for filler byte (usully F6h).
;  Floppy fill byte is determined by firmware in the disk, and cannot
;  be changed (as far as I know).
;I've seen some references to disks (not necessarily USB) that claim they
;  are write-protected when they actually aren't.  Therefore, we will
;  ignore the write-protect status in the Inquiry Response and just wait
;  for the device to respond with an error if we try to write.  It would
;  be nice for speed, among other things, to not even attempt a bus
;  transaction that we know will fail, but I'm not sure we can trust
;  the write-protect status.
;In 2008, Microsoft introduced exFAT, aka FAT64, specifically targeted at
;  Flash Drives.  It is proprietary and copyrighted, and I've yet to see
;  any specs on how it works.  This will cause all sorts of consternation
;  in the future.  Microsoft doing what it does best -- attempting to
;  destroy the competition by changing the rules and not letting anybody
;  else know what the rules are.  FAT64 does not have Short File Names --
;  DEFINITELY a problem.
;Option to low-level format non-Floppies.  Should use DOS FORMAT or similar
;  utility for floppies.  Needs INT 13h disk number (80h-FFh), not Drive Letter
;  (formatting a disk that can have multiple drive letters).  Many flash drives
;  returns as if the format was successful when it didn't really do anything
;  at all.  Performed by issuing External INT 13h SCSI call.
;Can install with no available DOS Drive Letters.  Useful if you want to
;  use FDISK/RANISH but don't want any DOS drive letters for some reason.
;  If no DOS drives available, need to change LASTDRIVE in CONFIG.SYS & reboot.
;Need to be careful if we "take over" the boot drive (the BIOS booted from
;  a disk that are now controlling), since teh boot drive letter will no
;  longer be valid.  Should be able to work around it with careful
;  configuration control.
;If requested to do a high-level format on a non-floppy, simply overwrites
;  entire sector with character stored at interrupt 1Eh.  This hardly ever
;  happens, though, since hard drives are almost never formatted this way.
;A Bad device is one that doesn't respond correctly to USB or SCSI requests,
;  not necessarily one that has no/invalid media/data.
;For INT 13h SCSI Command Request (ASPI look-alike), I13SCmdSize is only used
;  for Reserved & Vendor-specific Command Groups (3-4, 6-7).  Group 0 is
;  always 6 bytes, 1-2 always 10, 5 always 12.  If I13SCmdSize is provided
;  as 0, we use 12, else we use whatever is provided (up to 16).
;In INT 13h SCSI Command Request (ASPI look-alike), return values are
;  initialized to -1 and left there.  Values are only downloaded (e.g.,
;  ASC/Q codes from a Request Sense) if there is a reason to do it.  If
;  a Request returns successfully, Request Sense is not issued automatically
;  (ASPI always issues Request Sense, I think).
;Apologize for X option.  Just too many unknown variables to determine a
;  correct size automatically.  May depend on manufacturer, disk size,
;  host / hub manufacturer(s), cable lengths, number of hubs, other devices
;  attached to bus or hub, read vs. write, etc.  May provide an
;  automatic/dynamic X value in future (completely eliminating need for
;  X command-line option), but for now we need the option.  For sure
;  it depends on manufacturer adn/or size, since SanDisk 8G works with 64
;  when none of my other flash drives do.  Need to work with lowest common
;  denominator for now.
;Device/Interface Indexes vs Disk/LUN Numbers can be confusing.  Devices
;  are always 0-7 (just a 0-based Index), Disks are always 80h-FFh (INT 13h).
;  There is a one-to-many relationship, which can be very confusing until
;  you get used to it.
;May take several seconds for a new device/drive to get recognized, depending
;  on circumstances & factors.  This is especially true for multi-disk readers,
;  since USBDRIVE must constantly poll them (in the background) to find out
;  when media is inserted, and only looks at one media slot at a time
;  (round-robin polling).  Some devices also do not respond correctly the first
;  time they are queried.   It's better with single disks, but can still take
;  several seconds.  Factors related to how long it takes before the drive
;  will be mounted include the disk hardware, the timing (where in the polling
;  sequence things are when you actually insert the disk), number of media
;  slots, and which media slot is used.  Unlike other DOS USB disk drivers,
;  however, the computer does not stop and you don't need to reboot!
;Device with no media inserted usually takes longer to initialize than one
;  with media -- devices many times don't respond at all to certain Requests
;  instead of returning right away with an error.  Because Mass Storage is
;  notoriously unreliable, we keep retrying multiple times to make sure
;  things are really no good.
;Example of incompatibility issues: Some drives don't support Write with
;  Verification call, even though they are supposed to, and there's no
;  way to know which are which.  So, instead of issuing a Write with
;  Verification call, USBDRIVE issues a Write and then a Read.  This makes
;  Writes very slow -- way slower than they could be if the Devices followed
;  the specs.  Because some disk dont' work correctly, it screws things up
;  for the drives that do.



;According to the "official" specs, DOS 4 drives can be no larger than
;  128 MB, but that doesn't appear to be true from my tests.  I've used a
;  1GB Flash Drive under DOS 4, and it seems to work fine.  I think most
;  limits are artificial, and perhaps some utilities have problems with
;  certain disk sizes.  From what I've seen, DOS does not.  If try to load
;  disks with Device Drivers in CONFIG.SYS, DOS may impose the artifical
;  limits.  Using a TSR, DOS doesn't artificially limit you and you can use
;  them.  However, you may need to replace the archaic utilities that work
;  better with newer hardware, like those that come with FreeDOS.
;I don't have full versions (utilities) of older versions of DOS, just
;  the boot files.  So, I can't test everything fully.  You'll just have
;  to experiment and see what happens.  You can report back to me if you
;  discover anything, good or bad.  I don't believe many people are using
;  older versions of DOS any more, but if they are, they should be OK.
;As a test, I installed USBUHCIL, USBHUB, & USBDRIVE in MS-DOS 4.01, and
;  plugged in a 1GB Flash Drive (DOS 4.01 can supposedly handle a maximum
;  128 MB disk).  The drive had a few files and directories, and perusing
;  the disk (DIR/CD/etc.) worked fine.  One of the files was large,
;  150 MB.  I used PKZIP to create a .ZIP file on the Flash Drive (file
;  was already compressed, Zipping yielded a 2% compression, ZIP file
;  ended up being 1xx MB.  I then renamed the original 150MB file, unzipped
;  the 150 MB file from the ZIP archive, and compared the original 150 MB
;  file with the zipped-then-unzipped 150 MB file, using FreeDOS's FC
;  (File Compare) utility.  Not a bit of problem with any of it.  IOW,
;  at least from my non-thorough testing, DOS 4 does not appear to have a
;  128 MB limit in spite of what I have read in various places.  Some of the
;  DOS 4 utilites (FORMAT, FDISK, etc.) may have problems with large disks,
;  and DOS 4 may not mount large disks at boot time (unverified).  But, if
;  you mount the large drives after you've already booted, there doesn't seem
;  to be a problem.  Well over 500 MB of the 1GB disk was used.  Note that it
;  did take a long time to do this at USB 1 speeds, but it worked just fine.


;Speed Tests (COPY FileName NUL, single device on Host, no Hub)
;----------------------------------------------------------------
;  Computer      Disk         FAT    File MB     X  Seconds  Mbps
;  ------------  -----------  -----  ----------  -- -------  ----
;  Sony Laptop   Sandisk 8GB  FAT32  26,762,776   1  643.40  0.33
;  Sony Laptop   Sandisk 8GB  FAT32  26,762,776   2  343.23  0.62
;  Sony Laptop   Sandisk 8GB  FAT32  26,762,776   4  175.54  1.22
;  Sony Laptop   Sandisk 8GB  FAT32  26,762,776   8  134.51  1.59
;  Sony Laptop   Sandisk 8GB  FAT32  26,762,776  16  198.88  1.08
;  Sony Laptop   Sandisk 8GB  FAT32  26,762,776  32  118.42  1.81
;  Sony Laptop   Sandisk 8GB  FAT32  26,762,776  64  107.87  1.98
;  Dell Desktop  Toshiba 2GB  FAT16  21,329,041   1  530.47  0.32
;  Dell Desktop  Toshiba 2GB  FAT16  21,329,041   4  149.73  1.14

;Notes that sometimes increasing X actually slows things down.  To obtain
;  maximum speed, you'll just need to experiment and see what happens.
;  There is also a variance in each time you do it, so a truly scientific
;  test would make multiple tests at same X factor and average the results
;  (we didn't do that here).  Will probably also vary with other devices on
;  the Host/Hub.


COMMENT 

  To change DOS kernel to support Sector Size larger than 512 bytes:

  Before you do this, be aware that DOS will use a LOT more memory than it
  does if you leave things at the default values.  In particular, you may
  want to change the BUFFERS value in CONFIG.SYS to something smaller than
  normal.  If you have 640k of RAM available to DOS (all modern computers
  do), by default DOS will create 15 buffers, each one large enough to store
  a sector's worth of data.  Under normal conditions (512-byte sectors), this
  will be 7.5k of RAM dedicated to disk buffers.  If you increase the sector
  size to, say, 2048 bytes (instead of 512), and leave the number of buffers
  at the default (15), there is now 30k of RAM dedicated to disk buffers
  instead of 7.5k.  Unless you're actually accessing the disk with the
  larger sector size, much of the memory dedicated to disk buffers never
  gets used and is essentially wasted.  In other words, you shouldn't
  change the sector size in the DOS kernel unless you have a really good
  reason -- otherwise, you're simply wasting some of your precious memory
  for no reason.  Also, modern hard drives are pretty fast, so the DOS
  buffers (sort of a small-scale disk-cache) don't provide as much benefit
  like they did in the old days.

  DOS does have the capability to support sector sizes larger than 512
  bytes (supposedly up to 8192 bytes), but this is not enabled by default.

  DOS internally maintains several memory buffers, each large enough to
  store one sector's worth of data.  The number of these buffers defaults
  to 15 on most modern computer systems, but can be changed using the BUFFERS
  option in your CONFIG.SYS file.  The size of each buffer must be large enough
  to store a sector's-worth of data from any disk that DOS may need to access
  while running.  So, the buffers must be big enough to hold the largest sector of
  ANY disk that DOS may need to access.  The sector size of almost all disks
  is 512 bytes, but there are some exceptions.  It is those exceptions that
  cause all of the grief.



  You should NOT do this unless you need to load a disk that has a sector
  size larger than 512 bytes.  This will unnecessarily increase the amount
  of memory that DOS uses, and also increase the amount of memory that
  USBDRIVE uses (USBDRIVE sets up an internal buffer that is the same size
  as the DOS buffers).



  The size of the internal DOS sector buffers is determined at boot time using
  the default disk device drivers built ito the DOS boot kernel (MSDOS.SYS
  for MS-DOS, IBMDOS.COM for PC-DOS).  The kernels have a "default" minimum
  size of 128 (0080h) bytes hard-coded into the kernel.  During
  the boot process, the kernel adjusts this size to match the largest
  sector size of any disks it finds (which is very rarely anything other
  than 512 bytes).  The problem is, the boot kernel stops adjusting the
  size after the default disk device drivers (those built into the kernel)
  are finished processing the disks.  You can continue to load disk device
  drivers after the kernel has finished, using your CONFIG.SYS file (or via
  a TSR like USBDRIVE), but the DOS kernel has already determined the maximum
  sector size it will use (and reserved the memory it needs) before it gets
  to that point, so it's too late to change it.

  Since it is impossible to change the maximum sector size after the DOS
  kernel has decided what it should be, you have to change the DOS kernel.
  The way you do this is to change the "default" sector size that is hard-coded
  into the kernel from 128 bytes to whatever you want it to be (presumably,
  something larger than 512 bytes).  I've seen documentation that says DOS
  will support sector sizes up to 8192 bytes, though I have not personally
  tested anything larger than 2048 bytes.

  The easiest and fastest way to perform the patch is to use DOS's
  extremely powerful DEBUG program.  DEBUG is a powerful program, and is
  therefore also extremely dangerous in the hands of someone who does not
  know what they are doing.  If you're not at least a little bit familiar
  with hexadecimal arithmetic, memory segments and offsets, and similar
  concepts, you're probably better off letting someone else do this for you.
  This will take you through the steps one at a time and explain what each of
  them does, but if you're queasy about this kind of thing, let someone
  help you.

  First of all, you will need to locate and modify the attributes of the DOS
  boot kernel before you can edit it.  The file will be located in the root
  directory of your boot drive (usually C:\, or A:\ if you boot from a
  floppy).  If you're using MS-DOS (Microsoft), the file is called MSDOS.SYS.
  If you're using PC-DOS (IBM), the file is called IBMDOS.COM.  If you're
  using DOS from some other manufacturer, you'll need to figure out
  which file you should be editing.

  The boot kernel file is a critical system file, and is "hidden" from
  normal view so that you can't move or delete or change it
  by accident.  You need to change the attributes of the file so that
  you can see it and edit it.  Later versions of DOS came with the ATTRIB
  utility that lets you do just that, and there are also several
  after-market utilities that will let you accomplish the same thing.

  Let's assume you're using MS-DOS, that you're in the root directory
  of the hard drive you booted from (C:\), and that you're using the MS-DOS
  ATTRIB utility.  To make sure that the MSDOS.SYS file is there, you would
  do the following:

  ATTRIB MSDOS.SYS {Enter}

  The computer will respond with something like this:

  SHR  C:\MSDOS.SYS

  Note that a "DIR MSDOS.SYS" would say the file doesn't exist, since it
  has several special attributes set (S = System, H = Hidden, and
  R = Read-only) that keep the DIR command from "seeing" it.  To unset
  the S, H, and R attributes so that you can edit the file, do the following:

  ATTRIB -R -S -H MSDOS.SYS {Enter}



  Can make backup copy here just in case things get screwed up.  Problem is,
  need SYS to store file (must be in specific location on disk), so a backup
  on the same drive doesn't do a lot of good.  If you want a backup, you
  should have a bootable floppy or something to store the original file.



  Now for the fun part -- we'll get into the DOS kernel and change it using
  DEBUG.  Keep in mind that everything in DEBUG uses hexadecimal numbers
  and arithmetic (not decimal):

  DEBUG MSDOS.SYS {Enter}

  The computer will simply respond with a "-", which is the DEBUG prompt
  asking you what it should do next:

    -

  The first thing you need to do is ask DEBUG how big the file it loaded
  actually is (you'll need to know this for the next step).  DEBUG puts
  the file size in the CPU's CX register when it loads, so you just need
  to ask DEBUG what's stored in the CPU's CX Register:

  RCX {Enter}

  The computer will respond with something like this:

  CX 94FA
  :

  "94FA" is the hexadecimal value currently stored in the CX register
  (the number of bytes in the MSDOS.SYS file), and the ":" is DEBUG
  prompting you to enter a new value to be stored in the CX register.
  You don't want to change it, so:

  {Enter}

  DEBUG will respond with another "-" prompt:

  -

  Now, we need to Search in the kernel file to find out where the
  NUL device header is located.  We will use DEBUG to Search (S), starting
  at the beginning of the file (offset 0), for the entire Length (L) of the
  file, for the string 'NUL     ' (NUL followed by 5 spaces):

  S 0 L 94FA 'NUL     ' {Enter}

  Note that in most cases, whether characters are upper-case and lower-case
  doesn't matter, but it DOES matter in the search string ('NUL     ') --
  NUL must be in upper-case letters.  The number following the 'L' should be
  the same number that was returned by DEBUG in the "RCX" step above.

  The computer will respond with something like this:

  1924:82E2
  -

  The second number (the one after the colon, 82E2 in this case) is the
  offset into the file where the NUL device header is located.  The location
  in the file we actually need to change is located 28 (1Ch) bytes before
  the start of the NUL device header.  Since most people can't subtract
  hexadecimal numbers (like 82E2h and 1Ch) easily in their heads, we'll have
  DEBUG do it for us using the H (Hexadecimal math) function:

  H 82E2 1C {Enter}

  The computer will respond with something like this:

  82FE 82C6

  The first number (82FE is the sum of the two numbers (82E2h + 1Ch), and the
  second number (82C6) is the difference of the two numbers (82E2h - 1Ch).
  We need the second number (the difference) for the next step, where we're
  going to make sure that we've got the correct file offset before we
  change anything.  We'll use DEBUG's D (Dump memory) function to see what's
  stored in the kernel file at this location.  We'll look at enough data to
  make sure we see the data we're trying to change, along with the NUL device
  header that we originally searched for:

  D 82C6 L 28 {Enter}

  The computer will respond with something like this:


  1924:82C0                    80 00-00 00 00 00 00 00 00 00         ..........
  1924:82D0  00 00 00 00 00 00 00 00-00 00 00 00 04 80 C6 0D   ................
  1924:82E0  CC 0D 4E 55 4C 20 20 20-20 20 00 00 00 00         ..NUL     ....
  -

  The far left column is the data address (file offset), the second
  column is the hexadecimal value of each data byte, and the last column
  is the data represented as ASCII text (with a "." in the last column
  indicating that the byte can't be represented as a printable ASCII character).
  The important thing is that the first two numbers you see are 80 00,
  and that you see a 'NUL' followed by 5 spaces (20h's) 4 bytes from the end
  of the Dump.  What the other numbers are in between and after don't
  really matter.

  The two bytes at the beginning (80 00) are the ones we need to change.
  In the Intel architecture, data is stored in a little-endian format, which
  means that the Least Significant Byte (LSB) is stored first, followed by
  the Most Significant Byte (MSB).  This actually makes a lot of sense to
  the computer, but is very confusing to humans because it is backwards
  from the way we usually write things.  The two bytes, 80 00, converted to a
  human-readable form, is 0080h, which equates to 128 decimal (the
  hard-coded "default" sector size).  Following are the values we may want
  to change the default sector size to:

  Decimal  Hex    DEBUG
  -------  -----  -----
     1024  0400h  00 04
     2048  0800h  00 08
     4096  1000h  00 10
     8192  2000h  00 20

  To change data in the file, you use DEBUG's E (Edit) command.  For instance,
  to change the sector size to 2048 bytes, you would do the following:

  E 82C6 00 08 {Enter}

  The computer will simply respond with another "-" prompt:

  -

  To verify that the data was actually changed like you thought it was,
  you should do another Dump:

  D 82C6 L 2 {Enter}

  The computer will respond with something like this:


  1924:82C0                    00 08                                 ..
  -

  If you're satisfied with what you've done, you can W (Write) the file
  to make the changes permanent:

  W {Enter)

  The computer will respond with something like this:

  Writing 094FA bytes
  -

  If you're not sure you've done everything correctly, or screwed something
  up so badly that you just want to start over again, just skip the W command.
  Unless you tell DEBUG to Write the file, none of the changes you've made
  are permanent.

  To exit DEBUG, use the Q (Quit) command:

  Q {Enter}

  Now that the file is changed, you should set the S, H, and R attributes
  again so that you won't erase or change the file by accident:

    ATTRIB +R +S +H MSDOS.SYS

  Now, reboot and you should be all set.


  Here is a sample session to change Sector Size to 2048 for MS-DOS 6.20:

  C:\>attrib msdos.sys
    A  SHR     C:\MSDOS.SYS

  C:\>attrib -r -s -h msdos.sys

  C:\>attrib msdos.sys
    A          C:\MSDOS.SYS

  C:\>debug msdos.sys
  -rcx
  CX 94FA
  :
  -s 0 l 94fa "NUL     "
  1E5E:82E2
  -h 82e2 1c
  82FE  82C6
  -d 82c6 l 28
  1E5E:82C0                    80 00-00 00 00 00 00 00 00 00         ..........
  1E5E:82D0  00 00 00 00 00 00 00 00-00 00 00 00 04 80 C6 0D   ................
  1E5E:82E0  CC 0D 4E 55 4C 20 20 20-20 20 00 00 00 00         ..NUL     ....
  -e 82c6 00 08
  -d 82c6 l 28
  1E5E:82C0                    00 08-00 00 00 00 00 00 00 00         ..........
  1E5E:82D0  00 00 00 00 00 00 00 00-00 00 00 00 04 80 C6 0D   ................
  1E5E:82E0  CC 0D 4E 55 4C 20 20 20-20 20 00 00 00 00         ..NUL     ....
  -w
  Writing 094FA bytes
  -q

  C:\>attrib +r +s +h msdos.sys

  C:\>attrib msdos.sys
    A  SHR     C:\MSDOS.SYS

  C:\>

  Now, after a reboot, the DOS sector size is 2048 bytes.

END COMMENT ;


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;EQUATE/STRUCTURE/MACRO DEFINITIONS
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;EQUATES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;==============================================================================
;TSR Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Size of our TSR Stack
  ;----------------------------------------------------------------------------
  StackSize EQU 384

  ;----------------------------------------------------------------------------
  ;Special Interrupt 2Fh (TSR Multiplex) Function Numbers we monitor/use
  ;----------------------------------------------------------------------------
  MuxInstallChk  EQU 0 ;Handle # Install Check
  MuxGetProgName EQU 1 ;Get Program Name
  MuxGetProgVer  EQU 2 ;Get Program Version
  MuxGetAuthor   EQU 3 ;Get Program Author


;==============================================================================
;Miscellaneous
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special Codes
  ;----------------------------------------------------------------------------
  No  EQU  0 ;Miscellaneous Yes/No tests
  Yes EQU -1 ;      "        "  "    "


;==============================================================================
;CPU Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Bit masks in the CPU Flags Register
  ;----------------------------------------------------------------------------
  CarryFlag  EQU 0001h ;Carry Flag
  ParityFlag EQU 0004h ;Parity Flag
  AuxFlag    EQU 0010h ;Auxiliary Flag
  ZeroFlag   EQU 0040h ;Zero Flag
  SignFlag   EQU 0080h ;Sign Flag
  TrapFlag   EQU 0100h ;Trap Flag
  IntFlag    EQU 0200h ;Interrupt Flag
  DirFlag    EQU 0400h ;Direction Flag
  OFFlag     EQU 0800h ;Overflow Flag

  ;----------------------------------------------------------------------------
  ;Special CPU OpCodes we need to process
  ;----------------------------------------------------------------------------
  OpCodeJmpNear  EQU 0E9h ;JMP NEAR  (Within Same Segment)
  OpCodeJmpShort EQU 0EBh ;JMP SHORT (+127/-128 Bytes)


;==============================================================================
;CONsole/Screen Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special ASCII Characters
  ;----------------------------------------------------------------------------
  Tab       EQU  9 ;Tab
  LF        EQU 10 ;Line Feed
  FormFeed  EQU 12 ;FormFeed
  CR        EQU 13 ;Carriage Return
  EOF       EQU 26 ;End-of-File
  Quote2    EQU 34 ;Double quote
  Quote1    EQU 39 ;Single quote
  BackSlash EQU 92 ;BackSlash (\)

  ;----------------------------------------------------------------------------
  ;Special Keys that can be pressed during Pause routine
  ;----------------------------------------------------------------------------
  CtrlC  EQU  3 ;Control-C Keystroke
  Escape EQU 27 ;Escape Keystroke


;==============================================================================
;DOS Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;;Minimum DOS Version required to use this program
  ;----------------------------------------------------------------------------
  MinDOSVer EQU 0400h

  ;----------------------------------------------------------------------------
  ;DOS Memory Allocation Strategies
  ;----------------------------------------------------------------------------
  StrategyLowFirst     EQU 00h ;First Fit, Low Memory Only
  StrategyLowBest      EQU 01h ;Best Fit, Low Memory Only
  StrategyLowLast      EQU 02h ;Last Fit, Low Memory Only
  ;For DOS 3&4, anything >2 is Last Fit Low Memory
  ;Below are for DOS 5+ Only
  StrategyHighFirst    EQU 40h ;First Fit, High Memory Only
  StrategyHighBest     EQU 41h ;Best Fit, High Memory Only
  StrategyHighLast     EQU 42h ;Last Fit, High Memory Only
  StrategyHighLowFirst EQU 80h ;First Fit, Try High Memory then Low Memory
  StrategyHighLowBest  EQU 81h ;Best Fit, Try High Memory then Low Memory
  StrategyHighLowLast  EQU 82h ;Last Fit, Try High Memory then Low Memory

  ;----------------------------------------------------------------------------
  ;UMB Link States
  ;----------------------------------------------------------------------------
  UMBLinkNo  EQU 00h ;UMB's are not part of DOS Memory Chain
  UMBLinkYes EQU 01h ;UMB's are in DOS Memory Chain (DOS=HIGH,UMB in CONFIG.SYS)

  ;----------------------------------------------------------------------------
  ;Sizes of various DOS data structures
  ;----------------------------------------------------------------------------
  FCBSize     EQU  44 ;Size of DOS File Control Block
  CmdTailMax  EQU 128 ;Maximum size of a DOS Command Tail
  MaxPathSize EQU  64 ;Maximum Size of a DOS Path/FileName String

  ;----------------------------------------------------------------------------
  ;Special "hard-coded" DOS Device Handles.
  ;These Handles are permanently hard-coded in DOS, and are always open.
  ;There is no need to issue Find, Open, or Close calls to these
  ;  devices - you can just use them at will.
  ;----------------------------------------------------------------------------
  StdInHandle  EQU 0 ;Standard Input Device Handle
  StdOutHandle EQU 1 ;Standard Output Device Handle
  StdErrHandle EQU 2 ;Standard Error Device Handle
  StdAuxHandle EQU 3 ;Standard Auxiliary Device Handle (COM1 by default)
  StdPrnHandle EQU 4 ;Standard Printer Device Handle (LPT1 by default)

  ;----------------------------------------------------------------------------
  ;Codes returned by INT 21h, Function 4400h (Get Device Information)
  ;----------------------------------------------------------------------------
  ;If bit 7 is Set (is a Device):
  DvcInfoIsStdIn    EQU 0001h ;STDIN
  DvcInfoIsStdOut   EQU 0002h ;STDOUT
  DvcInfoIsNUL      EQU 0004h ;NUL
  DvcInfoIsClock    EQU 0008h ;CLOCK$
  DvcInfoInt29h     EQU 0010h ;Uses Int 29h (Special Device)
  DvcInfoBinary     EQU 0020h ;Binary (Raw) Mode
  DvcInfoEOF        EQU 0040h ;EOF on Input
  DvcInfoIsDevice   EQU 0080h ;Is a Device (not a File)
  DvcInfoKEYB       EQU 0100h ;Unknown (set by DOS 6.2x KEYB program)
  DvcInfoOpenClose  EQU 0800h ;Supports Open/Close calls
  DvcInfoOutputBusy EQU 2000h ;Supports Output until Busy
  DvcInfoIOCTL      EQU 4000h ;Can process IOCTL requests (INT 21h, Func 4402h)

  ;If bit 7 is Clear (is a File):
  DvcInfoDriveMask    EQU 003Fh ;Drive number (0 = A:)
  DvcInfoNotWritten   EQU 0040h ;File has not been written (Dirty Buffer?)
  ;Bit 7 = Clear!
  DvcInfoInt24h       EQU 0100h ;Generate Int 24h on Errors (DOS 4 only)
  DvcInfoNotRemovable EQU 0800h ;Media Not Removable
  DvcInfoNoDateTime   EQU 4000h ;Don't set File Date/Time on Closing (DOS 3.0+)
  DvcInfoRemote       EQU 8000h ;File is Remote (DOS 3.0+)

  ;----------------------------------------------------------------------------
  ;DOS Extended Error Codes
  ;Most of these won't get used by us, but we still have the complete list
  ;----------------------------------------------------------------------------
  DOSXErrNone          EQU   0 ;None
  DOSXErrInvalidFunc   EQU   1 ;Invalid Function Number
  DOSXErrFileNotFound  EQU   2 ;File Not Foune
  DOSXErrPathNotFound  EQU   3 ;Path Not Found
  DOSXErrNoHandles     EQU   4 ;No Handles Available
  DOSXErrAccessDenied  EQU   5 ;Access Denied
  DOSXErrInvalidHandle EQU   6 ;Invalid Handle
  DOSXErrMCBDestroyed  EQU   7 ;Memory Control Block Destroyed
  DOSXErrInsuffMemory  EQU   8 ;Insufficient Memory
  DOSXErrInvalidMBA    EQU   9 ;Memory Block Address Invalid
  DOSXErrInvalidEnvir  EQU  10 ;Invalid Environment (>32k Length)
  DOSXErrInvalidFormat EQU  11 ;Invalid Format
  DOSXErrInvalidAccess EQU  12 ;Invalid Access Code
  DOSXErrInvalidData   EQU  13 ;Invalid Data
  ;14 = Reserved
  DOSXErrInvalidDrive  EQU  15 ;Invalid Drive
  DOSXErrRmvCurrDir    EQU  16 ;Attempted to Remove Current Directory
  DOSXErrNotSameDvc    EQU  17 ;Not Same Device
  DOSXErrNoMoreFiles   EQU  18 ;No More Files
  ;DOS 3+ Errors (INT 24h)
  DOSXErrWriteProt     EQU  19 ;Disk is Write-protected
  DOSXErrUnknownUnit   EQU  20 ;Unknown Unit
  DOSXErrDriveNotReady EQU  21 ;Drive Not Ready
  DOSXErrUnknownCmd    EQU  22 ;Unknown Command
  DOSXErrCRCError      EQU  23 ;Cyclic Redundancy Check Error
  DOSXErrBadRqLength   EQU  24 ;Bad Request Structure Length
  DOSXErrSeekError     EQU  25 ;Seek Error
  DOSXErrUnknownMedia  EQU  26 ;Unknown Media
  DOSXErrNoSector      EQU  27 ;Sector Not Found
  DOSXErrOutOfPaper    EQU  28 ;Printer Out of Paper
  DOSXErrWriteFault    EQU  29 ;Write Fault
  DOSXErrReadFault     EQU  30 ;Read Fault
  DOSXErrGeneralFail   EQU  31 ;General Failure
  DOSXErrShareViolate  EQU  32 ;Sharing Violation
  DOSXErrLockViolate   EQU  33 ;Lock Violation
  DOSXErrBadDiskChange EQU  34 ;Invalid Disk Change
  DOSXErrFCBUnavail    EQU  35 ;File Control Block Unavailable
  DOSXErrShareOverflow EQU  36 ;Sharing Buffer Overflow
  DOSXErrCodePage      EQU  37 ;Code Page Mismatch (DOS 4+)
  DOSXErrEOF           EQU  38 ;Cannot Complete File Operation (EOF) (DOS 4+)
  DOSXErrNoDiskSpace   EQU  39 ;Insufficient Disk Space (DOS 4+)
  ;40-49 = Reserved
  ;Network Errors (INT 24h)
  DOSXErrReqNoSupport  EQU  50 ;Request Not Supported
  DOSXErrNoListen      EQU  51 ;Remote Comptuer not Listening (not Responding)
  DOSXErrDupName       EQU  52 ;Duplicate Name on Network
  DOSXErrNameNotFound  EQU  53 ;Network Name Not Found
  DOSXErrNetworkBusy   EQU  54 ;Network Busy
  DOSXErrNoDevice      EQU  55 ;network Device no longer exists
  DOSXErrBIOSLimit     EQU  56 ;Network BIOS Command Limit Exceeded
  DOSXErrAdapterErr    EQU  57 ;Network Adapter Hardware Error
  DOSXErrBadResponse   EQU  58 ;Incorrect Response for Network
  DOSXErrNetworkErr    EQU  59 ;Unexpected Network Error
  DOSXErrIncompat      EQU  60 ;Incompatible Remote Adapter
  DOSXErrPrnQueueFull  EQU  61 ;Print Queue Full
  DOSXErrQueueNotFull  EQU  62 ;Queue Not Full
  DOSXErrPrnNoSpace    EQU  63 ;Not Enough Space to Print File
  DOSXErrNetNameDel    EQU  64 ;Network Name Deleted
  DOSXErrNetNoAccess   EQU  65 ;Network Access Denied
  DOSXErrNetDvcWrong   EQU  66 ;Network Device Type Incorrect
  DOSXErrNetNoName     EQU  67 ;Network Name Not Found
  DOSXErrNetNameLimit  EQU  68 ;Network Name Limit Exceeded
  DOSXErrNetBIOSLimit  EQU  69 ;Network BIOS Session Limit Exceeded
  DOSXErrNetPuase      EQU  70 ;Network Temporarily Paused
  DOSXErrReqNoAccept   EQU  71 ;Network Request Not Accepted
  DOSXErrRedirPause    EQU  72 ;Redirection Paused (Disk/Printer)
  DOSXErrNoSoftware    EQU  73 ;Network Software Not Installed
  DOSXErrAdapterClose  EQU  74 ;Unexpected Adapter Close
  ;75-79 = Reserved
  ;Done with INT 24h Errors
  DOSXErrFileExists    EQU  80 ;File Exists
  DOSXErrDuplicateFCB  EQU  81 ;Duplicated File Control Block
  DOSXErrMkDir         EQU  82 ;Cannot Make Directory
  DOSXErrInt24Fail     EQU  83 ;Fail on INT 24h
  ;Network Errors, not related to INT 24h
  DOSXErrNoStructures  EQU  84 ;Too many Redir's / Out of structures (DOS 3.3+)
  DOSXErrDupRedir      EQU  85 ;Duplicate Redirection / Already Assigned (DOS 3.3+)
  DOSXErrBadPassword   EQU  86 ;Invalid Password (DOS 3.3+)
  DOSXErrBadParameter  EQU  87 ;Invalid Parameter (DOS 3.3+)
  DOSXErrNetWriteFault EQU  88 ;Network Write Fault (DOS 3.3+)
  DOSXErrNetNoSupport  EQU  89 ;Function Not Supported / No Process Slots (DOS 4.0+)
  DOSXErrNotFrozen     EQU  90 ;(DOS 4.0+) required system component not installed / not frozen
  DOSXErrTimerServerOF EQU  91 ;(DOS 4.0+,NetWare4) timer server table overflowed
  DOSXErrDupTimerTbl   EQU  92 ;(DOS 4.0+,NetWare4) duplicate in timer service table
  DOSXErrNoItems       EQU  93 ;(DOS 4.0+,NetWare4) no items to work on
  ;94 = Reserved
  DOSXErrBadSystemCall EQU  95 ;Interrupted / Invalid System Call (DOS 4.0+)
  DOSXErrCDUnknown     EQU 100 ;Unknown Error (MSCDEX)
  DOSXErrSemaphoreOpen EQU 100 ;Open Semaphore Limit Exceeded (DOS 4.0+)
  DOSXErrCDNotReady    EQU 101 ;Not Ready (MSCDEX)
  DOSXErrSemaphoreOwn  EQU 101 ;Exclusive Semaphore Already Owned (DOS 4.0+)
  DOSXErrInvalidEMS    EQU 102 ;EMS Memory No Longer Valid (MSCDEX)
  DOSXErrSemaphoreSet  EQU 102 ;Semaphore Set When Close Attempted (DOS 4.0+)
  DOSXErrCDBadFormat   EQU 103 ;Not High Sierra or ISO-9660 Format (MSCDEX)
  DOSXErrSemaphoneExcl EQU 103 ;Too Many Exclusive Semaphore Requests (DOS 4.0+)
  DOSXErrCDDoorOpen    EQU 104 ;Door Open (MSCDEX)
  DOSXErrBadInterrupt  EQU 104 ;Operation Invalid From Interrupt Handler (DOS 4.0+)
  DOSXErrSemaphoreDied EQU 105 ;Semaphore Owner Died (DOS 4.0+)
  DOSXErrSemaphoreLmt  EQU 106 ;Semaphore Limit Exceeded (DOS 4.0+)
  DOSXErrDiskChanged   EQU 107 ;Insert Drive B: Disk Into A: / Disk Changed (DOS 4.0+)
  DOSXErrDriveLocked   EQU 108 ;Drive Locked by Another Process (DOS 4.0+)
  DOSXErrBrokenPipe    EQU 109 ;Broken Pipe (DOS 4.0+)
  DOSXErrPipeOpen      EQU 110 ;Pipe Open/Create Failed (DOS 5.0+)
  DOSXErrPipeOverflow  EQU 111 ;Pipe Buffer Overflowed (DOS 5.0+)
  DOSXErrDiskFull      EQU 112 ;Disk Full (DOS 5.0+)
  DOSXErrSearchHandles EQU 113 ;No More Search Handles (DOS 5.0+)
  DOSXErrDup2SearchHdl EQU 114 ;Invalid Target Handle for Dup2 (DOS 5.0+)
  DOSXErrVirtualAddr   EQU 115 ;Bad User Virtual Address / Protection Violation (DOS 5.0+)
  DOSXErrVioKbd        EQU 116 ;VIOKBD Request (DOS 5.0+)
  DOSXErrConsoleIO     EQU 116 ;Error on Console I/O (NetWare4)
  DOSXErrIOCtlCategory EQU 117 ;Unknown Category Code for IOCTL (DOS 5.0+)
  DOSXErrVerifyFlag    EQU 118 ;Invalid Value for Verify Flag (DOS 5.0+)
  DOSXErrIOCtlLevel4   EQU 119 ;Level Four Driver Not Found by DOS IOCTL (DOS 5.0+)
  DOSXErrBadFunction   EQU 120 ;Invalid / Unimplemented Function Number (DOS 5.0+)
  DOSXErrSemaphoreTO   EQU 121 ;Semaphore Timeout (DOS 5.0+)
  DOSXErrSmallBuffer   EQU 122 ;Buffer Too Small to Hold Return Data (DOS 5.0+)
  DOSXErrBadChar       EQU 123 ;Invalid Character or Bad File-system Name (DOS 5.0+)
  DOSXErrInfoLevel     EQU 124 ;Unimplemented Information Level (DOS 5.0+)
  DOSXErrNoVolumeLabel EQU 125 ;No Volume Label Found (DOS 5.0+)
  DOSXErrModuleHandle  EQU 126 ;Module Handle Not Found (DOS 5.0+)
  DOSXErrProcedureAddr EQU 127 ;Procedure Address Not Found (DOS 5.0+)
  DOSXErrCWaitNoChild  EQU 128 ;CWait Found No Children (DOS 5.0+)
  DOSXErrCWaitChildRun EQU 129 ;CWait Children Still Running (DOS 5.0+)
  DOSXErrDirectDiskHdl EQU 130 ;Invalid Operation for Direct Disk-access Handle (DOS 5.0+)
  DOSXErrNegOffset     EQU 131 ;Attempted Seek to Negative Offset (DOS 5.0+)
  DOSXErrSeekPipe      EQU 132 ;Attempted to Seek on Device or Pipe (DOS 5.0+)
  ;JOIN/SUBST errors
  DOSXErrAlreadyJOINs  EQU 133 ;Drive Already Has JOINed Drives (DOS 5.0+)
  DOSXErrAlreadyJOIN   EQU 134 ;Drive Already JOINed (DOS 5.0+)
  DOSXErrAlreadySUBST  EQU 135 ;Drive Already SUBSTed (DOS 5.0+)
  DOSXErrDeleteJOIN    EQU 136 ;Can Not Delete Drive Which Is Not JOINed (DOS 5.0+)
  DOSXErrDeleteSUBST   EQU 137 ;Can Not Delete Drive Which Is Not SUBSTed (DOS 5.0+)
  DOSXErrJoinJoin      EQU 138 ;Can Not JOIN to a JOINed Drive (DOS 5.0+)
  DOSXErrSubstSubst    EQU 139 ;Can Not SUBST to a SUBSTed Drive (DOS 5.0+)
  DOSXErrJoinSubst     EQU 140 ;Can Not JOIN to a SUBSTed Drive (DOS 5.0+)
  DOSXErrSubstJoin     EQU 141 ;Can Not SUBST to a JOINed Drive (DOS 5.0+)
  DOSXErrDriveBusy     EQU 142 ;Drive Busy (DOS 5.0+)
  DOSXErrJoinSubstSame EQU 143 ;Can Not JOIN/SUBST to Same Drive (DOS 5.0+)
  DOSXErrRootDir       EQU 144 ;Directory Must Not Be Root Directory (DOS 5.0+)
  DOSXErrJoinEmptyDir  EQU 145 ;Can only JOIN to Empty Directory (DOS 5.0+)
  DOSXErrPathUseSUBST  EQU 146 ;Path Already In Use for SUBST (DOS 5.0+)
  DOSXErrPathUseJOIN   EQU 147 ;Path Already In Use for JOIN (DOS 5.0+)
  DOSXErrPathUseProc   EQU 148 ;Path In Use by Another Process (DOS 5.0+)
  DOSXErrPreviousSUBST EQU 149 ;Directory Previously SUBSTituted (DOS 5.0+)
  DOSXErrSystemTrace   EQU 150 ;System Trace Error (DOS 5.0+)
  DOSXErrSemWaitEvent  EQU 151 ;Invalid Event Count for DosMuxSemWait (DOS 5.0+)
  DOSXErrMutex         EQU 152 ;Too Many Waiting on Mutex (DOS 5.0+)
  DOSXErrListFormat    EQU 153 ;Invalid List Format (DOS 5.0+)
  DOSXErrVolLblSize    EQU 154 ;Volume Label Too Large (DOS 5.0+)
  DOSXErrTCBCreate     EQU 155 ;Unable to Create Another TCB (DOS 5.0+)
  DOSXErrSignalRefused EQU 156 ;Signal Refused (DOS 5.0+)
  DOSXErrSegDiscard    EQU 157 ;Segment Discarded (DOS 5.0+)
  DOSXErrSetNotLocked  EQU 158 ;Segment Not Locked (DOS 5.0+)
  DOSXErrThreadIDAddr  EQU 159 ;Invalid Thread-ID Address (DOS 5.0+)
  DOSXErrArguments     EQU 160 ;Bad Arguments (DOS 5.0+)
  DOSXErrEnvirPtr      EQU 160 ;Bad Environment Pointer (NetWare4)
  DOSXErrPathName      EQU 161 ;Invalid Pathname Passed to EXEC (DOS 5.0+,NetWare4)
  DOSXErrSignalPending EQU 162 ;Signal Already Pending (DOS 5.0+,NetWare4)
  DOSXErrUncertMedia   EQU 163 ;Uncertain Media (DOS 5.0+)
  DOSXErrMap124A       EQU 163 ;ERROR_124 Mapping (NetWare4)
  DOSXErrThreads       EQU 164 ;Maximum Number of Threads Reached (DOS 5.0+)
  DOSXErrProcessSlots  EQU 164 ;No More Process Slots (NetWare4)
  DOSXErrMap124B       EQU 165 ;ERROR_124 Mapping (NetWare4)
  DOSXErrVolNotLock    EQU 176 ;Volume Not Locked (MS-DOS 7.0)
  DOSXErrVolLock       EQU 177 ;Volume Locked in Drive (MS-DOS 7.0)
  DOSXErrVolRemovable  EQU 178 ;Volume Not Removable (MS-DOS 7.0)
  DOSXErrLockCount     EQU 180 ;Lock Count Exceeded (MS-DOS 7.0)
  DOSXErrSegNumber     EQU 180 ;Invalid Segment Number (NetWare4)
  DOSXErrEjectRequest  EQU 181 ;Eject Request Failed (MS-DOS 7.0)


;==============================================================================
;DOS Drive/File Related
;==============================================================================
  DefSectorSize  EQU   512  ;Default Sector Size.  Technically, Drives can have
                            ;  any value that is an exponent of 2 between
                            ;  32 & 8192, but using anything other than 512
                            ;  can cause problems since some programs are
                            ;  "hard-wired" for 512 bytes, and most
                            ;  documentation is based on the assumption of
                            ;  512-byte sectors.
                            ;Sector sizes less than 512 will most likely cause
                            ;  HUGE problems, while sizes greater than 512
                            ;  will probably be handled a little better.
  MinSectorSize  EQU    32  ;Minimum Sector Size allowed by DOS
  MaxSectorSize  EQU  8192  ;Maximum Sector Size allowed by DOS
  BootRecSig     EQU 0AA55h ;Signature at Offset 510 (last two bytes)
                            ;  of a Partition Record or Boot Record Sector


;==============================================================================
;Start/Stop/Lock/Unlock Unit Related
;==============================================================================
;  StopTicks EQU 36  ;Timer ticks to wait before issuing
  StopTicks EQU 90  ;Timer ticks to wait before issuing
                    ;  Stop & Unlock Unit Requests


;==============================================================================
;INT 13h (DISK BIOS) Related
;==============================================================================
  ;----------------------------------------------------------------------------
  ;MAXIMUM VALUES FOR INT 13H CYLINDER, HEAD, SECTOR NUMBERS
  ;Standard BIOS INT 13h calls are limited to 1024 Cylinders (0-1023),
  ;  255 Heads/Cylinder (0-254), and 63 Sectors/Track (1-63).
  ;This equates to a maximum BIOS LBA Sector Number of
  ;  ((1024*255*63)-1) = FB_03FFh = 16,450,599
  ;At 512 bytes/sector, this is 7.84GiB (8,422,686,208 Bytes)
  ;28-bit LBA (the "low-end" standard) equates to 268,435,456 Sectors or
  ;  128GiB (137,438,953,472 Bytes).  All SCSI drives are compatible with
  ;  28-bit LBA.
  ;SCSI Requests actually have a 32-bit space for LBA's, not just 28 bits.
  ;  Therefore, SCSI Drives may actually allow 32-bit LBA's, for a
  ;  capacity of 4,294,967,296 Sectors or 2TB (TeraBytes)
  ;48-bit LBA (the new "high-end" standard) equates to 2.81^14 Sectors or
  ;  1.44^17 Bytes or 128PB (PetaBytes).
  ;----------------------------------------------------------------------------
  MaxI13Tracks        EQU 1024 ;10 bits, 0-based
  MaxI13Heads         EQU  255 ; 8 bits, 0-based
  MaxI13SectsPerTrack EQU   63 ; 6 bits, 1-based
  MaxI13TotalSects    EQU (MaxI13Tracks*MaxI13Heads*MaxI13SectsPerTrack) ;~16.5M

  MaxI13TrackNum  EQU (MaxI13Tracks-1)     ;Track Numbers are 0-based
  MaxI13HeadNum   EQU (MaxI13Heads-1)      ;Head Numbers are 0-based
  MaxI13SectorNum EQU MaxI13SectsPerTrack  ;Sector Numbers are 1-based
  MaxBIOSLBA      EQU (MaxI13TotalSects-1) ;LBA's are 0-based

  ;----------------------------------------------------------------------------
  ;INT 13h Command Codes (in AH on INT 13h Calls)
  ;----------------------------------------------------------------------------
  I13CmdResetSystem    EQU 00h ;Reset Disk System
  I13CmdLastStatus     EQU 01h ;Gets Status of Last Operation
  I13CmdRead           EQU 02h ;Read Sectors into Memory
  I13CmdWrite          EQU 03h ;Write Disk Sectors
  I13CmdVerify         EQU 04h ;Verify Disk Sectors
  I13CmdFormatTrack    EQU 05h ;Format Track
  I13CmdFormatBad      EQU 06h ;Format Track and Set Bad Sectors Flag
  I13CmdFormatDrive    EQU 07h ;Format Drive Starting at Given Track
  I13CmdGetParams      EQU 08h ;Get Drive Parameters
  I13CmdInitParams     EQU 09h ;Initialize Controller with Drive Parameters
  I13CmdReadLong       EQU 0Ah ;Read Long Sectors
  I13CmdWriteLong      EQU 0Bh ;Write Long Sectors
  I13CmdSeek           EQU 0Ch ;Seek to Cylinder
  I13CmdResetDisk      EQU 0Dh ;Reset Hard Disks
  I13CmdReadBuffer     EQU 0Eh ;Read Sector Buffer
  I13CmdWriteBuffer    EQU 0Fh ;Write Sector Buffer
  I13CmdCheckReady     EQU 10h ;Check if Drive Ready
  I13CmdRecalibrate    EQU 11h ;Recalibrate Drive
  I13CmdRAMDiag        EQU 12h ;Controller RAM Diagnostic
  I13CmdDriveDiag      EQU 13h ;Drive Diagnostic
  I13CmdContDiag       EQU 14h ;Controller Diagnostics
  I13CmdGetDiskType    EQU 15h ;Get Disk Type
  I13CmdDetChange      EQU 16h ;Detect Disk Change
  I13CmdSetDiskType    EQU 17h ;Set Disk Type for Format
  I13CmdSetMediaType   EQU 18h ;Set Media Type for Format
  I13CmdESDIPark       EQU 19h ;ESDI - Park Heads
  I13CmdESDIFormat     EQU 1Ah ;ESDI - Format Unit
  I13CmdESDIGetMfg     EQU 1Bh ;ESDI - Get Manufacturing Header
  I13CmdESDIVarious    EQU 1Ch ;ESDI - Various SubCommands in AL Register
  I13CmdATAPIGetFmt    EQU 20h ;ATAPI - Get Current Media Format
  I13CmdATAPIReadMult  EQU 21h ;ATAPI - Read Multiple Disk Sectors
  I13CmdATAPIWriteMult EQU 22h ;ATAPI - Write Multiple Disk Sectors
  I13CmdPS1SetCtlFeat  EQU 23h ;PS/1 & PS/2 - Set Controller Features
  I13CmdPS1SetMultMode EQU 24h ;PS/1 & PS/2 - Set Multiple Mode
  I13CmdPS1IdentDrive  EQU 25h ;PS/1 & PS/2 - Identify Drive
  I13CmdXInstallCk     EQU 41h ;Extended Installation Check
  I13CmdXRead          EQU 42h ;Extended Read
  I13CmdXWrite         EQU 43h ;Extended Write
  I13CmdXVerify        EQU 44h ;Extended Verify Sectors
  I13CmdXLockUnlock    EQU 45h ;Extended Lock/Unlock Drive
  I13CmdXEjectMedia    EQU 46h ;Extended Eject Media
  I13CmdXExtSeek       EQU 47h ;Extended Seek
  I13CmdXGetDrvParams  EQU 48h ;Extended Get Drive Parameters
  I13CmdXMediaChange   EQU 49h ;Extended Media Change
  I13CmdIssueSCSIReq   EQU 51h ;Issue SCSI Request (new function we've added)

  ;----------------------------------------------------------------------------
  ;INT 13h Error Codes (in AH on INT 13h Returns)
  ;----------------------------------------------------------------------------
  I13ErrNone        EQU 000h ;No error (success)
  I13ErrInvalidFunc EQU 001h ;Invalid function in AH or invalid parameter
  I13ErrNoAddrMark  EQU 002h ;Address mark not found
  I13ErrWriteProt   EQU 003h ;Disk write-protected
  I13ErrNoSector    EQU 004h ;Sector not found/read error
  I13ErrReset       EQU 005h ;Reset failed (hard disk)
  I13ErrVerify      EQU 005h ;Data did not verify correctly (TI Professional PC)
  I13ErrDiskChanged EQU 006h ;Disk changed (floppy)
  I13ErrParameter   EQU 007h ;Drive parameter activity failed (hard disk)
  I13ErrDMAOverrun  EQU 008h ;DMA overrun
  I13ErrDMABoundary EQU 009h ;Data boundary error (attempted DMA across 64K boundary or >80h sectors)
  I13ErrBadSector   EQU 00Ah ;Bad sector detected (hard disk)
  I13ErrBadTrack    EQU 00Bh ;Bad track detected (hard disk)
  I13ErrInvMedia    EQU 00Ch ;Unsupported track or invalid media
  I13ErrInvSectors  EQU 00Dh ;Invalid number of sectors on format (PS/2 hard disk)
  I13ErrCtlAddrMark EQU 00Eh ;Control data address mark detected (hard disk)
  I13ErrDMAArbrit   EQU 00Fh ;DMA arbitration level out of range (hard disk)
  I13ErrCRCECC      EQU 010h ;Uncorrectable CRC or ECC error on read
  I13ErrECCCorrect  EQU 011h ;Data ECC corrected (hard disk)
  I13ErrController  EQU 020h ;Controller failure
  I13ErrXNoMedia    EQU 031h ;No media in drive (IBM/MS INT 13 extensions)
  I13ErrCMOS        EQU 032h ;Incorrect drive type stored in CMOS (Compaq)
  I13ErrSeekFail    EQU 040h ;Seek failed
  I13ErrTimeout     EQU 080h ;Timeout (Drive Not Ready of Not Present)
  I13ErrNotReady    EQU 0AAh ;Drive not ready (hard disk)
  I13ErrXUnlocked   EQU 0B0h ;Volume not locked in drive (INT 13 extensions)
  I13ErrXLocked     EQU 0B1h ;Volume locked in drive (INT 13 extensions)
  I13ErrXNotRemove  EQU 0B2h ;Volume not removable (INT 13 extensions)
  I13ErrXInUse      EQU 0B3h ;Volume in use (INT 13 extensions)
  I13ErrXLockCount  EQU 0B4h ;Lock count exceeded (INT 13 extensions)
  I13ErrXEject      EQU 0B5h ;Valid eject request failed (INT 13 extensions)
  I13ErrXReadProt   EQU 0B6h ;Volume present but read protected (INT 13 extensions)
  I13ErrUndefined   EQU 0BBh ;Undefined error (hard disk)
  I13ErrWriteFault  EQU 0CCh ;Write fault (hard disk)
  I13ErrStatusReg   EQU 0E0h ;Status register error (hard disk)
  I13ErrSense       EQU 0FFh ;Sense operation failed (hard disk)

  ;----------------------------------------------------------------------------
  ;Offsets on Stack for INT 13h Registers
  ;----------------------------------------------------------------------------
  I13StkCFlag EQU   6 ;Callers Flags
  I13StkCCS   EQU   4 ;Callers CS
  I13StkCIP   EQU   2 ;Callers IP
  I13StkBP    EQU   0 ;DS at start of Int 13h Call
  I13StkOFlag EQU  -2 ;Flags at start of Int 13h Call
  I13StkDS    EQU  -4 ;DS at start of Int 13h Call
  I13StkSI    EQU  -6 ;SI at start of Int 13h Call
  I13StkAX    EQU  -8 ;AX at start of Int 13h Call


;==============================================================================
;INT 25h/26h Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Error Codes returned by INT 25h/INT 26h
  ;----------------------------------------------------------------------------
  ;----------------------------------------------------------------------------
  ;Error Codes in AH (Bitmapped?)
  ;----------------------------------------------------------------------------
  I25ErrAHBadCmd    EQU 01h ;Bad Command
  I25ErrAHBadAddr   EQU 02h ;Bad Address Mark
  I25ErrAHWriteProt EQU 03h ;Write Protected Disk (INT 26h Only)
  I25ErrAHNoSector  EQU 04h ;Requested Sector Not Found
  I25ErrAHDMAFail   EQU 08h ;DMA Failure
  I25ErrAHBadCRC    EQU 10h ;Data Error (Bad CRC)
  I25ErrAHCtrlFail  EQU 20h ;Controller Failed
  I25ErrAHSeekFail  EQU 40h ;Seek Operation Failed
  I25ErrAHTimeout   EQU 80h ;Device Failed to Respond (Timeout)

  ;----------------------------------------------------------------------------
  ;Error Codes in AL
  ;----------------------------------------------------------------------------
  I25ErrALWriteProt EQU 00h ;Write-Protection Violation Attempted
  I25ErrALUnknUnit  EQU 01h ;Unknown Unit for Driver
  I25ErrALNotReady  EQU 02h ;Drive Not Ready
  I25ErrALUnknCmd   EQU 03h ;Unknown Command Given to Driver
  I25ErrALBadCRC    EQU 04h ;Data Error (Bad CRC)
  I25ErrALStrucLen  EQU 05h ;Bad Device Driver Request Structure Length
  I25ErrALSeekErr   EQU 06h ;Seek Error
  I25ErrALUnknMedia EQU 07h ;Unknown Media Type (non-DOS Disk)
  I25ErrALNoSector  EQU 08h ;Sector Not Found
  I25ErrALNoPaper   EQU 09h ;Printer Out of Paper
  I25ErrALWrite     EQU 0Ah ;Write Fault
  I25ErrALRead      EQU 0Bh ;Read Fault
  I25ErrALGeneral   EQU 0Ch ;General Failure
  I25ErrALShare     EQU 0Dh ;Sharing Violation (DOS 3+)
  I25ErrALLock      EQU 0Eh ;Lock Violation (DOS 3.0+)
  I25ErrALWrongDisk EQU 0Fh ;Invalid Disk Change / Wrong Disk
  I25ErrALFCB       EQU 10h ;FCB Unavailable (DOS 3.0+)
  I25ErrALUncMedia  EQU 10h ;Uncertain Media
  I25ErrALShareBuff EQU 11h ;Sharing Buffer Overflow (DOS 3.0+)
  I25ErrALCharInt   EQU 11h ;Character Call Interrupted
  I25ErrALCodePage  EQU 12h ;Code Page Mismatch (DOS 4.0+)
  I25ErrALNoInput   EQU 13h ;Out of Input (DOS 4.0+)
  I25ErrALDiskSpace EQU 14h ;Insufficient Disk Space (DOS 4.0+)


;==============================================================================
;USB Mass-Storage Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special Control Requests sent to Bulk-Only Mass Storage Devices
  ;----------------------------------------------------------------------------
  SRRQResetBulkDvc EQU 255 ;Reset Bulk Device
  SRRQGetMaxLUN    EQU 254 ;Get Maximum Logical Unit Number
                           ;  May Return STALL if only one LUN

  ;----------------------------------------------------------------------------
  ;Special Control Requests sent to Control/Bulk/Interrupt Mass Storage Devices
  ;----------------------------------------------------------------------------
  SRRQADSC EQU 0 ;Accept Device-Specific Command

  ;----------------------------------------------------------------------------
  ;Maximum Delay during Drive Initialization process
  ;----------------------------------------------------------------------------
  MaxDelay EQU 60 ;60 seconds


;==============================================================================
;SCSI Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Number of Bytes in a Standard SCSI Request Sense Response
  ;----------------------------------------------------------------------------
  SReqSenseRespSize EQU 18

  ;----------------------------------------------------------------------------
  ;Number of Possible Bytes returned by a Format Capacities Request
  ;----------------------------------------------------------------------------
  FmtCapacityRespSize EQU 0FCh

  ;----------------------------------------------------------------------------
  ;Many disks will only accept a Mode Sense Request with a requested
  ;  data size of 192, even though they never send that many bytes.
  ;  On those disks, putting ion the "correct" size (the number of bytes
  ;  that you know will actually be returned) results in an error.
  ;  Go Figure.
  ;----------------------------------------------------------------------------
  MSenseRespSize EQU 192

  ;----------------------------------------------------------------------------
  ;Number of Entries in the ASC/Q Buffer Table for each Disk
  ;----------------------------------------------------------------------------
  ASCQBuffEntries EQU 10


;==============================================================================
;USB Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Maximum number of USB Devices (Interfaces) we can control
  ;A single Device can have multiple LUNs, and a single LUN can have more
  ;  than one partition, so a single Device can be associated with multiple
  ;  Drive Letters.
  ;----------------------------------------------------------------------------
  MaxDevices EQU 8

  ;----------------------------------------------------------------------------
  ;Maximum number of Disk (LUNs) we can control
  ;  Each of these will be associated with an INT 13h Drive Number
  ;----------------------------------------------------------------------------
  MaxDisks EQU 16

  ;----------------------------------------------------------------------------
  ;Maximum Number of Drive Letters we can assign
  ;  Each drive is association with a partition on a disk
  ;----------------------------------------------------------------------------
  MaxDrives EQU 16

  ;----------------------------------------------------------------------------
  ;Maximum number of entries in Bad (incompatible) Device Table
  ;This needs to include "incompatible" Drives, like those with no
  ;  DOS partitions on them.  Therefore, it needs to be pretty big to
  ;  handle any unusal drives.  As long as a Drive has at least one
  ;  valid Partition, it won't show up here.
  ;----------------------------------------------------------------------------
  MaxBadDevices EQU 20

  ;----------------------------------------------------------------------------
  ;General
  ;----------------------------------------------------------------------------
  Int14RequestSize EQU 64 ;Size of Int 14 USB Request Data Structure

  ;----------------------------------------------------------------------------
  ;Maximum Descriptor Sizes
  ;----------------------------------------------------------------------------
;  MaxDescriptorSize EQU 256 ;Max size of Device/Config Descriptors
  MaxDescriptorSize EQU 512 ;Max size of Device/Config Descriptors

  ;----------------------------------------------------------------------------
  ;USB Descriptor Types
  ;----------------------------------------------------------------------------
  DescrTypeDevice    EQU 01h ;Device
  DescrTypeConfig    EQU 02h ;Configuration
  DescrTypeString    EQU 03h ;String
  DescrTypeInterface EQU 04h ;Interface
  DescrTypeEndPoint  EQU 05h ;EndPoint
  DescrTypeDvcQual   EQU 06h ;Device Qualifier
  DescrTypeOtherSpd  EQU 07h ;Other Speed Configuration
  DescrTypeIntfPower EQU 08h ;Interface Power
  DescrTypeOnTheGo   EQU 09h ;On-the-Go
  DescrTypeDebug     EQU 0Ah ;Debug
  DescrTypeIntfAssoc EQU 0Bh ;Interface Association
  ;Types 12 - 17 (0Ch - 11h) are added for Wireless USB
  DescrTypeWSecurity EQU 0Ch ;Wireless USB Security
  DescrTypeWKey      EQU 0Dh ;Wireless USB Key
  DescrTypeWEncrType EQU 0Eh ;Wireless USB Encryption Type
  DescrTypeWBOS      EQU 0Fh ;Wireless USB Binary-device Object Store
  DescrTypeWDvcCap   EQU 10h ;Wireless USB Device Capability
  DescrTypeWEndPtCmp EQU 11h ;Wireless USB Endpoint Companion

  ;----------------------------------------------------------------------------
  ;USB-Defined Device and Interface Classes, SubClasses, and Protocols
  ;----------------------------------------------------------------------------
  DvcClassNone         EQU   0  ;Device Class = None
  DvcSubClassNone      EQU   0  ;Device SubClass = None
  DvcProtocolNone      EQU   0  ;Device Protocol = None
  IntfClassMassStorage EQU   8  ;Interface Class = Mass Storage
  IntfSubClassUFI      EQU   4  ;Interface SubClass = USB Floppy Interface
  IntfSubClass8070i    EQU   5  ;Interface SubClass = SFF-8070i (ATAPI)
  IntfSubClassSCSI     EQU   6  ;Interface SubClass = SCSI Transparent
  IntfSubClassAny      EQU 0FFh ;Interface SubClass = Any
  IntfProtocolCBI      EQU   0  ;Interface Protocol = Control/Bulk/Interrupt
  IntfProtocolCtrlBulk EQU   1  ;Interface Protocol = Control/Bulk
  IntfProtocolBulkOnly EQU  50h ;Interface Protocol = Bulk Only (Zip)
  IntfProtocolAny      EQU 0FFh ;Interface Protocol = Any

  ;----------------------------------------------------------------------------
  ;Possible Error Codes to return to calling program on completion of TD
  ;----------------------------------------------------------------------------
  TDStsOK             EQU 0000h ;ACK Received (TD completed OK / no errors)
  TDStsNAKReceived    EQU 0001h ;NAK Received
  TDStsStalled        EQU 0002h ;TD is Stalled
  TDStsTimeout        EQU 0004h ;TD has timed out (Bulk/Control)
  TDStsOverDue        EQU 0008h ;TD is OverDue (Int/Isoch)
  TDStsShortPacket    EQU 0010h ;TD Short Packet Detected
  TDStsBabbleDetected EQU 0020h ;Babble Detected
  TDStsCRCTOReceived  EQU 0040h ;CRC/TimeOut Error Received
  TDStsBitStuffError  EQU 0080h ;Rx Data contained > 6 ones in a row
  TDStsDataBuffErr    EQU 0100h ;Data Buffer Error
  TDStsControlSetup   EQU 1000h ;Error actually occurred during Control Setup
  TDStsDvcRemoved     EQU 2000h ;Device removed while TD was in progress
  TDStsLargeCallErr   EQU 8000h ;Error during Large Call

  ;----------------------------------------------------------------------------
  ;Statuses sent by Host to USB Device Owners
  ;----------------------------------------------------------------------------
  ;Device Connect/Disconnect
  OwnerCallNewDvc   EQU 0001h ;A new Matching Device has been attached
  OwnerCallDvcDisc  EQU 0002h ;Registered Device has been disconnected
  OwnerCallDvc0Disc EQU 0003h ;Matching Unregistered Device Disconnected
  OwnerCallDontLook EQU 0007h ;Stop Looking for New Devices for ~5 seconds
  ;Device Enable/Disable/Reset/Suspend/Resume/Power
  OwnerCallDvcEnable   EQU 0008h ;Device Enabled
  OwnerCallDvcDisable  EQU 0009h ;Device Disabled
  OwnerCallDvcReset    EQU 000Ah ;Device Resetting
  OwnerCallDvcSuspend  EQU 000Bh ;Device Suspended
  OwnerCallDvcResume   EQU 000Ch ;Device Resumed
  OwnerCallDvcPwrOn    EQU 000Dh ;Device Power On
  OwnerCallDvcPwrOff   EQU 000Eh ;Device Power Off
  OwnerCallDvcPwrReset EQU 000Fh ;Device Power Reset
  ;Host Connect/Disconnect/Error
  OwnerCallNewHost     EQU 0011h ;A new Host Driver has been Installed
  OwnerCallHostDisc    EQU 0012h ;An existing Host Driver has been Uninstalled
  OwnerCallHostHWErr   EQU 0017h ;Host System/Processor Error (Host will Reset)
  ;Host Run/Stop/Reset/Suspend/Resume
  OwnerCallHostRun     EQU 0018h ;Host Running
  OwnerCallHostStop    EQU 0019h ;Host Stopped
  OwnerCallHostReset   EQU 001Ah ;Host Reset
  OwnerCallHostSuspend EQU 001Bh ;Host Suspended
  OwnerCallHostResume  EQU 001Ch ;Host Resumed
  OwnerCallHostDebug   EQU 001Dh ;Host in Debug Mode
  OwnerCallHostSST     EQU 001Eh ;Host Single-Stepped
  ;Timing Changes
  OwnerCallTimingChg   EQU 0021h ;Timing Change on Host
  ;Upstream Device Changes
  OwnerCallDvcDiscUS     EQU (OwnerCallDvcDisc OR 0080h)     ;Dvc Disc Upstream
  OwnerCallDvcEnableUS   EQU (OwnerCallDvcEnable OR 0080h)   ;Dvc Enable Upstream
  OwnerCallDvcDisableUS  EQU (OwnerCallDvcDisable OR 0080h)  ;Dvc Disable Upstream
  OwnerCallDvcResetUS    EQU (OwnerCallDvcReset OR 0080h)    ;Dvc Reset Upstream
  OwnerCallDvcSuspendUS  EQU (OwnerCallDvcSuspend OR 0080h)  ;Dvc Suspend Upstream
  OwnerCallDvcResumeUS   EQU (OwnerCallDvcResume OR 0080h)   ;Dvc Resume Upstream
  OwnerCallDvcPwrOnUS    EQU (OwnerCallDvcPwrOn OR 0080h)    ;Dvc PwrOn Upstream
  OwnerCallDvcPwrOffUS   EQU (OwnerCallDvcPwrOff OR 0080h)   ;Dvc PwrOff Upstream
  OwnerCallDvcPwrResetUS EQU (OwnerCallDvcPwrReset OR 0080h) ;Dvc PwrReset Upstream


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;STRUCTURES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;==============================================================================
;TSR Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;This is a Structure to use at the beginning of Interrupt Routines in
  ;  TSR's.  Using this header, along with the appropriate code,
  ;  will allow the installation and removal of TSR's (actually,
  ;  the redirected interrupt vectors of a TSR) in any order.
  ;Note that the real Interrupt code MUST IMMEDIATELY follow this Header!!
  ;----------------------------------------------------------------------------
  IntHdr STRUC
    HdwreRst  DB      0CBh ;Hardware Reset Routine (CBh = RETF)
    CodeJmp   DW    010EBh ;Jump to real Interrupt Handler (JMP ENDS)
    OldVector DD        ?  ;Old interrupt Vector
    Signature DW    0424Bh ;Signature for this type of Interrupt routine
    EOIFlag   DB        0  ;=80h if we issue End-of-Interrupt, else 0
    HdwreJmp  DW    0F4EBh ;Jump to Hardware Reset Routine (JMP HdwreRst)
    FutureUse DB 7 DUP (0) ;Reserved for future use
   ENDS
  IntOfst EQU OFFSET CodeJmp ;Offset from beginning of our Structure


;==============================================================================
;DOS Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Program Segment Prefix
  ;----------------------------------------------------------------------------
  PSPStruc      STRUC
    PSPDOSExit     DW       20CDh ;Int 20h Call
    PSPNextSegment DW          ?  ;Segment of First Byte of Memory beyond Program
    PSPCPMCall5    DB   6 DUP (?) ;CPM Far Call 5
    PSPInt22Addr   DD          ?  ;Stored Int 22h Handler
    PSPInt23Addr   DD          ?  ;Stored Int 23h (Ctrl-Break) Handler
    PSPInt24Addr   DD          ?  ;Stored Int 23h (Critical Error) Handler
    PSPParentPSP   DW          ?  ;Segment of Parent PSP
    PSPJFT         DB  20 DUP (?) ;Job File Table (20 File Handles)
    PSPEnvirSeg    DW          ?  ;Environment Segment for PSP
    PSPSSSPOnEntry DD          ?  ;Processes SS:SP on Entry to last Int 21h Call
    PSPJFTSize     DW          ?  ;Number of entries in JFT (default = 20)
    PSPJFTPointer  DD          ?  ;Pointer to JFT (Default = PSP:0018h)
    PSPPreviousPSP DD          ?  ;Pointer to previous PSP (Default = FFFF:FFFF)
    PSPFiller1     DB  18 DUP (?) ;Misc stuff used by SHARE, Windows, etc.
                                  ;Memory Below here available to TSR!
    PSPFiller2     DB   2 DUP (?) ;Unused in DOS <= 6.00
    PSPInt21       DW       21CDh ;Int 21h Call
    PSPRETF        DB        0CBh ;RETF Call
    PSPFiller3     DB   9 DUP (?) ;Can be used to make Extended FCB from FCB1
    PSPFCB1        DB  16 DUP (?) ;First File Control Block
    PSPFCB2        DB  16 DUP (?) ;Second File Control Block
    PSPFiller4     DB   4 DUP (?) ;Unused
    PSPCmdLineLen  DB          ?  ;Command Line Length & DTA
    PSPCmdLine     DB 127 DUP (?) ;Command Line String
   ENDS
  PSPStrucSize EQU (TYPE PSPStruc) ;Should be 256 bytes

  ;----------------------------------------------------------------------------
  ;Memory Control Block
  ;----------------------------------------------------------------------------
  MCBStruc STRUC
    MCBID              DB        ?  ;Memory Control Block ID
      MCBIDValid      EQU       'M' ;Memory Block is Valid
      MCBIDLastInList EQU       'Z' ;Memory Block is Last in List
    MCBOwnerID         DW        ?  ;PSP Segment of Owner
                                    ;   0 = Owns Self (Free)
                                    ;   6 = DR-DOS XMS UMB
                                    ;   7 = DR-DOS Excluded Upper Memory (Hole)
                                    ;   8 = Belongs to DOS
                                    ;FFFx = 386Max
    MCBSize            DW        ?  ;Size in Paragraphs
    MCBFiller          DB 3 DUP (?) ;Filler
    MCBOwnerName       DB 8 DUP (?) ;Owner Name
   ENDS
  MCBStrucSize EQU (TYPE MCBStruc) ;Should be 16 bytes

  ;----------------------------------------------------------------------------
  ;Structure needed to Initialize DOS EXEC Function
  ;----------------------------------------------------------------------------
  ParamBlockStruc STRUC
    PBEnvirSegment   DW ? ;Environment Segment to use (0 = Copy Callers Segment)
    PBCmdTailPtr     DD ? ;Pointer to Command Tail
    PBFCB1Offset     DD ? ;Pointer to File Control Block #1
    PBFCB2Offset     DD ? ;Pointer to File Control Block #2
    PBSSSPOnReturn   DD ? ;Holds Childs Initial SS:SP on Return (if AL = 01)
    PBCSIPOnReturn   DD ? ;Holds Entry Point (CS:IP) on Return (if AL = 01)
   ENDS
  ParamBlockSize EQU (TYPE ParamBlockStruc) ;Size of EXEC Parameter Block

  ;----------------------------------------------------------------------------
  ;DTA (Disk Transfer Area) after Find First Matching File (INT 21h, Func 4Eh)
  ;The first several bytes of the DTA are DOS version specific, and
  ;  we don't care about that data anyway.  We only care about the data
  ;  that is documented and the same across all versions of DOS.
  ;----------------------------------------------------------------------------
  FindFirstStruc   STRUC            ;Find First Matching File
    FFVerSpecific     DB 21 DUP (0) ;DOS Version-specific Data
    FFAttribs         DB         ?  ;File Attributes
      FAttrReadOnly  EQU        01h ;Read-Only
      FAttrHidden    EQU        02h ;Hidden
      FAttrSystem    EQU        04h ;System
      FAttrVolume    EQU        08h ;Volume Label
      ;Bit 3 = Execute-only (Novell Netware)
      FAttrDirectory EQU        10h ;Directory
      FAttrArchive   EQU        20h ;Archive
      FAttrUnused    EQU        40h ;Unused
                                    ;DOS 3+ returns this bit set if file
                                    ;  is actually a character device
                                    ;DOS Window underneath Windows XP doesn't
      ;Bit 7 = Delete Pending (OpenDOS, NovellDOS)
      ;      = Shareable (Novell Netware)
   FFTime            DW         ?  ;File Creation Time
    FFDate            DW         ?  ;File Creation Date
    FFSize            DD         ?  ;File Size
    FFName            DB 13 DUP (?) ;ASCIIZ File Name & Extension
   ENDS

   FAttrToUse EQU FAttrHidden+FAttrSystem
     ;Attributes to use in DOS's Find First Matching File Function
     ;DOS ignores the Read-Only and and Archive bits, so they don't matter


;==============================================================================
;Structures: List of Lists, Current Directory Structure, Drive Parameter Block
;==============================================================================

;==============================================================================
;BIOS Parameter Block
;This is sent back and forth between DOS and all Block Device Drivers.
;It is also included in the Boot Sector of all Drives.
;
;This is the structure for a BIOS Parameter Block
;It is used during a Build BPB call to the Device Driver
;This is also in the Boot Sector of the drive, starting at Offset 11
;  (after three bytes of Code and 8 bytes of OEM Name)
;==============================================================================
  BIOSParamBlockStruc  STRUC
    BPBBytesPerSect    DW   ?  ;Number of Bytes per Sector
                               ;Must be a multiple of 32
                               ;Values other than 512 can cause problems!
    BPBSectsPerCluster DB   ?  ;Number of Sectors per Cluster
                               ;Must be a power of 2
    BPBReservedSects   DW   ?  ;Number of Reserved Sectors at start of disk
                               ;  Starting Sector of first FAT (usually 1)
    BPBNumFATs         DB   ?  ;Number of FAT copies (usually 2)
    BPBRootEntries     DW   ?  ;Maximum Number of Root Directory Entries
                               ;  (0 for FAT32)
    BPBNumSects16      DW   ?  ;Total Number of Sectors
                               ;If DOS 4+ and partition > 32MB, set this
                               ;  to 0 and use DWORD value at Offset 15h
    BPBMediaID         DB   ?  ;Media ID (Descriptor) Byte
                               ;    Sec/ Root Totl Sec/
                               ;Sid Clus Entr Sect Trak Diam Trak
      MediaID160k     EQU 0FEh ; SS    1   64  320    8 5.25   40
      MediaID180k     EQU 0FCh ; SS    1   64  360    9 5.25   40
      MediaID200k     EQU 0FCh ; SS    1   64  400   10 5.25   40
      MediaID205k     EQU 0FCh ; SS    1   64  410   10 5.25   41
      MediaID320k     EQU 0FFh ; DS    2  112  640    8 5.25   40
      MediaID360k     EQU 0FDh ; DS    2  112  720    9 5.25   40
      MediaID400k     EQU 0FDh ; DS    2  112  800   10 5.25   40
      MediaID410k     EQU 0FDh ; DS    2  112  820   10 5.25   41
      MediaID720k     EQU 0F9h ; LD    2  112 1440    9 3.5    80
      MediaID800k     EQU 0F9h ; LD    2  112 1600   10 3.5    82
      MediaID820k     EQU 0F9h ; LD    2  112 1640   10 3.5    82
      MediaID1200k    EQU 0F9h ; HD    1  224 2400   15 5.25   80
      MediaID1440k    EQU 0F0h ; HD    1  224 2880   18 3.5    80
      MediaID1476k    EQU 0F0h ; HD    1  224 2952   18 3.5    82
      MediaID2988k    EQU 0F9h ; HD    1  224 2988   18 5.25   83
      MediaID1600k    EQU 0F0h ; HD    1  224 3200   20 3.5    80
      MediaID1640k    EQU 0F0h ; HD    1  224 3280   20 3.5    82
      MediaID1680k    EQU 0F0h ; HD    1  224 3360   21 3.5    80
      MediaID1722k    EQU 0F0h ; HD    1  224 3444   21 3.5    82
      MediaID1743k    EQU 0F0h ; HD    1  224 3486   21 3.5    83
      MediaID2880k    EQU 0F0h ; ED    2  240 5760   36 3.5    80
      MediaID3360k    EQU 0F0h ; ED    2  240 6720   42 3.5    80
      MediaID3486k    EQU 0F0h ; ED    2  240 6792   42 3.5    83
      MediaIDHP995k   EQU 0FAh ;HP 200LX ROM Disk,   16 Sectors/Track
      MediaIDHard     EQU 0F8h ;Hard Drive
      MediaIDOther    EQU 0F0h ;Other Media
      MediaIDNone     EQU 000h ;No Media Installed
    BPBSectsPerFAT16   DW   ?  ;Number of Sectors per FAT (0 if FAT32)
    ;DOS v3+ below this line
    BPBSectsPerTrack   DW   ?  ;Number of Sectors per Track
    BPBNumHeads        DW   ?  ;Number of Heads
    BPBHiddenSects     DD   ?  ;Number of Hidden Sectors (DOS 4+)
                               ;For DOS 3-, this is a Word
                               ;This is the Number of Sectors on the
                               ;  Physical Disk that Precede the Partition
                               ;  Boot Record (including the Master Boot
                               ;  Record and all Partition Records)
    ;DOS 3 is 11 Bytes Reserved after this
    ;DOS v4+ below this line (Extended BIOS Signature)
    BPBNumSects32      DD   ?  ;Number of Sectors (if DOS 4+ &
                               ;  NumSects16 = 0)
   ENDS
  BPBSize EQU (TYPE BIOSParamBlockStruc) ;25 bytes

  BPBBasicSize EQU (BPBSize+6) ;Officially, BPB Size is 31 Bytes
                               ;  (6 Bytes Reserved after 25 byte base)
  BPBFAT32Size EQU 85 ;For FAT32 Device Driver calls (Category 48h instead
                      ;  of 08h), BPB is 53 bytes + 32 bytes reserved

  ;----------------------------------------------------------------------------
  ;Flash drives do not always have an MBR.  They are sometimes formatted as
  ;  a "super floppy", with a simple Volume Boot Record (just like a Floppy)
  ;  instead of an MBR.  We cannot simply assume that a non-UFI Device will
  ;  have an MBR.
  ;
  ;We'll also need to be able to parse out all of the different DOS versions
  ;  of PBR's, since we on occasion need to return the Volume Label for a
  ;  Disk.  Before Version 4, Volume Names were not included on the Disks,
  ;  so we'll need to use "NO NAME    " for those.
  ;
  ;Note also that the structure of the BPB is determined by the OS that was
  ;  used to format the disk, not necessarily the OS that is currently in
  ;  use.  Therefore, we must be able to process all different types.
  ;----------------------------------------------------------------------------

  BPBStrucDOS4  STRUC    ;Structure for a DOS 4+ BPB
    BPB4Common     DB BPBSize DUP (0) ;Basic Structure
    BPB4DriveNum   DB 80h ;Physical Drive Number (usually 80h)
    BPB4Reserved1  DB 00h ;Reserved (0)
    BPB4Signature  DB 29h ;Extended Boot Record Signature
                          ;Some references say this could be 28h (40) or
                          ;  29h (41).  Any other value here indicates
                          ;  non-DOS (like NT)
    BPB4SerialNum  DD  ?  ;Volume Serial Number
    BPB4VolumeName DB 'NO NAME    ' ;Volume Name (NO NAME if never LABELed)
    BPB4FileSystem DB 'FAT16   '    ;ASCII File System Type
    BPB4Reserved2  DB 8 DUP (?)     ;Reserved for Future Use
   ENDS
  BPB4Size EQU (TYPE BPBStrucDOS4) ;59 Bytes

  BPBExtStruc         STRUC ;Structure for an Extended BPB (FAT32)
    BPBXCommon           DB BPBSize DUP (0) ;Basic Structure
    BPBXSectsPerFAT32    DD         ?  ;Sectors/FAT (if SectorsPerFAT16 = 0)
    BPBXFlags            DW         ?  ;Extended Flags
      ;Bits 8-15 = Reserved?
      BPBXNoFATMirror   EQU      0080h ;Do not Mirror Active FAT
      ;Bits 0-4 = Reserved
      BPBXActiveFATMask EQU      000Fh ;Active FAT (if Mirroring Disabled,
                                       ;  0-based)
    BPBXVersion          DW         ?  ;File System Version (0=Win95 OSR2)
    BPBXRootCluster      DD         ?  ;Starting Cluster of Root Dir
    BPBXInfoSectNum      DW         ?  ;File System Information Sector Num
                                       ;  FFFFh = None
    BPBXBkupBootSect     DW         ?  ;Backup Boot Sector Number
                                       ;  FFFFh = None
    BPBXReserved1        DB 12 DUP (0) ;Reserved
    BPBXDriveNum         DB         ?  ;Logical Drive Number
    BPBXReserved2        DB         ?  ;Reserved
    BPBXSignature        DB        29h ;FAT32 Boot Record Signature
    BPBXSerialNum        DD         ?  ;Volume Serial Number
    BPBXVolumeName       DB 'NO NAME    ' ;Volume Name (NO NAME if never LABELed)
    BPBXFileSystem       DB 'FAT32   '    ;ASCII File System Type
   ENDS
  BPBXSize EQU (TYPE BPBExtStruc) ;79 Bytes

  FSISStruc STRUC ;Structure for a FAT32 File System Information Sector
    FSISSignature1    DD 05252_6141h ;First Signature
    FSISReserved1     DB 480 DUP (?) ;Unknown (Always 0?)
    FSISSignature2    DD 07272_4161h ;Second Signature
    FSISFreeClusters  DD          ?  ;Number of Free Clusters (-1 = Unknown)
    FSISRecentCluster DD          ?  ;Most recently allocated Cluster
    FSISReserved2     DB  12 DUP (?) ;Reserved
    FSISReserved3     DW          ?  ;Unknown always null?)
    FSISSignature3    DW      0AA55h ;MBR/VBR/FSIS Signature
    ENDS ;Total size = 512 bytes (1 Sector)

  ;----------------------------------------------------------------------------
  ;Structure returned by DOS Function 52h (Get List of Lists) in ES:[BX]
  ;This is the first several bytes of the Structure (not the entire thing),
  ;  and only applies to DOS 3.1+.  Previous DOS versions are different.
  ;ES returned is the DOS Data Segment.
  ;Not all DOS Clones use all fields here.  Verify they are not 0:0 or -1:-1
  ;  before using the Pointers.
  ;---------------------------------------------------------------------------
  ListOfListsStruc STRUC
    ;-2 = Segment of First Memory Control Block
    LOLDPBPtr       DD ? ;Pointer to first Drive Parameter Block (#1395-2132)
    LOLSFTPtr       DD ? ;*Pointer to first (current?) System File Table (#1639-1642)
    LOLClockPtr     DD ? ;Pointer to CLOCK$ Device Header
    LOLCONPtr       DD ? ;Pointer to CON (STDIN) Device Header
    LOLBytesPerSect DW ? ;Maximum Bytes per Sector of ANY Block Device
    LOLDiskBuffPtr  DD ? ;Pointer to first Disk Buffer (#1650)
    LOLCDSPtr       DD ? ;Pointer to first Current Directory Structure (#1643-4)
    LOLSysFCBPtr    DD ? ;Pointer to first System File Control Block
    LOLNumProtFCB   DW ? ;Number of Protected FCBs (y in CONFIG.SYS FCBS=x,y)
    LOLNumBlockDvc  DB ? ;Number of Block Devices installed
    LOLNumAvailDrv  DB ? ;Number of Available Drive Letters (LASTDRIVE)
                         ;Is also the number of CDS entries
                         ;Is 32 in Windows 9x if no LASTDRIVE in CONFIG.SYS?
    LOLNULDvcHdr    DB 18 DUP (?) ;NUL Device Header (NOT Pointer to Header)
                                  ;NUL is always first Device (#1646)
    LOLNumJoinDrv   DB ? ;Number of JOINed Drives
    ;DOS 4+ are different from each other from here down, and we don't need
    ;  any of this for our program anyway, so we won't include it
   ENDS

  ;----------------------------------------------------------------------------
  ;Current Directory Structure (CDS).  Defined by DOS.
  ;Contiguous Array, LASTRIVE number of entries in the Array
  ;----------------------------------------------------------------------------
  CurrentDirStruc  STRUC
    CDSPathName       DB  67 DUP (0) ;ASCIIZ Path Name (Current Path)
                                     ;  (X:\Path or \\Server\Path)
                                     ;Is REAL Path Name (Not SUBST or JOIN)
                                     ;Should be X:\ for Invalid Drives?
    CDSDriveAttr      DW          ?  ;Drive Attributes (Flags)
      DAttrNetRedir  EQU       8000h ;Uses Network Redirector
      DAttrPhysical  EQU       4000h ;Is a Physical Drive
      DAttrJoin      EQU       2000h ;Drive is JOINed
      DAttrSubst     EQU       1000h ;Drive is SUBSTituted
      DAttrRemovable EQU       0800h ;Removable Media (NT 4.0)
      DAttrHardDrive EQU       0400h ;Hard Drive?? (NT 4.0)
      DAttrNetHide   EQU       0080h ;Hidden from Net Redirectors Assign-list
    CDSDPBPtr         DD          ?  ;Pointer to Drive Parameter Block
    CDSCurrDirClust   DW          ?  ;Starting Cluster of Current Directory
    CDSUnknown1       DD         -1  ;Always seems to be -1 for Local Drives
      ;For Network Drives (including CD-ROMs)
      CDSRedirPtr    EQU OFFSET CDSCurrDirClust[0] ;Pointer to REDIR Record (DW)
      CDSInt5F03Data EQU OFFSET CDSCurrDirClust[4] ;User Data from Func 5F03h (W)
    CDSRootOffset     DW          ?  ;Offset in Path Name of Root Directory
                                     ;  (Normally 2, after the X:)
                                     ;  Offsets in the CDS File Name (SHSUCDX)
                                     ;   %ifdef CDROOT
                                     ;    %define DriveOff       2
                                     ;    %define RootSlashOff   7
                                     ;   %else
                                     ;    %define DriveOff       0
                                     ;    %define RootSlashOff   2
                                     ;   %endif
    ;DOS 4+ beyond this point (not detailed in SHSUCDX)
    CDSDeviceType     DB          ?  ;Device Type: 04h if Network Drive
    CDSRedirBlockPtr  DD          ?  ;Pointer to Redirector/IFS Block
                                     ;  0000_0000h if Native DOS
    CDSIFSScratch     DW          ?  ;Used by IFS Driver
   ENDS
  CDSSize EQU (TYPE CurrentDirStruc) ;Size of Structure

  ;----------------------------------------------------------------------------
  ;Drive Parameter Block (DPB).  Defined by DOS.
  ;This particular Structure only applies to DOS 4+?
  ;Some parts of the structure are different in previous DOS versions.
  ;DRVEXCH simply swaps DPB's to swap drive letters.
  ;----------------------------------------------------------------------------
  DriveParamBlockStruc STRUC
    DPBDriveNum         DB -1  ;Drive Number (0=A, 1=B, ...) -1 = Unused
    DPBUnitNum          DB  ?  ;Unit Number within Device Driver
    DPBBytesPerSect     DW  ?  ;Bytes per Sector
    DPBHiSectInCluster  DB  ?  ;Highest Sector Number within a Cluster
                               ;  (sectors Per Cluster - 1)
    DPBSectorShift      DB  ?  ;Shift count needed to convert Clusters to Sectors
    DPBReservedSects    DW  ?  ;Number of Reserved Sectors at beginning of Drive
                               ;  (Boot Sectors)
    DPBNumFATs          DB  ?  ;Number of FATs (usually 2)
    DPBRootEntries      DW  ?  ;Number of Root Directory Entries
    DPBFirstUserSector  DW  ?  ;First Sector Number that contains "real" data
    DPBHighestCluster   DW  ?  ;Highest Cluster Number
                               ;  (Number of Data Clusters + 1)
                               ;  If <= 0FF6h, FAT12, else FAT16
    DPBSectorsPerFAT    DW  ?  ;Number of Sectors per FAT
                               ;  Prior to DOS 4, this was a Byte
    DPBRootSector       DW  ?  ;Sector Number of First (Root) Directory
    DPBDvcDriverPtr     DD  ?  ;Device Driver Header Pointer (#1646)
    DPBMediaID          DB  ?  ;Media ID (#1356)
    DPBAccessed         DB  ?  ;Has the Drive been accessed?
      AccessedYes      EQU  0  ;The Drive has been Accessed
      AccessedNo       EQU -1  ;The Drive has NOT been accessed
    DPBNextDPBPtr       DD  ?  ;Pointer to next Drive Parameter Block
                               ;  (-1 = end of list)
    DPBStartCluster     DW  ?  ;Cluster at which to start search for free space
                               ;  when writing (usually last cluster allocated)
                               ;  (for DOS 3+)
                               ;In DOS 2, = Start Cluster of Current Directory
                               ;  (0 = Root, -1 = Unknown)
    DPBFreeClustersL    DW  ?  ;Number of Free Clusters left (-1 = Unknown)
                               ;  For DOS 3+
                               ;In DOS 2, is 64-byte ASCIIZ Current Directory
  ;Below here is Extended DPB (FAT32 drives only MS-DOS & FreeDOS)
    DPBFreeClustersH    DW  ?  ;Number of Free Clusters left (-1 = Unknown)
                               ;  High Word
    DPBFATMirror        DW  ?  ;Active FAT/Mirroring
      DPBFATFATNum     EQU 0Fh ;0-based FAT number of active FAT
                               ;  (only valid if mirroring is disabled)
      ;bits 4-6 = Reserved (0)
      DPBFATNoMirror   EQU 80h ;Do not Mirror Active FAT to Inactive FATs
      ;bits 8-15 = Reserved (0?)
    DPBFSysInfoSect     DW  ?  ;File System Information Sector (-1 = None)
    DPBBkupBootSect     DW  ?  ;Backup Boot Sector (-1 = None)
    DPBFirstClusterSect DD  ?  ;First Sector Number of First Cluster
    DPBMaxCluster       DD  ?  ;Maximum Cluster Number
    DPBNumFATSectors    DD  ?  ;Number of Sectors occupied by FAT
    DPBRootCluster      DD  ?  ;Cluster number of start of Root Directory
    DPBSearchCluster    DD  ?  ;Cluster number to start searching for free space
    DPBFiller           DB  ?  ;To align at even addresses
   ENDS
  DPBSize EQU (TYPE DriveParamBlockStruc) ;62 bytes (with extra Filler Byte)

  ;----------------------------------------------------------------------------
  ;DDSC Structure.  This is EDR-DOS's equivalent to DOS's Extended DPB.
  ;This is a few bytes larger than the EDPB, so we need to allow room
  ;  for this in our data area.  Most of the data in here gets filled
  ;  in by DOS, so we don't need to worry too much about the actual
  ;  structure.  The first several bytes are the same as the MS-DOS
  ;  FAT12/FAT16 DPB anyway, which are the only ones we change.
  ;----------------------------------------------------------------------------
  DDSCStruc STRUC
    DDSC_Unit     DB ? ;Absolute drive number
    DDSC_RUnit    DB ? ;Relative unit number
    DDSC_SecSize  DW ? ;Sector size in bytes
    DDSC_ClMsk    DB ? ;Sectors/cluster - 1
    DDSC_ClShf    DB ? ;Log2 (sectors/cluster)
    DDSC_FATAddr  DW ? ;Sector address of FAT
    DDSC_NFATs    DB ? ;# of FAT copies
    DDSC_DirEnt   DW ? ;Size of root directory
    DDSC_DatAddr  DW ? ;Sector address of cluster #2
    DDSC_NClstrs  DW ? ;# of clusters on disk
    DDSC_NFATRecs DW ? ;# of sectors per FAT
    DDSC_DirAddr  DW ? ;Sector address of root dir
    DDSC_DevHead  DD ? ;Device driver header
    DDSC_Media    DB ? ;Current media byte
    DDSC_First    DB ? ;"drive never accessed" flag
    DDSC_Link     DD ? ;Next drive's DDSC
    DDSC_Block    DW ? ;Next block to allocate
    DDSC_Free     DW ? ;Total free clusters on drive
   ;Below here everything is different than for MS-DOS EDPB
   ;MS-DOS just adds a second Word for the Total Free Clusters, instead of
   ;  adding a complete second DWord, and MS-DOS does not have a version
   ;  number at teh end.
    DDSC_BFree    DD ? ;Total free clusters on drive (32-bit)
    DDSC_FSFlags  DW ? ;FAT mirroring flags
    DDSC_FSInfo   DW ? ;Sector number of file system info block
    DDSC_BootBak  DW ? ;Sector number of backup boot sector
    DDSC_BDatAddr DD ? ;Sector address of cluster #2 (32-bit)
    DDSC_BClstrs  DD ? ;# of clusters on disk (32-bit)
    DDSC_BFATRecx DD ? ;# of sectors per FAT (32-bit)
    DDSC_FSRoot   DD ? ;Starting cluster of root directory
    DDSC_BBlock   DD ? ;Next block to allocate (32-bit)
    DDSC_FSVer    DW ? ;Version of file system
    DDSC_Filler   DB ? ;To align at even addresses
   ENDS
  DDSCSize EQU (TYPE DDSCStruc) ;66 bytes (with extra Filler Byte)

  ;----------------------------------------------------------------------------
  ;File Control Block
  ;----------------------------------------------------------------------------
  XFCBStruc STRUC                   ;Disk Transfer Area (Standard/Extended)
    FCBDriveNumber     DB        ?  ;Drive Number (0 = Default, 1 = A, etc.)
     FCBExtendedFlag  EQU      0FFh ;Indicates Extended FCB (XFCB)
                                    ;  Later versions of DOS are always this??
    XFCBReserved1      DB 5 DUP (?) ;Reserved
    XFCBFileAttr       DB        ?  ;File Attributes
      FAttrReadOnly   EQU       01h ;Read Only
      FAttrHidden     EQU       02h ;Hidden
      FAttrSystem     EQU       04h ;System
      FAttrVolume     EQU       08h ;Volume Label
       FAttrExecOnly  EQU       08h ;Execute-Only (Novell Netware)
      FAttrDirectory  EQU       10h ;Directory
      FAttrArchive    EQU       20h ;Archive
      FAttrUnused     EQU       40h ;Unused
      FAttrPending    EQU       80h ;Pending Deletion (Novell DOS, OpenDOS)
       FAttrShareable EQU       80h ;Shareable (Novell Netware)
    ;If not an Extended FCB (XFCB), this is at the beginning of the structure
    ;  (everything is shifted up by 7 bytes)
    XFCBDriveNumber    DB        ?  ;Drive Number (0 = Default, 1 = A, etc.)
    XFCBFileName       DB 8 DUP (?) ;File Name (blank-padded)
    XFCBFileExtension  DB 3 DUP (?) ;File Extension (blank-padded)

    XFCBCurrentBlock   DW        ?  ;Current Block Number
    XFCBLogRecordSize  DW        ?  ;Logical Record Size
    XFCBFileSize       DD        ?  ;File Size
    XFCBLastWriteDate  DW        ?  ;Date of Last Write
      FDateYearMask   EQU    0FE00h ;Bits 15-09 = Year - 1980
      FDateMonthMask  EQU     01E0h ;Bits 08-05 = Month
      FDateDayMask    EQU     001Fh ;Bits 04-00 = Day
    XFCBLastWriteTime  DW        ?  ;Time of Last Write
      FTimeHourMask   EQU    0F800h ;Bits 15-11 = Hours (0-23)
      FTimeMinuteMask EQU     07E0h ;Bits 10-05 = Minutes
      FTimeSec2Mask   EQU     001Fh ;Bits 04-00 = Seconds / 2
    XFCBReserved2      DB 8 DUP (?) ;Reserved
    XFCBBlkRecordNum   DB        ?  ;Record Number within current Block
    XFCBRanRecordNum   DD        ?  ;Random Access Record Number
                                    ;  if record size > 64 bytes, no high byte)
   ENDS
  XFCBStrucSize EQU (TYPE XFCBStruc) ;44 Bytes


;==============================================================================
;Floppy Drive Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Data stored at INT 1Eh Vector
  ;NOTES: If this data is changed or moved, INT 13h/AH=00h should be called
  ;         to re-program the Floppy Drive
  ;----------------------------------------------------------------------------
  Int1EStruc STRUC
    Int1ESpecify1        DB   ?  ;Specify Byte #1
      I1ES1StepRateMask EQU 0F0h ;Step Rate in bits 4-7
        IE1Step32ms     EQU 000h ;Step Rate = 32ms
        IE1Step30ms     EQU 010h ;Step Rate = 30ms
        IE1Step28ms     EQU 020h ;Step Rate = 28ms
        IE1Step26ms     EQU 030h ;Step Rate = 26ms
        IE1Step24ms     EQU 040h ;Step Rate = 24ms
        IE1Step22ms     EQU 050h ;Step Rate = 22ms
        IE1Step20ms     EQU 060h ;Step Rate = 20ms
        IE1Step18ms     EQU 070h ;Step Rate = 18ms
        IE1Step16ms     EQU 080h ;Step Rate = 16ms
        IE1Step14ms     EQU 090h ;Step Rate = 14ms
        IE1Step12ms     EQU 0A0h ;Step Rate = 12ms
        IE1Step10ms     EQU 0B0h ;Step Rate = 10ms
        IE1Step08ms     EQU 0C0h ;Step Rate = 08ms
        IE1Step06ms     EQU 0D0h ;Step Rate = 06ms
        IE1Step04ms     EQU 0E0h ;Step Rate = 04ms
        IE1Step02ms     EQU 0F0h ;Step Rate = 02ms
      I1ES1HUnloadMask  EQU 00Fh ;Head Unload Time (0Fh = 240ms)
    Int1ESpecify2        DB   ?  ;Specify Byte #2
      I1ES2HLoadMask    EQU 0FEh ;Head Load Time (01h = 4ms, default = 15ms)
      I1ES2NonDMAMode   EQU  01h ;Non-DMA Mode (always 0)
    Int1EOffDelay        DB   ?  ;Delay until motor turns off (Timer Ticks)
    Int1EBytesPerSect    DB   ?  ;Bytes Per Sector
      I1EBPS0128        EQU  00h ;128 Bytes Per Sector
      I1EBPS0256        EQU  01h ;256 Bytes Per Sector
      I1EBPS0512        EQU  02h ;512 Bytes Per Sector
      I1EBPS1024        EQU  03h ;1024 Bytes Per Sector
    Int1ESectsPerTrack   DB   ?  ;Sectors Per Track (Maximum if variable)
    Int1EGapLength       DB   ?  ;Length of Gap between Sectors
                                 ;  (5.25" = 2Ah, 3.5" = 1Bh)
    Int1EDataLength      DB   ?  ;Data Length (ignored if BPS is non-zero)
    Int1EFmtGapLength    DB   ?  ;Gap Length when Formatting
                                 ;  (5.25" = 50h, 3.5" = 6Ch)
    Int1EFormatFiller    DB   ?  ;Format Filler Byte (default = F6h)
    Int1ESettleTime      DB   ?  ;Head Settle Time (milliseconds)
    Int1EStartTime       DB   ?  ;Motor Start Time (1/8 seconds)
   ENDS


;==============================================================================
;BIOS Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Fixed Disk Parameter Structure
  ;Two of these are stored in memory, one for the first hard drive (80h),
  ;  pointed at by INT 41h in the Interrupt Vector Table, and the other
  ;  for the second hard drive (81h), pointed at by INT 46h in the IVT.
  ;Theoretically, modern programs should not ever look at these tables
  ;  directly, but instead should rely on INT 13h functions to tell them
  ;  the disk parameters.  Unfortunately, some programs do not do what
  ;  they're supposed to.
  ;----------------------------------------------------------------------------
  FDPTStruc STRUC
    FDPTNumTracks     DW  ?  ;Number of Tracks (Cylinders), Max 1024
    FDPTNumHeads      DB  ?  ;Number of Heads, Max 255
    FDPTReducedCyl    DW  ?  ;Starting Reduced Write Current Cylinder (XT Only)
    FDPTPrecompCyl    DW  ?  ;Starting Precompensation cylinder (Obsolete)
    FDPTMaxECCBurst   DB  ?  ;Maximum ECC Burst Length (XT Only)
    FDPTCtlByte       DB  ?  ;Control Byte (following bit definitions are AT+)
      ;Bits 0-2 = Reserved (0)
      FDPTHeads8Plus EQU 08h ;More than 8 Heads
      ;Bit 4 = Reserved (0)
      FDPTDefectMap  EQU 20h ;Mfg Defect Map stored on Max Track + 1
      FDPTNoECCRetry EQU 40h ;Disable ECC retries
      FDPTNoAccRetry EQU 80h ;Disable Access retries
    FDPTStdTimeout    DB  ?  ;Standard Timeout (XT Only)
    FDPTFmtTimeout    DB  ?  ;Formatting Timeout (XT & WD1002 Only)
    FDPTChkTimeout    DB  ?  ;Check Drive Timeout (XT & WD1002 Only)
    FDPTLandingZone   DW  ?  ;Landing Zone Cylinder (Obsolete)
    FDPTSectsPerTrack DB  ?  ;Number of Sectors Per Track, Max 63
    FDPTPAD           DB  ?  ;PAD/Reserved
   ENDS ;16 bytes

  ;----------------------------------------------------------------------------
  ;Enhanced Disk Parameter Structure
  ;This is used for BIOSes that "Translate" Logical CHS (BIOS) to Physical
  ;  CHS (IDE/EIDE).
  ;This is also required for Drives larger than 8 GB, since we need to put
  ;  16383/16/63 in Physical CHS to indicate a "fake" drive size.
  ;----------------------------------------------------------------------------
  EDPTStruc STRUC
    EDPTLNumTracks      DW   ?  ;Logical Number of Tracks, Max 1024
    EDPTLNumHeads       DB   ?  ;Logical Number of Heads, Max 255
    EDPTSignature       DB 0A0h ;Signature for EDPT
    EDPTPSectsPerTrack  DB   ?  ;Physical Sectors Per Track, Max 255
    EDPTPrecompCyl      DW   ?  ;Starting Precompensation cylinder (Obsolete)
    EDPTPAD             DB   ?  ;PAD/Reserved
    EDPTCtlByte         DB   ?  ;Control Byte
      ;Bits 0-2 = Reserved (0)
      FDPTHeads8Plus   EQU  08h ;More than 8 Heads
      ;Bit 4 = Reserved (0)
      FDPTDefectMap    EQU  20h ;Mfg Defect Map stored on Max Track + 1
      FDPTNoECCRetry   EQU  40h ;Disable ECC retries
      FDPTNoAccRetry   EQU  80h ;Disable Access retries
    EDPTPNumTracks      DW   ?  ;Physical Number of Tracks, Max 65535
    EDPTPNumHeads       DB   ?  ;Physical Number of Heads, Max 16
    EDPTLandingZone     DW   ?  ;Landing Zone Cylinder (Obsolete)
    EDPTLSectsPerTrack  DB   ?  ;Logical Sectors Per Track, Max 63
    EDPTCheckSum        DB   ?  ;CheckSum
   ENDS ;16 bytes

  ;----------------------------------------------------------------------------
  ;Data Structure returned by an INT 13h Get Extended Disk Parameters Request
  ;----------------------------------------------------------------------------
  Int13XDrvParamStruc STRUC
    I13XBuffSize      DW 001Ah ;Size of Buffer (on input & Output)
                               ;  V1 = 1Ah, v2 = 1Eh, v3 = 42h
    I13XFlags         DW    ?  ;Flags
      I13XDMAHandled EQU 0001h ;DMA Boundary Errors Handled Transparently
      I13XCHSValid   EQU 0002h ;CHS Information is Valid
      I13XRemovable  EQU 0004h ;Drive is Removable
      I13XWrtVerify  EQU 0008h ;Write with Verify is Supported
      I13XChgLineSup EQU 0010h ;Change-Line is Supported
      I13XLockSup    EQU 0020h ;Drive Locking is Supported
      I13XCHSMaximum EQU 0040h ;CHS Information is Maximum, not Current Media
      ;Bits 7-15 = Reserved
      I13XFlagsToUse EQU (I13XDMAHandled+I13XCHSValid+I13XRemovable+I13XWrtVerify+I13XChgLineSup)
                               ;Flags we will use for our Disks
                               ;We do not support Drive Locking (it is never
                               ;  possible to physically lock a USB Drive,
                               ;  though some may support media locking)
                               ;We also assume CHS details are current, though
                               ;  that will not necessarily be correct if the
                               ;  drive has removable media (e.g., a Floppy)
    I13XNumTracks     DD    ?  ;Number of Physical Cylinders
    I13XNumHeads      DD    ?  ;Number of Physical Heads
    I13XSectsPerTrack DD    ?  ;Number of Sectors Per Track/Cylinder
    I13XTotalSects    DQ    ?  ;Total Number of Sectors
    I13XBytesPerSect  DW    ?  ;Bytes Per Sector
   ENDS
  I13XSize EQU (TYPE Int13XDrvParamStruc)  ;Size = 26 (1Ah) Bytes

  ;----------------------------------------------------------------------------
  ;Structure for Extended Int 13h Read/Write/Verify/Seek Requests
  ;----------------------------------------------------------------------------
  Int13DAPStruc STRUC ;Int 13h Disk Address Packet (For Extended Read/Write)
    DAPPktSize    DB ? ;Packet Size (10h or 18h)
    DAPPAD1       DB ? ;PAD/Reserved (0)
    DAPNumBlocks  DB ? ;Number of Blocks to Transfer
    DAPPAD2       DB ? ;PAD/Reserved (0)
    DAPXferAddr32 DD ? ;Memory Address to Transfer To/From (-1 if 64-bit Addr)
    DAPLBA64      DQ ? ;64-Bit LBA of Starting Sector
    DAPXferAddr64 DQ ? ;64-bit Memory Address (if PktSize = 18h & Addr32 = -1)
   ENDS

  ;----------------------------------------------------------------------------
  ;Structure for an INT 13h Request to issue an SRB to a device that responds
  ;  to SCSI commands.
  ;Issued through INT 13h (with Drive Number).  We fill in LUN (always assume
  ;  LUN is high bits of first byte in Request).  In USB, LUN is always 0.
  ;Does NOT automatically issue Request Sense.  Request Sense is a command
  ;  unto itself.
  ;No Post-routine calls, no Linking.
  ;If Device is busy processing another call, this will wait for the other
  ;  call to finish before being sent to the SCSI device.  It is not Queued.
  ;----------------------------------------------------------------------------
  I13SCSIStruc      STRUC ;Structure to send SCSI requests through INT 13h
    I13SID             DD   'SCSI'   ;ID string for valid Structure
    I13SFlags          DB       ?    ;Flags
      I13SFlagIn      EQU      01h   ;Data Direction = In (Device to Computer)
                                     ;  Only applies to Data Stage
                                     ;  Can sometimes be extrapolated from the
                                     ;    SCB Request Type, but is inconsistent.
                                     ;If data Size is 0 (e.g., Test Unit Ready),
                                     ;  Direction must be what Device expects
                                     ;  to see (e.g., TUR = OUT).
      I13SFNoRetry    EQU      02h   ;No Automatic Retries
      I13SFShortPktOK EQU      04h   ;No Error for Short Packet
    I13SCmdSize        DB       ?    ;Size of Command Block (Group 3-4, 6-7)
                                     ;  (0 = Use Default)
    I13SCmdBlock       DB 16 DUP (0) ;SCSI Command Block (must be 0-padded)
                                     ;Command size determined from Command
    I13SDataSize       DW       ?    ;Number of bytes to transfer in data stage
                                     ; (NOT number of Sectors)
                                     ;Note: Data Size is usually embedded in
                                     ;  SRB, but location varies, is sometimes
                                     ;  sectors instead of bytes, and is
                                     ;  sometimes not there at all.
                                     ;  We don't have a lookup table for all
                                     ;  possibilities, so user must provide the
                                     ;  orrect number of bytes in data stage.
    I13SDataPtr        DD       ?    ;Pointer to Data Area (Segment:Offset)
   ;Return Data
    I13SSetupErr       DB       ?    ;Error during Setup Stage
    I13SDataErr        DB       ?    ;Error during Data Stage
    I13SStatusErr      DB       ?    ;Error during Status Stage
      I13SErrNone     EQU      00h   ;No Error
      I13SErrNoResp   EQU      01h   ;No response from Device (USB Stall)
      I13SErrShortPkt EQU      02h   ;Short Data Packet
      I13SErrHW       EQU      03h   ;Hardware Error on Bus, incl No Dvc/Media
      I13SErrNoStage  EQU     0FFh   ;Stage never happened
    ;If Short Packet, need to return # of bytes Xfered, or is Residue enough?
    I13SCmdStatus      DB       ?    ;CSW Status
      ;CSWStsOK        EQU     00h    ;OK (No Error)
      ;CSWStsFail      EQU     01h    ;Command Failed
      ;CSWStsPhase     EQU     02h    ;Phase Error
      ;-1 = Unknown??   (If "wrapper" doesn't contain status??)
    I13SDataResidue    DD       ?    ;Data Residue
    I13SSenseErrCode   DB       ?    ;Requst Sense Error Code
    I13SSenseKey       DB       ?    ;Request Sense Sense Key & ILI
    I13SSenseASC       DB       ?    ;Additional Sense Code
    I13SSenseASCQ      DB       ?    ;Additional Sense Code Qualifier
    I13SSenseInfo      DD       ?    ;Request Sense Info
   ENDS ;xx bytes


;==============================================================================
;DOS Device Driver Request Headers
;  Issued by DOS to a Device Driver
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Structure for Request Header Needed by Device Driver Interrupt Calls.
  ;This is used to pass data back and forth between DOS and the Driver.
  ;All Requests include this Header.  Some Requests include additional
  ;  data appended to the end of the header, as detailed below.
  ;----------------------------------------------------------------------------
  RequestHdrStruc     STRUC
   RHLength              DB        ?  ;Length of Request (bytes)
   RHUnit                DB        ?  ;Unit Number (Block Devices Only)
     RHLastLogicalDvc   EQU (OFFSET RHUnit)
                                      ;The Get Logical Device Function
                                      ;  returns the Last Logical Device Used
                                      ;  in this field
   RHCommand             DB        ?  ;Most Recent Command sent to Driver
     RHCmdInitialize    EQU        0  ;Initialize
     RHCmdMediaCheck    EQU        1  ;Media Check
     RHCmdBuildBPB      EQU        2  ;Build BIOS Parameter Block
     RHCmdIOCtlRead     EQU        3  ;IOCtl Read (Input)
     RHCmdRead          EQU        4  ;Read (Input)
     RHCmdNDRead        EQU        5  ;Non-destructive Read (Input) No Wait
     RHCmdInputStatus   EQU        6  ;Current Input Status
     RHCmdFlushInput    EQU        7  ;Flush Input Buffers
     RHCmdWrite         EQU        8  ;Write (Output)
     RHCmdWriteVerify   EQU        9  ;Write (Output) with Verify
     RHCmdOutputStatus  EQU       10  ;Output Status
     RHCmdFlushOutput   EQU       11  ;Flush Output Buffers
     RHCmdIOCtlWrite    EQU       12  ;IOCtl Write (Output)
     RHCmdOpen          EQU       13  ;Device Open
     RHCmdClose         EQU       14  ;Device Close
     RHCmdRemovable     EQU       15  ;Removable Media
     RHCmdOutputTilBusy EQU       16  ;Output Until Busy
     RHCmdGenIOCtlV3    EQU       17  ;Generic IOCtl DOS 3
     ;Illegal Function   EQU       18
     RHCmdGenIOCtlV4    EQU       19  ;Generic IOCtl DOS 4+
     ;Illegal Function   EQU       20
     ;Illegal Function   EQU       21
     ;Illegal Function   EQU       22
     RHCmdGetLogicalDvc EQU       23  ;Get Logical Device (DOS 3.2+)
     RHCmdSetLogicalDvc EQU       24  ;Set Logical Device (DOS 3.2+)
     RHCmdIOCtlCheck    EQU       25  ;IOCtl Check (DOS 5+)

     RHCmdCDReadLong    EQU      128  ;CD-ROM Read Long
                                      ;129 = CD-ROM Reserved
     RHCmdCDReadLongPre EQU      130  ;CD-ROM Read Long Prefetch
     RHCmdCDSeek        EQU      131  ;CD-ROM Seek
     RHCmdCDPlayAudio   EQU      132  ;CD-ROM Play Audio
     RHCmdCDStopAudio   EQU      133  ;CD-ROM Stop Audio
     RHCmdCDWriteLong   EQU      134  ;CD-ROM Write Long
     RHCmdCDWriteLongVf EQU      135  ;CD-ROM Write Long Verify
     RHCmdCDResumeAudio EQU      136  ;CD-ROM Resume Audio
   RHStatus              DW        ?  ;Status Code
     RHSNoError         EQU        0  ;No error
     RHSDone            EQU     0100h ;Done processing last Interrupt Call
     RHSBusy            EQU     0200h ;Driver is currently Busy
       RHSPermanent     EQU   RHSBusy ;Bit is also used by the Removable Media
                                      ;  Function, returning 1 (RHSPermanent) if
                                      ;  the media is permanent (not removable),
                                      ;  0 if it is removable
     RHSError           EQU     8000h ;Error (must be combined with other Bits)
                                      ;Error Code is entire low byte
     RHSWriteProt       EQU        0  ;Write-protect Violation
     RHSUnknownUnit     EQU        1  ;Unknown Unit
     RHSDvcNotReady     EQU        2  ;Device Not Ready
     RHSUnknownCmd      EQU        3  ;Unknown Command
     RHSCRCError        EQU        4  ;CRC Error
     RHSBadRHLength     EQU        5  ;Bad Request Header Length field
     RHSSeekError       EQU        6  ;Seek Error
     RHSUnknownMedia    EQU        7  ;Unknown Media
     RHSSectorNF        EQU        8  ;Sector Not Found
     RHSOutOfPaper      EQU        9  ;Printer Out of Paper
     RHSWriteFault      EQU       10  ;Write Fault
     RHSReadFault       EQU       11  ;Read Fault
     RHSGeneralFail     EQU       12  ;General failure
     ;Reserved           EQU       13  ;Reserved
     ;Reserved           EQU       14  ;Reserved (Resend?)
     RHSInvalidChange   EQU       15  ;Invalid Disk Change
   RHReserved            DB 8 DUP (0) ;Reserved for use by DOS
   ENDS

  RHSize EQU (TYPE RequestHdrStruc) ;Size of Header (13 bytes)

  ;----------------------------------------------------------------------------
  ;Data on Entry to Initialize Function
  ;----------------------------------------------------------------------------
  RHInitInStruc    STRUC
    RHInitInHdr       DB RHSize DUP (?) ;Common Header
    RHInitInPAD       DB      5 DUP (?) ;Leave space for return values
    RHInitInCmdLine   DD             ?  ;Pointer to Command Line Arguments
    RHInitInFirstUnit DB             ?  ;First Unit Number
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Exit from Initialize Function
  ;----------------------------------------------------------------------------
  RHInitOutStruc   STRUC
    RHInitOutHdr      DB RHSize DUP (?) ;Common Header
    RHInitOutNumUnits DB             ?  ;Number of Units
    RHInitOutLastByte DD             ?  ;Pointer to first byte of unused
                                        ;  Memory at end of Driver (where
                                        ;  next Driver can be loaded)
    RHInitOutBPBPtr   DD             ?  ;Pointer to BIOS Parameter Block(s)
                                        ;Points at an array of WORD Pointers
                                        ;   How to end the Array list?
                                        ;   BPB's are read-only!
    RHInitOutPAD      DB             ?  ;Don't change First Unit
    RHInitInConfigErr DW             ?  ;CONFIG.SYS Error Msg Ctrl Flag (v4)
                                         ;  If <> 0, "Error in CONFIG.SYS"
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Entry to Media Check Function
  ;  Sole purpose is to check if media has changed or not!
  ;----------------------------------------------------------------------------
  RHMediaInStruc  STRUC
    RHMediaInHdr     DB RHSize DUP (?) ;Common Header
    RHMediaInMediaID DB             ?  ;Media ID
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Exit from Media Check Function
  ;----------------------------------------------------------------------------
  RHMediaOutStruc      STRUC
    RHMediaOutHdr         DB RHSize DUP (?) ;Common Header
    RHMediaOutPAD         DB             ?  ;Don't change Media ID
    RHMediaOutChangeCode  DB             ?  ;Media Change Code
      MediaChangeNo      EQU             1  ;Media not changed
      MediaChangeYes     EQU            -1  ;Media changed
      MediaChangeUnknown EQU             0  ;Don't know/Unsure
    ;DR-DOS recommends setting a two second timer to keep the disk
    ;  as "not changed" after a successful disk access, if the disk
    ;  does not have a legitimate media change line/bit
    RHMediaOutVolNamePtr  DD             ?  ;Last Volume Name (ID) Read Pointer
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Entry to Build BIOS Parameter Block Function
  ;Called after a Media change has been detected to log the new media
  ;----------------------------------------------------------------------------
  RHBPBInStruc     STRUC
    RHBPBInHdr        DB RHSize DUP (?) ;Common Header
    RHBPBInMediaID    DB             ?  ;Media ID
    RHBPBInSectorBuff DD             ?  ;Pointer to Buffer one sector in size
                                        ;If IBM format, is first FAT Sector
                                        ;  (First byte of FAT Sector contains
                                        ;   the FAT ID)
                                        ;All Devices supported by the same
                                        ;  Driver must have the same
                                        ;  FAT Sector Number!
                                        ;If non-IBM format, can be used by the
                                        ;  driver to determine the BPB
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Exit from Build BIOS Parameter Block Function
  ;----------------------------------------------------------------------------
  RHBPBOutStruc STRUC
    RHBPBOutHdr    DB RHSize DUP (?) ;Common Header
    RHBPBOutPAD    DB      5 DUP (?) ;Don't change Media ID or Buffer Pointer
    RHBPBOutBPBPtr DD             ?  ;Pointer to BPB
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Entry to IOCtl Read & Write Functions
  ;  This is NOT a Request to read/write from/to the Device, which is why
  ;    there is no Starting Sector information like there is in a "real"
  ;    Read Request.
  ;  This is used to pass information from/to the Device Driver, not the
  ;    Device itself.  The Transfer Address will contain a structure or
  ;    string which details what to do (typically a call for the Driver
  ;    to somehow reconfigure itself).
  ;  This call is Device-Specific, and nothing about it is defined at a
  ;    generic level in DOS.  For a general-purpose program like ours,
  ;    this call does not need to be implemented.
  ;  If we leave the DHAttrIOCtl bit in the Device Header clear, it tells
  ;    DOS that we do not support IOCTL.
  ;----------------------------------------------------------------------------
  RHIOCtlRdWrInStruc    STRUC
    RHIOCtlRdWrInHdr       DB RHSize DUP (?) ;Common Header
    RHIOCtlRdWrInMediaID   DB             ?  ;Media ID
    RHIOCtlRdWrInXferAddr  DD             ?  ;Transfer Address
    RHIOCtlRdWrInSectCount DW             ?  ;Sector Count (Requested)
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Exit from IOCtl Read & Write Functions is Driver-specific
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;Data on Entry to Read, Write, and Write-with-Verification Functions
  ;This is also used for the Output-Til-Busy Function (Character Devices)
  ;Write with Verify Reads back after the Write and compares values
  ;----------------------------------------------------------------------------
  RHRdWrInStruc      STRUC
    RHRdWrInInHdr       DB RHSize DUP (?) ;Common Header
    RHRdWrInMediaID     DB             ?  ;Media ID
    RHRdWrInXferAddr    DD             ?  ;Transfer Address
    RHRdWrInSectCount   DW             ?  ;Sector Count (Requested)
    RHRdWrInStartSect16 DW             ?  ;Starting Sector # (16-bit)
                                          ;  Block Devices Only
                                          ;  If DOS 4+, -1 means to use
                                          ;    StartSector32
    RHRdWrInPAD         DB      4 DUP (?) ;Leave room for Volume Name (ID)
    RHRdWrInStartSect32 DD             ?  ;Starting Sector # (32-bit)
                                          ;  Block Devices Only
                                          ;  Only valid if DOS 4+ &
                                          ;    StartSector16 = -1
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Exit from Read, Write, and Write-with-Verification Functions
  ;This is also used for the Output-Til-Busy Function (Character Devices)
  ;----------------------------------------------------------------------------
  RHRdWrOutStruc    STRUC
    RHRdWrOutInHdr     DB RHSize DUP (?) ;Common Header
    RHRdWrOutPAD1      DB      5 DUP (?) ;Don't change Media ID or Xfr Addr
    RHRdWrOutSectCount DW             ?  ;Sector Count (Actual)
    RHRdWrOutPAD2      DB      2 DUP (?) ;Don't change Starting Sector
    RHRdWrOutVolumePtr DD             ?  ;Pointer to Volume Name (ID)
                                         ;Required if Device Error = 15
                                         ;  (Invalid Media Change)
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Entry to Non-Destructive Read Function is empty
  ;Character (Keyboard) Devices Only
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;Data on Exit from Non-Destructive Read Function
  ;Character (Keyboard) Devices Only
  ;Reads the character, but does not remove it from the Input Buffer
  ;----------------------------------------------------------------------------
  RHNDReadOutStruc STRUC
    RHNDReadOutHdr    DB RHSize DUP (?) ;Common Header
    RHReadOutChar     DB             ?  ;The character read from the Device
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Entry to Input Status, Output Status, Flush Input,
  ;  and Flush Output Functions is empty
  ;Character Devices Only
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;Data on Exit from Input Status, Output Status, Flush Input,
  ;  and Flush Output Functions is empty
  ;Character Devices Only
  ;Status Function tests to see if the Device is Ready (Write) or a
  ;  character is in the Buffer (Read) so that a consequent call will not
  ;  need to wait.  Returns 0 in Busy Bit if Device is Ready, 1 if
  ;  not Ready (Read/Write would need to wait).
  ;----------------------------------------------------------------------------

  ;Functions below this point require DOS 3.0+

  ;----------------------------------------------------------------------------
  ;Data on Entry to Open, Close, and Removable Media Functions is empty
  ;Removable Media Function is only for Block Devices.
  ;This informs the BIOS when a File (Block Dvc) or Device (Character Dvc)
  ;  is Opened or Closed
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;Data on Exit from Open, Close, and Removable Media Functions is empty
  ;The Removable Media Function should return 0 in the Busy Bit if the Media
  ;  is Removable, 1 in the Busy Bit if non-Removable.
  ;Removable Media Function is only for Block Devices.
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;Data on Entry to Generic IOCtl Function
  ;  DOS Function 440Ch = Generic I/O Request for Character Devices
  ;  DOS Function 440Dh = Generic I/O Request for Block Devices
  ;  Cat/Func Codes were sent by application in the CX register for Func 44h
  ;Data on entry to GenericIOCtlCk Function is same through the Category
  ;  and Function.  It does not have the SI, DI, or parameter Block fields.
  ;----------------------------------------------------------------------------
  RHGenIOCtlStruc      STRUC
    RHGenIOCtlHdr         DB RHSize DUP (?) ;Common Header
    RHGenIOCtlCategory    DB  ?  ;Category (Major) Code
     ;-------------------------------------------------------------------------
     ;Categories 00-7Fh = Microsoft
     ;-------------------------------------------------------------------------
      IOCatUnknown       EQU 00h ;Unknown (DOS 3.3+)
      IOCatCOMx          EQU 01h ;COMx
      IOCatTermReserved  EQU 02h ;Reserved for Terminal Control
      IOCatCON           EQU 03h ;CON
      IOCatKeybReserved  EQU 04h ;Reserved for Keyboard Control
      IOCatLPTx          EQU 05h ;LPTx
      IOCatEuroMouse     EQU 07h ;Mouse Control (European DOS 4.0)
      IOCatDisk          EQU 08h ;Disk Control (INT 21/440Dh)
      IOCatFAT32Disk     EQU 48h ;FAT32 Disk Control (INT 21/440Dh)
     ;-------------------------------------------------------------------------
     ;Categories 80-FFh = OEM/User-Defined
     ;-------------------------------------------------------------------------
    RHGenIOCtlFunction    DB  ?  ;Function (Minor) Code (aka Command)
     ;-------------------------------------------------------------------------
     ;Meanings of certain bits in the Command Byte
     ;-------------------------------------------------------------------------
      IOCmdMaskIgnoreErr EQU 80h ;Ignore error if unsupported
                                 ;  (else return error code)
      IOCmdMaskToDriver  EQU 40h ;Send command to Driver
                                 ;  (else intercepted by DOS)
      IOCmdMaskGetData   EQU 20h ;Gets Data (else Sends Data)
                                 ;  If both Gets and Sends, bit = 0
      IOCmdMaskCommand   EQU 1Fh ;Actual command in bits 0-4
     ;-------------------------------------------------------------------------
     ;Block Device Commands
     ;-------------------------------------------------------------------------
      IOCmdSetDvcParams  EQU 40h ;Set Device Parameters
      IOCmdGetDvcParams  EQU 60h ;Get Device Parameters
      IOCmdWriteTrack    EQU 41h ;Write to Track on Logical Dvc
      IOCmdReadTrack     EQU 61h ;Read Track from Logical Dvc
      IOCmdFormatTrack   EQU 42h ;Format & Verify Track on Log Dvc
      IOCmdVerifyTrack   EQU 62h ;Verify Track without Formatting
      IOCmdSetVolSerNum  EQU 46h ;Set Volume Serial # (Media ID)
      IOCmdGetVolSerNum  EQU 66h ;Get Volume Serial # (Media ID)
      IOCmdSetAccess     EQU 47h ;Set Access Status
      IOCmdGetAccess     EQU 67h ;Get Access Status
    RHGenIOCtlSI          DW  ?  ;SI Register (EuroDOS and OS/2)
    RHGenIOCtlDI          DW  ?  ;DI Register (EuroDOS and OS/2)
    RHGenIOCtlParamBlkPtr DD  ?  ;Parameter Block Pointer
   ENDS

  ;----------------------------------------------------------------------------
  ;Data on Entry and Exit from Query Generic IOCtl Capability Function
  ;----------------------------------------------------------------------------
  RHGenIOCtlCkStruc      STRUC
    RHGenIOCtlCkHdr       DB RHSize DUP (?) ;Common Header
    RHGenIOCtlCkCategory  DB  ? ;Category (Major) Code
                                ;  (Same as GenericIOCtl Category Codes)
    RHGenIOCtlCkFunction  DB  ? ;Function (Minor) Code (aka Command)
                                ;  (Same as GenericIOCtl Function Codes)
    RHGenIOCtlCkPAD       DB 3 DUP (?) ;No idea what this area is for
    RHGenIOCtlCkAX        DW  ? ;Value INT 21h returns in AX when done
                                ;Set to 0 before completing call
   ENDS


  ;============================================================================
  ;Generic I/O Parameter Blocks
  ;============================================================================

  ;----------------------------------------------------------------------------
  ;Generic IOCTL Parameter Block for
  ;  Set Device Parameters (Function 40h)
  ;  Get Device Parameters (Function 60h)
  ;----------------------------------------------------------------------------
  GIODvcParamsStruc STRUC
    GIODPSpecFunc       DB    ?  ;Special Functions
                                 ;DOS 7.10 Several Functions do not change
                                 ;  this byte!
      DPSFGetMediaBPB  EQU   01h ;Return the Media BPB (current BPB)
                                 ;  (the same BPB that Build BPB would return)
                                 ;0 = Return Default (Device) BPB
                                 ;All other Bits = 0
      DPSFSetDevBPB    EQU   01h ;Sets Default (Device) BPB for all subsequent
                                 ;  Build BPB requests to use
                                 ;If 0, the BPB contains new default Device BPB,
                                 ;  but does not change the Media BPB.
                                 ;  If a previous Request set this bit on,
                                 ;  the Media BPB is returned.  Otherwise,
                                 ;  returns Default Device BPB.
                                 ;Before the Format function is issued, Set Dvc
                                 ;  Params should be called with bit set in
                                 ;  order to set the format media type.
      DPSFSetTrkLayout EQU   02h ;Ignore all fields except Track Layout
                                 ;If 0, all fields are valid
                                 ;Bits 0 & 1 cannot be set at same time
      DPSFSetSectSame  EQU   04h ;All sectors in track are the same size, and
                                 ;  sector numbers are 1 to sectors/track
                                 ;If 0, sectors in track may be different sizes
      ;Bits 3-7 = Reserved
    GIODPDvcType        DB    ?  ;Device Type
      DPDT3x0k         EQU   00h ;320k/360k 5.25in floppy
      DPDT1200k        EQU   01h ;1.2M 5.25in Floppy
      DPDT720k         EQU   02h ;720k 3.5in Floppy
      DPDTSD8in        EQU   03h ;SD 8in Floppy
      DPDTDD8in        EQU   04h ;DD 8in Floppy
      DPDTFixed        EQU   05h ;Fixed Disk
      DPDTTape         EQU   06h ;Tape Drive
      DPDTOther        EQU   07h ;Other (usually 1.44MB Floppy)
      DPDTOptical      EQU   08h ;Optical Disk (R/W)
      DPDT2800k        EQU   09h ;2.88M 3.5in Floppy
    GIODPDvcAttribs     DW    ?  ;Device Attributes
      DPDAFixed        EQU 0001h ;Non-removable media
      DPDAChangeSupt   EQU 0002h ;Changeline supported
      ;bits 2-15 = Reserved
    GIODPNumCyls        DW    ?  ;Maximum Number of Cylinders supported by
                                 ;  Physical Device (independent of Media)
    GIODPMediaType      DB    ?  ;Media Type (used only if Media cannot be
                                 ;  determined some other way)
      DPMTOther        EQU   00h ;All other Drives
      DPMT1200k        EQU   01h ;1.2MB Floppy (1.2MB Device)
      DPMT3x0k         EQU   02h ;320k/360k Floppy (1.2MB Device)
      DPMTDublDisk     EQU  0F8h ;DUBLDISK v2.6 Drive (whatever that is)
    GIODPBPB            DB 31 DUP (?) ;Final 6 bytes only sent in DOS 5.0
                                      ;  for Function 40h if Flags bit 0 Set
    ;If Track Layout bit is set, this is followed by the Track Layout Table
    ;  Track Layouts should nopt be used by any disks we deal with
    ;Bytes below here only sent for Category 48h (FAT32 functions)
    GIODPXBPB           DB 22 DUP (?) ;Extended BPB Data
    GIODPReserved       DB 32 DUP (?) ;Reserved (set to 0 in DOS 7.10)
    ;GIOTrackLayout      DB  ? DUP (?) ;Track Layout
    ;Layout is a variable length table of words detailing Sector Sizes
    ;First Word is number of Sectors
    ;  Second Word is Sector Number, Third Word is Sector Size
    ;  Table continues with Sector Number/Sector Size combos til end
   ENDS

  ;----------------------------------------------------------------------------
  ;Generic IOCTL Parameter Block for
  ;  Write Track (Function 41h)
  ;  Read  Track (Function 61h)
  ;NOTE: Under later versions of Windows, the Drive must be Locked.
  ;----------------------------------------------------------------------------
  GIORWTrackStruc STRUC
    GIORWReserved  DB ? ;Reserved (0)
    GIORWHeadNum   DW ? ;Head Number
    GIORWCylNum    DW ? ;Cylinder Number
    GIORWStartSect DW ? ;Starting Sector Number
    GIORWNumSects  DW ? ;Number of Sectors to Transfer
    GIORWDataAddr  DD ? ;Data Transfer Address (Segment:Offset)
   ENDS

  ;----------------------------------------------------------------------------
  ;Generic IOCTL Parameter Block for
  ;  Format Track (Function 42h)
  ;----------------------------------------------------------------------------
  GIOFmtTrackStruc STRUC
    GIOFmtFlags          DB  ?  ;Flags (must be 0 for DOS < 3.2)
      ;Input
      GIOFFInStatus     EQU 01h ;Status call (don't actually format, DOS 3.2+)
      GIOFFInMultiple   EQU 02h ;Format Multiple Tracks (requires additional Word)
                                ;  Hard Disks Only
      ;Bits 2-7 = Reserved (0)
      ;Output
      GIOFFOutTracksOK  EQU 00h ;Tracks & Sectors/Track values Supported
      GIOFFOutBadFunc   EQU 01h ;Function Not Supported
      GIOFFOutTracksBad EQU 02h ;Tracks & Sectors/Track values Not Supported
      GIOFFOutNoMedia   EQU 03h ;No Media in Drive
      ;Bits 4-7 = Reserved?
    GIOFmtHeadNum        DW  ?  ;Head Number
    GIOFmtCylNum         DW  ?  ;Cylinder Number
    GIOFmtNumTracks      DW  ?  ;Number of Tracks to Format (If Multiple Flag)
   ENDS

  ;----------------------------------------------------------------------------
  ;Generic IOCTL Parameter Block for
  ;  Verify Track (Function 62h)
  ;----------------------------------------------------------------------------
  GIOVerifyTrackStruc STRUC
    GIOVfyFlags          DB  ?  ;Flags (must be 0 for DOS < 3.2)
      ;Input
      GIOVFInMultiple   EQU 01h ;Verify Multiple Tracks
      ;Bits 1-7 = Reserved (0)
      ;Output
      GIOVFOutTracksOK  EQU 00h ;Tracks & Sectors/Track values Supported
      GIOVFOutBadFunc   EQU 01h ;Function Not Supported
      GIOVFOutTracksBad EQU 02h ;Tracks & Sectors/Track values Not Supported
      GIOVFOutNoMedia   EQU 03h ;No Media in Drive
      ;Bits 4-7 = Reserved?
    GIOVfyHeadNum        DW  ?  ;Head Number
    GIOVfyCylNum         DW  ?  ;Cylinder Number
    GIOVfyNumTracks      DW  ?  ;Number of Tracks to Verify (If Multiple Flag)
                                ;  Equivalent to 255 or fewer Sectors)
   ENDS

  ;----------------------------------------------------------------------------
  ;Generic IOCTL Parameter Block for
  ;  Set Volume Serial Number (Function 46h)
  ;  Get Volume Serial Number (Function 66h)
  ;----------------------------------------------------------------------------
  GIOSerialNumStruc STRUC
    GIOSerInfoLevel DW         ?  ;Info Level (should be 0)
    GIOSerSerNum    DD         ?  ;Disk Serial Number (binary)
    GIOSerVolumeID  DB 11 DUP (?) ;Volume Label (can be "NO NAME    ")
    GIOSerFSysType  DB  8 DUP (?) ;File System Type String ("FAT12   ", etc.)
   ENDS

  ;----------------------------------------------------------------------------
  ;Generic IOCTL Parameter Block for
  ;  Set Access State (Function 67h)
  ;  Get Access State (Function 47h)
  ;----------------------------------------------------------------------------
  GIOAccessStruc STRUC
    GIOAccessFlags  DB ? ;Flags (must be 0)
    GIOAccessStatus DB ? ;Disk Access Flag, 0 = No Access Allowed
   ENDS

  ;----------------------------------------------------------------------------
  ;Data on Entry to CD Read Long, Read Long Prefetch, Write Long,
  ;  Write Long Verify, and Seek Functions.
  ;----------------------------------------------------------------------------
  RHCDRdWrStruc    STRUC
    RHCDRWHdr         DB RHSize DUP (?) ;Common Header
    RHCDRWAddrMode    DB             ?  ;Address Mode
      CDRWAMHSG      EQU            00h ;HSG (Default)
      CDRWAMRedBook  EQU            01h ;Phillips/Sony Red Book
    RHCDRWXferAddr    DD             ?  ;Transfer Address (Segment:Offset)
                                        ;Ignored if Writing Zeroes
                                        ;Ignored if Seeking
    RHCDRWNumSects    DW             ?  ;Number of Sectors to Transfer
                                        ;Ignored if Seeking
    RHCDRWStartSect   DD             ?  ;Starting Sector Number
                                        ;  LBA in HSG Mode
                                        ;  Frame/Second/Minute/Unused in Red Book
                                        ;  ((Min*4500)+(Sec*75)+Frame-150)
    RHCDRWDataMode    DB             ?  ;Data Read Mode
                                        ;Ignored if Seeking
      ;Read & Read Prefetch
      CDRdDMCooked   EQU            00h ;Cooked (2048 bytes/frame)
      CDRdDMRaw      EQU            01h ;Raw (2532 bytes/frame)
      ;Write & Write Verify
      CDWrDMZeroes   EQU            00h ;Mode 0 (Write All Zeroes)
      CDWrDM1        EQU            01h ;Mode 1 (default, 2048 bytes/sector)
      CDWrDM2Form1   EQU            02h ;Mode 2 Form 1 (2048 bytes/sector)
      CDWrDM2Form2   EQU            03h ;Mode 2 Form 2 (2336 bytes/sector)
    RHCdRWIleaveSize  DB             ?  ;Interleave Size (Num Sects stored
                                        ;  consecutively)
                                        ;Ignored if Seeking
    RHCDRWIleaveSkip  DB             ?  ;Interleave Skip Factor (Num Sects
                                        ;  between consecutive portions)
                                        ;Ignored if Seeking
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Entry to CD Play Audio Function.
  ;----------------------------------------------------------------------------
  RHCDPlayAudioStruc STRUC
    RHCDPlayHdr       DB RHSize DUP (?) ;Common Header
    RHCDPlayAddrMode  DB             ?  ;Address Mode (Same as RHCDRWAddrMode)
    RHCDPlayStartSect DD             ?  ;Starting Sector Number
                                        ;  (same format as RHCDRWStartSect)
    RHCDPlayNumSects  DD                ;Number of Sectors to Play
  ENDS

  ;----------------------------------------------------------------------------
  ;Data on Entry to CD Stop Audio & Resume Audio Functions requires no
  ;  special fields other than those in the Common Header.
  ;----------------------------------------------------------------------------


;--------d-214402-----------------------------
;INT 21 - CD-ROM device driver - IOCTL INPUT
;        AX = 4402h
;        BX = file handle referencing character device for CD-ROM driver
;        CX = number of bytes to read
;        DS:DX -> control block (see #01449)
;Return: CF clear if successful
;            AX = number of bytes actually read
;        CF set on error
;            AX = error code (01h,05h,06h,0Dh) (see #01680 at AH=59h/BX=0000h)
;Notes:  the data returned depends on the first byte of the control block
;          (two bytes for functions 01h/07h/0Bh, see #01449); the remainder of
;          the control block is filled by the driver
;        some device drivers support several subunits (that is more than one
;          drive) but it is not possible to distinguish between them with this
;          function; use INT 2F/AX=1510h or INT 2F/AX=0802h instead
;        under Windows95, the "mscd$$$$" device cannot be opened so you cannot
;          obtain the handle required by this function: use INT 2F/AX=1510h
;          or INT 2F/AX=0802h instead
;SeeAlso: AX=4403h"CD-ROM",INT 2F/AX=0802h,INT 2F/AX=1510h
;
;(Table 01448)
;Values for CD-ROM data being requested:
; 00h    device driver header address
; 01h    drive head location
; 02h    reserved
; 03h    error statistics
; 04h    audio channel info
; 05h    raw drive bytes (uninterpreted and device-specific)
; 06h    device status
; 07h    sector size
; 08h    volume size
; 09h    media change status
; 0Ah    audio disk info
; 0Bh    audio track info
; 0Ch    audio Q-Channel info
; 0Dh    audio sub-channel info
; 0Eh    UPC code
; 0Fh    audio status info
;
;Format of CD-ROM control block:
;Offset  Size    Description     (Table 01449)
; 00h    BYTE    data being requested (see #01448)
;---function 00h---
; 01h    DWORD   device driver header address (see also AH=52h,#01646)
;---function 01h---
; 01h    BYTE    (call) addressing mode
;                00h HSG
;                01h Red Book
; 02h    DWORD   current location of drive's head
;                logical sector number in HSG mode
;                frame/second/minute/unused in Red Book mode
;                (HSG sector = minute * 4500 + second * 75 + frame - 150)
;---function 03h---
; 01h  N BYTEs   undefined as of 5 Aug 88 specification
;---function 04h---
; 01h    BYTE    input channel (0-3) for output channel 0
; 02h    BYTE    volume for output channel 0
; 03h    BYTE    input channel (0-3) for output channel 1
; 04h    BYTE    volume for output channel 1
; 05h    BYTE    input channel (0-3) for output channel 2
; 06h    BYTE    volume for output channel 2
; 07h    BYTE    input channel (0-3) for output channel 3
; 08h    BYTE    volume for output channel 3
;Notes:  output channels 0 and 1 are left and right, 2 and 3 are left prime and
;          right prime; a volume of 00h is off
;        the default setting is for each input channel to be assigned to the
;          same-numbered output channel at full (FFh) volume
;---function 05h---
; 01h    BYTE    number of bytes read
; 02h 128 BYTEs  buffer for drive bytes
;---function 06h---
; 01h    DWORD   device parameters (see #01450)
;---function 07h---
; 01h    BYTE    (call) read mode
;                00h cooked
;                01h raw
; 02h    WORD    (return) sector size in bytes
;---function 08h---
; 01h    DWORD   volume size in sectors
;BUGS:   Aztech device driver v1.10 and v1.27 (at least) return the last sector
;          number, i.e. total number of sectors - 1
;        Windows95 returns the total number of sectors + 150 (see the Red Book
;          to HSG conversion formula at function 01h to understand why this
;          happens)
;---function 09h---
; 01h    BYTE    media change status
;                00h don't know
;                01h media unchanged
;                FFh media has been changed
;---function 0Ah---
; 01h    BYTE    lowest audio track number
; 02h    BYTE    highest audio track number
; 03h    DWORD   start address of lead-out track (Red Book format)
;--function 0Bh---
; 01h    BYTE    (call) track number
; 02h    DWORD   starting point of track (Red Book format)
; 06h    BYTE    track control info
;                bits 15,14,12: track type (notice: bits not contiguous!)
;                        000 two audio channels, no pre-emphasis
;                        001 two audio channels with pre-emphasis
;                        010 data track
;                        100 four audio channels, no pre-emphasis
;                        101 four audio channels with pre-emphasis
;                        other reserved
;                bit 13: digital copy permitted
;---function 0Ch---
; 01h    BYTE    CONTROL and ADR byte (as received from drive)
; 02h    BYTE    track number
; 03h    BYTE    point or index
; 04h    BYTE    minute  \
; 05h    BYTE    second   > running time within track
; 06h    BYTE    frame   /
; 07h    BYTE    zero
; 08h    BYTE    "AMIN" or "PMIN"     \
; 09h    BYTE    "ASEC" or "PSEC"      > running time on disk
; 0Ah    BYTE    "AFRAME" or "PFRAME" /
;---function 0Dh---
; 01h    DWORD   starting frame address (Red Book format)
; 05h    DWORD   transfer address
; 09h    DWORD   number of sectors to read
;Note:   copies 96 bytes of sub-channel info per sector into buffer
;---function 0Eh---
; 01h    BYTE    CONTROL and ADR byte
; 02h  7 BYTEs   UPC/EAN code (13 BCD digits,low-order nybble of last byte is 0)
; 09h    BYTE    zero
; 0Ah    BYTE    "AFRAME"
;---function 0Fh---
; ??? documentation not yet available
; 01h    WORD    pause status (0000h not paused, 0001h paused)
; 03h    DWORD   audio play start address
; 07h    DWORD   ??? audio play length or end address
;
;Bitfields for CD-ROM device parameters:
;Bit(s)  Description     (Table 01450)
; 0      door open
; 1      door unlocked
; 2      supports raw reading in addition to cooked
; 3      writable
; 4      can play audio/video tracks
; 5      supports interleaving
; 6      reserved
; 7      supports prefetch requests
; 8      supports audio channel control
; 9      supports Red Book addressing in addition to HSG
; 10     audio is playing
; 11     no disk in drive
; 12     supports R-W subchannels


;--------d-214403-----------------------------
;INT 21 - CD-ROM device driver - IOCTL OUTPUT
;        AX = 4403h
;        BX = file handle referencing character device for CD-ROM driver
;        CX = number of bytes to write
;        DS:DX -> control block (see #01524)
;Return: CF clear if successful
;            AX = number of bytes actually written
;        CF set on error
;            AX = error code (01h,05h,06h,0Dh) (see #01680 at AH=59h/BX=0000h)
;Notes:  some device drivers support several subunits (that is more than one
;          drive) but it is not possible to distinguish between them with this
;          function; use INT 2F/AX=1510h or INT 2F/AX=0802h instead
;        under Windows95, the "mscd$$$$" device cannot be opened so you cannot
;          obtain the handle required by this function: use INT 2F/AX=1510h
;          or INT 2F/AX=0802h instead
;SeeAlso: AX=4402h"CD-ROM",INT 2F/AX=0802h,INT 2F/AX=1510h
;
;Format of CR-ROM control block:
;Offset  Size    Description     (Table 01524)
; 00h    BYTE    function code
;                00h eject disk
;                01h lock/unlock door
;                02h reset drive
;                03h control audio channel
;                04h write device control string
;                05h close tray
;---functions 00h,02h,05h---
; no further fields
;---function 01h---
; 01h    BYTE    lock function
;                00h unlock door
;                01h lock door
;---function 03h---
; 01h    BYTE    input channel (0-3) for output channel 0
; 02h    BYTE    volume for output channel 0
; 03h    BYTE    input channel (0-3) for output channel 1
; 04h    BYTE    volume for output channel 1
; 05h    BYTE    input channel (0-3) for output channel 2
; 06h    BYTE    volume for output channel 2
; 07h    BYTE    input channel (0-3) for output channel 3
; 08h    BYTE    volume for output channel 3
;Note:   output channels 0 and 1 are left and right, 2 and 3 are left prime and
;          right prime; a volume of 00h is off
;---function 04h---
; 01h  N BYTEs   bytes to send directly to the CD-ROM drive without
;                  interpretation


;==============================================================================
;Device Driver Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Device Driver Header (Standard Block Devices)
  ;This is the format of the first several bytes (offset 0) of a standard
  ;  Block Device Driver file, as loaded via CONFIG.SYS.
  ;In a regular Device Driver (loaded through CONFIG.SYS), this header MUST
  ;  be the first thing at the top of the file (OFFSET 0).
  ;We are "loading" ourselves indirectly by pulling some tricks on DOS
  ;  (much as DOS programs like JOIN, SUBST, ASSIGN, MSCDEX do)
  ;  through a COM file, not a SYS file, so it doesn't actually matter
  ;  what OFFSET this is at in our file.
  ;Being at an OFFSET other than 0 could cause problems with poorly written
  ;  programs, but several of the default DOS character drivers (like CON
  ;  and NUL and PRN) aren't at OFFSET 0, so programs should be used to it!
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  DvcHdrStruc         STRUC
    DHNextHeader         DD    ?  ;Point to the Next Device Header
                                  ;  Offset = -1 if this is Last Device Header
    DHAttribs            DW    ?  ;Device Attributes
     ;Block Devices
      DHAttrCharDvc     EQU 8000h ;Is a Character Device (must be clear!)
      DHAttrIOCtl       EQU 4000h ;IOCTL supported
      DHAttrIBMFormat   EQU 2000h ;IBM Format (non-FAT?)
      ;Bit 12 = Reserved (0)
      DHAttrNoOpenClose EQU 0800h ;Open/Close/RemovableMedia calls NOT supported
      ;Bits 10-8 = Reserved
      DHAttrGenIOCtlCk  EQU 0080h ;Generic IOCTL check supported (DOS 5.0+)
                                  ;  (Driver Command 25)
      DHAttrGenIOCtl    EQU 0040h ;Generic IOCTL supported (DOS 3.2+)
                                  ;  (Driver Command 19)
                                  ;  Also supports Get/Set Logical Device
      ;Bit 5 = Reserved (0)
      ;Bits 2-4 only apply to Character Devices (0)
      DHAttr32BitSector EQU 0002h ;Can handle 32-bit Sector Numbers (DOS 4+)
      ;Bit 1 only applies to Character Devices (0)
    DHStrategyOffset     DW    ?  ;Offset of Strategy Code Entry Point
                                  ;  Called with ES:[BX] = Request Header
    DHInterruptOffset    DW    ?  ;Offset of Interrupt Code Entry Point
    DHNumDrives          DB    ?  ;# of Logical Drive Letters - 1
    DHDvcName            DB 7 DUP ' ' ;Device Name
                                      ; Technically, this is not used for
                                      ;  anything, but we'll use it as a
                                      ;  Driver Name
   ENDS
  DvcHdrStrucSize EQU (TYPE DvcHdrStruc) ;Should be 18 bytes

  DHAttrsToUse EQU DHAttr32BitSector+DHAttrGenIOCtlCk+DHAttrGenIOCtl
    ;Attributes we will use for our USB Disk Drivers


;  ;----------------------------------------------------------------------------
;  ;Structure for DOS 3.1-3.3 7 DR-DOS 5.0-6.0 System File Tables (SFT)
;  ;  and File Control Blocks (FCB).
;  ;----------------------------------------------------------------------------
;  SftFcbDOS3Struc    STRUC
;    SFT3NumHandles      DW     ?  ;Number of File handles referring to this File
;                                  ;  SHSUCDX calls this SFT.RefCnt
;    SFT3OpenMode        DW     ?  ;Open Mode
;      ;Bits 0-2 = Access Mode
;      ModeReadOnly     EQU  0000h ;Read-only
;      ModeWriteOnly    EQU  0001h ;Write-only
;      ModeReadWrite    EQU  0002h ;Read/Write
;      ModeEXECCase     EQU  0003h ;Passed to Redirector on EXEC to allow
;                               ;  case-sensitive file-names
;      ;Bit 3 = Reserved (0)
;      ;Bits 4-6 = Sharing Mode
;      ModeCompat       EQU  0000h ;Compatibility Mode
;      ModeDenyAll      EQU  0010h ;Deny All Access by Others
;      ModeDenyWrite    EQU  0020h ;Deny Write Access by Others
;      ModeDenyRead     EQU  0030h ;Deny Read Access by Others
;      ModeDenyNone     EQU  0040h ;Allow Full Access by Others
;      ModeNetworkFCB   EQU  0070h ;Network FCB (only allowed during Server Call)
;      ;Bit 7 = Inheritance
;      ModeNoInherit    EQU  0080h ;File will not be Inherited by Child Processes
;      ;Bit 15 = Opened with FCB
;      ModeFCBOpen      EQU  8000h ;File was Opened via FCB
;    SFT3FileAttr        DB     ?  ;File Attributes
;      FAttrReadOnly    EQU    01h ;Read-only
;      FAttrHidden      EQU    02h ;Hidden
;      FAttrSystem      EQU    04h ;System
;      FAttrVolume      EQU    08h ;Volume Label (Novell Netware = Execute-only)
;      FAttrDirectory   EQU    10h ;Directory
;      FAttrArchive     EQU    20h ;Archive
;      ;Bit 6 = Reserved
;      ;Bit 7 = Pending Delete Files (Novell DOS, OpenDOS)
;      ;      = Shareable (Novell Netware)
;    SFT3DeviceInfo      DW     ?  ;Device Information
;      DvcInfoDriveMask EQU  003Fh ;Drive Number for Disk Files
;      ;Bits 6-11 = Reserved
;      DvcInfoNoInherit EQU  1000h ;Don't Inherit File on EXEC
;      ;Bit 13 = Reserved
;      DvcInfoNoDate    EQU  4000h ;Don't Update File Date/Time on Closing
;      DvcInfoRemote    EQU  8000h ;File is Remote
;    SFT3DPBPtr          DD     ?  ;Pointer to Drive Parameter Block (if Block)
;                                  ;Pointer to Driver Header (if Character)
;    SFT3StartCluster    DW     ?  ;Starting Cluster of File
;    SFT3FileTime        DW     ?  ;File Time (Packed Format)
;      FileTimeHourMask EQU  001Fh ;Seconds/2 (0-30)
;      FileTimeMinMask  EQU  07E0h ;Minutes (0-60)
;      FileTimeSec2Mask EQU 0F800h ;Hours (0-23)
;    SFT3FileDate        DW     ?  ;File Date (Packed Format)
;      FileDateDayMask  EQU  001Fh ;Day (0-31)
;      FileDateMonMask  EQU  01E0h ;Month (1-12)
;      FileDateYearMask EQU 0FE00h ;Year - 1980
;    SFT3FileSize        DD     ?  ;File Size
;    SFT3CurrentOffset   DD     ?  ;Current Offset on File (SFT Only -- not FCB)
;      FCB3LastIOCtrW   EQU (OFFSET SFT3CurrentOffset[0]) ;FCB Last I/O Counter (Word)
;      FCB3LastOpenCtr  EQU (OFFSET SFT3CurrentOffset[2]) ;FCB Last Open Counter (Word)
;    SFT3LastClusterRel  DW     ?  ;Relative Number of Last Cluster Accessed
;    SFT3LastClusterAbs  DW     ?  ;Absolute Number of Last Cluster Accessed
;    SFT3DirSector       DW     ?  ;Sector Number that contains Directory Entry
;    SFT3DirIndex        DB     ?  ;Index of Dir Entry in Sector (Byte Offset/32)
;    SFT3FileName        DB 11 DUP (' ') ;FIle Name (8.3, No Dot, Blank-padded)
;    SFT3PreviousSFT     DD     ?  ;Pointer to Previous SFT for File (SHARE)
;    SFT3NetMachineNum   DW     ?  ;Network Machine Number that opened file
;    SFT3OwnerPSPSegment DW     ?  ;PSP Segment of File Owner
;    SFT3ShareOffset     DW     ?  ;Offset within SHARE.EXE of Sharing Record
;  ENDS
;
;
;  ;----------------------------------------------------------------------------
;  ;Structure for DOS 4.0-6.0 System File Tables (SFT)
;  ;  and File Control Blocks (FCB).
;  ;----------------------------------------------------------------------------
;  SftFcbDOS4Struc     STRUC
;    SFT4NumHandles       DW    ?  ;Number of File handles referring to this File
;                                  ;  SHSUCDX calls this SFT.RefCnt
;    SFT4OpenMode         DW    ?  ;Open Mode
;                                  ;  Same as SFT3
;    SFT4FileAttr         DB    ?  ;File Attributes
;                                  ;  Same as SFT3
;    SFT4DeviceInfo       DW    ?  ;Device Information
;                                  ;  Same as SFT3, with additions
;      DvcInfoIsDevice   EQU 0080h ;Is a Device (not a File) (only if Local)
;      DvcInfoNetSpool   EQU 0800h ;Network Spooler
;      DvcInfoNamedPipe  EQU 2000h ;Named Pipe
;      ;If Character Device
;      DvcInfoChEOFIn    EQU 0040h ;End-of-File on Input
;      DvcInfoChRawMode  EQU 0020h ;Raw (Binady) Mode
;      DvcInfoChINT29h   EQU 0010h ;Device used INT 29h
;      DvcInfoChClock    EQU 0008h ;Is CLOCK Device
;      DvcInfoChNul      EQU 0004h ;Is NUL Device
;      DvcInfoChStdOut   EQU 0002h ;Is STDOUT Device
;      DvcInfoChStdIn    EQU 0001h ;Is STDIN Device
;      ;If Block Device
;      DvcInfoBkNotWrite EQU 0040h ;File Not Written
;      ;Bits 0-5 = Drive Number
;    SFT4DPBPtr          DD     ?  ;Pointer to Drive Parameter Block (if Block)
;                                  ;Pointer to Driver Header (if Character)
;    SFT4StartCluster    DW     ?  ;Starting Cluster of File (Local Files Only)
;                                  ;  Not set for FAT32 compatible OS's
;    SFT4FileTime        DW     ?  ;File Time (Packed Format)
;    SFT4FileDate        DW     ?  ;File Date (Packed Format)
;    SFT4FileSize        DD     ?  ;File Size
;    SFT4CurrentOffset   DD     ?  ;Current Offset on File (SFT Only -- not FCB)
;  ENDS


;; System File Table (SHSUCDX)
;struc SFT
;  .RefCnt       resw     1              ; Reference count
;  .Mode         resw     1              ; Open Mode
;  .DirAttrib    resb     1
;  .Flags        resw     1
;  .DCB          resd     1              ; Device control block
;  .Cluster      resw     1              ; Initial cluster
;  .HHMMSS       resw     1              ; Hour, Min, Sec/2
;  .YYMMDD       resw     1              ; Year, Month, Day
;  .FilSiz       resd     1              ; file size/EOF location
;  .FilPos       resd     1              ; Current file position
;  ;.RelClstr    resw     1              ; clusters from beginning
;  ;.CurClstr    resw     1              ; current cluster
;  ;.LBN         resw     1              ; block number
;  .FBN          resd     1              ; first block of file extent
;  .Owner        resw     1
;  .DirIndex     resb     1              ; directory index
;  .Name         resb    11              ; file name
;  .Unknown      resb     4
;  .OwnerMach    resw     1              ; machine number of owner
;  .OwnerPSP     resw     1              ; psp of owner task
;  .Status       resw     1
;endstruc

;; DOS Search Data Block (SHSUCDX)
;struc SDB
;  .DriveLet     resb     1              ; Drive Letter
;  .TemPlate     resb    11              ; Search template
;  .SAttr        resb     1              ; Search attribute
;  .Entry        resw     1              ; Entry Count within dir
;  .ParentBlk    resd     1              ; Blk # of start of parent
;  .ParentSize   resw     1              ; Size of parent, in blocks
;endstruc

;; DOS Found Data Block (SHSUCDX)
;struc FDB
;  .FName        resb    11              ; Found Filename
;  .Fattr        resb     1              ; Attr of found file
;  .Reserved     resb    10
;  .FTime        resd     1
;  .Cluster      resw     1
;  .FSize        resd     1
;endstruc


;
;
;       ---local file---
;        19h    WORD    relative cluster within file of last cluster accessed
;        1Bh    DWORD   number of sector containing directory entry
;        1Fh    BYTE    number of dir entry within sector (byte offset/32)
;       ---network redirector---
;        19h    DWORD   pointer to REDIRIFS record
;        1Dh  3 BYTEs   ???
;       ------
;        20h 11 BYTEs   filename in FCB format (no path/period, blank-padded)
;        2Bh    DWORD   (SHARE.EXE) pointer to previous SFT sharing same file
;        2Fh    WORD    (SHARE.EXE) network machine number which opened file
;                       (Windows Enhanced mode DOSMGR uses the virtual machine
;                         ID as the machine number; see INT 2F/AX=1683h)
;        31h    WORD    PSP segment of file's owner (see #01378 at AH=26h)
;                         (first three entries for AUX/CON/PRN contain segment
;                         of IO.SYS startup code)
;        33h    WORD    offset within SHARE.EXE code segment of
;                       sharing record (see #01595)  0000h = none
;        35h    WORD    (local) absolute cluster number of last clustr accessed
;                       (redirector) ???
;        37h    DWORD   pointer to IFS driver for file, 0000000h if native DOS
;Note:  the OS/2 2.0 DOS Boot Session does not properly fill in the filename
;         field due to incomplete support for SFTs; the OS/2 2.0 DOS Window
;         does not appear to support SFTs at all
;SeeAlso: #01639,#01640,#01641


;Format of DOS directory entry:
;Offset Size    Description     (Table 01352)
; 00h  8 BYTEs  blank-padded filename
;               first character is set to E5h for deleted files (05h for
;                 pending delete files under Novell DOS / OpenDOS)
; 08h  3 BYTEs  blank-padded file extension
; 0Bh   BYTE    attributes
; 0Ch 10 BYTEs  (MS-DOS 1.0-6.22) reserved
;               (DR DOS) used to store file password / owner (see #01354)
;                       (see also INT 21/AX=4302h)
;               (Novell DOS 7) DELWATCH data (see #01354)
;               (MS-DOS 7/Windows95) additional file times (see #01353)
; 16h   WORD    time of creation or last update (see #01665 at AX=5700h)
; 18h   WORD    date of creation or last update (see #01666 at AX=5700h)
; 1Ah   WORD    starting cluster number (see also AX=440Dh/CX=0871h)
;               (may not be set in INT 21/AH=11h return data for FAT32 drives)
; 1Ch   DWORD   file size
;SeeAlso: #01355,#02628,#02629


;Format of sharing record:
;Offset Size    Description     (Table 01637)
; 00h   BYTE    flag
;               00h free block
;               01h allocated block
;               FFh end marker
; 01h   WORD    size of block
; 03h   BYTE    checksum of pathname (including NUL)
;               if sum of ASCII values is N, checksum is (N/256 + N%256)
; 04h   WORD    offset in SHARE's DS of first Record Lock Record (see #01638)
; 06h   DWORD   pointer to start of system file table chain for file
; 0Ah   WORD    unique sequence number
; 0Ch   var     ASCIZ full pathname
;Note:  not supported by DR DOS SHARE 1.1 and 2.0; will reportedly be
;         supported by Novell DOS 7
;SeeAlso: #01636,#01638




;==============================================================================
;Disk-Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Structure for a Partition Record
  ;There are four of these in each Partition Record (the first being the
  ;  Master Boot Record on the first Sector of a Hard Disk).  There are also
  ;  four in each Extended Partition Record, if any exist.
  ;----------------------------------------------------------------------------
  PartRecordStruc STRUC      ;Structure for a Partition Record
    PartPrimary      DB   ?  ;Primary (Active) Partition Indicator
      PPrimaryNo    EQU  00h ;Is not the Primary (Bootable) Partition
      PPrimaryYes   EQU  80h ;Is the Primary (Bootable) Partition
                             ;There can only be one Primary Partition!
    PartStartHead    DB   ?  ;Partition Starting Head
    PartStartSect    DB   ?  ;Partition Starting Sector
      PSectSector   EQU  3Fh ;Sector is only in bits 0-5
      PSectCyl89    EQU 0C0h ;Bits 8-9 of Starting Cylinder/Track
    PartStartCyl     DB   ?  ;Partition Starting Cylinder/Track
                             ;  (bits 8-9 come from PartStartSect)
    PartOpSys        DB   ?  ;Operating System Indicator
                             ;The following OS type list is not guaranteed to
                             ;  be either accurate or complete, other than the
                             ;  low-numbered ones relating to DOS
      POSNone       EQU  00h ;None (Empty Parition Entry)
      POSFAT12      EQU  01h ;DOS 12-bit FAT
      POSXenixRoot  EQU  02h ;XENIX root file system
      POSXenixUsr   EQU  03h ;XENIX /usr file system (obsolete)
      POSFAT16      EQU  04h ;FAT16 (max 32M)
      POSDOSExt     EQU  05h ;DOS Extended
      POSFAT16H     EQU  06h ;FAT16 (32M+)
      POSQNX        EQU  07h ;QNX, HPFS, NTFS, Advanced Unix, FAT64 (exFAT),
                             ;  maybe others
      POSAIXBoot    EQU  08h ;OS/2 (v1.0-1.3 only), AIX Bootable, SplitDrive,
                             ;  Commodore DOS,
                             ;  DELL Partition Spanning Multiple Drives
      POSAIXData    EQU  09h ;AIX Data, Coherent
      POSOS2        EQU  0Ah ;OS/2 Boot Manager, OPUS, Coherent Swap
      POSFAT32      EQU  0Bh ;FAT32
      POSFAT32LBA   EQU  0Ch ;FAT32 w/ LBA extensions
      POSLBAVFAT16H EQU  0Eh ;LBA VFAT (same as 06h but using LBA-mode INT 13)
      POSLBAVFATExt EQU  0Fh ;LBA VFAT (same as 05h but using LBA-mode INT 13)
      POSOpus       EQU  10h ;OPUS
      POSOS2FAT12H  EQU  11h ;OS/2 Boot Manager Hidden FAT12
      POSCompaqDiag EQU  12h ;Compaq Diagnostics
      POSOS2FAT16H  EQU  14h ;OS/2 Boot Manager Hidden FAT16 (max 32M)
      POSOS2FAT16HH EQU  16h ;OS/2 Boot Manager Hidden FAT16 (32M+)
      POSOS2HPFSH   EQU  17h ;OS/2 Boot Manager Hidden HPFS, Hidden NTFS
      POSASTSwap    EQU  18h ;AST Special Windows Swap File (Zero-Volt Suspend)
      POSPhoton     EQU  19h ;Willowtech Photon coS
      POSFAT32H     EQU  1Bh ;FAT32 Hidden
      POSFAT32HH    EQU  1Ch ;FAT32 Hidden w/ LBA extensions
      POSLBAVFATH   EQU  1Eh ;LBA VFAT Hidden
      POSOFS1       EQU  20h ;OFS1 (Willowsoft Overture File System)
      POSReserv21   EQU  21h ;Reserved, Oxygen FSo2
      POSReserv22   EQU  22h ;Reserved, Oxygen Extended
      POSReserv23   EQU  23h ;Reserved
      POSNECDOS     EQU  24h ;NEC MS-DOS 3.x
      POSReserv26   EQU  26h ;Reserved
      POSReserv31   EQU  31h ;Reserved
      POSAlien      EQU  32h ;Alien NOS
      POSReserv33   EQU  33h ;Reserved
      POSReserv34   EQU  34h ;Reserved
      POSOS2JFS     EQU  35h ;OS/2 JFS
      POSReserv36   EQU  36h ;Reserved
      POSTheos      EQU  38h ;Theos
      POSPartMagic  EQU  3Ch ;PowerQuest PartitionMagic Recovery
      POSNWHidden   EQU  3Dh ;Netware Hidden
      POSVenix      EQU  40h ;VENIX 80286
      POSPersRISC   EQU  41h ;Personal RISC Boot, PowerPC Boot
      POSSFS        EQU  42h ;SFS (Secure File System)
      POSPTSDOS     EQU  43h ;PTS-DOS 6.7
      POSGoBack     EQU  44h ;GoBack
      POSEumel1     EQU  45h ;EUMEL/Elan
      POSEumel2     EQU  46h ;EUMEL/Elan
      POSEumel3     EQU  47h ;EUMEL/Elan
      POSEumel4     EQU  48h ;EUMEL/Elan
      POSAdaOS      EQU  4Ah ;AsaOS Aquila
      POSOberon1    EQU  4Ch ;Oberon
      POSQNX1       EQU  4Dh ;QNX 4.0 First Partition
      POSQNX2       EQU  4Eh ;QNX 4.0 Second Partition
      POSQNX3       EQU  4Fh ;QNX 4.0 Third Partition, Oberon Boot/Data?
      POSOnTrack1   EQU  50h ;OnTrack Disk Manager Read-only
      POSOnTrack2   EQU  51h ;OnTrack Disk Manager Read/write, NOVELL
      POSCPM1       EQU  52h ;CP/M, Microport System V/386
      POSOnTrack3   EQU  53h ;OnTrack Disk Manager Write-only?
      POSOnTrack4   EQU  54h ;OnTrack Disk Manager (DDO)
      POSEZDrive    EQU  55h ;EZ-Drive
      POSGoldenBow  EQU  56h ;GoldenBow VFeature
      POSPriam      EQU  5Ch ;Priam EDISK
      POSSpeedSto1  EQU  61h ;SpeedStor
      POS386IX      EQU  63h ;Unix SysV/386, 386/ix, Mach, MtXinu BSD 4.3 on Mach, GNU HURD
      POSNovell1    EQU  64h ;Novell NetWare 286, SpeedStore
      POSNovell2    EQU  65h ;Novell NetWare 3.11
      POSNovell3    EQU  67h ;Novell
      POSNovell4    EQU  68h ;Novell
      POSNovell5    EQU  69h ;Novell
      POSDiskSecur  EQU  70h ;DiskSecure Multi-Boot
      POSReserv71   EQU  71h ;Reserved
      POSReserv73   EQU  73h ;Reserved
      POSReserv74   EQU  74h ;Reserved
      POSPCIX       EQU  75h ;PC/IX
      POSReserv76   EQU  76h ;Reserved
      POSFIX        EQU  7Eh ;F.I.X.
      POSMinix1     EQU  80h ;Minix v1.1 - 1.4a
      POSMinix2     EQU  81h ;Minix v1.4b+, Linux, Mitac Advanced Disk Manager
      POSLinuxSwap  EQU  82h ;Linux Swap, Prime, Solaris
      POSLinuxNFS   EQU  83h ;Linux Native File System (ext2fs/xiafs)
      POSOS2Renum   EQU  84h ;OS/2-renumbered type 04h (related to hiding DOS C: drive)
      POSLinuxExt   EQU  85h ;Linux EXT
      POSFAT16Str   EQU  86h ;FAT16 Volume/Stripe (Windows NT)
      POSHPFSMir    EQU  87h ;HPFS Fault-Tolerant Mirror, NTFS Volume/Stripe
      POSAmoebaFS   EQU  93h ;Amoeba File System
      POSAmoebaBad  EQU  94h ;Amoeba Bad Block Table
      POSDataLight  EQU  98h ;Datalight ROM-DOS SuperBoot
      POSMylex      EQU  99h ;Mylex EISA SCSI
      POSNoteBIOS   EQU 0A0h ;Phoenix NoteBIOS Power Management "Save-to-Disk"
      POSReservA1   EQU 0A1h ;Reserved
      POSReservA3   EQU 0A3h ;Reserved
      POSReservA4   EQU 0A4h ;Reserved
      POSFreeBSD    EQU 0A5h ;FreeBSD, BSD/386, BSD Variant
      POSOpenBSD    EQU 0A6h ;OpenBSD
      POSNeXTStep   EQU 0A7h ;NeXTStep
      POSNetBSD     EQU 0A9h ;NetBSD
      POSDarwin     EQU 0ABh ;Apple Darwin Boot
      POSReservB1   EQU 0B1h ;Reserved
      POSReservB3   EQU 0B3h ;Reserved
      POSReservB4   EQU 0B4h ;Reserved
      POSReservB6   EQU 0B6h ;Reserved, Windows NT Mirror Master, FAT16
      POSBSDI       EQU 0B7h ;BSDI File System, Windows NT Mirror Master, NTFS
      POSBSDISwap   EQU 0B8h ;BSDI Swap (Secondarily File System)
      POSSolarisBt  EQU 0BEh ;Solaris Boot
      POSCTOS       EQU 0C0h ;DR DOS/DR-DOS/Novell DOS Secured, CTOS
      POSFAT12Log   EQU 0C1h ;FAT12 DR DOS 6.0 LOGIN.EXE-Secured
      POSFAT16Log   EQU 0C4h ;FAT16 DR DOS 6.0 LOGIN.EXE-Secured
      POSDDLogin    EQU 0C6h ;DR DOS 6.0 LOGIN.EXE-Secured Huge,
                             ;  Windows NT Corrupted FAT16 Volume/Stripe,
                             ;  Windows NT Mirror Slave, FAT16
      POSSyrinx     EQU 0C7h ;Syrinx Boot, Corrupted NTFS Volume/Stripe,
                             ;  Windows NT Mirror Slave, NTFS
      POSReservCB   EQU 0CBh ;FAT32 Reserved for DR DOS/DR-DOS/OpenDOS Secured
      POSReservCC   EQU 0CCh ;FAT32 LBA Reserved for DR DOS/DR-DOS Ssecured
      POSReservCE   EQU 0CEh ;FAT16 LBA Reserved for DR DOS/DR-DOS Secured
      POSFAT12SMU   EQU 0D0h ;FAT12 Multiuser DOS Secured
      POSFAT12MU    EQU 0D1h ;FAT12 Old Multiuser DOS Secured
      POSEOSGEFAT1  EQU 0D2h ;OSG EFAT Tiny Version
      POSEOSGEFAT2  EQU 0D3h ;OSG EFAT Normal Version
      POSFAT16MU    EQU 0D4h ;FAT16 Old Multiuser DOS secured (max 32M),
                             ;  OSG EFAT Secured Version
      POSMUSecExt   EQU 0D5h ;Old Multiuser DOS Secured Extended,
                             ;  OSG EFAT Optical Version
      POSFAT16HMU   EQU 0D6h ;FAT16 Old Multiuser DOS Secured (32M+)
      POSCPM2       EQU 0D8h ;CP/M-86
      POSCPM3       EQU 0DBh ;CP/M, Concurrent CP/M, Concurrent DOS, CTOS
      POSBootItNG   EQU 0DFh ;Boot-It NG
      POSFAT12XSS   EQU 0E1h ;FAT12 SpeedStor Extended
      POSPainke     EQU 0E2h ;DOS Read-only (Florian Painke's XFDISK 1.0.4)
      POSDOSROSD    EQU 0E3h ;DOS Read-only, Storage Dimensions
      POSFAT16XSS   EQU 0E4h ;FAT16 SpeedStor Extended
      POSReservE5   EQU 0E5h ;Reserved
      POSReservE6   EQU 0E6h ;Reserved
      POSBeOS       EQU 0EBh ;BeOS BFS-1
      POSGPT        EQU 0EEh ;GUID Partition Table (Required for Itanium)
      POSPARISC     EQU 0F0h ;Linux/PA-RISC Boot Loader
      POSStorDim    EQU 0F1h ;Storage Dimensions
      POSDOS33Sec   EQU 0F2h ;DOS 3.3+ Secondary
      POSReservF3   EQU 0F3h ;Reserved, SpeedStor
      POSSpeedSto2  EQU 0F4h ;SpeedStor, Storage Dimensions
      POSPrologue   EQU 0F5h ;Prologue
      POSReservF6   EQU 0F6h ;Reserved, Storage Dimensions, SpeedStor
      POSOSGEFAT3   EQU 0F7h ;OSG EFAT
      POSBochs      EQU 0FAh ;MandrakSoft's Bochs x86 Emulator
      POSVMWareFS   EQU 0FBh ;VMWare File System
      POSVMWareSwap EQU 0FCh ;VMWare Swap
      POSLinuxRAID  EQU 0FDh ;Linux RAID
      POSLANStep    EQU 0FEh ;LANstep, IBM PS/2 IML
      POSXenixBad   EQU 0FFh ;Xenix Bad Block Table
    PartEndHead      DB   ?  ;Partition Ending Head
    PartEndSect      DB   ?  ;Partition Ending Sector (bits 0-5)
    PartEndCyl       DB   ?  ;Partition Ending Cylinder/Track
                             ;  (bits 8-9 come from PartEndSect)
    PartLBASector    DD   ?  ;LBA Starting Sector (number of sectors
                             ;  preceding the partition)
    PartLBALength    DD   ?  ;Length of Partition (Sectors)
   ENDS ;16 bytes
  PRecordSize EQU (TYPE PartRecordStruc) ;16 Bytes


  ;----------------------------------------------------------------------------
  ;Structure for a Master Boot Record or Extended Partition Record
  ;----------------------------------------------------------------------------
  MasterBootStruc STRUC
   MBRCode      DB 446 DUP (?) ;446 bytes of unknown data
                               ;For MBR, this is the boot code
                               ;For Extended Partition Record, this is zeroes
   MBRPart1     DB PRecordSize DUP (?) ;Partition 1 Record
   MBRPart2     DB PRecordSize DUP (?) ;Partition 2 Record
   MBRPart3     DB PRecordSize DUP (?) ;Partition 3 Record
   MBRPart4     DB PRecordSize DUP (?) ;Partition 4 Record
   MBRSignature DW 0AA55h ;Signature indicating an MBR or Partition Boot Record
   ENDS ;512 Bytes (1 standard sector)

  ;----------------------------------------------------------------------------
  ;Int 21h FAT32 Extended Absolute Disk Read/Write Mode Flags
  ;  (in SI on INT 21h, Function 7305h Call)
  ;----------------------------------------------------------------------------
  I21XRWWrite     EQU 0001h ;Write (Output) (0 = Read/Input)
  ;Bits 1-12 = Reserved (0)
  I21XRWWrType    EQU 6000h ;Write Type (Reads should be 0)
    I21XRWUnknown EQU 0000h ;Unknown Data
    I21XRWFAT     EQU 2000h ;FAT Data
    I21XRWDir     EQU 4000h ;Directory Data
    I21XRWFile    EQU 6000h ;File Data
  ;Bit 15 = Reserved (0)

  ;----------------------------------------------------------------------------
  ;Structure for INT 25h & INT 26h Extended Functions (Disks <= 2GB)
  ;Also for INT 21h/AX=7305h FAT32 Function
  ;----------------------------------------------------------------------------
  Int25PktStruc STRUC
    I25PktSectNum  DD ? ;Sector Number
    I25PktNumSects DW ? ;Number of Sectors to Read/Write
    I25PktXferAddr DD ? ;Transfer Address
   ENDS


;==============================================================================
;USB/Drive-Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;This structure is called a Command Block Wrapper.
  ;It is used with Bulk-Only Devices to send Control Commands to a Drive.
  ;----------------------------------------------------------------------------
  CommandBlockWrapperStruc STRUC
    CBWSignature  DD 4342_5355h ;Signature for a CBW (to distinguish from Data)
    CBWUserTag    DD         ?  ;Tag Defined by User (echoed in CSW)
    CBWDataSize   DD         ?  ;Number of Bytes to Transfer
                                ;If 0, no Data Transfer Stage will be issued
    CBWFlags      DB         ?  ;Flags
      CBWFlagIn  EQU        80h ;Direction = In (for Data Transfer, if any)
                                ;Bit 6 = Obsolete (Reserved), 5-0 = Reserved (0)
    CBWLUN        DB         ?  ;Logical Unit Number (0-15)
    CBWCmdBlkSize DB         ?  ;Size of Command Block (1-16)
    CBWCmdBlock   DB 16 DUP (?) ;Command Block to Send
                                ;If < 16 bytes, load at beginning of Block
    CBWFiller     DB         ?  ;To align at even addresses
  ENDS
    CBWSize EQU ((TYPE CommandBlockWrapperStruc)-1) ;ALWAYS send 31 bytes!!

  ;----------------------------------------------------------------------------
  ;This structure is called a Command Status Wrapper.
  ;It is used with Bulk-Only Devices to receive Status from a Drive.
  ;----------------------------------------------------------------------------
  CommandStatusWrapperStruc STRUC
    CSWSignature    DD 5342_5355h ;Signature for a CSW (to distinguish from Data)
    CSWUserTag      DD         ?  ;Tag Defined by User (echoed from CBW)
    CSWDataResidue  DD         ?  ;Number of Relevant Bytes "Unsent" by the CBW
                                  ;  (Difference between CBWDataSize and Reality)
    CSWStatus       DB         ?  ;Actual Status Byte
      CSWStsOK     EQU        00h ;OK (No Error)
      CSWStsFail   EQU        01h ;Command Failed
      CSWStsPhase  EQU        02h ;Phase Error
                                  ;Error Codes 03h-04h = Obsolete
                                  ;Error Codes 05h-FFh = Reserved
    CSWFiller       DB         ?  ;To align at even addresses
  ENDS
    CSWSize EQU ((TYPE CommandStatusWrapperStruc)-1) ;ALWAYS sends 13 bytes!!

  ;----------------------------------------------------------------------------
  ;There are three logical "divisions" in getting from a USB Device/Interface
  ;  to a Drive Letter (A:-Z:) that DOS uses.
  ;A USB Device/Interface is set up like SCSI, which means it can have
  ;  multiple LUNs (Logical Unit Numbers) per Device/Interface.
  ;  We will use the term LUN and Disk pretty much interchangably, since it
  ;  tracks nicely with what we would commonly call a "Disk".  Each LUN can
  ;  be a different size and media format than the the other LUNs on the
  ;  same Device/Interface, and if the media is removable, some media
  ;  can be there when the others aren't.  The BIOS INT 13h functions
  ;  generally request information from drives at this level -- all they
  ;  care about is disk geometry (CHS), not OS or FAT or Partitions.
  ;Each Disk/LUN can also have multiple Partitions on it, each being associated
  ;  with a separate DOS Drive Letter.  The DOS Device Driver & INT 25h/26h
  ;  functions operate at this level.  The information they need is always
  ;  relative to a Paritition (actually, a Partition/Volume Boot Record).
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;This structure keeps track of each of the several individual USB Devices
  ;  (Technically, this keeps track of USB Interfaces, not Devices.  But, we
  ;  will call them Devices for simplicity sake until it causes us grief,
  ;  at which time we may choose to call them Interfaces).
  ;----------------------------------------------------------------------------
  DeviceInfoStruc    STRUC
    DvcFlags             DB  ?  ;Misc Yes/No Flags
      DvcFlagInUse      EQU 01h ;This entry currently being used?
      DvcFlagNoLock     EQU 02h ;Device is known to be unlockable
    DvcHostIndex         DB  ?  ;Host Index this Device is on
    DvcAddress           DB  ?  ;Device Address of Device
    DvcInterfaceNum      DB  ?  ;Interface number of Device (usually 0)
    DvcIntfSubClass      DB  ?  ;Interface SubClass
    DvcIntfProtocol      DB  ?  ;Interface Protocol
    DvcEndPointIn        DB  ?  ;In End Point
    DvcEndPointOut       DB  ?  ;Out End Point
    DvcEndPointInt       DB  ?  ;Interrupt End Point
    DvcMaxLUN            DB  ?  ;Maximum Logical Unit Number
    DvcRegHandle         DW  ?  ;Handle Number of Owner Registry
    DvcInt14Request      DB Int14RequestSize DUP (?) ;Interrupt 14 Request
   ENDS
  DeviceInfoSize EQU (TYPE DeviceInfoStruc)

  ;----------------------------------------------------------------------------
  ;This structure keeps track of each of each Disk/LUN (can be many per Device)
  ;----------------------------------------------------------------------------
  DiskInfoStruc       STRUC
    DskFlags             DB  0  ;Misc Yes/No Flags #1
      DskFlagInUse      EQU 01h ;This entry currently being used
      DskFlagReqInProg  EQU 02h ;A Request is currently in Progress
      DskFlagShortPktOK EQU 04h ;Short Data Packet OK in SCSI Command Request
      DskFlagAccessed   EQU 08h ;Disk has been accessed at least once
      DskFlagWriteProt  EQU 10h ;Disk is Write Protected
      DskFlagI13ChgRptd EQU 20h ;Disk Change Reported through INT 13h
      DskFlagNoRetry    EQU 40h ;Don't retry failed SCSI Request
      DskFlagReqSense   EQU 80h ;Doing Request Sense
    DskFlags2            DB  0  ;Misc Yes/No Flags #2
      DskFlagNoLock     EQU 01h ;Don't issue Lock/Unlock Requests
      DskFlagNoStart    EQU 02h ;Don't issue Start/Stop Requests
      DskFlagNoSync     EQU 04h ;Don't issue Sync Cache Requests
    DskReqSenseFlags     DB  0  ;Misc Flags for Request Sense
    DskInt13DrvNum       DB  ?  ;Drive Number for Int 13h Calls
                                ;  (80h = 1st Physical Drive, 81h = 2nd, etc.)
                                ;Can have multiple partitions on each Physical Disk
    DskInt13LastSts      DB  ?  ;Int 13h Return Status Last Time
    DskLUN               DB  ?  ;Logical Unit Number of this Disk
    DskAccessTimer       DB  0  ;Timer needed to keep track of Media Changes
                                ;  Floppies & Other Removable Media)
                                ;-1 = No Changeable Media, 0 = Timed Out,
                                ;  Anything else = Counting Down
    DskStopTimer         DB  ?  ;Timer to issue Stop/Unlock Requests
    DskSCSICmdSize       DB  ?  ;Size of SCSI Command (Group 3-4, 6-7)
                                ;  (0 = Use Default)
    DskSCSIRetries       DB  ?  ;Retry Counter for SCSI Requests
    DskDvcOffset         DW  ?  ;Device Info Entry Ptr that Drive is on
    DskNumHeads          DW  ?  ;Number of Heads (Heads Per Track/Cylinder)
    DskNumTracks         DW  ?  ;Number of Tracks/Cylinders
    DskSectsPerTrack     DW  ?  ;Number of Sectors Per Track/Cylinder
    DskBytesPerSect      DW  ?  ;Block (Sector) Size
    DskMaxLBA            DD  ?  ;Maximum Large Block Address (Sector Number)
    DskEPResetRtn        DW  ?  ;Return Address to use when Resetting EndPts
    DskDrvTimer          DB  ?  ;Countdown Timer to look for Drive letters
                                ;  Also used as "No Media" Flag (If <> 0)
      DskStageOnHold    EQU 252 ;Process is On Hold, waiting until later
      DskStageNewDisk   EQU 253 ;Have a New Disk
      DskStageInProc    EQU 254 ;Still processing a New Disk
      DskStageStartup   EQU 255 ;Still in Inquiry/Startup Stage
    DskSCSIRequest       DB  ?  ;Last SCSI Request Type issued
    DskSCSIReqErrSetup   DB  ?  ;Lower byte of TD Status during Setup Stage
    DskSCSIReqErrData    DB  ?  ;Lower byte of TD Status during Data Stage
    DskSCSIReqErrStatus  DB  ?  ;Lower byte of TD Status during Status Stage
    DskCSWStatus         DB  ?  ;Status returned by SCSI Request (in CSW)
    DskCSWResidue        DD  ?  ;Residue (# of unsent Data Bytes)
    DskLastSectorRW      DD  ?  ;Last Sector Accessed (LBA)
    DskPerIntStatus      DW  ?  ;Status returned by Periodic Int (CBI/UFI)
    DskPerIntReqSenseSts DW  ?  ;Status returned by Request Sense
    DskSenseBuffer       DB SReqSenseRespSize DUP (?) ;Request Sense Response
    DskASCQTable         DD ASCQBuffEntries DUP (?) ;Table of ASC/Q Codes
    DskCBWDataPtr        DD  ?  ;Data Pointer for CBW
    DskCBW               DB (CBWSize+1) DUP (0) ;Command Block Wrapper
    DskCSW               DB (CSWSize+1) DUP (0) ;Command Status Wrapper
    DskReqSenseDataPtr   DD  ?  ;Original Data Pointer for Req Sense
    DskReqSenseCBW       DB (CBWSize+1) DUP (0) ;Original CBW for Req Sense
    DskReqSenseCSW       DB (CSWSize+1) DUP (0) ;CSW from Request Sense
   ENDS
  DiskInfoSize EQU (TYPE DiskInfoStruc)

  ;----------------------------------------------------------------------------
  ;This structure keeps track of each of each Drive (Partition on a Disk/LUN)
  ;----------------------------------------------------------------------------
  DriveInfoStruc    STRUC
    DrvFlags           DB  0  ;Misc Yes/No Flags
      DrvFlagInUse    EQU 01h ;This entry currently being used
      DrvFlagValid    EQU 02h ;Entry is Valid (can be used)
      DrvFlagReady    EQU 04h ;Drive is configured and Ready
      DrvFlagLocalBPB EQU 08h ;Use Local (Stored) BPB - don't download
                              ;  from Device
    DrvPartOS          DB  ?  ;Partition Operating System (-1 = Floppy)
    DrvGIOAccess       DB  ?  ;Generic IOCTL Access Status (0 = No Access)
    DrvFiller          DB  ?  ;To align at even addresses

    DrvFmtCyls         DW  ?  ;Number of Cylinders while Formatting
    DrvFmtHeads        DW  ?  ;Number of Heads while Formatting
    DrvFmtSects        DW  ?  ;Number of Sectors while Formatting
    DrvFmtTotalSects   DD  ?  ;Total Number of Sectors while Formatting

    DrvDskOffset       DW  ?  ;Disk Info Entry Pointer that Drive is on
    DrvBootSector      DD  ?  ;LBA of Sector that Boot Record Info for this
                              ;  Drive is stored in (Boot Record contains BPB)
                              ;  Same as "Hidden Sectors"
    DrvSectsInPart     DD  ?  ;Number of Sectors in Partition
    DrvPartSector      DD  ?  ;LBA of Sector that Partition Info for this
                              ;  Drive is stored in (-1 = None)
    DrvPartIndex       DB  ?  ;Index of this Drive's Partition Entry in the
                              ;  Partition Table (0-3)
    DrvVolumeName      DB 11 DUP (?) ;Volume Name
    DrvBPB             DB (BPBFAT32Size+1) DUP (0) ;BIOS Parameter Block
    DrvDPB             DB DDSCSize DUP (0) ;Drive Parameter Block
                                           ;We leave enough room for the EDR-DOS
                                           ;  DDSC here, since it is bigger than
                                           ;  the standard MS-DOS/FreeDOS EDPB
                                           ;DOS fills most of this in, so we
                                           ;  don't really care about the
                                           ;  structure, just the size
   ENDS
  DriveInfoSize EQU (TYPE DriveInfoStruc)

  ;----------------------------------------------------------------------------
  ;This structure keeps track of Bad (incompatible) Devices
  ;----------------------------------------------------------------------------
  BadDeviceStruc   STRUC
    BDFlags           DB  ?  ;Misc Yes/No Flags
      BDFlagInUse    EQU 01h ;This entry currently being used?
    BDInterfaceNum    DB  ?  ;Interface Number of Bad Device
    BDHostIndex       DB  ?  ;Host Index of Bad Device
    BDDvcAddress      DB  ?  ;Device Address of Bad Device
    BDNewDeviceError  DW  ?  ;Bad Device Error Code First Time
    BDNewDeviceStage  DB  ?  ;Bad Device Stage First Time
    BDFiller          DB  ?  ;To align at even addresses
    BDSCSIRequest     DB  ?  ;Last SCSI Request Type
    BDSCSISetupErr    DB  ?  ;Error during last SCSI Request Setup Stage
    BDSCSIDataErr     DB  ?  ;Error during last SCSI Request Data Stage
    BDSCSIStatusErr   DB  ?  ;Error during last SCSI Request Status Stage
    BDSCSICSWStatus   DB  ?  ;Last SCSI Request Status Code
    BDSCSISenseKey    DB  ?  ;Sense Key
    BDSCSISenseInfo   DD  ?  ;Sense Info (LBA?)
    BDCSWResidue      DD  ?  ;Residue from last SCSI Request
    BDSCSIASC         DB  ?  ;Additional Sense Code
    BDSCSIASCQ        DB  ?  ;Additional Sense Code Qualifier
    BDLastSectorRW    DD  ?  ;Last Sector Read/Written to (LBA)
   ENDS
  BadDeviceStrucSize EQU (TYPE BadDeviceStruc)

  ;----------------------------------------------------------------------------
  ;This is the format for a request sent to Int 14h to Send/Receive Data
  ;It contains the type of request, etc.
  ;----------------------------------------------------------------------------
  Int14RequestStruc         STRUC      ;Structure for an Int 14 Request
    I14RRequestType            DB   ?  ;Type of Request
      I14RRTHostClass         EQU  00h ;Host/System/OS Class
        I14RRTGetHostSWInfo   EQU  01h ;Get Host Software Info
        I14RRTGetHostHWInfo   EQU  02h ;Get Host Hardware Info
        I14RRTGetHostVendInfo EQU  03h ;Get Host Vendor Info
        I14RRTGetHostStatus   EQU  04h ;Get Current Host Status
        I14RRTHostRun         EQU  08h ;Start/Run/Resume Host
        I14RRTHostStop        EQU  09h ;Stop Host
        I14RRTHostReset       EQU  0Ah ;Reset Host
        I14RRTHostSuspend     EQU  0Bh ;Global Suspend Host
        I14RRTHostResume      EQU  0Ch ;Force Global Resume on Host
      I14RRTTimingClass       EQU  10h ;Frame Timing Class
        I14RRTRegTmgOwner     EQU  11h ;Register as Timing Owner
        I14RRTUnRegTmgOwner   EQU  12h ;UnRegister as Timing Owner
        I14RRTIncTiming       EQU  13h ;Increment (Slow Down) Frame Timing
        I14RRTDecTiming       EQU  14h ;Decrement (Speed Up) Frame Timing
        I14RRTChangeTiming    EQU  15h ;Change Frame Timing (by Large Amount)
      I14RRTHubClass          EQU  20h ;Hub Class
        I14RRTGetDvcHubInfo   EQU  21h ;Get Hub Info for Device
        I14RRTNewDvcConn      EQU  24h ;Hub has Detected new Device
        I14RRTDvcDisc         EQU  25h ;Device has been Disconnected
        I14RRTSendHubChar     EQU  27h ;Send Hub Characteristics to Host
        I14RRTEnableHubPort   EQU  28h ;Enable Device given Hub & Port
        I14RRTDisableHubPort  EQU  29h ;Disable Device given Hub & Port
        I14RRTResetHubPort    EQU  2Ah ;Reset Device given Hub & Port
        I14RRTSuspendHubPort  EQU  2Bh ;Suspend Device given Hub & Port
        I14RRTResumeHubPort   EQU  2Ch ;Resume Device given Hub & Port
        I14RRTPwrOnHubPort    EQU  2Dh ;Power On Device given Hub & Port
        I14RRTPwrOffHubPort   EQU  2Eh ;Power Off Device given Hub & Port
        I14RRTPwrResetHubPort EQU  2Fh ;Power Reset Device given Hub & Port
      I14RRTTPowerClass       EQU  30h ;Power Class
        I14RRTGetDvcPowerInfo EQU  31h ;Get Power Info for Device
        I14RRTGetHubPowerDraw EQU  32h ;Get Power Draw for Hub
        I14RRTPwrOnDevice     EQU  3Dh ;Power On Device given Dvc Addr
        I14RRTPwrOffDevice    EQU  3Eh ;Power Off Device given Dvc Addr
        I14RRTPwrResetDevice  EQU  3Fh ;Power Reset Device given Dvc Addr
      I14RRTDeviceClass       EQU  40h ;Device Class
        I14RRTGetDvcClassInfo EQU  41h ;Get Device Class Info
        I14RRTGetDvcVendInfo  EQU  42h ;Get Device Vendor Info
        I14RRTGetDvcStatus    EQU  43h ;Get Device Status
        I14RRTEnableDevice    EQU  48h ;Enable/Resume Device given Dvc Addr
        I14RRTDisableDevice   EQU  49h ;Disable Device given Dvc Addr
        I14RRTResetDevice     EQU  4Ah ;Reset Device given Dvc Addr
        I14RRTSuspendDevice   EQU  4Bh ;Suspend Device given Dvc Addr
        I14RRTResumeDevice    EQU  4Ch ;Resume Device given Dvc Addr
      I14RRTConfigClass       EQU  50h ;Configuration Class
        I14RRTConfigingIntf   EQU  51h ;Driver is Configuring an Interface
        I14RRTConfigIntfDone  EQU  52h ;Interface Configuration is Complete
        I14RRTSetNewConfig    EQU  58h ;Set/Change Device Config Value
      I14RRTInterfaceClass    EQU  60h ;Interface Class
        I14RRTFindRegIntf     EQU  62h ;Look for Registered Interface
        I14RRTFindUnRegIntf   EQU  63h ;Look for Unregistered Interface
        I14RRTRegIntfOwner    EQU  64h ;Register as Interface Owner
        I14RRTUnRegIntfOwner  EQU  65h ;Unregister as Interface Owner
        I14RRTIntfDontLook    EQU  68h ;Existing Interface Owner Don't Look
      I14RRTAltIntfClass      EQU  70h ;Alternate Interface Class
        I14RRTGetAltIntfInfo  EQU  71h ;Get Alternate Interface Info
      I14RRTEndPointClass     EQU  80h ;End Point Class
        I14RRTGetDataX        EQU  81h ;Get Current DataX Value
        I14RRTIncDataX        EQU  88h ;Increment/Toggle DataX Value
      I14RRTPacketClass       EQU  90h ;Packet Class
        I14RRTDoIsoch         EQU  94h ;Schedule Isochronous Transaction
        I14RRTDoInterruptPer  EQU  95h ;Schedule Periodic Interrupt
        I14RRTDoControl       EQU  96h ;Schedule Control/Setup Request
        I14RRTDoBulk          EQU  97h ;Schedule Bulk Transaction
        I14RRTDoInterrupt1T   EQU  98h ;Schedule One-Time Interrupt
        I14RRTCloseHandle     EQU  9Ch ;Close/Remove Scheduled Transaction
        I14RRTChangeIntPer    EQU  9Dh ;Change Periodicity of Interrupt
        I14RRTGetTransStatus  EQU  9Fh ;Get Status of Packet Transaction
      I14RRTMiscClass         EQU 0A0h ;Miscellaneous Class
        I14RRTLargeCallDone   EQU 0A1h ;Large (Complicated) Call Complete
        I14RRTBeepSpeaker     EQU 0AFh ;Beep the Speaker
      I14RRTInterHostClass    EQU 0E0h ;Inter-Host Communication Class
      I14RRTInternalClass     EQU 0F0h ;Host Internal/Troubleshooting Class
    I14RFlags                  DB   ?  ;Bit-level flags
      I14RFlagIn              EQU  01h ;In Direction
      I14RFlagLowSpeed        EQU  02h ;Low-Speed Device
      I14RFlagHiSpeed         EQU  04h ;High-Speed Device
      I14RFlagNoRetries       EQU  10h ;No Auto Retries for Control
      I14RFlagShortPktOK      EQU  20h ;No Retries for Short Packets
      I14RFlagSpecificFrame   EQU  40h ;Use Specific Frame Number
      I14RFlagAddrIsPhys      EQU  80h ;Data Address is Physical
    I14RHostIndex              DB   ?  ;Host Index
    I14RDeviceAddress          DB   ?  ;USB Device Address
      I14RHubAddress          EQU (OFFSET I14RDeviceAddress)
    I14REndPoint               DB   ?  ;EndPoint or Port or Alt Interface
      I14RHubPort             EQU (OFFSET I14REndPoint)
      I14RAltInterface        EQU (OFFSET I14REndPoint)
    I14RConfigValue            DB   ?  ;Configuration Value
      I14RCloseID             EQU (OFFSET I14RConfigValue)
      I14RDataX               EQU (OFFSET I14RConfigValue)
    I14RInterfaceNum           DB   ?  ;Interface Number
    I14RSearchIndex            DB   ?  ;Search Index
    I14RVendorID               DW   ?  ;Vendor ID
    I14RProductID              DW   ?  ;Product ID
    I14RDvcClass               DB   ?  ;Device Class
    I14RDvcSubClass            DB   ?  ;Device SubClass
    I14RDvcProtocol            DB   ?  ;Device Protocol
    I14RIntfClass              DB   ?  ;Interface Class
    I14RIntfSubClass           DB   ?  ;Interface SubClass
    I14RIntfProtocol           DB   ?  ;Interface Protocol
    I14RRequestHandle          DW   ?  ;Request Handle Number
    I14RPeriodicity            DW   ?  ;Interrupt Periodicity/Duration
      I14RBeepFrequency       EQU (OFFSET I14RPeriodicity)
    I14RTimeout                DW   ?  ;Transaction Time Out Value
    I14RDataAddress            DD   ?  ;Data Address
    I14RDataSize               DW   ?  ;Size of Data (Bytes)
    I14RCallBackAddr           DD   ?  ;Call Back Address (CS:IP format)
      I14RLargeCallRtnCode    EQU (OFFSET I14RCallBackAddr)
    I14RUserPktID              DW   ?  ;User Packet ID
    I14RSetupReqData           DQ   ?  ;Setup Request Data (8 bytes)
    I14RFrameTiming            DW   ?  ;Frame Timing Value (def = 12000)
      I14RFrameIndex          EQU (OFFSET I14RFrameTiming)
                                       ;Starting Frame of Isoch Schedule
    I14RIsochSchedAddr         DD   ?  ;Address of Isoch Schedule
    I14RFiller  DB (Int14RequestSize-$) DUP (0)
   ENDS

  ;----------------------------------------------------------------------------
  ;Device Request is a structure containing data required by a USB Setup Packet
  ;----------------------------------------------------------------------------
  SetupRequest           STRUC     ;Structure for a Standard Setup Pkt
    SRRequestType           DB  ?  ;Request Type
      SRRTOut              EQU 00h ;0=Out (Host to Device)
      SRRTIn               EQU 80h ;1=In (Device to Host)
      SRRTTypeMask         EQU 60h ;Mask for Type
        SRRTTypeStandard   EQU 00h ;Type 0 = Standard
        SRRTTypeClass      EQU 20h ;Type 1 = Class
        SRRTTypeVendor     EQU 40h ;Type 2 = Vendor
                                   ;Type 3 = Reserved
      SRRTRecipientMask    EQU 1Fh ;Mask for Recipient Type
        SRRTRecipDevice    EQU 00h ;Recipient Type 0 = Device
        SRRTRecipInterface EQU 01h ;Recipient Type 1 = Interface
        SRRTRecipEndPoint  EQU 02h ;Recipient Type 2 = EndPoint
        SRRTRecipOther     EQU 03h ;Recipient Type 3 = Other
                                   ;Types 4-31 = Reserved
    SRRequest               DB  ?  ;Specific Request
      SRRQGetStatus        EQU  0  ;Request  0 = Get Status
      SRRQClearFeature     EQU  1  ;Request  1 = Clear Feature
      SRRQGetState         EQU  2  ;Request  2 = Get State
      SRRQSetFeature       EQU  3  ;Request  3 = Set Feature
                                   ;Request  4 = Reserved
      SRRQSetAddress       EQU  5  ;Request  5 = Set Address
      SRRQGetDescriptor    EQU  6  ;Request  6 = Get Descriptor
      SRRQSetDescriptor    EQU  7  ;Request  7 = Set Descriptor
      SRRQGetConfig        EQU  8  ;Request  8 = Get Configuration
      SRRQSetConfig        EQU  9  ;Request  9 = Set Configuration
      SRRQGetAltInterface  EQU 10  ;Request 10 = Get Alternate Interface
      SRRQSetAltInterface  EQU 11  ;Request 11 = Set Alternate Interface
      SRRQSynchFrame       EQU 12  ;Request 12 = Synch Frame
    SRValue                 DW  ?  ;Value depends on Request Type
    SRIndex                 DW  ?  ;Index depends on Request Type
      ;If EndPoint,  Bits 3:0 = EndPoint Number
      ;              Bit    7 = 1 if IN EndPoint, 0 if OUT EndPoint
      ;              All other bits are 0
      ;If Interface, Bits 7:0 = Interface Number (low word)
      ;              All other bits are 0 (high word)
    SRLength                DW  ?  ;Length of Data (if there is Data)

   ENDS
  SetupRequestSize EQU TYPE (SetupRequest)

  ;----------------------------------------------------------------------------
  ;Format of data returned by a Get Device Descriptor
  ;----------------------------------------------------------------------------
  DeviceDescriptor   STRUC    ;Structure for a Device Descriptor
    DDLength            DB  ? ;Size of Descriptor in bytes
    DDDescType          DB DescrTypeDevice
    DDUSBRelease        DW  ? ;USB Compliance  bcd (0210h=v2.10)
    DDDvcClass          DB  ? ;Device Class (defined by USB-IF)
    DDDvcSubClass       DB  ? ;Device SubClass (defined by USB-IF)
    DDDvcProtocol       DB  ? ;Device Protocol (defined by USB-IF)
    DDMaxPktSize        DB  ? ;Max Packet Size for EndPoint 0
                              ;  MUST be 8, 16, 32, or 64
    DDVendorID          DW  ? ;Vendor ID (defined by USB-IF)
    DDProductID         DW  ? ;Product ID (defined by manufacturer)
    DDDeviceRelease     DW  ? ;Device Release Number (bcd)
    DDManufacturerIndx  DB  ? ;Index of Manufacturer String
    DDProductIndx       DB  ? ;Index of Product String
    DDSerialNumberIndx  DB  ? ;Index of Serial Number String
    DDNumConfigs        DB  ? ;Number of possible Configurations
   ENDS
  DeviceDescriptorSize EQU TYPE (DeviceDescriptor)

  ;----------------------------------------------------------------------------
  ;Format of data returned by a Get Configuration Descriptor
  ;----------------------------------------------------------------------------
  ConfigDescriptor     STRUC     ;Structure for a Config Descriptor
    CDLength              DB  ?  ;Size of Descriptor in bytes
    CDDescrType           DB DescrTypeConfig
    CDTotalLength         DW  ?  ;Total length of data returned for
                                 ;  this configuration (ALL data)
    CDNumInterfaces       DB  ?  ;Number of Interfaces in this Config
    CDConfigValue         DB  ?  ;Value to use in SetRequest to
                                 ;  set this configuration
    CDConfigurationIndx   DB  ?  ;Index of Configuration String
    CDAttributes          DB  ?  ;Configuration Attributes
      CDAttrBit7         EQU 80h ;Bit 7 must be set to 1
      CDAttrSelfPowered  EQU 40h ;Self Powered
      CDAttrRemoteWakeup EQU 20h ;Remote Wakeup Supported
      CDAttrBatteryPower EQU 10h ;Battery Powered
      ;Bits 3:0 = Reserved (0)
    CDMaxBusPower         DB  ?  ;Maximum Power Consumption FROM BUS
                                 ;  in 2mA units (*2 to get mA)
   ENDS
  ConfigDescriptorSize EQU TYPE (ConfigDescriptor)

  ;----------------------------------------------------------------------------
  ;Format of data returned by a Get Interface Descriptor
  ;----------------------------------------------------------------------------
  InterfaceDescriptor   STRUC     ;Structure for an Interface Descr
    IDLength               DB  ?  ;Size of Descriptor in bytes
    IDDescType             DB DescrTypeInterface
    IDInterfaceNumber      DB  ?  ;Interface Number (0-based Index)
    IDAlternateSetting     DB  ?  ;Value used to select this alternate
                                  ;  setting for the Interface Number
    IDNumEndPoints         DB  ?  ;Number of Interfaces, excl 0
    IDInterfaceClass       DB  ?  ;Interface Class (defined by USB-IF)
    IDInterfaceSubClass    DB  ?  ;Interface SubClass (def by USB-IF)
    IDInterfaceProtocol    DB  ?  ;Interface Protocol (def by USB-IF)
    IDInterfaceIndx        DB  ?  ;Index of Interface String
   ENDS
  InterfaceDescriptorSize EQU TYPE (InterfaceDescriptor)

  ;----------------------------------------------------------------------------
  ;Format of data returned by a Get EndPoint Descriptor
  ;----------------------------------------------------------------------------
  EndPointDescriptor    STRUC     ;Structure for an EndPoint Descr
    EDLength               DB  ?  ;Size of Descriptor in bytes
    EDDescrType            DB DescrTypeEndPoint
    EDEndPointNumber       DB  ?  ;EndPoint Number
      EDDirectionIn       EQU 80h ;Direction = In (Ignored in Control EP's)
      ;Bits 6:4 = Reserved (0)
      EDNumberMask        EQU 0Fh ;EndPoint Number (0-15)
    EDAttributes           DB  ?  ;EndPoint attributes
      ;Bits 7:6 = Reserved (0)
      EDUsageTypeMask     EQU 30h ;Bits 5:4 = Usage Type
      EDUsageTypeSft      EQU  4  ;Bits to Shift by
        EDAttrImplicitFB  EQU 20h ;2 = Implicit Feedback Data EndPoint
        EDAttrFeedback    EQU 10h ;1 = Feedback EndPoint
        EDAttrData        EQU 00h ;0 = Data EndPoint
      EDSynchTypeMask     EQU 0Ch ;Bits 3:2 = Synchronization Type
      EDSynchTypeSft      EQU  2  ;Bits to Shift By
        EDAttrSynch       EQU 0Ch ;3 = Synchronous
        EDAttrAdaptive    EQU 08h ;2 = Adaptive
        EDAttrAsynch      EQU 04h ;1 = Asynchronous
      EDAttrTransTypeMask EQU 03h ;Bits 1:0 = Transfer Type
        EDAttrInterrupt   EQU 03h ;3 = Interrupt
        EDAttrBulk        EQU 02h ;2 = Bulk
        EDAttrIsoch       EQU 01h ;1 = Isochronous
        EDAttrControl     EQU 00h ;0 = Control
    EDMaxPktSize           DW  ?  ;Max Packet Size EndPoint can handle
    EDPollInterval         DB  ?  ;Polling Interval for Data Transfers
    ;The following two bytes only appear in some Isochronous Applications
    EDRefreshRate          DB  ?  ;Refresh Rate (1-9, power of 2 mS)
    EDSynchEndPoint        DB  ?  ;Synchronization EndPoint
   ENDS
  EndPointDescriptorSize EQU TYPE (EndPointDescriptor)


;==============================================================================
;Partition Processing-Related
;==============================================================================
  ;----------------------------------------------------------------------------
  ;Tracing through all of the partitions to find all appropriate DOS
  ;  Drive Letters is a recursive process, since there is the possibility of
  ;  extended partitions which can contain other extended partitions.
  ;Normally, we would just use the regular stack to be able to trace our way
  ;  up and down the partitions as we are processing them.  Unfortunately,
  ;  we are processing the partitions in the background, and must "stall"
  ;  our processing periodically while we wait for a sector of partition data
  ;  to be transferred from the USB Device into memory where we can use it.
  ;  Therefore, we cannot use the regular stack.
  ;We have to create our own "Partition Stack" in the TSR memory space to
  ;  be able to process things correctly.
  ;----------------------------------------------------------------------------
  PartStackStruc STRUC
    PStkSector DD ? ;Sector Number (LBA) of the Partition Record
    PStkOffset DW ? ;Offset of Partition Record in SectorBuff
   ENDS
  PStkSize EQU (TYPE PartStackStruc) ;6 bytes


;==============================================================================
;SCSI Commands and Status Codes
;NOTE: Everything in SCSI Commands and Statuses is High-Endian, even though
;        all of the USB stuff is Little-Endian.  This can make things really
;        confusing!
;==============================================================================

  ;----------------------------------------------------------------------------
  ;SCSI Request Command Codes
  ;I have found conflicting documentation from different places on exactly
  ;  what all of these are and what they apply to, so do NOT take the
  ;  information in this table as the Gospel!
  ;----------------------------------------------------------------------------

  ;ALL  = All Device Types
  ;DASD = Direct Access Devices
  ;SAD  = Sequential Access Devices
  ;PRN  = Printer Devices
  ;SCAN = Scanner Devices
  ;PROC = Processor Devices
  ;WORM = Write-Once Devices
  ;CDR  = CD-ROM Devices
  ;OPT  = Optical Memory Devices
  ;COMM = Communication Devices
  ;JUKE = Medium Changer/Juke Box Devices

  ;M = Mandatory
  ;O = Optional
  ;D = Device Specific

  ;----------------------------------------------------------------------------
  ;Group 0 = 00h-1Fh (6-byte commands)
  ;----------------------------------------------------------------------------
  SCmdTestUnitReady     EQU  00h ;Test Unit Ready                  ALL -M
  SCmdRewind            EQU  01h ;Rewind Unit                      SAD -M
    SCmdRezero          EQU  01h ;Rezero Unit                      DASD-O
  SCmdRequestSense      EQU  03h ;Request Sense Data               ALL -M
  SCmdFormatUnit        EQU  04h ;Format Unit                      DASD-M
  SCmdReadBlockLimits   EQU  05h ;Read Block Size Limits           SAD -M
  SCmdReassignBlocks    EQU  07h ;Reassign Blocks                  DASD-O
    SCmdInitElementStat EQU  07h ;Initialize Element Status        JUKE-O
  SCmdReadSeq06         EQU  08h ;Read 6 bytes                     DASD-M
                                 ;                                 SAD -M?
    SCmdReceiveProc     EQU  08h ;Receive (Processor)              PROC-O
    SCmdGetMsg06        EQU  08h ;Get Message 6 bytes              COMM-M
  SCmdWriteSeq06        EQU  0Ah ;Write 6 bytes                    DASD-M
                                 ;                                 SAD -M?
    SCmdSendProc        EQU  0Ah ;Send (Processor)                 PROC-O
    SCmdSendMsg06       EQU  0Ah ;Send Message 6 bytes             COMM-M
    SCmdPrint           EQU  0Ah ;Print                            PRN -M
  SCmdSeek06            EQU  0Bh ;Seek 6 bytes                     DASD-O
    SCmdSlewPrint       EQU  0Bh ;Slew & Print                     PRN -O
  SCmdReadReverse       EQU  0Fh ;Read Reverse                     SAD -O
  SCmdWriteFilemarks    EQU  10h ;Write Filemarks                  SAD -M
    SCmdSynchPrintBuff  EQU  10h ;Synchronize Print Buffer         PRN -O
  SCmdSpace             EQU  11h ;Space Set Position?)             SAD -M
  SCmdInquiry           EQU  12h ;Inquiry                          ALL -M
  SCmdVerifyTape        EQU  13h ;Verify Tape                      SAD -O
  SCmdRecoverBuffData   EQU  14h ;Recover Buffered Data            SAD -O
  SCmdModeSelect06      EQU  15h ;Mode Select 6 bytes              ALL -D
  SCmdReserveUnit       EQU  16h ;Reserve Unit                     SAD -M
  SCmdReleaseUnit       EQU  17h ;Release Unit                     DASD-M
  SCmdCopy              EQU  18h ;Copy                             ALL -O
  SCmdErase             EQU  19h ;Erase                            SAD -M
  SCmdModeSense06       EQU  1Ah ;Mode Sense 6 bytes               ALL -D
  SCmdStartStop         EQU  1Bh ;Start/Stop Unit                  DASD-O
    CCmdLoadUnload      EQU  1Bh ;Load/Unload Unit/Media           SAD -O
                                 ;Load/Unload is 6 bytes total
                                 ;1B 00 00 00 xx 00
                                 ;  xx = 00 = Unload / Stop Motor
                                 ;       01 = Load / Start Motor
                                 ;       02 = Unload w/ Retension / Eject Media
                                 ;       03 = Load w/ Retension / Load Media
    SCmdStopPrint       EQU  1Bh ;Stop Print                       PRN -O
    SCmdScan            EQU  1Bh ;Scan                             SCAN-O
  SCmdRxDiagResults     EQU  1Ch ;Receive Diagnostic Results       DASD-O
  SCmdSendDiagnostics   EQU  1Dh ;Send Diagnostics                 ALL -O
                                 ;                                 DASD-M
    SCmdReqSelfCheck    EQU  1Dh ;Request Target Self-check        ????-?
  SCmdSetMediaRemoval   EQU  1Eh ;Prevent/Allow Media Removal      DASD-O

  ;----------------------------------------------------------------------------
  ;Group 1 = 20h-3Fh (10-byte commands)
  ;----------------------------------------------------------------------------
  SCmdReadFmtCap        EQU  23h ;Read Format Capacities           (Multimedia?)
  SCmdSetWindow         EQU  24h ;Set Window Parameters            SCAN-M
  SCmdReadCapacity      EQU  25h ;Read Capacity (Read Window)      DASD-M
                                 ;                                 CDR -M
    SCmdGetWindow       EQU  25h ;Get Window                       SCAN-O
  SCmdRead10            EQU  28h ;Read 10 bytes                    DASD-M
    SCmdGetMsg10        EQU  28h ;Get Message 10 bytes             COMM-O
  SCmdReadGeneration    EQU  29h ;Read Generation
  SCmdWrite10           EQU  2Ah ;Write 10 bytes                   DASD-M
    SCmdSendMsg10       EQU  2Ah ;Get Message 10 bytes             COMM-O
  SCmdSeek10            EQU  2Bh ;Seek 10 bytes                    DASD-O
    SCmdLocate          EQU  2Bh ;Locate                           SAD -O
    SCmdPosToElement    EQU  2Bh ;Position to Element              JUKE-O
  SCmdErase10           EQU  2Ch ;Erase 10 bytes
  SCmdReadUpdatedBlk    EQU  2Dh ;Read Updated Block
  SCmdWriteVerify10     EQU  2Eh ;Write and Verify 10 bytes        DASD-O
                                 ;                                 WORM-O
  SCmdVerify10          EQU  2Fh ;Verify 10 bytes                  DASD-O
                                 ;                                 WORM-O
  SCmdSearchDataHigh10  EQU  30h ;Search Data High 10 bytes        DASD-O
                                 ;                                 WORM-O
  SCmdSearchDataEqual10 EQU  31h ;Search Data Equal 10 bytes       DASD-O
                                 ;                                 WORM-O
    SCmdObjectPos       EQU  31h ;Object Position                  SCAN-O
  SCmdSearchDataLow10   EQU  32h ;Search Data Low 10 bytes         DASD-O
                                 ;                                 WORM-O
  SCmdSetLimits10       EQU  33h ;Set Limits 10 bytes              DASD-O
                                 ;                                 WORM-O
  SCmdPreFetch          EQU  34h ;Pre-Fetch                        DASD-O
    SCmdReadPosition    EQU  34h ;Read Position                    SAD -O
    SCmdGetDataBuffStat EQU  34h ;Get Data Buffer Status           SCAN-O
  SCmdSyncCache         EQU  35h ;Synchronize Cache                DASD-O
  SCmdLockUnlockCache   EQU  36h ;Lock/Unlock Cache                DASD-O
  SCmdReadDefects       EQU  37h ;Read Defect Data                 DASD-O
  SCmdMediumScan        EQU  38h ;Medium Scan                      WORM-O
  SCmdCompare           EQU  39h ;Compare                          ALL -O
                                 ;                                 DASD-O
  SCmdCopyVerify        EQU  3Ah ;Copy and Verify                  ALL -O
  SCmdWriteBuff         EQU  3Bh ;Write Buffer                     ALL -O
  SCmdReadBuff          EQU  3Ch ;Read Buffer                      ALL -O
  SCmdUpdateBlk         EQU  3Dh ;Update Block                     OPT -O
  SCmdReadLong          EQU  3Eh ;Read Long                        DASD-O
  SCmdWriteLong         EQU  3Fh ;Write Long                       DASD-O

  ;----------------------------------------------------------------------------
  ;Group 2 = 40h-5Fh (10-byte commands)
  ;----------------------------------------------------------------------------
  SCmdChangeDef         EQU  40h ;Change Definition                ALL -O
  SCmdWriteSame         EQU  41h ;Write Same                       DASD-O
  SCmdReadSubChan       EQU  42h ;Read Sub-Channel                 CDR -O
  SCmdReadTOC           EQU  43h ;Read Table of Contents           CDR -O
  SCmdReadHdr           EQU  44h ;Read Header                      CDR -O
  SCmdPlayAudio10       EQU  45h ;Play Audio 10 bytes              CDR -O
  SCmdPlayAudioMSF      EQU  47h ;Play Audio MSF                   CDR -O
  SCmdPlayAudioTrkIdx   EQU  48h ;Play Audio Track/Index           CDR -O
  SCmdPlayTrkRel10      EQU  49h ;Play Track Relative 10 bytes     CDR -O
  SCmdPauseResume       EQU  4Bh ;Pause/Resume
  SCmdLogSelect         EQU  4Ch ;Log Select                       ALL -O
  SCmdLogSense          EQU  4Dh ;Log Sense                        ALL -O
  SCmdXDWrite           EQU  50h ;XD Write
  SCmdXPWrite           EQU  51h ;XP Write
  SCmdXDRead            EQU  52h ;XD Read
  SCmdModeSelect10      EQU  55h ;Mode Select 10 bytes             ALL -D
  SCmdReserve10         EQU  56h ;Reserve 10 bytes
  SCmdRelease10         EQU  57h ;Release 10 bytes
  SCmdModeSense10       EQU  5Ah ;Mode Sense 10 bytes              ALL -D
  SCmdPersResvIn        EQU  5Eh ;Persistent Reserve In
  SCmdPersResvOut       EQU  5Fh ;Persistent Reserve Out

  ;----------------------------------------------------------------------------
  ;Group 3 = 60h-7Fh (Reserved)
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;Group 4 = 80h-9Fh (Reserved)
  ;----------------------------------------------------------------------------
  SCmdXDWriteX          EQU  80h ;XDWrite Extended
  SCmdRegnerate         EQU  82h ;Regenerate

  ;----------------------------------------------------------------------------
  ;Group 5 = A0h-BFh (12-byte commands)
  ;----------------------------------------------------------------------------
  SCmdReportLUNs        EQU 0A0h ;Report LUNs
  SCmdPlayAudio12       EQU 0A5h ;Play Audio 12 bytes              CDR -O
    SCmdMoveMedium      EQU 0A5h ;Move Medium
  SCmdExchangeMedium    EQU 0A6h ;Exchange Medium                  JUKE-O
  SCmdRead12            EQU 0A8h ;Read 12 bytes
    SCmdGetMsg12        EQU 0A8h ;Get Message 12 bytes             COMM-O
  SCmdPlayTrkRel12      EQU 0A9h ;Play Track Relative 12 bytes     CDR -O
  SCmdWrite12           EQU 0AAh ;Write 12 bytes                   WORM-O
    SCmdSendMsg12       EQU 0AAh ;Send Message 12 bytes            COMM-O
  SCmdErase12           EQU 0ACh ;Erase 12 bytes
  SCmdWriteVerify12     EQU 0AEh ;Write and Verify 12 bytes        WORM-O
  SCmdVerify12          EQU 0AFh ;Verify 12 bytes                  WORM-O
  SCmdSearchDataHigh12  EQU 0B0h ;Search Data High 12 bytes        WORM-O
  SCmdSearchDataEqual12 EQU 0B1h ;Search Data Equal 12 bytes       WORM-O
  SCmdSearchDataLow12   EQU 0B2h ;Search Data Low 12 bytes         WORM-O
  SCmdSetLimits12       EQU 0B3h ;Set Limits 12 bytes              WORM-O
  SCmdReadElementSts    EQU 0B4h ;Read Element Status
  SCmdReqVolElementAddr EQU 0B5h ;Request Volume Element Address   JUKE-O
  SCmdSendVolTag        EQU 0B6h ;Send Volume Tag                  JUKE-O
  SCmdReadDefects12     EQU 0B7h ;Read Defect Data 12 bytes

  ;----------------------------------------------------------------------------
  ;Group 6 = C0h-DFh (vendor-specific)
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;Group 7 = E0h-FFh (vendor-specific)
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;SCSI Request Status Codes
  ;----------------------------------------------------------------------------
  ;Low-level Status Codes (00xxh)
  SReqStsOK             EQU  0000h ;OK (Operation Successful)
  SReqStsWaitInt        EQU  0001h ;Wait on Interrupt
  SReqStsSelectFail     EQU  0010h ;Selection Failed
  SReqStsBadLUN         EQU  0011h ;Logical Unit Number Not Present
  SReqStsNoDataXfer     EQU  0021h ;Data Transfer Phase Did Not Occur
  SReqStsDataXferIncomp EQU  0022h ;Data Transfer Phase Did Not Complete
  SReqStsIntStsBit      EQU  0023h ;Unable To Clear Interrupt Status Bit
  SReqStsParityErr      EQU  0024h ;Parity Error on SCSI Bus
  SReqStsGrossErr       EQU  0025h ;Gross Error
  SReqStsAdapterInitErr EQU  0030h ;Adapter Initialization Error
  SReqStsBadTerm        EQU  0031h ;Bad Termination on SCSI Bus
  ;Reset Status Codes (01xxh)
  SReqStsBusReset       EQU  0100h ;Bus Reset Occurred
  ;Device Status Codes (02xxh)
  SReqStsCheckCond      EQU  0202h ;Check Condition
  SReqStsHWBusy         EQU  0208h ;Hardware Busy
  SReqStsReservConflict EQU  0218h ;Reservation Conflict
  ;Device Unexpected Message Errors
  SReqStsSaveDataPtrs   EQU  0302h ;Save Data Pointers
  SReqStsRestorDataPtrs EQU  0303h ;Restore Data Pointers
  SReqStsAbortSent      EQU  0306h ;Abort Message Sent
  SReqStsRejectRcv      EQU  0307h ;Reject Message Received
  SReqStsModifyDataPtrs EQU  0310h ;Modify Data Pointers
  SReqStsSynchRequest   EQU  0311h ;Synchronous Request
  SReqStsRejectSent     EQU  0327h ;Reject Message Sent"
  ;Software Timeout (04xxh)
  SReqStsSWTimeout      EQU  0400h ;Software Timeout Occurred??
  ;Bad Phase Sequence on SCSI Bus (05xxh)
  SReqStsBadPhaseSeq    EQU  0500h ;Bad Phase Sequence on SCSI Bus??
  ;Miscellaneous Status Codes
  SReqStsNoMemory       EQU  8000h ;Unable to allocate memory for Request Block
  SReqStsIncomplete     EQU 0FFFFh ;Request Not Complete

  ;----------------------------------------------------------------------------
  ;SCSI Adapter Status Codes
  ;----------------------------------------------------------------------------
  SAdStsReady     EQU 00h ;Adapter Ready
  SAdStsBusy      EQU 01h ;Adapter Busy
  SAdStsError     EQU 02h ;Adapter Error
  SAdStsDisabled  EQU 04h ;Adapter Disabled
  SAdStsInterrupt EQU 80h ;Adapter Interrupt

  ;----------------------------------------------------------------------------
  ;SCSI Device Status Codes
  ;----------------------------------------------------------------------------
  SDvcStsGood       EQU 00h ;Good Status
  SDvcStsCheckCond  EQU 02h ;Check Condition
  SDvcStsCondMet    EQU 04h ;Condition Met/Good
  SDvcStsBusy       EQU 08h ;Busy
  SDvcStsIntGood    EQU 10h ;Intermediate/Good
  SDvcStsIntCondMet EQU 14h ;Intermediate/Condition Met/Good
  SDvcStsReservConf EQU 18h ;Reservation Conflict
  SDvcStsCmdTerm    EQU 22h ;Command Terminated
  SDvcStsQueueFull  EQU 28h ;Queue Full
  ;All other codes are reserved


  ;============================================================================
  ;General SCSI Request Structure
  ;============================================================================

  ;----------------------------------------------------------------------------
  ;General SCSI Request Structure
  ;  All Requests fit this general format
  ;----------------------------------------------------------------------------
  SCSIRequestStruc STRUC
    SCSIReqCommand    DB         ?  ;SCSI Command Code (See List Above)
    SCSIReqLUNFlags   DB         ?  ;LUN (bits 5-7) and Misc Flags
      SCSIReqLUNMask EQU       0E0h ;Logical Unit Number is in bits 7-5
    SCSIReqData       DB 10 DUP (?) ;Request-specific (LBA, Alloc Size, etc.)
   ENDS
  SCSIRequestSize EQU (TYPE SCSIRequestStruc) ;12 bytes

  ;============================================================================
  ;SCSI Request Structures for Specific Commands
  ;============================================================================

  ;============================================================================
  ;SCSI General Commands
  ;============================================================================

  ;----------------------------------------------------------------------------
  ;SCSI Test Unit Ready Request
  ;  Returns GOOD if Device can handle a medium-access request
  ;  Returns CHECK CONDITION/NOT READY if unready
  ;----------------------------------------------------------------------------
  SReqTestUnitRdy STRUC
    STestRdyCmd DB SCmdTestUnitReady ;Command Request (00h)
    STestRdyLUN DB        00h ;No Specific Flags
    STestRdyPAD DB 10 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Rezero (Rewind) Unit Request
  ;Many Devices may not actually do anything in response to this command
  ;  (like UFI or Flash Drives).
  ;----------------------------------------------------------------------------
  SReqRezero STRUC
    SRezeroCmd  DB SCmdRezero ;Command Request (01h)
    SRezeroLUN  DB        00h ;No Specific Flags
    SRezeroPAD  DB 10 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Request Sense Request
  ;Returns Request Sense Response Data
  ;----------------------------------------------------------------------------
  SReqRequestSense STRUC
    SReqSenseCmd    DB SCmdRequestSense ;Command Request (03h)
    SReqSenseLUN    DB       00h ;No Specific Flags
    SReqSensePAD1   DW       00h ;PAD/Reserved
    SReqSenseLength DB       12h ;Allocation length
    SReqSensePAD2   DB 7 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;Response from a SCSI Request Sense Request (18 bytes)
  ;The amount of data returned by the Device from a Request Sense Request
  ;  is variable, but will usually be at most 18 bytes.
  ;If 18 bytes are requested, but less than 18 bytes are returned,
  ;  any additional bytes must be assumed to be 0 (even if they are not
  ;  actually returned that way).
  ;The Additional Length Field in the Response reflects the amount
  ;  of Data AVAILABLE as a Response to the Request, not necessarily the
  ;  amount of data actually transferred.
  ;Some Devices return an incorrect value in the Additional Length Field,
  ;  so it cannot be trusted or used to verify validity.
  ;----------------------------------------------------------------------------
  SReqSenseRespStruc      STRUC
    SReqSRespErrCode         DB        ?  ;Error Code
                                          ;Bit 7 Set = Valid
      SReqSRespValid        EQU       80h ;Error Information is valid
      SReqSRespErrMask      EQU       7Fh ;Error Code Mask (bits 0-6)
        SReqSRespErrCurrent EQU       70h ;Current Error
        SReqSRespErrDefer   EQU       71h ;Deferred Error
                                          ;  (may not apply to USB Devices)
        SReqSRespErrVendor  EQU       7Fh ;Vendor-specific Error
                                          ;  (may not apply to USB Devices)
    SReqSRespPAD1            DB        ?  ;PAD/Reserved (Segment Number?)
    SReqSRespSenseKey        DB        ?  ;Sense Key & ILI
      SReqRespSKFileMark    EQU       80h ;Bit 7 = File Mark (not for UFI)
      SReqRespSKEOM         EQU       40h ;Bit 6 = EOM (not for UFI)
      SReqRespSKILI         EQU       20h ;Bit 5 = ILI (not for UFI)
      SReqRespSenseMask     EQU       0Fh ;Sense Key in Bits 0-3
        SenseKeyNone        EQU       00h ;None
        SenseKeyRecover     EQU       01h ;Recovered Error
        SenseKeyNotReady    EQU       02h ;Unit Not Ready
        SenseKeyMedium      EQU       03h ;Medium Error
        SenseKeyHardware    EQU       04h ;Hardware Error (unrecoverable)
        SenseKeyRequest     EQU       05h ;Illegal Request (bad parameter)
        SenseKeyAttention   EQU       06h ;Unit Attention (Target Reset)
        SenseKeyProtect     EQU       07h ;Data Protect
        SenseKeyBlank       EQU       08h ;Blank Check
        SenseKeyVendor      EQU       09h ;Vendor Specific
        SenseKeyCopyAbort   EQU       0Ah ;Copy Aborted
        SenseKeyCmdAbort    EQU       0Bh ;Command Aborted
        SenseKeyEqual       EQU       0Ch ;Equal (Search)
        SenseKeyOverflow    EQU       0Dh ;Volume Overflow
        SenseKeyCompare     EQU       0Eh ;Miscompare (Search)
        SenseKeyReserved    EQU       0Fh ;Reserved
    SReqSRespInfo            DD        ?  ;Sense Information
                                          ;  (LBA where Error Occurred?)
    SReqSRespAddSenseLen     DB       0Ah ;Additional Sense Length
    SReqSRespPAD2            DD        ?  ;PAD/Reserved (Command-specific Info?)
    SReqSRespAddSenseCode    DB        ?  ;Additional Sense Code
    SReqSRespAddSenseQual    DB        ?  ;Additional Sense Code Qualifier
    SReqSRespPAD3            DB        ?  ;PAD/Reserved (Field Replacable Unit?)
    SReqSRespPAD4            DB 3 DUP (?) ;PAD/Reserved (Sense Key Specific?)
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Inquiry Request
  ;  If EVPD = 1, the Page Code is set as follows:
  ;            00h = Supported Vital Product Data
  ;        01h-7Fh = ASCII Information
  ;            80h = Unit Serial Number
  ;            81h = Implemented Operating Definitions
  ;            82h = ASCII Implemented Operating Definitions
  ;        83h-Bfh = Reserved
  ;        C0h-FFh = Vendor-specific
  ;----------------------------------------------------------------------------
  SReqInquiry  STRUC
    SInquiryCmd   DB SCmdInquiry  ;Command Request (12h)
    SInquiryLUN   DB          00h ;Specific Flags
      SInqEVPD   EQU          01h ;Enable Vital Product Data (0 for UFI)
    SInquiryPage  DB          00h ;Vital Product Data Page Code
                                  ;  (if SInqEVPD is set)
      ;    00h = Supported Vital Product Data
      ;01h-7Fh = ASCII Information
      ;    80h = Unit Serial Number
      ;    81h = Implemented Operating Definitions
      ;    82h = ASCII Implemented Operating Definitions
      ;83h-Bfh = Reserved
      ;C0h-FFh = Vendor-specific
    SInquiryPAD1  DB          00h ;PAD/Reserved
    SInquiryLen   DB SInquiryRespSize ;Allocation Length
                                      ;  (Amount of Data to Return)
    SInquiryPAD2  DB    7 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;Response from a SCSI Inquiry Request
  ;----------------------------------------------------------------------------
  SInquiryRespStruc STRUC
    SInqRespPDT        DB         ?  ;Peripheral Device Type & Qualifier
     PDTMask          EQU        1Fh ;Peripheral Device Type Mask
       PDTDirect      EQU        00h ;Direct Access Dvc (eg, Magnetic Disk)
       PDTSequential  EQU        01h ;Sequential Access Dvc (eg, Magnetic Tape)
       PDTPrinter     EQU        02h ;Printer Device
       PDTProcessor   EQU        03h ;Processor Device
       PDTWORM        EQU        04h ;Write-Once Device
       PDTCDROM       EQU        05h ;CD-ROM Device
       PDTScanner     EQU        06h ;Scanner Device
       PDTOpticalMem  EQU        07h ;Optical Memory Device
       PDTMedChanger  EQU        08h ;Medium Changer (eg, Jukebox)
       PDTComm        EQU        09h ;Communications Device
       PDT0A          EQU        0Ah ;Defined by non-SCSI Standard (IT8)
       PDT0B          EQU        0Bh ;Defined by non-SCSI Standard (IT8)
       PDTRAID        EQU        0Ch ;Storage Array (eg, RAID)
       PDTEnclosure   EQU        0Dh ;Enclosure Services Device
       PDTReduced     EQU        0Eh ;Reduced Block Commands (simplified DASD)
       PDTOpticalCard EQU        0Fh ;Optical Card Read/Write Device
       PDTBridgeExp   EQU        10h ;Reserved for Bridging Expanders
       PDTObjectStore EQU        11h ;Object-based Storage Device
       PDTAutoDrive   EQU        12h ;Automation/Drive Interface
       ;13h-1Dh = Reserved
       PDTLoicalUnit  EQU        1Eh ;Well-known Logical Unit
       PDTUnknown     EQU        1Fh ;Unknown or No Device Type
     PDQMask          EQU       0E0h ;Peripheral Device Qualifier Mask
       PDQPossible    EQU        00h ;Currently Connected (or indeterminate)
       PDQSupported   EQU        20h ;Not Currently Connected
       ;40h = Reserved
       PDQNever       EQU        60h ;Not possible to attach a physical device
       PDQVendor      EQU        80h ;Vendor-unique
       ;If LUN is present but no Device is currently attached, it will return
       ;  PDTUnknown + PDQNever
    SInqRespDTM        DB         ?  ;Device Type Modifier & Removable Flag
      RMBFlag         EQU        80h ;Removable Media Flag
      DTMMask         EQU        7Fh ;Device Type Modifier Mask (bits 0-6)
      ;No idea what could be in here!
    SInqRespVersions   DB         ?  ;ISO/ECMA/ANSI versions
      ANSIVerMask     EQU        07h ;ANSI-approved Version Mask (3 bits)
        ANSIMaybe     EQU        00h ;May or May not be ANSI Approved
        ANSISCSI1     EQU        01h ;SCSI-1 (ANSI X3.131-1986)
        ANSISCSI2     EQU        02h ;SCSI-2
        ;03-07 = Reserved
      ECMAVerMask     EQU        38h ;ECMA Version Mask (3 bits)
      ISOVerMask      EQU       0C0h ;ISO Version Mask (2 bits)
    SInqRespDataFmt    DB         ?  ;Response Data Format
      RDFMask         EQU        0Fh ;Response Data Format Mask
        RDFSCSI1      EQU        00h ;SCSI 1
        RDFCCSRS      EQU        01h ;Common Command Set Request Sense
        RDFSCSI2      EQU        02h ;SCSI 2
        ;All other values = Legacy Devices
      ;bits 4-5 = Reserved
      TermIOProc      EQU        40h ;Supports Terminate I/O Process Messages
      AsyncEvent      EQU        80h ;Supports Asynchronous Event Notifications
                                     ;  (only applies to Processor Devices)
    SInqRespAddLength  DB         ?  ;Additional Length (n-4), 31 for UFI
    SInqRespPAD        DW         ?  ;PAD (Reserved)
    SInqRespFlags      DB         ?  ;Miscellaneous Flags
      SoftResets      EQU        01h ;Performs Soft Resets
      TaggedCmdQueue  EQU        02h ;Supports Tagged Command Queuing
      ;Bit 2 = Reserved
      Linked          EQU        08h ;Supports Linked Commands
      SynchOK         EQU        10h ;Supports Synchronous Transfers
      BusWidthMask    EQU        60h ;Bus Width Mask
        BusWidth08    EQU        00h ;8-bit Bus
        BusWidth16    EQU        20h ;16-bit Bus
        BusWidth32    EQU        40h ;32-bit Bus
      RelAddr         EQU        80h ;Supports Relative Addressing Mode
                                     ;  (Linked Commands only)
    SInqRespVendorID   DB  8 DUP (?) ;Vendor ID (ASCII)
    SInqRespProductID  DB 16 DUP (?) ;Product ID (ASCII)
    SInqRespRevision   DB  4 DUP (?) ;Product Revision Level (ASCII)
    ;Bytes 36-55 = Vendor Specific
    ;      56-95 = Reserved
    ;      96+   = Vendor Specific Parameters (variable size)
   ENDS
  SInquiryRespSize EQU (TYPE SInquiryRespStruc) ;36 bytes

  ;----------------------------------------------------------------------------
  ;SCSI Start/Stop Unit Request
  ;Can be used to update the Media Type and Write-Protect Status in UFI.
  ;In UFI, this does NOT Enable/Disable disk access.
  ;----------------------------------------------------------------------------
  SReqStartStop STRUC
    SStartStopCmd      DB SCmdStartStop ;Command Request (1Bh)
    SStartStopLUN      DB       00h ;Specific Flags
      SStartStopImmed EQU       01h ;Immediate (Ignored by UFI)
    SStartStopPAD1     DW       00h ;PAD/Reserved
    SStartStopFlags    DB        ?  ;Miscellaneous Flags
      SStartStopStart EQU       01h ;Start Unit/Motor (0 = Stop)
      SStartStopLoEj  EQU       02h ;Load or Eject Media Automatically
                                    ;  (Load if Start, Eject if Stop)
                                    ;Load/Eject is Illegal for UFI
                                    ;00h = Stop Motor, 01h = Start Motor,
                                    ;02h = Eject Media, 03h = Load Media
    SStartStopPAD2     DB 7 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Send Diagnostic Request
  ;Results Vendor-specific or Page-sepcific
  ;A Send Diagnostics with the Self-Test bit set and a return length of
  ;  0 is required of all Devices, which will return GOOD or CHECK STATUS.
  ;----------------------------------------------------------------------------
  SReqSendDiag STRUC
    SSendDiagCmd     DB SCmdSendDiagnostics ;Command Request (1Dh)
    SSendDiagLUN     DB        ?  ;Specific Flags
      SDiagUnitOfl  EQU       01h ;Unit Off-Line (Unit is allowed to
                                  ;  perform tests that can screw up other
                                  ;  Requests in progress for this LUN)
      SDiagDvcOfl   EQU       02h ;Device Off-Line (Device is allowed to
                                  ;  perform tests that can screw up other
                                  ;  Requests in progress for ALL LUNs)
      SDiagSelfTest EQU       04h ;Perform Default Self-Test
                                  ;  (0 = Perform Special Diagnostic Test)
      SDiagPgFmt    EQU       10h ;Page Format (Int'l Standard / SCSI-2)
                                  ;  0 = SCSI-1 (Vendor Specific)
    SSendDiagPAD1    DB        ?  ;PAD/Reserved
    SSendDiagLength  DW        ?  ;Parameter List Length (Length of Data to
                                  ;  follow the CDB) (0 for Default Self-Test)
                                  ;  (Big-Endian)
    SSendDiagPAD     DB 7 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Prevent/Allow Medium Removal Request
  ;If a Device does not support Media Removal Locking, attempting to
  ;  set Prevent results in an error.  Most Devices do not support
  ;  Media Removal Locking.
  ;----------------------------------------------------------------------------
  SReqSetMediaRemoval STRUC
    SMedRemCmd        DB SCmdSetMediaRemoval ;Command Request (1Eh)
    SMedRemLUN        DB       00h ;No Specific Flags
    SMedRemPAD1       DW       00h ;PAD/Reserved
    SMedRemFlags      DB        ?  ;Flags
      SMedRemPrevent EQU       01h ;Prevent Removal (0 = Allow Removal)
    SMedRemPAD2       DB 7 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Synchronize Cache Request
  ;----------------------------------------------------------------------------
  SReqSyncCache   STRUC
    SSyncCmd         DB SCmdSyncCache ;Command Request (1Eh)
    SSyncLUN         DB       00h ;Specific Flags
      SSyncRelAddr  EQU       01h ;Relative Address
      SSyncImmed    EQU       02h ;Immediate Return (don't wait for completion)
    SSyncLBA         DD        ?  ;Starting Logical Block Address (High-Endian)
    SSyncPAD1        DB        ?  ;PAD/Reserved
    SSyncLength      DW        ?  ;Number of Blocks to Synchronize (High-Endian)
                                  ;  0 = All remaining Blocks
    SSyncPAD2        DB 3 DUP (0) ;PAD/Reserved
   ENDS


  ;============================================================================
  ;SCSI Format-Related Commands
  ;============================================================================

  ;----------------------------------------------------------------------------
  ;SCSI Format Unit Request
  ;----------------------------------------------------------------------------
  SReqFormatUnit STRUC
    SFmtCmd         DB SCmdFormatUnit ;Command Request (04h)
    SFmtLUN         DB       17h ;Specific Flags
      SFmtFmtData  EQU       10h ;Format Data (1 for UFI)
      SFmtCmpList  EQU       08h ;Cmp List (0 for UFI)
      SFmtDefFmt   EQU       07h ;Defect List Format (7 for UFI)
    SFmtTrackNum    DB        ?  ;Track Number
                                 ;  (for HD & DD single-track floppies)
    SFmtInterleave  DW        ?  ;Interleave (High-Endian)
                                 ;  0 = Default (usually 1:1)
    SFmtPAD1        DW        0  ;PAD/Reserved
    SFmtParamLen    DW     0C00h ;Parameter List Length (High-Endian)
                                 ;Can be 0, but is usually 12
                                 ;Parameter List = Defect List Header followed
                                 ;  by Format Descriptor (in same format as
                                 ;  returned by Read Format Capacities,
                                 ;  Number of Blocks & Block Length)
    SFmtPAD2        DB 3 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Defect List Structure
  ;  (used in Format Unit Requests)
  ;----------------------------------------------------------------------------
  DefectListStruc STRUC
    DefLstPAD       DB    0  ;PAD/Reserved
    DefLstFlags     DB    ?  ;Flags
      DefFlgSide1  EQU   01h ;Side 1 (Top), as opposed to Side 0 (Bottom)
      DefFlgImmed  EQU   02h ;Immediate Status Return (0 for UFI)
      ;Bits 2-3 = Reserved
      DefFlg1Track EQU   10h ;Only format the single Track specified
                             ;  in SFmtTrackNum
      DefFlgNoCert EQU   20h ;Disable Certification (1 for UFI)
      DefFlgExtend EQU   40h ;Extend (0 for UFI)
      DefFlgFOV    EQU   80h ;Format Option Valid (must be 1 if
                             ;  DefFlgDisCert or DefFlgDefFlgImmed is 1)
    DefLstLength    DW 0800h ;Length of Defect List (Format Descriptor)
                             ;  (High Endian)
   ENDS
  DefectListSize EQU (TYPE DefectListStruc) ;4 bytes

  ;----------------------------------------------------------------------------
  ;SCSI Format Descriptor Structure
  ;  (used in various format-related Requests)
  ;In Read Format Capacities Request, FDescNumBlocks is the total number
  ;  of Blocks (LBA's/Sectors).  Since they start numbering at 0, this is
  ;  one more than the largest LBA.
  ;In a Read Capacities Request, FDescNumBlocks is the largest Block Number,
  ;  which is one less than the value returned by a Read Format Capacities
  ;  request.
  ;----------------------------------------------------------------------------
  FormatDescrStruc STRUC
    FDescNumBlocks    DD        ?  ;Number of Blocks (High-Endian)
    FDescCode         DB        ?  ;Descriptor Code (=0 for most requests,
                                   ;  but !=0 for first (Current/Maximum)
                                   ;  Descriptor in a Read Format Capacities
                                   ;  Request)
      FDCodeNoFormat EQU       01h ;Unformatted Media (Data is Maximum,
                                   ;  not Actual)
      FDCodeCurrent  EQU       02h ;Formatted Media (Data is Actual Capacity)
      FDCodeNoMedia  EQU       03h ;No Media (Cartridge) in Drive (Data is
                                   ;  Maximum Capacity for ANY Cartridge)
    FDescBlockLength  DB 3 DUP (0) ;Block (Sector) Length (High-Endian)
   ENDS
  FormatDescrSize EQU (TYPE FormatDescrStruc) ;8 bytes

  ;----------------------------------------------------------------------------
  ;SCSI Read Format Capacities Request
  ;Returns a Capacity List Header, followed by the Current/Maximum Format
  ;  Descriptor (with a non-zero FDescCode), followed by one or more
  ;  Formattable Capacity Format Descriptors (with a zero FDescCode).
  ;----------------------------------------------------------------------------
  SReqReadFmtCapacity STRUC
    SReadFCapCmd     DB SCmdReadFmtCap ;Command Request (23h)
    SReadFCapLUN     DB       00h ;No Specific Flags
    SReadFCapPAD1    DB 5 DUP (0) ;PAD/Reserved
    SReadFCapLength  DW    0FC00h ;Allocation Length (Returned Values include
                                  ;  a byte-field for the length, which means
                                  ;  a max of 255, which means a 4-byte header
                                  ;  and a max of 31 Format Descriptors for a
                                  ;  total of 252 bytes max.
                                  ;  (High-Endian)
    SReadFCapPAD2    DB 3 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Capacity List Header Structure
  ;Returned by a Read Format Capacities Request, followed by the
  ;  Current/Maximum Format Descriptor (with a non-zero FDescCode), followed
  ;  by one or more Formattable Capacity Format Descriptors (with a zero
  ;  FDescCode).
  ;----------------------------------------------------------------------------
  CapListHdr     STRUC
    CLHdrPAD    DB 3 DUP (0) ;PAD/Reserved
    CLHdrLength DB        ?  ;Capacity List Length (8 * NumDescriptors)
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Read Capacity Request
  ;Returns a single Format Descriptor, with FDescCode = 0 (this is actually
  ;  the MSB of the Block Length, which should always be 0)
  ;----------------------------------------------------------------------------
  SReqReadCapacity STRUC
    SReadCapCmd     DB SCmdReadCapacity ;Command Request (25h)
    SReadCapLUN     DB       00h ;Specific Flags
      SRCapRelAddr EQU       01h ;Relative Address (0 for UFI)
    SReadCapLBA     DD        ?  ;Large Block Address (High-Endian)
                                 ;  (why do we need an LBA here?)  (0 for UFI)
    SReadCapPAD1    DW        0  ;PAD/Reserved
    SReadCapFlags   DB        0  ;Flags
      SRCapPMI     EQU       01h ;Partial Medium Indicator
                                 ;  0 = Last LBA
                                 ;  1 = Last LBA after which long delays occur
                                 ;(0 for UFI)
    SReadCapPAD2    DB 3 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Mode Select Request
  ;----------------------------------------------------------------------------
  SReqModeSelect STRUC
    SModeSelCmd     DB SCmdModeSelect10 ;Command Request (55h)
    SModeSelLUN     DB        ?  ;Specific Flags
      SMSelSavPg   EQU       01h ;Save Pages (0 for UFI)
      SMSelPgFmt   EQU       10h ;Page Format (1 for UFI)
    SModeSelPAD1    DB 5 DUP (0) ;PAD/Reserved
    SModeSelLength  DW        ?  ;Parameter List Length (High-Endian)
                                 ;  Can be any of several different parameters
                                 ;  Either 0 or 8 (Length of List)
    SModeSelPAD2    DB 3 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Mode Sense Request 6
  ;----------------------------------------------------------------------------
  SReqModeSense6      STRUC
    SModeSense6Cmd       DB SCmdModeSense06 ;Command Request (1Ah)
    SModeSense6LUN       DB        ?  ;Specific Flags
      SMSensDBD         EQU       08h ;Disable Block Descriptor (0 for UFI)
    SModeSense6Page      DB        ?  ;Page Control & Page Code
      SMSensPgCtlMask   EQU      0C0h ;Page Control (bits 6-7)
        SMSensCurrent   EQU      000h ;Current values
        SMSensChange    EQU      040h ;Changeable Values
        SMSensDefault   EQU      080h ;Default Values
        SMSensSaved     EQU      0C0h ;Saved Values
      SMSensPgCodeMask  EQU      03Fh ;Page Code (bits 0-5)
        SMSensRecovery  EQU      001h ;Read/Write Error Recovery Page
        SMSensFlexible  EQU      005h ;Flexible Disk Page
        SMSensAccess    EQU      01Bh ;Removable Block Access Capacities Page
        SMSensTimer     EQU      01Ch ;Timer & Protect Page
        SMSensAll       EQU      03Fh ;Return All Pages
    SModeSense6PAD       DB        0  ;PAD/Reserved
    SModeSense6Length    DB        ?  ;Parameter List Length
    SModeSense6Flags     DB        ?  ;PAD/Reserved
      SMS6FlagVUMask    EQU      0C0h ;Bits 6-7 = VU
      SMS6FlagFlag      EQU      002h ;Bit 1 = Flag
      SMS6FlagLink      EQU      001h ;Bit 0 = Link
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Mode Sense Request 10
  ;----------------------------------------------------------------------------
  SReqModeSense10   STRUC
    SModeSense10Cmd    DB SCmdModeSense10 ;Command Request (5Ah)
    SModeSense10LUN    DB        ?  ;Specific Flags
      ;DBD same as Mode Sense 6
    SModeSense10Page   DB        ?  ;Page Control & Page Code
      ;Page Controls & Codes same as Mode Sense 6
    SModeSense10PAD1   DD        0  ;PAD/Reserved
    SModeSense10Length DW        ?  ;Parameter List Length (High-Endian)
    SModeSense10PAD2   DB 3 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;Mode Parameter Header Structure (Response from a GetModeSense6 Request)
  ;A Mode Sense Request will respond with this Header structure, followed by
  ;  one or more Mode Pages.
  ;This is also used in Mode Select Requests.
  ;----------------------------------------------------------------------------
  ModeParam6HdrStruc STRUC    ;Mode Parameter Header
    MPH6DataLength   DB    ?  ;Mode Data Length (Num Bytes following this one)
    MPH6MediumType   DB    ?  ;Medium Type
                              ;Parameters in Flexible Disk Mode Page take
                              ;  priority over this code
      MPHNoChange   EQU   00h ;For Mode Select, 00h means to not change the type
      MPHType720k   EQU   1Eh ;DSDD 720KB Floppy (1MB Unformatted)
      MPHType125M   EQU   93h ;DSHD 1.25MB Floppy (1.6MB Unformatted)
      MPHType144M   EQU   94h ;DSHD 1.44MB Floppy (2MB Unformatted)
    MPH6Flags        DB    ?  ;Miscellaneous Flags
      MPHDPOFUA     EQU   10h ;Unit Supports DPO & FUA in Read/Write Requests
                              ;  (0 for UFI)
      MPHWriteProt  EQU   80h ;Write Protect
    MPH6BlockLen     DB    ?  ;Block length (0 or 8)
                              ;Block Descriptor, if there, is same format
                              ;  as Get Capacity (DD Num Blocks, DB Density,
                              ;  3 Bytes Block Size)
   ENDS
  ModeParam6HdrSize  EQU (TYPE ModeParam6HdrStruc) ;4 bytes

  ;----------------------------------------------------------------------------
  ;Mode Parameter Header Structure (Response from a GetModeSense10 Request)
  ;A Mode Sense Request will respond with this Header structure, followed by
  ;  one or more Mode Pages.
  ;This is also used in Mode Select Requests.
  ;----------------------------------------------------------------------------
  ModeParam10HdrStruc STRUC ;Mode Parameter Header
    MPH10DataLength DW ? ;Mode Data Length (Num Bytes following this one)
                         ;  (High-Endian)
    MPH10MediumType DB ? ;Medium Type
      ;MPH Medium Type same as Mode Parameters 6
    MPH10Flags      DB ? ;Miscellaneous Flags
      ;MPH Flags same as Mode Parameters 6
    MPH10PAD        DD 0 ;PAD/Reserved
   ENDS
  ModeParam10HdrSize EQU (TYPE ModeParam10HdrStruc) ;8 bytes

  ;----------------------------------------------------------------------------
  ;Read-Write Error Recovery Page Structure
  ;Used in Mode Sense/Mode Select Requests
  ;----------------------------------------------------------------------------
  ReadWriteRecoveryStruc STRUC
    RecoveryCode          DB SMSensRecovery ;Flags & Page Code (01h)
      RecoveryPSav       EQU       80h ;Parameters Savable (0 for UFI)
      RecoveryPgCodeMask EQU       3Fh ;Page Code
    RecoveryPgLength      DB       0Ah ;Length of Page (following this)
    RecoveryParams        DB        ?  ;Error Recovery Parameters
      RecoveryDCR        EQU       01h ;Disable Error Correction
                                       ;  (0 for UFI)
      RecoveryPostError  EQU       04h ;Post Error (Post/Ignore Recovered
                                       ;  Errors)
      RecoveryReadCont   EQU       10h ;Read Continuous (0 for UFI)
      RecoveryAWRE       EQU       80h ;Automatic Write Reallocation
                                       ;  Enable (for bad blocks)
                                       ;  (0 for UFI)
    RecoveryReadRetryCt   DB        ?  ;Read Retry Count
    RecoveryPAD1          DD        0  ;PAD/Reserved
    RecoveryWriteRetryCt  DB        ?  ;Write Retry Count
    RecoveryPAD2          DB 3 DUP (0) ;PAD/Reserved
   ENDS
  RecoverySize EQU (TYPE ReadWRiteRecoveryStruc) ;12 bytes

  ;----------------------------------------------------------------------------
  ;Flexible Disk Mode Page Structure
  ;Used in Mode Sense/Mode Select Requests.
  ;MUST be supported by all devices except CD-ROMs.
  ;----------------------------------------------------------------------------
  FlexDiskModeStruc  STRUC
    FlexCode            DB SMSensFlexible ;Flags & Page Code (05h)
      FlexPSav         EQU       80h ;Parameters Savable (0 for UFI)
      FlexPgCodeMask   EQU       3Fh ;Page Code
    FlexPgLength        DB       1Eh ;Length of Page (following this)
    FlexXferRate        DW        ?  ;Transfer Rate (kbps) (High-Endian)
    FlexNumHeads        DB        2  ;Number of Heads (always 2 for UFI)
    FlexSectsPerTrack   DB        ?  ;Number of Sectors per Track (1-63)
    FlexBytesPerSect    DW        ?  ;Number of Data Bytes per Sector
                                     ;  (High-Endian)
    FlexNumCylinders    DW        ?  ;Number of Cylinders (High-Endian)
    FlexPAD1            DB 9 DUP (0) ;PAD/Reserved
    FlexMotorOnDly      DB        5  ;Motor On Delay (tenths of seconds)
                                     ;  (always 5 for UFI)
    FlexMotorOffDly     DB        ?  ;Motor Off Delay (tenths of seconds)
                                     ;  (FFh indicates motor never turns off
                                     ;   automatically, only in response to
                                     ;   a Stop Unit Request)
                                     ;  (always 30 for UFI)
    FlexPAD2            DB 7 DUP (0) ;PAD/Reserved
    FlexRotationRate    DW        ?  ;Medium Rotation Rate (rpm)
                                     ;  (High-Endian)
    FlexPAD3            DW        ?  ;PAD/Reserved
   ENDS
  FlexSize EQU (TYPE FlexDiskModeStruc) ;32 bytes

  ;----------------------------------------------------------------------------
  ;Removable Block Access Capabilities Page Structure
  ;Used in Mode Sense/Mode Select Requests.
  ;----------------------------------------------------------------------------
  RmvBlkAccessCapStruc  STRUC
    AccessCode            DB SMSensAccess ;Flags & Page Code (1Bh)
      AccessPSav         EQU       80h ;Parameters Savable (0 for UFI)
      AccessPgCodeMask   EQU       3Fh ;Page Code
    AccessPgLength        DB       0Ah ;Length of Page (following this)
    AccessFlags1          DB        ?  ;Misc Flags 1
      AccessF1FmtProg    EQU       40h ;Supports Reporting Format Progress
                                       ;  via Request Sense (0 for UFI)
      AccessF1SysFloppy  EQU       80h ;System Floppy Device (always? 1
                                       ;   for UFI)
    AccessFlags2          DB        ?  ;Misc Flags 2
      AccessF2TotLUNMask EQU       07h ;Total Number of Supported LUNs
                                       ;  (1 for UFI)
      AccessF2MultLUN    EQU       40h ;Multiple LUNs Supported (Phase Change
                                       ;  Dual Device) (0 for UFI)
      AccessF2NonCD      EQU       80h ;Non-CD Optical Device (0 for UFI)
    AccessPAD             DB 8 DUP (0) ;PAD/Reserved
   ENDS
  AccessSize EQU (TYPE FlexDiskModeStruc) ;12 bytes

  ;----------------------------------------------------------------------------
  ;Timer and Protect Page Structure
  ;Used in Mode Sense/Mode Select Requests.
  ;----------------------------------------------------------------------------
  TimerProtectStruc     STRUC
    TimerCode              DB SMSensTimer ;Flags & Page Code (1Ch)
      TimerPSav           EQU       80h ;Parameters Savable (0 for UFI)
      TimerPgCodeMask     EQU       3Fh ;Page Code
    TimerPgLength          DB       06h ;Length of Page (following this)
    TimerPAD1              DB        0  ;PAD/Reserved
    TimerInactiveMult      DB        ?  ;Inactivity Time Multiplier (bits 0-3)
                                        ;  (5 for UFI (2 seconds))
      InactiveInfinite    EQU       00h ;Infinite
      Inactive125ms       EQU       01h ;125 ms
                                        ;Values 1-F are 2^(n-1)*125 ms
                                        ;1=125ms, 2=250ms, 3=500ms, 4=1s, ...,
                                        ;  A = 1min, ..., F=32min
    TimerFlags             DB        ?  ;Misc Flags
      TimerSWPP           EQU       01h ;Software Write Protect til Power Cycle
                                        ;  (0 for UFI)
      TimerDISP           EQU       02h ;Disable Media Access til Power Cycle
                                        ;  (0 for UFI)
    TimerPAD2              DB 3 DUP (0) ;PAD/Reserved
   ENDS
  TimerSize EQU (TYPE TimerProtectStruc) ;8 bytes


  ;============================================================================
  ;SCSI Read-Related Commands
  ;============================================================================

  ;----------------------------------------------------------------------------
  ;SCSI Read (10 Bytes) Request
  ;  Reads Data from Device
  ;----------------------------------------------------------------------------
  SReqRead10     STRUC
    SRead10Cmd      DB SCmdRead10 ;Command Request (28h)
    SRead10LUN      DB       00h ;Specific Flags
      SR10RelAddr  EQU       01h ;Relative Address (0 for UFI)
      SR10FUA      EQU       08h ;Force Unit Access (No Buffering) (0 for UFI)
      SR10DPO      EQU       10h ;Disable Page Out (No Buffering) (0 for UFI)
    SRead10LBA      DD        ?  ;Large Block Address (High-Endian)
    SRead10PAD1     DB        0  ;PAD/Reserved
    SRead10Length   DW        ?  ;Transfer Length (Number of Blocks)
                                 ;  (High-Endian)
    SRead10PAD2     DB 3 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Seek (10 Bytes) Request
  ;UFI performs automatic Motor Start/Stop and Seeks associated with other
  ;  Requests (Read/Write/Format/etc.) so this Request may not actually do
  ;  anything on most Devices.
  ;----------------------------------------------------------------------------
  SReqSeek10 STRUC
    SSeek10Cmd DB SCmdSeek10 ;Command Request (2Bh)
    SSeek10LUN DB       00h  ;No Specific Flags
    SSeek10LBA DD        ?   ;Large Block Address (High-Endian)
    SSeek10PAD DB 6 DUP (0)  ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Verify (10 bytes) Request
  ;----------------------------------------------------------------------------
  SReqVerify10      STRUC
    SVerify10Cmd       DB SCmdVerify10 ;Command Request (2Fh)
    SVerify10LUN       DB        ?  ;Specific Flags
      SVerify10RelAdr EQU       01h ;Relative Address (0 for UFI)
      SVerify10ByteCk EQU       02h ;Do a byte-by-byt verification
                                    ;  (0 = Check CRC Only)
                                    ;  (0 for UFI)
      SVerify10DPO    EQU       10h ;DPO (0 for UFI)
    SVerify10LBA       DD        ?  ;Starting Logical Block Address
                                    ;  (High Endian)
    SVerify10PAD1      DB        ?  ;PAD/Reserved
    SVerify10Length    DW        ?  ;Verification length (Blocks)
                                    ;  (High-Endian)
    SVerify10PAD2      DB 3 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Read (12 Bytes) Request
  ;  Reads Data from Device
  ;----------------------------------------------------------------------------
  SReqRead12     STRUC
    SRead12Cmd      DB SCmdRead12 ;Command Request (A8h)
    SRead12LUN      DB       00h ;Specific Flags
      SR12RelAddr  EQU       01h ;Relative Address (0 for UFI)
      SR12FUA      EQU       08h ;Force Unit Access (No Buffering) (0 for UFI)
      SR12DPO      EQU       10h ;Disable Page Out (No Buffering) (0 for UFI)
    SRead12LBA      DD        ?  ;Large Block Address (High-Endian)
    SRead12Length   DD        ?  ;Transfer Length (Number of Blocks)
                                 ;  (High-Endian)
    SRead12PAD      DB 2 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Verify (12 Bytes) Request
  ;----------------------------------------------------------------------------
  SReqVerify12    STRUC
    SVerify12Cmd     DB SCmdverify12 ;Command Request (AFh)
    SVerify12LUN     DB       00h ;Specific Flags
      SV12RelAddr EQU       01h ;Relative Address (0 for UFI)
      SV12FUA     EQU       08h ;Force Unit Access (No Buffering) (0 for UFI)
      SV12DPO     EQU       10h ;Disable Page Out (No Buffering) (0 for UFI)
    SVerify12LBA     DD        ?  ;Large Block Address (High-Endian)
    SVerify12Length  DD        ?  ;Transfer Length (Number of Blocks)
                                ;  (High-Endian)
    SVerify12PAD     DB 2 DUP (0) ;PAD/Reserved
   ENDS


  ;============================================================================
  ;SCSI Write-Related Commands
  ;============================================================================

  ;----------------------------------------------------------------------------
  ;SCSI Write (10 bytes) Request
  ;  Writes Data to Device
  ;----------------------------------------------------------------------------
  SReqWrite10      STRUC
    SWrite10Cmd       DB SCmdWrite10 ;Command Request (2Ah)
    SWrite10LUN       DB        ?  ;Specific Flags
      SWrite10RelAdr EQU       01h ;Relative Address (0 for UFI)
      SWrite10FUA    EQU       08h ;Force Unit Access (No Buffering) (0 for UFI)
      SWrite10DPO    EQU       10h ;Disable Page Out (No Buffering) (0 for UFI)
    SWrite10LBA       DD        ?  ;Starting Logical Block Address
                                   ;  (High Endian)
    SWrite10PAD1      DB        ?  ;PAD/Reserved
    SWrite10Length    DW        ?  ;Transfer Length (Blocks)
                                   ;  (High-Endian)
    SWrite10PAD2      DB 3 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Write and Verify (10 bytes) Request
  ;  Writes Data to Device, and verifies it was written correctly
  ;----------------------------------------------------------------------------
  SReqWriteVerify10 STRUC
    SWrVer10Cmd       DB SCmdWriteVerify10 ;Command Request (2Eh)
    SWrVer10LUN       DB        ?  ;Specific Flags
      SWrVer10RelAdr EQU       01h ;Relative Address (0 for UFI)
      SWrVer10ByteCk EQU       02h ;Do a byte-by-byt verification
                                   ;  (0 = Check CRC Only)
                                   ;  (0 for UFI)
      SWrVer10DPO    EQU       10h ;DPO (0 for UFI)
    SWrVer10LBA       DD        ?  ;Starting Logical Block Address
                                   ;  (High Endian)
    SWrVer10PAD1      DB        ?  ;PAD/Reserved
    SWrVer10Length    DW        ?  ;Transfer & Verification Length (Blocks)
                                   ;  (High-Endian)
    SWrVer10PAD2      DB 3 DUP (0) ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Write (12 bytes) Request
  ;  Writes Data to Device
  ;----------------------------------------------------------------------------
  SReqWrite12      STRUC
    SWrite12Cmd       DB SCmdWrite12 ;Command Request (AAh)
    SWrite12LUN       DB        ?  ;Specific Flags
      SWrite12RelAdr EQU       01h ;Relative Address (0 for UFI)
      SWrite12FUA    EQU       08h ;Force Unit Access (No Buffering) (0 for UFI)
      SWrite12DPO    EQU       10h ;Disable Page Out (No Buffering) (0 for UFI)
    SWrite12LBA       DD        ?  ;Starting Logical Block Address
                                   ;  (High Endian)
    SWrite12Length    DD        ?  ;Transfer Length (Blocks)
                                   ;  (High-Endian)
    SWrite12PAD       DW       00h ;PAD/Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;SCSI Write and Verify (12 bytes) Request
  ;  Writes Data to Device, and verifies it was written correctly
  ;----------------------------------------------------------------------------
  SReqWrVer12    STRUC
    SWrVer2Cmd      DB SCmdWriteVerify12 ;Command Request (AEh)
    SWrVer12LUN     DB       00h ;Specific Flags
      SWV12RelAddr EQU       01h ;Relative Address (0 for UFI)
      SWV12FUA     EQU       08h ;Force Unit Access (No Buffering) (0 for UFI)
      SWV12DPO     EQU       10h ;Disable Page Out (No Buffering) (0 for UFI)
    SWrVer12LBA     DD        ?  ;Large Block Address (High-Endian)
    SWrVer2Length   DD        ?  ;Transfer Length (Number of Blocks)
                                 ;  (High-Endian)
    SWrVer12PAD     DB 2 DUP (0) ;PAD/Reserved
   ENDS


;==============================================================================
;Specific SCSI Requests
;==============================================================================

  ;----------------------------------------------------------------------------
  ;CBI Command Block Reset
  ;Used to "Reset" a CBI Device that is not responding
  ;On Receipt, the CBI Device will:
  ;  Attempt to abort any currently executing command or data transfer
  ;  Drop any command blocks that may be queued for execution
  ;  Reset the mass storage portion of the device (self-test, re-initialize)
  ;  Clear any persisitent command block failure condition
  ;Upon completion, Stall and DataX are undefined.  Host shall issue a
  ;  ClearFeatureHalt to both Bulk In and Bulk Out EndPoints to Clear Stalls
  ;  and Reset DataX.
  ;----------------------------------------------------------------------------
  SReqCBIReset STRUC
    SCBIResetCmd  DB 1Dh ;Command Request = SCmdSendDiagnostics
    SCBIResetLUN  DB 04h ;LUN = 0, Flags = SDiagSelfTest
    SCBIResetCode DD -1  ;Special Code to Indicate CBI Reset, not Send Diag
    SCBIResetPAD  DB 6 DUP (0) ;PAD/Reserved
      ;Should PAD be -1's or 0's?  Spec isn't clear (just shows ellipes)
      ;  Since this is a 6-byte command, they should probably be 0
   ENDS

;  ;----------------------------------------------------------------------------
;  ;SCSI Read Table of Contents Request
;  ;  Only applies to CD-ROMs/DVDs
;  ;  Format-A = 0 & Format-B = 1 indicates multi-session mode
;  ;  MSF = 0 indicates return CD address values are in LBA format,
;  ;    not minute-second-frame.
;  ;  Returns 13 bytes of data (see format defined in SReadTOCRespStruc)
;  ;----------------------------------------------------------------------------
;  SReadTOCReq:
;      DB SCmdReadTOC ;Command Request
;    TOCMSF:
;      DB          0  ;MSF in bit 1 (set to 0) (no LUN??)
;    TOCFormatA:
;      DB          0  ;Format-A in bits 3-0 (set to 0)
;      DB   4 DUP (0) ;PAD/Reserved
;    TOCLengthMSB:
;      DB          0  ;Allocation Length MSB
;    TOCLengthLSB:
;      DB         0Ch ;Allocation Length LSB (set to 12)
;    TOCFormatB:
;      DB         40h ;Format-B in bits 7-6 (set to 01h)
;      DB   2 DUP (0) ;PAD/Reserved

;  ;----------------------------------------------------------------------------
;  ;Response from a SCSI Read Table of Contents Request
;  ;----------------------------------------------------------------------------
;  SReadTOCRespStruc STRUC
;    TOCDataLen      DB 2 DUP (?) ;Data Length (will be 0Ah)
;    TOCFirstSession DB        1  ;First Complete Session Number (always 1)
;    TOCLastSession  DB        ?  ;Last Complete Session Number (1 for single-
;                                 ;  session disks or LUNs that don't support
;                                 ;  multiple-session disks)
;    ;TOC Track Decriptor follows
;                    DB 2 DUP (?) ;PAD/Reserved
;    TOCFirstTrack   DB        ?  ;First Track Number in Last Complete Session
;                    DB        ?  ;PAD/Reserved
;    TOCFirstLBA     DB 4 DUP (?) ;LBA of First Track in Last Session
;   ENDS
;  SReadTOCRespSize EQU (TYPE SReadTOCRespStruc) ;13 bytes


;;------------------------------------------------------------------------------
;;ASPI Commands and Status Codes
;;  NOTE: Adaptec's ASPI documentation pretty much universally interchanges
;;          the acronyms SCSI and ASPI with each other.  For example,
;;          Adaptec documentation refers to a command sent to the SCSI device
;;          through the ASPI interface as a SRB (SCSI Request Block).
;;          In actuality, the SRB is a SCSI Command in an ASPI "wrapper",
;;          and it causes me a lot of heartburn to call it a SCSI command
;;          when it's not.  Therefore, I won't.  Instead, I'm going to call
;;          it an ASPI Request Block (ARB).
;;        What we actually do in this program is "extract" the SCSI request
;;          out of the ASPI request and then "wrap" the SCSI request inside
;;          a USB request, which is what gets transported across the USB Bus.
;;          I would never have the audacity to call a SCSI command "wrapped"
;;          inside a USB command a SCSI command (it's a USB command, not a
;;          SCSI command, just like an ASPI command is not a SCSI command).
;;------------------------------------------------------------------------------
;
;  ;----------------------------------------------------------------------------
;  ;Header common to all ASPI Request Blocks
;  ;----------------------------------------------------------------------------
;  ASPIReqBlkHdr     STRUC     ;ASPI Request Block Header
;    AReqHReqType       DB  ?  ;Request Type (Request Number)
;      ARTHostInquiry  EQU 00h ;Host Adapter Inquiry (also Extended Inquiry)
;      ARTGetDvcType   EQU 01h ;Get Device Type
;      ARTExecSCSIIO   EQU 02h ;Execute SCSI I/O Command
;      ARTAbortASPIReq EQU 03h ;Abort ASPI Request (SCSI Request)
;      ARTResetDvc     EQU 04h ;Reset SCSI Device
;      ARTSetHostParam EQU 05h ;Set Host Adapter Parameters (Hardware Specific)
;      ARTGetDiskInfo  EQU 06h ;Get Disk Drive Info
;      ARTGetASPIInfo  EQU 7Fh ;Get ASPI Manager Info (we do not support this)
;    AReqHStatus        DB  ?  ;Request (Requester waits for non zero)
;      ARSPending      EQU 00h ;Request Still Pending (not completed yet)
;      ARSSuccess      EQU 01h ;Request Completed Successfully
;      ARSHostAbort    EQU 02h ;Aborted by Host
;      ARSIOError      EQU 04h ;SCSI I/O Error
;      ARSInvalid      EQU 80h ;Invalid??
;      ARSNoAdapter    EQU 81h ;No Adapter
;      ARSNoDevice     EQU 82h ;No Device Attached
;    AReqHHostAdapter   DB  ?  ;Host Adapter Number
;    AReqHFlags         DB  ?  ;Flags
;      ARFPosting      EQU 01h ;Posting Enabled
;      ARFLinking      EQU 02h ;Linking Enabled
;      ARFDALResid     EQU 04h ;Residual Byte Len Reported in Data Alloc Len
;      ARFTarget2Host  EQU 08h ;Direction = In (Target to Host)
;      ARFHost2Target  EQU 10h ;Direction = Out (Host to Target)
;      ARFScatter      EQU 20h ;Scatter/Gather
;                              ;If both directions are set, no data is xfered
;                              ;If neither is set, direction is in SCSI Cmd
;      ;Bits 6-7 = Reserved
;    AReqHPAD           DD  ?  ;PAD/Reserved (0)
;   ENDS
;  ASPIReqBlkHdrSize EQU (TYPE ASPIReqBlkHdr) ;8 bytes
;
;  ;----------------------------------------------------------------------------
;  ;Function 0 (Host Inquiry)
;  ;----------------------------------------------------------------------------
;  ASPIReqHostInquiry STRUC           ;ASPI Host Inquiry Request Block
;    ARHIHdr            DB ASPIReqBlkHdrSize DUP (?) ;Common Header
;    ARHINumAdapters    DB         ?  ;<ret> Number of Host Adapters
;    ARHITargetAdapter  DB         ?  ;<ret> Target Adapter ID
;    ARHISCSIMgrID      DB 16 DUP (?) ;<ret> SCSI Manager ID
;    ARHIHostAdapter    DB 16 DUP (?) ;<ret> Host Adapter ID
;    ARHIHostParams     DB 16 DUP (0) ;<ret> Host Adapter Parameters
;                                     ;      (hardware-specific)
;                                     ;      For now, we will return all zeroes
;                                     ;      Later we may rtn Host, Addr, Intf
;    ARHIPAD            DB  5 DUP (0) ;PAD/Reserved
;   ENDS
;
;  ;Function 1 (Get Device Type)
;  ASPIReqGetDvcType STRUC    ;ASPI Get Device Type Request Block
;    ARGDTHdr           DB ASPIReqBlkHdrSize DUP (?) ;Common Header
;    ARGDTTargetID      DB ?  ;Target ID
;    ARGDTLUN           DB ?  ;Logical Unit Number
;    ARGDTDvcType       DB ?  ;<ret> Device Type (same codes as returned
;                             ;      by SCSI Inquiry Request PDT Codes)
;                             ;      (0 = Disk, 1 = Tape, 2 = Printer, etc.)
;    ARGDTPAD   DB 53 DUP (?) ;PAD/Reserved (we'll return all zeroes)
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Function 2 (SCSI I/O Request)
;  ;----------------------------------------------------------------------------
;  ASPIReqSCSIIO     STRUC            ;ASPI SCSI I/O Request Block
;    ARSIOHdr           DB ASPIReqBlkHdrSize DUP (?) ;Common Header
;    ARSIOTargetID      DB         ?  ;Target (Host Adapter?) ID
;    ARSIOLUN           DB         ?  ;Logical Unit Number
;    ARSIODataLength    DD         ?  ;Data Allocation Length
;                                     ;<ret> Residual Byte Length
;                                     ;      (if supported & requested)
;    ARSIOSenseLength   DB         ?  ;Sense Allocation Length (set to 16/18/20/24)
;    ARSIODataBuffer    DD         ?  ;Data Buffer Pointer
;    ARSIONextRequest   DD         ?  ;Next Request Pointer (for Linking)
;    ARSIOCDBLength     DB         ?  ;CDB Length (SCSI Request Length 10/12)
;    ARSIOHostStatus    DB         ?  ;<ret> Host Adapter Status
;      ARHSOK          EQU        00h ;OK/No Error
;      ARHSSelectTO    EQU        11h ;Select Timeout
;      ARHSDataOverrun EQU        12h ;Data Overrun
;      ARHSBusError    EQU        13h ;Bus Error
;      ARHSBusFailure  EQU        14h ;Bus Failure
;    ARSIOTargetStatus  DB         ?  ;<ret> Target Status
;      ARTSNone        EQU        00h ;No Status
;      ARTSSenseInARB  EQU        02h ;Sense Data Stored in ASPI Request Block
;      ARTSTargetBusy  EQU        08h ;Target Busy
;      ARTSReservErr   EQU        18h ;Reservation Error
;    ARSIOPostAddr      DD         ?  ;Post Routine Address
;                                     ;  Auto-called after ASPI Req complete
;                                     ;    With: original SRB address on Stack
;                                     ;          Interrupts Disabled
;                                     ;  Post Routine must return
;                                     ;    With: EBX, EDI, ESI, EBP Unchanged
;                                     ;          Interrupts Disabled
;                                     ;  Post Routine must return quickly
;                                     ;  Post Routine can issue any ASPI call
;                                     ;    except an Abort
;;    ARSIOPostDataSeg   DW         ?  ;Post Real Mode Data Segment (DS)
;;    ARSIOARBPtr        DD         ?  ;ASPI Request Block Pointer
;;    ARSIOPAD           DW         ?  ;PAD/Reserved
;;    ARSIOARBPhysAddr   DD         ?  ;ASPI Request Block Physical Address
;;    ARSIOWorkSpace     DB 22 DUP (?) ;SCSIMGR$ Workspace
;    ARSIOWorkSpace     DB 34 DUP (?) ;SCSIMGR$ Workspace
;    ARSIOCDB           DB 12 DUP (?) ;Command Data Block (may be 10/12 bytes)
;                                     ;  (Size must match ARSIOCDBLength)
;                                     ;  (This is the actual SCSI Command)
;                                     ;For UFI (USB Floppy Interface), size
;                                     ;  is ALWAYS 12 bytes
;    ARSIOSenseData     DB 32 DUP (?) ;<ret> Sense Data
;                                     ;  (Usually only need about 16 bytes)
;                                     ;This is the actual SCSI Response Data
;   ENDS
;  ASPIReqSCSIIOSize EQU (TYPE  ASPIReqSCSIIO) ;Size of Request = 88 bytes
;
;  ;----------------------------------------------------------------------------
;  ;Function 3 (Abort ASPI Request)
;  ;----------------------------------------------------------------------------
;  ASPIReqAbort STRUC            ;ASPI Abort Request Block
;    ARAbortHdr    DB ASPIReqBlkHdrSize DUP (?) ;Common Header
;    ARAbortAddr   DD         ?  ;Address of ASPI Request Block to Abort
;    ARAbortPAD    DB 52 DUP (0) ;PAD/Reserved
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Function 4 (Reset SCSI Device)
;  ;----------------------------------------------------------------------------
;  ASPIReqResetDvc  STRUC            ;ASPI Reset SCSI Device Request Block
;    ARRstHdr          DB ASPIReqBlkHdrSize DUP (?) ;Common Header
;    ARRstTargetID     DB         ?  ;Target ID
;    ARRstLUN          DB         ?  ;Logical Unit Number
;    ARRstPAD          DB 14 DUP (0) ;PAD/Reserved
;    ARRstHostStatus   DB         ?  ;<ret> Host Adapter Status (same as Func 2)
;    ARRstTargetStatus DB         ?  ;<ret> Target Status (same as Func 2)
;    ARRstPostAddr     DD         ?  ;Post Routine Address
;    ARRstWorkSpace    DB 34 DUP (0) ;SCSIMGR$ WorkSpace
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Function 5 (Set Host Parameters) - We do not support this function
;  ;----------------------------------------------------------------------------
;  ASPIReqSetHostParam STRUC         ;ASPI Set Host Parameters Request Block
;    ARSHPHdr          DB ASPIReqBlkHdrSize DUP (?) ;Common Header
;    ARSHPPAD          DB 56 DUP (0) ;PAD/Reserved (Hardware-specific)
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Function 6 (Get Disk Drive Info)
;  ;----------------------------------------------------------------------------
;  ASPIReqGetDiskInfo STRUC            ;ASPI Get Disk Information Request Block
;    ARDiskHdr           DB ASPIReqBlkHdrSize DUP (?) ;Common Header
;    ARDiskTargetID      DB         ?  ;Target ID
;    ARDiskLUN           DB         ?  ;Logical Unit Number
;    ARDiskFlags         DB         ?  ;Disk Drive Flags
;      ARDFInt13None    EQU        00h ;No INT 13h Access
;      ARDFInt13DOS     EQU        01h ;INT 13h with DOS Access
;      ARDFInt14NoDOS   EQU        02h ;INT 13h without DOS Access
;      ARDFInvalidFlags EQU        03h ;Invalid Flags
;    ARDiskInt13Drive    DB         ?  ;INT 13h Drive Number (0=A, etc?)
;    ARDiskHeadXlat      DB         ?  ;Preferred Head Number Translation
;    ARDiskSectorXlat    DB         ?  ;Preferred Sector Number Translation
;    ARDiskPAD1          DB 10 DUP (0) ;Reserved
;    ARDiskPAD2          DB 40 DUP (0) ;PAD/Reserved
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Function 7Fh (Get ASPI Info) - We do not support this function
;  ;----------------------------------------------------------------------------
;  ASPIReqGetASPIInfo STRUC          ;ASPI Get ASPI Info Request Block
;    ARGAIHdr          DB ASPIReqBlkHdrSize DUP (?) ;Common Header
;    ARGAIPAD          DB 56 DUP (0) ;PAD/Reserved
;                                    ;Adaptec Drivers return IRQ, I/O Port, etc.
;   ENDS


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;MACROS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

  JUMP MACRO     ;Do a NEAR (SHORT) JMP instead of a Local JMP
    JMP SHORT #1
   #EM


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;TSR DATA
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;==============================================================================
;TSR Related
;==============================================================================

  ;------------------------------------------------------------------------------
  ;INT2F Data (this needs to be the first data at the top of the file)
  ;If the user does a "TYPE USBDRIVE.COM" at the command line, this will
  ;  just show the program name and version, instead of sending all kinds of
  ;  annoying happy faces and BELs to the screen the way most programs do.
  ;This is also the same data that is used to test if the program is
  ;  already installed in memory.
  ;------------------------------------------------------------------------------
  NoType1:     DB               CR  ;To handle TYPE from command line
  ProgName:    DB        'USBDRIVE' ;Program Name
  ProgNameLen EQU       $-ProgName  ;Length of name
  ProgVerTxt:  DB           ' 0.18' ;Program version in ASCII
  Author:      DB '  Bret Johnson' ;Authors name
  AuthorLen   EQU         $-Author  ;Length of Author
  NoType2:     DB              EOF  ;To handle TYPE from command line
  ProgVer      DW             0018h ;Program version as a word
  HandleNum    DB              0C0h ;TSR multiplex handle number

  ;------------------------------------------------------------------------------
  ;Miscellaneous Yes/No TSR Flags
  ;------------------------------------------------------------------------------
  TSRFlags         DB 00h ;Miscellaneous Yes/No Flags
    Uninstalled   EQU 01h ;Program has been uninstalled
    NoBeep        EQU 02h ;Don't Beep the Speaker
    Int14ReqInUse EQU 04h ;Currently using the Int 14 Request Structure
    SectBuffInUse EQU 08h ;Currently using the Sector Buffer
    NoBeep1Time   EQU 10h ;No Beep this One Time
    UseFAT32      EQU 20h ;Allow FAT32 drives (assign Drive letters to them)
    IsFreeDOS     EQU 40h ;FreeDOS (needed for FAT32 patch)


;==============================================================================
;Stack Related
;==============================================================================
  StackInUse DB 0 ;Counter to keep track of "setup stack" calls
  OldSS      DW ? ;Original Stack Segment
  OldSP      DW ? ;Original Stack Pointer
  TempBX     DW ? ;Temporary Storage for BX while setting up Stack
  TempFlags  DW ? ;Temporary Storage for Flags while setting up Stack


;==============================================================================
;DOS Related
;==============================================================================
  DOSVersion DW ? ;DOS Version (Major in AH, Minor in AL, BCD)

;  ;----------------------------------------------------------------------------
;  ;Maximum partition sizes (in Sectors) for various versions of DOS
;  ;DOS version 7+ gets wierd for maximum partition sizes.  Early versions
;  ;  of DOS 7 (DOS 95) still used FAT16, so the maximum size is the same as
;  ;  as DOS 6 (2 GB).  FAT32 was introduced in DOS 95 OSR 2, but the maximum
;  ;  partition size was still limited to 32 GB (I think).  DOS 98 (DOS 7.1)
;  ;  had a maximum partition size of 128 GB.  DOS Me was the first (and only)
;  ;  Microsoft DOS to support 2 TB, the actual limit for FAT32.
;  ;Also note that Windows NT, 2000, & XP (and maybe Vista as well) can use
;  ;  partitions up to 2 TB, but cannot format them.  The maximum size they
;  ;  can format is 32 GB.  The only MS product that can format a partition
;  ;  larger than 32 GB is Windows/DOS Me.
;  ;----------------------------------------------------------------------------
;  MaxPartSizeTbl:
;;    DB 3         ;DOS Version 3 (32 MB)
;;      DD   65536 ;    33,554,432 bytes   16384 Clusters   4 Sects/Cluster
;    DB 4         ;DOS Version 4 (128 MB)
;      DD  262144 ;   134,217,728 bytes   65536 Clusters   4 Sects/Cluster
;    DB 5         ;DOS Version 5 (512 MB)
;      DD 1048576 ;   536,870,912 bytes   65536 Clusters  16 Sects/Cluster
;    DB 6         ;DOS Version 6 (2 GB)
;      DD 4194304 ; 2,273,312,768 bytes   65536 Clusters  64 Sects/Cluster
;    DB 0         ;End of Table


;==============================================================================
;Device Driver Related
;==============================================================================
  EVEN 2
  DvcDriverHdr:
    DD 0FFFF_FFFFh  ;Pointer to Next Device Header
    DW DHAttrsToUse ;Attributes
    DW DvcStrategy  ;Offset of Strategy Code
    DW DvcInterrupt ;Offset of Interrupt Code
    DB ?            ;Number of Drives handled by Device Driver
                    ;  (Determined by how many the user wants to have)
    DB 'USBDrvs'    ;Driver Name

  DvcDrvReqOffset DD ? ;Request Pointer (issued by Strategy Call)

  ;----------------------------------------------------------------------------
  ;Code Offset Lookup Table for DOS Driver calls
  ;  Functions NOT Supported:
  ;    RHCmdInitialize    (00h) Only needed if we install in CONFIG.SYS
  ;    RHCmdIOCtlRead     (03h) No generic DOS support defined
  ;    RHCmdNDRead        (05h) Character Devices Only
  ;    RHCmdInputStatus   (06h) Character Devices Only
  ;    RHCmdFlushInput    (07h) Character Devices Only
  ;    RHCmdOutputStatus  (0Ah) Character Devices Only
  ;    RHCmdFlushOutput   (0Bh) Character Devices Only
  ;    RHCmdIOCtlWrite    (0Ch) No generic DOS support defined
  ;    RHCmdOutputTilBusy (10h) Character Devices Only
  ;----------------------------------------------------------------------------
  DvcIntTable:
    DB RHCmdMediaCheck      ;Media Check (01h)
     DW DvcIntMediaCheck
    DB RHCmdBuildBPB        ;Build BIOS Parameter Block (02h)
     DW DvcIntBuildBPB
    DB RHCmdRead            ;Read (04h)
     DW DvcIntRead
    DB RHCmdWrite           ;Write (08h)
     DW DvcIntWrite
    DB RHCmdWriteVerify     ;Write with Verification (09h)
     DW DvcIntWriteVerify
    DB RHCmdOpen            ;Device Open (0Dh)
     DW DvcIntOpen
    DB RHCmdClose           ;Device Close (0Eh)
     DW DvcIntClose
    DB RHCmdRemovable       ;Removable Media (0Fh)
     DW DvcIntRemovable
    DB RHCmdGenIOCtlV3      ;Generic IOCTL DOS 3 (11h)
     DW DvcIntGenIOCtlV3
    DB RHCmdGenIOCtlV4      ;Generic IOCTL DOS 4+ (13h)
     DW DvcIntGenIOCtlV4
    DB RHCmdGetLogicalDvc   ;Get Logical Device (17h)
     DW DvcIntGetLogicalDvc
    DB RHCmdSetLogicalDvc   ;Set Logical Device (18h)
     DW DvcIntSetLogicalDvc
    DB RHCmdIOCtlCheck      ;IOCTL Check DOS 5+ (19h)
     DW DvcIntIOCtlCheck
    DB -1                   ;End of Table
     DW -1

  ;----------------------------------------------------------------------------
  ;Code Offset Lookup Table for DOS Driver Generic IOCTL calls
  ;----------------------------------------------------------------------------
  GenIOCmdTable:
    DB IOCmdSetDvcParams ;Set Device Parameters
     DW GIOSetDvcParams
    DB IOCmdGetDvcParams ;Get Device Parameters
     DW GIOGetDvcParams
    DB IOCmdWriteTrack   ;Write Track
     DW GIOWriteTrack
    DB IOCmdReadTrack    ;Read Track
     DW GIOReadTrack
    DB IOCmdFormatTrack  ;Format Track
     DW GIOFormatTrack
    DB IOCmdVerifyTrack  ;Verify Track
     DW GIOVerifyTrack
    DB IOCmdSetVolSerNum ;Set Volume Serial Number
     DW GIOSetVolSerNum
    DB IOCmdGetVolSerNum ;Get Volume Serial Number
     DW GIOGetVolSerNum
    DB IOCmdGetAccess    ;Get Access Status
     DW GIOGetAccess
    DB IOCmdSetAccess    ;Set Access Status
     DW GIOSetAccess
    DB -1                ;End of Table
     DW -1


  ;----------------------------------------------------------------------------
  ;Data downloaded from DOS's List of Lists that we need to use
  ;We would normally simply call the DOS List of List function when we
  ;  needed these things instead of storing them (in case they somehow
  ;  got changed, though I don't think they ever would).  Because we
  ;  need these things in the TSR, though, and we generally can't call
  ;  DOS functions from a TSR, we download these when we aren't a TSR
  ;  (as the program is first installing) and store them here.
  ;----------------------------------------------------------------------------
  FirstCDSPtr     DD   ? ;Pointer to First Current Directory Structure
  MaxBytesPerSect DW 512 ;Maximum Bytes Per Sector for any Block Device
                         ;  (almost always 512, but could be something else)

  ;----------------------------------------------------------------------------
  ;Default Serial Number, Volume Name, & File System Type Name
  ;  (Always used when there was never a real name created)
  ;  This is the data returned by a DOS 3 formatted floppy in a USB Drive
  ;    under Windows XP.  There is no "standard" data that should be
  ;    returned (as far as I know) in this situation, so we'll just
  ;    copy what Windows does.
  ;  Documentation for IBM DOS version 7 says that we should return
  ;    an "invalid media" error if the disk does not have any of this
  ;    data.  We'll do what Windows does instead.
  ;----------------------------------------------------------------------------
  DefSerialNum:
    DD 0
  DefVolumeName:
    DB 'MSD        '   ;Exactly 11 Characters
  DefSerNum:
    DB 'FAT',0,0,0,0,0 ;Exactly 8 Characters

  ;----------------------------------------------------------------------------
  ;Maximum number of Sectors to Transfer in a Single Transaction
  ;  Linux says that the maximum for some disks is 32kb (64 sectors).
  ;  Windows seems to only do 4 or 8KB at a time -- haven't really
  ;    figured out when or why they do things -- may be related to
  ;    cluster size.
  ;  At least while using INT 25h/26h functions, it seems that we can only use
  ;    a maximum value of 4 or we get LOTS of errors.  We will need to
  ;    experiment on some other computers to see how consistent this
  ;    is.  It's possible that it depends on the Host Controller hardware
  ;    or Hub that the Device is attached to.
  ;----------------------------------------------------------------------------
  MaxXferSects EQU 64 ;32kB (Based on Linux Documentation)
  DefXferSects EQU  1 ;Max size that works on my computers
;  DefXferSects EQU  4 ;Max size that works on my computers
                      ;Get errors once in a great while with this value,
                      ;  but overall it works very well
  MinXferSects EQU  1 ;Can't be 0

  XferSects DW DefXferSects ;Maximum Number of Sectors to Transfer in Reads/Writes


;==============================================================================
;Background SCSI Request Related
;==============================================================================
  NextSCSIReqOffset DW ? ;Code Address of Next SCSI-related background stage
  BGReqNextCode     DW ? ;Code to issue when Background SCSI Request is Complete


;==============================================================================
;SCSI Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Devices that cannot handle SCSI Unit Lock/Unlock Requests
  ;  This list came from Linux
  ;  To minimize memory use, we really only care about Devices that actually
  ;    crash or lock up if they receive a particular request, not ones that
  ;    simply reject or ignore the request with no undesirable side-effects.
  ;  First word is Vendor ID, Second Word is Device ID
  ;----------------------------------------------------------------------------
  UnlockableTbl:
    DW 00419h, 0AAF5h ;TrekStor, i.Beat 115 2.0
    DW 00457h, 00150h ;USBest Technology, USB Mass Storage Device
    DW 00457h, 00151h ;USB 2.0, Flash Disk
    DW 00482h, 00107h ;Kyocera, CONTAX SL300R T*
    DW 004B0h, 00301h ;NIKON, NIKON DSC E2000
    DW 004DAh, 02372h ;Panasonic, DMC-LCx Camera
    DW 004DAh, 02373h ;LEICA, D-LUX Camera
    DW 0054Ch, 00010h ;Sony, DSC-S30/S70/S75/505V/F505/F707/F717/P8
    DW 005ACh, 01204h ;Apple, iPod
    DW 00851h, 01543h ;PanDigital, Photo Frame
    DW 04146h, 0BA01h ;Iomega, Micro Mini 1GB
    DW 0 ;End of Table


;==============================================================================
;Drive Related
;==============================================================================

  EVEN 2

  ;----------------------------------------------------------------------------
  ;Interrupt Vectors used as pointers by the BIOS for Hard Drive Parameters
  ;----------------------------------------------------------------------------
  OldInt41Vect DD -1 ;Old INT 41h (FDPT for first hard drive, 80h)
  OldInt46Vect DD -1 ;Old INT 41h (FDPT for second hard drive, 81h)

  ;----------------------------------------------------------------------------
  ;Fixed Disk Parameter Tables for the first two Hard Drives
  ;----------------------------------------------------------------------------
  FDPT80h: DB (TYPE FDPTStruc) DUP (0) ;FBPT for first Hard Drive (80h)
  FDPT81h: DB (TYPE FDPTStruc) DUP (0) ;FBPT for Second Hard Drive (81h)

  ;----------------------------------------------------------------------------
  ;Fixed Disk Parameter Table for a 10MB HD (default to use when no
  ;  Drive is installed yet)
  ;This is copied from the BIOS of a computer with no second disk installed
  ;----------------------------------------------------------------------------
  FDPT10MB:
    DW 0132h ;Tracks = 306
    DB   04h ;Heads = 4
    DW 0000h ;Reduced Write Current Cylinder = 0
    DW 0080h ;Precompensation Cylinder = 128
    DB   00h ;Max ECC Burst Length = 0
    DB   00h ;Control Byte = 0
    DB   00h ;Standard Timeout = 0
    DB   00h ;Formatting Timeout = 0
    DB   00h ;Check Drive Timeout = 0
    DW 0131h ;Landing Zone Track = 305
    DB   11h ;Sectors per Track = 17
    DB   00h ;PAD

  ;----------------------------------------------------------------------------
  ;Enhanced Disk Parameter Table for a Drive Larger than 8GB
  ;This is copied from the BIOS of a computer with a Large Hard Drive
  ;----------------------------------------------------------------------------
  EDPTLarge:
    DW 0400h ;Logical Tracks = 1024
    DB  0FFh ;Logical Heads = 255
    DB  0A0h ;Signature for EDPT
    DB   3Fh ;Physical Sectors = 63
    DW 0000h ;Precompensation Cylinder = 0
    DB   00h ;PAD
    DB   08h ;Control Byte = 8
    DW 3FFFh ;Physical Tracks = 16383
    DB   10h ;Physical Heads = 16
    DW 3FFFh ;Landing Zone Track = 16383
    DB   3Fh ;Logical Sectors per Track = 63
    DB   4Bh ;Checksum

  ;----------------------------------------------------------------------------
  ;Data needed while parsing though Partition & Boot Records when a New
  ;  Device is attached
  ;----------------------------------------------------------------------------
  EVEN 2
  NewPartIndex   DB ? ;Current Partition Index
  NewPartOS      DB ? ;Partition Operating System
  NewPartSector  DD ? ;Current Partition Sector
  NewBootSector  DD ? ;Sector number of Volume Boot Sector
  NewSectsInPart DD ? ;Number of Sectors in Partition

  LBAInBuffer    DD ? ;LBA of the Sector that is in the Sector Buffer

  ;----------------------------------------------------------------------------
  ;Our Partition Stack
  ;Keeps track of Extended Partitions as we process our way through all
  ;  of the Partition Entries on a Drive.
  ;----------------------------------------------------------------------------
;  PStkEntries EQU 10 ;Maximum Partition Levels we can process
  PStkEntries EQU 16 ;Maximum Partition Levels we can process
  EVEN 2
  PartStack:
    DB (PStkEntries*PStkSize) DUP (0)

  PartStackPtr DW PartStack ;Pointer to Current Partition Stack Entry

  ;----------------------------------------------------------------------------
  ;Miscellaneous data needed while Processing Partitions on a Drive
  ;----------------------------------------------------------------------------
  CurrentLUN DB 0 ;Current LUN Number we are processing


;==============================================================================
;INT 13h Related
;==============================================================================

  Int13AXInput DW ? ;Function (AH) and AL Values on Input to INT 13h Call
  Int13DXInput DW ? ;DX Value on Input to INT 13h Call

  Int13AHSuccess  DB  0 ;Value to Return in AH if the Call is Successful
                        ;Normally 0, but some INT 13h Functions require a
                        ;  non-zero value returned in AH even if the call
                        ;  is successful

I13CmdTable:
  ;----------------------------------------------------------------------------
  ;Basic INT 13h Functions
  ;----------------------------------------------------------------------------
  DB I13CmdResetSystem  ;Reset Disk System
     DW I13ResetSystem
  DB I13CmdLastStatus   ;Get Status of Last Operation
     DW I13LastStatus
  DB I13CmdRead         ;Read Sectors into Memory
     DW I13Read
  DB I13CmdWrite        ;Write Disk Sectors
     DW I13Write
  DB I13CmdVerify       ;Verify Disk Sectors
     DW I13Verify
  DB I13CmdFormatTrack  ;Format Track
     DW I13FormatTrack
  DB I13CmdFormatBad    ;Format Track and Set Bad Sectors Flag
     DW I13FormatBad
  DB I13CmdFormatDrive  ;Format Drive Starting at Given Track
     DW I13FormatDrive
  DB I13CmdGetParams    ;Get Drive Parameters
     DW I13GetParams
  DB I13CmdInitParams   ;Initialize Controller with Drive Parameters
     DW I13InitParams
  DB I13CmdSeek         ;Seek to Cylinder
     DW I13Seek
  DB I13CmdResetDisk    ;Reset Hard Disk
     DW I13ResetDisk
  DB I13CmdCheckReady   ;Check if Drive Ready
     DW I13CheckReady
  DB I13CmdRecalibrate  ;Recalibrate Drive
     DW I13Recalibrate
  DB I13CmdRAMDiag      ;Controller RAM Diagnostic
     DW I13RAMDiag
  DB I13CmdDriveDiag    ;Drive Diagnostic
     DW I13DriveDiag
  DB I13CmdContDiag     ;Controller Internal Diagnostics
     DW I13ContDiag
  DB I13CmdGetDiskType  ;Get Disk Type
     DW I13GetDiskType
  DB I13CmdDetChange    ;Detect Disk Change
     DW I13DetChange
  DB I13CmdSetDiskType  ;Set Disk Type for Format
     DW I13SetDiskType
  DB I13CmdSetMediaType ;Set Media Type for Format
     DW I13SetMediaType
  ;----------------------------------------------------------------------------
  ;Extended INT 13h Functions
  ;----------------------------------------------------------------------------
  DB I13CmdXInstallCk   ;Extended Installation Check
     DW I13XInstallCk
  DB I13CmdXRead        ;Extended Read
     DW I13XRead
  DB I13CmdXWrite       ;Extended Write
     DW I13XWrite
  DB I13CmdXVerify      ;Extended Verify Sectors
     DW I13XVerify
  DB I13CmdXExtSeek     ;Extended Seek
     DW I13XExtSeek
  DB I13CmdXGetDrvParams;Extended Get Drive Parameters
     DW I13XGetDrvParams
  ;----------------------------------------------------------------------------
  ;New Functions we've added
  ;----------------------------------------------------------------------------
  DB I13CmdIssueSCSIReq ;Issue SCSI Request
     DW I13IssueSCSIReq
  ;----------------------------------------------------------------------------
  ;End of Table
  ;----------------------------------------------------------------------------
  DB -1    ;End of Table
     DW -1


;==============================================================================
;Format Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Character to use when doing high-level formats on non-Floppies
  ;----------------------------------------------------------------------------
  FormatFillByte DB ?

  ;----------------------------------------------------------------------------
  ;Starting Sector for Format Option
  ;  (We don't necessarily always start at Sector 0!)
  ;----------------------------------------------------------------------------
  FmtStartSect DW ?

  ;----------------------------------------------------------------------------
  ;Data structure needed to format a floppy drive
  ;USB floppies use a modified version of the Defect List Structure
  ;  (normally associated with delineating bad sectors) to issue format
  ;  requests.  Not exactly what you would expect, but it works.
  ;----------------------------------------------------------------------------
  FmtDefectList:
    DB   00h ;PAD/Reserved
    DB (DefFlgFOV+DefFlgNoCert+DefFlg1Track)
             ;Flags (B0h), Head # Gets Masked in Bit 0 (DefFlgSide1)
    DW 0800h ;Defect List Length (High-Endian)
    DD    ?  ;Number of Blocks on Media (High-Endian)
    DB    0  ;Code (0 for all Writes)
    DB    0  ;High byte of Tri-Byte High-Endian Sector Length
    DW    ?  ;Block/Sector Length (High-Endian, almost always 512)
    ;12 bytes total


;==============================================================================
;SCSI Buffers
;==============================================================================

  EVEN 2

  ;----------------------------------------------------------------------------
  ;Buffer for SCSI Inquiry Response
  ;----------------------------------------------------------------------------
  InquiryBuff:
    DB SInquiryRespSize DUP (-1)

  ;----------------------------------------------------------------------------
  ;Buffer for SCSI Get Format Capacity Response
  ;----------------------------------------------------------------------------
  FmtCapacityBuff:
    DB FmtCapacityRespSize DUP (-1)

  ;----------------------------------------------------------------------------
  ;Buffer for SCSI Get Capacity Response
  ;----------------------------------------------------------------------------
  CapacityBuff:
    DB FormatDescrSize DUP (-1)

  ;----------------------------------------------------------------------------
  ;Buffer for SCSI Mode Sense Response
  ;----------------------------------------------------------------------------
  ModeSenseBuff:
    DB MSenseRespSize DUP (-1)


;==============================================================================
;New Device Related
;==============================================================================
  NewWaitHostIndex  DB ? ;Host Index of Device we're waiting for
  NewWaitDvcAddress DB ? ;Device Address of Device we're waiting for
  NewWaitTimer      DW ? ;Timer Tick Counter for waiting


;==============================================================================
;USB Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Handle Number of New Device (Device 0) Registry
  ;----------------------------------------------------------------------------
  Reg0Handle DW ?

  ;----------------------------------------------------------------------------
  ;Int08 Countdown Timers
  ;----------------------------------------------------------------------------
  NewDvcCounter   DW 5 ;Countdown Timer to periodically check for new Devices
                       ;Initial Delay is 5 timer ticks (about 1/4 second)
                       ;Delays after initial one will be about 1 second
                       ;Setting to 0 Disables the program
  DontLookCounter DW 0 ;Countdown Timer to not Look for New Devices

  ;----------------------------------------------------------------------------
  ;Delay during Drive Initialization
  ;----------------------------------------------------------------------------
  ;InitDelay DW 91 ;5 seconds * 18.2 Timer Ticks per Second
  InitDelay DW 0 ;0 seconds

  ;----------------------------------------------------------------------------
  ;Calls that the USB Host Driver can send to us after we're "registered"
  ;Our code is called with this function code in AX
  ;----------------------------------------------------------------------------
  OwnerCallFunctionTbl:
   ;Device Connect/Disconnect
    DB OwnerCallNewDvc        ;New Device Connected
     DW DeviceAdded
    DB OwnerCallDvcDisc       ;Existing Device Disconnected
     DW DeviceDisconnected
    DB OwnerCallDvc0Disc      ;Unregistered Device Disconnected
     DW Device0Disconnected
    DB OwnerCallDontLook      ;Don't Look for New Interface Temporarily
     DW StartDontLook
   ;Device Enable/Disable/Reset/Suspend/Resume/PwrOn/PwrOff/PwrReset
    DB OwnerCallDvcEnable     ;Device Enabled
     DW DeviceEnabled
    DB OwnerCallDvcDisable    ;Device Disabled
     DW DeviceDisabled
    DB OwnerCallDvcReset      ;Device Reset
     DW DeviceReset
    DB OwnerCallDvcSuspend    ;Device Suspend
     DW DeviceSuspend
    DB OwnerCallDvcResume     ;Device Resume
     DW DeviceResume
    DB OwnerCallDvcPwrOn      ;Device Power On
     DW DevicePowerOn
    DB OwnerCallDvcPwrOff     ;Device Power Off
     DW DevicePowerOff
    DB OwnerCallDvcPwrReset   ;Device Power Reset
     DW DevicePowerReset
   ;Host Connect/Disconnect
    DB OwnerCallNewHost       ;New Host has been Added
     DW NewHostAdded
    DB OwnerCallHostDisc      ;Existing Host Disconnected
     DW HostDisconnected
    DB OwnerCallHostHWErr     ;Host System/Processor Error
     DW HostHWErr
   ;Host Run/Stop/Reset/Suspend/Resume/Debug/SingleStep
    DB OwnerCallHostRun       ;Host Running
     DW HostRun
    DB OwnerCallHostStop      ;Host Stopped
     DW HostStop
    DB OwnerCallHostReset     ;Host Reset
     DW HostReset
    DB OwnerCallHostSuspend   ;Host Suspended
     DW HostSuspend
    DB OwnerCallHostResume    ;Host Resumed
     DW HostResume
    DB OwnerCallHostDebug     ;Host in Debug Mode
     DW HostDebug
    DB OwnerCallHostSST       ;Host Single-Stepped
     DW HostSST
   ;Timing Changes
    DB OwnerCallTimingChg     ;Host Timing Changed
     DW TimingChange
   ;Upstream Device Changes
    DB OwnerCallDvcDiscUS     ;Device Disconnect Upstream
     DW DeviceDisconnectedUS
    DB OwnerCallDvcEnableUS   ;Device Enable Upstream
     DW DeviceEnabledUS
    DB OwnerCallDvcDisableUS  ;Device Disable Upstream
     DW DeviceDisabledUS
    DB OwnerCallDvcResetUS    ;Device Reset Upstream
     DW DeviceResetUS
    DB OwnerCallDvcSuspendUS  ;Device Suspend Upstream
     DW DeviceSuspendUS
    DB OwnerCallDvcResumeUS   ;Device Resume Upstream
     DW DeviceResumeUS
    DB OwnerCallDvcPwrOnUS    ;Device Power On Upstream
     DW DevicePowerOnUS
    DB OwnerCallDvcPwrOffUS   ;Device Power Off Upstream
     DW DevicePowerOffUS
    DB OwnerCallDvcPwrResetUS ;Device Power Reset Upstream
     DW DevicePowerResetUS
   ;End of Table
    DB -1                     ;End of Table
     DW -1

  ;----------------------------------------------------------------------------
  ;Table to keep track of individual USB Devices (Interfaces)
  ;----------------------------------------------------------------------------
  EVEN 2
  NumDevices DW 4 ;Number of USB Devices we can control
  NumDisks   DW 8 ;Number of Disks (LUNs) we can control
  NumDrives  DW 8 ;Number of DOS Drive Letters we can control

  DeviceInfoOffset DW ? ;Offset to USB Device Info Table
  DiskInfoOffset   DW ? ;Offset to Disk/LUN Info Table
  DriveInfoOffset  DW ? ;Offset to DOS Drive Letter Info Table

  ;----------------------------------------------------------------------------
  ;Table to keep track of "bad" (incompatible) Devices.
  ;This table will keep track of Host Indexes and Address of incompatible
  ;  Devices that we find.
  ;If we don't keep track of them, we will get caught in an endless
  ;  loop of looking at the bad one every time we check (if it happens
  ;  to be the first one), and will never skip over it and be
  ;  able to find a "good" (compatible) Device.
  ;----------------------------------------------------------------------------
  EVEN 2
  BadDeviceTable:
    DB (MaxBadDevices*BadDeviceStrucSize) DUP (0)

  ;----------------------------------------------------------------------------
  ;Offset in InfoTable of Last Device we found (needed to print Descriptors)
  ;----------------------------------------------------------------------------
  LastDeviceFound DW ?

  ;----------------------------------------------------------------------------
  ;Stage & Error Code where New Device search failed (for troubleshooting)
  ;For even stages < 200, the Error is a TD Status Error Code.
  ;  These are the ones generally caused by Devices that don't respond
  ;  like they're expected to.
  ;For odd stages < 200, the Error is an INT 14h Call Error Code.
  ;  These are generally cause by faulty code, and should not appear
  ;  in final, bug-less release of the program.
  ;For stages >= 200, the "Error" is not related to an INT 14h or TD at all.
  ;  These are other kinds of Errors, usually caused by a value in one
  ;    of the Descriptors that we don't undertand how to handle.  The
  ;    "Error Code" in these instances is usually meaningless.
  ;Categorizing the Error Codes like this allows us to easily write a more
  ;  complete and meaningful description of the Bad Device Error.  It is
  ;  still necessary to look at the source code to REALLY figure out what's
  ;  going on, but the information provided is better than just writing
  ;  the raw Error Code numbers.
  ;----------------------------------------------------------------------------
  NewDeviceStage DB ?
  NewDeviceError DW ?

  ;----------------------------------------------------------------------------
  ;Data Structures needed to issue Requests to the USB Host
  ;----------------------------------------------------------------------------
  EVEN 2
  Int14Request:
    DB Int14RequestSize DUP (0)
  Int14Request2:
    DB Int14RequestSize DUP (0)

  ;----------------------------------------------------------------------------
  ;Storage Area for Data returned by USB Descriptors and Reports
  ;----------------------------------------------------------------------------
  DvcDescrData:
    DB DeviceDescriptorSize DUP (?) ;Device Descriptor Data
  DescriptorData:
    DB MaxDescriptorSize    DUP (?) ;Actual Descriptor Data


;==============================================================================
;USB Mass-Storage-Specific Control Requests
;==============================================================================
  EVEN 2

  ;----------------------------------------------------------------------------
  ;Reset Bulk-Only Device
  ;  Device maintains current Stall and DataX bits status after the Reset.
  ;  What exactly does this Reset, then?
  ;----------------------------------------------------------------------------
  ResetBulkDeviceReq:
    DB SRRTOut+SRRTTypeClass+SRRTRecipInterface
    DB SRRQResetBulkDvc
    DW 0
    DB ? ;Interface Number to use
    DB 0
    DW 0

  I14RResetBulkDvcIntf EQU I14RSetupReqData.SRIndex ;Byte

  ;----------------------------------------------------------------------------
  ;Get Maximum Logical Unit Number from Bulk-Only Device
  ;----------------------------------------------------------------------------
  GetMaxLUNReq:
    DB SRRTIn+SRRTTypeClass+SRRTRecipInterface
    DB SRRQGetMaxLUN
    DW 0
    DB ? ;Interface Number to use
    DB 0
    DW 1

  I14RGetMaxLUNIntf EQU I14RSetupReqData.SRIndex ;Byte

  ;----------------------------------------------------------------------------
  ;Send ADSC (Accept Device-Specific Command) Request (to a CBI Device)
  ;----------------------------------------------------------------------------
  SendADSCReq:
    DB SRRTOut+SRRTTypeClass+SRRTRecipInterface
    DB SRRQADSC
    DW 0
    DB ? ;Interface Number to use
    DB 0
    DW 0Ch ;Request Size - always 12

  I14RSendADSCIntf EQU I14RSetupReqData.SRIndex  ;Byte
  I14RSendADSCSize EQU I14RSetupReqData.SRLength ;Word

  ;----------------------------------------------------------------------------
  ;Clear EndPoint Feature HALT
  ;----------------------------------------------------------------------------
  ClearEndPtHaltReq:
    DB SRRTOut+SRRTTypeStandard+SRRTRecipEndPoint
    DB SRRQClearFeature
    DB 0 ;Feature 0 = End Point Halt
    DB 0
    DB ? ;EndPoint number to Clear Feature of
    DB 0
    DW 0

  I14RClearEndPtHaltEP  EQU I14RSetupReqData.SRIndex ;Byte


;==============================================================================
;USB General-Purpose Control Requests
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Get Device Descriptor
  ;----------------------------------------------------------------------------
  GetDvcDescrReq:
    DB SRRTIn+SRRTTypeStandard+SRRTRecipDevice
    DB SRRQGetDescriptor
    DB 0
    DB DescrTypeDevice
    DW 0
    DW DeviceDescriptorSize

  ;----------------------------------------------------------------------------
  ;Get Configuration Descriptor
  ;----------------------------------------------------------------------------
  GetCfgDescrReq:
    DB SRRTIn+SRRTTypeStandard+SRRTRecipDevice
    DB SRRQGetDescriptor
    DB 0 ;Configuration Value to Get (always 0?)
    DB DescrTypeConfig
    DW 0
    DW ConfigDescriptorSize ;Size will change for a Complete Config

  I14RGetCfgDescrValue EQU I14RSetupReqData.SRValue[0] ;Byte
  I14RGetCfgDescrSize  EQU I14RSetupReqData.SRLength   ;Word

  ;----------------------------------------------------------------------------
  ;Set Alternate Interface
  ;----------------------------------------------------------------------------
  SetAltIntfReq:
    DB SRRTOut+SRRTTypeStandard+SRRTRecipInterface
    DB SRRQSetAltInterface
    DB ? ;Alternate Value to set Interface to
    DB 0
    DB ? ;Interface to Set
    DB 0
    DW 0

  I14RSetAltIntfAltIntf EQU I14RSetupReqData.SRValue[0] ; Byte
  I14RSetAltIntfIntf    EQU I14RSetupReqData.SRIndex[0] ; Byte


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;TSR CODE
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO HANDLE INT 2Fh (TSR Multiplex)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HAVE INTERRUPT 2Fh RUN THIS PROGRAM EVERY TIME IT OCCURS
;Inputs:  CS = TSR Data Area
;         AH = Function (Handle) number, C0h-FFh
;         AL = Subfunction number
;         (If MuxGetProgName): DI = 0
;Outputs: (AL = MuxInstallChk):  AL = FFh if installed
;         (AL = MuxGetProgName): ES:[DI] = Pointer to ProgName
;         (AL = MuxGetProgVer):  AX = ProgVer (Program version number, AH=Major)
;         (AL = MuxGetAuthor):   ES:[DI] = Pointer to Author
;Changes:
;------------------------------------------------------------------------------
Int2FHdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int2F:
  STI                               ;Enable Interrupts
  CMP  AH,CS:HandleNum              ;Is this our handle?
  JE   Int2FInstall                 ;If so, jump to handle it
  CMP  W CS:Int2FHdr.OldVector[2],0 ;Is the Old Vector valid?
  JE   Int2FDone                    ;If not, handle it
  JMP  D CS:Int2FHdr.OldVector      ;If so, go to the next one in the chain
Int2FDone:                          ;Invalid vector before us
  IRET

Int2FInstall:
  CMP  AL,MuxInstallChk ;Is it Install Check?
  JNZ  Int2FProgName    ;If not, try the next possibility
  MOV  AL,-1            ;Mark the flag byte
  IRET

Int2FProgName:
  CMP  AL,MuxGetProgName ;Is it Get Program Name?
  JNE  Int2FProgVer      ;If not, try the next possibility
  OR   DI,DI             ;Does DI = 0?
  JNZ >N90               ;If not, it's not for us
  MOV  ES,CS             ;If so, point ES:[DI]
  MOV  DI,ProgName       ;  at ProgName
N90:                     ;Done
  IRET

Int2FProgVer:
  CMP  AL,MuxGetProgVer ;Is it Get Program Version?
  JNE  Int2FAuthor      ;If not, try the next one
  MOV  AX,CS:ProgVer    ;If so, do it
  IRET

Int2FAuthor:
  CMP  AL,MuxGetAuthor ;Is it Get Author?
  JNE >A90             ;If not, we're done
  MOV  ES,CS           ;If so, point ES:[DI]
  MOV  DI,Author       ;  at Author
A90:                   ;Done
  IRET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS DEVICE DRIVERS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PERFORM THE DEVICE STRATEGY ROUTINE CALL FROM DOS
;Inputs:  CS = TSR Data Area
;         ES:[BX] = Location of Request Header
;Outputs: Stores Address DvcDrvReqOffset
;Changes:
;NOTES: This is called by DOS, not by our program.  It needs to end in a RETF.
;------------------------------------------------------------------------------
DvcStrategy:
  MOV  W CS:DvcDrvReqOffset[2],ES ;Store the
  MOV  W CS:DvcDrvReqOffset[0],BX ;  Request Pointer
  RETF

;------------------------------------------------------------------------------
;PERFORM THE DEVICE INETERRUPT ROUTINE CALL FROM DOS
;Inputs:  CS = TSR Data Area
;         DvcDrvReqOffset filled in by previous Strategy Call
;Outputs: Performs Function as Requested
;         Returns Status in Request Buffer as appropriate
;Changes:
;NOTES: This is called by DOS, not by our program.  It needs to end in a RETF.
;       We do not diligently test the RHLength Field of the Input Request to
;         to make sure it is valid for each specific call.  We simply verify
;         that it is big enough to hold the Header common to all Requests,
;         and return an error if it is not at least that big.  Most sample
;         code I've seen doesn't even bother to check the length field
;         at all, so we should be OK.  These calls always come directly from
;         DOS anyway, so I don't think we should have any issues.
;------------------------------------------------------------------------------
DvcInterrupt:
  PUSHF                     ;Save flags
  STI                       ;Enable interrupts
  CLD                       ;Go forward with string functions
  PUSH AX,BX,CX,DI,SI,BP    ;Save used registers
  PUSH DS,ES                ;Save used registers
  MOV  DS,CS                ;Point DS at Local Data Area
  LES  DI,DvcDrvReqOffset   ;Point ES:[DI] at the Request Header
  MOV  ES:[DI].RHStatus,0   ;Initialize Return Status to 0
  CMP  ES:[DI].RHLength,RHSize ;Is the Header Length legitimate?
  JB  >I70                  ;If not, Error
  MOV  CL,ES:[DI].RHUnit    ;CL = Unit Number
  CMP  CL,B NumDrives[0]    ;Valid Unit Number?
  JAE >I71                  ;If not, error
  CALL DrvIndex2OffsetSI    ;[SI] = Drive Info Entry
  TEST [SI].DrvFlags,DrvFlagReady ;Drive configured & Ready?
  JZ  >I72                  ;If not, Error
  MOV  AL,ES:[DI].RHCommand ;Get the Command Byte
  MOV  BX,DvcIntTable       ;Point [BX] at the Code Offset Lookup Table
  CALL SearchByte2WordTblDS ;Search for a match
  JC  >I73                  ;If no match, Error
  MOV  BP,[SI].DrvDskOffset ;[BX] = Disk Info Entry
  XCHG BX,BP                ;  [BP] = Code to Call
  CALL BP                   ;Perform the Code
  JMP >I80                  ;Done
I70:                        ;Bad Request Header Length
  OR   B ES:[DI].RHStatus[0],RHSBadRHLength ;Error = Bad Header length
  JMP >I75                  ;Done
I71:                        ;Bad Unit Number
  OR   B ES:[DI].RHStatus[0],RHSUnknownUnit ;Error = Unknown Unit
  JMP >I75                  ;Done
I72:                        ;Device Not Ready/Not Installed Yet
  OR   B ES:[DI].RHStatus[0],RHSDvcNotReady ;Error = Device Not Ready
  JMP >I75                  ;Done
I73:                        ;Illegal/Unknown/Unsupported Command
  OR   B ES:[DI].RHStatus[0],RHSUnknownCmd ;Error = Unknown command
;  JMP >I75                  ;Done
I75:                        ;Error
  OR   B ES:[DI].RHStatus[1],(RHSError SHR 8) ;Mark as an Error
I80:                        ;Done processing the Request
  OR   B ES:[DI].RHStatus[1],(RHSDone SHR 8) ;Mark request as Done
I90:                        ;Done
  POP  ES,DS                ;Restore used registers
  POP  BP,SI,DI,CX,BX,AX    ;Restore used registers
  POPF                      ;Restore flags
  RETF

;------------------------------------------------------------------------------
;PERFORM THE MEDIA CHECK FUNCTION CALL TO OUR DEVICE DRIVER
;Inputs:  CS = DS  = TSR Data Area
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;         ES:[DI] = Device Driver Request Header
;         ES:[DI].RHStatus = 0
;Outputs: Performs Function as Requested by DOS
;         Updates Request Header data as appropriate
;           (Everything except Done flag)
;NOTES: The sole purpose of this call is to determine if the Media has
;         changed or not.  On floppies (where both the USB Device and the
;         media are removable), this cannot be determined.  On "straight"
;         USB Devices, we can easily tell whether it's been disconnected
;         and reinserted or not.
;------------------------------------------------------------------------------
DvcIntMediaCheck:
  PUSH AX                                   ;Save used registers
  CALL ReserveSectorBuff                    ;Reserve Resources
  CMP  [BX].DskAccessTimer,-1               ;Removable Media?
  JE  >M20                                  ;If not, no need for Ready Check
  CALL WaitForDrvSI                         ;Wait for Media
  JC  >M70                                  ;If none, error
M20:                                        ;Drive is Ready
  MOV  ES:[DI].RHMediaOutChangeCode,MediaChangeYes ;Assume changed
  TEST [BX].DskFlags,DskFlagAccessed        ;Has the Drive been accessed?
  JZ  >M80                                  ;If not, it's changed
  CMP  [BX].DskAccessTimer,-1               ;Removable Media?
  JE  >M40                                  ;If not, it hasn't changed
M30:                                        ;Removable Media
  MOV  ES:[DI].RHMediaOutChangeCode,MediaChangeUnknown ;Assume Unknown
  CMP  [BX].DskAccessTimer,0                ;Do we know if it's changed?
  JE  >M80                                  ;If not, we're done
M40:                                        ;Media has not changed
  MOV  ES:[DI].RHMediaOutChangeCode,MediaChangeNo ;Mark as not changed
  JMP >M80                                  ;Done
M70:
  OR   ES:[DI].RHStatus,(RHSError+RHSDvcNotReady) ;Set the Error Code
  JMP >M90                                  ;Done
M80:                                        ;Done - Device has Media
  CALL GetVolumeNameSI                      ;Download the Volume Name
  MOV  W ES:[DI].RHMediaOutVolNamePtr[2],DS ;Store the
  LEA  AX,[SI].DrvVolumeName                ;  Volume Name
  MOV  W ES:[DI].RHMediaOutVolNamePtr[0],AX ;  Pointer
M90:                                        ;Done
  CALL ReleaseSectorBuff                    ;Release Resources
  POP  AX                                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PERFORM THE GET/SET LOGICAL DEVICE FUNCTION CALLS TO OUR DEVICE DRIVER
;Inputs:  CS = DS  = TSR Data Area
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;         ES:[DI] = Device Driver Request Header
;         ES:[DI].RHStatus = 0
;Outputs: Performs Function as Requested by DOS
;         Updates Request Header data as appropriate
;           (Everything except Done flag)
;NOTES: We don't actually support Logical Devices, so any attempts to
;         set the Logical Device to anything other than what it already
;         is will fail.
;------------------------------------------------------------------------------
DvcIntGetLogicalDvc:
DvcIntSetLogicalDvc:
  MOV  ES:[DI].RHUnit,0 ;Only one Logical Drive Assigned
  RET

;------------------------------------------------------------------------------
;PERFORM THE OPEN/CLOSE/REMOVABLE MEDIA FUNCTION CALLS TO OUR DEVICE DRIVER
;Inputs:  CS = DS  = TSR Data Area
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;         ES:[DI] = Device Driver Request Header
;         ES:[DI].RHStatus = 0
;Outputs: Performs Function as Requested by DOS
;         Updates Request Header data as appropriate
;           (Everything except Done flag)
;NOTES: The Open and Close functions do not actually do anything - they are
;         simply for compatibility.
;       The purpose of Open/Close is to inform the Device Driver (and
;         consequently the BIOS for a "normal" drive) when a File has been
;         opened or closed.  However, if a program uses FCB's to access the
;         files, rather than DOS functions, this mechanism is bypassed.
;       The normal response to this call is to increment a counter on
;         opens and decrement it on closes.  When the count becomes 0,
;         internal buffers are flushed.  We don't use any buffers, so we
;         don't need to do anything with Opens and Closes.
;
;       The response to the Removable Media Request is to set the Busy bit
;         in RHStatus if the Device/Media is non-removable, and leave it
;         clear if the Device/Media is removable.  All USB Devices are
;         Removable, and the busy bit is clear when this function is
;         called, so we don't need to do anything.
;------------------------------------------------------------------------------
DvcIntOpen:
DvcIntClose:
DvcIntRemovable:
  RET

;------------------------------------------------------------------------------
;PERFORM THE BUILD BIOS PARAMETER BLOCK FUNCTION CALL TO OUR DEVICE DRIVER
;Inputs:  CS = DS  = TSR Data Area
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;         ES:[DI] = Device Driver Request Header
;         ES:[DI].RHStatus = 0
;         CLD already issued
;Outputs: Performs Function as Requested by DOS
;         Updates Request Header data as appropriate
;           (Everything except Done flag)
;NOTES: We assume that the first thing DOS does to a "new" disk is this
;         function, so this will be the only place we set the Accessed bit.
;------------------------------------------------------------------------------

;Change this to call GetBootSectorFG?

DvcIntBuildBPB:
  PUSH EAX,CX,BP                      ;Save used registers
  CALL ReserveSectorBuff              ;Reserve the Sector Buffer
  MOV  AL,ES:[DI].RHRdWrInMediaID     ;Does the
  CMP  AL,[SI].DrvDPB.DPBMediaID      ;  Media ID match?
  JE  >B20                            ;If so, continue
  OR   B ES:[DI].RHStatus[0],RHSUnknownMedia ;If not, set return error code
  JMP >B70                            ;Done
B20:                                  ;Correct Media ID
  LEA  BP,[SI].DrvBPB                 ;[AX] = Where to store the BPB
  TEST [SI].DrvFlags,DrvFlagLocalBPB  ;Do we need to download the Media BPB?
  JNZ >B40                            ;If not, use the one we have stored
  CALL WaitForDrvSI                   ;Wait for Media
  JNC >B25                            ;If it's Ready, continue
  OR   B ES:[DI].RHStatus[0],RHSDvcNotReady ;If not, set return error code
  JMP >B70                            ;Done
B25:                                  ;Drive is Ready
  MOV  EAX,[SI].DrvBootSector         ;EAX = Sector where BPB is stored
  MOV  CX,1                           ;Read 1 Sector
  PUSH DI,ES                          ;Save used registers
  MOV  ES,DS                          ;ES:[DI] =
  MOV  DI,SectorBuff                  ;  Our Sector Buffer
  CALL SCSIReadFG                     ;Read the Sector
  MOV  LBAInBuffer,EAX                ;Store Sector Number that's in the Buffer
  POP  ES,DI                          ;Restore used registers
  JC  >B50                            ;If error, handle it
B30:                                  ;No Error
  PUSH DI,SI,ES                       ;Save used registers
  MOV  ES,DS                          ;ES:[DI] =
  MOV  DI,BP                          ;  where to store the BPB data
  MOV  SI,(SectorBuff+11)             ;DS:[SI] = BPB from Boot Sector
  MOV  CX,BPBFAT32Size                ;CX = Number of Bytes to Copy
  REP  MOVSB                          ;Copy the BPB
  POP  ES,SI,DI                       ;Restore used registers
B40:                                  ;DS:[BP] contains BPB
  MOV  W ES:[DI].RHBPBOutBPBPtr[2],DS ;Store the BPB Buffer Address
  MOV  W ES:[DI].RHBPBOutBPBPtr[0],BP ;  for the return
  CALL SetAccessedBX                  ;Mark Drive as Recently Accessed
  JMP >B90                            ;Done
B50:                                  ;Error Reading Sector
  OR   B ES:[DI].RHStatus[0],RHSReadFault ;Set Error Code

;Need more definitive Error Decoding here?

B70:                                  ;Error
  OR   B ES:[DI].RHStatus[1],(RHSError SHR 8) ;Set the Error bit
B90:                                  ;Done
  CALL ReleaseSectorBuff              ;Mark us as done with the Buffer
  POP  BP,CX,EAX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PERFORM THE READ, WRITE, OR WRITE/VERIFY FUNCTION CALL TO OUR DEVICE DRIVER
;Inputs:  CS = DS  = TSR Data Area
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;         ES:[DI] = Device Driver Request Header
;         ES:[DI].RHStatus = 0
;Outputs: Performs Function as Requested by DOS
;         Updates Request Header data as appropriate
;           (Everything except Done flag)
;Changes:
;NOTES: We always return the Volume ID Pointer in the Return Status, even
;         though we are only required to do it if there is an Invalid Media
;         Change Error.
;------------------------------------------------------------------------------

;Change WriteVerify to separate Write, Verify
;Do same w/ INT 13, 25, 26, 21h Functions
;Also check WriteProtect with other functions!

DvcIntRead:
  PUSH BP                                 ;Save used registers
  MOV  BP,SCSIReadFG                      ;[BP] = Code to Call
  JMP >V00                                ;Do it
DvcIntWrite:
  PUSH BP                                 ;Save used registers
  MOV  BP,SCSIWriteFG                     ;[BP] = Code to Call
  JMP >V00                                ;Do it
DvcIntWriteVerify:
  PUSH BP                                 ;Save used registers
  MOV  BP,SCSIWriteVerifyFG               ;[BP] = Code to Call
;  JMP >V00                                ;Do it
V00:
  PUSH EAX,CX,DI                          ;Save used registers
  CALL ReserveSectorBuff                  ;Reserve Resources
  MOV  AL,ES:[DI].RHRdWrInMediaID         ;Does the
  CMP  AL,[SI].DrvDPB.DPBMediaID          ;  Media ID match?
  JE  >V10                                ;If so, continue
  OR   B ES:[DI].RHStatus[0],RHSUnknownMedia ;If not, set return error code
  JMP >V70                                ;Done
V10:                                      ;Correct Media ID
  CMP  BP,SCSIWriteFG                     ;Are we writing?
  JE  >V12                                ;If so, test Write Protection
  CMP  BP,SCSIWriteVerifyFG               ;Are we writing?
  JNE >V15                                ;If not, don't care about WritePtor
V12:                                      ;Need to test Write Protection
  TEST [BX].DskFlags,DskFlagWriteProt     ;If so, is the disk write-protected?
  JZ  >V15                                ;If not, continue
  OR   B ES:[DI].RHStatus[0],RHSWriteProt ;If not, set return error code
  JMP >V70                                ;Done
V15:                                      ;Not write protected
  CALL WaitForDrvSI                       ;Wait for Media
  JNC >V20                                ;If Ready, continue
  OR   B ES:[DI].RHStatus[0],RHSDvcNotReady ;If not, set return error code
  JMP >V70                                ;Done
V20:                                      ;Unit is ready
  XOR  EAX,EAX                            ;Get the 16-bit
  MOV  AX,ES:[DI].RHRdWrInStartSect16     ;  Starting Sector Number
  CMP  AX,-1                              ;Is it a 32-bit Sector Number?
  JNE >V30                                ;If not, continue
V25:                                      ;It's a 32-bit Sector Number
  MOV  EAX,ES:[DI].RHRdWrInStartSect32    ;Get the 32-bit Starting Sector Number
V30:                                      ;EAX = Starting Sector Number (LBA)
  ADD  EAX,[SI].DrvBootSector             ;Compensate for Hidden Sectors
  MOV  CX,ES:[DI].RHRdWrInSectCount       ;CX = Sector Count
  CALL TestDvcIntSectors                  ;Test Sector Numbers for validity
  JNC >V40                                ;If OK, continue
  OR   B ES:[DI].RHStatus[0],RHSSectorNF  ;If not, set return error code
  JMP >V70                                ;Done
V40:                                      ;Everything is OK for the call
  PUSH DI,ES                              ;Save used registers
  LES  DI,ES:[DI].RHRdWrInXferAddr        ;ES:[DI] = Memory Address to use
  CALL BP                                 ;Issue the Request
  POP  ES,DI                              ;Restore used registers
  JC  >V60                                ;If error, jump to handle it
V50:                                      ;No Error
  CALL SetAccessedBX                      ;Mark Drive as Recently Accessed
  JMP >V90                                ;Done
V60:                                      ;Error
  OR   B ES:[DI].RHStatus[0],RHSGeneralFail ;Set Error Code

;Need more definitive Error Decoding here?
;Need to store USB Byte Count in Return Status?
;  (if so, need to Divide by BytesPerSector to get Sectors Transferred)

V70:                                      ;Set Error Bit
  OR  B ES:[DI].RHStatus[1],(RHSError SHR 8) ;Set the Error bit
V90:                                      ;Done
  CALL GetVolumeNameSI                    ;Download the Volume Name
  MOV  W ES:[DI].RHRdWrOutVolumePtr[2],DS ;Store the
  LEA  AX,[SI].DrvVolumeName              ;  Volume Name
  MOV  W ES:[DI].RHRdWrOutVolumePtr[0],AX ;  Pointer
  CALL ReleaseSectorBuff                  ;Release Resources
  POP  DI,CX,EAX                          ;Restore used registers
  POP  BP                                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DOWNLOAD AND COPY THE SERIAL, VOLUME, & FILE SYSTEM FROM A DRIVE
;Inputs:   CS = DS = TSR Data Area
;         [SI] = Drive Info Entry
;         ES:[DI] = Device Interrupt Request Header (if all three)
;         CLD already issued
;Outputs: CF = Clear if OK
;              [SI].DrvVolumeName (if VolumeName only)
;              ES:[DI] = Filled in (if all three)
;              = Set if Error
;Changes:
;------------------------------------------------------------------------------
GetVolumeNameSI:
  PUSH CX               ;Save used registers
  MOV  CL,11            ;Mark as Volume Name
  JMP >N00              ;Do it
GetSerialNumSI:
  PUSH CX               ;Save used registers
  MOV  CL,23            ;Mark as Serial Number, Volume Name, & File System
;  JMP >N00              ;Do it
N00:
  PUSH AX,BX,DI,SI,ES   ;Save used registers
  XOR  CH,CH            ;Convert CL to a Word
  CALL GetBootSectorFG  ;Download the Boot Sector (SectorBuff)
  JC  >N70              ;If error, quit
  MOV  BX,SI            ;[BX] = Drive Info Entry
  CALL GetVolNamePtr    ;Get the Volume Name Pointer ([SI])
  JNC >N30              ;If OK, continue
N20:                    ;FAT12/FAT16 DOS 3-
  MOV  SI,DefVolumeName ;Point at Default Volume Name
N30:                    ;[SI] = Volume Name Pointer
  CMP  CL,11            ;Doing Volume Name or All Three?
  JNE >N50              ;If all three, jump to handle it
N40:                    ;Just doing Volume Name
  MOV  ES,DS                 ;ES:[DI] =
  LEA  DI,[BX].DrvVolumeName ;  where to store data
  JMP >N60              ;Copy the data
N50:                    ;Doing all three
  SUB  SI,4             ;DS:[SI] = Serial Number
N60:                    ;Copy CX bytes from DS:[SI] to ES:[DI]
  REP  MOVSB            ;Copy the data
  JMP >N80              ;Done
N70:                    ;Error
  STC                   ;Set return flag
  JMP >N90              ;Done
N80:                    ;OK
  CLC                   ;Set return flag
N90:                    ;Done
  POP  ES,SI,DI,BX,AX   ;Restore used registers
  POP  CX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE POINTER TO THE VOLUME NAME IN THE BOOT SECTOR
;Inputs:  DS = TSR Data Area
;         SectorBuff filled with Boot Sectgor Data (contains BPB)
;Outputs: CF = Clear if OK (DOS 4+ Boot Sector)
;              [SI] = Volume Name Pointer
;            = Set if Error (DOS 3- Boot Sector)
;              SI = Undefined
;Changes:
;------------------------------------------------------------------------------
GetVolNamePtr:
  PUSH AX                 ;Save used registers
P10:                      ;Test for FAT32
  MOV  SI,SectorBuff+11+(OFFSET BPBXVolumeName) ;Assume FAT32
  CMP  SectorBuff.BPBXSignature[11],29h ;Is it possibly FAT32?
  JNE >P20                ;If not, try next possibility
  CALL TestVolumeName     ;Test the Volume Name for validity
  JNC >P80                ;If OK, we're done
P20:                      ;Test for FAT12/FAT16 DOS 4+
  MOV  SI,SectorBuff+11+(OFFSET BPB4VolumeName) ;Assume FAT12/FAT16 DOS 4+
  MOV  AL,SectorBuff.BPB4Signature[11] ;Get the Signature Byte
  CMP  AL,28h             ;Is it possibly DOS 4+?
  JB  >P70                ;If not, it's DOS 3-
  CMP  AL,29h             ;Is it possibly DOS 4+?
  JA  >P70                ;If not, it's DOS 3-
  CALL TestVolumeName     ;Test the Volume Name for validity
  JNC >P80                ;If OK, we're done
P70:                      ;Error
  STC                     ;Set return flag
  JMP >P90                ;Done
P80:                      ;OK
  CLC                     ;Set return flag
P90:                      ;Done
  POP  AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST A POTENTIAL VOLUME NAME TO SEE IF IT'S VALID
;Inputs:  DS:[SI] = Potential Volume Name
;         CLD = already issued
;Outputs: CF = Clear if OK (appears to be a valid VOLUME NAME)
;            = Set if Error (
;Changes:
;------------------------------------------------------------------------------
TestVolumeName:
  PUSH AX,CX,SI ;Save Pointer
  MOV  CX,11    ;Test 11 bytes
V10:            ;Loop to here for each character
  LODSB         ;Get the next character
  CMP  AL,' '   ;Valid ASCII character?
  JB  >V70      ;If not, invalid string
  CMP  AL,127   ;Valid ASCII character?
  JE  >V70      ;If not, invalid string
  LOOP V10      ;Keep going until we're done
  JMP >V80      ;All characters appear valid
V70:            ;Error
  STC           ;Set return flag
  JMP >V90      ;Done
V80:            ;OK
  CLC           ;Set return flag
V90:            ;Done
  POP  SI,CX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DOWNLOAD THE BOOT SECTOR A DRIVE (PROCESS AS A FOREGROUND REQUEST)
;Inputs:   CS = DS = TSR Data Area
;         [SI] = Drive Info Entry
;         Resources Reserved
;Outputs: CF = Clear if OK
;              SectorBuff filled with Data
;            = Set if Error (problem downloading data)
;Changes:
;------------------------------------------------------------------------------
GetBootSectorFG:
  PUSH EAX,BX,CX,DI,ES        ;Save used registers
  MOV  ES,DS                  ;ES = Local Data Area
  CALL WaitForDrvSI           ;Wait for Media
  JC  >B70                    ;If not Ready, Error
  MOV  EAX,[SI].DrvBootSector ;EAX = Sector where BPB is stored
  MOV  CX,1                   ;Read 1 Sector
  MOV  DI,SectorBuff          ;ES:[DI] = Sector Buffer
  MOV  BX,[SI].DrvDskOffset   ;[BX] = Disk Info Entry
  CALL SCSIReadFG             ;Read the Sector
  MOV  LBAInBuffer,EAX        ;Store the Sector Number stored in the Buffer
  JNC >B80                    ;If it worked, we're done
B70:                          ;Error
  STC                         ;Set return flag
  JMP >B90                    ;Done
B80:                          ;OK
  CLC                         ;Set return flag
B90:                          ;Done
  POP  ES,DI,CX,BX,EAX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST SECTOR NUMBERS IN A DEVICE DRIVER CALL FOR VALIDITY
;Inputs:   DS  = TSR Data Area
;         EAX  = Starting Sector Number for Device Driver Read/Write Call
;          CX  = Sector Count (Number of Sectors to Read/Write)
;         [SI] = Drive Info Entry
;Outputs: CF = Clear if OK (Sector numbers are within the Partition)
;            = Set if Error (Sector Numbers are outside the Partition)
;Changes:
;------------------------------------------------------------------------------
TestDvcIntSectors:
  PUSH EAX,ECX                 ;Save used registers
  AND  ECX,0000_FFFFh          ;Convert Number of Sectors to a DWord
  ADD  EAX,ECX                 ;EAX = Requested Ending Sector Number + 1
  MOV  ECX,[SI].DrvBootSector  ;ECX = Partition Ending
  ADD  ECX,[SI].DrvSectsInPart ;  Sector Number + 1

;Need to add in Hidden Sectors???
;If so, need it in several places!

  CMP  EAX,ECX                 ;Is the Request Sector in the Partition?
  JBE >S80                     ;If so, it's OK
S70:                           ;Error
  STC                          ;Set return flag
  JMP >S90                     ;Done
S80:                           ;OK
  CLC                          ;Set return flag
S90:                           ;Done
  POP  ECX,EAX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WAIT FOR OUR SECTOR BUFFER TO BECOME AVAILABLE, AND THEN RESERVE IT FOR US
;Inputs:  DS = TSR Data Area
;         TSRFlags.SectBuff
;Outputs: TSRFlags.SectBuffInUse
;Changes:
;------------------------------------------------------------------------------
ReserveSectorBuff:
  PUSHF                       ;Save flags
  STI                         ;Enable Interrupts
W10:                          ;Loop to here to wait for the Buffer
  CLI                         ;Disable Interrupts
  TEST TSRFlags,SectBuffInUse ;Is the Buffer available?
  JZ  >W20                    ;If so, continue
  STI                         ;If not, Enable Interrupts
  JMP  W10                    ;Keep waiting
W20:                          ;The Buffer is available
  OR   TSRFlags,SectBuffInUse ;Mark Buffer as in use
  POPF                        ;Restore flags
  RET

;------------------------------------------------------------------------------
;RELEASE OUR RESERVATION OF THE SECTOR BUFFER
;Inputs:  DS = TSR Data Area
;         TSRFlags.SectBuff = Set
;Outputs: TSRFlags.SectBuffInUse = Clear
;Changes:
;NOTES: The reason we perform such a simple task (a single clear bit command)
;         as a subroutine is so that we can preserve flags across the call.
;       This simplifies the calling routine's structure.
;------------------------------------------------------------------------------
ReleaseSectorBuff:
  PUSHF                             ;Save flags
  AND  TSRFlags,(NOT SectBuffInUse) ;Release the Sector Buffer
  POPF                              ;Restore flags
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;GENERIC IOCTL
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;PERFORM A DOS GENERIC IOCTL CHECK DEVICE DRIVER CALL
;Inputs:  CS = DS  = TSR Data Area
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;         ES:[DI] = Device Driver Request Header
;         ES:[DI].RHStatus = 0
;Outputs: Performs Function as Requested by DOS
;         Updates Request Header data as appropriate
;           (Everything except Done flag)
;Changes:
;------------------------------------------------------------------------------
DvcIntIOCtlCheck:
  PUSH AX,BX                    ;Save used registers
  CMP  ES:[DI].RHGenIOCtlCategory,IOCatDisk ;Is it for a FAT12/FAT16 Disk?
  JE  >K10                      ;If so, continue
  CMP  ES:[DI].RHGenIOCtlCategory,IOCatFAT32Disk ;Is it for a FAT32 Disk?
  JNE >K70                      ;If not, Invalid Command
K10:                            ;Valid Category
  MOV  AL,ES:[DI].RHGenIOCtlFunction ;If so, get the Function
  MOV  BX,GenIOCmdTable         ;[BX] = Code Lookup Table
  CALL SearchByte2WordTblDS     ;Search for a match (returns CF, BX)
  JNC >K80                      ;If found, we're done
K70:                            ;Invalid Command
  MOV  ES:[DI].RHGenIOCtlCkAX,1 ;Set AX return value to 1 (DOS will change it)
  OR   ES:[DI].RHStatus,(RHSError+RHSUnknownCmd) ;Mark as Unknown Command
  JMP >K90                      ;Done
K80:                            ;Valid Command
  MOV  ES:[DI].RHGenIOCtlCkAX,0 ;Set AX return value to 0
K90:                            ;Done
  POP  BX,AX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PERFORM A DOS GENERIC IOCTL DEVICE DRIVER CALL
;Inputs:  CS = DS  = TSR Data Area
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;         ES:[DI] = Device Driver Request Header
;         ES:[DI].RHStatus = 0
;Outputs: Performs Function as Requested by DOS
;         Updates Request Header data as appropriate
;           (Everything except Done flag)
;Changes:
;------------------------------------------------------------------------------
DvcIntGenIOCtlV3:
DvcIntGenIOCtlV4:
  PUSH AX,DX                            ;Save used registers
  MOV  AX,W ES:[DI].RHGenIOCtlCategory  ;AL = Function,
  XCHG AL,AH                            ;  AH = Category
  CMP  AH,IOCatDisk                     ;Is it for a FAT12/FAT16 Disk?
  JE  >I10                              ;If so, continue
  CMP  AH,IOCatFAT32Disk                ;Is it for a FAT32 Disk?
  JNE >I75                              ;If not, Invalid Command
I10:                                    ;Valid Category
  MOV  DX,BX                            ;Save Disk Offset
  MOV  BX,GenIOCmdTable                 ;[BX] = Code Offset Lookup Table
  CALL SearchByte2WordTblDS             ;Search for a match
  XCHG BX,DX                            ;[BX] = Disk Info, [DX] = Code Offset
  JC  >I75                              ;If no match, Error
  PUSH DI,ES                            ;Save Request Header Pointer
  LES  DI,ES:[DI].RHGenIOCtlParamBlkPtr ;ES:[DI] = IOCTL Parameter Block
  CALL DX                               ;If found, call the code (rtns CF, AX)
  POP  ES,DI                            ;Restore Request Header Pointer
  JNC >I90                              ;If it worked, we're done
I70:                                    ;Error
  MOV  B ES:[DI].RHStatus[1],(RHSError SHR 8) ;Set error flag
  JMP >I90                              ;Done
I75:                                    ;Invalid Command
  OR   ES:[DI].RHStatus,(RHSError+RHSUnknownCmd) ;Return Invalid Command Error
I90:                                    ;Done
  POP  DX,AX                            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS A GENERIC IOCTL GET DEVICE PARAMETERS CALL (FUNCTION 60h)
;Inputs:  CS = DS  = TSR Data Area
;          AH  = Category (from Request Header, 08h or 48h)
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;         ES:[DI] = Generic IOCTL Parameter Block
;         CLD already issued
;Outputs: CF = Clear if OK (Function worked)
;              AX = Undefined
;            = Set if Error
;              AL = Appropriate Device Driver Error Code
;Changes:
;------------------------------------------------------------------------------
GIOGetDvcParams:
  PUSH CX,DX,DI,SI                      ;Save used registers
  MOV  DL,AH                            ;Save Category in DL
  CALL ReserveSectorBuff                ;Reserve the Sector Buffer
  TEST ES:[DI].GIODPSpecFunc,DPSFGetMediaBPB ;Should we use the Local BPB?
  JNZ >P15                              ;If so, don't download from the Media
P10:                                    ;Download Boot Sector (contains BPB)
  PUSH EAX,DI,ES                        ;Save used registers
  MOV  EAX,[SI].DrvBootSector           ;EAX = Sector to Download (Boot Sector)
  MOV  ES,DS                            ;ES:[DI] =
  MOV  DI,SectorBuff                    ;  Sector Buffer
  MOV  CX,1                             ;Transfer 1 Sector
  CALL SCSIReadFG                       ;Read the Sector
  MOV  LBAInBuffer,EAX                  ;Store the Sector Number
  POP  ES,DI,EAX                        ;Restore used registers
  JC  >P70                              ;If error, quit
P15:                                    ;SectorBuff contains Boot Sector
  MOV  AL,DPDTFixed                     ;Assume Fixed Disk
  CALL TestFloppyDskBX                  ;Is it a Floppy Drive?
  JC  >P20                               ;If not, continue
  MOV  AL,DPDTOther                     ;If so, mark as a 1.44MB Floppy
P20:                                    ;AL = Device Type
  MOV  ES:[DI].GIODPDvcType,AL          ;Store Device Type
  MOV  AX,(DPDAFixed+DPDAChangeSupt)    ;Assume Fixed Disk, Change Line
  CMP  [BX].DskAccessTimer,-1           ;Is it Removable Media?
  JE  >P30                              ;If not, continue
  XOR  AX,AX                            ;If so, Removable Media, No Change Line
P30:                                    ;AX = Device Attributes
  MOV  ES:[DI].GIODPDvcAttribs,AX       ;Store the Device Attributes

  MOV  AX,[BX].DskNumTracks             ;Store the Number
  MOV  ES:[DI].GIODPNumCyls,AX          ;  of Cylinders
  MOV  ES:[DI].GIODPMediaType,DPMTOther ;Store Media Type
P40:                                    ;Copy BPB
  ADD  SI,(OFFSET DrvBPB)               ;Assume we use Local BPB
  TEST ES:[DI].GIODPSpecFunc,DPSFGetMediaBPB ;Should we use the Local BPB?
  JNZ >P42                              ;If so, continue
  MOV  SI,SectorBuff+11                 ;Use the Downloaded BPB
P42:                                    ;DS:[SI] = BPB to copy
  ADD  DI,(OFFSET GIODPBPB)             ;ES:[DI] = Where to copy the data
  MOV  CX,BPBBasicSize                  ;Assume Category = FAT12/FAT16
  CMP  DL,IOCatDisk                     ;Is it FAT12/FAT16?
  JE  >P45                              ;If so, continue
  MOV  CX,BPBFAT32Size                  ;Category = FAT32
P45:                                    ;CX = BPB bytes to copy
  REP  MOVSB                            ;Copy the BPB
;  CMP  DL,IOCatDisk                     ;Category = FAT12/FAT16?
;  JE  >P80                              ;If so, we're done
;  XOR  AX,AX                            ;If not,
;  MOV  CX,16                            ;  fill in the
;  REP  STOSW                            ;  rest of the Parameter Block
  JMP >P80                              ;Done
P70:                                    ;Error
  MOV  AL,RHSDvcNotReady                ;Error Code = Device Not Ready
  STC                                   ;Set Error Flag
  JMP >P90                              ;Done
P80:                                    ;OK
  CLC                                   ;Set return flag
P90:                                    ;Done
  CALL ReleaseSectorBuff                ;Release the Sector Buffer
  POP  SI,DI,DX,CX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS A GENERIC IOCTL SET DEVICE PARAMETERS CALL (FUNCTION 40h)
;Inputs:  CS = DS  = TSR Data Area
;          AH  = Category (from Request Header, 08h or 48h)
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;         ES:[DI] = Generic IOCTL Parameter Block
;         CLD already issued
;Outputs: CF = Clear if OK (Function worked)
;              AX = Undefined
;              Data from Parameter Block copied to appropriate TSR sections
;            = Set if Error
;              AL = Appropriate Device Driver Error Code
;Changes:
;NOTES: The only time this should get called is right before a Format
;         Track Call (to select the appropriate format for a Floppy).
;         We simply store the values obtained (overwriting any previous
;         values), and when the Format Track request is issued we use
;         the values we stored.
;       We don't do a lot of validity checking on the values sent for
;         the Device parameters -- we assume that we we won't get any
;         really off-the-wall or inappropriate values.
;------------------------------------------------------------------------------


;Do more aggressive parameter checks for floppies -- just allow 720k & 1.44M

;If called with DPSVSetDevBPB, mark flag and don't issue LookForNewDrive.
;If called with bit clear, delete existing drives (all of them?) and
;  issue LookForNewDrives.
;This call should only be issued from a Formatting program, so the approach
;  should be OK.


GIOSetDvcParams:
  PUSH ECX                                    ;Save used registers
  CALL ReserveSectorBuff                      ;Reserve Resources
  MOV  ECX,EAX                                ;Save original EAX
  MOV  AL,ES:[DI].GIODPSpecFunc               ;AL = flags
  TEST AL,DPSFSetTrkLayout                    ;Ignore fields?
  JNZ >M701                                   ;If so, error
  TEST AL,DPSFSetSectSame                     ;All sectors same size?
  JZ  >M701                                   ;If not, error
  TEST AL,DPSFSetDevBPB                       ;Use this BPB in Builds?
  JNZ >M20                                    ;If so, handle it
M10:                                          ;Don't use in BPB Builds
  AND  [SI].DrvFlags,(NOT DrvFlagLocalBPB)    ;Mark as not using in BPB Builds
  JMP >M30                                    ;Continue
M20:                                          ;Use this BPB in Build Requests
  OR   [SI].DrvFlags,DrvFlagLocalBPB          ;Mark as using in BPB Builds
  PUSH CX,DI,SI,DS,ES                         ;Save used registers
  LEA  CX,[SI].DrvBPB                         ;DS:[CX] = Where to store data
  LEA  SI,[DI].GIODPBPB                       ;ES:[SI] = Where to get data from
  MOV  DI,CX                                  ;DS:[DI] = Where to store data
  PUSH DS                                     ;DS:[SI] =
  PUSH ES                                     ;  where to get data from
  POP  DS                                     ;ES:[DI] =
  POP  ES                                     ;  where to store data
  MOV  CX,BPBFAT32Size                        ;CX = Number of Bytes to Copy
  REP  MOVSB                                  ;Copy the BPB
  POP  ES,DS,SI,DI,CX                         ;Restore used registers
  JMP >M30                                    ;Continue
M701:                                         ;To avoid JMP > 128
  JMP >M70                                    ;Error
M30:                                          ;Test CHS validity
  MOV  AX,ES:[DI].GIODPNumCyls                ;Valid
  CMP  AX,[BX].DskNumTracks                   ;  Cylinders?
  JA  >M70                                    ;If not, error
  MOV  AX,W ES:[DI].GIODPBPB.BPBNumHeads      ;Valid
  CMP  AX,[BX].DskNumHeads                    ;  Heads?
  JA  >M70                                    ;If not, error
  MOV  AX,W ES:[DI].GIODPBPB.BPBSectsPerTrack ;Valid
  CMP  AX,[BX].DskSectsPerTrack               ;  Sectors?
  JBE >M40                                    ;If so, continue
  CALL TestFloppyDskBX                        ;Is this a Floppy?
  JC  >M70                                    ;If not, error
  CMP  AX,18                                  ;Valid # of Sectors?
  JNE >M70                                    ;If not, error
M40:                                          ;Store CHS & Total Sectors
  XOR  EAX,EAX                                ;Assume < 32MB
  MOV  AX,W ES:[DI].GIODPBPB.BPBNumSects16    ;Get Total Sectors
  OR   AX,AX                                  ;Is it 0?
  JNZ >M50                                    ;If not, continue
  MOV  EAX,D ES:[DI].GIODPBPB.BPBNumSects32   ;Get Total Sectors
M50:                                          ;EAX = Total Sectors
  MOV  [SI].DrvFmtTotalSects,EAX              ;Store it
  MOV  AX,ES:[DI].GIODPNumCyls                ;Copy the
  MOV  [SI].DrvFmtCyls,AX                     ;  number of Cylinders
  MOV  AX,W ES:[DI].GIODPBPB.BPBNumHeads      ;Copy the
  MOV  [SI].DrvFmtHeads,AX                    ;  number of Heads
  MOV  AX,W ES:[DI].GIODPBPB.BPBSectsPerTrack ;Copy the
  MOV  [SI].DrvFmtSects,AX                    ;  number of Sectors per Track

;  CALL SetInt1ESects                          ;Store it in the INT 1Eh Table
;    (Only if Floppy, maybe not at all)

;  CALL TestFloppyDskBX                        ;Is this a Floppy?
;  JC  >M80                                    ;If not, we're done
;  MOV  AX,SCSIModeSelect144MFG                ;If so, assume 1.44MB
;  CMP  W [SI].DrvFmtTotalSects,2880           ;Is it 1.44MB?
;  JE  >M60                                    ;If so, continue
;  MOV  AX,SCSIModeSelect720kFG                ;If not, assume 720K MB
;M60:                                          ;[AX] = Code to Call
;  CALL AX                                     ;Issue the Mode Select Request
;  JNC >M80                                    ;If it worked, we're done
;  MOV  EAX,ECX                                ;Restore original EAX
;  MOV  AL,RHSUnknownMedia                     ;If not, Error = Unknown Media
;  JMP >M75                                    ;Done

  JMP >M80                                   ;Done
M70:                                          ;Error
  MOV  EAX,ECX                                ;Restore original EAX
  MOV  AL,RHSUnknownCmd                       ;Error = Unknown Command
M75:                                          ;AL = Error Code
  STC                                         ;Set return flag
  JMP >M90                                    ;Done
M80:                                          ;OK
  MOV  EAX,ECX                                ;Restore original EAX
  CLC                                         ;Set return flag
M90:                                          ;Done
  CALL ReleaseSectorBuff                      ;Release Resources
  POP  ECX                                    ;Restore used registers
  RET

;Inputs:  AL = Number of Sectors Per Track

;SetInt1ESects:
;  PUSH BX,DS      ;Save used registers
;  XOR  BX,BX      ;DS:[BX] =
;  MOV  DS,BX      ;  INT 1Eh
;  MOV  BX,(1Eh*4) ;  Vector
;  LDS  BX,[BX]    ;DS:[BX] = INT 1Eh Data Area
;  MOV  [BX].Int1ESectsPerTrack,AL ;Store the Number of Sectors Per Track
;  POP  DS,BX      ;Restore used registers
;  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A DISK IS A FLOPPY (UFI)
;Inputs:   DS = TSR Data Area
;         [BX] = Disk Info Entry
;Outputs: CF = Clear if Drive is a Floppy
;            = Set if not
;Changes:
;------------------------------------------------------------------------------
TestFloppyDskBX:
  PUSH BX                   ;Save used registers
  MOV  BX,[BX].DskDvcOffset ;[BX] = Device Info Offset
  CMP  [BX].DvcIntfSubClass,IntfSubClassUFI ;Is it a Floppy (UFI)?
  JE  >F80                  ;If so, handle it
F70:                        ;Not a Floppy
  STC                       ;Set return flag
  JMP >F90                  ;Done
F80:                        ;Is a Floppy
  CLC                       ;Set return flag
F90:                        ;Done
  POP  BX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS A GENERIC IOCTL READ OR WRITE TRACK CALL (FUNCTIONS 61h & 41h)
;Inputs:  CS = DS  = TSR Data Area
;          AH  = Category (from Request Header, 08h or 48h)
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;         ES:[DI] = Generic IOCTL Parameter Block
;         ES:[DI].RHStatus = 0
;         CLD already issued
;Outputs: CF = Clear if OK (Function worked)
;              AX = Undefined
;            = Set if Error
;              AL = Appropriate Device Driver Error Code
;Changes:
;NOTES: Unlike the BIOS (INT 13h) calls, the Sector Numbers are 0-based,
;         not 1-based.
;------------------------------------------------------------------------------
GIOWriteTrack:
  PUSH BP             ;Save used registers
  MOV  BP,SCSIWriteFG ;[BP] = Code to call
  JMP >K00            ;Do it
GIOReadTrack:
  PUSH BP             ;Save used registers
  MOV  BP,SCSIReadFG  ;[BP] = Code to call
;  JMP >K00            ;Do it
K00:
  PUSH CX,EDX,DI,ES             ;Save used registers
  CALL GetGIOLBA                ;Get the LBA (EDX) & Number of Sectors (CX)
  JC  >K70                      ;If error (invalid LBA), handle it
  MOV  CX,ES:[DI].GIORWNumSects ;CX = Number of Sectors to Transfer
  PUSH EAX                      ;Save used registers
  MOV  EAX,EDX                  ;EAX = Starting LBA
  LES  DI,ES:[DI].GIORWDataAddr ;ES:[DI] = Where to copy data
  CALL BP                       ;Issue the Request
  POP  EAX                      ;Restore used registers
  JNC >K80                      ;If it worked, we're done
  MOV  AL,RHSWriteFault         ;Assume it was a Write
  CMP  BP,SCSIWriteFG           ;Is it a Write?
  JE  >K75                      ;If so, continue
  MOV  AL,RHSReadFault          ;It was a Read
  JMP >K75                      ;Continue
K70:                            ;Sector Not Found Error
  MOV  AL,RHSSectorNF           ;Error = Sector Not Found
K75:                            ;Error
  STC                           ;Set return flag
  JMP >K90                      ;Done
K80:                            ;OK
  CLC                           ;Set return flag
K90:                            ;Done
  POP  ES,DI,EDX,CX             ;Restore used registers
  POP  BP                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS A GENERIC IOCTL VERIFY TRACK CALL (FUNCTION 62h)
;Inputs:  CS = DS  = TSR Data Area
;          AH  = Category (from Request Header, 08h or 48h)
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;         ES:[DI] = Generic IOCTL Parameter Block
;         ES:[DI].RHStatus = 0
;         CLD already issued
;Outputs: CF = Clear if OK (Function worked)
;              AX = Undefined
;            = Set if Error
;              AL = Appropriate Device Driver Error Code
;Changes:
;NOTES: Unlike the BIOS (INT 13h) calles, the Track Number is 0-based,
;         not 1-based.
;       DOS 6.20 FORMAT for a hard drive calls this with Flags bit 1 (02h)
;         set, which according to specs is illegal (I have no idea what it's
;         supposed to mean).
;------------------------------------------------------------------------------
GIOVerifyTrack:
  PUSH CX,EDX                ;Save used registers
V10:                         ;Test flags
  TEST ES:[DI].GIOVfyFlags,GIOVFInMultiple ;Multiple Tracks?
  JZ  >V20                   ;If not, continue
V15:                         ;Invalid flags
  MOV  ES:[DI].GIOVfyFlags,GIOVFOutBadFunc ;Set Parameter Block Flag
  MOV  AL,RHSUnknownCmd      ;Error = Unknown (Illegal) Command
  JMP >V70                   ;Done
V20:                         ;Flags are OK
  CALL GetGIOLBA             ;Get the LBA (EDX) & Number of Sectors (CX)
  JNC >V30                   ;If OK, continue
V25:                         ;Illegal/Bad LBA
  MOV  ES:[DI].GIOVfyFlags,GIOVFOutTracksBad ;Set Parameter Block Flag
  MOV  AL,RHSSectorNF        ;Error = Sector Not Found
  JMP >V70                   ;Done
V30:                         ;LBA OK
  PUSH EAX                   ;Save used registers
  MOV  EAX,EDX               ;EAX = Starting LBA
  CALL SCSIVerifyFG          ;Issue the Request
  POP  EAX                   ;Restore used registers
  JNC >V80                   ;If it worked, we're done
  MOV  ES:[DI].GIOVfyFlags,GIOVFOutTracksBad ;Set Parameter Block Flag
  MOV  AL,RHSReadFault       ;Error = Read Fault
V70:                         ;Sector Not Found Error
  STC                        ;Set return flag
  JMP >V90                   ;Done
V80:                         ;OK
  MOV  ES:[DI].GIOVfyFlags,GIOVFOutTracksOK ;Set Parameter Block Flag
  CLC                        ;Set return flag
V90:                         ;Done
  POP  EDX,CX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS A GENERIC IOCTL FORMAT & VERIFY TRACK CALL (FUNCTION 42h)
;Inputs:  CS = DS  = TSR Data Area
;          AH  = Category (from Request Header, 08h or 48h)
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;         ES:[DI] = Generic IOCTL Parameter Block
;         ES:[DI].RHStatus = 0
;         CLD already issued
;Outputs: CF = Clear if OK (Function worked)
;              AX = Undefined
;            = Set if Error
;              AL = Appropriate Device Driver Error Code
;Changes:
;------------------------------------------------------------------------------
GIOFormatTrack:
  TEST ES:[DI].GIOFmtFlags,GIOFFInMultiple ;Valid flags?
  JZ  >F20                      ;If so, continue
F15:                            ;Invalid flags
  MOV  ES:[DI].GIOFmtFlags,GIOVFOutBadFunc ;Set Parameter Block Flag
  MOV  AL,RHSUnknownCmd         ;Error = Unknown (Illegal) Command
  JMP >F70                      ;Done
F20:                            ;Flags are OK
  MOV  AX,ES:[DI].GIOFmtCylNum  ;Valid
  CMP  AX,[SI].DrvFmtCyls       ;  Cylinder Number?
  JAE >F25                      ;If not, error
  MOV  AX,ES:[DI].GIOFmtHeadNum ;Valid
  CMP  AX,[SI].DrvFmtHeads      ;  Head Number?
  JAE >F25                      ;If not, error
  TEST ES:[DI].GIOFmtFlags,GIOFFInStatus ;Is this just a Test?
  JZ  >F30                      ;If not, do the Format
  JMP >F80                      ;If so, we're done
F25:                            ;Illegal/Bad LBA
  MOV  ES:[DI].GIOVfyFlags,GIOVFOutTracksBad ;Set Parameter Block Flag
  MOV  AL,RHSSectorNF           ;Error = Sector Not Found
  JMP >F70                      ;Done
F30:                            ;Do the Format
  CALL TestFloppyDskBX          ;Is this a Floppy?
  JNC >F40                      ;If so, handle a Floppy
F35:                            ;Format a Hard Drive
  CALL GIOFmtTrkNotFloppy       ;If not, handle a hard drive
  JNC >F80                      ;If it worked, we're done
  JMP >F50                      ;If error, jump to handle it
F40:                            ;Format a Floppy
  CALL GIOFmtTrkFloppy          ;Handle a Floppy
  JNC >F80                      ;If it worked, we're done
F50:                            ;Format Failure
  MOV  ES:[DI].GIOVfyFlags,GIOVFOutNoMedia ;Set Parameter Block Flag
  MOV  AL,RHSGeneralFail        ;Error = General Failure
F70:                            ;Sector Not Found Error
  STC                           ;Set return flag
  JMP >F90                      ;Done
F80:                            ;OK
  MOV  ES:[DI].GIOFmtFlags,GIOFFOutTracksOK ;Set Parameter Block Flag
  CLC                           ;Set return flag
F90:                            ;Done
  RET

;------------------------------------------------------------------------------
;LOW-LEVEL FORMAT A TRACK ON A FLOPPY DRIVE
;Inputs:  ES:[DI] = IOCTL Format Parameter Block
;         Data already verified for errors
;         [SI] = Drive info Entry (Contains DrvFmtXX data)
;         [BX] = Disk Info entry (Contains Sectors per Track)
;Outputs: CF = Clear if OK
;              Track Formatted
;            = Set if Error
;Changes:
;------------------------------------------------------------------------------
GIOFmtTrkFloppy:
  PUSH EAX,CX                         ;Save used registers
  CALL ReserveSectorBuff              ;Wait for and reserve Resources
  CALL ClearSCSIReqBX                 ;Initialize SCSI Request with all zeroes
  MOV  [BX].DskCBW.CBWCmdBlock.SCSIReqCommand,SCmdFormatUnit ;Store Command
  MOV  [BX].DskCBW.CBWCmdBlock.SCSIReqLUNFlags,(SFmtFmtData+SFmtDefFmt) ;Flags
  MOV  AL,B ES:[DI].GIOFmtCylNum                    ;Store the
  MOV  [BX].DskCBW.CBWCmdBlock.SFmtTrackNum,AL      ;  Track (Cylinder) Number
  MOV  CX,12                                        ;Store the
  MOV  B [BX].DskCBW.CBWCmdBlock.SFmtParamLen[1],CL ;  Data Size
  MOV  B FmtDefectList[1],(DefFlgFOV+DefFlgNoCert+DefFlg1Track) ;Flags
  CMP  B ES:[DI].GIOFmtHeadNum,0                    ;Head #0?
  JE  >P20                                          ;If so, continue
  OR   B FmtDefectList[1],DefFlgSide1 ;If not, it's Head #1
P20:                                  ;Head Number Set
  PUSH EAX                            ;Save used registers
  MOV  EAX,[SI].DrvFmtTotalSects      ;Store the
  CALL CvtEndianEAX                   ;  Total Number
  MOV  D FmtDefectList[4],EAX         ;  of Sectors
  POP  EAX                            ;Restore used registers
  MOV  AX,[BX].DskBytesPerSect        ;Store the
  XCHG AL,AH                          ;  Sector
  MOV  W FmtDefectList[10],AX         ;  Size
P30:                                  ;Format Request is Ready to issue
  PUSH DI,ES                          ;Save used registers
  MOV  ES,DS                          ;ES:[DI] =
  MOV  DI,FmtDefectList               ;  data to send
  CALL DoSCSIReqOutFG                 ;Issue the Request
  POP  ES,DI                          ;Restore used registers
  JNZ >P70                            ;If error, handle it
P40:                                  ;Format complete
  CALL GetGIOLBANoSect                ;Get the starting LBA (EAX)
  MOV  CX,[SI].DrvFmtSects            ;CX = Number of Sectors to Verify
  CALL SCSIVerifyFG                   ;Verify the Sectors
  JNC >P80                            ;If it worked, we're done
P70:                                  ;Error
  STC                                 ;Set return flag
  JMP >P90                            ;Done
P80:                                  ;OK
  CLC                                 ;Set return flag
P90:                                  ;Done
  CALL ReleaseSectorBuff              ;Release Resources
  POP  CX,EAX                         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HIGH-LEVEL FORMAT A TRACK ON A NON-FLOPPY DRIVE
;Inputs:  ES:[DI] = IOCTL Format Parameter Block
;         Data already verified for errors
;         [SI] = Drive info Entry (Contains DrvFmtXX data)
;         [BX] = Disk Info entry (Contains Sectors per Track)
;         FormatFillByte
;         CLD already issued
;Outputs: CF = Clear if OK
;              All Sectors in Track filled with FormatFillByte
;            = Set if Error
;Changes:
;------------------------------------------------------------------------------


;Writes zeroes to LBA 0, not FillByte!
;If not, even Ranish can't read it!
;Command-line option to write zeroes to Sector 0?


GIOFmtTrkNotFloppy:
  PUSH EAX,CX,DX,DI,ES     ;Save used registers
  CALL ReserveSectorBuff   ;Wait for and reserve Resources
  CALL GetGIOLBANoSect     ;Get the starting LBA (EAX)
  MOV  ES,DS               ;ES:[DI] =
  MOV  DI,SectorBuff       ;  Sector Buffer
  MOV  CX,MaxBytesPerSect  ;CX = Number of
  SHR  CX,1                ;  Words to Write
  PUSH AX,DI               ;Save used registers
  MOV  AL,FormatFillByte   ;AL = AH =
  MOV  AH,AL               ;  byte to write
  REP  STOSW               ;Fill the Buffer
  POP  DI,AX               ;Restore used registers
  MOV  DX,[SI].DrvFmtSects ;DX = Total Number of Sectors to write
  MOV  CX,1                ;Write 1 Sector at a time
N30:                       ;Loop to here for each Sector
  PUSH BX                  ;Save used registers
  MOV  BX,SI               ;[BX] = Drive Info Entry
  CALL TestSectInPartBX    ;Is the Sector past the end of the partition?
  POP  BX                  ;Restore used registers
  JC  >N70                 ;If not in Partition, Error
  CALL SCSIWriteFG         ;Write the Sector
  MOV  LBAInBuffer,EAX     ;Store the Sector Number
  JC  >N70                 ;If error, we're done
  CALL SCSIVerifyFG        ;Verify the Sector
  JC  >N70                 ;If error, we're done
  INC  EAX                 ;Increment the LBA
  DEC  DX                  ;Decrement the Loop Counter
  JNZ  N30                 ;If not 0 yet, keep writing
  JMP >N80                 ;Done
N70:                       ;Error
  STC                      ;Set return flag
  JMP >N90                 ;Done
N80:                       ;OK
  CLC                      ;Set return flag
N90:                       ;Done
  CALL ReleaseSectorBuff   ;Release Resources
  POP  ES,DI,DX,CX,EAX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS A GENERIC IOCTL GET VOLUME SERIAL NUMBER CALL (FUNCTION 66h)
;Inputs:  CS = DS  = TSR Data Area
;          AH  = Category (from Request Header, 08h or 48h)
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;         ES:[DI] = Generic IOCTL Parameter Block
;         ES:[DI].RHStatus = 0
;         CLD already issued
;Outputs: CF = Clear if OK (Function worked)
;              AX = Undefined
;            = Set if Error
;              AL = Appropriate Device Driver Error Code
;Changes:
;------------------------------------------------------------------------------
GIOGetVolSerNum:
  PUSH CX,DI,SI          ;Save used registers
  CALL ReserveSectorBuff ;Reserve Resources
  XOR  AX,AX             ;Info Level
  STOSW                  ;  = 0
  CALL GetSerialNumSI    ;Download & copy the Serial Number
  JNC >S90               ;If it worked, we're done
S70:                     ;Error
  MOV  AL,RHSDvcNotReady ;Error = Not Ready
  STC                    ;Set return flag
S80:                     ;OK
  CLC                    ;Set return flag
S90:                     ;Done
  CALL ReleaseSectorBuff ;Release Resources
  POP  SI,DI,CX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS A GENERIC IOCTL SET VOLUME SERIAL NUMBER CALL (FUNCTION 46h)
;Inputs:  CS = DS  = TSR Data Area
;          AH  = Category (from Request Header, 08h or 48h)
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;         ES:[DI] = Generic IOCTL Parameter Block
;         ES:[DI].RHStatus = 0
;         CLD already issued
;Outputs: CF = Clear if OK (Function worked)
;              AX = Undefined
;            = Set if Error
;              AL = Appropriate Device Driver Error Code
;Changes:
;------------------------------------------------------------------------------
GIOSetVolSerNum:
  PUSH CX,DI,SI,BP,ES            ;Save used registers
  CALL ReserveSectorBuff         ;Reserve Resources
  MOV  BP,SI                     ;[BP] = Drive Info entry
  CALL GetBootSectorFG           ;Download the Boot Sector (SectorBuff)
  JC  >M70                       ;If error, quit
  CALL GetVolNamePtr             ;Get the Volume Name Pointer ([SI])
  JC  >M80                       ;If not DOS 4+ Format, just quit
  SUB  SI,4                      ;[SI] = Serial Number
  ADD  DI,(OFFSET GIOSerSerNum)  ;DS:[SI] =
  XCHG DI,SI                     ;  Copy
  PUSH DS                        ;  From
  PUSH ES                        ;ES:[DI] =
  POP  DS                        ;  Copy
  POP  ES                        ;  To
  MOV  CX,23                     ;Copy 23 bytes
  REP  MOVSB                     ;Do it
  MOV  DS,CS                     ;DS = Local Data Area
  MOV  EAX,DS:[BP].DrvBootSector ;EAX = Boot Sector LBA
  MOV  CX,1                      ;Write 1 Sector
  MOV  DI,SectorBuff             ;ES:[DI] = Data to Transfer
                                 ;DS:[BX] = Disk Info Entry
  CALL SCSIWriteFG               ;Write the Sector
  MOV  LBAInBuffer,EAX           ;Store the Sector Number
  JNC >M80                       ;If it worked, we're done
M70:                             ;Error
  MOV  AL,RHSGeneralFail         ;Error = General Failure
  STC                            ;Set return flag
M80:                             ;OK
  CLC                            ;Set return flag
M90:                             ;Done
  CALL ReleaseSectorBuff         ;Release Resources
  POP  ES,BP,SI,DI,CX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS A GENERIC IOCTL GET/SET ACCESS STATUS CALL
;Inputs:  CS = DS  = TSR Data Area
;          AH  = Category (from Request Header, 08h or 48h)
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;         ES:[DI] = Generic IOCTL Parameter Block
;         ES:[DI].RHStatus = 0
;         CLD already issued
;Outputs: CF = Clear if OK (Function worked)
;              AX = Undefined
;            = Set if Error
;              AL = Appropriate Device Driver Error Code
;Changes:
;NOTES: For GetAccess, DOS 7 returns with the flags unchanged, so we will
;         do the same thing.
;------------------------------------------------------------------------------
GIOGetAccess:
  MOV  AL,[SI].DrvGIOAccess       ;Copy the
  MOV  ES:[DI].GIOAccessStatus,AL ;  Access Status
  CLC
  RET

GIOSetAccess:
  MOV  AX,W ES:[DI].GIOAccessFlags ;Get the Flags (AL) & the Value (AH)
  OR   AL,AL                       ;Valid Flags?
  JZ  >A80                         ;If so, handle it
A70:                               ;Error
  MOV  AL,RHSUnknownCmd            ;Error = Unknown Command
  STC                              ;Set Return Flag
  JMP >A90                         ;Done
A80:                               ;OK
  MOV  [SI].DrvGIOAccess,AH        ;Store the New Value
  CLC                              ;Set return flag
A90:                               ;Done
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;SUPPORT CODE FOR DOS DEVICE DRIVER CALLS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;DONVERT A DRIVE INFO INDEX TO A DRIVE INFO OFFSET
;Inputs:   DS  = TSR Data Area
;          CL  = Drive Info Entry Index (0-based)
;Outputs: [SI] = Drive Info Entry associated with the Index
;Changes:
;------------------------------------------------------------------------------
DrvIndex2OffsetSI:
  PUSH AX                 ;Save used registers
  MOV  AL,DriveInfoSize   ;AL = Size of Each Entry
  MUL  CL                 ;AX = Offset from Base
  ADD  AX,DriveInfoOffset ;Add the Base Offset
  MOV  SI,AX              ;Put it in BX for the return
  POP  AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SET THE DRIVE ACCESSED VALUES FOR A DISK INFO ENTRY
;Inputs:   DS  = TSR Data Area
;         [BX] = Disk Info Entry
;         Disk just recently accessed for some reason
;Outputs: [BX].DskFlags.DskFlagAccessed is set
;         [BX].DskAccessTimer is initialized to two seconds
;Changes:
;------------------------------------------------------------------------------
SetAccessedBX:
  OR   [BX].DskFlags,DskFlagAccessed ;Mark as Accessed
  CMP  [BX].DskAccessTimer,-1        ;Is it removable media?
  JE  >A90                           ;If not, we're done
  MOV  [BX].DskAccessTimer,36        ;If so, set the Timer for 2 seconds
A90:                                 ;Done
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LBA FROM A GENERIC IOCTL DESCRIPTOR
;Inputs:  CS = DS  = TSR Data Area
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;         ES:[DI] = Generic IOCTL Parameter Block
;         CLD already issued
;Outputs: CF = Clear if OK (LBA valid)
;              EDX = LBA
;               CX = Number of Sectors in Track (or Left in Track)
;            = Set if Error
;              EDX = Undefined
;               CX = Undefined
;Changes:
;------------------------------------------------------------------------------

;ResetDrvFmtXX values on BuildBPB function?  On R/W Accesses?
;  Copy Defaults to FDksFmtXX on initialization?
;Make sure we reload ALL Disk AND Drive parameters after formatting.
;  Do after verifying last track??
;Check for DrvGIOAccess on all DOS calls, return Invalid Media if 0
;Assign Drive Letters even if not DOS compatible, Set DrvGIOAccess to 0
;  so user can format non-DOS drive

GetGIOLBANoSect:
  MOV  FmtStartSect,0              ;Use Sector 0
  JMP >L00                         ;Do it
GetGIOLBA:
  PUSH AX                          ;Save used registers
  MOV  AX,W ES:[DI].GIORWStartSect ;Use the Sector Number
  MOV  FmtStartSect,AX             ;  from the Parameter Block
  POP  AX                          ;Restore used registers
;  JMP >L00                         ;Do it
L00:
  PUSH EAX,EBP                     ;Save used registers
  XOR  EAX,EAX                     ;Intialize
  XOR  EBP,EBP                     ;  High Words
L10:                               ;Calculate Number of Sectors to Do
  MOV  AX,FmtStartSect             ;AX = Starting Sector Number (0-based)
  MOV  CX,[SI].DrvFmtSects         ;CX = Sectors to Format
  CMP  AX,CX                       ;Is it valid?
  JAE >L70                         ;If not, error
  SUB  CX,AX                       ;CX = Number of Sectors to do
L20:                               ;Calculate LBA
  MOV  AX,ES:[DI].GIORWCylNum      ;Get the Cylinder Number
  CMP  AX,[SI].DrvFmtCyls          ;Is it valid?
  JAE >L70                         ;If not, Error
  MOV  BP,[SI].DrvFmtHeads         ;If OK, multiply by
  MUL  EBP                         ;  Heads per Cylinder
  MOV  BP,ES:[DI].GIORWHeadNum     ;Get the Head Number
  CMP  BP,[SI].DrvFmtHeads         ;Is it valid?
  JAE >L70                         ;If not, Error
  ADD  EAX,EBP                     ;If OK, add it
  MOV  BP,[SI].DrvFmtSects         ;Multiply by
  MUL  EBP                         ;  Sectors Per Track
  MOV  BP,FmtStartSect             ;Add in
  ADD  EAX,EBP                     ;  the Sector Number
  CMP  EAX,[BX].DskMaxLBA          ;Is it too big?
  JA  >L70                         ;If so, error
  MOV  EDX,EAX                     ;Put LBA in EDX for the return
  JMP >L80                         ;If valid, we're done
L70:                               ;Error
  STC                              ;Set return flag
  JMP >L90                         ;Done
L80:                               ;OK
  CLC                              ;Set return flag
L90:                               ;Done
  POP  EBP,EAX                     ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO SEND SCSI REQUESTS TO A USB DEVICE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;INITIALIZE ALL DISK/SCSI-RELATED BUFFERS TO ALL ZEROES
;Inputs:  DS = TSR Data Area
;Outputs: Fills Appropriate Buffers with Zeroes
;Changes:
;------------------------------------------------------------------------------
ClearAllBuffs:
  CALL ClearInquiryBuff     ;Clear Inquiry Buffer
  CALL ClearFmtCapacityBuff ;Clear Format capacity Buffer
  CALL ClearCapacityBuff    ;Clear Capacity Buffer
  CALL ClearModeSenseBuff   ;Clear Mode Sense Buffer
  CALL ClearSectorBuff      ;Clear Sector Buffer
  RET

;------------------------------------------------------------------------------
;INITIALIZE A BUFFER TO ALL ZEROES
;Inputs:  DS = TSR Data Area
;         CLD already issued
;Outputs: Fills Appropriate Buffer with Zeroes
;Changes:
;------------------------------------------------------------------------------
ClearInquiryBuff:
  PUSH CX,DI                      ;Save used registers
  MOV  CX,(SInquiryRespSize/2)    ;CX = Number of Words to write
  MOV  DI,InquiryBuff             ;[DI] = Buffer
  JMP >C00                        ;Do it
ClearFmtCapacityBuff:
  PUSH CX,DI                      ;Save used registers
  MOV  CX,(FmtCapacityRespSize/2) ;CX = Number of Words to write
  MOV  DI,FmtCapacityBuff         ;[DI] = Buffer
  JMP >C00                        ;Do it
ClearCapacityBuff:
  PUSH CX,DI                      ;Save used registers
  MOV  CX,(FormatDescrSize/2)     ;CX = Number of Words to write
  MOV  DI,CapacityBuff            ;[DI] = Buffer
  JMP >C00                        ;Do it
ClearModeSenseBuff:
  PUSH CX,DI                      ;Save used registers
  MOV  CX,(MSenseRespSize/2)      ;CX = Number of Words to write
  MOV  DI,ModeSenseBuff           ;[DI] = Buffer
  JMP >C00                        ;Do it
ClearSectorBuff:
  PUSH CX,DI                      ;Save used registers
  MOV  CX,MaxBytesPerSect         ;CX = Number of
  SHR  CX,1                       ;  Words to Write
  MOV  DI,SectorBuff              ;[DI] = Buffer
;  JMP >C00                        ;Do it
C00:
  PUSH AX,ES                      ;Save used registers
  MOV  ES,DS                      ;ES = TSR Data Area
  XOR  AX,AX                      ;Write Zeroes
  REP  STOSW                      ;Do it
  POP  ES,AX                      ;Restore used registers
  POP  DI,CX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEND A SPECIFIC SCSI REQUEST, PERFORMING AS A BACKGROUND PROCESS
;Inputs:   DS  = TSR Data Area
;         [BX] = Disk Info Entry
;         [DI] = Device Info Entry
;          If ReadSector Call, EAX = LBA Sector Number
;Outputs: Sends SCSI Request
;         CF = Clear if it worked OK
;              Appropriate Buffer cleared, then filled with Data
;            = Set if Error
;Changes:
;NOTES: This simply starts a background SCSI Request Process, but does not
;         follow it through to completion.  The caller is expected to provide
;         a "wrapper" around this that monitors [BX].SCSIReqStage to know
;         when the request has completed.
;       The only SCSI Requests included here are the ones we need during
;         the LookForNewDevice or LookForNewDrive processes.  All other
;         SCSI Request will use the "Wait" Process, since they will be
;         called from Device Driver, INT 13h, or INT 25h/26h Requests,
;         and do not need to run in the background.
;------------------------------------------------------------------------------
SCSIReqSenseBG:
  PUSH CX,BP                  ;Save used registers
  LEA  BP,[BX].DskSenseBuffer ;[BP] = Data Buffer
  CALL ClearSCSIReqBX         ;Initialize SCSI Request with all zeroes
  MOV  CX,SReqSenseRespSize   ;CX = Number of Bytes to Transfer
  MOV  W [BX].DskCBW.CBWCmdBlock.SCSIReqCommand,SCmdRequestSense ;Store Command
  MOV  [BX].DskCBW.CBWCmdBlock.SReqSenseLength,CL ;Store Data Size
  JMP >X000                   ;Do it
SCSIInquiryBG:
  PUSH CX,BP                  ;Save used registers
  CALL ClearInquiryBuff       ;Clear out the Buffer
  MOV  BP,InquiryBuff         ;[BP] = Buffer to use
  CALL ClearSCSIReqBX         ;Initialize SCSI Request with all zeroes
  MOV  CX,SInquiryRespSize    ;CX = Number of Bytes to Transfer
                              ;Many Devices won't accept any size other than 36
  MOV  W [BX].DskCBW.CBWCmdBlock.SCSIReqCommand,SCmdInquiry ;Store Command
  MOV  [BX].DskCBW.CBWCmdBlock.SInquiryLen,CL ;Store Data Size
  JMP >X000                   ;Do it
SCSICapacityBG:
  PUSH CX,BP                  ;Save used registers
  CALL ClearCapacityBuff      ;Clear out the Buffer
  MOV  BP,CapacityBuff        ;[BP] = Buffer to use
  CALL ClearSCSIReqBX         ;Initialize SCSI Request with all zeroes
  MOV  CX,FormatDescrSize     ;CX = Number of Bytes to Transfer
  MOV  W [BX].DskCBW.CBWCmdBlock.SCSIReqCommand,SCmdReadCapacity ;Store Command
  JMP >X000                   ;Do it
SCSIFmtCapacityBG:
  PUSH CX,BP                  ;Save used registers
  CALL ClearFmtCapacityBuff   ;Clear out the Buffer
  MOV  BP,FmtCapacityBuff     ;[BP] = Buffer to use
  CALL ClearSCSIReqBX         ;Initialize SCSI Request with all zeroes
  MOV  CX,FmtCapacityRespSize ;CX = Maximum Number of Bytes to Transfer
  MOV  W [BX].DskCBW.CBWCmdBlock.SCSIReqCommand,SCmdReadFmtCap ;Store Command
  MOV  [BX].DskCBW.CBWCmdBlock.SReadFCapLength[1],CL ;Store Data Size
  OR   [BX].DskFlags,DskFlagShortPktOK ;Short Packets are OK
X000:                         ;To avoid JMP > 128
  JMP >X00                    ;Do it
SCSIReadSectorEAXBG:
  PUSH CX,BP                  ;Save used registers
  CALL ClearSectorBuff        ;Clear out the Buffer
  MOV  BP,SectorBuff          ;[BP] = Buffer to use
  CALL ClearSCSIReqBX         ;Initialize SCSI Request with all zeroes
  MOV  [BX].DskLastSectorRW,EAX ;Store the Sector Number
  MOV  LBAInBuffer,EAX        ;Store the Sector Number
  CALL CvtEndianEAX                             ;Store the
  MOV  D [BX].DskCBW.CBWCmdBlock.SRead10LBA,EAX ;  Sector Number
  CALL CvtEndianEAX           ;Restore original EAX
  MOV  CX,[BX].DskBytesPerSect ;CX = Number of Bytes to Transfer
  MOV  W [BX].DskCBW.CBWCmdBlock.SCSIReqCommand,SCmdRead10 ;Store Command
  MOV  B [BX].DskCBW.CBWCmdBlock.SRead10Length[1],1 ;Store # of Segments
  JMP >X00                    ;Do it
SCSIFlexPageBG:
  PUSH CX,BP                  ;Save used registers
  CALL ClearModeSenseBuff     ;Clear out the Buffer
  MOV  BP,ModeSenseBuff       ;[BP] = Buffer to use
  CALL ClearSCSIReqBX         ;Initialize SCSI Request with all zeroes
  MOV  CX,MSenseRespSize      ;CX = Number of Bytes to Transfer
  MOV  [BX].DskCBW.CBWCmdBlock.SModeSense6Page,(SMSensFlexible+SMSensCurrent)
                              ;Store Page (same location for Mode Sense 6 & 10)
  CMP  [DI].DvcIntfSubClass,IntfSubClassSCSI ;Is it SCSI Transparent?
  JNE >X20                    ;If not, issue Mode Sense 10
X10:                          ;Issue Mode Sense 6
  MOV  W [BX].DskCBW.CBWCmdBlock.SCSIReqCommand,SCmdModeSense06 ;Store Command
  MOV  [BX].DskCBW.CBWCmdBlock.SModeSense6Length,CL ;Store Data Size
  JMP >X30                    ;Continue
X20:                          ;Issue Mode Sense 10
  MOV  W [BX].DskCBW.CBWCmdBlock.SCSIReqCommand,SCmdModeSense10 ;Store Command
  MOV  [BX].DskCBW.CBWCmdBlock.SModeSense10Length[1],CL ;Store Data Size
X30:                          ;Correct Mode Sense values stored
  OR   [BX].DskFlags,DskFlagShortPktOK ;Short Packets are OK
;  JMP >X00                    ;Do it
X00:
  CALL DoSCSIReqInBG          ;Issue the Request
  POP  BP,CX                  ;Restore used registers
  RET

SCSITestReadyBG:
  PUSH CX             ;Save used registers
  CALL ClearSCSIReqBX ;Initialize SCSI Request with all zeroes
  XOR  CX,CX          ;CX = Number of Bytes to Transfer
  MOV  W [BX].DskCBW.CBWCmdBlock.SCSIReqCommand,SCmdTestUnitReady ;Store Command
  CALL DoSCSIReqOutBG ;Issue the Request
  POP  CX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEND A SCSI START/STOP/LOCK/UNLOCK REQUEST, PERFORMING AS A BACKGROUND PROCESS
;Inputs:   DS  = TSR Data Area
;         [BX] = Disk Info Entry
;         [DI] = Device Info Entry
;Outputs: Sends SCSI Request
;         CF = Clear if it worked OK
;            = Set if Error
;Changes:
;NOTES: This simply starts a background SCSI Request Process, but does not
;         follow it through to completion.  The caller is expected to provide
;         a "wrapper" around this that monitors [BX].SCSIReqStage to know
;         when the request has completed.
;       The only SCSI Requests included here are the ones we need during
;         the LookForNewDevice or LookForNewDrive processes.  All other
;         SCSI Request will use the "Wait" Process, since they will be
;         called from Device Driver, INT 13h, or INT 25h/26h Requests,
;         and do not need to run in the background.
;------------------------------------------------------------------------------
SCSILockUnitBG:
  PUSH AX                            ;Save used registers
  MOV  AL,[BX].DskStopTimer          ;Get current Stop/Unlock Timer
  MOV  [BX].DskStopTimer,StopTicks   ;Initialize Stop/Unlock Timer
  CMP  AL,2                          ;Still counting down from previous Request?
  JA  >V99                           ;If so, don't reissue the Request
  TEST [BX].DskFlags2,DskFlagNoLock  ;Should we issue the Request?
  JNZ >V99                           ;If not, we're done
  MOV  AX,((SCmdSetMediaRemoval SHL 8)+SMedRemPrevent) ;AH = Command, AL = Flags
  JMP >V00                           ;Do it
SCSIUnlockUnitBG:
  PUSH AX                            ;Save used registers
  MOV  AX,((SCmdSetMediaRemoval SHL 8)+0) ;AH = Command, AL = Flags
  JMP >V00                           ;Do it
SCSIStartUnitBG:
  PUSH AX                            ;Save used registers
  MOV  AL,[BX].DskStopTimer          ;Get current Stop/Unlock Timer
  MOV  [BX].DskStopTimer,StopTicks   ;Initialize Stop/Unlock Timer
  CMP  AL,2                          ;Still counting down from previous Request?
  JA  >V99                           ;If so, don't reissue the Request
  TEST [BX].DskFlags2,DskFlagNoStart ;Should we issue the Request?
  JNZ >V99                           ;If not, we're done
  MOV  AX,((SCmdStartStop SHL 8)+SStartStopStart) ;AH = Command, AL = Flags
  JMP >V00                           ;Do it
SCSIStopUnitBG:
  PUSH AX                            ;Save used registers
  MOV  AX,((SCmdStartStop SHL 8)+0)  ;AH = Command, AL = Flags
;  JMP >V00                           ;Do it
V00:
  PUSH CX,DX                         ;Save used registers
  CALL ClearSCSIReqBX                ;Initialize SCSI Request with all zeroes
  MOV  [BX].DskCBW.CBWCmdBlock.SCSIReqCommand,AH ;Store Command
  MOV  [BX].DskCBW.CBWCmdBlock.SMedRemFlags,AL   ;Store Flag
  XOR  CX,CX                         ;Data Size = 0 bytes
  CALL DoSCSIReqOutBG                ;Send it (returns AX, DX)
  POP  DX,CX                         ;Restore used registers
  POP  AX                            ;Restore used registers
  RET

V99:      ;Don't issue Request
  POP  AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEND A SCSI WRITE/VERIFY REQUEST, WAIT FOR THE FINISH
;Inputs:    DS  = TSR Data Area
;          EAX  = LBA (Sector Number) to Write to
;          [BX] = Disk Info Entry
;           CX  = Number of Sectors to Write
;         ES:[DI] = Memory Location to Write From
;Outputs: Sends SCSI Request
;         CF = Clear if it worked OK
;            = Set if Error
;              Error Details are stored in appropriate Device Info Entry
;Changes:
;NOTES: There is a "native" SCSI WriteVerify command, which is supposed to
;         do both the Write and Verification processes with a single call.
;         Unfortunately, none of the USB Drives (at least Flash Drives) I've
;         tested support the command.  Therefore, we will need to do two
;         separate calls, a Write and then a separate Verify.  This ends
;         up slowing things down, but what's a fellow to do when the hardware
;         manufacturers are lazy and don't provide all the functionality
;         that they should?
;------------------------------------------------------------------------------
SCSIWriteVerifyFG:
  CALL SCSIWriteFG  ;Do the Write
  JC  >V90          ;If error, quit
  CALL SCSIVerifyFG ;Do the Verify
V90:                ;Done
  RET

;------------------------------------------------------------------------------
;SEND A SCSI READ, VERIFY, OR WRITE REQUEST, WAIT FOR THE FINISH
;Inputs:    DS  = TSR Data Area
;          EAX  = LBA (Sector Number) to Read/Write from
;          [BX] = Disk Info Entry
;           CX  = Number of Sectors to Read/Write
;         ES:[DI] = Memory Location to Read/Write From/To
;Outputs: Sends SCSI Request
;         CF = Clear if it worked OK
;            = Set if Error
;              Error Details are stored in appropriate Device Info Entry
;Changes:
;NOTES: For WriteVerify and Verify, we do not set the Byte-by-Byte comparison
;         flag.  It is not supported by UFI drives anyway, and the simple
;         CRC check will hopefully be good enough for our purposes.  If a
;         Byte-by-Byte comparison is actually required, it can be done
;         at the application level rather than the hardware level.
;       We assume that the total number of Bytes to send (Number of Sectors
;         times Bytes Per Sector) is less than 65536.  It is up to the caller
;         to verify and compensate for this if it isn't.
;------------------------------------------------------------------------------

;Make sure we return proper data transfer size!

SCSIReadFG:
  PUSH EDX                      ;Save used registers
  MOV  DL,SCmdRead10            ;DL = Command to Issue
  JMP >W01                      ;Do it
SCSIVerifyFG:
  PUSH EDX                      ;Save used registers
  MOV  DL,SCmdVerify10          ;DL = Command to Issue
                                ;RelAddr, ByteCk, DPO Flags = 0
  JMP >W00                      ;Do it
SCSIWriteFG:
  PUSH EDX                      ;Save used registers
  MOV  DL,SCmdWrite10           ;DL = Command to Issue
                                ;RelAddr, FUA, DPO Flags = 0
;  JMP >W00                      ;Do it
W00:                            ;Is an Output (Write) Request
  PUSH BP                       ;Save used registers
  MOV  BP,DoSCSIReqOutFG        ;[BP] = Code to Call
  JMP >W000                     ;Do it
W01:                            ;Is an Input (Read) Request
  PUSH BP                       ;Save used registers
  MOV  BP,DoSCSIReqInFG         ;[BP] = Code to Call
;  JMP >W000                     ;Do it
W000:
  PUSH EAX,CX,SI                ;Save used registers
  MOV  SI,CX                    ;SI = Number of Sectors Left to Transfer
  CALL SCSILockUnitFG           ;Prevent Medium Removal
  CALL SCSIStartUnitFG          ;Start Unit
  CALL ClearSCSIReqBX           ;Initialize SCSI Request with all zeroes
  MOV  [BX].DskLastSectorRW,EAX ;Store the Sector Number
  MOV  [BX].DskCBW.CBWCmdBlock.SCSIReqCommand,DL  ;Store the SCSI Command
  CMP  DL,SCmdVerify10          ;Is it a Verify command?
  JNE >W20                      ;If not, handle it
W10:                            ;Is a Verify command
  CALL CvtEndianEAX                               ;Store
  MOV  D [BX].DskCBW.CBWCmdBlock.SRead10LBA,EAX   ;  LBA
  XCHG CL,CH                                      ;Store
  MOV  W [BX].DskCBW.CBWCmdBlock.SRead10Length,CX ;  # of Sectors
  XOR  CX,CX                    ;Transfer 0 bytes
  XOR  SI,SI                    ;Mark as no more to send next time
  JMP >W50                      ;Do it
W20:                            ;Loop to here for each sub-call
  MOV  CX,SI                    ;Assume less than 64 sectors
  CMP  CX,XferSects             ;Should we send all of them at once?
  JBE >W25                      ;If so, continue
  MOV  CX,XferSects             ;If not, just send the max
W25:                            ;CX = Possible Number of Sectors to Transfer
  CALL TestLastLBA              ;Is this a potential issue with the Last LBA?
  JNC >W30                      ;If not, continue
  DEC  CX                       ;If so, don't include the Last LBA
W30:                            ;CX = Number of Sectors to Transfer
  SUB  SI,CX                    ;Subtract it from the Sectors Left Count
  MOV  DX,CX                    ;Save it for later
  CALL CvtEndianEAX                             ;Store
  MOV  D [BX].DskCBW.CBWCmdBlock.SRead10LBA,EAX ;  LBA
  XCHG CL,CH                                      ;Store
  MOV  W [BX].DskCBW.CBWCmdBlock.SRead10Length,CX ;  # of Sectors
  MOV  AX,[BX].DskBytesPerSect  ;Multiply Number of Sectors
  PUSH DX                       ;  Number of Sectors
  MUL  DX                       ;  by Bytes Per Sector
  POP  DX                       ;  (Result in AX)
  MOV  CX,AX                    ;Put Byte Count in CX
W50:                            ;Correct values are stored (CX, ES:[DI])
  CALL BP                       ;If not, issue the Request (Rtns AX = Error Code)
  JNZ >W70                      ;If error, quit
W60:                            ;Success - adjust pointers if needed
  OR   SI,SI                    ;Anything left to send?
  JZ  >W80                      ;If not, we're done
  ADD  DI,CX                    ;Adjust the Data Address
  AND  EDX,0000_FFFFh           ;Convert Number of Sectors Xfered to DWOrd
  MOV  EAX,D [BX].DskCBW.CBWCmdBlock.SRead10LBA ;Adjust
  CALL CvtEndianEAX                             ; the
  ADD  EAX,EDX                                  ;  LBA
  JMP  W20                      ;Keep going until we're done
W70:                            ;Error
  STC                           ;Set return flag
  JMP >W90                      ;Done
W80:                            ;OK
  CLC                           ;Set return flag
W90:                            ;Done
  POP  SI,CX,EAX                ;Restore used registers
  POP  BP                       ;Restore used registers
  POP  EDX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A SECTOR RANGE INCLUDES THE LAST SECTOR (MAX LBA)
;Inputs:  DS:[BX] = Disk Info Entry
;         EAX = Starting LBA
;          CX = Number of Sectors to Transfer
;Outputs:  CF = Clear if OK (Last Sector is not included in Transfer Range,
;                 or Number of Sectors = 1)
;             = Set if Error (Range includes Last Sector and
;                 and Number of Ssectors > 1)
;Changes:
;------------------------------------------------------------------------------
TestLastLBA:
  PUSH ECX                ;Save used registers
  CMP  CX,1               ;Is the number of Sectors more than 1?
  JBE >L80                ;If not, it's OK
  AND  ECX,0000_FFFFh     ;If so, convert # of Sectors to a DWord
  ADD  ECX,EAX            ;Calculate the Last LBA
  DEC  ECX                ;  we will transfer
  CMP  ECX,[BX].DskMaxLBA ;Is the the Last LBA?
  JB  >L80                ;If not, we're OK
L70:                      ;Error
  STC                     ;Set return flag
  JMP >L90                ;Done
L80:                      ;OK
  CLC                     ;Set return flag
L90:                      ;Done
  POP  ECX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEND A SCSI SEEK REQUEST, WAIT FOR THE FINISH
;Inputs:    DS  = TSR Data Area
;          EAX  = LBA (Sector Number) to Seek
;          [BX] = Disk Info Entry
;Outputs: Sends SCSI Request
;         CF = Clear if it worked OK
;            = Set if Error
;              Error Details are stored in appropriate Device Info Entry
;Changes:
;NOTES: Many USB Devices don't support the Seek Command, so instead we will
;         do a Read into an internal buffer.  It's really annoying to have
;         do perform all of these workarounds because the hardware
;         manufacturers make incomplete products.
;------------------------------------------------------------------------------
SCSISeek0FG:
  PUSH EAX        ;Save used registers
  XOR  EAX,EAX    ;Seek Sector 0
  CALL SCSISeekFG ;Do it
  POP  EAX        ;Restore used registers
  RET

SCSISeekFG:
  PUSH CX,DI,ES          ;Save used registers
  CALL ReserveSectorBuff ;Reserve the Sector buffer
  MOV  CX,1              ;Read 1 Sector
  MOV  ES,DS             ;ES:[DI] =
  MOV  DI,SectorBuff     ;  our Sector Buffer
  CALL SCSIReadFG        ;Do the Read
  MOV  LBAInBuffer,EAX   ;Store the Sector Number
  CALL ReleaseSectorBuff ;Relese the Sector Buffer
  POP  ES,DI,CX          ;Restore used registers
  RET

;;------------------------------------------------------------------------------
;;SEND A SCSI MODE SELECT REQUEST, WAIT FOR THE FINISH
;;Inputs:    DS  = TSR Data Area
;;          [BX] = Disk Info Entry
;;          Resources Reserved (SectorBuff, ModeSenseBuff, etc.)
;;Outputs: Sends SCSI Request
;;         CF = Clear if it worked OK
;;            = Set if Error
;;              Error Details are stored in appropriate Device Info Entry
;;Changes:
;;NOTES: This must only get called for Floppy Drives!
;;------------------------------------------------------------------------------
;SCSIModeSelect720kFG:
;  PUSH DX                        ;Save used registers
;  MOV  DL,MPHType720k            ;DL = Media Type
;  JMP >S00                       ;Do it
;;SCSIModeSelect125MFG:
;;  PUSH DX                        ;Save used registers
;;  MOV  DL,MPHType125M            ;DL = Media Type
;;  JMP >S00                       ;Do it
;SCSIModeSelect144MFG:
;  PUSH DX                        ;Save used registers
;  MOV  DL,MPHType144M            ;DL = Media Type
;;  JMP >S00                       ;Do it
;S00:
;  PUSH AX,CX,DI,ES               ;Save used registers
;  MOV  ES,DS                     ;ES:[DI] =
;  CALL ClearModeSenseBuff        ;Clear out the Buffer
;  CALL ClearSCSIReqBX            ;Initialize SCSI Request with all zeroes
;  MOV  DI,ModeSenseBuff          ;  Mode Sense Buffer
;;  MOV  DI,ModeSelectPBlk          ;  Mode Select Buffer
;  MOV  W [BX].DskCBW.CBWCmdBlock.SCSIReqCommand,SCmdModeSense10 ;Store Command
;  MOV  [BX].DskCBW.CBWCmdBlock.SModeSense10Page,(SMSensFlexible+SMSensCurrent)
;                                 ;Store Page
;  MOV  CX,MSenseRespSize         ;CX = Number of Bytes to Transfer
;  MOV  [BX].DskCBW.CBWCmdBlock.SModeSense10Length[1],CL ;Store Data Size
;  OR   [BX].DskFlags,DskFlagShortPktOK ;Short Packets are OK
;  CALL DoSCSIReqInFG             ;Issue the Request (rtns ZF, AX)
;  JNZ >S70                       ;If error, quit
;  CALL ClearSCSIReqBX            ;Initialize SCSI Request with all zeroes
;  MOV  [BX].DskCBW.CBWCmdBlock.SCSIReqCommand,SCmdModeSelect10 ;Store Command
;  MOV  [BX].DskCBW.CBWCmdBlock.SModeSelLUN,SMSelPgFmt ;Store Flags
;  MOV  CX,(ModeParam10HdrSize+FlexSize)               ;CX = Transfer Size
;;  MOV  CX,ModeParam10HdrSize     ;CX = Transfer Size
;  MOV  [BX].DskCBW.CBWCmdBlock.SModeSelLength[1],CL   ;Store Number of Bytes
;  MOV  [DI].MPH10DataLength,0    ;Header Length Field = 0 for Mode Select
;  MOV  [DI].MPH10MediumType,DL   ;Store the Medium Type
;  CMP  DL,MPHType720k            ;Is it 720k?
;  JNE >S30                       ;If not, handle 1.44M
;S20:                             ;720k
;  MOV  [DI].ModeParam10HdrSize.FlexXferRate,0F401h   ;Store Transfer Rate
;  MOV  [DI].ModeParam10HdrSize.FlexSectsPerTrack,09h ;Store Sectors per Track
;  JMP >S40                       ;Do it
;S30:                             ;1.44M
;  MOV  [DI].ModeParam10HdrSize.FlexXferRate,0E803h   ;Store Transfer Rate
;  MOV  [DI].ModeParam10HdrSize.FlexSectsPerTrack,12h ;Store Sectors per Track
;S40:                             ;Data is filled in!
;  CALL DoSCSIReqOutFG            ;Issue the Request (rtns AX, ZF)
;  JZ  >S80                       ;If it worked, we're done
;S70:                             ;Error
;  STC                            ;Set return flag
;  JMP >S90                       ;Done
;S80:                             ;OK
;  CLC                            ;Set return flag
;S90:                             ;Done
;  POP  ES,DI,CX,AX               ;Restore used registers
;  POP  DX                        ;Restore used registers
;  RET

;------------------------------------------------------------------------------
;SEND A SCSI PREVENT/ALLOW MEDIUM REMOVAL, START/STOP UNIT, OR SYNC CACHE
;  REQUEST
;Inputs:    DS  = TSR Data Area
;          [BX] = Disk Info Entry
;Outputs: Sends SCSI Request
;         Flags Preserved
;Changes:
;NOTES: Most Devices do NOT support Media Removal commands, but we will issue
;         them anyway (like Windows does).
;       For the Synchronize Cache Request, we will Synchronize ALL data that
;         may be in the Cache (Starting LBA = 0, Ending LBA = last possible LBA)
;------------------------------------------------------------------------------
SCSILockUnitFG:
  PUSH AX                            ;Save used registers
  MOV  AL,[BX].DskStopTimer          ;Get current Stop/Unlock Timer
  MOV  [BX].DskStopTimer,StopTicks   ;Initialize Stop/Unlock Timer
  CMP  AL,2                          ;Still counting down from previous Request?
  JA  >V99                           ;If so, don't reissue the Request
  TEST [BX].DskFlags2,DskFlagNoLock  ;Should we issue the Request?
  JNZ >V99                           ;If not, we're done
  MOV  AX,((SCmdSetMediaRemoval SHL 8)+SMedRemPrevent) ;AH = Command, AL = Flags
  JMP >V00                           ;Do it
;SCSIUnlockUnitFG:
;  PUSH AX                            ;Save used registers
;;  MOV  [BX].DskStopTimer,0           ;Reset Stop/Unlock Timer
;  TEST [BX].DskFlags2,DskFlagNoLock  ;Should we issue the Request?
;  JNZ >V99                           ;If not, we're done
;  MOV  AX,((SCmdSetMediaRemoval SHL 8)+0) ;AH = Command, AL = Flags
;  JMP >V00                           ;Do it
SCSIStartUnitFG:
  PUSH AX                            ;Save used registers
  MOV  AL,[BX].DskStopTimer          ;Get current Stop/Unlock Timer
  MOV  [BX].DskStopTimer,StopTicks   ;Initialize Stop/Unlock Timer
  CMP  AL,2                          ;Still counting down from previous Request?
  JA  >V99                           ;If so, don't reissue the Request
  TEST [BX].DskFlags2,DskFlagNoStart ;Should we issue the Request?
  JNZ >V99                           ;If not, we're done
  MOV  AX,((SCmdStartStop SHL 8)+SStartStopStart) ;AH = Command, AL = Flags
  JMP >V00                           ;Do it
;SCSIStopUnitFG:
;  PUSH AX                            ;Save used registers
;;  MOV  [BX].DskStopTimer,0           ;Reset Stop/Unlock Timer
;  TEST [BX].DskFlags2,DskFlagNoStart ;Should we issue the Request?
;  JNZ >V99                           ;If not, we're done
;  MOV  AX,((SCmdStartStop SHL 8)+0)  ;AH = Command, AL = Flags
;  JMP >V00                           ;Do it
SCSISyncCacheFG:
  PUSH AX                            ;Save used registers
  TEST [BX].DskFlags2,DskFlagNoSync  ;Should we issue the Request?
  JNZ >V99                           ;If not, we're done
  MOV  AX,((SCmdSyncCache SHL 8)+0)  ;AH = Command, AL = Flags
;  JMP >V00                           ;Do it
V00:
  PUSH CX,DX                         ;Save used registers
  CALL ClearSCSIReqBX                ;Initialize SCSI Request with all zeroes
  MOV  [BX].DskCBW.CBWCmdBlock.SCSIReqCommand,AH ;Store Command
  MOV  [BX].DskCBW.CBWCmdBlock.SMedRemFlags,AL   ;Store Flag
  XOR  CX,CX                         ;Data Size = 0 bytes
  CALL DoSCSIReqOutFG                ;Send it (returns AX, ZF)
  JZ  >V80                           ;If it worked, we're done
V70:                                 ;Error
  STC                                ;Set return flag
  JMP >V90                           ;Done
V80:                                 ;OK
  CLC                                ;Set return flag
V90:                                 ;Done
  POP  DX,CX                         ;Restore used registers
  POP  AX                            ;Restore used registers
  RET

V99:                                 ;Don't issue the Request!
  POP  AX                            ;Restore used registers
  CLC                                ;Mark as successful
  RET

;------------------------------------------------------------------------------
;SEND A SCSI SEND DIAGNOSTICS (SELF-TEST) REQUEST
;Inputs:    DS  = TSR Data Area
;          [BX] = Disk Info Entry
;Outputs: Sends SCSI Request
;         CF = Clear if OK (Self-Test Results OK)
;              Set if Error (Self-Test Results Bad)
;Changes:
;------------------------------------------------------------------------------
SCSISelfTestFG:
  PUSH AX,CX,DX       ;Save used registers
  CALL ClearSCSIReqBX ;Initialize SCSI Request with all zeroes
  MOV  [BX].DskCBW.CBWCmdBlock.SCSIReqCommand,SCmdSendDiagnostics ;Store Command
  MOV  [BX].DskCBW.CBWCmdBlock.SCSIReqLUNFlags,SDiagSelfTest ;Store Flags
  XOR  CX,CX          ;Send 0 bytes
  CALL DoSCSIReqOutFG ;Send it (returns AX, ZF)
  JZ  >S80            ;If no error, we're done
S70:                  ;Error
  STC                 ;Set return flag
  JMP >S90            ;Done
S80:                  ;OK
  CLC                 ;Set return flag
S90:                  ;Done
  POP  DX,CX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WAIT FOR A DRIVE TO BE READY (CONTAIN MEDIA)
;Inputs:    DS  = TSR Data Area
;          [SI] = Drive Info Entry
;       or [BX] = Drive Info Entry
;Outputs: CF = Clear if OK (Drive has Media)
;            = Set if Error (No Media)
;Changes:
;NOTES: Waits a maximum of 22.5 seconds for the Drive to have Media
;         (10 seconds for the disk (LUN), 12.5 seconds for the Drive)
;------------------------------------------------------------------------------
WaitForDrvBX:
  PUSH SI           ;Save used registers
  MOV  SI,BX        ;[SI] = Drive Info entry
  CALL WaitForDrvSI ;Check for Media
  POP  SI           ;Restore used registers
  RET

WaitForDrvSI:
  PUSH AX,BX,CX                   ;Save used registers
  TEST [SI].DrvFlags,DrvFlagValid ;Legitimate Drive Entry?
  JZ  >V70                        ;If not, error
  MOV  BX,[SI].DrvDskOffset       ;[BX] = Disk Offset
  CALL SCSIWaitDskReadyBX         ;Wait for the Disk to be Ready
  JC  >V70                        ;If not, error
  MOV  CL,250                     ;Wait a total of 12.5 seconds
  MOV  AX,50                      ;  50 milliseconds at a time
V10:                              ;Loop to here to wait until Ready
  TEST [BX].DskFlags,DskFlagInUse ;Disk still connected?
  JZ  >V70                        ;If not, error
  TEST [SI].DrvFlags,DrvFlagReady ;Drive configured & Ready to go?
  JNZ >V80                        ;If so, we're done
V20:                              ;Not ready yet
  DEC  CL                         ;If not, have we waited long enough?
  JZ  >V70                        ;If so, quit
  CALL DelayMSAX                  ;If not, wait a little while
  JMP  V10                        ;Check again for Unit Ready
V70:                              ;Error (Not Ready)
  STC                             ;Set return flag
  JMP >V90                        ;Done
V80:                              ;OK (Drive Ready)
  CLC                             ;Set return flag
V90:                              ;Done
  POP  CX,BX,AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WAIT FOR A DISK TO BE READY (TEST UNIT READY)
;Inputs:    DS  = TSR Data Area
;          [BX] = Disk Info Entry
;Outputs: CF = Clear if OK (Unit is Ready)
;            = Set if Error (Unit Not Ready)
;Changes:
;NOTES: Waits a maximum of 10 seconds for the Device to become ready
;       Some disks with removable media do not respond to a Test Unit Ready
;         correctly after a media change the first time (they return
;         indicating that the media is still inserted even though it isn't).
;       Therefore, if the disk has removable media, we perform the TUR
;         test twice to ensure it's returning valid data.
;------------------------------------------------------------------------------
SCSIWaitDskReadyBX:
  PUSH AX,CX,ES        ;Save used registers
  MOV  ES,DS           ;ES = TSR Data ARea
  MOV  CL,200          ;Wait a total of 10 seconds
  MOV  AX,50           ;  25 milliseconds at a time
  MOV  CH,1            ;Assume not Removable Media
  CMP  [BX].DskAccessTimer,-1 ;Is it Removable Media?
  JE  >W10             ;If not, continue
  INC  CH              ;If so, we need to get two valid Test Unit Ready's
W10:                   ;Loop to here to wait until Ready
  TEST [BX].DskFlags,DskFlagInUse ;Legitimate Drive?
  JZ  >W70             ;If not, error
  CALL SCSITestReadyFG ;Is the Drive Ready?
  JC  >W30             ;If not, jump to try again
  DEC  CH              ;If so, decrement our retry counter
  JZ  >W80             ;If we've tried enough times, quit
W30:                   ;Do it again
  DEC  CL              ;Have we waited long enough?
  JZ  >W70             ;If so, quit
  CALL DelayMSAX       ;If not, wait a little while
  JMP  W10             ;Check again for Unit Ready
W70:                   ;Error (Not Ready)
  STC                  ;Set return flag
  JMP >W90             ;Done
W80:                   ;OK (Drive Ready)
  CLC                  ;Set return flag
W90:                   ;Done
  POP  ES,CX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEND A SCSI TEST UNIT READY REQUEST, WAIT FOR THE FINISH
;Inputs:    DS  = TSR Data Area
;          [BX] = Disk Info Entry
;Outputs: Sends SCSI Request
;         CF = Clear if OK (Unit is Ready)
;            = Set if Error (Unit Not Ready)
;Changes:
;------------------------------------------------------------------------------
SCSITestReadyFG:
  PUSH AX,CX            ;Save used registers
  CALL ClearSCSIReqBX   ;Initialize SCSI Request with all zeroes
  XOR  CX,CX            ;Data Size = 0 bytes
  CALL DoSCSIReqOutFG   ;Send it (returns AX, ZF)
  JZ  >Y80              ;If no error, we're cool
;  CALL TestSanDiskErrBX ;If error, is a SanDisk "Medium Not Present"?
;  JC  >Y80              ;If so, pretend it's not an Error
Y70:                    ;Unit Not Ready
  STC                   ;Set return flag
  JMP >Y90              ;Done
Y80:                    ;Unit Ready
  CLC                   ;Set return flag
Y90:                    ;Done
  POP  CX,AX            ;Restore used registers
  RET

;;------------------------------------------------------------------------------
;;TEST AND SEE IF A DISK ERROR IS A SANDISK "MEDIUM NOT PRESENT" ERROR
;;Inputs:   DS  = TSR Data Area
;;         [BX] = Disk Info Entry
;;Outputs: CF = Clear if Disk is not made by SanDisk, or
;;                is made by SanDisk but is not "Medium Not Present"
;;            = Set if Disk is made by SanDisk and Error is "Medium Not Present"
;;Changes:
;;------------------------------------------------------------------------------
;TestSanDiskErrBX:
;  PUSH DI                           ;Save used registers
;  MOV  DI,[BX].DskDvcOffset         ;If error, [DI] = Device Info Entry
;  TEST [DI].DvcFlags,DvcFlagSanDisk ;Is the Disk made by SanDisk?
;  JZ  >S80                          ;If not, we're done
;  CMP  B [BX].DskSenseBuffer.SReqSRespAddSenseCode,3Ah ;Medium Not Present?
;  JNE >S80                          ;If not, we're done
;S70:                                ;Error (SanDisk "Medium Not Present")
;  STC                               ;Set return flag
;  JMP >S90                          ;Done
;S80:                                ;OK (not SanDisk "Medium Not Present")
;  CLC                               ;Set return flag
;S90:                                ;Done
;  POP  DI                           ;Restore used registers
;  RET

;------------------------------------------------------------------------------
;ISSUE A SCSI REQUEST TO A DEVICE, WAITING FOR THE REQUEST TO FINISH
;Inputs:   DS  = TSR Data Area
;         [BX] = Disk Info Entry
;                  Corresponding Device Info Entry SCSI Command Block is
;                  filled in, except for LUN
;          CX  = Data Size (Bytes)
;         ES:[DI] = Data Address
;Outputs: AX = Error Code (Combined Errors from all Stages)
;         ZF = Set if AX = 0
;            = Clear if AX != 0
;Changes:
;------------------------------------------------------------------------------
DoSCSIReqInFG:
  MOV  AX,DoSCSIReqIn                 ;[DX] = Code to Call
  JMP >F00                            ;Do it
DoSCSIReqOutFG:
  MOV  AX,DoSCSIReqOut                ;[DX] = Code to Call
;  JMP >W00                            ;Do it
F00:
  CLI                                 ;Disable interrupts
  TEST [BX].DskFlags,DskFlagReqInProg ;Request currently in progress?
  JNZ >F15                            ;If so, wait
  TEST TSRFlags,Int14ReqInUse         ;Resources available?
  JZ  >F20                            ;If so, continue
F15:                                  ;Not Ready
  STI                                 ;Disable interrupts
  JMP F00                             ;Keep waiting
F20:                                  ;OK to continue
  OR   TSRFlags,Int14ReqInUse         ;Mark us as using resources
  OR   [BX].DskFlags,DskFlagReqInProg ;Mark as In Progress
  STI                                 ;Enable interrupts
  CALL AX                             ;Call the Code
F30:                                  ;Loop to here to wait for done
  TEST [BX].DskFlags,DskFlagReqInProg ;Done yet?
  JNZ  F30                            ;If not, keep waiting
  AND  TSRFlags,(NOT Int14ReqInUse)   ;Mark us done with resources
  CALL GetSCSIReqErr                  ;Get the Error (rtns ZF & AX)
  RET

;------------------------------------------------------------------------------
;CALCULATE AND RETURN THE OR'd STATUS OF A SCSI REQUEST
;Inputs:   DS = TSR Data Area
;         [BX] = Disk Info Entry
;Outputs:  AH = CSW Status (if valid)
;          AL = Lower byte of TD Status's from various stages OR'd together
;          ZF = Set if AX = 0 (No Error)
;             = Clear if Error (of some sort)
;Changes:
;------------------------------------------------------------------------------
;GetSCSIReqErrNoSts:
;  XOR  AH,AH                       ;Mark as not needing Status Stage
;  JMP >E00                         ;Do it
GetSCSIReqErr:
  MOV  AH,1                         ;Mark as needing Status Stage
;  JMP >E00                         ;Do it
;E00:
  XOR  AL,AL                       ;AL = 0
E10:                               ;Handle Setup Error Code
  CMP  [BX].DskSCSIReqErrSetup,-1  ;Valid Error Code?
  JE  >E20                         ;If not, continue
  OR   AL,[BX].DskSCSIReqErrSetup  ;If so, mask it in
E20:                               ;Handle Setup Error Code
  CMP  [BX].DskSCSIReqErrData,-1   ;Valid Error Code?
  JE  >E30                         ;If not, continue
  OR   AL,[BX].DskSCSIReqErrData   ;If so, mask it in
E30:                               ;Handle Setup Error Code
  OR   AH,AH                       ;Need to get the status stage?
  JZ  >E40                         ;If not, skip it
  CMP  [BX].DskSCSIReqErrStatus,-1 ;Valid Error Code?
  JE  >E40                         ;If not, continue
  OR   AL,[BX].DskSCSIReqErrStatus ;If so, mask it in
E40:                               ;Handle CSW Status
  MOV  AH,[BX].DskCSW.CSWStatus    ;Get the CSW Status
  CMP  AH,-1                       ;Is it valid?
  JNE >E90                         ;If so, we're done
  XOR  AH,AH                       ;If not, make it 0
E90:                               ;Done
  OR   AX,AX                       ;Set the return flag
  RET

;------------------------------------------------------------------------------
;ISSUE A SCSI REQUEST TO A DEVICE, PROCESSING IT AS A BACKGROUND REQUEST
;Inputs:   DS = ES = TSR Data Area
;         [BX] = Disk Info Entry
;                SCSI Command Block is filled in, except for LUN
;         [DI] = Device Info Entry
;          CX  = Data Size (Bytes)
;         [BP] = Data Address
;Outputs: CF = Clear if OK (Request was issued)
;            = Set if Error (Error issuing Request)
;Changes: [BX].DskFlags.DskFlagReqInProg = True
;NOTES: This simply starts a background SCSI Request Process, but does not
;         follow it through to completion.  The caller is expected to provide
;         a "wrapper" around this that monitors [BX].SCSIReqStage to know
;         when the request has completed.
;------------------------------------------------------------------------------

;Note: We simply assume that the Request is available for a background
;        request.  The only time background requests are issued is during
;        the LookForNewDevice routine, so we should be OK.

DoSCSIReqInBG:
  PUSH AX              ;Save used registers
  MOV  AX,DoSCSIReqIn  ;[DX] = Code to Call
  JMP >W00             ;Do it
DoSCSIReqOutBG:
  PUSH AX              ;Save used registers
  MOV  AX,DoSCSIReqOut ;[DX] = Code to Call
;  JMP >W00             ;Do it
W00:
  PUSH BX,DI ;Save used registers
  OR   [BX].DskFlags,DskFlagReqInProg ;Mark as a Request In Progress
  MOV  DI,BP ;ES:[DI] = Data Address
  CALL AX    ;Issue the Request (rtns CF)
  POP  DI,BX ;Restore used registers
  POP  AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE A BACKGROUND SCSI REQUEST TO A DEVICE
;Inputs:   DS  = TSR Data Area
;         [BX] = Disk Info Entry
;                  Corresponding Device Info Entry SCSI Command Block is
;                  filled in, except for LUN
;          CX  = Data Size (Bytes)
;         ES:[DI] = Data Address (if CX != 0)
;Outputs: CF = Clear if OK
;              SCSI Request Issued
;            = Set if Error
;Changes:
;NOTES: In Real SCSI, the LUN needs to be included in the SCSI Request.
;       In USB, the LUN is already declared in the CBW, so doesn't need to
;         be in the SCSI Request (the LUN is always 0).  I don't know what
;         would happen if we actually put the LUN number in there, but suspect
;         some devices would "blow up".  Then again, there may be a device
;         somewhere that actually requires it.
;------------------------------------------------------------------------------
DoSCSIReqIn:
  PUSH DX                                   ;Save used registers
  MOV  DL,-1                                ;Mark as In
  JMP >Q00                                  ;Do it
DoSCSIReqOut:
  PUSH DX                                   ;Save used registers
  XOR  DL,DL                                ;Mark as Out
;  JMP >Q00                                  ;Do it
Q00:
  PUSH AX,DI,SI,ES                          ;Save used registers
  MOV  W [BX].DskCBWDataPtr[2],ES           ;Store the
  MOV  W [BX].DskCBWDataPtr[0],DI           ;  Data Address
  MOV  W [BX].DskCBW.CBWDataSize[0],CX      ;Store the Data Size
  MOV  ES,DS                                ;Point ES at local data area
  MOV  DI,[BX].DskDvcOffset                 ;[DI] = Device Info Structure
  LEA  SI,[DI].DvcInt14Request              ;[SI] = Int 14 Request
  CALL GetSCSICmdSize                       ;Fill in the size of the
  MOV  [BX].DskCBW.CBWCmdBlkSize,AL         ;  SCSI Request Blk
  MOV  AL,[BX].DskLUN                       ;AL = LUN Number
  MOV  [BX].DskCBW.CBWLUN,AL                ;Store LUN in the CBW
;  SHL  AL,5                                 ;Store LUN in the Command Block
;  AND  [BX].DskCBW.CBWCmdBlock.SCSIReqLUNFlags,(NOT SCSIReqLUNMask)
;  OR   [BX].DskCBW.CBWCmdBlock.SCSIReqLUNFlags,AL
  AND  [BX].DskCBW.CBWFlags,(NOT CBWFlagIn) ;Assume Out
  OR   DL,DL                                ;Is it Out?
  JZ  >Q10                                  ;If so, continue
  OR   [BX].DskCBW.CBWFlags,CBWFlagIn       ;Mark as In
Q10:                                        ;Data Stage Direction has been handled
  TEST [BX].DskFlags,DskFlagReqSense        ;Is this the Request Sense?
  JNZ >Q20                                  ;If so, don't modify retry counter
  MOV  [BX].DskSCSIRetries,5                ;Default is 5 retries
  TEST [BX].DskFlags,DskFlagNoRetry         ;Should we retry at all?
  JZ  >Q20                                  ;If so, continue
  MOV  [BX].DskSCSIRetries,1                ;If not, just do it once
Q20:                                        ;Retries handled
  AND  [BX].DskFlags,(NOT DskFlagNoRetry)   ;Reset Retry flag for next time
  CALL IssueSCSIReq                         ;Issue the Request
  JNC >Q80                                  ;If it worked, we're done
Q70:                                        ;Error
  CALL FinishSCSIReq                        ;Mark it as Complete
  STC                                       ;Set Return Flag
  JMP >Q90                                  ;Done
Q80:                                        ;OK
  CLC                                       ;Set Return flag
Q90:                                        ;Done
  POP  ES,SI,DI,AX                          ;Restore used registers
  POP  DX                                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;(RE)ISSUE A SCSI REQUEST (THREE SEPARATE STAGES REQUIRED)
;Inputs:   CS = DS = ES = TSR Data Area
;         [BX] = Disk Info Entry, with all SCSI Request Data Filled in (CBW)
;         [DI] = Device Info Entry
;         [SI] = Int 14 Request
;         [BX].DskSCSIRetries = Current Retry Counter
;Outputs: CF = Clear if OK (SCSI Request (Re)Issued
;            = Set if Error
;                (Retry Counter is completed, or Host Lacks Resources)
;Changes:
;------------------------------------------------------------------------------
IssueSCSIReq:
  PUSH AX,CX                                 ;Save used registers
  TEST [BX].DskFlags,DskFlagReqSense         ;Is this a Request Sense?
  JNZ >I05                                   ;If so, don't change Retries
  MOV  AL,[BX].DskCBW.CBWCmdBlock.SCSIReqCommand ;Save the
  MOV  [BX].DskSCSIRequest,AL                    ;  Request Type
  CMP  [BX].DskSCSIRetries,0                 ;Should we retry?
  JE  >I70                                   ;If not, error
  DEC  [BX].DskSCSIRetries                   ;If so, decrement retry counter
  CALL InitSCSIReqErrs                       ;Initialize Error Codes
I05:                                         ;Retries handled, if appropriate
  MOV  [BX].DskCSW.CSWUserTag,00FF_00FFh     ;Set User Tag
  MOV  W [SI].I14RCallBackAddr[0],DoSCSIReqData1 ;Assume we'll need a Data Stage
  CMP  W [BX].DskCBW.CBWDataSize,0           ;Will we need a Data Stage?
  JNE >I10                                   ;If so, continue
  MOV  W [SI].I14RCallBackAddr[0],DoSCSIReqStatus1 ;No Data Stage needed
I10:                                         ;Return Address set
  MOV  [SI].I14RFlags,0                      ;Direction = Out
  MOV  [SI].I14RUserPktID,BX                 ;User Packet ID = Disk Info Entry
  MOV  W [SI].I14RDataAddress[2],DS          ;Store the Data Address Segment
  CMP  [DI].DvcIntfProtocol,IntfProtocolBulkOnly ;Is it Bulk Only?
  JNE >I40                                   ;If not, handle a CBI Device
I20:                                         ;Device is Bulk Only
  MOV  AL,[DI].DvcEndPointOut                ;Use the Out
  MOV  [SI].I14REndPoint,AL                  ;  End Point
  MOV  [SI].I14RDataSize,CBWSize             ;Store Data Size of CBW Packet
  LEA  AX,[BX].DskCBW                        ;Store the Data Address
  MOV  W [SI].I14RDataAddress[0],AX          ;  of the CBW
  MOV  [SI].I14RRequestType,I14RRTDoBulk     ;Request Type = Bulk
  MOV  [SI].I14RTimeout,5                    ;Timeout = 0.5 Seconds
  JMP >I60                                   ;Send it
I40:                                         ;Device is CBI
  MOV  [SI].I14REndPoint,0                   ;Use End Point 0
  LEA  AX,[BX].DskCBW.CBWCmdBlock            ;Store the Address
  MOV  W [SI].I14RDataAddress[0],AX          ;  of the Request Block
  MOV  CX,SendADSCReq                        ;Copy ADSC
  CALL CopySetupReqToInt14SI                 ;  Request Pkt
  MOV  [SI].I14RSendADSCSize,SCSIRequestSize ;Fill in Size of SCSI Request Blk
  MOV  AL,[DI].DvcInterfaceNum               ;Fill in
  MOV  B [SI].I14RSendADSCIntf,AL            ;  Interface Number
  MOV  [SI].I14RRequestType,I14RRTDoControl  ;Request Type = Control
I60:                                         ;Request is ready to send
  CALL DoInt14CallAXSI                       ;Send the Request
  JNC >I80                                   ;If it worked, we're done
I70:                                         ;Error
  STC                                        ;Set return flag
  JMP >I90                                   ;Done
I80:                                         ;OK
  CLC                                        ;Set return flag
I90:                                         ;Done
  POP  CX,AX                                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs: CS = DS = ES = TSR Data Area
;         AX  = TD Status Code from previous call
;               ZF Set according to value in AX
;        [BX] = Disk Info Entry
;        All registers preserved
;------------------------------------------------------------------------------
DoSCSIReqData1:
  CALL InitSCSIReqStage              ;[BX] = Disk, [DI] = Device,
                                     ;  [SI] = Int 14 Request
  TEST [BX].DskFlags,DskFlagReqSense ;Is this a Request Sense?
  JNZ >T10                           ;If so, don't store Error Code
  MOV  [BX].DskSCSIReqErrSetup,AL    ;Store Error Code
T10:                                 ;Error stored, if appropriate
  OR   AX,AX                         ;Was there an Error?
  JZ  >T30                           ;If not, continue
  TEST AL,TDStsStalled               ;If so, is it Stalled?
  JZ  >T30                           ;If not, continue with the normal process
  TEST [BX].DskFlags,DskFlagReqSense ;If Stalled, is this a Request Sense?
  JZ  >T40                           ;If not, it needs to be Reset
  JMP >T70                           ;If so, error
T30:                                 ;OK
  MOV  AX,DoSCSIReqData2             ;[AX] = Where to go when done
  CALL Start1TimeIntSI               ;Issue a 1-time interrupt
  JNC >T90                           ;If no error, we're done
  JMP >T70                           ;If error, handle it
T40:                                 ;It was stalled
  MOV  [BX].DskEPResetRtn,DoSCSIReqStatus2       ;Assume Bulk-only
  CMP  [DI].DvcIntfProtocol,IntfProtocolBulkOnly ;Is it Bulk-only?
  JE  >T45                                       ;If so, continue
  MOV  [BX].DskEPResetRtn,DoSCSIReqDone1         ;If not, it's CBI
T45:                                 ;Return address is stored
  CALL SendEPReset                   ;Issue the Reset EP Request
  JNC >T90                           ;If it worked, we're done
T70:                                 ;Error
  CALL FinishSCSIReq                 ;Mark it as Complete
T90:                                 ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: CS = DS = ES = TSR Data Area
;         AX  = TD Status Code from previous call
;               ZF Set according to value in AX
;        [BX] = Disk Info Entry
;        All registers preserved
;------------------------------------------------------------------------------
DoSCSIReqData2:
  CALL InitSCSIReqStage                ;[BX] = Disk, [DI] = Device,
                                       ;  [SI] = Int 14 Req, ErrType = TD,
                                       ;  Error Stored
  MOV  AX,W [BX].DskCBW.CBWDataSize[0] ;Store the
  MOV  [SI].I14RDataSize,AX            ;  Data Size
  MOV  EAX,[BX].DskCBWDataPtr          ;Store the
  MOV  [SI].I14RDataAddress,EAX        ;  Data Address
  AND  [SI].I14RFlags,(NOT I14RFlagIn) ;Assume
  MOV  AL,[DI].DvcEndPointOut          ;  Out
  TEST [BX].DskCBW.CBWFlags,CBWFlagIn  ;Is it Out?
  JZ  >D20                             ;If so, continue
  OR   [SI].I14RFlags,I14RFlagIn       ;If not,
  MOV  AL,[DI].DvcEndPointIn           ;  it's In
D20:                                   ;AL = EndPoint to Use
  MOV  [SI].I14REndPoint,AL            ;Store the EndPoint
  MOV  W [SI].I14RCallBackAddr[0],DoSCSIReqStatus1 ;Code to Call when Done
  MOV  [SI].I14RRequestType,I14RRTDoBulk ;Request Type = Bulk
  MOV  [SI].I14RTimeout,15             ;Timeout = 1.5 Seconds
  CALL DoInt14CallSaveAllSI            ;Send the Request
  JNC >D90                             ;If no error, we're done
D70:                                   ;Error
  CALL FinishSCSIReq                   ;Mark it as Complete
D90:                                   ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: CS = DS = ES = TSR Data Area
;         AX  = TD Status Code from previous call
;               ZF Set according to value in AX
;         CX  = Number of Data Bytes Transferred in Last Call
;        [BX] = Disk Info Entry
;        All registers preserved
;------------------------------------------------------------------------------
DoSCSIReqStatus1:
  CALL InitSCSIReqStage                ;[BX] = Disk, [DI] = Device,
                                       ;  [SI] = Int 14 Req
  TEST [BX].DskFlags,DskFlagReqSense   ;Is this a Request Sense?
  JNZ >A20                             ;If so, don't store Error Code
  CMP  W [BX].DskCBW.CBWDataSize[0],0  ;Is this a Setup or Data Stage Error?
  JNE >A15                             ;If Data Stage, handle it
A10:                                   ;It's a Setup Stage Error
  MOV  [BX].DskSCSIReqErrSetup,AL      ;Store Error Code
  JMP >A20                             ;Continue
A15:                                   ;It's a Data Stage Error
  MOV  [BX].DskSCSIReqErrData,AL       ;Store Error Code
A20:                                   ;Error Code stored
  OR   AX,AX                           ;Was there an error?
  JZ  >A40                             ;If not, continue
  TEST AL,TDStsStalled                 ;If so, is it stalled?
  JNZ >A50                             ;If so, Reset the EndPoint
  CMP  W [BX].DskCBW.CBWDataSize[0],0  ;Was this a Setup or Data Stage?
  JE  >A30                             ;If Setup, short packet error is valid
  JCXZ >A50                            ;If not data at all, Reset the EP
  TEST [BX].DskFlags,DskFlagShortPktOK ;If some data, is a Short Packet OK?
  JZ  >A30                             ;If not, continue
  AND  B [BX].DskSCSIReqErrData,(NOT TDStsShortPacket) ;If so, unmask the Error
A30:                                   ;Done processing Short Packet
  AND  [BX].DskFlags,(NOT DskFlagShortPktOK) ;Reset Short Packet Flag
  CMP  AX,TDStsShortPacket             ;Was a Short Packet the Only Error?
  JNE >A50                             ;If not, continue
A40:                                   ;No error
  MOV  AX,DoSCSIReqStatus2             ;[AX] = Where to go when done
  CALL Start1TimeIntSI                 ;Issue a 1-time interrupt
  JNC >A90                             ;If no error, we're done
  JMP >A70                             ;If error, handle it
A50:                                   ;There was a Stall error
  MOV  [BX].DskEPResetRtn,DoSCSIReqStatus2 ;Where to go when done
  CALL SendEPReset                     ;Issue the Reset EP Request
  JNC >A90                             ;If it worked, we're done
A70:                                   ;Error
  CALL FinishSCSIReq                   ;Mark it as Complete
A90:                                   ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: CS = DS = ES = TSR Data Area
;         AX  = TD Status Code from previous call
;               ZF Set according to value in AX
;        [BX] = Disk Info Entry
;        All registers preserved
;------------------------------------------------------------------------------
DoSCSIReqStatus2:
  CALL InitSCSIReqStage              ;[BX] = Disk, [DI] = Device,
                                     ;  [SI] = Int 14 Req, ErrType = TD,
                                     ;  Error Stored
  OR   [SI].I14RFlags,I14RFlagIn     ;Direction = In
  MOV  W [SI].I14RDataAddress[2],DS  ;Fill in Data Address Segment
  MOV  W [SI].I14RCallBackAddr[0],DoSCSIReqDone1 ;Fill in Call Back Address
  MOV  [SI].I14RRequestType,I14RRTDoBulk         ;Request Type = Bulk
  CMP  [DI].DvcIntfProtocol,IntfProtocolBulkOnly ;Is it Bulk Only?
  JNE >S30                           ;If not, handle CBI
S10:                                 ;Device is Bulk-Only
  MOV  [SI].I14RDataSize,CSWSize     ;Fill in number of Bytes
  LEA  AX,[BX].DskCSW                ;Assume not Request Sense
  TEST [BX].DskFlags,DskFlagReqSense ;Is this a Request Sense?
  JZ  >S15                           ;If not, continue
  LEA  AX,[BX].DskReqSenseCSW        ;It is Request Sense
S15:                                 ;[AX] = Data Address
  MOV  W [SI].I14RDataAddress[0],AX  ;  Data Address
  MOV  AL,[DI].DvcEndPointIn         ;Fill in the
  MOV  [SI].I14REndPoint,AL          ;  End Point
  JMP >S60                           ;Do it
S30:                                 ;Not Bulk-Only
  MOV  [SI].I14RDataSize,2           ;Data Size always 2 bytes
  LEA  AX,[BX].DskPerIntStatus       ;Assume not Request Sense
  TEST [BX].DskFlags,DskFlagReqSense ;Is this a Request Sense?
  JZ  >S35                           ;If not, continue
  LEA  AX,[BX].DskPerIntReqSenseSts  ;It is Request Sense
S35:                                 ;[AX] = Data Address
  MOV  W [SI].I14RDataAddress[0],AX  ;  Data Address
  MOV  AL,[DI].DvcEndPointInt        ;Fill in the
  MOV  [SI].I14REndPoint,AL          ;  End Point
S60:                                 ;Request is ready to send
  MOV  [SI].I14RTimeout,5            ;Timeout = 0.5 Seconds
  CALL DoInt14CallSaveAllSI          ;Send the Request
  JNC >S90                           ;If it worked, we're done
S70:                                 ;Error
  CALL FinishSCSIReq                 ;Mark it as Complete
S90:                                 ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: CS = DS = ES = TSR Data Area
;         AX  = TD Status Code from previous call
;               ZF Set according to value in AX
;        [BX] = Disk Info Entry
;        All registers preserved
;NOTES: Some Devices (my Imation Flash Drive) return an error during the
;         Status Stage (don't return a CSW at all), even though the Setup
;         and Data Stages worked just fine.  When testing whether the
;         overall SCSI Request was successful, therefore, we ignore the
;         Status Stage.
;------------------------------------------------------------------------------
DoSCSIReqDone1:
  CALL InitSCSIReqStage              ;[BX] = Disk, [DI] = Device,
                                     ;  [SI] = Int 14 Req
  CALL AddASCQ2Buff                  ;Store ASC/Q Code, if appropriate
  TEST [BX].DskFlags,DskFlagReqSense ;Is this a Request Sense?
  JNZ >D40                           ;If so, jump to handle it
D10:                                 ;Not Request Sense
  MOV  [BX].DskSCSIReqErrStatus,AL   ;Store Error Code
  OR   AX,AX                         ;Is there an error getting the CSW?
  JZ  >D20                           ;If not, continue
  MOV  [BX].DskEPResetRtn,DoSCSIReqDone1 ;Store return address
  CALL SendEPReset                   ;Issue an End Point Reset
  JNC >D95                           ;If it worked, we're done for now
  JMP >D90                           ;If not, we're done for good
D20:                                 ;No error or handled error in CSW
  CALL GetSCSIReqErr                 ;Get the combined USB error
  JZ  >D45                           ;If no error, we're done
  CMP  B [BX].DskCBW.CBWCmdBlock.SCSIReqCommand,SCmdRequestSense
  JE  >D45                           ;If primary is Request Sense, not again
D30:                                 ;Issue Request Sense
  OR   [BX].DskFlags,DskFlagReqSense ;If not, mark it as a Request Sense
  CALL BackupCBWData                 ;Backup CBW data
  CALL SCSIReqSenseBG                ;Issue the Request Sense
  JMP >D95                           ;Done
D40:                                 ;Done with Request Sense
  CALL RestoreCBWData                ;Restore original CBW data
D45:                                 ;Original CBW restored, if needed
  AND  [BX].DskFlags,(NOT DskFlagReqSense) ;Mark as not Request Sense
  CALL GetSCSIReqErr                 ;Get the combined USB error
  JZ  >D90                           ;If no error, we're done
  CALL TestASCQRetry                 ;Should we retry?
  JC  >D90                           ;If not, quit
  CALL IssueSCSIReq                  ;Attempt a retry
  JNC >D95                           ;If it worked, we're done for now
D90:                                 ;Truly done
  CALL FinishSCSIReq                 ;Mark it as Complete
D95:                                 ;Done (Retried or Complete)
  RETF

;------------------------------------------------------------------------------
;TEST THE ASC/Q VALUES AFTER A SCSI REQUEST TO SEE IF WE NEED TO RETRY
;Inputs:   DS = ES = TSR Data Area
;         [BX] = Disk Info Entry
;         [DI] = Device Info Entry
;         [BX] Data filled in (at end of SCSI Request Retry Attempt)
;         [SI] = Int 14 Request (partially filled in)
;Outputs: CF = Clear if OK to retry (ASCQ code is not one of the "special" ones)
;            = Set if Error (no need to retry)
;Changes: Depending on where we are in the Disk/Drive recognition process,
;           we may Reset various values or issue USB Requests.
;         At least one SanDisk Flash Drive I have really acts wierd.
;           It's a regular flash drive (no removable media), but it sort
;           of acts like it has removable media.  It reports No Media at first
;           (not unusual for a Flash Drive), then says it has Media, then
;           says it doesn't have Media again.  To accommodate this particular
;           drive, therefore, we need to retry more than once if it reports
;           No Media, even though we shouldn't need to do this.
;------------------------------------------------------------------------------
TestASCQRetry:
  PUSH AX                      ;Save used registers
  MOV  AX,W [BX].DskSenseBuffer.SReqSRespAddSenseCode
                               ;AL = ASC, AH = ASCQ
R10:                           ;Illegal (unaccepted) SCSI Requests
  CMP  AL,20h                  ;Illegal SCSI Request?
  JE  >R701                    ;If so, don't retry
  CMP  AL,24h                  ;Illegal SCSI Request?
  JE  >R701                    ;If so, don't retry
  CMP  AL,26h                  ;Bad Parameter in SCSI Request?
  JE  >R701                    ;If so, don't retry
R11:                           ;Unsupported LUN
  CMP  AL,25h                  ;Unsupported LUN?
  JE  >R701                    ;If so, don't retry
R12:                           ;Illegal LBA
  CMP  AL,21h                  ;Illegal LBA?
  JE  >R701                    ;If so, don't retry
R13:                           ;POST/Configuration Failures
  CMP  AL,42h                  ;POST Failure?
  JE  >R701                    ;If so, don't retry
  CMP  AL,46h                  ;Soft Reset Failure?
  JE  >R701                    ;If so, don't retry
  CMP  AL,4Ch                  ;Self-configuration Failure?
  JE  >R701                    ;If so, don't retry
R14:                           ;Missing/Invalid Medium
  CMP  AL,30h                  ;Invalid/Corrupted Medium?
  JE  >R20                     ;If so, handle it
  CMP  AL,3Ah                  ;No Medium?
  JE  >R20                     ;If so, handle it
R15:                           ;Device Now Ready
  CMP  AL,28h                  ;Not Ready-to-Ready Transition?
  JE  >R30                     ;If so, handle it
R16:                           ;Change in Device Parameters
  CMP  AL,2Ah                  ;Change in parameters?
  JE  >R40                     ;If so, handle it
  CMP  AL,3Fh                  ;Change in parameters?
  JE  >R40                     ;If so, handle it
R17:                           ;Write Protection
  CMP  AL,27h                  ;Write Protected?
  JE  >R50                     ;If so, handle it
R19:                           ;Default = Nothing Special
  JMP >R80                     ;If none of these, OK to Retry
R701:                          ;To avoid JMP > 128
  JMP >R70                     ;No retry

R20:                           ;Invalid Medium/No Medium
  CMP  [BX].DskDrvTimer,DskStageStartup ;Are we still in the Startup Stages?
  JE  >R80                     ;If so, do the Retry
  CMP  [BX].DskSCSIRetries,1   ;Is this the last Retry?
  JA  >R80                     ;If not, just do the Retry
  CMP  AL,3Ah                  ;No Medium (as compared to Bad Medium)?
  JNE >R25                     ;If not, it must really be removable medium
  CMP  [DI].DvcMaxLUN,0        ;Is there just one LUN?
  JA  >R25                     ;If not, assume Media is really bad/missing
  CMP  [DI].DvcIntfSubClass,IntfSubClassUFI ;If so, is it a Floppy?
  JNE >R80                     ;If not, we're done (assume it's a SanDisk or
                               ;  similar drive that lies about No Media)
R25:                           ;No
  MOV  [BX].DskAccessTimer,0   ;If not, assume removable media
  CMP  [BX].DskDrvTimer,0      ;Did we have Media last time we checked?
  JNE >R70                     ;If not, don't Retry
  CALL ResetDrvs4DiskBX        ;If so, delete all Drives from previous Media
  MOV  [BX].DskDrvTimer,DskStageOnHold ;Look for new Media periodically
  JMP >R80                     ;Retry

R30:                           ;Transition to Ready - Possible Medium Change
  CMP  [BX].DskDrvTimer,DskStageStartup ;Are we still in the Startup Stages?
  JE  >R80                     ;If so, do the Retry
  MOV  [BX].DskAccessTimer,0   ;If not, it must have removable media

;  CMP  [BX].DskSCSIRequest,SCmdModeSelect10 ;Is this a Mode Select Request
;                                            ;  (part of a possible Format)?
;  JE  >R70                     ;If so, No Retry, don't Reset anything yet
;Check for "Use Stored BPB" here to know if we're formatting.

  CALL ResetDrvs4DiskBX        ;Delete all Drives from previous Media
  MOV  [BX].DskDrvTimer,DskStageOnHold ;Look for new Media periodically
  JMP >R70                     ;No Retry

R40:                           ;Need to Reset (Parameters changed)
  MOV  AX,W [DI].DvcHostIndex  ;Store the Host Index
  MOV  W [SI].I14RHostIndex,AX ;  and Device Address
  MOV  [SI].I14RRequestType,I14RRTResetDevice ;Request = Reset Device
  MOV  W [SI].I14RCallBackAddr[0],-1 ;Do nothing when done
  CALL DoInt14CallSaveAllSI    ;Issue the Request
  JMP >R70                     ;No Retry

R50:                           ;Write Protected
  OR   [BX].DskFlags,DskFlagWriteProt ;Set Write Protect Flag
R70:                           ;Don't Retry
  STC                          ;Set return flag
  JMP >R90                     ;Done
R80:                           ;OK to retry
  CLC                          ;Set return flag
R90:                           ;Done
  POP  AX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SET UP AND SEND A BACKGROUND RESET END POINTS REQUEST
;Inputs:  CS = DS = ES = TSR Data Area
;         [BX] = Disk Info Entry
;         [DI] = Device Info Entry
;         [SI] = Int 14 Request (Contains offending End Point Number)
;         [BX].DskEPResetRtn filled in with appropriate Return Address
;Outputs: Sets up and sends Int 14 Request to Reset End Points
;         CF = Clear if OK
;            = Set if Error
;Changes:
;------------------------------------------------------------------------------
SendEPReset:
  PUSH AX,CX                          ;Save used registers
  MOV  W [SI].I14RCallBackAddr[2],DS  ;Segment of where to go when done
  MOV  AL,[SI].I14REndPoint           ;AL = End Point Number to Reset
  OR   AL,AL                          ;EndPoint 0 (CBI)?
  JNZ >R20                            ;If not, handle Bulk-only
R10:                                  ;Is CBI
  MOV  [SI].I14RRequestType,I14RRTDoInterrupt1T ;Set up One-time Interrupt
  MOV  [SI].I14RPeriodicity,1         ;Wait 1 Millisecond
;  MOV  W [SI].I14RCallBackAddr[0],ResetEPDone  ;Offset of where to go when done
  JMP >R50                            ;Do it
R20:                                  ;Is Bulk-only
  MOV  [SI].I14RRequestType,I14RRTDoControl ;Request = Control
  MOV  [SI].I14REndPoint,0            ;Control Requests always go to EP 0
  MOV  CX,ClearEndPtHaltReq           ;Copy the
  CALL CopySetupReqToInt14SI          ;  Request Pkt
  TEST [SI].I14RFlags,I14RFlagIn      ;Was it an In?
  JZ  >R25                            ;If not, continue
  OR   AL,80h                         ;Mark it as an In EndPoint
R25:                                  ;AL = ENdPoint w/ Direction
  MOV  B [SI].I14RClearEndPtHaltEP,AL ;Store the EP in the Request
  MOV  [SI].I14RTimeout,2             ;Timeout = 0.2 Seconds
;  MOV  W [SI].I14RCallBackAddr[0],SendBulkReset ;Offset of where to go when done
;  MOV  W [SI].I14RCallBackAddr[0],ResetEPDone ;Offset of where to go when done
R50:                                  ;Reqest is ready to go
  MOV  W [SI].I14RCallBackAddr[0],ResetEPDone ;Offset of where to go when done
  CALL DoInt14CallSaveAllSI           ;Perform the Request
R90:                                  ;Done
  POP  CX,AX                          ;Restore used registers
  RET

;;------------------------------------------------------------------------------
;;Inputs: CS = DS = ES = TSR Data Area
;;         AX  = TD Status Code from previous call
;;               ZF Set according to value in AX
;;        [BX] = Disk Info Entry
;;        All registers preserved
;;------------------------------------------------------------------------------
;SendBulkReset:
;  CALL InitSCSIReqStage               ;[BX] = Disk, [DI] = Device,
;                                      ;  [SI] = Int 14 Req, ErrType = TD
;
;call WriteAX
;
;  MOV  CX,ResetBulkDeviceReq          ;Copy the
;  CALL CopySetupReqToInt14SI          ;  Request Pkt
;  MOV  AL,[DI].DvcInterfaceNum        ;Store the
;  MOV  B [SI].I14RResetBulkDvcIntf,AL ;  Interface Number
;  MOV  W [SI].I14RCallBackAddr[0],ResetEPDone ;Offset of where to go when done
;  MOV  W [SI].I14RCallBackAddr[2],DS  ;Where to go when done
;  CALL DoInt14CallSaveAllSI           ;Perform the Request
;  JNC >K90                            ;If no error, we're done
;K70:                                  ;Error
;  CALL FinishSCSIReq                  ;Mark it as Complete
;K90:                                  ;Done
;  RETF

;------------------------------------------------------------------------------
;Inputs: CS = DS = ES = TSR Data Area
;         AX  = TD Status Code from previous call
;               ZF Set according to value in AX
;        [BX] = Disk Info Entry
;        All registers preserved
;NOTES: We don't monitor whether the call really worked or not, since we
;         can issue a request to reset the End Point even if it's not needed
;         (we do it as a response to any type of error, not just Stalls).
;       If it fails, we don't really care.
;------------------------------------------------------------------------------
ResetEPDone:
  CALL InitSCSIReqStage       ;[BX] = Disk, [DI] = Device,
                              ;  [SI] = Int 14 Req, ErrType = TD
  MOV  [SI].I14RTimeout,0     ;Restore Default Timeout
  MOV  AX,[BX].DskEPResetRtn         ;Store the
  MOV  W [SI].I14RCallBackAddr[0],AX ;  Call back address
  MOV  [SI].I14RRequestType,I14RRTDoInterrupt1T ;Set up One-time Interrupt
  MOV  [SI].I14RPeriodicity,1 ;Wait 1 Millisecond
  CALL DoInt14CallAXSI        ;Send the Request
  JNC >D90                    ;If no error, we're done
D70:                          ;Error
  CALL FinishSCSIReq          ;Mark it as Complete
D90:                          ;Done
  RETF

;------------------------------------------------------------------------------
;FINISH OUT A SCSI REQUEST CALL
;Inputs:   CS = DS = ES = TSR Data Area
;          AX = Error Code (0 if no Error)
;         [BX] = Disk Info Entry
;         [DI] = Device Info Entry
;Outputs: Stores Error (DICSWStatus)
;         Marks Request as Available (DskFlagReqInProg)
;         Resets DvcFlagShortPktOK
;Changes:
;NOTES: Some Devices do not return a valid value in CSWSignature (there's no
;         way they should have ever made it through USB testing that way,
;         but they did).  So, instead of testing for CSWSignature,
;         we test CSWUserTag (even though we don't actually use it
;         for anything).
;------------------------------------------------------------------------------
FinishSCSIReq:
  PUSH AX,ECX                               ;Save used registers
  MOV  AL,-1                                ;Assume
  MOV  ECX,-1                               ;  Invalid Status
  CMP  [DI].DvcIntfProtocol,IntfProtocolBulkOnly ;Is it Bulk Only?
  JNE >F20                                  ;If not, handle CBI
F10:                                        ;Bulk Only
  CMP  D [BX].DskCSW.CSWUserTag,00FF_00FFh  ;Valid Status Wrapper?
  JNE >F40                                  ;If not, continue
  MOV  AL,[BX].DskCSW.CSWStatus             ;If so, get the actual status
  MOV  ECX,D [BX].DskCSW.CSWDataResidue     ;  and Residue value
  JMP >F40                                  ;Continue
F20:                                        ;CBI
  MOV  AX,[BX].DskPerIntStatus              ;Get the CSW or ASC/ASCQ
  CMP  [DI].DvcIntfSubClass,IntfSubClassUFI ;Is this a Floppy (UFI)?
  JNE >F40                                  ;If not, Interrupt Status is CSW
F30:                                        ;Is Floppy (UFI)
  MOV  AL,-1                                ;Set CSW to Unknown
F40:                                        ;AL = Status
  MOV  [BX].DskCSWStatus,AL                 ;Store the Return Status
  MOV  [BX].DskCSWResidue,ECX               ;Store the Residue Value
  MOV  [BX].DskSCSICmdSize,0                ;Reset non-standard Command Size
  AND  [BX].DskFlags,(NOT (DskFlagReqInProg+DskFlagShortPktOK+DskFlagNoRetry+DskFlagReqSense))
                                            ;Mark as done
  POP  ECX,AX                               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;BACKUP THE ORIGINAL CBW DATA FROM A SCSI REQUEST, IN CASE WE NEED REQ SENSE
;Inputs:   CS = DS = ES = TSR Data Area
;         [BX] = Disk Info Entry, with all SCSI Request Data Filled in (CBW)
;         CLD already issued
;Outputs: Copies (Backs up) all CBW-related data to a special data area
;Changes:
;------------------------------------------------------------------------------
BackupCBWData:
  PUSH EAX,CX,DI,SI                ;Save used registers
  LEA  SI,[BX].DskCBW              ;DS:[SI] = Original CBW
  LEA  DI,[BX].DskReqSenseCBW      ;ES:[DI] = Backup CBW
  MOV  CX,((CBWSize+1)/2)          ;CX = Number of Words to Copy
  REP  MOVSW                       ;Copy the basic CBW data
  MOV  EAX,[BX].DskCBWDataPtr      ;Backup the
  MOV  [BX].DskReqSenseDataPtr,EAX ;  Data Pointer
  MOV  AL,[BX].DskFlags                      ;Backup the
  AND  AL,(DskFlagShortPktOK+DskFlagNoRetry) ;  appropriate
  MOV  [BX].DskReqSenseFlags,AL              ;  Flags
  POP  SI,DI,CX,EAX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESTORE THE ORIGINAL CBW DATA FOR A SCSI REQUEST
;Inputs:   CS = DS = ES = TSR Data Area
;         [BX] = Disk Info Entry, with Backup CBW Data Filled
;         CLD already issued
;Outputs: Restores original CBW data after a Request Sense
;Changes:
;------------------------------------------------------------------------------
RestoreCBWData:
  PUSH EAX,CX,DI,SI                ;Save used registers
  LEA  SI,[BX].DskReqSenseCBW      ;DS:[SI] = Backup CBW
  LEA  DI,[BX].DskCBW              ;ES:[DI] = Original CBW
  MOV  CX,((CBWSize+1)/2)          ;CX = Number of Words to Copy
  REP  MOVSW                       ;Copy the basic CBW data
  MOV  EAX,[BX].DskReqSenseDataPtr ;Restore the
  MOV  [BX].DskCBWDataPtr,EAX      ;  Data Pointer
  MOV  AL,[BX].DskReqSenseFlags    ;Restore
  OR   [BX].DskFlags,AL            ;  the flags
  POP  SI,DI,CX,EAX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADD AN ASC/Q ENTRY TO THE HISTORY BUFFER FOR A DISK
;Inputs:   CS = DS = ES = TSR Data Area
;         [BX] = Disk Info Entry
;Outputs: Copies ASC/Q Code from Request Sense to Buffer, if appropriate
;Changes:
;------------------------------------------------------------------------------
AddASCQ2Buff:
  PUSH AX,BX,CX,DX               ;Save used registers
  MOV  AX,W [BX].DskSenseBuffer.SReqSRespAddSenseCode ;AX = Last ASC/Q
  XCHG AL,AH                     ;Put ASC in high byte, ASCQ in low
  MOV  DL,[BX].DskSCSIRequest    ;DL = Request Type
  MOV  DH,[BX].DskSenseBuffer.SReqSRespSenseKey ;DH = Sense Key
  CMP  AX,W [BX].DskASCQTable[2] ;Changed since last time?
  JE  >Q90                       ;If so, quit
  OR   AX,AX                     ;Valid?
  JZ  >Q90                       ;If not, quit
  CMP  AX,-1                     ;Valid?
  JE  >Q90                       ;If not, quit
  ADD  BX,(OFFSET DskASCQTable)  ;[BX] = Storage Table
  MOV  CX,ASCQBuffEntries        ;CX = Number of Table Entries
Q10:                             ;Loop to here for each Table Entry
  XCHG DX,[BX]                   ;Swap New Command & Sense Key with Old
  XCHG AX,[BX+2]                 ;Swap New ASCQ with old
  ADD  BX,4                      ;Point at the next entry
  LOOP Q10                       ;Keep going until we're done
Q90:                             ;Done
  POP  DX,CX,BX,AX               ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE FOR SCSI REQUESTS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;INITIALIZE (FILL WITH ZEROES) THE SCSI REQUEST & COMMAND STATUS WRAPPER
;Inputs:  DS   = TSR Data Area
;         [BX] = Disk Info Entry or
;         [DI] = Disk Info Entry
;         CLD already issued
;Outputs: Fills SCSI Request & CSW with all zeroes
;Changes:
;------------------------------------------------------------------------------
ClearSCSIReqBX:
  PUSH DI             ;Save used registers
  MOV  DI,BX          ;[DI] = Drive Info Entry
  CALL ClearSCSIReqDI ;Do it
  POP  DI             ;Restore used registers
  RET

ClearSCSIReqDI:
  PUSH AX,CX,ES               ;Save used registers
  MOV  ES,DS                  ;ES = TSR Data Area
  XOR  AX,AX                  ;Fill it with Zeroes
  MOV  CX,(SCSIRequestSize/2) ;CX = Number of Words to Write
  PUSH DI                     ;Save Pointer momentarily
  ADD  DI,(OFFSET DskCBW)+(OFFSET CBWCmdBlock) ;[DI] = SCSI Request Block
  REP  STOSW                  ;Do it
  POP  DI                     ;Restore Pointer
  MOV  CX,((CSWSize+1)/2)     ;CX = Number of Words to Write
  PUSH DI                     ;Save Pointer momentarily
  ADD  DI,(OFFSET DskCSW)     ;[DI] = Command Status Wrapper
  REP  STOSW                  ;Do it
  POP  DI                     ;Restore Pointer
  AND  [DI].DskFlags,(NOT DskFlagShortPktOK) ;Reset Short Packet Flag
  POP  ES,CX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE SCSI REQUEST ERROR CODES TO -1
;Inputs:   DS = TSR Data Area
;         [BX] = Disk Info Entry
;Outputs: DskSCSIReqErrSetup, DskSCSIReqErrData, DskSCSIReqErrStatus,
;         DskCSWResidue all -1
;Changes:
;------------------------------------------------------------------------------
InitSCSIReqErrs:
  PUSH EAX                                            ;Save used registers
  MOV  EAX,-1                                         ;Store -1's
  MOV  D [BX].DskSCSIReqErrSetup,EAX                  ;Stp, Dta, Sts, & CSW
  MOV  [BX].DskCSWResidue,EAX                         ;Residue
  MOV  D [BX].DskPerIntStatus,EAX                     ;Periodic Int Status
  MOV  [BX].DskCSW.CSWStatus,AL                       ;CSW Status
  MOV  [BX].DskSenseBuffer.SReqSRespErrCode,AL        ;Sense Error Code
  MOV  [BX].DskSenseBuffer.SReqSRespSenseKey,AL       ;Sense Key
  MOV  D [BX].DskSenseBuffer.SReqSRespInfo,EAX        ;Sense Info
  MOV  W [BX].DskSenseBuffer.SReqSRespAddSenseCode,AX ;ASC/ASCQ
  POP  EAX                                            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SETUP THE REGISTERS NEEDED AT THE BEGINNING OF A SCSI BACKGROUND STAGE
;Inputs:   CS = DS = ES = TSR Data Area
;         [BX] = Disk Info Entry
;          AX  = TD Error from previous call
;          ZF  = Set if OK (AX = 0)
;              = Clear if Error (AX !=0)
;Outputs: [DI] = Device Info Entry
;         [SI] = Int 14 Request
;         Flags Unchanged
;Changes:
;------------------------------------------------------------------------------
InitSCSIReqStage:
  MOV  DI,[BX].DskDvcOffset    ;[DI] = Device Info Entry
  LEA  SI,[DI].DvcInt14Request ;[SI] = Int 14h Request
  RET

;------------------------------------------------------------------------------
;CALCULATE THE ACTUAL SIZE OF A SCSI COMMAND BLOCK (BASED ON COMMAND)
;Inputs:   DS  = TSR Data Area
;         [BX] = Disk Info Entry, with SCSI Request (SCSI Command
;                  Code) filled in
;Outputs: AL = Size of Command Block
;Changes:
;NOTES: This calculates based on SCSI Group.  If the Command is in a
;         Reserved or Vendor-specific Group (3-4, 6-7), this returns the
;         the value contained in [BX].DskSCSICmdSize if it is not 0,
;         and returns 12 if [BX].DskSCSICmdSize = 0.
;------------------------------------------------------------------------------
GetSCSICmdSize:
  PUSH BX                     ;Save used registers
  MOV  BL,[BX].DskCBW.CBWCmdBlock.SCSIReqCommand ;BL = SCSI Command
  MOV  AL,6                   ;Assume Group 0 (6 bytes)
  SHR  BL,5                   ;Put Group in BL
  JZ  >Z90                    ;If Group 0, we're done
  MOV  AL,10                  ;Assume Group 1 or 2 (10 bytes)
  CMP  BL,2                   ;Is it Group 1 or 2?
  JBE >Z90                    ;If so, we're done
  MOV  AL,12                  ;Assume Group 5 (12 bytes)
  CMP  BL,5                   ;Is it Group 5?
  JBE >Z90                    ;If so, we're done
  CMP  [BX].DskSCSICmdSize,0  ;Is there a user-provided size?
  JE  >Z90                    ;If not, we're done (use 12)
  MOV  AL,[BX].DskSCSICmdSize ;If so, use the user-provided size
Z90:                          ;Done
  POP  BX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT THE ENDIAN-NESS OF A DWORD
;Inputs:  EAX = DWord to Convert
;Outputs: EAX = DWord Converted to other-Endian
;Changes:
;NOTES: We could use the BSWAP instruction, but that requires an 80486+ CPU.
;       Not that anybody with a 386 would have USB, but we still want to make
;         this compatible with the lowest level CPU that is reasonable (not
;         necessarily the easiest one to program).
;------------------------------------------------------------------------------
CvtEndianEAX:
  XCHG AL,AH  ;Swap the Low Bytes
  ROL  EAX,16 ;Move the Low Word to the High Word
  XCHG AL,AH  ;Swap the Low Bytes
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO LOOK FOR NEW USB DEVICES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;CHECK AND SEE IF THERE IS A NEW DEVICE CONNECTED, AND HANDLE IT IF IT IS
;Inputs:  DS = ES = Our Data Area
;         CLD already issued
;Outputs:
;Changes: Looks for new, unowned (unconfigured) Devices
;         If one is found, it is Configured and pointed at us
;         May change any or all registers!
;NOTES:   When we first install this program into memory, we Registered with
;           the USB Drivers that we wanted to be informed as soon as a new
;           Device was attached.  We also poll the hosts periodically for a
;           new Device, just in case we somehow missed the Host informing us.
;         Whether this is in response to the Host telling us, or whether we
;           polled to find out, this section of code is called.
;         This section of code is actually a series of short pieces of code,
;           which are disjointed in time.  One section schedules a USB Request
;           with the Host Driver, and gives the Host Driver the address
;           of the NEXT section of code to perform when the Request is
;           completed.
;         Requests sent to a USB Host can take anywhere from a few
;           milliseconds to several hundred milliseconds to complete.
;         It is very bad for a TSR to just sit around waiting for something
;           to happen, especially when it can be a long time in coming.
;         This back-and-forth approach between the Host Driver and the Device
;           Driver makes the TSR run pretty efficiently.
;         This process only goes as far as assigning Disk Numbers to LUNs,
;           and then sets a timer to initiate a separate process to search
;           for Drive Letters (which requires reading sectors from the disk
;           and deciphering partition information contained on the disk).
;           Performing the process this way allows us to handle devices
;           with removable media much easier, since we will need to continually
;           poll those types of Devices to know when media has been inserted
;           or removed.
;------------------------------------------------------------------------------
LookForNewDevice:
  CALL FindEmptyInfoBX              ;Look for an empty Info Table Entry (BX)
  JZ  >L901                         ;If none, just quit
  TEST TSRFlags,(Int14ReqInUse+SectBuffInUse) ;Resources available?
  JZ  >L05                          ;If so, continue
  MOV  NewDvcCounter,1              ;If not, try again at the next opportunity
  JMP >L901                         ;Done for now
L05:                                ;OK to issue
  OR   TSRFlags,(Int14ReqInUse+SectBuffInUse) ;If not, mark us as using it
  MOV  SI,Int14Request              ;Point at our Int 14 Structure
  MOV  [SI].I14RRequestType,I14RRTFindUnRegIntf ;Request Type = Find Interface
  MOV  [SI].I14RHostIndex,-1        ;Any/All Hosts
  MOV  [SI].I14RSearchIndex,0       ;Start with Search Index 0
L10:                                ;Loop to here to find Device
  CALL DoInt14CallCXDXSI            ;Do it (uses DS:SI, CH = Addr, CL = Host,
                                    ;  DL = Interface, DH = Alt Interface)
  JC  >L801                         ;If no device, we're done
  CALL TestBadDevice                ;If one there, is it in our Bad List?
  JC  >L20                          ;If not, continue
  INC  [SI].I14RSearchIndex         ;If so, Increment the Search Index
  JMP  L10                          ;Keep looking
L20:                                ;Found a possible Device!

  CMP  CX,W NewWaitHostIndex        ;Is it one we're already waiting for?
  JE  >L25                          ;If so, handle it
  MOV  AX,InitDelay                 ;If not, initialize
  MOV  NewWaitTimer,AX              ;  the Timer
  MOV  W NewWaitHostIndex,CX        ;Store the Host Index & Device Address
L25:                                ;Already waiting for it
  MOV  AX,NewWaitTimer              ;Have we waited
  OR   AX,AX                        ;  long enough?
  JZ  >L28                          ;If so, continue
  ADD  AX,4                         ;If not,
  MOV  NewDvcCounter,AX             ;  wait until looking again
  JMP >L801                         ;Done for now
L28:                                ;Have waited long enough
  MOV  NewWaitDvcAddress,0          ;Reset New Device Wait entry

  MOV  [SI].I14RRequestType,I14RRTConfigingIntf ;Request Type = Configing
  MOV  W [SI].I14RHostIndex,CX      ;Store Host Index & Device Address
  CALL DoInt14CallSaveAllSI         ;Do it
  JNC >L30                          ;If OK, continue
  MOV  NewDvcCounter,2              ;If not, Look again Soon
L801:                               ;To avoid JMP > 128
  JMP >L80                          ;Done for now
L901:                               ;To avoid JMP > 128
  JMP >L90
L30:                                ;OK to Configure Interface
  MOV  NewDeviceStage,0             ;Stage
  MOV  NewDeviceError,0             ;  Zero
  CALL ClearAllBuffs                ;Clear out the Disk/SCSI-related Buffers
  OR   [BX].DvcFlags,DvcFlagInUse   ;Mark Info Table entry as in use
  MOV  W [BX].DvcHostIndex,CX       ;Store Host Index
  MOV  W [BX].DvcInt14Request.I14RHostIndex,CX ;  & Device Address
  MOV  [BX].DvcInterfaceNum,DL      ;Store Interface Number
  MOV  [SI].I14RUserPktID,BX        ;Set User Pkt ID to Info Table Offset
  MOV  [SI].I14RRequestType,I14RRTDoControl ;Request Type = Control
  MOV  [SI].I14RInterfaceNum,DL     ;Store Interface Number
  MOV  [SI].I14REndPoint,0          ;EndPoint 0
  MOV  CX,SetAltIntfReq             ;Copy
  CALL CopySetupReqToInt14SI        ;  Request Pkt
  MOV  B [SI].I14RSetAltIntfIntf,DL          ;Store Interface in Request
  MOV  B [SI].I14RSetAltIntfAltIntf,DH       ;Store Alt Interface in Request
  MOV  W [SI].I14RCallBackAddr[0],AltIntfSet ;Go here when done
  CALL DoInt14CallAXSI              ;Do it
  JNC >L90                          ;If it worked, we're done
  MOV  NewDeviceStage,1              ;Update Stage
  CALL FinishUpBadDevice0           ;If not, mark it as bad
  JMP >L90                          ;Done
L80:                                ;No New Devices
  AND  TSRFlags,(NOT (Int14ReqInUse+SectBuffInUse)) ;Mark as available
L90:                                ;Done
  RET                               ;NOT RETF here!

;------------------------------------------------------------------------------
;Inputs: [BX] = Device Info Table Pointer
;NOTE: Some Devices will not accept a Set Alternate Interface Request,
;        so an error here does not necessarily indicate a bad Device!
;------------------------------------------------------------------------------
AltIntfSet:
  MOV  NewDeviceStage,6      ;Update Stage
  MOV  SI,Int14Request       ;Point at Int14 Request Structure
  MOV  CX,GetDvcDescrReq     ;Copy
  CALL CopySetupReqToInt14SI ;  Request Pkt
  MOV  W [SI].I14RDataAddress[0],DvcDescrData    ;Put data here
  MOV  W [SI].I14RCallBackAddr[0],GotDeviceDescr ;Go here when done
  CALL DoInt14CallAXSI       ;Do it
  JNC >I90                   ;If it worked, we're done
  MOV  NewDeviceStage,7      ;Update Stage
I70:                         ;Error
  CALL FinishUpBadDevice0    ;Mark it as Bad
I90:                         ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Device Info Table Pointer
;------------------------------------------------------------------------------
GotDeviceDescr:
  MOV  NewDeviceStage,12     ;Update Stage
  JNZ >D70                   ;If Error, handle it
  CALL TestUnLockable        ;Check for Known Unlockable Devices
  MOV  SI,Int14Request       ;Point at Int14 Request Structure
  MOV  CX,GetCfgDescrReq     ;Copy
  CALL CopySetupReqToInt14SI ;  Request Pkt
  MOV  W [SI].I14RDataAddress[0],DescriptorData  ;Put data here
  MOV  W [SI].I14RCallBackAddr[0],GotConfigDescr ;Go here when done
  CALL ClearDescriptorData   ;Clear out the data buffer
  CALL DoInt14CallAXSI       ;Do it
  JNC >D90                   ;If it worked, we're done
  MOV  NewDeviceStage,13     ;Update Stage
D70:                         ;Error
  CALL FinishUpBadDevice0    ;Mark it as Bad
D90:                         ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Device Info Table Pointer
;------------------------------------------------------------------------------
GotConfigDescr:
  MOV  NewDeviceStage,18     ;Update Stage
  JNZ >O70                   ;If Error, handle it
  MOV  NewDeviceStage,100    ;Update Stage
  MOV  DI,DescriptorData     ;Point at Config Descriptor Data
  MOV  SI,Int14Request       ;Point at Int14 Request Structure
  MOV  AX,[DI].CDTotalLength ;Get length of entire Descriptor
  CMP  AX,MaxDescriptorSize  ;Will it fit in our buffer?
  JAE >O70                   ;If not, error
  MOV  CX,GetCfgDescrReq     ;Copy
  CALL CopySetupReqToInt14SI ;  Request Pkt
  MOV  W [SI].I14RGetCfgDescrSize,AX ;Store the number of bytes
  MOV  W [SI].I14RCallBackAddr[0],GotCompleteConfig ;Go here when done
  CALL DoInt14CallAXSI       ;Do it
  JNC >O90                   ;If it worked, we're done
  MOV  NewDeviceStage,19     ;Update Stage
O70:                         ;Error
  CALL FinishUpBadDevice0    ;Mark it as Bad
O90:                         ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Device Info Table Pointer
;------------------------------------------------------------------------------
GotCompleteConfig:
  MOV  NewDeviceStage,24             ;Update Stage
  JNZ >C701                          ;If Error, handle it
  MOV  NewDeviceStage,105            ;Update Stage
  MOV  SI,Int14Request               ;Point at Int14 Request Structure
  MOV  DI,DescriptorData             ;Point at Config Data
  MOV  DL,[BX].DvcInterfaceNum       ;Interface Number to look for
C10:                                 ;Loop to find Interface Descriptor
  MOV  AL,DescrTypeInterface         ;Look for an Interface
  CALL FindDescrType                 ;  Descriptor (rtns AX, DI)
  JC  >C70                           ;If none found, Error
  CMP  [DI].IDInterfaceNumber,DL     ;Is it the Correct Interface?
  JE  >C20                           ;If so, continue
  ADD  DI,AX                         ;If not, point at the next Descr
  JMP  C10                           ;Keep looking
C20:                                 ;Found the Interface Descriptor
  MOV  NewDeviceStage,106            ;Update Stage
  MOV  AX,W [DI].IDInterfaceSubClass ;AL = SubClass, AH = Protocol
  CMP  AL,IntfSubClassUFI            ;UFI, 8070i, or SCSI?
  JB  >C70                           ;If not, Error
  CMP  AL,IntfSubClassSCSI           ;UFI, 8070i, or SCSI?
  JA  >C70                           ;If not, Error
  CMP  AH,IntfProtocolCBI            ;Ctrl-Bulk-Interrupt?
  JE  >C30                           ;If so, continue
  CMP  AH,IntfProtocolBulkOnly       ;Bulk-only?
  JNE >C70                           ;If not, Error
C30:                                 ;Device is what we're looking for
  MOV  NewDeviceStage,107            ;Update Stage
  MOV  W [BX].DvcIntfSubClass,AX     ;Store the SubClass & Protocol
  CALL GetEndPointNums               ;Get the EndPoint Numbers
  JC  >C70                           ;If Error, quit
  MOV  W [SI].I14RCallBackAddr[0],GotMaxLUN0 ;Go here when done
  CMP  AH,IntfProtocolBulkOnly       ;Is it Bulk Only?
  JNE >C50                           ;If not, continue
C40:                                 ;Bulk Only
  MOV  CX,GetMaxLUNReq               ;Copy
  CALL CopySetupReqToInt14SI         ;  Request Packet
  MOV  B [SI].I14RGetMaxLUNIntf,DL   ;Store Interface Number
  LEA  AX,[BX].DvcMaxLUN             ;Where to put
  MOV  W [SI].I14RDataAddress[0],AX  ;  the Data
  CALL DoInt14CallAXSI               ;Do it
  JNC >C90                           ;If OK, we're done
  MOV  NewDeviceStage,25             ;Update Stage
C701:                                ;To avoid JMP > 128
  JMP >C70                           ;If not, Error
C50:                                 ;Not Bulk Only
  MOV  [SI].I14RRequestType,I14RRTDoInterrupt1T ;Set up One-time Interrupt
  MOV  [SI].I14RPeriodicity,1        ;Wait 1 Millisecond
  CALL DoInt14CallAXSI               ;Do it
  JNC >C90                           ;If it worked, we're done
  MOV  NewDeviceStage,27             ;Update Stage
C70:                                 ;Error
  CALL FinishUpBadDevice0            ;Mark it as Bad
C90:                                 ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Device Info Table Pointer
;NOTES: The GetMaxLUN Request that this follows may return with an
;         Error if the Device only has one LUN (MaxLUN = 0).
;         According to the spec, it should return with a STALL error, but
;         at least one Device does not (it returns with simply a Short
;         Packet error), so we can't test the error for validity.
;------------------------------------------------------------------------------
GotMaxLUN0:
  MOV  NewDeviceStage,110 ;Update Stage
  XOR  AL,AL              ;Start with LUN 0
  CALL StartNextLUN       ;Start getting the LUN details
  JNC >L90                ;If OK, we're done
  MOV  NewDeviceStage,111 ;Update Stage
L70:                      ;Error
  CALL FinishUpBadDevice0 ;Mark it as Bad
L90:                      ;Done
  RETF

;------------------------------------------------------------------------------
;INITIALIZE THE NEXT LUN (DISK) SUBSEQUENCE IN LOOKFORNEWDEVICE
;Inputs:   DS = ES = TSR Data Area
;         [BX] = Device Info Entry
;          AL  = LUN Number to use
;         Int14Request = Request to use to Perform USB Requests
;Outputs: CF = Clear if OK (Disk Info Entry available)
;              Sequence initiated to get Disk Details
;              Stores AL in Current LUN
;            = Set if Error
;              AX = Error Code to Store
;         Stores AL in Current LUN
;Changes:
;------------------------------------------------------------------------------
StartNextLUN:
  PUSH BX,DI                ;Save used registers
  MOV  CurrentLUN,AL        ;Store LUN Number
  CALL GetAvailDiskDI       ;Get an available Disk Entry ([DI], DskStageStartup)
  JC  >X70                  ;If none available, error
  MOV  [DI].DskDvcOffset,BX ;Store the Device Info Pointer
  MOV  [DI].DskLUN,AL       ;Store the LUN Number
  MOV  Int14Request.I14RUserPktID,DI ;User Packet ID = Disk Info
  XCHG BX,DI                ;[BX] = Disk, [DI] = Device
  MOV  NextSCSIReqOffset,GotInquiry  ;Go here when done
  CALL SCSIInquiryBG        ;Start the Inquiry Request
  JC  >X70                  ;If error, quit
  CALL SetupSCSIDone        ;Issue the Request
  JNC >X80                  ;If OK, we're done
X70:                        ;Error
  STC                       ;Set return flag
  JMP >X90                  ;Done
X80:                        ;OK
  CLC                       ;Set return flag
X90:                        ;Done
  POP  DI,BX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs: [BX] = Disk Info Table Pointer
;NOTES: This processes the data from the SCSI Inquiry Request to make
;         sure the attached Device is really DASD (a Disk Drive of some
;         sort).
;       There are other things in the Inquiry Data besides the Device
;         Type SCSIx Data/Response formats, etc.) that may be useful at
;         some point in time, but I think we can ignore them for now.
;       The Removable Media Flag in the Inquiry Response always seems
;         to be set for USB Drives, even though I think technically
;         they are a removable drive, not a drive with removable media.
;         Anyway, bottom line, we can't use the flag to determine if the
;         disk actually has removable media or not.  The only thing we can
;         do (at least for now) is assume only UFI (Floppy) devices have
;         removable media.  We may need to figure out a better method
;         in the future.
;       Some multi-LUN devices only respond to an Inquiry Request
;         on LUN 0, so an error on any other LUN isn't necessarily a
;         bad device
;------------------------------------------------------------------------------
GotInquiry:
  CALL SetupRETFRegs2                  ;[BX] = Disk, [DI] = Device,
                                       ;[SI] = Int14Request, AX = Error
  MOV  NewDeviceStage,115              ;Update Stage
  JZ  >Q05                             ;If OK, continue
  CMP  [BX].DskLUN,0                   ;Is it LUN 0?
  JE  >Q70                             ;If so, it's really an error
Q05:                                   ;Got Inquiry Data
  MOV  NewDeviceStage,116              ;Update Stage
  CMP  InquiryBuff.SInqRespAddLength,0 ;Valid Inquiry Response?
  JE  >Q70                             ;If not, Error
  MOV  NewDeviceStage,117              ;Update Stage
  OR   TSRFlags,NoBeep1Time            ;Don't Beep if incorrect Device Type
  MOV  AL,InquiryBuff.SInqRespPDT      ;AL =
  MOV  AH,AL                           ;  Peripheral Device Type
  AND  AL,PDTMask                      ;AH =
  AND  AH,PDQMask                      ;  Peripheral Device Qualifier
  CMP  AL,PDTDirect                    ;Is it DASD (a Disk Drive)?
  JNE >Q70                             ;If not, Error
  MOV  NewDeviceStage,118              ;Update Stage
  CMP  AH,PDQPossible                  ;Is it currently connected?
  JNE >Q70                             ;If not, Error
  AND  TSRFlags,(NOT NoBeep1Time)      ;Allow Beeps again
  MOV  NextSCSIReqOffset,GotUnitReady  ;Go here when done
  CALL SCSITestReadyBG                 ;Start the Request
  JC  >Q70                             ;If error, quit
  CALL SetupSCSIDone                   ;Issue the Request
  JNC >Q90                             ;If it worked, we're done
  MOV  NewDeviceStage,119              ;Update Stage
Q70:                                   ;Error
  CALL FinishUpBadDevice               ;Mark it as Bad
Q90:                                   ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Disk Info Table Pointer
;------------------------------------------------------------------------------
GotUnitReady:
  CALL SetupRETFRegs2                ;[BX] = Disk, [DI] = Device,
                                     ;[SI] = Int14Request, AX = Error
  MOV  NewDeviceStage,120            ;Update Stage
  JZ  >R20                           ;If Request worked, continue
;  CALL TestSanDiskErrBX              ;If not, SanDisk "Medium Not Present"?
;  JC  >R20                           ;If so, pretend it's not an Error
R10:                                 ;Unit is Not Ready
  MOV  AX,GotDiskSize                ;[AX] = Where to go when done
  CALL Start1TimeIntSI               ;Issue a 1-time Interrupt
  JNC >R90                           ;If it worked, we're done
  MOV  NewDeviceStage,121            ;Update Stage
  JMP >R70                           ;Error
R20:                                 ;Unit is Ready
  CMP  [DI].DvcMaxLun,0              ;Is this a multiple-LUN Device?
  JNE >R40                           ;If so, don't issue Fmt Capacity Request
R30:                                 ;Single-LUN Device
  MOV  NextSCSIReqOffset,GotFmtCap   ;Go here when done
  CALL SCSIFmtCapacityBG             ;Start the Request
  CALL SetupSCSIDone                 ;Issue the Request
  JNC >R90                           ;If it worked, we're done
  MOV  NewDeviceStage,122            ;Update Stage
  JMP >R70                           ;Error
R40:                                 ;Multiple-LUN Device
  MOV  NextSCSIReqOffset,GotCapacity ;Go here when done
  CALL SCSICapacityBG                ;Start the Request
  JC  >R70                           ;If error, quit
  CALL SetupSCSIDone                 ;Issue the Request
  JNC >R90                           ;If it worked, we're done
  MOV  NewDeviceStage,123            ;Update Stage
R70:                                 ;Error
  CALL FinishUpBadDevice             ;Mark it as Bad
R90:                                 ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Disk Info Table Pointer
;------------------------------------------------------------------------------
GotFmtCap:
  CALL SetupRETFRegs2                 ;[BX] = Disk, [DI] = Device,
                                      ;[SI] = Int14Request, AX = Error
  MOV  NewDeviceStage,130             ;Update Stage
  JNZ >F40                            ;If error, issue alternate request
  MOV  NewDeviceStage,131             ;Update Stage
  MOV  BP,FmtCapacityBuff             ;Is it a
  CALL TestFmtCapDescr                ;  valid Descriptor?
  JC  >F40                            ;If not, continue to next stage
F20:                                  ;Valid Descriptor
  MOV  NewDeviceStage,132             ;Update Stage
  MOV  AX,W DS:[BP].FDescBlockLength[1][4] ;AX =
  XCHG AL,AH                              ;  Bytes per Sector
  CMP  AX,MaxBytesPerSect             ;Is it too big for DOS to handle?
  JA  >F70                            ;If so, Error
  MOV  [BX].DskBytesPerSect,AX        ;If OK, store it
  MOV  EAX,DS:[BP]..FDescNumBlocks[4] ;Get the
  CALL CvtEndianEAX                   ;  Number of Sectors
  MOV  [BX].DskMaxLBA,EAX             ;Store Max LBA
F40:                                  ;Issue Mode Sense Request
  MOV  NextSCSIReqOffset,GotCapacity  ;Go here when done
  CALL SCSICapacityBG                 ;Start the Request
  JC  >F70                            ;If error, quit
  CALL SetupSCSIDone                  ;Issue the Request
  JNC >F90                            ;If it worked, we're done
  MOV  NewDeviceStage,133             ;Update Stage
F70:                                  ;Error
  CALL FinishUpBadDevice              ;Mark it as Bad
F90:                                  ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Disk Info Table Pointer
;------------------------------------------------------------------------------
GotCapacity:
  CALL SetupRETFRegs2                   ;[BX] = Disk, [DI] = Device,
                                        ;[SI] = Int14Request, AX = Error
  MOV  [BX].DskDrvTimer,DskStageInProc  ;Mark as In Process (past Startup Stage)
  MOV  NewDeviceStage,135               ;Update Stage
  JNZ >Y40                              ;If error, issue alternate request
  MOV  NewDeviceStage,136               ;Update Stage
  MOV  BP,CapacityBuff                  ;Is it a
  CALL TestCapDescr                     ;  valid Descriptor?
  JC  >Y40                              ;If not, continue to next stage
Y20:                                    ;Valid Descriptor
  MOV  NewDeviceStage,137               ;Update Stage
  MOV  AX,W DS:[BP].FDescBlockLength[1] ;AX =
  XCHG AL,AH                            ;  Bytes per Sector
  CMP  AX,MaxBytesPerSect               ;Is it too big for DOS to handle?
  JA  >Y70                              ;If so, Error
  MOV  [BX].DskBytesPerSect,AX          ;If OK, store it
  MOV  EAX,DS:[BP].FDescNumBlocks       ;Get the
  CALL CvtEndianEAX                     ;  Number of Sectors
  MOV  [BX].DskMaxLBA,EAX               ;Store Max LBA
Y40:                                    ;Issue Get Capacity Request
  MOV  NextSCSIReqOffset,GotFlexPage    ;Go here when done
  CALL SCSIFlexPageBG                   ;Issue Mode Sense Request
  JC  >Y70                              ;If error, quit
  CALL SetupSCSIDone                    ;Issue the Request
  JNC >Y90                              ;If it worked, we're done
  MOV  NewDeviceStage,138               ;Update Stage
Y70:                                    ;Error
  CALL FinishUpBadDevice                ;Mark it as Bad
Y90:                                    ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Disk Info Table Pointer
;At least one disk (an external 500 MB LaCie Hard Drive, with a Samsung disk
;  inside) does not return a complete Flex Page descriptor.  It only returns
;  the first several bytes, up to and including the CHS values (which is
;  what we're looking for).  Therefore, if the only error is a Short Packet
;  and some data was actually sent, the drive is probably OK.
;Some Flash Drives do not return a Flex Page at all.  In those cases,
;  we'll assume the disk is writable and just calculate the CHS values
;  ourselves based on the Max LBA.
;At least one Flash Drive (Toshiba) does not respond to either the
;  Get Capacity or Get Format Capacity Request, so when we get to here neither
;  the Sector Size nor the Max LBA is filled in (even though they should be).
;  In those cases, if we don't get a Flex Page descriptor either, we'll
;  finally give up since we can't figure out the capacity of the drive.  If
;  we do get the Flex Descriptor even though we didn't get either of the
;  Capacity Descriptors, we'll calculate the Max LBA based on the CHS values
;  returned in the Flex Descriptor, and also get the sector size from
;  the Flex Decriptor.
;There is a WriteProtect flag in the SCSI data, but it seems to be inaccurate,
;  at least for some drives.  Therefore, we ignore it here and just use the
;  SCSI error codes to determine if the disk is write-protected or not.  It
;  would be nice to do it here, since we could return immediately with a
;  write-protect error instead of actualyl needing to wait for the disk to
;  respond, but we can't.
;------------------------------------------------------------------------------
GotFlexPage:
  CALL SetupRETFRegs2                 ;[BX] = Disk, [DI] = Device,
                                      ;[SI] = Int14Request, AX = Error
  MOV  NewDeviceStage,140             ;Update Stage
  MOV  BP,ModeSenseBuff               ;[BP] = Data Buffer
  CALL TestFlexDescr                  ;Valid Data?
  JC  >X40                            ;If not, we're done
X10:                                  ;Flex Data is valid
  MOV  NewDeviceStage,141             ;Update Stage
  CMP  [BX].DskBytesPerSect,0         ;Did we get any valid Capacity Data?
  JNE >X20                            ;If so, just get simple Flex Data
  MOV  NewDeviceStage,142             ;Update Stage
  CALL CopyFlexData                   ;If not, get Capacity from Flex Data
  JC  >X40                            ;If invalid data, we're done
X20:                                  ;Test Write Protection
;  MOV  AL,DS:[BP].MPH6Flags           ;Assume Mode Sense 6
;  CMP  B DS:[BP],0                    ;Is it Mode Sense 6?
;  JNE >X32                            ;If so, continue
;X31:                                  ;Mode Sense 10
;  MOV  AL,DS:[BP].MPH10Flags          ;Mode Sense 10
;X32:                                  ;AL = MPHFlags
;  TEST AL,MPHWriteProt                ;Is it Write Protected?
;  JZ  >X35                            ;If not, continue
;  OR   [BX].DskFlags,DskFlagWriteProt ;Set our Write-protect flag
;X35:                                  ;Write-protect handled
  MOV  AX,ModeParam6HdrSize           ;Assume Mode Sense 6
  CMP  B DS:[BP],0                    ;Is it Mode Sense 6?
  JNE >X30                            ;If so, continue
  MOV  AX,ModeParam10HdrSize          ;If not, Mode Sense 10
X30:                                  ;AX = Correct Offset to Use
  ADD  BP,AX                          ;Point at Flex Data
  XOR  AH,AH                          ;Store
  MOV  AL,DS:[BP].FlexNumHeads        ;  Number
  MOV  [BX].DskNumHeads,AX            ;  of Heads
  MOV  AL,DS:[BP].FlexSectsPerTrack   ;Store Number
  MOV  [BX].DskSectsPerTrack,AX       ;  of Sectors Per Track
  MOV  AX,DS:[BP].FlexNumCylinders    ;Store Number
  XCHG AL,AH                          ;  of Cylinders
  MOV  [BX].DskNumTracks,AX           ;  (Tracks)
X40:                                  ;CHS values filled in
  MOV  AX,GotDiskSize                 ;[AX] = Where to go when done
  CALL Start1TimeIntSI                ;Issue a 1-time Interrupt
  JNC >X90                            ;If it worked, we're done
  MOV  NewDeviceStage,144             ;Update Stage
X70:                                  ;Error
  CALL FinishUpBadDevice              ;Mark it as Bad
X90:                                  ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Disk Info Table Pointer
;------------------------------------------------------------------------------
GotDiskSize:
  CALL SetupRETFRegs2         ;[BX] = Disk, [DI] = Device,
                              ;[SI] = Int14Request, AX = Error
  MOV  NewDeviceStage,145     ;Update Stage
  CALL AdjustCHSValues        ;Calculate CHS Values
  CALL FillInFDPTParams       ;Fill in FBDT Table if needed
  MOV  [BX].DskAccessTimer,-1 ;Assume not removable media
  CMP  [DI].DvcIntfSubClass,IntfSubClassUFI ;Is this a Floppy (UFI)?
  JE  >K10                    ;If so, it has Removable Media
  CMP  [DI].DvcMaxLUN,0       ;Are there multiple LUNs?
  JE  >K15                    ;If not, assume not removable media
K10:                          ;Removable Media
  MOV  [BX].DskAccessTimer,0  ;Mark as Removable media
K15:                          ;Removable Media handled
  MOV  [BX].DskDrvTimer,DskStageNewDisk ;Mark as a new Disk
  MOV  AL,CurrentLUN          ;Get the Current LUN Number
  INC  AL                     ;Increment by one
  CMP  AL,[DI].DvcMaxLUN      ;Have we already done all of the LUNs?
  JA  >K30                    ;If so, handle it
K20:                          ;Need to process another LUN
  MOV  BX,DI                  ;[BX] = Device Info Entry
  CALL StartNextLUN           ;Start getting the LUN details
  JNC >K90                    ;If it worked, we're done
  MOV  NewDeviceStage,146     ;Update Stage
  CALL FinishUpBadDevice0     ;Mark it as Bad
  JMP >K90                    ;Done
K30:                          ;Have already processed all of the LUNs
  MOV  NewDeviceStage,147     ;Update Stage
  MOV  AX,DoRegistry          ;[AX] = Where to go when done
  CALL Start1TimeIntSI        ;Issue a 1-time Interrupt
  JNC >K90                    ;If it worked, we're done
K70:                          ;Error
  CALL FinishUpBadDevice      ;Mark it as Bad
K90:                          ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Drive Info Table Pointer
;       This may also follow a One-Time Interrupt, which should never
;           return a STALL.
;       There is at least one Bulk-Only Device out there that has
;         an Interrupt End Point (which is not possible according to the
;         Bulk-Only Specification).  There is nothing in the Standard
;         that defines what kind of data is returned by the Interrupt.
;         I suppose we could assume that it is the same as the CBI Data,
;         but there would be no guarantee.  Therefore, at least for now,
;         we will NOT setup the Periodic Interrupt unless the
;         Device claims it is CBI.  This may need to change later on.
;------------------------------------------------------------------------------
DoRegistry:
  CALL SetupRETFRegs2         ;[BX] = Disk, [DI] = Device,
                              ;[BP] = Drive, [SI] = Int14Request,
                              ;AX = Error
  MOV  NewDeviceStage,96      ;Update Stage
  MOV  LastDeviceFound,DI     ;Mark this as the Last Device
  MOV  [SI].I14RRequestType,I14RRTRegIntfOwner ;Register as Owner
  MOV  [SI].I14RUserPktID,DI  ;User Packet ID = Device Info
  MOV  W [SI].I14RCallBackAddr[0],DvcOwnerFarCall ;Owner Address
  CALL DoInt14CallAXCXSI      ;Do it
  MOV  [DI].DvcRegHandle,CX   ;Store the Registry Handle
  JNC >R80                    ;If it worked, we're done
R70:                          ;Error (DX contains orig BX)
  CALL FinishUpBadDevice      ;Mark it as Bad
  JMP >R90                    ;Done
R80:                          ;Device is OK
  MOV  NewDeviceStage,97      ;Update Stage
  MOV  [SI].I14RRequestType,I14RRTConfigIntfDone ;Request = Done Configuring
  CALL DoInt14CallSaveAllSI   ;Do it
  CMP  NewDvcCounter,0        ;Int 08 Disabled?
  JE  >R85                    ;If so, quit
  MOV  NewDvcCounter,2        ;Look for another Device soon
R85:                          ;Done for now
  AND  TSRFlags,(NOT (Int14ReqInUse+SectBuffInUse)) ;Mark as available
R90:                          ;Done
  RETF


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO LOOK FOR USB DRIVES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;LOOK FOR NEW DRIVE LETTERS FOR A SPECIFIC DISK
;Inputs:   DS = ES = TSR Data Area
;         [BX] = Disk Entry to use
;         [BX].DskDrive Timer reset to look again next time
;         TSRFlags.Int14RequestInUse, TSRFlags.SectBuffInUse set
;Outputs:
;Changes:
;NOTES: This is called as a separate process than LookForNewDevice, which
;         assigns Int 13h Disk Numbers.  Originally, they were combined
;         (this directly followed LookForNewDevice), but that made it much
;         more difficult to handle removable media (like floppy drives),
;         since we need to perform this process again (separately) to
;         look for media changes anyway.
;       So, we just made it a separate process, even though it technically
;         doesn't need to be if we're dealing with flash drives and disk
;         drives with permanent media.
;------------------------------------------------------------------------------
LookForNewDrive:
  PUSH BX,CX,DI,SI                     ;Save used registers
  MOV  DI,[BX].DskDvcOffset            ;[DI] = Device Info Entry
  TEST [DI].DvcFlags,DvcFlagNoLock     ;Is it a known Unlockable Device?
  JZ  >V20                             ;If not, continue
  OR   [BX].DskFlags2,DskFlagNoLock    ;If so, it's an Unlockable Disk
V20:                                   ;Unlockable transferred, if appropriate
  MOV  SI,Int14Request                 ;[SI] = Int14Request
  MOV  [SI].I14RUserPktID,BX           ;User Packet ID = Disk Info
  MOV  CL,[DI].DvcHostIndex            ;Copy the
  MOV  [SI].I14RHostIndex,CL           ;  Host Index
  MOV  NextSCSIReqOffset,GotUnitReady2 ;Go here when done
  CALL SCSITestReadyBG                 ;Issue Test Unit Ready
  JC  >V70                             ;If error, quit
  CALL SetupSCSIDone                   ;Issue the Request
  JNC >V90                             ;If it worked, we're done
  MOV  NewDeviceStage,150              ;Update Stage
V70:                                   ;Error
  CALL FinishUpBadDrive                ;Mark it as Bad
V90:                                   ;Done
  POP  SI,DI,CX,BX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs: [BX] = Disk Info Table Pointer
;------------------------------------------------------------------------------
GotUnitReady2:
  CALL SetupRETFRegs2     ;[BX] = Disk, [DI] = Device,
                          ;[SI] = Int14Request, AX = Error
  MOV  NewDeviceStage,155 ;Update Stage
  JZ  >Q20                ;If OK, continue
;  CALL TestSanDiskErrBX   ;If not, SanDisk "Medium Not Present"?
;  JC  >Q20                ;If so, pretend it's not an Error
  MOV  AX,W [BX].DskSenseBuffer.SReqSRespAddSenseCode
                          ;AL = ASC, AH = ASCQ
  CMP  AL,3Ah             ;Any Media?
  JE  >Q70                ;If not, quit
  CMP  AL,30h             ;Invalid/corrupted Media?
  JE  >Q70                ;If so, quit
Q20:                      ;Media is OK
  MOV  NextSCSIReqOffset,GotCapacity2 ;Go here when done
  CALL SCSICapacityBG     ;Issue Test Unit Ready Request
  JC  >Q70                ;If error, quit
  CALL SetupSCSIDone      ;Issue the Request
  JNC >Q90                ;If it worked, we're done
  MOV  NewDeviceStage,156 ;Update Stage
Q70:                      ;Error
  CALL FinishUpBadDrive   ;We're done
Q90:                      ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Disk Info Table Pointer
;NOTE: If the disk has removable media (like a floppy), until a disk is
;        actually inserted, any of the size data retrieved previously
;        will be a maximum size, not necessarily an actual size.
;      For instance, you can put a 720kB floppy in a 1.44MB slot,
;        but the computer can't know what size it is until you actually
;        insert the media.
;------------------------------------------------------------------------------
GotCapacity2:
  CALL SetupRETFRegs2                   ;[BX] = Disk, [DI] = Device,
                                        ;[SI] = Int14Request, AX = Error
  MOV  NewDeviceStage,165               ;Update Stage
  JNZ >Y40                              ;If error, issue alternate request
  MOV  NewDeviceStage,166               ;Update Stage
  MOV  BP,CapacityBuff                  ;Is it a
  CALL TestCapDescr                     ;  valid Descriptor?
  JC  >Y40                              ;If not, continue to next stage
Y20:                                    ;Valid Descriptor
  MOV  NewDeviceStage,167               ;Update Stage
  MOV  AX,W DS:[BP].FDescBlockLength[1] ;AX =
  XCHG AL,AH                            ;  Bytes per Sector
  CMP  AX,MaxBytesPerSect               ;Is it too big for DOS to handle?
  JA  >Y70                              ;If so, Error
  MOV  [BX].DskBytesPerSect,AX          ;If OK, store it
  MOV  EAX,DS:[BP].FDescNumBlocks       ;Get the
  CALL CvtEndianEAX                     ;  Number of Sectors
  MOV  [BX].DskMaxLBA,EAX               ;Store Max LBA
Y40:                                    ;Issue Get Capacity Request
  MOV  NextSCSIReqOffset,GotFlexPage2   ;Go here when done
  CALL SCSIFlexPageBG                   ;Issue Mode Sense Request
  JC  >Y70                              ;If error, quit
  CALL SetupSCSIDone                    ;Issue the Request
  JNC >Y90                              ;If it worked, we're done
  MOV  NewDeviceStage,168               ;Update Stage
Y70:                                    ;Error
  CALL FinishUpBadDrive                 ;We're done
Y90:                                    ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Disk Info Table Pointer
;At least one disk (an external 500 MB LaCie Hard Drive, with a Samsung disk
;  inside) does not return a complete Flex Page descriptor.  It only returns
;  the first several bytes, up to and including the CHS values (which is
;  what we're looking for).  Therefore, if the only error is a Short Packet
;  and some data was actually sent, the drive is probably OK.
;Some Flash Drives do not return a Flex Page at all.  In those cases,
;  we'll assume the disk is writable and just calculate the CHS values
;  ourselves based on the Max LBA.
;------------------------------------------------------------------------------
GotFlexPage2:
  CALL SetupRETFRegs2                 ;[BX] = Disk, [DI] = Device,
                                      ;[SI] = Int14Request, AX = Error
  MOV  NewDeviceStage,170             ;Update Stage
  MOV  BP,ModeSenseBuff               ;[BP] = Data Buffer
  CALL TestFlexDescr                  ;Valid Data?
  JC  >X40                            ;If not, we're done
X10:                                  ;Flex Data is valid
  MOV  NewDeviceStage,171             ;Update Stage
  CMP  [BX].DskBytesPerSect,0         ;Did we get any valid Capacity Data?
  JNE >X20                            ;If so, just get simple Flex Data
  MOV  NewDeviceStage,172             ;Update Stage
  CALL CopyFlexData                   ;If not, get Capacity from Flex Data
  JC  >X40                            ;If invalid data, we're done
X20:                                  ;Test Write Protection
  MOV  NewDeviceStage,173             ;Update Stage
  MOV  AL,DS:[BP].MPH6Flags           ;Assume Mode Sense 6
  CMP  B DS:[BP],0                    ;Is it Mode Sense 6?
  JNE >X32                            ;If so, continue
X31:                                  ;Mode Sense 10
  MOV  AL,DS:[BP].MPH10Flags          ;Mode Sense 10
X32:                                  ;AL = MPHFlags
  TEST AL,MPHWriteProt                ;Is it Write Protected?
  JZ  >X35                            ;If not, continue
  OR   [BX].DskFlags,DskFlagWriteProt ;Set our Write-protect flag
X35:                                  ;Write-protect handled
  MOV  AX,ModeParam6HdrSize           ;Assume Mode Sense 6
  CMP  B DS:[BP],0                    ;Is it Mode Sense 6?
  JNE >X37                            ;If so, continue
  MOV  AX,ModeParam10HdrSize          ;If not, Mode Sense 10
X37:                                  ;AX = Correct Offset to Use
  ADD  BP,AX                          ;Point at Flex Data
  XOR  AH,AH                          ;Store
  MOV  AL,DS:[BP].FlexNumHeads        ;  Number
  MOV  [BX].DskNumHeads,AX            ;  of Heads
  MOV  AL,DS:[BP].FlexSectsPerTrack   ;Store Number
  MOV  [BX].DskSectsPerTrack,AX       ;  of Sectors Per Track
  MOV  AX,DS:[BP].FlexNumCylinders    ;Store Number
  XCHG AL,AH                          ;  of Cylinders
  MOV  [BX].DskNumTracks,AX           ;  (Tracks)
X40:                                  ;CHS values filled in
  CMP  [BX].DskBytesPerSect,0         ;Got a valid size?
  JNE >X45                            ;If so, continue
  CMP  [BX].DskNumHeads,0             ;Got a valid size?
  JE  >X70                            ;If not, quit
X45:                                  ;Got valid data
  MOV  AX,UnitLocked                  ;[AX] = Where to go when done
  TEST [BX].DskFlags2,DskFlagNoLock   ;Should we issue Lock Requests?
  JZ  >X60                            ;If so, continue
X50:                                  ;Don't issue Lock Request
  CALL Start1TimeIntSI                ;Issue a 1-time interrupt
  JNC >X90                            ;If it worked, we're done
  MOV  NewDeviceStage,174             ;Update Stage
  JMP >X70                            ;Error
X60:                                  ;Issue Lock Request
  MOV  NextSCSIReqOffset,AX           ;Go here when done
  CALL SCSILockUnitBG                 ;Start the Lock Unit Request
  JC  >X70                            ;If error, quit
  CALL SetupSCSIDone                  ;Issue the Request
  JNC >X90                            ;If it worked, we're done
  MOV  NewDeviceStage,175             ;Update Stage
X70:                                  ;Error
  CALL FinishUpBadDrive               ;We're done
X90:                                  ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Disk Info Table Pointer
;NOTES: Some devices reject or ignore Lock Medium Requests, so an error here
;         is not necessarily a reason to stop.
;------------------------------------------------------------------------------
UnitLocked:
  CALL SetupRETFRegs2       ;[BX] = Disk, [DI] = Device,
                            ;[SI] = Int14Request, AX = Error
  MOV  NewDeviceStage,180   ;Update Stage
  JZ  >L10                  ;If no error, continue
  OR   [BX].DskFlags2,DskFlagNoLock ;If error, mark as Locks invalid
L10:                        ;Lock flag updated, if appropriate
  MOV  AX,UnitStarted       ;[AX] = Where to go when done
  CMP  [DI].DvcIntfSubClass,IntfSubClassUFI ;Is this a Floppy?
  JNE >L15                  ;If not, continue
  OR   [BX].DskFlags2,DskFlagNoStart ;If so, Start/Stop is automatic
L15:                        ;Floppy test handled, if needed
  TEST [BX].DskFlags2,DskFlagNoStart ;Should we issue Start Requests?
  JZ  >L40                  ;If so, continue
L20:                        ;Don't issue Lock Request
  CALL Start1TimeIntSI      ;Issue a 1-time interrupt
  JNC >L90                  ;If it worked, we're done
  MOV  NewDeviceStage,181   ;Update Stage
  JMP >L70                  ;Error
L40:                        ;Issue Lock Request
  MOV  NextSCSIReqOffset,AX ;Go here when done
  CALL SCSIStartUnitBG      ;Start the Start Motor Request
  JC  >L70                  ;If error, quit
  CALL SetupSCSIDone        ;Issue the Request
  JNC >L90                  ;If it worked, we're done
  MOV  NewDeviceStage,182   ;Update Stage
L70:                        ;Error
  CALL FinishUpBadDrive     ;We're done
L90:                        ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Disk Info Table Pointer
;NOTES: Some devices reject or ignore Start Motor Requests, so an error here
;         is not necessarily a reason to stop.
;------------------------------------------------------------------------------
UnitStarted:
  CALL SetupRETFRegs2      ;[BX] = Disk, [DI] = Device,
                           ;[SI] = Int14Request, AX = Error
  MOV  NewDeviceStage,185  ;Update Stage
  JZ  >R10                 ;If no error, continue
  OR   [BX].DskFlags2,DskFlagNoStart ;If error, mark as Starts invalid
R10:                       ;Start flag updated, if appropriate
  CALL InitPartStack       ;Initialize Partition Stack
  XOR  EAX,EAX             ;Start with Sector 0 & LUN 0
  MOV  NextSCSIReqOffset,GotPartSector ;Go here when done
  CALL SCSIReadSectorEAXBG ;Start the Read Sector Request
  JC  >S70                 ;If error, quit
  CALL SetupSCSIDone       ;Issue the Request
  JNC >S90                 ;If it worked, we're done
  MOV  NewDeviceStage,186  ;Update Stage
S70:                       ;Error
  CALL FinishUpBadDrive    ;We're done
S90:                       ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  [BX] = Disk Info Table Pointer
;         Partition Stack contains Partition Details
;------------------------------------------------------------------------------
GotPartSector:
  CALL SetupRETFRegs2                  ;[BX] = Disk, [DI] = Device,
                                       ;[SI] = Int14Request, AX = Error
  MOV  NewDeviceStage,190              ;Update Stage
  JNZ >P702                            ;If error, quit
  MOV  NewDeviceStage,191              ;Update Stage
  CMP  SectorBuff.MBRSignature,BootRecSig ;Valid MBR/Partition Record?
  JNE >P702                            ;If not, error
P05:                                   ;Valid MBR/Partition Record
  MOV  NewDeviceStage,192              ;Update Stage
  CALL CopyBPBData                     ;Copy BPB data, if appropriate
  JC  >P702                            ;If error, quit
  CALL TestForFloppy                   ;Is it a (Super)Floppy?
  JC  >P15                             ;If not, handle a hard drive
P10:                                   ;Is a (Super)Floppy
  CALL InitNewFloppy                   ;Initialze Drive Parameters
  MOV  AX,GotBootSector                ;[AX] = Where to go when done
  CALL Start1TimeIntSI                 ;Issue a 1-time interrupt
  JNC >P901                            ;If it worked, we're done
P702:                                  ;TO avoid JMP >128
  JMP >P701                            ;If error, quit
P15:                                   ;Not a (Super)Floppy
  MOV  NewDeviceStage,193              ;Update Stage
  MOV  SI,PartStackPtr                 ;[SI] = Partition Stack Pointer
  MOV  BP,SI                           ;[BP] = Partition Stack Pointer
  MOV  SI,[SI].PStkOffset              ;[SI] = Partition Entry Offset
  CMP  SI,(SectorBuff+(OFFSET MBRPart4)) ;Processed all Partitions?
  JA  >P50                             ;If so, handle it
P20:                                   ;Loop to here to find valid Partitions
  MOV  AL,[SI].PartOpSys               ;Get the Operating System Flag
  OR   AL,AL                           ;Valid Partition Record?
  JZ  >P40                             ;If not, skip it
  CALL TestValidPOS                    ;If so, is it an OS that we can handle?
  JC  >P40                             ;If not, skip it
  CMP  AL,POSDOSExt                    ;If so, is it an Extended DOS Partition?
  JE  >P30                             ;If so, handle it
  CMP  AL,POSLBAVFATExt                ;If not, is it an Extended W95 Partition?
  JE  >P30                             ;If so, handle it
P25:                                   ;Is a regular DOS Partition
  MOV  NewDeviceStage,194              ;Update Stage
  ADD  DS:[BP].PStkOffset,PRecordSize  ;Update Partition Stack pointer
  CALL InitNewHard                     ;Initialize Drive Parameters (rtns EAX)
  MOV  NextSCSIReqOffset,GotBootSector ;Go here when done
  CALL SCSIReadSectorEAXBG             ;Start the Read Sector Request
  JC  >P70                             ;If error, quit
  CALL SetupSCSIDone                   ;Issue the Request
  JC  >P70                             ;If error, handle it
P901:                                  ;To avoid JMP > 128
  JMP >P90                             ;Done
P801:                                  ;To avoid JMP > 128
  JMP >P80                             ;Completely Done
P30:                                   ;Is an extended DOS partition
  MOV  NewDeviceStage,195              ;Update Stage
  CALL PushPart                        ;Push the Current Partition Info (EAX)
  JNC >P60                             ;If it worked, continue
P701:                                  ;To avoid JMP > 128
  JMP >P70                             ;If error, quit
P40:                                   ;Not a valid Partition
  ADD  SI,PRecordSize                  ;Point at the next Partition Entry
  MOV  DS:[BP].PStkOffset,SI           ;Store it for next time
  CMP  SI,(SectorBuff+(OFFSET MBRPart4)) ;Processed all Partitions?
  JBE  P20                             ;If not, keep looking
P50:                                   ;Have processed all Partitions in Record
  CALL PopPart                         ;Go to the previous Partition (CF, EAX)
  JC  >P80                             ;If none, we've processed all of them
P60:                                   ;Get the next Partition Record
  MOV  NextSCSIReqOffset,GotPartSector ;Go here when done
  CALL SCSIReadSectorEAXBG             ;Start the Read Sector Request
  JC  >P70                             ;If error, quit
  CALL SetupSCSIDone                   ;Issue the Request
  JNC >P90                             ;If it worked, we're done
  MOV  NewDeviceStage,196              ;Update Stage
P70:                                   ;Error
  CALL FinishUpBadDrive                ;Mark it as Bad
  JMP >P90                             ;Done
P80:                                   ;Completely done
  MOV  [BX].DskDrvTimer,0              ;Mark as Media Inserted
  AND  TSRFlags,(NOT (Int14ReqInUse+SectBuffInUse)) ;Mark resources as available
P90:                                   ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Disk Info Table Pointer
;NOTES: The FAT32 mods (changing DPBRootEntries & DPBSectorsPerFAT)
;         is a patch needed for FreeDOS.  MS-DOS does not need the patch.
;------------------------------------------------------------------------------
GotBootSector:
  CALL SetupRETFRegs2                  ;[BX] = Disk, [DI] = Device,
                                       ;[SI] = Int14Request, AX = Error
  MOV  NewDeviceStage,200              ;Update Stage
  JNZ >B70                             ;If error, quit
  MOV  NewDeviceStage,201              ;Update Stage
  MOV  AX,SectorBuff.MBRSignature      ;Get the Sector Signature Word
  CMP  AX,BootRecSig                   ;Is this a Valid VBR Sector?
  JNE >B70                             ;If not, error
B20:                                   ;Valid Boot Signature
  MOV  NewDeviceStage,202              ;Update Stage
  CALL GetAvailDriveSI                 ;Get an available Drive Entry ([SI])
  JC  >B80                             ;If error, we're done
  MOV  [SI].DrvDskOffset,BX            ;If OK, store the Disk Offset
  CALL CopyNewDriveParams              ;Copy Parameters to Drive Entry
  TEST TSRFlags,IsFreeDOS              ;Is this FreeDOS?
  JZ  >B40                             ;If not, continue
  CMP  [SI].DrvPartOS,POSFAT32         ;Is it FAT32?
  JE  >B30                             ;If so, handle it
  CMP  [SI].DrvPartOS,POSFAT32LBA      ;Is it FAT32?
  JNE >B40                             ;If not, no mods needed
B30:                                   ;Is FAT32 under FreeDOS
  CALL BPB2DPBFreeDOS32                ;Partially fill in the DPB
B40:                                   ;Done FreeDOS with FAT32 mods
  OR   [SI].DrvFlags,DrvFlagReady      ;Mark Drive as configured
  MOV  [SI].DrvGIOAccess,1             ;Mark as Accessible via Generic IOCTL
  CMP  [SI].DrvPartOS,-1               ;Is it a (Super)Floppy?
  JE  >B80                             ;If so, we're done
  MOV  EAX,[SI].DrvPartSector          ;Get the Partition Sector to read
  MOV  NextSCSIReqOffset,GotPartSector ;Go here when done
  CALL SCSIReadSectorEAXBG             ;Start the Read Sector Request
  CALL SetupSCSIDone                   ;Issue the Request
  JNC >B90                             ;If it worked, we're done
  MOV  NewDeviceStage,203              ;Update Stage
B70:                                   ;Error
  CALL FinishUpBadDrive                ;Mark it as Bad
  JMP >B90                             ;Done
B80:                                   ;Completely done
  MOV  [BX].DskDrvTimer,0              ;Mark as Media Inserted
  AND  TSRFlags,(NOT (Int14ReqInUse+SectBuffInUse)) ;Mark resources as available
B90:                                   ;Done
  RETF


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE TO LOOK FOR NEW DRIVES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;COPY BPB DATA TO DISK INFO ENTRY, IF APPROPRIATE
;Inputs:   DS  = TSR Data Area
;         [BX] = Disk Info Entry (may already be filled in)
;Outputs: CF = Clear if OK
;              Copies & verifies MaxLBA, CHS values if not already filled in
;            = Set if Error
;Changes:
;NOTES: When we get to here, SectorBuff contains data from one of the
;         disk sectors.  Depending on how the disk responded to the
;         earlier SCSI requests (Format Capacity, Capacity, and
;         Flex Descriptor) we may or may not know anything about the
;         disk size parameters (Max LBA or CHS values).  If we got valid
;         data from the earlier requests, we just ignore what we find in
;         Sector 0.  If we didn't get any data from the earlier requests,
;         we use what we find in Sector 0 to "guesstimate" the disk
;         parameters.  This may not necessarily be accurate, depending on
;         how (or if) the disk was formatted.
;------------------------------------------------------------------------------
CopyBPBData:
  PUSH EAX,CX,DX,DI,SI,BP           ;Save used registers
  CMP  [BX].DskSectsPerTrack,0      ;Already have valid data?
  JNE >B80                          ;If so, we're done
  CMP  LBAInBuffer,0                ;Is this Sector 0?
  JNE >B80                          ;If not, just quit
  MOV  SI,SectorBuff                ;[SI] = Sector Buffer
  CMP  [SI].MBRSignature,BootRecSig ;Valid MBR/Partition Record?
  JNE >B70                          ;If not, error
  MOV  AL,[SI]                      ;Get the first OpCode Byte in the Sector
  CMP  AL,OpCodeJmpShort            ;Is it a Boot Record?
  JE  >B20                          ;If so, it's a (Super)Floppy
  CMP  AL,OpCodeJmpNear             ;Is it a Boot Record?
  JE  >B20                          ;If so, it's a (Super)Floppy
B10:                                ;It's a Hard Drive
  CALL GetBPBHard                   ;Glean Hard Drive Data
  JZ  >B70                          ;If error, quit
  JMP >B30                          ;If OK, continue
B20:
  CALL GetBPBFloppy                 ;Glean Floppy Data
  JZ  >B70                          ;If error, quit
B30:                                ;Handle Max LBA (EAX)
  MOV  [BX].DskMaxLBA,EAX           ;If so, store it
  MOV  [BX].DskBytesPerSect,CX      ;If so, store it
  MOV  [BX].DskNumTracks,DX         ;If so, store it
  MOV  [BX].DskNumHeads,DI          ;If so, store it
  MOV  [BX].DskSectsPerTrack,BP     ;If so, store it
B60:                                ;All values stored
  JMP >B80                          ;Done
B70:                                ;Error
  STC                               ;Set error flag
  JMP >B90                          ;Done
B80:                                ;OK
  CALL AdjustCHSValues              ;Adjust CHS values as necessary
  CALL FillInFDPTParams             ;Fill in FBDT Table if needed
  CLC                               ;Set return flag
B90:                                ;Done
  POP  BP,SI,DI,DX,CX,EAX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GLEAN THE DISK SIZE INFORMATION FROM A HARD DRIVE SECTOR 0 PARTITION RECORD
;Inputs:   DS  = TSR Data Area
;         [SI] = Sector Buffer (with Sector 0 Partition Record)
;Outputs:  ZF  = Clear if OK (data is valid)
;                EAX  = Max LBA (Total number of Sectors - 1)
;                 CX  = Number of Bytes per Sector
;                 DX  = Number of Cylinders/Tracks
;                 DI  = Number of Heads
;                 BP  = Number of Sectors per Track
;          ZF  = Set if Error
;                EAX, CL, DX, BP = Undefined
;Changes:
;NOTES: Normally, partition records are set up in ascending order from the
;         beginning of the disk (record 1 is nearest the beginning of the
;         disk, and record 4 is nearest the end).  Howevever, this is not an
;         absolute requirement and we will not assume that the disk is set
;         up that way.  We will check all of the records and find the one
;         with the largest ending LBA.
;       Also, normally, partitions are set up so that they start at the
;         beginning of a cylinder (head 0, sector 1), and stop at the end of
;         a cylinder (max cylinder, max sector).  However, this is not an
;         absolute requirement, either.  If it is not, though, we will never
;         be able to figure out what the maximum head and sector numbers.
;         We will search all of the records and find the one with the
;         largest numbers, though we would expect all of the records to
;         be the same.  Most disks only have one partition anyway, so we
;         won't have anything to compare the first record to.  As long as
;         the disk was formatted in a "reasonable" customary fashion, we should
;         be OK.
;       Partition records also do not contain any information at all about
;         the number of bytes per sector, so we will simply assume it is 512.
;         That is a fairly safe assumption, though it is certainly not
;         ALWAYS true.
;------------------------------------------------------------------------------
GetBPBHard:
  PUSH EBX,SI                 ;Save used registers
  MOV  BP,1                   ;Initialize Sectors per Track
  XOR  DI,DI                  ;Initialize Number of Heads
  XOR  DX,DX                  ;Initialize Number of Cylinders/Tracks
  XOR  EBX,EBX                ;EBX = LBA comparison value
  MOV  CX,4                   ;Do 4 partition records
  ADD  SI,(OFFSET MBRPart1)   ;[SI] = First Partition Record
H10:                          ;Loop to here for each partition record
  MOV  EAX,[SI].PartLBASector ;Calculate
  ADD  EAX,[SI].PartLBALength ;  End LBA + 1
  OR   EAX,EAX                ;Valid record?
  JZ  >H60                    ;If not, skip it
H20:                          ;Valid record
  CMP  EAX,EBX                ;Is it more than the previous record(s)?
  JBE >H30                    ;If not, it's not the last record
  MOV  EBX,EAX                ;If so, mark it as the new last record
H30:                          ;Get Max Cylinder
  MOV  AL,[SI].PartStartCyl   ;AX =
  MOV  AH,[SI].PartStartSect  ;  Start Cylinder
  SHR  AH,6                   ;  Number
  CMP  AX,DX                  ;Is it more than the previous Max Cylinder?
  JBE >H35                    ;If not, continue
  MOV  DX,AX                  ;If so, store it as the new Max Cylinder
H35:                          ;DX = Updated Max Cylinder
  MOV  AL,[SI].PartEndCyl     ;AX =
  MOV  AH,[SI].PartEndSect    ;  End Cylinder
  SHR  AH,6                   ;  Number
  CMP  AX,DX                  ;Is it more than the previous Max Cylinder?
  JBE >H40                    ;If not, continue
  MOV  DX,AX                  ;If so, store it as the new Max Cylinder
H40:                          ;Get Max Head
  XOR  AH,AH                  ;Values from here on are bytes
  MOV  AL,[SI].PartStartHead  ;AX = Start Head Number
  CMP  AX,DI                  ;Is it more than the previous Max Head?
  JBE >H45                    ;If not, continue
  MOV  DI,AX                  ;If so, store it as the new Max Head
H45:                          ;DI = Updated Max Head
  MOV  AL,[SI].PartEndHead    ;AX = End Head Number
  CMP  AX,DI                  ;Is it more than the previous Max Head?
  JBE >H50                    ;If not, continue
  MOV  DI,AX                  ;If so, store it as the new Max Head
H50:                          ;Get Max Sector
  MOV  AL,[SI].PartStartSect  ;AX =
  AND  AL,PSectSector         ;  Start Sector Number
  CMP  AX,BP                  ;Is it more than the previous Max Cylinder?
  JBE >H55                    ;If not, continue
  MOV  BP,AX                  ;If so, store it as the new Max Cylinder
H55:                          ;DX = Updated Max Cylinder
  MOV  AL,[SI].PartEndSect    ;AX =
  AND  AL,PSectSector         ;  End Sector Number
  CMP  AX,BP                  ;Is it more than the previous Max Cylinder?
  JBE >H60                    ;If not, continue
  MOV  BP,AX                  ;If so, store it as the new Max Cylinder
H60:                          ;Done with this Partition Record
  ADD  SI,PRecordSize         ;Point at the next record
  LOOP H10                    ;Keep going until we're done
  MOV  EAX,EBX                ;EAX =
  DEC  EAX                    ;  Max LBA
  INC  DX                     ;Convert Max Cylinder to Number of Cylinders
  INC  DI                     ;Convert Max Head to Number of Heads
  MOV  CX,512                 ;CX = Bytes per Sector (assume 512)
  CMP  BP,1                   ;Set return flag
  POP  SI,EBX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GLEAN THE DISK SIZE INFORMATION FROM A (SUPER)FLOPPY SECTOR 0 BOOT RECORD
;Inputs:   DS  = TSR Data Area
;         [SI] = Sector Buffer (with Sector 0 Floppy Boot Record)
;Outputs:  ZF  = Clear if OK (data is valid)
;                EAX  = Max LBA (Total number of Sectors - 1)
;                 CX  = Number of Bytes per Sector
;                 DX  = Number of Cylinders/Tracks
;                 DI  = Number of Heads
;                 BP  = Number of Sectors per Track
;          ZF  = Set if Error
;                EAX, CL, DX, BP = Undefined
;Changes:
;------------------------------------------------------------------------------
GetBPBFloppy:
  PUSH SI                         ;Save used registers
  ADD  SI,11                      ;[SI] = BIOS Parameter Block
  XOR  BP,BP                      ;Set test value (Sectors per Track) to 0
  MOV  CX,[SI].BPBBytesPerSect    ;Get the Bytes per sector
  CMP  CX,MaxBytesPerSect         ;Is it too big for DOS to handle?
  JA  >F90                        ;If so, Error
  MOV  DI,[SI].BPBNumHeads        ;DI = Number of Heads
  MOV  AX,[SI].BPBSectsPerTrack   ;BP =
  MUL  DI                         ;  Number of Heads times
  MOV  BP,AX                      ;  Number of Sectors Per Track
  XOR  DX,DX                      ;DX:AX = Total Number
  MOV  AX,[SI].BPBNumSects16      ;  of Sectors
  OR   AX,AX                      ;Is the Total a 16-bit value?
  JNZ >F20                        ;If so, continue
F10:                              ;Total Sectors is a 32-bit value
  MOV  AX,W [SI].BPBNumSects32[0] ;DX:AX = Total Number
  MOV  DX,W [SI].BPBNumSects32[2] ;  of Sectors
F20:                              ;DX:AX = Total Number of Sectors
  DIV  BP                         ;AX = Whole Cylinders
  OR   DX,DX                      ;Do we need to round it up?
  JZ  >F30                        ;If not, continue
  INC  AX                         ;If so, round it up
F30:                              ;AX = Number of Cylinders
  MOV  DX,AX                      ;DX = Number of Cylinders
  XOR  EAX,EAX                    ;Get the 16-bit
  MOV  AX,[SI].BPBNumSects16      ;  Number of Sectors
  OR   EAX,EAX                    ;Is it a 16-bit LBA?
  JNZ >F40                        ;If so, continue
  MOV  EAX,[SI].BPBNumSects32     ;Get the Number of Sectors
F40:                              ;EAX = Number of Sectors
  XOR  ECX,ECX                    ;Add in
  MOV  CX,W [SI].BPBHiddenSects   ;  the number of
  ADD  EAX,ECX                    ;  Hidden Sectors
  DEC  EAX                        ;Convert to Max LBA
  MOV  BP,[SI].BPBSectsPerTrack   ;BP = Sectors Per Track
F90:                              ;Done
  OR   BP,BP                      ;Set return flag
  POP  SI                         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST THE CYLINDER/HEAD/SECTOR VALUES WE'VE GOT SO FAR FOR LEGITIMACY
;Inputs:   DS  = TSR Data Area
;         [BX] = Disk Info Entry
;                Cylinder, Head, Sector Values filled in (as downloaded
;                  via SCSI Requests)
;Outputs:  Cylinder, Head, Sector Values adjusted as necessary to make
;            them work with INT 13h Functions
;Changes:
;NOTES: Several USB Drives I've tested don't return CHS values that
;         correspond to the Total Sectors value.  This makes the adjustments
;         necessary so that everything "fits" like it's supposed to.
;       If the CHS values are "legal" and match up with the Total Sectors,
;         we leave them alone.  If the Total Sectors is small enough to be
;         accessible using INT 13h Functions (<= 8.4GB), this adjusts
;         the CHS values so that they work correctly.  If the drive is too
;         big for INT 13h functions, this sets the size to the maximum (8.4GB).
;       Some Devices return Total Number of Sectors when they should return
;         Maximum LBA.  SInce disks should always have an even number of
;         sectors (Maximum LBA should always be odd) we'll perform the
;         adjustment here to make sure the Maximum LBA is odd.
;------------------------------------------------------------------------------
AdjustCHSValues:
  PUSH EAX,CX,DX,EBP                   ;Save used registers
  TEST B [BX].DskMaxLBA[0],1           ;Is the Max LBA odd?
  JNZ >A05                             ;If so, it's OK
  DEC  [BX].DskMaxLBA                  ;If not, make it odd
A05:                                   ;MaxLBA adjusted, if appropriate
  MOV  EBP,[BX].DskMaxLBA              ;EBP =
  INC  EBP                             ;  Total Sectors
  CMP  [BX].DskMaxLBA,MaxI13TotalSects ;Can the Disk use INT 13h funcs?
  JBE >A20                             ;If so, handle it
A10:                                   ;Disk is too big for INT 13h funcs
  MOV  [BX].DskNumHeads,MaxI13Heads    ;Store Max Heads
  MOV  [BX].DskNumTracks,MaxI13Tracks  ;Store Max Cylinders
  MOV  [BX].DskSectsPerTrack,MaxI13SectsPerTrack ;Store Max Sects Per Track
  JMP >A90                             ;Done
A20:                                   ;Disk can use INT 13h funcs
  CMP  [BX].DskNumHeads,0              ;Did we have any CHS data at all?
  JE  >A40                             ;If not, adjustments are needed
  CMP  [BX].DskNumHeads,MaxI13Heads    ;Is Number of Heads Legal?
  JA  >A40                             ;If not, adjustments are needed
  CMP  [BX].DskNumTracks,MaxI13Tracks  ;Is Number of Tracks Legal?
  JA  >A40                             ;If not, adjustments are needed
  CMP  [BX].DskSectsPerTrack,MaxI13SectsPerTrack  ;Is Sectors Per Track Legal?
  JA  >A40                             ;If not, adjustments are needed
  MOV  AX,[BX].DskNumHeads             ;Multiply Number of Heads
  MUL  W [BX].DskSectsPerTrack         ;  by Number of Sectors per Track
  MOV  CX,AX                           ;Save this intermediate value
  MUL  W [BX].DskNumTracks             ;Multiply by Number of Tracks
  PUSH DX                              ;Put Total
  PUSH AX                              ;  Sectors in
  POP  EAX                             ;  EAX
  CMP  EAX,EBP                         ;How does it compare to Total Sectors?
  JE  >A90                             ;If equal, it's OK
  JA  >A40                             ;If too big, adjustments are needed
  MOV  AX,[BX].DskNumTracks            ;If too small,
  INC  AX                              ;  is it
  MUL  CX                              ;  too small
  PUSH DX                              ;  by
  PUSH AX                              ;  exactly
  POP  EAX                             ;  one
  CMP  EAX,EBP                         ;  cylinder?
  JA  >A90                             ;If so, it's OK
A40:                                   ;Adjustments are needed to CHS values
  MOV  [BX].DskNumHeads,MaxI13Heads    ;Store Max Heads
  MOV  [BX].DskSectsPerTrack,MaxI13SectsPerTrack ;Store Max Sects Per Track
  MOV  AX,W [BX].DskMaxLBA[0]               ;Calculate the
  MOV  DX,W [BX].DskMaxLBA[2]               ;  Number of Tracks
  MOV  CX,(MaxI13Heads*MaxI13SectsPerTrack) ;  we need
  DIV  CX                                   ;  to use
  MOV  [BX].DskNumTracks,AX            ;Store it
A90:                                   ;Done
  POP  EBP,DX,CX,EAX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY THE APPROPRIATE PARAMETERS FROM A DISK INFO ENTRY TO A FDPT
;Inputs:   DS = TSR Data Area
;         [BX] = Disk Info Entry to use
;Outputs: Copies Appropriate Data from Disk Info Entry to FBPT
;Changes:
;------------------------------------------------------------------------------
FillInFDPTParams:
  PUSH AX,DI                           ;Save used registers
  MOV  DI,FDPT80h                      ;Assume it's the first hard drive
  CMP  [BX].DskInt13DrvNum,81h         ;Is it the first or second hard drive?
  JA  >F90                             ;If neither, quit
  JB  >F10                             ;If the first hard drive, continue
  MOV  DI,FDPT81h                      ;If not, it's the second hard drive
F10:                                   ;[BX] = Disk Info, [DI] = FDPT
  CALL EmptyFDPTTable                  ;Fill Table with Zeroes
  CMP  [BX].DskMaxLBA,MaxI13TotalSects ;Is it a large disk?
  JBE >F30                             ;If not, continue
F20:                                   ;Is a Large Disk
  CALL CopyEDPTLarge                   ;Fill it with the Large Data
  JMP >F90                             ;Done
F30:                                   ;Not a large disk
  CALL EmptyFDPTTable                  ;Fill the table with zeroes
  MOV  AX,[BX].DskNumTracks            ;Copy the
  MOV  [DI].FDPTNumTracks,AX           ;  number of Tracks
  MOV  [DI].FDPTLandingZone,AX         ;Store this value in Landing Zone also
  MOV  AL,B [BX].DskSectsPerTrack[0]   ;Copy the
  MOV  [DI].FDPTSectsPerTrack,AL       ;  Sectors per Track
  MOV  AX,[BX].DskNumHeads             ;Copy the
  MOV  [DI].FDPTNumHeads,AL            ;  number of Heads
  CMP  AL,8                            ;More than 8 heads?
  JBE >F90                             ;If not, we're done
  OR   [DI].FDPTCtlByte,FDPTHeads8Plus ;If so, set the Flag in the Control Byte
F90:                                   ;Done
  POP  DI,AX                           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY THE DEFAULT OR LARGE FDPT/EPDT PARAMETERS TO AN FDPT TABLE
;Inputs:   DS = TSR Data Area
;         [DI] = FDPT Table to fill in
;         CLD already issued
;Outputs: Fills in FBPT with appropriate data
;Changes:
;------------------------------------------------------------------------------
CopyFDPT10MB:
  PUSH SI           ;Save used registers
  MOV  SI,FDPT10MB  ;[SI] = 10MB FDPT Table Data
  JMP >F00          ;Do it
CopyEDPTLarge:
  PUSH SI           ;Save used registers
  MOV  SI,EDPTLarge ;[SI] = Large FDPT Table Data
;  JMP >F00          ;Do it
F00:
  PUSH CX,DI        ;Save used registers
  MOV  CX,((TYPE FDPTStruc)/2) ;CX = Number of Words to Copy
  REP  MOVSW        ;Copy the Data
  POP  DI,CX        ;Restore used registers
  POP  SI           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CREATE A PARTIALLY CORRECT DPB GIVEN A BPB
;Inputs:   DS = ES = TSR Data Area
;         [SI] = Drive Info Entry (BPB filled in)
;Outputs: DPB area filled in
;Changes:
;NOTE: This is only called if in FreeDOS and drive is FAT32 (this patches a
;        bug in FreeDOS -- the problem is not actually in USBDRIVE).
;        Newer versions of FreeDOS will hopefully have the bug fixed.
;      This does not actually create a real, valid DPB.  It just copies the
;        things from the BPB that are straightforward to copy (no calculations
;        needed), and sets everything else to 0 or -1.  This is apparently
;        close enough to a real DPB that it keeps the bug in FreeDOS happy.
;------------------------------------------------------------------------------
BPB2DPBFreeDOS32:
  PUSH EAX,BX,DI                   ;Save used registers
  LEA  BX,[SI].DrvBPB              ;[BX] = BPB
  LEA  DI,[SI].DrvDPB              ;[DI] = DPB
  MOV  AX,[BX].BPBBytesPerSect     ;Copy
  MOV  [DI].DPBBytesPerSect,AX     ;   Bytes per Sector
  MOV  AL,[BX].BPBSectsPerCluster  ;Copy
  DEC  AL                          ;  Sectors
  MOV  [DI].DPBHiSectInCluster,AL  ;  per Cluster
  XOR  AL,AL                       ;Start Sector->Cluster Shift at 0
  MOV  AH,[BX].BPBSectsPerCluster  ;AH = Sectors Per Cluster
  OR   AH,AH                       ;Is it valid?
  JZ  >B15                         ;If not, leave it at 0
B10:                               ;Loop to here to find Sector->Cluster Shift
  SHR  AH,1                        ;Shift over by 1
  JC  >B15                         ;If CF is set, this is the bit we're looking for
  INC  AL                          ;If not, increment Sector Shift
  JMP  B10                         ;Keep looking
B15:                               ;AL = Sector Shift
  MOV  [DI].DPBSectorShift,AL      ;Store Sector Shift
  MOV  EAX,D [BX].BPBReservedSects ;Copy
  MOV  D [DI].DPBReservedSects,EAX ;  Reserved Sectors,
  MOV  AL,B [BX].BPBRootEntries[1] ;  Number of FATs,
  MOV  B [DI].DPBRootEntries[1],AL ;  and Number of Root Entries
  MOV  [DI].DPBFirstUserSector,-1  ;First User Sector = Unknown
  MOV  [DI].DPBHighestCluster,0    ;Highest Cluster = 0
  MOV  AX,[BX].BPBSectsPerFAT16    ;Copy
  MOV  [DI].DPBSectorsPerFAT,AX    ;  Sectors per FAT
  MOV  [DI].DPBRootSector,-1       ;Root Sector = -1
  ;DPBDvcDriverPtr filled in elsewhere
  MOV  AL,[BX].BPBMediaID          ;Copy
  MOV  [DI].DPBMediaID,AL          ;  Media ID
  ;DPBAccessed filled in elsewhere
  ;DPBNextDPBPtr filled in elsewhere
  MOV  [DI].DPBStartCluster,-1     ;Search Start Cluster = Unknown
  MOV  D [DI].DPBFreeClustersL,-1  ;Number of Free Clusters = Unknown
  MOV  AX,[BX].BPBXFlags           ;Copy
  MOV  [DI].DPBFATMirror,AX        ;  Extended Flags
  MOV  EAX,D [BX].BPBXInfoSectNum  ;Copy File System Information Sector
  MOV  D [DI].DPBFSysInfoSect,EAX  ;  & Backup Boot Sector
  MOV  [DI].DPBFirstClusterSect,-1 ;First Cluster Sector = Unknown
  MOV  [DI].DPBMaxCluster,-1       ;Maximum Cluster = Unknown
  MOV  [DI].DPBNumFATSectors,-1    ;Number of FAT Sectors = Unknown
  MOV  EAX,[BX].BPBXRootCluster    ;Copy
  MOV  [DI].DPBRootCluster,EAX     ;  Root Cluster
  MOV  [DI].DPBSearchCluster,0     ;Search Cluster = Unknown
  POP  DI,BX,EAX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESET AN FDPT TABLE TO ALL ZEROES
;Inputs:   DS = TSR Data Area
;         [DI] = FDPT Table to fill in
;         CLD already issued
;Outputs: Fills in FBPT with zeroes
;Changes:
;------------------------------------------------------------------------------
EmptyFDPTTable:
  PUSH AX,CX,DI ;Save used registers
  XOR  AX,AX    ;Fill the table with zeroes
  MOV  CX,((TYPE FDPTStruc)/2) ;CX = Number of Words to Copy
  REP  STOSW    ;Fill the Table
  POP  DI,CX,AX ;Restore used registers
  RET

FinishUpBadDrive:
  AND  TSRFlags,(NOT (Int14ReqInUse+SectBuffInUse)) ;Mark resources as available
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE FOR LOOKFORNEWDEVICE & LOOKFORNEWDRIVES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST AND SEE IF A DEVICE IS IN THE UNLOCAKBLE LIST OR NOT
;Inputs:   DS = ES = TSR Data Area
;         [BX] = Device Info Entry
;          DvcDescrData contains Device Descriptor
;            (This is called immediately after we successfully downloaded
;               the Device Descriptor)
;          CLD already issued
;Outputs: If Device is in List, sets DskFlagNoLock
;Changes:
;------------------------------------------------------------------------------
TestUnlockable:
  PUSH AX,DI,SI            ;Save used registers
  MOV  DI,DvcDescrData     ;[DI] = Device Descriptor Data
  MOV  SI,UnlockableTbl    ;[SI] = Table to Look in
U30:                       ;Loop to here fore each Table Entry
  LODSW                    ;Get the Vendor ID from our Lookup Table
  OR   AX,AX               ;End or the Table?
  JZ  >U90                 ;If so, we're done
  CMP  AX,[DI].DDVendorID  ;Does the Vendor ID match?
  LODSW                    ;Get the Product ID
  JNE  U30                 ;If Vendor ID doesn't match, keep looking
  CMP  AX,[DI].DDProductID ;Does the Product ID match?
  JNE  U30                 ;If not, keep looking
U70:                       ;Not Lockable
  OR   [BX].DvcFlags,DvcFlagNoLock ;If so, mark it as Unlocakble
U90:                       ;Done
  POP  SI,DI,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs:  DS = ES = TSR Data Area
;         [BX] = Disk Info Entry
;Outputs: [BX] = Disk Info Entry
;         [DI] = Device Info Entry
;         [SI] = Int14Request
;          AL  = Combined USB Error Codes (returned by Background SCSI Request)
;          AH  = CSW Status Code
;          ZF  = Set if no Error (AX = 0)
;              = Clear if Error (AX != 0)
;------------------------------------------------------------------------------
SetupRETFRegs2:
  MOV  DI,[BX].DskDvcOffset ;[DI] = Device Info Entry
  MOV  SI,Int14Request      ;[SI] = Int14Request
  CALL GetSCSIReqErr        ;AH = 0, AL = Combined SCSI Status
  OR   AX,AX                ;Set the Error Flag
  RET

;------------------------------------------------------------------------------
;Inputs:  DS = TSR Data Area
;         NextSCSIReqOffset already filled in
;         [BX] = Disk Info
;Outputs: CF = Set if Error (Int 14 Request Failed)
;              AX = Error Code
;            = Clear of OK
;              AX = 0
;Changes: Int14Request
;------------------------------------------------------------------------------
SetupSCSIDone:
  PUSH SI                     ;Save used registers
  MOV  SI,Int14Request        ;Point at Int14 Request Structure
  MOV  [SI].I14RRequestType,I14RRTDoInterrupt1T ;Set up One-time Interrupt
  MOV  [SI].I14RPeriodicity,2 ;Wait 2 Milliseconds
  MOV  [SI].I14RUserPktID,BX  ;User ID = Disk Info Pointer
  MOV  W [SI].I14RCallBackAddr[0],WaitForSCSIDone ;Go here while waiting
  CALL DoInt14CallAXSI        ;Do it (returns CF, AX)
  POP  SI                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs: [BX] = Disk Info Table Pointer
;NOTE: This is a "Wrapper" Call for a SCSI Background Request.  A SCSI
;        background request actually has three stages: Request, Data, and
;        Status.  They are literally three separate USB Requests (and in
;        some cases three different types of Requests to different
;        endpoints).  Since we need to do this many times, we create a
;        "wrapper" around the three requests so that we can simplify and
;        re-use large portions of code.
;      The SCSI Request performs in the background, and when it is done it
;        simply updates some fl;ags and error code information in memory
;        (stored in the Device Info Structure).  We "wrap" ourselves around
;        that request by issuing an effective periodic interrupt that simply
;        monitors the status bytes, and keeps waiting until the status bytes
;        indicate that the SCSI Request is done.  When it is done, the
;        "wrapper" finally lets the process continue at the next stage.
;      The code following this will actually be performed after a one-time
;        interrupt, so the status returned in will not reflect the actual
;        status of the SCSI Request.  The code will need to look in the
;        Device Info Request STrcutre for the actual Error Codes.
;------------------------------------------------------------------------------
WaitForSCSIDone:
  MOV  SI,Int14Request                ;[SI] = Int 14h Request Structure
  TEST [BX].DskFlags,DskFlagReqInProg ;Is the Request done yet?
  JNZ >I30                            ;If not, keep waiting until it is
I10:                                  ;Request is Done
  MOV  [SI].I14RPeriodicity,1         ;Wait 1 Millisecond
  MOV  AX,NextSCSIReqOffset           ;Go here
  MOV  W [SI].I14RCallBackAddr[0],AX  ;  when done
I30:                                  ;Int 14h Request is set up
  CALL DoInt14CallAXSI                ;Do it
  JNC >I90                            ;If it worked, we're done
  MOV  NewDeviceStage,250             ;Update Stage
I70:                                  ;Error
  CALL FinishUpBadDevice              ;Mark it as Bad
I90:                                  ;Done
  RETF

;------------------------------------------------------------------------------
;GET AN AVAILABLE DISK INFORMATION TABLE ENTRY
;Inputs:  DS = ES = TSR Data Area
;Outputs: CF = Clear if OK
;              [DI] = Disk Info Entry, marked as In Use
;            = Set if Error
;              DI = Unchanged
;         Interrupts Enabled (Issues STI at end)
;Changes:
;------------------------------------------------------------------------------
GetAvailDiskDI:
  PUSH AX,CX                      ;Save used registers
  MOV  AX,DI                      ;Save original DI
  MOV  CX,NumDisks                ;CX = Number of Disk Entries
  MOV  DI,DiskInfoOffset          ;[DI] = Disk Entry Table
  CLI                             ;Disable interrupts
K10:                              ;Loop to here for each Drive Entry
  TEST [DI].DskFlags,DskFlagInUse ;Is it avaialble?
  JZ  >K80                        ;If not, it's what we're looking for!
K40:                              ;Can't use this Entry
  ADD  DI,DiskInfoSize            ;Point at the next Entry
  LOOP K10                        ;Keep looking until the end of the Table
K70:                              ;Error
  MOV  DI,AX                      ;Restore original DI
  STC                             ;Set return flag
  JMP >K90                        ;Done
K80:                              ;OK
  OR   [DI].DskFlags,DskFlagInUse ;Mark it as in use
  MOV  [DI].DskDrvTimer,DskStageStartup ;Mark as in Startup Stage
  MOV  [DI].DskLastSectorRW,-1    ;Mark Sectors as unaccessed
  CLC                             ;Set return flag
K90:                              ;Done
  STI                             ;Enable Interrupts
  POP  CX,AX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET AN AVAILABLE DRIVE INFORMATION TABLE ENTRY
;Inputs:  DS = ES = TSR Data Adrea
;         Drive Info Table filled in with default information
;Outputs: CF = Clear if OK
;              [SI] = Drive Info Entry, marked as In Use
;            = Set if Error
;              SI = Unchanged
;         Interrupts Enabled (Issues STI at end)
;Changes:
;------------------------------------------------------------------------------
GetAvailDriveSI:
  PUSH AX,CX                      ;Save used registers
  MOV  AX,SI                      ;Save original DI
  MOV  CX,NumDrives               ;CX = Number of Drive Entries
  MOV  SI,DriveInfoOffset         ;[DI] = Drive Entry Table
  CLI                             ;Disable interrupts
I10:                              ;Loop to here for each Drive Entry
  TEST [SI].DrvFlags,DrvFlagValid ;Valid Drive Entry?
  JZ  >I40                        ;If not, we can't use it
  TEST [SI].DrvFlags,DrvFlagInUse ;If Valid, is it already being used?
  JZ  >I80                        ;If not, it's what we're looking for!
I40:                              ;Can't use this Entry
  ADD  SI,DriveInfoSize           ;Point at the next Entry
  LOOP I10                        ;Keep looking until the end of the Table
I70:                              ;Error
  MOV  SI,AX                      ;Restore original DI
  STC                             ;Set return flag
  JMP >I90                        ;Done
I80:                              ;OK
  OR   [SI].DrvFlags,DrvFlagInUse ;Mark it as in use
  CLC                             ;Set return flag
I90:                              ;Done
  STI                             ;Enable Interrupts
  POP  CX,AX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST A CAPACITY DESCRIPTOR RETURNED BY A DEVICE TO SEE IF IT'S VALID
;Inputs:   DS  = TSR Data Area
;         [BP] = Format Descriptor to test
;Outputs:  CF  = Clear if OK (Descriptor is OK)
;              = Set if Error (Descriptor is Invalid/Illegal/Incomplete)
;Changes:
;------------------------------------------------------------------------------
TestCapDescr:
  PUSH EAX,BX                        ;Save used registers
  MOV  BX,BP                         ;[BX] = Format Descriptor
  MOV  EAX,[BX].FDescNumBlocks       ;EAX = Number
  CALL CvtEndianEAX                  ;  of Blocks
  CMP  EAX,32                        ;Is it a reasonable number?
  JB  >M70                           ;If not, error
  CMP  B [BX].FDescBlockLength[0],0  ;Is Bytes-per-Sector > 65535?
  JNE >M70                           ;If so, error
  MOV  AX,W [BX].FDescBlockLength[1] ;If not, AX
  XCHG AL,AH                         ;  = Bytes per Sector
  CMP  AX,MinSectorSize              ;Is it too small for DOS to handle?
  JB  >M70                           ;If so, error
  CMP  AX,MaxSectorSize              ;Is it too big for DOS to handle?
  JBE >M80                           ;If not, it's OK
M70:                                 ;Error
  STC                                ;Set return flag
  JMP >M90                           ;Done
M80:                                 ;OK
  CLC                                ;Set return flag
M90:                                 ;Done
  POP  BX,EAX                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST A FORMAT CAPACITY DESCRIPTOR RETURNED BY A DEVICE TO SEE IF IT'S VALID
;Inputs:   DS  = TSR Data Area
;         [BP] = Format Descriptor to test
;Outputs:  CF  = Clear if OK (Descriptor is OK)
;              = Set if Error (Descriptor is Invalid/Illegal/Incomplete)
;Changes:
;------------------------------------------------------------------------------
TestFmtCapDescr:
  PUSH EAX,BX                        ;Save used registers
  MOV  BX,BP                         ;[BX] = Format Descriptor
  CMP  [BX].CLHdrLength,0            ;Valid Length?
  JE  >F70                           ;If not, error
  ADD  BX,(TYPE CapListHdr)          ;If so, point at the Current Format Hdr
  CMP  [BX].FDescCode,0              ;Valid Descriptor Code?
  JE  >F70                           ;If not, Error
  CMP  [BX].FDescCode,FDCodeNoMedia  ;Valid Descriptor Code?
  JA  >F70                           ;If not, Error
  MOV  EAX,[BX].FDescNumBlocks       ;EAX = Number
  CALL CvtEndianEAX                  ;  of Blocks
  CMP  EAX,32                        ;Is it a reasonable number?
  JB  >F70                           ;If not, error
  CMP  B [BX].FDescBlockLength[0],0  ;Is Bytes-per-Sector > 65535?
  JNE >F70                           ;If so, error
  MOV  AX,W [BX].FDescBlockLength[1] ;If not, AX
  XCHG AL,AH                         ;  = Bytes per Sector
  CMP  AX,MinSectorSize              ;Is it too small for DOS to handle?
  JB  >F70                           ;If so, error
  CMP  AX,MaxSectorSize              ;Is it too big for DOS to handle?
  JBE >F80                           ;If not, it's OK
F70:                                 ;Error
  STC                                ;Set return flag
  JMP >F90                           ;Done
F80:                                 ;OK
  CLC                                ;Set return flag
F90:                                 ;Done
  POP  BX,EAX                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST A FLEXIBLE DISK PAGE DESCRIPTOR RETURNED BY A DEVICE TO SEE IF IT'S VALID
;Inputs:   DS  = TSR Data Area
;         [BP] = Flexible Disk Descriptor to test (with Header)
;         [DI] = Device Info Entry
;Outputs:  CF  = Clear if OK (Descriptor is OK)
;              = Set if Error (Descriptor is Invalid/Illegal/Incomplete)
;Changes:
;NOTES: Almost every drive I've tested returns a different value for the
;         in the Mode Parameter Header size, even though it should be
;         (ModeParamHdrSize+FlexSize-2).  Therefore, we can't use it
;         as a test.
;       In addition, at least one drive doesn't return a complete Flex
;         Descriptor, so we can't use the size as a test either (it did work
;         for most drives I've tested, but not all).
;       I don't know if changing to a Mode Sense 6 Request (instead of a
;         Mode Sense 10 Request) would make any difference or not, but we
;         may need to resort to that in the future.  Given the problems we've
;         had with devices not returning data at all, or returning data in
;         invalid sizes/formats, I wouldn't be a bit surprised if some disks
;         out there will respond to a 6 request but not a 10 request.
;         I suppose the opposite could be true also (responds to a Mode Sense
;         10 but not a 6), though that seems less likely.  I won't change
;         the code unless it becomes an issue.
;------------------------------------------------------------------------------
TestFlexDescr:
  PUSH AX,SI                    ;Save used registers
  CALL GetFlexPtr               ;Get the Flex Page Pointer (SI)
  JC  >X70                      ;If error, quit
  CMP  [SI].FlexNumHeads,0      ;Valid number of Heads?
  JE  >X70                      ;If not, error
  CMP  [SI].FlexSectsPerTrack,0 ;Valid number of Sectors per Track?
  JE  >X70                      ;If not, error
  MOV  AX,[SI].FlexBytesPerSect ;Get number of
  XCHG AL,AH                    ;  bytes per sector
  CMP  AX,MinSectorSize         ;Is it too small for DOS to handle?
  JB  >X70                      ;If so, error
  CMP  AX,MaxSectorSize         ;Is it too big for DOS to handle?
  JA  >X70                      ;If so, error
  CMP  [SI].FlexNumCylinders,0  ;Valid number of Cylinders?
  JNE >X80                      ;If so, it's OK
X70:                            ;Error
  STC                           ;Set return flag
  JMP >X90                      ;Done
X80:                            ;OK
  CLC                           ;Set return flag
X90:                            ;Done
  POP  SI,AX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TRANSFER DATA FROM THE FLEX DESCRIPTOR TO THE DISK DATA AREA, IF APPROPRIATE
;Inputs:   DS  = TSR Data Area
;         [BP] = Flexible Disk Descriptor to test (with Header)
;         [BX] = Disk Info Structure to copy to
;                [BX].DskBytesPerSect, [BX].DskMaxLBA are both zero if
;                  we need to do something here
;         [DI] = Drive Info Structure
;Outputs: CF = Clear of OK
;              Several data values copied to [BX], if approriate
;            = Set if error
;Changes:
;------------------------------------------------------------------------------
CopyFlexData:
  PUSH AX,CX,DX,SI               ;Save used registers
  CALL GetFlexPtr                ;Get the Flex Page Pointer (SI)
  JC  >Y70                       ;If error, quit
  MOV  AX,[SI].FlexBytesPerSect  ;Get the number of
  XCHG AL,AH                     ;  Bytes per Sector
  CMP  AX,MaxBytesPerSect        ;Is it too big for DOS to handle?
  JA  >Y70                       ;If so, Error
  MOV  [BX].DskBytesPerSect,AX   ;If OK, store it
  XOR  AX,AX                     ;AX =
  MOV  AL,[SI].FlexNumHeads      ;  Number of Heads
  XOR  CX,CX                     ;CX =
  MOV  CL,[SI].FlexSectsPerTrack ;  Number of Sectors Per Track
  MUL  CX                        ;Multiply them
  MOV  CX,[SI].FlexNumCylinders  ;CX =
  XCHG CL,CH                     ;  Number of Cylinders
  MUL  CX                        ;Multiply it (DX:AX = MaxLBA)
  MOV  W [BX].DskMaxLBA[0],AX    ;Store the
  MOV  W [BX].DskMaxLBA[2],DX    ;  Max LBA
  JMP >Y80                       ;Done
Y70:                             ;Error
  STC                            ;Set return flag
  JMP >Y90                       ;Done
Y80:                             ;OK
  CLC                            ;Set return flag
Y90:                             ;Done
  POP  SI,DX,CX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE POINTER TO THE FLEXIBLE DISK PAGE DATA
;Inputs:   DS  = TSR Data Area
;         [BP] = Mode Sense Buffer (after a "Get All" Mode Sense Request)
;         [BX] = Disk Info Structure to copy to
;         [DI] = Drive Info Structure
;Outputs: CF = Clear of OK
;              [SI] = Flexible Disk Page Data
;            = Set if error
;              [SI] = Undefined
;Changes:
;NOTES: Some Devices appear to return data in a Mode Sense 10 format even
;         though they were issued a Mode Sense 6 request.  Therefore, we
;         will check the data size (High-endian Word if Mode Sense 10, Byte
;         if Mode Sense 6) to determine what was returned, rather than
;         depending on what we actually requestd.
;------------------------------------------------------------------------------
GetFlexPtr:
  PUSH AX,CX                      ;Save used registers
  MOV  AX,DS:[BP]                 ;AX = Buffer Data Size
  LEA  CX,[BP].MSenseRespSize     ;[CX] = End of Buffer
  LEA  SI,[BP].ModeParam6HdrSize  ;  Mode Sense 6
  OR   AL,AL                      ;Is it a byte Data Size?
  JNZ >P10                        ;If so, it's Mode Sense 6
  LEA  SI,[BP].ModeParam10HdrSize ;  Mode Sense 10
  OR   AH,AH                      ;Is it a word Data Size?
  JZ  >P70                        ;If not, error
P10:                              ;Loop to here to find Flex Page
  CMP  SI,CX                      ;Are we past the end of the buffer?
  JAE >P70                        ;If so, error
  MOV  AX,[SI]                    ;Get the Code Page (AL) & Page Size (AH)
  OR   AX,AX                      ;Valid data?
  JZ  >P70                        ;If not, error
  AND  AL,FlexPgCodeMask          ;  Code Page
  CMP  AL,SMSensFlexible          ;Is it the one we're looking for?
  JE  >P80                        ;If so, we're done
  SHR  AX,8                       ;If not,
  INC  AX,2                       ;  point at
  ADD  SI,AX                      ;  the next Page
  JMP  P10                        ;Keep looking
P70:                              ;Error
  STC                             ;Set return flag
  JMP >P90                        ;Done
P80:                              ;OK
  CLC                             ;Set return flag
P90:                              ;Done
  POP  CX,AX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST A PARTITION RECORD TO SEE IF THE DRIVE IS A (SUPER)FLOPPY OR NOT
;Inputs:   DS = ES = TSR Data Area
;         [BX] = Disk Info Entry
;         LBAInBuffer = LBA of Sector data that is in the Buffer
;         Partition Stack contains Partition Details
;         SectorBuff filled with Data from Partition Sector
;Outputs: CF = Clear if this is the MBR for a (Super)Floppy
;            = Set if this is Data from a Partition Record
;Changes:
;NOTES: We check here for Volume Boot Records (Floppies & Super-Floppies),
;         Partition Boot Records (hard drives), and Multi-boot Records
;         (hard drives that look like Super-Floppies).  We do a few
;         relatively simple tests to distinguish between VBR's and
;         MBR's, but it's possible that we could be fooled by some exotic
;         IPL without more extensive testing.  It is UNLIKELY that we would
;         be fooled, but it is possible.
;------------------------------------------------------------------------------
TestForFloppy:
  PUSH EAX,BX,CX,SI           ;Save used registers
  CMP  LBAInBuffer,0          ;Is the Data in the Buffer from Sector 0?
  JNE >F70                    ;If not, it can't be (Super)Floppy
  MOV  SI,PartStackPtr        ;[SI] =
  MOV  SI,[SI].PStkOffset     ;  Partition Stack Offset
  CMP  SI,(SectorBuff+(OFFSET MBRPart1)) ;Are we processing the first record?
  JNE >F70                    ;If not, it can't be a (Super)Floppy
  MOV  SI,SectorBuff          ;[SI] = Sector Buffer
  CMP  B [SI],OpCodeJmpShort  ;Is it a possible Volume Boot Record?
  JE  >F10                    ;If so, keep checking
  CMP  B [SI],OpCodeJmpNear   ;Is it a possible Volume Boot Record?
  JNE >F70                    ;If not, it can't be a (Super)Floppy
F10:                          ;Is possibly a (Super)Floppy
  MOV  BL,2                   ;BL = Active Partition Counter
  ADD  SI,(OFFSET MBRPart1)   ;[SI] = Partition 1 Record
  CMP  [SI].PartOpSys,POSNone ;Is it a valid OpSys type?
  JE  >F80                    ;If not, it's a (Super)Floppy
  MOV  CX,4                   ;Need to test a total of 4 partition records
F20:                          ;Loop to here for each partition
  MOV  AL,[SI].PartPrimary    ;AL = Primary (Active) Partition Indicator
  MOV  AH,[SI].PartOpSys      ;AH = OpSys type
  OR   AX,AX                  ;Is it an Invalid OpSys on an Inactive Partition?
  JNZ >F25                    ;If not, continue testing
  CMP  [SI].PartLBASector,0   ;If so, is the Start LBA Sector 0?
  JNE >F80                    ;If not, it's a (Super)Floppy
  CMP  [SI].PartLBALength,0   ;Is the Partition Length 0?
  JE  >F50                    ;If so, it's probably a valid Partition Record
F25:                          ;Not an Invalid OpSys on and Inactive Partition
  OR   AL,AL                  ;Inactive Partition?
  JZ  >F30                    ;If so, check OpSys
  CMP  AL,80h                 ;Active Partition?
  JNE >F80                    ;If so, it's a (Super)Floppy
  DEC  BL                     ;Decrement Active Partition Counter
  JZ  >F80                    ;If >1 Active Partition, it's a (Super)Floppy
F30:                          ;Valid Primary Flag
  OR   AH,AH                  ;Valid OpSys?
  JZ  >F80                    ;If not, it's a (Super)Floppy
F40:                          ;Valid Partition Flag & OpSys
  MOV  EAX,[SI].PartLBASector ;Get the Starting LBA Sector
  OR   EAX,EAX                ;Is it 0?
  JZ  >F80                    ;If so, it's a (Super)Floppy
  CMP  [SI].PartLBALength,0   ;Is the Partition Length 0?
  JE  >F80                    ;If so, it's a (Super)Floppy
  ADD  EAX,[SI].PartLBALength ;Add the Length to the Start
  JC  >F80                    ;If overflow, it's a (Super)Floppy
F50:                          ;Partition record is in a valid format
  ADD  SI,PRecordSize         ;Point at the next partition record
  LOOP F20                    ;Keep testing
F70:                          ;Not a (Super)Floppy
  STC                         ;Set return flag
  JMP >F90                    ;Done
F80:                          ;Is a (Super)Floppy
  CLC                         ;Set return flags
F90:                          ;Done
  POP  SI,CX,BX,EAX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE THE PARTITION STACK TO HANDLE A NEW DISK
;Inputs:  DS = TSR Data Area
;Outputs: PartStackPtr = First Partition Stack Entry
;         First Partition Stack Entry initialized to Sector 0, Partition Index 0
;Changes:
;------------------------------------------------------------------------------
InitPartStack:
  PUSH BX                ;Save used registers
  MOV  BX,PartStack      ;[BX] = First (Current) Partition Stack Record
  MOV  PartStackPtr,BX   ;Store it as the Current Pointer
  MOV  [BX].PStkSector,0 ;First Sector LBA is always 0
  MOV  [BX].PStkOffset,(SectorBuff+(OFFSET MBRPart1)) ;First Index is always 0
  POP  BX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PUSH A PARTITION ENTRY ON TO THE PARTITION STACK
;Inputs:  DS = TSR Data Area
;         PartStackPtr
;         [SI] = Current Partition Entry (in SectorBuff)
;                Points at Record for Extended Partition!
;Outputs: CF = Clear if OK (Space left in Stack)
;              PartStackPtr incremented appropriately
;              Next Partition Details stored on Partition Stack
;              EAX = Sector Number of Next Partition to Retrieve
;            = Set if Error
;              EAX unchanged
;Changes:
;------------------------------------------------------------------------------
PushPart:
  PUSH BX                          ;Save used registers
  MOV  BX,PartStackPtr             ;[BX] = Current Partition Stack Pointer
  CMP  BX,PartStack+((PStkEntries-1)*PStkSize) ;Any room left on the Stack?
  JAE >H70                         ;If not, error
  MOV  [BX].PStkOffset,SI          ;Put Next Partition Record Offset
  ADD  [BX].PStkOffset,PRecordSize ;  on the Stack
  ADD  BX,PStkSize                 ;If OK, update the Stack Pointer
  MOV  PartStackPtr,BX             ;Store it
  MOV  [BX].PStkOffset,(SectorBuff+(OFFSET MBRPart1)) ;Start at Index 0
  MOV  EAX,[SI].PartLBASector      ;Get the Partition LBA Sector
  CMP  BX,(PartStack+(PStkSize*2)) ;Are we in an Extended Partition?
  JB  >H20                         ;If not, it's OK like it is
  ADD  EAX,D [PartStack+PStkSize].PStkSector ;If so, the Sector is Relative to
                                             ;  the first Extended Partition
H20:                               ;Stack entries are set up correctly
  MOV  [BX].PStkSector,EAX         ;Store the Absolute Partition Sector
  JMP >H80                         ;Done
H70:                               ;Error
  STC                              ;Set return flag
  JMP >H90                         ;Done
H80:                               ;OK
  CLC                              ;Set return flag
H90:                               ;Done
  POP  BX                          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;POP A PARTITION ENTRY OFF OF THE PARTITION STACK
;Inputs:  DS = TSR Data Area
;         PartStackPtr
;Outputs: CF = Clear if OK (there is something on the Stack)
;              PartStackPtr decremented appropriately
;              EAX = Sector Number of Next Partition to Retrieve (Previous Part)
;            = Set if Error
;              EAX = Unchanged
;Changes:
;------------------------------------------------------------------------------
PopPart:
  PUSH BX                  ;Save used registers
  MOV  BX,PartStackPtr     ;[BX] = Current Partition Stack Pointer
  CMP  BX,PartStack        ;Already popped everything off the stack?
  JBE >P70                 ;If so, error
  SUB  BX,PStkSize         ;If OK, update the Stack Pointer
  MOV  PartStackPtr,BX     ;Store it
  MOV  EAX,[BX].PStkSector ;EAX = Sector Number of Previous Partition
  JMP >P80                 ;Done
P70:                       ;Error
  STC                      ;Set return flag
  JMP >P90                 ;Done
P80:                       ;OK
  CLC                      ;Set return flag
P90:                       ;Done
  POP  BX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A PARTITION RECORD OFFSET (IN SectorBuff) TO A PARTITION RECORD INDEX
;Inputs:  [SI] = Current Partition Record (in SectorBuff)
;Outputs: CF = Clear if OK (SI is valid)
;              AL = Index Number of Partition Record (0-3)
;            = Set if Error (SI too big)
;              AL = Unchanged
;Changes:
;------------------------------------------------------------------------------
PartOffset2Idx:
  PUSH BX    ;Save used registers
  CMP  SI,(SectorBuff+(OFFSET MBRPart1)) ;Is SI too small?
  JB  >X70   ;If so, error
  CMP  SI,(SectorBuff+(OFFSET MBRPart4)) ;Is SI too big?
  JA  >X70   ;If so, error
  MOV  BX,SI ;If OK, put Pointer in BX
  SUB  BX,(SectorBuff+(OFFSET MBRPart1)) ;Convert to 0-based offset
  SHR  BX,4  ;Divide by 16 (size of each Partition Record)
  MOV  AL,BL ;Store result in AL
  JMP >X80   ;Done
X70:         ;Error
  STC        ;Set return flag
  JMP >X90   ;Done
X80:         ;OK
  CLC        ;Set return flag
X90:         ;Done
  POP  BX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SETUP NEW DRIVE PARAMETERS AS NEEDED FOR A (SUPER) FLOPPY DRIVE
;Inputs:   DS  = TSR Data Area
;         [BX] = Disk Info Entry
;Outputs: NewPartOS, NewPartSector, etc. as needed for (Super)Floppy
;Changes:
;------------------------------------------------------------------------------
InitNewFloppy:
  PUSH EAX                ;Save used registers
  MOV  NewPartOS,-1       ;Partition OS = -1 (Flag for Floppy)
  MOV  NewPartSector,-1   ;Partition Sector = -1 (N/A)
  MOV  NewPartIndex,-1    ;Partition Index = -1 (N/A)
  MOV  NewBootSector,0    ;Boot Sector = 0
  MOV  EAX,[BX].DskMaxLBA ;Store the
  INC  EAX                ;  Number of
  MOV  NewSectsInPart,EAX ;  Sectors
  POP  EAX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SETUP NEW DRIVE PARAMETERS AS NEEDED FOR A HARD DRIVE
;Inputs:   DS  = TSR Data Area
;         [SI] = Partition Record (in SectorBuff)
;         LBAInBuffer = Sector Number of data that is Stored in SectorBuff
;Outputs: NewPartOS, NewPartSector, etc. as needed for Hard Drive
;         EAX = LBA of Boot Sector to retrieve
;Changes:
;------------------------------------------------------------------------------
InitNewHard:
  MOV  AL,[SI].PartOpSys      ;Get the Operating System Flag
  MOV  NewPartOS,AL           ;Store Partition OS
  MOV  EAX,LBAInBuffer        ;Store
  MOV  NewPartSector,EAX      ;  Partition Sector
  MOV  NewBootSector,EAX      ;Store Absolute Boot Sector Start
  CALL PartOffset2Idx         ;Store
  MOV  NewPartIndex,AL        ;  Partition Index
  MOV  EAX,[SI].PartLBALength ;Store the
  MOV  NewSectsInPart,EAX     ;  Number of Sectors
  MOV  EAX,[SI].PartLBASector ;Store the
  ADD  NewBootSector,EAX      ;  Boot Sector
  RET

;------------------------------------------------------------------------------
;ISSUE A ONE-TIME INTERRUPT REQUEST
;Inputs:  DS = TSR Data Area
;         AX = Offset of Return Address to use
;         [SI] = Int 14 Request to use
;                Filled in with User Packet ID, Return Address Segment
;Outputs: Issues Int 14 Request for 1-time Interrupt with 1 mS Periodicity
;         CF = Clear if OK
;              AX = 0
;            = Set if Error
;              AX = Error Code
;Changes:
;------------------------------------------------------------------------------
Start1TimeIntSI:
  PUSH BX,CX                   ;Save used registers
  MOV  W [SI].I14RCallBackAddr[0],AX ;Store return Offset
  MOV  CL,[SI].I14RRequestType ;Save original Request Type
  MOV  [SI].I14RRequestType,I14RRTDoInterrupt1T ;Set up One-time Interrupt
  MOV  BX,[SI].I14RPeriodicity ;Save original Periodicity
  MOV  [SI].I14RPeriodicity,1  ;Wait 1 Millisecond
  CALL DoInt14CallAXSI         ;Do it
  MOV  [SI].I14RRequestType,CL ;Restore original Request Type
  MOV  [SI].I14RPeriodicity,BX ;Restore original Periodicity
  POP  CX,BX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FILL IN DRIVE INFO ENTRY WITH PARAMETERS FOR NEW DRIVE
;Inputs:  DS = ES = TSR Data Area
;         All New Device Drive Parameters filled in
;         [BX] = Disk Info Entry
;         [DI] = Device Info Entry
;         [SI] = Drive Info Entry
;Outputs: Copies New Device Parameters to Drive Parameters Section
;Changes:
;------------------------------------------------------------------------------
CopyNewDriveParams:
  PUSH EAX                     ;Save used registers
  MOV  EAX,NewPartSector       ;Copy
  MOV  [SI].DrvPartSector,EAX  ;  Partition Sector
  MOV  EAX,NewBootSector       ;Copy
  MOV  [SI].DrvBootSector,EAX  ;  Boot Sector
  MOV  EAX,NewSectsInPart      ;Copy
  MOV  [SI].DrvSectsInPart,EAX ;  Number of Sectors
  MOV  AL,NewPartOS            ;Copy
  MOV  [SI].DrvPartOS,AL       ;  Partition Operating System
  MOV  AL,NewPartIndex         ;Copy
  MOV  [SI].DrvPartIndex,AL    ;  Partition Index
  CALL CopyFmtParams           ;Copy Fomrat Parameters
  POP  EAX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY THE PARAMETERS NEEDED FOR FORMATTING FROM THE DISK TO THE DRIVE
;Inputs:   DS  = TSR Data Area
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;Outputs: [SI].DrvFmtXX values
;Changes:
;------------------------------------------------------------------------------
CopyFmtParams:
  PUSH EAX                       ;Save used registers
  MOV  EAX,[BX].DskMaxLBA        ;Copy
  INC  EAX                       ;  the Total Number
  MOV  [SI].DrvFmtTotalSects,EAX ;  of Sectors
  MOV  AX,[BX].DskNumTracks      ;Copy the
  MOV  [SI].DrvFmtCyls,AX        ;  Number of Cylinders
  MOV  AX,[BX].DskNumHeads       ;Copy the
  MOV  [SI].DrvFmtHeads,AX       ;  Number of Heads
  MOV  AX,[BX].DskSectsPerTrack  ;Copy the
  MOV  [SI].DrvFmtSects,AX       ;  Number of Sectors
  POP  EAX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND A MATCHING DISK INFO ENTRY GIVEN A DEVICE INFO ENTRY
;Inputs:   ES  = TSR Data Area
;         [DI] = Device Info Entry to find the Disk Info Entry For
;          AL  = Index Number (0-based) of Disk Info Entry to find
;                (Index Number = LUN Number)
;Outputs: CF = Clear if OK (Matching Entry Found)
;              [BX] = Matching Disk Info Entry
;            = Set if Error
;              BX = Undefined
;Changes:
;------------------------------------------------------------------------------
GetDiskForDevice:
  PUSH AX,DS             ;Save used registers
  MOV  DS,ES             ;DS = TSR Data ARea
  MOV  BX,DiskInfoOffset ;[BX] = Disk Info Table
  MOV  AH,B NumDisks[0]  ;AH = Number of Table Entries
K10:                     ;Loop to here for each Table Entry
  TEST [BX].DskFlags,DskFlagInUse ;Valid entry?
  JZ  >K40               ;If not, skip it
  CMP  [BX].DskDvcOffset,DI ;Is it on the Device we're looking for?
  JNE >K40               ;If not, skip it
  CMP  [BX].DskLUN,AL    ;Is it the correct LUN?
  JE  >K80               ;If so, we're done
K40:                     ;Done with this Table Entry
  ADD  BX,DiskInfoSize   ;Point at the next Table Entry
  DEC  AH                ;Decrement the Loop Counter
  JNZ  K10               ;If not done yet, keep looking
K70:                     ;Error
  STC                    ;Set return flag
  JMP >K90               ;Done
K80:                     ;OK
  CLC                    ;Set return flag
K90:                     ;Done
  POP  DS,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND A MATCHING DRIVE INFO ENTRY GIVEN A DISK INFO ENTRY
;Inputs:   ES  = TSR Data Area
;         [BX] = Disk Info Entry to find the Drive Info Entry For
;          AL  = Index Number (0-based) of Drive Info Entry to find
;Outputs: CF = Clear if OK (Matching Entry Found)
;              [SI] = Matching Disk Info Entry
;            = Set if Error
;              SI = Undefined
;Changes:
;------------------------------------------------------------------------------
GetDriveForDisk:
  PUSH AX,DS              ;Save used registers
  MOV  DS,ES              ;DS = TSR Data ARea
  INC  AL                 ;Turn 0-based Index to 1-based
  MOV  SI,DriveInfoOffset ;[BX] = Drive Info Table
  MOV  AH,B NumDrives[0]  ;AH = Number of Table Entries
V10:                      ;Loop to here for each Table Entry
  TEST [SI].DrvFlags,DrvFlagValid ;Valid entry?
  JZ  >V40                ;If not, skip it
  TEST [SI].DrvFlags,DskFlagInUse ;Valid entry?
  JZ  >V40                ;If not, skip it
  CMP  [SI].DrvDskOffset,BX ;Is it on the Disk we're looking for?
  JNE >V40                ;If not, skip it
  DEC  AL                 ;If so, is it the correct Index?
  JZ  >V80                ;If so, we're done
V40:                      ;Done with this Table Entry
  ADD  SI,DriveInfoSize   ;Point at the next Table Entry
  DEC  AH                 ;Decrement the Loop Counter
  JNZ  V10                ;If not done yet, keep looking
V70:                      ;Error
  STC                     ;Set return flag
  JMP >V90                ;Done
V80:                      ;OK
  CLC                     ;Set return flag
V90:                      ;Done
  POP  DS,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESET A DPB TO A NORMAL (UNUSED) STATE
;Inputs:  DS = TSR Data Area
;         [BX] or [DI] = Drive Info Entry to Reset DPB in
;Outputs: Resets all appropriate DPB Values
;Changes:
;NOTES: This is done when a USB Device is removed, so we need to keep some
;         "basic" information (like the Drive Number) intact.  We basically
;         just want the drive to look like it's never been installed.
;       We set it up to look like a 0kB Floppy, with a Media ID of 0
;         (No Media Installed).
;------------------------------------------------------------------------------
ResetDPBDI:
  PUSH BX         ;Save used registers
  MOV  BX,DI      ;BX] = Drive Info Entry
  CALL ResetDPBBX ;Reset it
  POP  BX         ;Restore used registers
  RET

ResetDPBBX:                       ;Set up as unaccessed 0k Floppy
  PUSH BX                         ;Save used registers
  ADD  BX,(OFFSET DrvDPB)         ;[BX] = DPD
  ;Leave Drive Number & Unit Number intact
  MOV  [BX].DPBBytesPerSect,32    ;Bytes Per Sector = 32
  MOV  [BX].DPBHiSectInCluster,1  ;Highest Sector in Cluster = 1
  MOV  [BX].DPBSectorShift,1      ;Sector Shift = 1
  MOV  [BX].DPBReservedSects,1    ;Reserved Sectors = 1
  MOV  [BX].DPBNumFATS,2          ;Number of FATs = 2
  MOV  [BX].DPBRootEntries,2      ;Number of Root Directory Entries = 2
  MOV  [BX].DPBFirstUserSector,2  ;First User Sector = 2
  MOV  [BX].DPBHighestCluster,2   ;Highest Cluster = 2
  MOV  [BX].DPBSectorsPerFAT,2    ;Sectors Per FAT = 2
  MOV  [BX].DPBRootSector,2       ;Root Sector = 2
  ;Leave Device Driver Pointer intact
  MOV  [BX].DPBMediaID,0          ;Media ID = 0 (Real 360k Floppy = FDh)
  MOV  [BX].DPBAccessed,-1        ;Accessed = No
  ;Leave Next DPB Pointer intact
  MOV  [BX].DPBStartCluster,0     ;Starting Search Cluster = 0
  MOV  [BX].DPBFreeClustersL,-1   ;Free Clusters = Unknown
  ;Leave extended DPB values (FAT32) alone
  POP  BX                         ;Restore used registers
  RET

;Valid Partition Operating System Flags that we (DOS) can handle
;Does this need to change based on DOS version?
ValidPOSList:
  DB POSFAT12      ;01h FAT-12
  DB POSFAT16      ;04h Fat-16 (<= 32M)
  DB POSDOSExt     ;05h DOS Extended
  DB POSFAT16H     ;06h Fat-16 (> 32M)
  DB POSFAT32      ;0Bh Fat-32 (<= 8G?)
  DB POSFAT32LBA   ;0Ch Fat-32 w/ LBA Extensions (<= 2T)
  DB POSLBAVFAT16H ;0Eh FAT16H w/ LBA Extensions
  DB POSLBAVFATExt ;0Fh DOSExt w/ LBA Extensions
;  DB POSFAT32H     ;1Bh FAT-32 Hidden
;  DB POSFAT32HH    ;1Ch FAT-32 Hidden w/ LBA Extension
;  DB POSLBAVFATH   ;1Eh LBA VFAT Hidden
;  DB POSDOS33Sec   ;F2h DOS 3.3+ Secondary
  DB 0 ;End of Table

;------------------------------------------------------------------------------
;TEST A PARTITION OPERATING SYSTEM BYTE TO SEE IF WE SUPPORT IT
;Inputs:  DS = TSR Data Area
;         AL = Partition Operating System Byte to test
;         TSRFlags.UseFAT32
;         ValidPOSList
;         CLD Already issued
;Outputs: CF = Clear if OK (OS is in the Table)
;            = Set if Error (OS is not in the Table)
;Changes:
;------------------------------------------------------------------------------
TestValidPOS:
  PUSH AX,SI             ;Save used registers
  MOV  SI,ValidPOSList   ;[SI] = POS Table
  MOV  AH,AL             ;AH = Byte to Look for
O10:                     ;Loop to here for each table entry
  LODSB                  ;Get the next table entry
  OR   AL,AL             ;End of the Table?
  JZ  >O70               ;If so, error
  CMP  AL,AH             ;If not, is it a match?
  JNE  O10               ;If not, keep looking
O20:                     ;POS is in the table
  TEST TSRFlags,UseFAT32 ;Do we support FAT32?
  JNZ >O80               ;If so, we're done
  CMP  AH,POSFAT32       ;If not, is it FAT32?
  JE  >O70               ;If so, we don't support it
  CMP  AH,POSFAT32LBA    ;Is it FAT32?
  JNE >O80               ;If not, it's OK
O70:                     ;Error
  STC                    ;Set return flag
  JMP >O90               ;Done
O80:                     ;OK
  CLC                    ;Set return flag
O90:                     ;Done
  POP  SI,AX             ;Restore used registers
  RET


;Need a StageTable for all Stages >= 200, use to print appropriate
;  stage messages in Bad Table
;  E.g.: StageNoIntf    EQU 200
;        StageIntfClass EQU 201
;        etc.
;Use bad table to store incompatible devices also, with reason for
;  incompatibility.  Need to make sure we set appropriate values in
;  AX before issuing FinishUpBadDevice -- Indicating some sort of clue
;  as to the problem (e.g., putting actual Peripheral Device Type in Error
;  if it's not DASD).
;In FinishUpBadDevice, test Stage Number -- Just beep for truly "bad" devices,
;  not just ones we don't support with this program (CD-ROM's, e.g.).
;Do something similar in other programs


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT FUNCTIONS NEEDED BY LOOKFORNEWDEVICE PROCESS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;FINISH UP A BAD DEVICE ENTRY
;Inputs:  [BX] = Disk Info Entry
;         [DI] = Device Info Entry
;         DS = ES = TSR Data Area
;         AX = Error Code to Store
;         NewDeviceStage already filled in
;Outputs: Puts Device info in BadDevice Table
;         Resets DeviceInfoTable Entry
;         Marks Int14Request as available (not in use any more)
;         Issues Request to Beep the Speaker, if appropriate
;         NewDvcCounter reset to look for another New Device right away
;         Issues Request to host indicating we're done Configuring
;Changes: BX,DI,SI
;NOTES: If FinishUpBadDevice0, [BX] = Device Info Entry, [DI] = Undefined
;         (this is being called early in the LookForNewDevice process,
;         before a Disk Info Entry has been assigned & before we have
;         started issuing SCSI Requests).
;------------------------------------------------------------------------------
FinishUpBadDevice0:
  MOV  DI,BX                         ;[DI] = Device Info Entry
  XOR  BX,BX                         ;[BX] = Undefined

FinishUpBadDevice:
  MOV  SI,Int14Request               ;Point at Int14 Request Structure
  MOV  NewDeviceError,AX             ;Store Error Code
  MOV  [SI].I14RRequestType,I14RRTGetDvcStatus ;Request = Get Dvc Status
                                               ;(Make sure Device is still
                                               ;  plugged in)
  PUSH W [DI].DvcHostIndex           ;Store Host Index
  POP  W [SI].I14RHostIndex          ;  and Device Address
  CALL DoInt14CallSaveAllSI          ;Issue the Request
  JC  >B10                           ;If error (no Device), don't add to Bad Tbl
  CALL AddBadDevice                  ;Add it to Bad Table
B10:                                 ;Bad Device added to table, if appropriate
  CALL ResetDvcEntryDI               ;Reset the Dvc Info Entry that we Reserved
  TEST TSRFlags,(NoBeep+NoBeep1Time) ;Are we allowed to Beep the Speaker
  JNZ >B20                           ;If not, skip down
  MOV  [SI].I14RRequestType,I14RRTBeepSpeaker ;Want to beep the Speaker
  MOV  [SI].I14RHostIndex,-1         ;Any Host
  MOV  B [SI].I14RTimeout,3          ;Beep length = 3 DeciSeconds
  MOV  W [SI].I14RBeepFrequency,300  ;Frequency = 300Hz
  CALL DoInt14CallSaveAllSI          ;Do it
  MOV  B [SI].I14RTimeOut,0          ;Reset Timeout Value
B20:                                 ;Done Handling Beep
  AND  TSRFlags,(NOT NoBeep1Time)    ;Mark as OK to Beep next time
  MOV  [SI].I14RRequestType,I14RRTConfigIntfDone ;Request = Done Configuring
  CALL DoInt14CallSaveAllSI          ;Do it
  CMP  NewDvcCounter,0               ;Disabled?
  JE  >B90                           ;If so, Done
  MOV  NewDvcCounter,2               ;Look for another Device soon
B90:                                 ;Done
  AND  TSRFlags,(NOT (Int14ReqInUse+SectBuffInUse)) ;Mark as available
  RET

;------------------------------------------------------------------------------
;CLEAR OUT THE OLD DATA FROM THE DESCRIPTOR DATA BUFFER
;Inputs:  ES = TSR Data Area
;Outputs:
;Changes: DescriptorData becomes all zeroes
;------------------------------------------------------------------------------
ClearDescriptorData:
  PUSH AX,CX,DI                 ;Save used registers
  MOV  DI,DescriptorData        ;Point at buffer
  MOV  CX,(MaxDescriptorSize/2) ;Number of words to write
  XOR  AX,AX                    ;Write zeroes
  REP  STOSW                    ;Do it
  POP  DI,CX,AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND A PARTICULAR TYPE OF DESCRIPTOR IN THE COMPLETE CONFIGURATION DESCRIPTOR
;Inputs:  DS = ES = TSR Data Area
;         [DI] = Pointer to start/middle of Configuration Descriptor
;          AL  = Descriptor Type to find
;Outputs: CF = Set if OK (Descriptor Found)
;              [DI] points at beginning of Descriptor
;               AX = Descriptor Length
;            = Clear if Error (Descriptor not found)
;              AX, DI unchanged
;Changes:
;------------------------------------------------------------------------------
FindDescrType:
  PUSH BX,SI              ;Save used registers
  MOV  SI,DI              ;Point SI at the starting Pointer
  XOR  BH,BH              ;Initialize high byte of Size to 0
Y10:                      ;Loop here to find Descriptor
  MOV  BL,[SI].DDLength   ;Put the Length in BL
  OR   BL,BL              ;Valid Descriptor?
  JZ  >Y70                ;If not, Error
  CMP  AL,[SI].DDDescType ;The Descriptor we're looking for?
  JE  >Y80                ;If so, we're done
  ADD  SI,BX              ;If not, point at next Descriptor
  CMP  SI,(DescriptorData+MaxDescriptorSize) ;Gone past the end of the buffer?
  JBE  Y10                ;If not, keep looking
Y70:                      ;Error
  STC                     ;Set Error Flag
  JMP >Y90                ;Done
Y80:                      ;OK
  MOV  DI,SI              ;Update Pointer
  MOV  AX,BX              ;Put length in AX
  CLC                     ;Set OK Flag
Y90:                      ;Done
  POP  SI,BX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND AND VERIFY THE END POINT NUMBERS FOR THE DEVICE
;Inputs:  DS = ES = TSR Data Area
;         [BX] = Info Table Pointer
;                No EndPoint Data filled in (All Zeroes)
;         [DI] = Interface Descriptor in DescriptorData to look through
;         Info Table SubClass and Protocol already copied
;Outputs: CF = Clear if OK (got EndPoint Info)
;              EndPoint Data filled in
;            = Set if Error (somehing wrong with Data)
;Changes:
;NOTES: I have seen at least one Mass Storage Device that claims to
;         be Bulk Only, but has an Interrupt EndPoint defined.  Acording
;         to the Bulk-only Specification, this is not possible.
;       We will not consider an Interrupt EndPoint on a Bulk-Only
;         Device to be an error, though we will probably not have any idea
;         what to do with it.
;------------------------------------------------------------------------------
GetEndPointNums:
  PUSH AX,CX,DI,SI                          ;Save used registers
  ADD  DI,InterfaceDescriptorSize           ;Skip over the Interface Descriptor
P10:                                        ;Loop to find End Points
  CMP  [DI].DDDescType,DescrTypeEndPoint    ;Is it an EndPoint Descriptor?
  JNE >P60                                  ;If not, we're done
  MOV  AX,W [DI].EDEndPointNumber           ;AL = Number, AH = Attribs
  AND  AH,EDAttrTransTypeMask               ;AH = EndPoint Transaction Type
  CMP  AH,EDAttrInterrupt                   ;Is it Interrupt?
  JE  >P30                                  ;If so, jump to handle it
  CMP  AH,EDAttrBulk                        ;Is it Bulk?
  JNE >P70                                  ;If not, Error
P20:                                        ;Is a Bulk EndPoint
  MOV  SI,OFFSET DvcEndPointOut             ;Assume it's Out
  TEST AL,EDDirectionIn                     ;Is it Out?
  JZ  >P40                                  ;If so, continue
  MOV  SI,OFFSET DvcEndPointIn              ;If not, point at In Offset
  JMP >P40                                  ;Continue
P30:                                        ;Is an Interrupt EndPoint
  TEST AL,EDDirectionIn                     ;Does Direction = In?
  JZ  >P70                                  ;If not, Error
  MOV  SI,OFFSET DvcEndPointInt             ;Point at Int EndPoint Offset
P40:                                        ;[BX+SI] = EndPoint Offset to Store
  AND  AL,EDNumberMask                      ;Get the EndPoint Number
  OR   AL,AL                                ;Is it valid?
  JZ  >P70                                  ;If not, Error
  CMP  B [BX+SI],0                          ;Is an EndPoint already stored?
  JNE >P70                                  ;If so, Error
  MOV  B [BX+SI],AL                         ;If not, store it
P50:                                        ;Done with this EndPoint Descr
  XOR  AH,AH                                ;Point at
  MOV  AL,[DI].EDLength                     ;  the next
  ADD  DI,AX                                ;  Descriptor
  JMP  P10                                  ;Keep looking
P60:                                        ;Done with EndPoints
  CMP  [BX].DvcEndPointIn,0                 ;Did we get a valid In EndPoint?
  JE  >P70                                  ;If not, Error
  CMP  [BX].DvcEndPointOut,0                ;Did we get a valid Out EndPoint?
  JE  >P70                                  ;If not, Error
  CMP  [BX].DvcIntfProtocol,IntfProtocolCBI ;Do we need an Interrupt EndPoint?
  JNE >P80                                  ;If not, we're done
  CMP  [BX].DvcEndPointInt,0                ;If so, did we get an Int EndPoint?
  JNE >P80                                  ;If so, we're done
P70:                                        ;Error
  STC                                       ;Set Error Flag
  JMP >P90                                  ;Done
P80:                                        ;OK
  CLC                                       ;Set OK Flag
P90:                                        ;Done
  POP  SI,DI,CX,AX                          ;Restoer used registers
  RET

;------------------------------------------------------------------------------
;COPY A REQUEST (CONTROL) STRUCTURE INTO THE INT14 STRUCTURE
;Inputs:  [CX] = Request Structure to Copy
;         ES = TSR Data Area (contains both Request & Int14 Request)
;         [DI] = Int14 Request Structure to copy it to
;      or [SI] = Int14 Request Structure to copy it to
;Outputs:
;Changes: Int14 Structure contains Request Structure Data
;------------------------------------------------------------------------------
CopySetupReqToInt14SI:
  PUSH DI                    ;Save used registers
  MOV  DI,SI                 ;Put pointer in DI
  CALL CopySetupReqToInt14DI ;Copy it
  POP  DI                    ;Restore used registers
  RET

CopySetupReqToInt14DI:
  PUSH CX,DI,SI,DS                ;Save used registers
  MOV  DS,ES                      ;Point DS at TSR Data Area
  ADD  DI,OFFSET I14RSetupReqData ;Point at correct part of structure
  MOV  SI,CX                      ;Point at structure to copy
  MOV  CX,(SetupRequestSize/2)    ;Number of words to copy
  REP  MOVSW                      ;Copy it
  POP  DS,SI,DI,CX                ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS NOTIFICATIONS FROM THE HOST DRIVER REGARDING DEVICE CHANGES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE A NOTIFICATION FROM THE HOST DRIVER FOR SOMETHING RELATED TO THE DEVICE
;Inputs:  AX = Device Owner Call Code (various possibilities)
;         [BX] = Info Table Offset
;         CX, DX = Varies by exact type of call
;         DS = ES = TSR Data Area
;Outputs: Depends on Call Type
;         Calls appropriate "subfunction"
;Changes: Nearly all registers
;------------------------------------------------------------------------------
DvcOwnerFarCall:
  CLD                          ;Go forward with string functions
  MOV  DI,BX                   ;Point DI at the Info Table Entry
  MOV  BX,OwnerCallFunctionTbl ;Point at the Function table to search
  CALL SearchByte2WordTblDS    ;Look for the function (in AL)
  JC  >H90                     ;If invalid function, quit
  CALL BX                      ;If OK, do it
H90:
  RETF

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST SAYING THAT A NEW DEVICE HAS BEEN ADDED
;Inputs:  [DI] = Info Table Entry
;         DS = ES = TSR Data Area
;         CL = Host Index
;         CH = Device Address
;         DL = Interface
;         DH = Alternate Interface
;Outputs:
;Changes: Prompts us to look for a new Device earlier than normal
;NOTES:   Originally, this routine directly called LookForNewDevice.
;         For some reason, this did not work with some Devices (they would
;           return bad descriptors).  This is probably due to the Devices not
;           being given enough time to "reorganize" themselves after the
;           enumeration process of the Host Driver, which downloads the same
;           descriptors we download again here.
;         So now, instead of calling LookForNewDevice directly, this routine
;           sets the NewDvcCounter to a small number so that we look for
;           the new Device after a small delay.  Doing it after a small
;           delay, instead of doing it immediately, seems to work better
;           (at least with some Devices).
;------------------------------------------------------------------------------
DeviceAdded:
  CMP  NewDvcCounter,0 ;Disabled?
  JE  >A90             ;If so, quit
  MOV  NewDvcCounter,2 ;If not, look for a new Device right away
A90:                   ;Done
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST SAYING THAT A DEVICE HAS BEEN DISCONNECTED
;Inputs:  [DI] = Device Info Table Entry
;         DS = ES = TSR Data Area
;         CL = Host Index
;         CH = Device Address
;Outputs:
;Changes: Removes Device from Configuration
;NOTES:   This is called if a REGISTERED Device has been disconnected
;------------------------------------------------------------------------------
DeviceDisconnected:
  CALL ResetDvcEntryDI ;Delete entry from our table
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST SAYING THAT AN UNREGISTERED DEVICE IS DISCO'D
;Inputs:  DS = ES = TSR Data Area
;         CL = Host Index
;         CH = Device Address
;Outputs:
;Changes:
;NOTES: This is called if an UNREGISTERED Device has been disconnected,
;         so it will NOT be in DeviceInfoTable.  It may or may not be
;         in the BadDeviceTable.
;------------------------------------------------------------------------------
Device0Disconnected:
  CALL DeleteBadDevices      ;Delete the Bad Entries from our Table, if there
  CMP  CX,W NewWaitHostIndex ;Is it the Device we're currently waiting on?
  JNE >D90                   ;If not, we're done
  MOV  NewWaitDvcAddress,0   ;If so, we don't need to wait any more
  CMP  NewDvcCounter,0       ;Currently disabled?
  JE  >D90                   ;If so, we're done
  MOV  NewDvcCounter,2       ;Look for another Device right away
D90:                         ;Done
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST TO TEMPORARILY STOP LOOKING FOR DEVICES
;Inputs:  DS = ES = TSR Data Area
;         CL = Host Index
;         CH = Device Address
;         DL = Interface Number
;         DH = TimeOut Value to use (deciseconds)
;         DI = Device Info Table Entry
;Outputs: DontLookCounter
;Changes:
;NOTES: This should only be called if a Device-specific Driver is trying
;         to take control of an already registered device from us.
;       We actually stop looking for ALL new Interfaces, rather than just
;         the one that is being requested.
;------------------------------------------------------------------------------
StartDontLook:
  PUSH AX,BX,DX,SI        ;Save used registers
  MOV  DontLookCounter,-1 ;Start not looking
  MOV  SI,Int14Request2   ;Point at Request Structure
  CALL RlsDvcNoResetDI    ;Release the Device, don't Reset it
  MOV  AL,DH              ;Put seconds in AL
  XOR  AH,AH              ;Multiply
  MOV  BX,18206           ;  seconds
  MUL  BX                 ;  by
  MOV  BX,10000           ;  1.8206
  DIV  BX                 ;  (number of timer ticks per decisecond)
  CMP  DX,5000            ;Do we need to round up?
  JB  >S90                ;If not, continue
  INC  AX                 ;If so, round up
S90:                      ;Done
  INC  AX                 ;Add one more Timer Tick for good measure
  MOV  DontLookCounter,AX ;Store the Counter Value
  POP  SI,DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM A HOST SAYING THAT IT'S BEEN UNINSTALLED
;Inputs:  CL = USB Host Index that isn't there any more
;         DS = ES = TSR Data Area
;Outputs:
;Changes:
;------------------------------------------------------------------------------
HostDisconnected:
  PUSH BX,DI                      ;Save used registers
  MOV  DI,DeviceInfoOffset        ;[DI] = Table to use
  MOV  BL,B NumDevices[0]         ;BL = Number of table entries
D20:                              ;Loop to here for each table entry
  TEST [DI].DvcFlags,DvcFlagInUse ;Empty Table Entry?
  JZ  >D40                        ;If so, skip it
  CMP  [DI].DvcHostIndex,CL       ;Is it the Host this Device is on?
  JNE >D40                        ;If not, skip it
  CALL ResetDvcEntryDI            ;Delete it from the Info Table
D40:                              ;Done with this table entry
  ADD  DI,DeviceInfoSize          ;Point at the next Table Entry
  DEC  BL                         ;Decrement loop counter
  JNZ  D20                        ;If not done yet, keep looking
  POP  DI,BX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE VARIOUS REQUESTS FROM THE USB HOST DRIVER ABOUT UPSTREAM CHANGES
;Inputs:  Depends on Call
;Outputs:
;Changes: We don't care about any of these calls, since they don't directly
;           affect our program.  Any critical changes to upstream devices
;           are eventually reflected to us as a call directly addressing
;           one of our Devices, which is how we handle those things.
;------------------------------------------------------------------------------
DeviceEnabled:        ;Device Enabled
DeviceDisabled:       ;Device Disabled
DeviceReset:          ;Device Reset
DeviceSuspend:        ;Device Suspended
DeviceResume:         ;Device Resumed
DevicePowerOn:        ;Device Power On
DevicePowerOff:       ;Device Power Off
DevicePowerReset:     ;Device Power Reset
NewHostAdded:         ;New Host Added
HostHWErr:            ;Host System/Processor Error
HostRun:              ;Host Running
HostStop:             ;Host Stopped
HostReset:            ;Host Reset
HostSuspend:          ;Host Suspended
HostResume:           ;Host Resumed
HostDebug:            ;Host in Debug Mode
HostSST:              ;Host Single-Stepped
TimingChange:         ;Host Timing Change
DeviceDisconnectedUS: ;Device Disconnect Upstream
DeviceEnabledUS:      ;Device Enable Upstream
DeviceDisabledUS:     ;Device Disable Upstream
DeviceResetUS:        ;Device Reset Upstream
DeviceSuspendUS:      ;Device Suspend Upstream
DeviceResumeUS:       ;Device Resume Upstream
DevicePowerOnUS:      ;Device Power On Upstream
DevicePowerOffUS:     ;Device Power Off Upstream
DevicePowerResetUS:   ;Device Power Reset Upstream
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE TO RELEASE/RESET A DEVICE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;COMPLETELY RELEASE A DEVICE THAT WE CURRENTLY OWN (POSSIBLY INCLUDING A RESET)
;Inputs:  DS = ES = TSR Data Area
;         [DI] = Device Info Entry to Release
;         [SI] = Int 14 Request to use
;Outputs: Releases Device Entry
;           Closes Periodic Handle
;           Unregisters as Interface Owner
;           Resets Device (if appropriate)
;           Resets Device Info Entry
;Changes:
;------------------------------------------------------------------------------
RlsDvcNoResetDI:
  PUSH BX                            ;Save used registers
  XOR  BL,BL                         ;Mark as No Reset
  JMP >R00                           ;Do it
RlsDvcDoResetDI:
  PUSH BX                            ;Save used registers
  MOV  BL,-1                         ;Mark as a Reset
;  JMP >R00                           ;Do it
R00:
  PUSH AX                            ;Save used registers
  MOV  W [SI].I14RCallBackAddr[0],-1 ;Set CallBackAddr to nothing
  MOV  AX,W [DI].DvcHostIndex        ;Copy Host Index and
  MOV  W [SI].I14RHostIndex,AX       ;  Device Address
  MOV  AX,[DI].DvcRegHandle          ;Copy
  MOV  [SI].I14RRequestHandle,AX     ;  Registry Handle
  MOV  [SI].I14RRequestType,I14RRTUnRegIntfOwner ;Request = UnRegister
  CALL DoInt14CallSaveAllSI          ;Do it
  OR   BL,BL                         ;Need to Reset the Device?
  JZ  >R80                           ;If not, we're done
  MOV  [SI].I14RRequestType,I14RRTResetDevice ;Request = Reset
  CALL DoInt14CallSaveAllSI          ;Do it
R80:                                 ;Done with Host
  CALL ResetDvcEntryDI               ;Delete the Device Info Entry
  POP  AX                            ;Restore used registers
  POP  BX                            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESET A DEVICE INFO TABLE ENTRY
;Inputs:  DS = ES = TSR Data Area
;        [DI] = Device Info Table Entry to reset
;         CLD already issued
;Outputs:
;Changes: Resets (clears out) the Device Info Table Entry,
;           along with all the associated Disk and Drive Table Entries
;NOTES: Unlike most routines, this one preserves Flags across the Call!
;------------------------------------------------------------------------------
ResetDvcEntryDI:
  PUSH AX,CX,DI         ;Save used registers
  PUSHF                 ;Save flags
  CLI                   ;Disable interrupts
  CALL ResetDisks4DvcDI ;Reset associated Disk and Drive entries
  XOR  AX,AX            ;Need to store zeroes
  MOV  CX,((OFFSET DvcInt14Request)/2) ;CX = Number of Words to write
  REP  STOSW            ;Reset the reset of the table

;Need to shut down interrupts/cancel pending requests here?

  POPF                  ;Restore flags
  POP  DI,CX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESET ALL DISK INFO ENTRIES ASSOCIATED WITH A PARTICULAR DEVICE
;Inputs:  DS = ES = TSR Data Area
;        [DI] = Device Info Table Entry to reset
;         CLD already issued
;Outputs:
;Changes: Resets (clears out) the Drive Info Table Entry,
;           along with all the associated Drive Table Entries
;------------------------------------------------------------------------------
ResetDisks4DvcDI:
  PUSH AX,BX,CX,DI                ;Save used registers
  MOV  BX,DI                      ;[BX] = Device Info Table
  MOV  DI,DiskInfoOffset          ;[DI] = Disk Info Table
  MOV  CX,NumDisks                ;CX = Number of Table Entries
K10:                              ;Loop to here for each Drive
  TEST [DI].DskFlags,DskFlagInUse ;Valid Entry?
  JZ  >K40                        ;If not, skip it
  CMP  [DI].DskDvcOffset,BX       ;If so, is it for this Disk?
  JNE >K40                        ;If not, skip it
  CALL ResetDrvs4DiskDI           ;If so, reset assoicated Drive Entries
  MOV  AH,[DI].DskInt13DrvNum     ;Save Int13h Drive Number
  PUSH CX,DI                      ;If so, save Counter & Pointer
  MOV  CX,(OFFSET DskCBW)         ;CX = Number of Bytes to write
  XOR  AL,AL                      ;Write zeroes
  REP  STOSB                      ;Do it
  POP  DI,CX                      ;Restore Counter & Pointer
  MOV  [DI].DskInt13DrvNum,AH     ;Restore Int 13h Drive Number
  CALL ResetFDPTAH                ;If so, reset the Fixed Disk Parameter Table
K40:                              ;Done with this entry
  ADD  DI,DiskInfoSize            ;Point at the next table entry
  LOOP K10                        ;Keep going until we're done
  POP  DI,CX,BX,AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESET ALL DRIVE INFO ENTRIES ASSOCIATED WITH A PARTICULAR DISK
;Inputs:  DS = ES = TSR Data Area
;        [DI] = Disk Info Table Entry to reset
;     or [BX] = Disk Info Table Entry to reset
;         CLD already issued
;Outputs:
;Changes: Resets (clears out) all the associated Drive Table Entries
;------------------------------------------------------------------------------
ResetDrvs4DiskBX:
  PUSH DI               ;Save used registers
  MOV  DI,BX            ;[DI] = Disk Info Pointer
  CALL ResetDrvs4DiskDI ;Reset All Drives
  POP  DI               ;Restore used registers
  RET

ResetDrvs4DiskDI:
  PUSH AX,BX,CX,DI                ;Save used registers
  PUSHF                           ;Save flags
  CLI                             ;Disable Interrupts
  MOV  BX,DI                      ;[BX] = Device Info Table
  MOV  DI,DriveInfoOffset         ;[DI] = Drive Info Table
  MOV  CX,NumDrives               ;CX = Number of Table Entries
V10:                              ;Loop to here for each Drive
  TEST [DI].DrvFlags,DrvFlagValid ;Valid Entry?
  JZ  >V40                        ;If not, skip it
  TEST [DI].DrvFlags,DrvFlagInUse ;Valid Entry?
  JZ  >V40                        ;If not, skip it
  CMP  [DI].DrvDskOffset,BX       ;If so, is it for this Drive?
  JNE >V40                        ;If not, skip it
  CALL ResetDPBDI                 ;Reset the DPB
  PUSH CX,DI                      ;If so, save counter
  MOV  CX,(((OFFSET DrvDPB)+1)/2) ;CX = Number of Words to write
  XOR  AX,AX                      ;Write zeroes
  REP  STOSW                      ;Do it
  POP  DI,CX                      ;Restore Pointer
  OR   [DI].DrvFlags,DrvFlagValid ;Mark entry as Valid again
V40:                              ;Done with this entry
  ADD  DI,DriveInfoSize           ;Point at the next table entry
  LOOP V10                        ;Keep going until we're done
  POPF                            ;Restore flags
  POP  DI,CX,BX,AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESET A FIXED DISK PARAMETER TABLE
;Inputs:  DS = ES = TSR Data Area
;         AH = Disk Number to Reset
;         CLD already issued
;Outputs: Resets appropriate FDPT
;Changes:
;------------------------------------------------------------------------------
ResetFDPTAH:
  PUSH DI           ;Save used registers
  MOV  DI,FDPT80h   ;Assume Disk 80h
  CMP  AH,81h       ;Is it Disk 80h or 81h?
  JA  >R90          ;If neither, we're done
  JB  >R10          ;If Disk 80h, continue
  MOV  DI,FDPT81h   ;It's Disk 81h
R10:                ;[DI] = FDPT entry to Reset
  CALL CopyFDPT10MB ;Copy the Default Data
R90:                ;Done
  POP  DI           ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO FIND/STORE ENTRIES IN VARIOUS STRUCTURE-BASED TABLES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;CONVERT A DEVICE INFO INDEX TO AN OFFSET
;Inputs:  ES = Data Segment where data is located
;         CL = Device Index, or BL = Device Index (if DIIndex2OffsetBL)
;Outputs: DI = Offset to Table Entry (Assuming ES is the segment)
;Changes:
;------------------------------------------------------------------------------
DIIndex2OffsetBL:
  PUSH CX             ;Save used registers
  MOV  CL,BL          ;Put Index in CL
  CALL DIIndex2Offset ;Do it
  POP  CX             ;Restore used registers
  RET

DIIndex2Offset:
  PUSH AX,CX,DX               ;Save used registers
  XOR  CH,CH                  ;Index is actually a byte
  MOV  DI,ES:DeviceInfoOffset ;[DI] = Beginning of Table
  MOV  AX,DeviceInfoSize      ;AX = Size of each entry
  MUL  CX                     ;Multiply Index by the size of each entry
  ADD  DI,AX                  ;Add the offset of the beginning of the table
  POP  DX,CX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND AN EMPTY INFO TABLE ENTRY
;Inputs:  DS = ES = TSR Data Area
;Outputs: ZF = Clear if OK (found an empty Table entry)
;              [BX] = Table Entry
;            = Set if error (Table is full)
;               BX  = 0
;Changes:
;------------------------------------------------------------------------------
FindEmptyInfoBX:
  PUSH CX                         ;Save used registers
  MOV  BX,DeviceInfoOffset        ;Point at first Table Entry
  MOV  CX,NumDevices              ;Number of Table Entries
E10:                              ;Loop to here to find empty Table Entry
  TEST [BX].DvcFlags,DvcFlagInUse ;Empty Table entry?
  JZ  >E90                        ;If so, continue
  ADD  BX,DeviceInfoSize          ;Point at next table entry
  LOOP E10                        ;Keep looking
  XOR  BX,BX                      ;Table is full!
E90:                              ;Done
  OR   BX,BX                      ;Set Return Flag
  POP  CX                         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE FOR BAD DEVICE TABLE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;ADD A BAD (INCOMPATIBLE) DEVICE HOST & ADDRESS TO THE TABLE
;Inputs:   DS  = TSR Data Area
;         [DI] = Device Info Entry to add to Bad Device Table
;         [BX] = Associated Disk Info Entry (contains SCSI Request Errors)
;              = 0 if too early in LookForNewDevice process for Disks
;Outputs: Adds data from Device to Bad Device Table
;Changes:
;------------------------------------------------------------------------------
AddBadDevice:
  PUSH EAX,CX,EDX,SI              ;Save used registers
  PUSHF                           ;Save Flags
  CLI                             ;Disable Interrupts
  MOV  SI,BadDeviceTable          ;Point at Table
  MOV  CX,MaxBadDevices           ;Number of Entries in Table
A10:                              ;Loop here to find empty table entry
  TEST [SI].BDFlags,BDFlagInUse   ;This entry already used?
  JNZ >A50                        ;If so, skip it
  OR   [SI].BDFlags,BDFlagInUse   ;If not, mark it as used
  MOV  AX,W [DI].DvcHostIndex     ;Store the Host Index
  MOV  W [SI].BDHostIndex,AX      ;  & Device Address
  MOV  AL,[DI].DvcInterfaceNum    ;Store the
  MOV  [SI].BDInterfaceNum,AL     ;  Interface Number
  MOV  AX,NewDeviceError          ;Store the
  MOV  [SI].BDNewDeviceError,AX   ;  Error Code
  MOV  AL,NewDeviceStage          ;Store the
  MOV  [SI].BDNewDeviceStage,AL   ;  New Device Stage
  MOV  EAX,-1                     ;Assume
  MOV  EDX,EAX                    ;  [BX] = Invalid
  OR   BX,BX                      ;Is [BX] a valid pointer?
  JZ  >A20                        ;If not, continue
  MOV  EAX,D [BX].DskSCSIReqErrSetup ;If so, get the SCSI Error Codes
  MOV  EDX,[BX].DskCSWResidue     ;Get the Residue
A20:                              ;EAX = SCSI Error Codes to Store
  MOV  D [SI].BDSCSISetupErr,EAX  ;Store SCSI Error Codes (Stp, Dta, Sts, CSW)
  MOV  [SI].BDCSWResidue,EDX      ;Store Residue
  MOV  AL,[BX].DskSCSIRequest     ;Store
  MOV  [SI].BDSCSIRequest,AL      ;  Request Type
  MOV  AL,[BX].DskSenseBuffer.SReqSRespSenseKey       ;Store
  AND  AL,SReqRespSenseMask                           ;  Sense
  MOV  [SI].BDSCSISenseKey,AL                         ;  Key
  MOV  AX,W [BX].DskSenseBuffer.SReqSRespAddSenseCode ;Store
  MOV  W [SI].BDSCSIASC,AX                            ;  ASC & ASCQ
  MOV  EAX,D [BX].DskSenseBuffer.SReqSRespInfo        ;Store
  MOV  [SI].BDSCSISenseInfo,EAX                       ;  Sense Info
  MOV  EAX,D [BX].DskLastSectorRW ;Store Last
  MOV  [SI].BDLastSectorRW,EAX    ;  Sector Accessed
  JMP >A90                        ;Done
A50:                              ;Entry not Empty
  ADD  SI,BadDeviceStrucSize      ;Point at next entry
  LOOP A10                        ;Keep going until we're done
A90:                              ;Done
  POPF                            ;Restore Flags
  POP  SI,CX,EDX,EAX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DELETE BAD (INCOMPATIBLE) DEVICE HOSTS & ADDRESSES FROM THE TABLE
;Inputs:  CL = Host Index, CH = Address
;Outputs: Deletes Host & Address from Bad Device Table
;Changes:
;NOTES: This is called as the result a a Device Disconnect, so we need to
;         delete all Interfaces of the Device.  There will probably only
;         be one Interface (but may be multiple LUNs) on a Device,
;         but we need to check all of them.
;------------------------------------------------------------------------------
DeleteBadDevices:
  PUSH AX,BX,CX,DX,DI            ;Save used registers
  PUSHF                          ;Save Flags
  MOV  AX,CX                     ;AL = Host Index, AH = Device Address
  MOV  DL,-1                     ;Don't care about the Interface Number
  CLI                            ;Disable Interrupts
D10:                             ;Loop here for each table entry
  CALL FindBadDeviceEntry        ;Any entries in the Table (rtns BX)?
  JC  >D90                       ;If not, we're done
  PUSH AX                        ;If so, save used registers
  XOR  AX,AX                     ;Write zeroes
  MOV  CX,(BadDeviceStrucSize/2) ;Number of words to write
  MOV  DI,BX                     ;Point DI at Table Entry
  REP  STOSW                     ;Write them
  POP  AX                        ;Restore used registers
  JMP  D10                       ;Keep looking for more Entries
D90:                             ;Done
  POPF                           ;Restore Flags
  POP  DI,DX,CX,BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COMPARE A HOST AND ADDRESS TO SEE IF IT'S IN OUR BAD DEVICE TABLE
;Inputs:  CL = Host, CH = Address, DL = Interface, DH = Alt Interface
;Outputs: CF = Set if it's not in the Bad Device Table
;            = Clear if it is in Table
;Changes:
;NOTES: This ignores the Alt Interface Setting (we don't care about it).
;------------------------------------------------------------------------------
TestBadDevice:
  PUSH AX,BX              ;Save used registers
  MOV  AX,CX              ;AL = Host Index, AH = Device Address
                          ;DL = Interface Number
  CALL FindBadDeviceEntry ;Is it in the Table (returns BX)?
  POP  BX,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND A MATCHING HOST/ADDRESS/INTERFACE ENTRY IN THE BAD DEVICE TABLE
;Inputs:  AL = Host Index to find
;         AH = Device Address to find
;         DL = Interface Number to find
;              if -1, we don't care about the Interface Number
;Outputs: CF = Clear if Entry Found
;              BX = Entry Offset
;            = Set if Entry not found
;              BX = Undefined
;Changes:
;------------------------------------------------------------------------------
FindBadDeviceEntry:
  PUSH CX                       ;Save used registers
  PUSHF                         ;Save flags
  MOV  BX,BadDeviceTable        ;Point at Table
  MOV  CX,MaxBadDevices         ;Number of Entries in Table
  CLI                           ;Disable Interrupts
E20:                            ;Loop here to find empty table entry
  TEST [BX].BDFlags,BDFlagInUse ;Valid Entry?
  JZ  >E50                      ;If not, skip it
  CMP  W [BX].BDHostIndex,AX    ;Do the Host Index & Device Address match?
  JNE >E50                      ;If not, skip it
  CMP  DL,-1                    ;Do we care about the Interface Number?
  JE  >E80                      ;If not, we've found it!
  CMP  [BX].BDInterfaceNum,DL   ;Does the Interface Number match?
  JE  >E80                      ;If so, we've found it!
E50:                            ;Go to next entry
  ADD  BX,BadDeviceStrucSize    ;Point at the next entry
  LOOP E20                      ;Keep looking
E70:                            ;Error
  POPF                          ;Restore Flags
  STC                           ;Set Not Found Flag
  JMP >E90                      ;Done
E80:                            ;OK
  POPF                          ;Restore Flags
  CLC                           ;Set Found Flag
E90:                            ;Done
  POP  CX                       ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO ISSUE INT 14h CALLS TO THE HOST DRIVER
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;ISSUE AN INT 14 CALL TO THE USB HOST
;Inputs:  DS:[DX] = Int 14 Request (filled with appropriate data)
;      OR DS:[DI]
;      OR DS:[SI]
;Outputs: CF = Set if error (host stalled, etc.)
;            = Clear if OK
;Changes: Sends the appropriate info to the USB Host via Int 14 call
;------------------------------------------------------------------------------
DoInt14CallSaveAllSI:       ;Save all changed registers
                            ;  [SI] = Int14 Structure
  PUSH DX                   ;Save used registers
  MOV  DX,SI                ;Point DX at the Data Offset
  CALL DoInt14CallSaveAllDX ;Do it
  POP  DX                   ;Restore used registers
  RET

DoInt14CallAXSI:     ;Save all changed registers except AX
                     ;  [SI] = Int14 Structure
  PUSH DX            ;Save used registers
  MOV  DX,SI         ;Point DX at the Data Offset
  CALL DoInt14CallAX ;Do it
  POP  DX            ;Restore used registers
  RET

DoInt14CallCXSI:     ;Save all changed registers except CX
                     ;  [SI] = Int14 Structure
  PUSH DX            ;Save used registers
  MOV  DX,SI         ;Point DX at the Data Offset
  CALL DoInt14CallCX ;Do it
  POP  DX            ;Restore used registers
  RET

DoInt14CallCXDI:     ;Save all changed registers except CX
                     ;  [DI] = Int14 Structure
  PUSH DX            ;Save used registers
  MOV  DX,DI         ;Point DX at the Data Offset
  CALL DoInt14CallCX ;Do it
  POP  DX            ;Restore used registers
  RET

DoInt14CallAXCXSI:     ;Save all changed registers except AX & CX
                       ;  [SI] = Int14 Structure
  MOV  DX,SI           ;Point DX at the Data Offset
  CALL DoInt14CallAXCX ;Do it
  RET

DoInt14CallCXDXSI:     ;Save all changed registers except CX & DX
                       ;  [SI] = Int14 Structure
  MOV  DX,SI           ;Point DX at the Data Offset
  CALL DoInt14CallCXDX ;Do it
  RET

DoInt14CallSaveAllDX: ;Save all changed registers
                      ;  [DX] = Int14 Structure
  PUSH AX,BX,CX,DX    ;Save registers that Int14 changes!
  CALL DoInt14Call    ;Do it
  POP  DX,CX,BX,AX    ;Restore used registers
  RET

DoInt14CallAX:
  PUSH BX,CX,DX    ;Save registers that Int14 changes, except AX
  CALL DoInt14Call ;Do it
  POP  DX,CX,BX    ;Restore used registers
  RET

DoInt14CallCX:
  PUSH AX,BX,DX    ;Save registers that Int14 changes, except CX
  CALL DoInt14Call ;Do it
  POP  DX,BX,AX    ;Restore used registers
  RET

DoInt14CallAXCX:
  PUSH BX,DX       ;Save registers that Int14 changes, except BX & DX
  CALL DoInt14Call ;Do it
  POP  DX,BX       ;Restore used registers
  RET

DoInt14CallCXDX:
  PUSH AX,BX       ;Save registers that Int14 changes, except CX & DX
  CALL DoInt14Call ;Do it
  POP  BX,AX       ;Restore used registers
  RET

;Int 14 returns various values in AX, BX, CX, & DX
DoInt14Call:
  STI           ;Enable Interrupts
  MOV  AX,5001h ;Set Function
  MOV  BX,'US'  ;Set
  MOV  CX,'B!'  ;  Registers
  STC           ;Preset Error Flag
  INT  14h      ;Do it
  RET

;------------------------------------------------------------------------------
;SEARCH A BYTE-TO-WORD LOOKUP TABLE FOR A MATCH
;Inputs:  DS:[BX] = Table to search
;         AL      = Byte to search for
;Outputs: CF = Clear if a byte match as found in Table
;              BX = Word from Table
;            = Set if no match found in Table
;              BX = unchanged
;Changes: Last Entry in Table (end-of-table marker) = DB -1, DW -1
;------------------------------------------------------------------------------
SearchByte2WordTblDS:
  PUSH AX,SI     ;Save used registers
  CLD            ;Go forward with string functions
  MOV  SI,BX     ;Put pointer in SI
  MOV  AH,AL     ;Put byte to check in AH
B10:             ;Loop to here for each table entry
  LODSB          ;Get the next table entry
  CMP  AL,-1     ;Is it possibly the end of the table?
  JNE >B20       ;If not, continue
  CMP  W [SI],-1 ;Is it actually the end of the table?
  JE  >B70       ;If so, there's no match
B20:             ;Not end of table
  CMP  AL,AH     ;Is it a match?
  JE  >B80       ;If so, handle it!
  INC  SI,2      ;If not, skip over this table entry
  JMP  B10       ;And keep looking
B70:             ;No entry found
  STC            ;Set the not found flag
  JMP >B90       ;Quit
B80:             ;Entry found [SI]
  MOV  BX,[SI]   ;Point BX at the table entry
  CLC            ;Set the found flag
B90:             ;Done
  POP  SI,AX     ;Restore used registers
  RET


;;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;;CODE TO HANDLE INT 21h (DOS Services)
;;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;
;
;  ;DOS (INT 21h) Calls we intercept
;  DeviceOpen   EQU    3Dh  ;Open Device (in AH)
;                           ;AL should be 0 for this call (to open as Read-Only),
;                           ;  but we will allow anything in AL
;  DeviceClose  EQU    3Eh  ;Close Device (in AH)
;  GetASPIEntry EQU  4402h  ;Get ASPI Entry Point (Device-specific Call, in AX)
;
;  ;File Handle we return when SCSIMGR$ is opened
;  DeviceHandle EQU 0FBBBh
;
;  ;To keep track of whether or not our ASPI Manager is opened
;  DeviceOpened  DB 0 ;We'll allow multiple opens?
;
;  ;ID String for ASPI Device Manager
;  ASPIMgrString:     DB 'SCSIMGR$',0
;  ASPIMgrStringSize EQU $-ASPIMgrString ;Size of the string
;
;  ASPIManagerID DB  0 ;ASPI Manager ID: 0 if we're the first/only one
;                      ;Target ID (Device) will be the Device Info Index?
;
;  ASPIManagerStr DB 'USBDrive v0.05  ' ;ASPI Manager String (must be 16 bytes!)
;  ASPIHostStr    DB 'USBDrive v0.05  ' ;Host Adapter String (must be 16 bytes!)
;
;
;  ;Errors returned from DOS Calls that we intercept
;  DvcErrNone          EQU 00h ;No Error
;  DvcErrBadFunction   EQU 01h ;Invalid Function Number
;  DvcErrBadFile       EQU 02h ;File Not Found
;  DvcErrBadPath       EQU 03h ;Path Not Found
;  DvcErrNoHandles     EQU 04h ;No Handles Available (too manyh open files)
;  DvcErrAccessDenied  EQU 05h ;Access Denied
;  DvcErrBadHandle     EQU 06h ;Invalid Handle
;  DvcErrBadAccessCode EQU 0Ch ;Invalid Access Code
;  DvcErrBadData       EQU 0Dh ;Invalid Data
;  DvcErrIBadPassword  EQU 56h ;Invalid Password
;
;
;;------------------------------------------------------------------------------
;;HAVE INTERRUPT 21h (DOS Services) RUN THIS EVERY TIME IT OCCURS
;;Inputs:  Depends on specific call
;;Outputs: Depends on specific call
;;Changes:
;;NOTES: For now, this is simply a test routine.  At this point, we are simply
;;         going to emulate the ASPI (SCSIMGR$) Device Driver by intercepting
;;         the appropriate INT 21h calls.  The ASPI interface only needs three
;;         calls (Open, Get Entry Point, and Close), and not the entire suite
;;         of calls needed by a "real" device driver.  This allows us to
;;         install ourselves as a TSR rather than a Device Driver, which has
;;         many, many advantages.  The problem with this approach is that
;;         we need to come up with a "fake" Device Handle when the ASPI
;;         Manager is opened.  We need to come up with a handle that is
;;         not going to conflict with anything that DOS uses.  DOS uses
;;         low numbers (starting at 0) for handle numbers, and will usually
;;         only have a few hundred at most.  So, we will just use a large
;;         number for the handle and hope for the best.
;;       The disadvantage to this approach is that some other software that
;;         uses the ASPI interface is installed as a Device Driver (in
;;         CONFIG.SYS), and requires the ASPI interface to be installed
;;         before they will load.  This will be especially true of a Driver
;;         that converts ASPI drivers to DOS Drive Letters, like the
;;         Motto-Hairu Driver that may end up getting used with this program.
;;       Later on, we may end up needing to convert this to a real device
;;         driver (though I would rather not do that), or build a small
;;         "fake" device driver that will allow something like Motto Hairu
;;         to load, but then later install a TSR to actually manage the
;;         drives.
;;       One issue to keep in mind is how to manage multiple ASPI managers
;;         in memory at the same time (keeping track of "Manager ID's", eg).
;;         At this point in time, I haven't studied ASPI enough to know if
;;         or how to manage that, but I hope that type of capability is built
;;         into ASPI.  We'll need to manage that as we're installing ourselves
;;         into memory, checking for ASPI manager(s) already installed,
;;         getting their entry addresses, etc.
;
;;       Rather than (or in addition to) installing this program as an
;;         ASPI interface, we may end up needing/wanting to install this
;;         directly as a device driver, or as a network interface (so the
;;         USB Drives look like network drives).  The ASPI interface is
;;         probably the easiest to implement, since all modern drives
;;         (including USB Drivers) are based on the SCSI interface.
;;         However, just because it easier to implement does not necessarily
;;         mean it is the best or most useful way to do it.  Which approach
;;         will be the "best" one to use is yet to be determined.
;;
;;       Note that we need to be careful about uninstalling our TSR
;;         if we do not have a "fake" Device Driver installed.  Any program
;;         that uses ASPI will probably only keep the Device/File opened
;;         long enough to obtain the ASPI entry address, and then will close
;;         us, and then will assume that the ASPI Entry Address does not
;;         change.
;;------------------------------------------------------------------------------
;Int21Hdr:
;  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code
;
;Int21:
;  PUSH BP                       ;Save used registers
;  MOV  BP,SP                    ;Point at the stack ([BP] = BP, [BP+6] = Flags)
;  PUSHF                         ;Save flags
;  PUSH DI                       ;Save used registers
;  MOV  DI,AX                    ;Save original AX
;  STI                           ;Enable interrupts
;  CLD                           ;Go forward with string functions
;T10:                            ;Test for Device Open Function
;  CMP  AH,DeviceOpen            ;Is it Open Device?
;  JNE >T20                      ;If not, try the next possibility
;  CALL TestDeviceString         ;If so, see if it's for us
;  JNZ  Int21Old                 ;If not, quit
;  INC  CS:DeviceOpened          ;If so, mark us as opened
;  MOV  AX,DeviceHandle          ;Return our Handle Number
;  JMP >T80                      ;Done
;T20:                            ;Preliminary Device Close/Get ASPI Entry Tests
;  CMP  CS:DeviceOpened,0        ;Are we open?
;  JE   Int21Old                 ;If not, let the old Interrupt Handler do it
;  CMP  BX,DeviceHandle          ;Is it our handle number?
;  JNE  Int21Old                 ;If not, it's not for us
;T30:                            ;Test for Device Close Function
;  CMP  AH,DeviceClose           ;Is it Close Device?
;  JNE >T40                      ;If not, try the next possibility
;  ;Need to flush any caches here?
;  DEC  CS:DeviceOpened          ;Decrement the Opened Counter
;  JMP >T80                      ;We're done
;T40:                            ;Test for Get ASPI Entry Point Function
;  CMP  AX,GetASPIEntry          ;Is it Get ASPI Entry Point?
;  JNE  Int21Old                 ;If not, quit
;T40:                            ;We're not Open for Get ASPI Entry
;  MOV  DI,DvcErrBadData         ;Assume Bad Data
;  CMP  CX,4                     ;Do they want 4 bytes?
;  JNE >T70                      ;If not, error
;  PUSH BX                       ;If OK, save used registers
;  MOV  BX,DX                    ;Point DS:[BX] at the User Data Area
;  MOV  W [BX+0],ASPIFarCall     ;Store the Offset
;  MOV  W [BX+2],CS              ;Store the Segment
;  POP  BX                       ;Restore used registers
;  JMP >T80                      ;Done
;T70:                            ;Error
;  OR   B [BP+6],CarryFlag       ;Mark as an error
;  MOV  AX,DI                    ;Put the ERror Code in AX
;  JMP >T90                      ;Done
;T80:                            ;OK
;  AND  B [BP+6],(NOT CarryFlag) ;Mark as OK
;T90:                            ;Done
;  POP  DI                       ;Restore used registers
;  POPF                          ;Restore flags
;  POP  BP                       ;Restore used registers
;  IRET
;
;Int21Old:
;  POP  DI                       ;Restore used registers
;  POPF                          ;Restore flags
;  POP  BP                       ;Restore used registers
;  JMP  D CS:Int21Hdr.OldVector  ;Let the old interrupt handle it
;
;;------------------------------------------------------------------------------
;;TEST THE USER STRING FOR A DEVICE OPEN CALL TO SEE IF IT'S FOR US
;;Inputs:  CS = TSR Data Area
;;         DS:[DX] = String to Compare to ours
;;         CLD alread issued
;;Outputs: ZF = Set if the strings match
;;            = Clear if the strings don't match
;;Changes:
;;------------------------------------------------------------------------------
;TestDeviceString:
;  PUSH CX,DI,SI,ES          ;Save used registers
;  MOV  ES,CS                ;Point ES:[DI] at
;  MOV  DI,ASPIMgrString     ;  out string
;  MOV  CX,ASPIMgrStringSize ;CX = Number of bytes to test
;  MOV  SI,DX                ;Point DS:[SI] at the user string
;  REPE CMPSB                ;Compare the strings
;  OR   CX,CX                ;Set the return flag
;  POP  ES,SI,DI,CX          ;Restore used registers
;  RET
;
;
;ASPIFarCall:
;  RETF


;;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;;CODE TO HANDLE INT 28h (DOS Idle)
;;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;
;;------------------------------------------------------------------------------
;;HAVE INTERRUPT 28h (DOS IDLE INTERRUPT) RUN THIS EVERY TIME IT OCCURS
;;Inputs:
;;Outputs: Issues Stop/Unlock Unit Requests, if appropriate
;;Changes:
;;------------------------------------------------------------------------------
;Int28Hdr:
;  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code
;
;Int28:
;  PUSHF                        ;Call the
;  CALL D CS:Int28Hdr.OldVector ;  Old Interrupt Handler
;  STI                          ;Enable interrupts
;  CLD                          ;Go forward with string functions
;  CALL MakeStack               ;Set up our own Stack Space
;  PUSH DS,ES                   ;Save used registers
;  MOV  DS,CS                   ;Point DS and
;  MOV  ES,CS                   ;  ES at our data area
;  CALL HandleUnitStops         ;Issue Stop & Unlock Request, if appropriate
;  POP  ES,DS                   ;Restore used registers
;  CALL ReturnStack             ;Restore Original Stack Space
;  IRET
;
;;------------------------------------------------------------------------------
;;ISSUE UNIT STOP & UNLOCK REQUESTS, AS APPROPRIATE
;;Inputs:  DS = ES = TSR Data Area
;;Outputs: Issues Requests to Stop & Unlock Disks, if appropriate
;;Changes:
;;NOTES: This must be called as a foreground process!
;;------------------------------------------------------------------------------
;HandleUnitStops:
;  PUSH BX,CX               ;Save used registers
;  MOV  BX,DiskInfoOffset   ;[BX] = Disk Info Table
;  MOV  CX,NumDisks         ;CX = Number of Table Entries
;P10:                       ;Loop to here for each Table Entry
;  TEST [BX].DskFlags,DskFlagInUse ;Valid Table Entry?
;  JZ  >P40                 ;If not, skip it
;  CMP  [BX].DskStopTimer,1 ;Need to do anything?
;  JNE >P40                 ;If not, skip it
;  DEC  [BX].DskStopTimer   ;If so, decrement the Timer
;  TEST [BX].DskFlags2,DskFlagNoStart ;Should we issue the Stop Request?
;  JZ  >P20                 ;If so, continue
;  TEST [BX].DskFlags2,DskFlagNoLock ;Should we issue the Unlock Request?
;  JNZ >P40                 ;If not, skip it
;P20:                       ;Issue the Request for this Drive
;  CALL ReserveSectorBuff   ;Reserve Resources
;  CALL SCSIStopUnitFG      ;Issue Stop Unit Request
;  CALL SCSIUnlockUnitFG    ;Issue Unlock Unit Request
;  CALL ReleaseSectorBuff   ;Release Resources
;P40:                       ;Done with this entry
;  ADD  BX,DiskInfoSize     ;Point at next Table Entry
;  LOOP P10                 ;If not done, keep looking
;P90:                       ;Done
;  POP  CX,BX               ;Restore used registers
;  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO HANDLE INT 08h (Timer Tick)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HAVE INTERRUPT 08 (TIMER) RUN THIS EVERY TIME IT OCCURS
;Inputs:
;Outputs: Searches for Newly attached Device
;Changes:
;NOTES: In theory, we shouldn't even need to do this since we are registering
;         and will be notified automatically if a new Device is attached.
;       We will do this just in case we miss it or are busy for some reason.
;------------------------------------------------------------------------------
Int08Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int08:
  PUSHF                          ;Call the
  CALL D CS:Int08Hdr.OldVector   ;  Old Interrupt Handler
  STI                            ;Enable interrupts
  CLD                            ;Go forward with string functions
  CALL MakeStack                 ;Set up our own Stack Space
  PUSH DI,SI,DS,ES               ;Save used registers
  MOV  DS,CS                     ;Point DS and
  MOV  ES,CS                     ;  ES at our data area
  CALL UpdateAccessTimers        ;Update the Drive Access Timers
  CALL UpdateStopTimers          ;Update the Stop/Unlock Timers
  CALL LookForNewDrives          ;Look for Drive Letters, if appropriate
  CALL HandleUnitStops           ;Stop & Unlock Units, if appropriate
  CALL UpdateWaitTimer           ;Update the New Device Wait Timer
  MOV  DI,OFFSET NewDvcCounter   ;Point DI at NewDvcCounter
  MOV  SI,OFFSET DontLookCounter ;Point BX at DontLookCounter
  CMP  W [SI],0                  ;Need to Decrement DontLookCounter?
  JE  >E20                       ;If not, continue
  DEC  W [SI]                    ;If so, Decrement it
  JNZ >E90                       ;If not 0 yet, quit
  CMP  W [DI],0                  ;Disabled?
  JE  >E90                       ;If so, quit
  MOV  W [DI],1                  ;If not, look for Device right away
E20:                             ;Done with DontLookCounter
  CMP  W [DI],0                  ;Are we supposed to look yet?
  JE  >E90                       ;If not, just quit
  DEC  W [DI]                    ;Decrement the Delay Counter
  JNZ >E90                       ;If not 0 yet, quit
  MOV  W [DI],182                ;If 0, reset for next time (approx 10 seconds)
  PUSH AX,BX,CX,DX,BP            ;Save used registers
  CALL LookForNewDevice          ;Look for a new Device
  POP  BP,DX,CX,BX,AX            ;Restore used registers
E90:                             ;Done
  POP  ES,DS,SI,DI               ;Restore used registers
  CALL ReturnStack               ;Restore Original Stack Space
  IRET

;------------------------------------------------------------------------------
;UPDATE THE DRIVE ACCESS TIMERS (DRIVES WITH REMOVALBE MEDIA, LIKE FLOPPIES)
;Inputs:  DS = ES = TSR Data Area
;Outputs: Updates Timers in DiskInfoTable
;Changes:
;------------------------------------------------------------------------------
UpdateAccessTimers:
  PUSH BX,CX                  ;Save used registers
  MOV  BX,DiskInfoOffset      ;[BX] = Disk Info Table
  MOV  CL,B NumDisks[0]       ;CL = Number of Table Entries
U10:                          ;Loop to here for each entry
  MOV  CH,[BX].DskAccessTimer ;Get the Timer
  OR   CH,CH                  ;Is it 0 (Counted Down or N/A)?
  JZ  >U30                    ;If so, continue
  CMP  CH,-1                  ;Is it a Device with Removable Media?
  JE  >U30                    ;If not, continue
  DEC  CH                     ;If not, decrement the Timer
U30:                          ;CH contains new value to store
  MOV  [BX].DskAccessTimer,CH ;Store the new timer value
  ADD  BX,DiskInfoSize        ;Update the Pointer
  DEC  CL                     ;Decrement the Counter
  JNZ  U10                    ;If not 0 yet, keep updating
  POP  CX,BX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;UPDATE UNIT STOP & UNLOCK TIMERS
;Inputs:  DS = ES = TSR Data Area
;Outputs: Updates DskStopTimers
;Changes:
;------------------------------------------------------------------------------
UpdateStopTimers:
  PUSH BX,CX               ;Save used registers
  MOV  BX,DiskInfoOffset   ;[BX] = Disk Info Table
  MOV  CX,NumDisks         ;CX = Number of Table Entries
S10:                       ;Loop to here for each Table Entry
  TEST [BX].DskFlags,DskFlagInUse ;Valid Table Entry?
  JZ  >S20                 ;If not, skip it
  CMP  [BX].DskStopTimer,2 ;Need to update the timer?
  JBE >S20                 ;If not, skip it
  DEC  [BX].DskStopTimer   ;If so, decrement the Timer
S20:                       ;Done with this entry
  ADD  BX,DiskInfoSize     ;Point at next Table Entry
  LOOP S10                 ;If not done, keep looking
S90:                       ;Done
  POP  CX,BX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE UNIT STOP & UNLOCK REQUESTS, AS APPROPRIATE
;Inputs:  DS = ES = TSR Data Area
;Outputs: Issues Requests to Stop & Unlock Disks, if appropriate
;Changes:
;NOTES: This must be called from INT 08.  We don't issue CLI's and do
;         various other tests to insure we are not causing problems with
;         other items already being processed.
;------------------------------------------------------------------------------
HandleUnitStops:
  PUSH AX,BX,CX,DI          ;Save used registers
  TEST TSRFlags,(Int14ReqInUse+SectBuffInUse) ;Resources available?
  JNZ >P90                  ;If not, quit
  MOV  BX,DiskInfoOffset    ;[BX] = Disk Info Table
  MOV  CX,NumDisks          ;CX = Number of Table Entries
P10:                        ;Loop to here for each Table Entry
  TEST [BX].DskFlags,DskFlagInUse ;Valid Table Entry?
  JZ  >P60                  ;If not, skip it
  CMP  [BX].DskStopTimer,0  ;Need to do anything?
  JE  >P60                  ;If not, skip it
  CMP  [BX].DskStopTimer,2  ;Need to do anything?
  JA  >P60                  ;If not, skip it
  JB  >P30                  ;If we need to Unlock, jump to handle it
P20:                        ;Time to Stop
  MOV  AX,SCSIStopUnitBG    ;[AX] = Code to Call
  TEST [BX].DskFlags2,DskFlagNoStart ;Should we issue the Stop Request?
  JZ  >P40                  ;If so, continue
  DEC  [BX].DskStopTimer    ;If not, mark as an Unlock Request
P30:                        ;Time to Unlock
  MOV  AX,SCSIUnlockUnitBG  ;[AX] = Code to Call
  TEST [BX].DskFlags2,DskFlagNoLock ;Should we issue the Unlock Request?
  JZ  >P40                  ;If so, continue
  DEC  [BX].DskStopTimer    ;If not, mark as an Unlock Request
  JMP >P60                  ;Done with this Disk
P40:                        ;[DX] = Request to Issue
  OR   TSRFlags,(Int14ReqInUse+SectBuffInUse) ;Mark resources as in use
  MOV  DI,[BX].DskDvcOffset ;[DI] = Device Info Entry
  MOV  BGReqNextCode,StopUnlockDone ;Store Code Completion Address
  CALL AX                   ;Issue the Request
  CALL SetupBGReqDone       ;Issue the Completion Monitoring Code (rtns CF, AX)
  JMP >P90                  ;Done
P60:                        ;Done with this entry
  ADD  BX,DiskInfoSize      ;Point at next Table Entry
  LOOP P10                  ;If not done, keep looking
P90:                        ;Done
  POP  DI,CX,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs: [BX] = Disk Info Table Pointer
;------------------------------------------------------------------------------
StopUnlockDone:
  DEC  [BX].DskStopTimer ;Decrement the Timer
  AND  TSRFlags,NOT(Int14ReqInUse+SectBuffInUse) ;Mark resources as available
  RETF

;------------------------------------------------------------------------------
;SETUP PARAMETERS TO MONITOR WHEN A BACKGROUND REQUEST IS COMPLETE
;Inputs:  DS = TSR Data Area
;         BGReqNextCode already filled in
;         [BX] = Disk Info Entry
;         [DI] = Device Info Entry
;         Resources already Reserved (TSRFlags.Int14ReqInUse)
;Outputs: CF = Set if Error (Int 14 Request Failed)
;              AX = Error Code
;            = Clear of OK
;              AX = 0
;Changes: Int14Request
;NOTES: This is called from code outside LookForNewDevice.  There is a
;         similar setup in LookForNewDevice, but when it is complete it
;         issues the FinishUpBadDevice code, which we don't want to
;         do here.
;------------------------------------------------------------------------------
SetupBGReqDone:
  PUSH AX,SI                  ;Save used registers
  MOV  SI,Int14Request        ;Point at Int14 Request Structure
  MOV  [SI].I14RRequestType,I14RRTDoInterrupt1T ;Set up One-time Interrupt
  MOV  [SI].I14RPeriodicity,2 ;Wait 2 Milliseconds
  MOV  [SI].I14RUserPktID,BX  ;User ID = Disk Info Pointer
  MOV  W [SI].I14RCallBackAddr[0],WaitForBGReq ;Go here while waiting
  MOV  AL,[DI].DvcHostIndex   ;Store
  MOV  [SI].I14RHostIndex,AL  ;  Host Index
  CALL DoInt14CallAXSI        ;Do it (returns CF, AX)
  POP  SI,AX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs: [BX] = Disk Info Table Pointer
;NOTE: This is a "Wrapper" Call for a SCSI Background Request.  A SCSI
;        background request actually has three stages: Request, Data, and
;        Status.  They are literally three separate USB Requests (and in
;        some cases three different types of Requests to different
;        endpoints).  Since we need to do this many times, we create a
;        "wrapper" around the three requests so that we can simplify and
;        re-use large portions of code.
;      The SCSI Request performs in the background, and when it is done it
;        simply updates some fl;ags and error code information in memory
;        (stored in the Device Info Structure).  We "wrap" ourselves around
;        that request by issuing an effective periodic interrupt that simply
;        monitors the status bytes, and keeps waiting until the status bytes
;        indicate that the SCSI Request is done.  When it is done, the
;        "wrapper" finally lets the process continue at the next stage.
;      The code following this will actually be performed after a one-time
;        interrupt, so the status returned in will not reflect the actual
;        status of the SCSI Request.  The code will need to look in the
;        Device Info Request Structure for the actual Error Codes.
;------------------------------------------------------------------------------
WaitForBGReq:
  MOV  SI,Int14Request                ;[SI] = Int 14h Request Structure
  TEST [BX].DskFlags,DskFlagReqInProg ;Is the Request done yet?
  JNZ >W30                            ;If not, keep waiting until it is
W10:                                  ;Request is Done
  MOV  [SI].I14RPeriodicity,1         ;Wait 1 Millisecond
  MOV  AX,BGReqNextCode               ;Go here
  MOV  W [SI].I14RCallBackAddr[0],AX  ;  when done
W30:                                  ;Int 14h Request is set up
  CALL DoInt14CallSaveAllSI           ;Do it
  RETF

;------------------------------------------------------------------------------
;UPDATE THE NEW DEVICE WAIT TIMER
;Inputs:  DS = ES = TSR Data Area
;Outputs: Updates New Device Wait Timer, if appropriate
;Changes:
;------------------------------------------------------------------------------
UpdateWaitTimer:
  CMP  NewWaitDvcAddress,0 ;Anything to do?
  JE  >W90                 ;If not, we're done
  CMP  NewWaitTimer,0      ;If so, is it already counted down?
  JE  >W90                 ;If so, we're done
  DEC  NewWaitTimer        ;If not, Decrement the Timer
W90:                       ;CH contains new value to store
  RET

;------------------------------------------------------------------------------
;LOOK FOR NEW DRIVE LETTERS, AS APPROPRIATE
;Inputs:  DS = ES = TSR Data Area
;Outputs: Updates Timers, Looks for New Drives when appropriate
;Changes:
;NOTES: This must be called from INT 08 -- we do not check for interrupts,
;         etc. that could cause issues.
;------------------------------------------------------------------------------
LookForNewDrives:
  PUSH AX,BX,CX,DX,SI             ;Save used registers
  CALL GetAvailDriveSI            ;Any Drive entries available?
  JC  >V901                       ;If not, quit
  AND  [SI].DrvFlags,(NOT DrvFlagInUse) ;If so, un-reserve it
  TEST TSRFlags,(Int14ReqInUse+SectBuffInUse) ;Resources available?
  JNZ >V901                       ;If not, quit
  XOR  AX,AX                      ;AL = Counting Counter, AH = On Hold Counter
  MOV  BX,DiskInfoOffset          ;[BX] = Disk Info Table
  MOV  CX,NumDisks                ;CX = Number of Table Entries
V10:                              ;Loop to here for each Table Entry
  TEST [BX].DskFlags,DskFlagInUse ;Valid table entry?
  JZ  >V15                        ;If not, skip it
  CMP  [BX].DskDrvTimer,0         ;Already assigned drives for this disk?
  JE  >V15                        ;If so, skip it
  CMP  [BX].DskDrvTimer,DskStageInProc ;Still processing disk?
  JAE >V15                        ;If so, skip it
  CMP  [BX].DskDrvTimer,DskStageNewDisk ;Is it a new Disk?
  JNE >V14                        ;If not, keep looking
V12:                              ;A new disk
  MOV  [BX].DskDrvTimer,1         ;Set to look this time
  JMP >V40                        ;Jump to look
V14:                              ;Not a New Disk
  INC  AL                         ;Assume already counting down
  CMP  [BX].DskDrvTimer,DskStageOnHold ;Is it On Hold?
  JNE >V15                        ;If not, continue
  DEC  AL                         ;If so, it's not counting down
  INC  AH                         ;It is On Hold
V15:                              ;Done with this Table Entry
  ADD  BX,DiskInfoSize            ;Point at next Table Entry
  LOOP V10                        ;If not done, keep looking

  OR   AX,AX                      ;Is there anything to do?
  JZ  >V90                        ;If not, we're done
V20:                              ;AL = Counting Counter, AH = On Hold Counter
  MOV  BX,DiskInfoOffset          ;[BX] = Disk Info Table
  MOV  CX,NumDisks                ;BX = Number of Table Entries
  OR   AL,AL                      ;Any Counting Table entries?
  JZ  >V50                        ;If not, handle Entries On Hold

V30:                              ;At least one Counting Entry
  TEST [BX].DskFlags,DskFlagInUse ;Valid table entry?
  JZ  >V35                        ;If not, skip it
  CMP  [BX].DskDrvTimer,0         ;Already assigned drives for this disk?
  JE  >V35                        ;If so, skip it
  CMP  [BX].DskDrvTimer,DskStageOnHold ;Is it On Hold or still in Progress?
  JB  >V40                        ;If not, Count it down
V35:                              ;Done with this Table Entry
  ADD  BX,DiskInfoSize            ;Point at next Table Entry
  LOOP V30                        ;If not done, keep looking
V40:                              ;Need to decrement this Timer
  DEC  [BX].DskDrvTimer           ;Decrement Timer
  JNZ >V90                        ;If not 0 yet, we're done
  MOV  [BX].DskDrvTimer,DskStageOnHold ;Mark as On Hold for next time
  OR   TSRFlags,(Int14ReqInUse+SectBuffInUse) ;Mark us as using resources
  CALL LookForNewDrive            ;Look for Drive Letters
V901:                             ;To avoid JMP > 128
  JMP >V90                        ;Done

V50:                              ;No Counting Entries, at least one On Hold
  MOV  DL,AH                      ;Calculate how many timer ticks
  MOV  AX,24                      ;  to Delay
  DIV  DL                         ;  for each Disk (AL)
  OR   AH,AH                      ;Round up,
  JZ  >V51                        ;  if
  INC  AL                         ;  necessary
V51:                              ;AL = Rounded Delay value to use
  CMP  AL,5                       ;Is it at least 5?
  JAE >V52                        ;If so, it's OK
  MOV  AL,5                       ;If not, make it 5
V52:                              ;AL = Delay value to use
  TEST [BX].DskFlags,DskFlagInUse ;Valid Table Entry?
  JZ  >V55                        ;If not, skip it
  CMP  [BX].DskDrvTimer,DskStageOnHold ;Is it On Hold?
  JNE  >V55                       ;If not, skip it
  MOV  [BX].DskDrvTimer,AL        ;If so, mark it as Counting
V55:                              ;Done with this Table Entry
  ADD  BX,DiskInfoSize            ;Point at next Table Entry
  LOOP V52                        ;If not done, keep looking

V90:                              ;Done
  POP  SI,DX,CX,BX,AX             ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO HANDLE INT 13h (Disk BIOS)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HAVE INTERRUPT 13h (DISK BIOS) RUN THIS EVERY TIME IT OCCURS
;Inputs:  Depends on Call, but generally AX, BX, CX, DX, and ES are used as
;           input parameters
;Outputs:
;Changes: Performs Functions as Requested by the Caller.  If the call is not
;           for one of the USB Drives we are controlling, the call is simply
;           passed on to the Original Interrupt Handler.
;------------------------------------------------------------------------------
Int13Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int13:
  PUSH BP                       ;Save used registers
  MOV  BP,SP                    ;SS:[BP] = Stack
  PUSHF                         ;Save flags
  PUSH DS,SI,AX                 ;Save used registers
  STI                           ;Enable interrupts
  CLD                           ;Go forward with string functions
  MOV  DS,CS                    ;Point DS at our data area
  MOV  Int13AXInput,AX          ;Save Input AX
  MOV  Int13DXInput,DX          ;Save Input DX
  MOV  Int13AHSuccess,0         ;Default is to return 0 in AH on Success
  TEST DL,80h                   ;Is the high bit of DL set?
  JZ  >T99                      ;If not, it can't be for us
  CMP  DL,-1                    ;Is it FFh?
  JE  >T99                      ;If so, it can't be for us
  CALL TestDLIsOurs             ;See if the call is for Us
  JC  >T99                      ;If not, let the Old Handler process it
  CALL TestDLReserved           ;If so, is it Reserved or In Use?
  JC  >T20                      ;If In Use, Jump to handle it
T10:                            ;Drive Number is Reserved, but not In Use
  CALL ProcessReservedErr       ;Process the Error
  JMP >T70                      ;Done
T20:                            ;Drive Number is Ours
  XCHG AL,AH                    ;AL = Command Code
  MOV  SI,BX                    ;Save original BX
  MOV  BX,I13CmdTable           ;[BX] = Command Code Lookup Table
  CALL SearchByte2WordTblDS     ;Look for a match
  XCHG AL,AH                    ;Restore original AL/AH Input Values
  XCHG BX,SI                    ;Restore original BX
  JNC >T40                      ;If in our Table, Continue
T30:                            ;Illegal Function
  MOV  B SS:[BP].I13StkAX[1],I13ErrInvalidFunc ;AH = Invalid Function
  JMP >T70                      ;Done
T40:                            ;[BX] = Code to Call
  CALL SI                       ;Call the Code
  JNC >T80                      ;If no error, quit
T70:                            ;Error (SS:[BP] already contains Error Codes)
  OR   B SS:[BP].I13StkCFlag,CarryFlag ;Set return flag
  CALL StoreLastStatus          ;Store return Status for Next Time
  POP  AX,SI,DS                 ;Restore used registers
  JMP >T90                      ;Done
T80:                            ;OK
  AND  B SS:[BP].I13StkCFlag,(NOT CarryFlag) ;Set return flag
  MOV  AH,Int13AHSuccess        ;Put the Success Return Code
  MOV  B SS:[BP].I13StkAX[1],AH ;  in AH
  CALL StoreLastStatus          ;Store return Status for Next Time
  POP  AX,SI,DS                 ;Restore used registers
T90:                            ;Done
  POPF                          ;Restore flags
  POP  BP                       ;Restore used registers
  IRET

Int13Old:
T99:
  POP  AX,SI,DS                 ;Restore used registers
  POPF                          ;Restore flags
  POP  BP                       ;Restore used registers
  JMP  D CS:Int13Hdr.OldVector  ;Let the Old Interrupt Handler process it


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE FOR HIGH-LEVEL INT 13h FUNCTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PROCESS AN ERROR FOR AN INT 13h DRIVE NUMBER THAT IS RESERVED
;Inputs:  DS = TSR Data Area
;         AX = Original values from INT 13h Call
;         SS:[BP] = Values Saved on Call to INT 13h Function
;Outputs: SS:[BP] Values (Return Registers) as appropriate for the call
;Changes:
;NOTES: For most Int 13h calls, all that is returned is an Error Code in AH.
;         However, for some types of Calls, we need to return values in
;         other registers as well (specifically, the AL register in some
;         cases).  This handles all of the appropriate details for the
;         various Calls.
;------------------------------------------------------------------------------
ProcessReservedErr:
  MOV  B SS:[BP].I13StkAX[1],I13ErrTimeout ;Error Code = Timeout/Not Ready
  CMP  AH,I13CmdRead           ;Do we need to return 0 in AL?
  JB  >V90                     ;If not, we're done
  CMP  AH,I13CmdVerify         ;Do we need to return 0 in AL?
  JA  >V90                     ;If not, handle other possibilities
  MOV  B SS:[BP].I13StkAX[0],0 ;If so, set AL = 0 for the return
V90:                           ;Done
  RET

;------------------------------------------------------------------------------
;TEST DL (DRIVE NUMBER ON INPUT TO INT 13h FUNCTION) TO SEE IF IT'S OURS
;Inputs:  DS = TSR Data Area
;         DL = Drive Number (for Int 13h Call)
;         CLD already issued
;Outputs: CF = Clear if it is Ours (or is Reserved)
;            = Set if not
;Changes:
;------------------------------------------------------------------------------
TestDLIsOurs:
  PUSH DX                ;Save used registers
  MOV  DH,-1             ;Mark as testing Ours
                         ;Leave DL Intact
  JMP >D00               ;Do it
TestDLReserved:
  PUSH DX                ;Save used registers
  XOR  DH,DH             ;Mark as Testing Reserved
;  JMP >D00               ;Do it
D00:
  PUSH CX,SI             ;Save used registers
  MOV  CX,NumDisks       ;CX = Loop Counter
  MOV  SI,DiskInfoOffset ;DS:[SI] = Disk Info Table
D10:                     ;Loop to here for each table entry
  CMP  DL,[SI].DskInt13DrvNum ;Is it a match?
  JNE >D50               ;If not, skip it
  OR   DH,DH             ;Are we testing Ours or Reserved?
  JNZ >D80               ;If testing Ours, we're done
  TEST [SI].DskFlags,DskFlagInUse ;If testing Reserved, is it In Use?
  JNZ >D70               ;If so, it's not Reserved
  JMP >D80               ;If not in Use, it's Reserved
D50:                     ;Not a match
  ADD  SI,DiskInfoSize   ;Point at the next table Entry
  LOOP D10               ;Keep going until we're done
D70:                     ;Error (Not Ours/Not Reserved)
  STC                    ;Set return flag
  JMP >D90               ;Done
D80:                     ;OK (Is Ours/Is Reserved)
  CLC                    ;Set return flag
D90:                     ;Done
  POP  SI,CX             ;Restore used registers
  POP  DX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT DL (DRIVE NUMBER ON INPUT TO INT 13h FUNCTION) TO A DRIVE INFO ENTRY
;Inputs:  DS = TSR Data Area
;         DL = Drive Number (for Int 13h Call)
;         CLD already issued
;Outputs: CF = Clear if OK (Drive Number Found)
;              [SI] or [BX] = Drive Info Entry
;            = Set if Error (Not Found)
;              SI, BX = Unchanged
;Changes:
;------------------------------------------------------------------------------
CvtDL2DskInfoBX:
  PUSH SI              ;Save used registers
  CALL CvtDL2DskInfoSI ;Convert to a Drive Offset (SI)
  JC  >B90             ;If error, quit
  MOV  BX,SI           ;If OK, put Offset in BX
B90:                   ;Done
  POP  SI              ;Restore used registers
  RET

CvtDL2DskInfoSI:
  PUSH AX,CX                  ;Save used registers
  MOV  AX,SI                  ;Save original SI
  MOV  SI,DiskInfoOffset      ;DS:[SI] = Disk Info Table
  MOV  CX,NumDisks            ;CX = Number of Table entries
S10:                          ;Loop to here for each table entry
  CMP  [SI].DskInt13DrvNum,DL ;Is it the one we're looking for?
  JE  >S80                    ;If so, we're done
  ADD  SI,DiskInfoSize        ;If not, point at the next table entry
  LOOP S10                    ;Keep looking
S70:                          ;Error
  MOV  SI,AX                  ;Restore original SI
  STC                         ;Set return flag
  JMP >S90                    ;Done
S80:                          ;OK
  CLC                         ;Set return flag
S90:                          ;Done
  POP  CX,AX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;STORE THE RETURN STATUS CODE FOR THIS INT 13h CALL
;Inputs:  DS = TSR Data Area
;         SS:[BP] = Values Saved on Call to INT 13h Function, except AX
;         SS:[BP].I13StkAX = Values to return in AX on Return
;         Int13DXInput = DX on Input to INT 13h Function (DL = Disk)
;Outputs: DskLastStatus for appropriate Disk (corresponding to DL) =
;           status code for this return
;Changes:
;------------------------------------------------------------------------------
StoreLastStatus:
  PUSH BX,DX                    ;Save used registers
  MOV  DL,B Int13DXInput[0]     ;DL = Disk Number
  CALL CvtDL2DskInfoBX          ;[BX] = Disk Info Entry
  MOV  DL,B SS:[BP].I13StkAX[1] ;Get Current AH Return Code
  MOV  [BX].DskInt13LastSts,DL  ;Store it
  POP  DX,BX                    ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE FOR NEW INT 13h FUNCTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PROCESS AN INT 13h ISSUE SCSI REQUEST REQUEST
;Inputs:  DS = TSR Data Area
;         ALL other registers except BP & SI = original INT 13h Calling Values
;           (AX,BX,CX,DX,DI,ES)
;         SS:[BP] = Original Calling Registers & Flags (AX,SI,BP,DS)
;Outputs: CF = Clear if OK
;            = Set if Error
;              SS:[BP].I13StkAX[1] = Error Code (return value in AX)
;Changes:
;------------------------------------------------------------------------------

;Need to return a version number?

I13IssueSCSIReq:
  PUSH EAX,BX,CX,DX,DI               ;Save used registers
  MOV  DI,BX                         ;ES:[DI] = Input Request Structure
  CALL ReserveSectorBuff             ;Reserve Resources
  CALL CvtDL2DskInfoBX               ;DS:[BX] = Disk Info Entry
  CMP  AL,1                          ;Subfunction 1?
  JNE >S70                           ;If not, error
  CMP  ES:[DI].I13SID,'SCSI'         ;Valid Structure Tag?
  JNE >S70                           ;If not, error
  MOV  DX,DoSCSIReqInFG              ;If OK, assume Direction = In
  TEST ES:[DI].I13SFlags,I13SFlagIn  ;Is it In?
  JNZ >S10                           ;If so, continue
  MOV  DX,DoSCSIReqOutFG             ;If not, Direction = Out
S10:                                 ;[DX] = Code to call (In/Out)
  CALL CopyI13SSCB                   ;Copy the SCSI Command Block
  MOV  AL,ES:[DI].I13SCmdSize        ;Get SCSI Command Size
  CMP  AL,16                         ;Is it valid?
  JA  >S70                           ;If not, error
  MOV  [BX].DskSCSICmdSize,AL        ;If OK, store it
  MOV  CX,ES:[DI].I13SDataSize       ;CX = Data Size
  PUSH DI,ES                         ;Save Int 13h Structure Pointer
  LES  DI,ES:[DI].I13SDataPtr        ;ES:[DI] = Data Address
  CALL DX                            ;Issue the Request (Returns ZF, AX)
  POP  ES,DI                         ;Restore Int 13h Structure Pointer
  MOV  EAX,D [BX].DskSCSIReqErrSetup ;Store
  MOV  D ES:[DI].I13SSetupErr,EAX    ;  Error Codes
  MOV  EAX,[BX].DskCSWResidue        ;Store
  MOV  ES:[DI].I13SDataResidue,EAX   ;  Residue
  MOV  AL,[BX].DskSenseBuffer.SReqSRespErrCode      ;Store Request Sense
  MOV  ES:[DI].I13SSenseErrCode,AL                  ;  Error Code
  MOV  AL,[BX].DskSenseBuffer.SReqSRespSenseKey     ;Store Request Sense
  MOV  ES:[DI].I13SSenseKey,AL                      ;  Sense Key
  MOV  AL,[BX].DskSenseBuffer.SReqSRespAddSenseCode ;Store Request Sense
  MOV  ES:[DI].I13SSenseASC,AL                      ;  Additional Sense Code
  MOV  AL,[BX].DskSenseBuffer.SReqSRespAddSenseQual ;Store Request Sense
  MOV  ES:[DI].I13SSenseASCQ,AL                     ;  Additional Sense Qual
  MOV  EAX,D [BX].DskSenseBuffer.SReqSRespInfo      ;Store Request Sense
  MOV  ES:[DI].I13SSenseInfo,EAX                    ;  Info
  JMP >S80                           ;Done
S70:                                 ;Error
  MOV  B SS:[BP].I13StkAX[1],I13ErrInvalidFunc ;Error = Invalid Parameter
  STC                                ;Set return flag
  JMP >S90                           ;Done
S80:                                 ;OK
  CLC                                ;Set return flag
S90:                                 ;Done
  CALL ReleaseSectorBuff             ;Release Resources
  POP  DI,DX,CX,BX,EAX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY SCSI COMMAND BLOCK FROM INT 13h STRUCTURE TO DISK INFO STRUCTURE
;Inputs:  DS = Local (TSR) Data Area
;         DS:[BX] = Disk Info Entry
;         ES:[DI] = Int 13 Request Structure
;         CLD already issued
;Outputs: Copies SCSI Command Block from Int 13h Structure to Disk Info Entry
;Changes:
;------------------------------------------------------------------------------
CopyI13SSCB:
  PUSH CX,DI,SI,DS,ES             ;Save used registers
  LEA  SI,[BX].DskCBW.CBWCmdBlock ;DS:[SI] = Disk Structure Pointer
  ADD  DI,OFFSET I13SCmdBlock     ;ES:[DI] = Int 13h Structure Pointer
  XCHG DI,SI                      ;Swap
  PUSH DS                         ;  ES:[DI]
  PUSH ES                         ;  and
  POP  DS                         ;  DS:[SI]
  POP  ES                         ;  pointers
  MOV  CX,8                       ;Copy 8 words (16 bytes)
  REP  MOVSW                      ;Copy the SCB
  POP  ES,DS,SI,DI,CX             ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE FOR BASIC INT 13h FUNCTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PROCESS AN INT 13h GET LAST STATUS REQUEST
;Inputs:  DS = TSR Data Area
;         ALL other registers except BP & SI = original INT 13h Calling Values
;           (AX,BX,CX,DX,DI,ES)
;         SS:[BP] = Original Calling Registers & Flags (AX,SI,BP,DS)
;         DskInt13LastSts for corresponding Drive (DL) contains Last Status
;Outputs: CF = Clear if OK (Last Status Return Code = 0)
;            = Set if Error (Last Status Return Code != 0)
;              SS:[BP].I13StkAX[1] = Status Return Code from last Time
;Changes:
;------------------------------------------------------------------------------
I13LastStatus:
  PUSH BX                       ;Save used registers
  CALL CvtDL2DskInfoBX          ;[BX] = Disk Info Entry
  MOV  BL,[BX].DskInt13LastSts  ;BL = Last Status
  MOV  B SS:[BP].I13StkAX[1],BL ;Store it in our Return AH
  OR   BL,BL                    ;Is it an Error?
  JZ  >L80                      ;If not, handle it
L70:                            ;Error
  STC                           ;Set return flag
  JMP >L90                      ;Done
L80:                            ;OK
  CLC                           ;Set return flag
L90:                            ;Done
  POP  BX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS AN INT 13h RESET SYSTEM OR RESET DISK REQUEST
;Inputs:  DS = TSR Data Area
;         AH = Int 13h Function Number (Reset System or Reset Disk)
;         DL = Drive Number to Reset
;         SS:[BP] = Original Calling Registers & Flags (AX,SI,BP,DS)
;Outputs: CF = Clear
;Changes: Rezeroes Disk
;         Flushes Internal Caches
;         Seeks to Track 0
;NOTES: There can be more than one Drive Info Entry associated with a
;         particular INT 13h Drive Number (e.g., a Drive with multiple
;         partitions).  Since we are actually resetting the disk (not the
;         drives on that disk), we only need to reset the Disk for One
;         Drive Entry, and all of the other Drive Entries (if there are
;         any) are effectively reset as well.
;------------------------------------------------------------------------------
I13ResetDisk:

;If Floppy w/ no Media, do we need to Reset parameters to Defaults?

I13ResetSystem:
  PUSH BX              ;Save used registers
  CALL CvtDL2DskInfoBX ;Convert Drive Number (DL) to a Disk Entry ([BX])
  CALL ResetDiskBX     ;Perform the Reset
  CLC                  ;Set return flag
  POP  BX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS AN INT 13h READ, WRITE, OR VERIFY REQUEST
;Inputs:  DS = TSR Data Area
;         ALL other registers except BP & SI = original INT 13h Calling Values
;           (AX,BX,CX,DX,DI,ES)
;         SS:[BP] = Original Calling Registers & Flags (AX,SI,BP,DS)
;Outputs: CF = Clear if OK
;            = Set if Error
;              SS:[BP].I13StkAX[1] = Error Code (return value in AX)
;Changes:
;NOTES: The verify function does not actually use the Data Buffer for anything.
;         Vefification simply verifies the CRC as stored on the disk.

;Need to test for Locked Drive before Using INT 13h calls?

;------------------------------------------------------------------------------
I13Read:
  PUSH DI                     ;Save used registers
  MOV  DI,SCSIReadFG          ;[DI] = Code to Call
  JMP >V00                    ;Do it
I13Write:
  PUSH DI                     ;Save used registers
  MOV  DI,SCSIWriteFG         ;[DI] = Code to Call
  JMP >V00                    ;Do it
I13Verify:
  PUSH DI                     ;Save used registers
  MOV  DI,SCSIVerifyFG        ;[DI] = Code to Call
  JMP >V00                    ;Do it
I13Seek:
  PUSH DI                     ;Save used registers
  MOV  DI,SCSISeekFG          ;[DI] = Code to Call
;  JMP >V00                    ;Do it
V00:
  PUSH EAX,BX,CX,SI           ;Save used registers
  CALL CvtDL2DskInfoSI        ;[SI] = Disk Info Entry
  CMP  DI,SCSIWriteFG         ;Is this a Write call?
  JNE >V20                    ;If not, continue
  TEST [SI].DskFlags,DskFlagWriteProt ;If so, is the disk write-protected?
  JZ  >V20                    ;If not, continue
  MOV  W SS:[BP].I13StkAX,(I13ErrWriteProt SHL 8) ;Error = Write Protected
  JMP >V75                    ;Done
V20:                          ;Not write-protected
  CALL TestCHSParamsSI        ;Test CHS Parameters (CX, DH, [SI])
  JC  >V75                    ;If error, quit
  CALL CHS2LBA32              ;Convert CHS (CX, DH, [SI]) to LBA (EAX)
  JNC >V25                    ;If OK, continue
  MOV  W SS:[BP].I13StkAX[0],(I13ErrNoSector SHL 8) ;Error = Invalid Sector
  JMP >V75                    ;Done
V25:                          ;EAX = Valid LBA
  XCHG BX,SI                  ;[BX] = Disk Info Entry, ES:[SI] = Data Buffer
  XCHG DI,SI                  ;ES:[DI] = Data Buffer, [SI] = Code to Call
  XOR  CX,CX                  ;CX = Number of Sectors
  MOV  CL,SS:[BP].I13StkAX[0] ;  to Read/Write/Verify
  CMP  SI,SCSISeekFG          ;Is it a Seek?
  JNE >V40                    ;If not, continue
V30:                          ;Seek Function - AL didn't contain number of Sects
  MOV  CL,1                   ;Set CX so it works correctly
V40:                          ;CX contains correct value
  CALL TestInt13RWV           ;Test the parameters for validity
  JC  >V75                    ;If invalid, Error
  CALL SI                     ;Do it
  JNC >V80                    ;If it worked, quit
V70:                          ;Error

  ;Figure out Actual Error Code here!

  MOV  W SS:[BP].I13StkAX,(I13ErrTimeout SHL 8) ;Error = Timeout
V75:                          ;Error (Error Code already set)
  STC                         ;Set Error Flag for Return
  JMP >V90                    ;Done
V80:                          ;OK
  CLC
V90:                          ;Done
  POP  SI,CX,BX,EAX           ;Restore used registers
  POP  DI                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS AN INT 13h GET DISK TYPE REQUEST
;Inputs:  DS = TSR Data Area
;         ALL other registers except BP & SI = original INT 13h Calling Values
;           (AX,BX,CX,DX,DI,ES)
;         SS:[BP] = Original Calling Registers & Flags (AX,SI,BP,DS)
;Outputs: CF = Clear
;              Int13AHSuccess = Appropriate Disk Value (Removable w/ ChangeLine)
;              CX:DX = Total Number of Sectors
;Changes:

;If Floppy, return type 1 (Floppy/Removable without Change Line support?)

;------------------------------------------------------------------------------
I13GetDiskType:
  PUSH BX                      ;Save used registers
  CALL CvtDL2DskInfoBX         ;[BX] = Disk Info entry
  MOV  Int13AHSuccess,2        ;Drive = Removable with Change-line Support
  MOV  CX,W [BX].DskMaxLBA,[2] ;CX:DX = Total
  MOV  DX,W [BX].DskMaxLBA,[0] ;  Number of Sectors
  CLC                          ;Set return flag
  POP  BX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS AN INT 13h GET DRIVE PARAMETERS REQUEST
;Inputs:  DS = TSR Data Area
;         ALL other registers except BP & SI = original INT 13h Calling Values
;           (AX,BX,CX,DX,DI,ES)
;         SS:[BP] = Original Calling Registers & Flags (AX,SI,BP,DS)
;Outputs: CF = Clear
;         CL (Bits 0-5)  = Max Sectors
;         CL (Bits 6-7) = Max Cylinder Bits 8-9
;         CH = Max Cylinder Bits 0-7
;         DH = Max Head
;         DL = Number of Hard Drives
;Changes:
;NOTE: This is the call used by FDISk to determine the Disk Parameters, and
;        what it uses to set up the Partition Tables!


;Return appropriate things in BL & ES:[DI] if really a floppy?

;------------------------------------------------------------------------------
I13GetParams:
  PUSH AX,BX                ;Save used registers
  CALL CvtDL2DskInfoBX      ;Convert Drive Num (DL) to Disk Entry ([BX])
  MOV  CL,B [BX].DskSectsPerTrack[0] ;CL = Maximum Sector
  MOV  AX,[BX].DskNumTracks ;AX = Maximum
  DEC  AX                   ;  Cylinder (Track)
  MOV  CH,AL                ;CH = Bits 0-7 of Max Cylinder (Track)
  SHL  AH,6                 ;CL Bits 6-7 =
  OR   CL,AH                ;  Bits 8-9 of Max Cylinder (Track)
  MOV  DX,[BX].DskNumHeads  ;DH =
  DEC  DX                   ;  Max
  MOV  DH,DL                ;  Head
  CALL GetNumDrivesDL       ;DL = Number of Int 13h Hard Drives
  CLC                       ;Set return flag
  POP  BX,AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS AN INT 13h CHECK READY OR SELF-TEST REQUEST
;Inputs:  DS = TSR Data Area
;         ALL other registers except BP & SI = original INT 13h Calling Values
;           (AX,BX,CX,DX,DI,ES)
;         SS:[BP] = Original Calling Registers & Flags (AX,SI,BP,DS)
;Outputs: CF = Clear if OK (Drive is Ready)
;            = Set if Error
;              SS:[BP].I13StkAX[1] = Error Code
;Changes:
;NOTE: There are actually three different Diagnostic Tests at the INT 13h
;        level (Controller RAM, Drive, and Controller Internal).  We do the
;        same test (a default SCSI Self-Test) for all of them.  Most SCSI
;        Devices only perform the default (mandatory) self-test.  If a
;        particular USB Device performs more tests than these, we can change
;        it in the future.
;------------------------------------------------------------------------------
I13CheckReady:
  PUSH AX,CX                    ;Save used registers
  MOV  CL,I13ErrNotReady        ;CL = Error Code to use for failure
  MOV  AX,SCSITestReadyFG       ;[AX] = Code to perform
  JMP >G00                      ;Do it
I13RAMDiag:
I13DriveDiag:
I13ContDiag:
  PUSH AX,CX                    ;Save used registers
  MOV  CL,I13ErrController      ;CL = Error Code to use for failure
  MOV  AX,SCSISelfTestFG        ;[AX] = Code to perform
;  JMP >G00                     ;Do it
G00:
  PUSH BX                       ;Save used registers
  CALL CvtDL2DskInfoBX          ;[BX] = Disk Info Entry
  CALL AX                       ;Perform the Test
  JNC >Y80                      ;If Success, we're done
Y70:                            ;Error
  MOV  B SS:[BP].I13StkAX[1],CL ;Store the Error Code
  STC                           ;Set return flag
  JMP >Y90                      ;Done
Y80:                            ;OK
  CLC                           ;Set return flag
Y90:                            ;Done
  POP  BX                       ;Restore used registers
  POP  CX,AX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS AN INT 13h RECALIBRATE REQUEST
;Inputs:  DS = TSR Data Area
;         ALL other registers except BP & SI = original INT 13h Calling Values
;           (AX,BX,CX,DX,DI,ES)
;         SS:[BP] = Original Calling Registers & Flags (AX,SI,BP,DS)
;Outputs: CF = Clear if OK (Seek Worked)
;            = Set if Error
;              SS:[BP].I13StkAX[1] = I13ErrSeekFail
;Changes:
;------------------------------------------------------------------------------
I13Recalibrate:
  PUSH BX              ;Save used registers
  CALL CvtDL2DskInfoBX ;[BX] = Disk Info Entry
  CALL SCSISeek0FG     ;Seek Sector 0
  JNC >C80             ;If Success, we're done
C70:                   ;Error
  MOV  B SS:[BP].I13StkAX[1],I13ErrSeekFail ;Store the Error Code
  STC                  ;Set return flag
  JMP >C90             ;Done
C80:                   ;OK
  CLC                  ;Set return flag
C90:                   ;Done
  POP  BX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS AN INT 13h DETECT CHANGE REQUEST
;Inputs:  DS = TSR Data Area
;         ALL other registers except BP & SI = original INT 13h Calling Values
;           (AX,BX,CX,DX,DI,ES)
;         SS:[BP] = Original Calling Registers & Flags (AX,SI,BP,DS)
;Outputs: CF = Clear if No disk Change
;            = Set if Disk Changed
;              SS:[BP].I13StkAX[1] = I13ErrDiskChanged
;Changes:
;NOTES: For hard drives, this only reports a Disk change once, after that
;         it reports no change.
;       For floppies, it always reports a change.  We could set up a timer
;         like we do in the Device Driver, but we won't.  A "regular"
;         Device Driver would simply call this INT 13h function and return
;         its status.  Our Device driver doesn't do that, so I don't think
;         this function will ever get called.
;------------------------------------------------------------------------------
I13DetChange:
  PUSH BX              ;Save used registers
  CALL CvtDL2DskInfoBX ;[BX] = Disk Info Entry
  CMP  [BX].DskAccessTimer,-1 ;Is the Media Removable?
  JNE >G70             ;If so, assume it has changed (we don't know)
  TEST [BX].DskFlags,DskFlagI13ChgRptd ;If not, have we already reported?
  JNZ >G80             ;If so, mark as No Change
  OR   [BX].DskFlags,DskFlagI13ChgRptd ;Mark as Reported
G70:                   ;Disk has changed
  MOV  B SS:[BP].I13StkAX[1],I13ErrDiskChanged ;AH = Disk Changed
  STC                  ;Set return flag
  JMP >G90             ;Done
G80:                   ;Disk has not changed, or we already reported
  CLC                  ;Set return flag
G90:                   ;Done
  POP  BX              ;Restore used registers
  RET

I13FormatTrack:
I13FormatBad:
I13FormatDrive:

I13InitParams:
I13SetDiskType:
I13SetMediaType:

  MOV  B SS:[BP].I13StkAX[1],I13ErrInvalidFunc ;AH = Invalid Function
  STC                                          ;Set Error Flag for Return
  RET


;All Standard INT 13h Functions below this point are related to formatting
;  and initialization


;--------B-1305-------------------------------
;INT 13 - FLOPPY - FORMAT TRACK
;        AH = 05h
;        AL = number of sectors to format
;        CH = track number
;        DH = head number
;        DL = drive number
;        ES:BX -> address field buffer (see #00235)
;Return: CF set on error
;        CF clear if successful
;        AH = status (see #00234)
;Notes:  on AT or higher, call AH=17h first
;        the number of sectors per track is read from the diskette parameter
;          table pointed at by INT 1E
;BUG:    some old Compaq BIOSes have a bug when attempting to call this function
;          from Windows Standard Mode with EMM386 loaded.  A possible workaround
;          is to call this function from Real Mode e.g. through DPMI function
;          "Call Real Mode function with FAR return" (see INT 31/AX=0301h).
;SeeAlso: AH=05h"FIXED",AH=17h,AH=18h,INT 1E
;
;Format of floppy format address field buffer entry (one per sector in track):
;Offset  Size    Description     (Table 00235)
; 00h    BYTE    track number
; 01h    BYTE    head number (0-based)
; 02h    BYTE    sector number
; 03h    BYTE    sector size (00h=128 bytes, 01h=256 bytes, 02h=512, 03h=1024)
;
;
;--------B-1305-------------------------------
;INT 13 - FIXED DISK - FORMAT TRACK
;        AH = 05h
;        AL = interleave value (XT-type controllers only)
;        ES:BX -> 512-byte format buffer
;                the first 2*(sectors/track) bytes contain F,N for each sector
;                   F = sector type
;                        00h for good sector
;                        20h to unassign from alternate location
;                        40h to assign to alternate location
;                        80h for bad sector
;                   N = sector number
;        CH = cylinder number (bits 8,9 in high bits of CL)
;        CL = high bits of cylinder number (bits 7,6)
;        DH = head
;        DL = drive
;Return: CF set on error
;        CF clear if successful
;        AH = status code (see #00234)
;Notes:  AWARD AT BIOS and AMI 386sx BIOS have been extended to handle more
;          than 1024 cylinders by placing bits 10 and 11 of the cylinder number
;          into bits 6 and 7 of DH
;        for XT-type controllers on an AT or higher, AH=0Fh should be called
;          first
;        the IBM AT BIOS and many other BIOSes use only the low four bits of
;          DH (head number) since the WD-1003 controller which is the standard
;          AT controller (and the controller that IDE emulates) only supports
;          16 heads
;        not all controller support sector types 20h and 40h
;        under Windows95, an application must issue a physical volume lock on
;          the drive via INT 21/AX=440Dh before it can successfully write to
;          the disk with this function
;SeeAlso: AH=05h"FLOPPY",AH=06h"FIXED",AH=07h"FIXED",AH=0Fh,AH=18h,AH=1Ah
;
;
;--------B-1306-------------------------------
;INT 13 - FIXED DISK - FORMAT TRACK AND SET BAD SECTOR FLAGS (XT,PORT)
;        AH = 06h
;        AL = interleave value
;        CH = cylinder number (bits 8,9 in high bits of CL)
;        CL = sector number
;        DH = head
;        DL = drive
;Return: AH = status code (see #00234)
;Note:   AWARD AT BIOS and AMI 386sx BIOS have been extended to handle more
;          than 1024 cylinders by placing bits 10 and 11 of the cylinder number
;          into bits 6 and 7 of DH
;SeeAlso: AH=05h"FIXED",AH=07h"FIXED"
;--------d-1306-------------------------------
;
;
;--------B-1307-------------------------------
;INT 13 - FIXED DISK - FORMAT DRIVE STARTING AT GIVEN TRACK (XT,PORT)
;        AH = 07h
;        AL = interleave value (XT only)
;        ES:BX = 512-byte format buffer (see AH=05h)
;        CH = cylinder number (bits 8,9 in high bits of CL)
;        CL = sector number
;        DH = head
;        DL = drive
;Return: AH = status code (see #00234)
;Note:   AWARD AT BIOS and AMI 386sx BIOS have been extended to handle more
;          than 1024 cylinders by placing bits 10 and 11 of the cylinder number
;          into bits 6 and 7 of DH
;SeeAlso: AH=05h"FIXED",AH=06h"FIXED",AH=1Ah
;
;
;--------B-1309-------------------------------
;INT 13 - HARD DISK - INITIALIZE CONTROLLER WITH DRIVE PARAMETERS (AT,PS)
;        AH = 09h
;        DL = drive (80h for first, 81h for second)
;Return: CF clear if successful
;        CF set on error
;        AH = status (see #00234)
;Notes:  on the PC and XT, this function uses the parameter table pointed at by
;          INT 41
;        on the AT and later, this function uses the parameter table pointed at
;          by INT 41 if DL=80h, and the parameter table pointed at by INT 46 if
;          DL=81h
;SeeAlso: INT 41"HARD DISK 0",INT 46"HARD DISK 1"
;
;

;--------B-1317-------------------------------
;INT 13 - FLOPPY DISK - SET DISK TYPE FOR FORMAT (AT,PS)
;        AH = 17h
;        AL = format type
;            01h = 320/360K disk in 360K drive
;            02h = 320/360K disk in 1.2M drive
;            03h = 1.2M disk in 1.2M drive
;            04h = 720K disk in 720K or 1.44M drive
;        DL = drive number
;Return: CF set on error
;        CF clear if successful
;        AH = status (see #00234 at AH=01h)
;Note:   this function does not handle 1.44M drives; use AH=18h instead
;SeeAlso: AH=15h,AH=18h
;
;
;--------B-1318-------------------------------
;INT 13 - DISK - SET MEDIA TYPE FOR FORMAT (AT model 3x9,XT2,XT286,PS)
;        AH = 18h
;        DL = drive number
;        CH = lower 8 bits of highest cylinder number (number of cylinders - 1)
;        CL = sectors per track (bits 0-5)
;             top 2 bits of highest cylinder number (bits 6,7)
;Return: AH = status
;            00h requested combination supported
;            01h function not available
;            0Ch not supported or drive type unknown
;            80h there is no disk in the drive
;        ES:DI -> 11-byte parameter table (see #01264 at INT 1E)
;Note:   this function does not set the INT 1E vector to point at the returned
;          parameter table; it is the caller's responsibility to do so
;SeeAlso: AH=05h,AH=07h,AH=17h,INT 1E
;
;


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE FOR EXTENDED INT 13h FUNCTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PROCESS AN INT 13h EXTENDED INSTALLATION CHECK
;Inputs:  DS = TSR Data Area
;         ALL other registers except BP & SI = original INT 13h Calling Values
;           (AX,BX,CX,DX,DI,ES)
;         SS:[BP] = Original Calling Registers & Flags (AX,SI,BP,DS)
;Outputs: CF = Clear if OK
;              AH, BX, CX contain appropriate return values
;            = Set if Error
;              SS:[BP].I13StkAX[1] = Error Code
;Changes:
;NOTES: We only support INT 13h Extensions version 1.
;       In addition, we do not support Drive Locking/Eject functions, since
;         most (if not all) USB Drives we will be controlling do not support
;         these functions either.  These functions are actually for drives
;         with removable media, not removable drives.
;------------------------------------------------------------------------------
I13XInstallCk:
  CMP  BX,55AAh ;Valid input parameter?
  JNE >I70      ;If not, error
  XCHG BL,BH    ;If OK, set return BX
  MOV  B SS:[BP].I13StkAX[1],01h ;AH = Major Version (1.0)
  MOV  CX,1     ;Functions Supported = 42h-44h (Read/Write/Verify)
                ;                      47h-48h (Seek/GetParams)
  JMP >I80      ;Done
I70:            ;Error
  MOV  B SS:[BP].I13StkAX[1],I13ErrInvalidFunc ;Error = Invalid Parameter
  STC           ;Set return flag
  JMP >I90      ;Done
I80:            ;OK
  CLC           ;Set return flag
I90:            ;Done
  RET

;------------------------------------------------------------------------------
;PROCESS AN INT 13h EXTENDED READ, WRITE, OR VERIFY REQUEST
;Inputs:  DS = TSR Data Area
;         ALL other registers except BP & SI = original INT 13h Calling Values
;           (AX,BX,CX,DX,DI,ES)
;         SS:[BP] = Original Calling Registers & Flags (AX,SI,BP,DS)
;Outputs: CF = Clear if OK
;            = Set if Error
;              SS:[BP].I13StkAX[1] = Error Code (return value in AX)
;Changes:
;NOTES: The verify function does not actually use the Data Buffer for anything.
;         Vefification simply verifies the CRC as stored on the disk.

;Need to test for Locked Drive before Using INT 13h calls?
;We actually shouldn't be changing AL on returns!

;------------------------------------------------------------------------------
I13XRead:
  PUSH SI                        ;Save used registers
  MOV  SI,SCSIReadFG             ;[DI] = Code to Call
  JMP >X00                       ;Do it
I13XWrite:
  PUSH SI                        ;Save used registers
  MOV  SI,SCSIWriteFG            ;[DI] = Code to Call (Assume No Verification)
  TEST AL,1                      ;Are we supposed to Verify?
  JZ  >X00                       ;If not, continue
  MOV  SI,SCSIWriteVerifyFG      ;[DI] = Code to Call (Need Verification)
  JMP >X00                       ;Do it
I13XVerify:
  PUSH SI                        ;Save used registers
  MOV  SI,SCSIVerifyFG           ;[DI] = Code to Call
;  JMP >X00                       ;Do it
X00:

;Test Write Protect in Write & WriteVerify

  PUSH EAX,BX,CX,DI,ES           ;Save used registers
  CALL CvtDL2DskInfoBX           ;[BX] = Disk Info Entry
  CMP  SI,SCSIWriteFG            ;Are we writing?
  JE  >X20                       ;If so, we need to test write protection
  CMP  SI,SCSIWriteVerifyFG      ;Are we writing?
  JNE >X30                       ;If not, continue
X20:                             ;Need to test Write Protection
  TEST [BX].DskFlags,DskFlagWriteProt ;Is the Disk Write Protected?
  JZ  >X30                       ;If not, continue
  MOV  B SS:[BP].I13StkAX[1],I13ErrWriteProt ;Error = Write Protected
  JMP >X70                       ;Done
X30:                             ;Not write-protected
  LES  DI,SS:[BP].I13StkSI       ;ES:[DI] = Disk Address Packet
  CMP  ES:[DI].DAPPktSize,10h    ;Legitimate Packet Size?
  JNE >X72                       ;If not, Error
  CMP  ES:[DI].DAPPktSize,10h    ;Legitimate Packet Size?


  CMP  D ES:[DI].DAPLBA64[4],0   ;LBA fits in DWord?
  JNE >X72                       ;If not, Error
  MOV  EAX,D ES:[DI].DAPLBA64[0] ;EAX = LBA Sector
  XOR  CX,CX                     ;CX =
  MOV  CL,ES:[DI].DAPNumBlocks   ;  Number of Sectors
  LES  DI,ES:[DI].DAPXferAddr32  ;ES:[DI] = Data Buffer
  CALL TestInt13RWV              ;Test the paramaters for validity
  JC  >X78                       ;If invalid, Error
  CALL SI                        ;Do it
  JNC >X80                       ;If it worked, quit
X70:                             ;Error

  ;Figure out Actual Error Code here!

  MOV  B SS:[BP].I13StkAX[1],I13ErrTimeout ;Error = Timeout
  JMP >X78                       ;Done
X72:
  MOV  B SS:[BP].I13StkAX[1],I13ErrInvalidFunc ;Error = Invalid Parameter
X78:                             ;Error (Error Codes already set)
  LES  DI,SS:[BP].I13StkSI       ;ES:[DI] = Disk Address Packet
  MOV  ES:[DI].DAPNumBlocks,0    ;Number of Bytes Transferred = 0
  STC                            ;Set Error Flag for Return
  JMP >X90                       ;Done
X80:                             ;OK
  CLC
X90:                             ;Done
  POP  ES,DI,CX,BX,EAX           ;Restore used registers
  POP  SI                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS AN INT 13h EXTENDED SEEK REQUEST
;Inputs:  DS = TSR Data Area
;         ALL other registers except BP & SI = original INT 13h Calling Values
;           (AX,BX,CX,DX,DI,ES)
;         SS:[BP] = Original Calling Registers & Flags (AX,SI,BP,DS)
;Outputs: CF = Clear if OK
;            = Set if Error
;              SS:[BP].I13StkAX[1] = Error Code
;Changes:
;------------------------------------------------------------------------------
I13XExtSeek:
  PUSH EAX,BX,DI,ES              ;Save used registers
  CALL CvtDL2DskInfoBX           ;[BX] = Disk Info Entry
  LES  DI,SS:[BP].I13StkSI       ;ES:[DI] = Disk Address Packet
  CMP  ES:[DI].DAPPktSize,10h    ;Legitimate Packet Size?
  JNE >K72                       ;If not, Error
  CMP  D ES:[DI].DAPLBA64[4],0   ;LBA fits in DWord?
  JNE >K72                       ;If not, Error
  MOV  EAX,D ES:[DI].DAPLBA64[0] ;EAX = LBA Sector
  CMP  EAX,[BX].DskMaxLBA        ;Valid LBA Sector Number?
  JA  >K74                       ;If not, error
  CALL SCSISeekFG                ;If OK, do it
  JNC >K80                       ;If it worked, quit
K70:                             ;Error
  MOV  B SS:[BP].I13StkAX[1],I13ErrSeekFail ;Error = Seek failure
  JMP >K78                       ;Done
K72:                             ;Error - Invalid Parameter
  MOV  B SS:[BP].I13StkAX[1],I13ErrInvalidFunc ;Error = Invalid Parameter
  JMP >K78                       ;Done
K74:                             ;Error - Bad Sector Number
  MOV  B SS:[BP].I13StkAX[1],I13ErrNoSector ;Error = Invalid Sector
K78:                             ;Error (Error Codes already set)
  STC                            ;Set Error Flag for Return
  JMP >K90                       ;Done
K80:                             ;OK
  CLC
K90:                             ;Done
  POP  ES,DI,BX,EAX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS AN INT 13h GET EXTENDED DRIVE PARAMETERS REQUEST
;Inputs:  DS = TSR Data Area
;         ALL other registers except BP & SI = original INT 13h Calling Values
;           (AX,BX,CX,DX,DI,ES)
;         SS:[BP] = Original Calling Registers & Flags (AX,SI,BP,DS)
;Outputs: CF = Clear if OK
;              DS:[SI] Input Buffer filled with Data
;            = Set if Error
;              SS;[BP].I13StkAX[1] = Error Code
;Changes:
;------------------------------------------------------------------------------
I13XGetDrvParams:
  PUSH EAX,EBX,EDX,DI,ES                ;Save used registers
  CALL CvtDL2DskInfoBX                  ;[BX] = Disk Info Entry
  LES  DI,SS:[BP].I13StkSI              ;ES:[DI] = Where to put data
  CMP  ES:[DI].I13XBuffSize,I13XSize    ;Is the Buffer Size big enough?
  JB  >P70                              ;If not, error
  MOV  ES:[DI].I13XBuffSize,I13XSize    ;If so, store the Size we're using
  MOV  ES:[DI].I13XFlags,I13XFlagsToUse ;Store Flags
  MOV  AX,[BX].DskBytesPerSect          ;Store Number of
  MOV  ES:[DI].I13XBytesPerSect,AX      ;  Bytes Per Sector
  MOV  EAX,[BX].DskMaxLBA               ;Store
  INC  EAX                              ;  Total
  MOV  D ES:[DI].I13XTotalSects[0],EAX  ;  Sectors
  XOR  EAX,EAX                          ;Set High Word of EAX to 0
  MOV  D ES:[DI].I13XTotalSects[4],EAX  ;Set High DWord of Total Sectors to 0
  CMP  [BX].DskMaxLBA,MaxI13TotalSects  ;Is the current CHS Data Valid?
  JA  >P20                              ;If not, handle it
P10:                                    ;Current CHS Data is Valid
  MOV  AX,[BX].DskNumHeads              ;Store Number
  MOV  ES:[DI].I13XNumHeads,EAX         ;  of Heads
  MOV  AX,[BX].DskNumTracks             ;Store Number
  MOV  ES:[DI].I13XNumTracks,EAX        ;  of Tracks
  MOV  AX,[BX].DskSectsPerTrack         ;Store Number of
  MOV  ES:[DI].I13XSectsPerTrack,EAX    ;  Sectors Per Track
  JMP >P80                              ;Done
P20:                                    ;Drive is too big for INT 13h CHS Data
  MOV  ES:[DI].I13XNumHeads,255         ;Set Number of Heads to 255
  MOV  ES:[DI].I13XSectsPerTrack,255    ;Set Sectors Per Track to 255
  MOV  EAX,[BX].DskMaxLBA               ;Divide
  INC  EAX                              ;  Total
  XOR  EDX,EDX                          ;  Sectors
  MOV  EBX,(255*255)                    ;  by (Heads * SectsPerTrack)
  DIV  EBX                              ;  (Leaves EAX = Tracks)
  OR   EDX,EDX                          ;Is there a Remainder?
  JZ  >P30                              ;If not, the number is OK
P25:                                    ;Need to Round Up by 1
  INC  EAX                              ;Round Up the number of Tracks
P30:                                    ;EAX = Number of Tracks
  MOV  ES:[DI].I13XNumTracks,EAX        ; Store Number of Tracks
  JMP >P80                              ;Done
P70:                                    ;Error
  MOV  B SS:[BP].I13StkAX[1],I13ErrInvalidFunc ;Error = Invalid Parameter
  STC                                   ;Set Return Flag
  JMP >P90                              ;Done
P80:                                    ;OK
  CLC                                   ;Set Return Flag
P90:                                    ;Done
  POP  ES,DI,EDX,EBX,EAX                ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE FOR INT 13h READ/WRITE/VERIFY/SEEK FUNCTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST REGISTERS IN AN INT 13h CALL FOR VALIDITY
;Inputs:   DS  = TSR Data Area
;         EAX  = Starting Sector Number
;         [BX] = Disk Info Entry
;          CX  = Number of Sectors (in Read/Write/Verify Call)
;         SS:[BP] = Int 13h Calling Values
;Outputs: CF = Clear if OK (Sectors Numbers are on the Disk)
;            = Set if Error
;              SS:[BP].I13StkAX = Error Code
;Changes:
;------------------------------------------------------------------------------
TestInt13RWV:
  PUSH EAX,ECX,DX              ;Save used registers
  CMP  EAX,[BX].DskMaxLBA      ;Starting Sector Number too big?
  JA  >S70                     ;If so, Error
  AND  ECX,0000_FFFFh          ;Calculate the
  ADD  EAX,ECX                 ;  Ending Sector Number
  CMP  EAX,[BX].DskMaxLBA      ;Ending Sector Number too big?
  JA  >S70                     ;If so, Error
  OR   CX,CX                   ;Is the number of Sectors 0?
  JZ  >S72                     ;If so, Error
  MOV  AX,[BX].DskBytesPerSect ;Multiply Bytes Per Sector
  MUL  CX                      ;  by Number of Sectors
  OR   DX,DX                   ;Is it more than 65535 bytes?
  JZ  >S80                     ;If not, it's OK
  JMP >S72                     ;If so, error
S70:                           ;Error - LBA too big
  MOV  B SS:[BP].I13StkAX[1],I13ErrNoSector ;Put Error Code on Stack
  JMP >S75                     ;Continue
S72:                           ;Error - Too Many Sectors
  MOV  B SS:[BP].I13StkAX[1],I13ErrInvalidFunc ;AH = Invalid Function
S75:                           ;Error (Error Code set)
  CMP  B Int13AXInput[1],I13CmdXInstallCk ;Was this an extended call?
  JAE >S77                     ;If so, don't reset AL
  MOV  B SS:[BP].I13StkAX[0],0 ;AL = 0 for Return
S77:                           ;Error (Error Codes Set)
  STC                          ;Set return flag
  JMP >S90                     ;Done
S80:                           ;OK
  CLC                          ;Set return flag
S90:                           ;Done
  POP  DX,ECX,EAX              ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE FOR DISK RESET FUNCTIONS (INT 13h & INT 21h)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;RESET ALL DISKS
;Inputs:   DS  = TSR Data Area
;Outputs:
;Changes: For All USB Disks:
;           Rezeroes Disk
;           Flushes Internal Caches
;           Seeks to Sector 0 (Track 0)
;NOTE: Not all USB Disks support all (or any) of the functions performed, so
;        this may not actually do anything at all.  Because some of the
;        functions may not be supported, there could be long delays while
;        all of the drives time out.
;      One of the main times this function is called is during a soft
;        shutdown, and is issued to try and make sure all disk buffers
;        and caches are synchronized to the physical media before the
;        computer is turned off or rebooted.  We need to make every attempt
;        to assure everything is synchronized.
;      There can be buffers/caches in several places, and the caches we
;        are actually responsible for synchronizing are the ones internal
;        to the hard drive (the "low level" caches).  If there are any
;        "high level" caches in use (like SMARTDRV), they need to be flushed
;        BEFORE we do our flushing or things will not be synchronized properly.
;      Since it is possible (even likely) that a program like SMARTDRV was
;        installed before us in memory, but we need to actually do our thing
;        after it does, we must call the old processes before we
;        flush our caches.  We cannot flush our caches and then call the
;        old Code.
;------------------------------------------------------------------------------
ResetAllDisks:
  PUSH BX,CX             ;Save used registers
  MOV  BX,DiskInfoOffset ;[BX] = First Disk Entry
  MOV  CX,NumDisks       ;CX = Number of Table Entries
R10:                     ;Loop to here for each Table Entry
  TEST [BX].DskFlags,DskFlagInUse ;Valid Disk?
  JZ  >R50               ;If not, skip it
  CALL ResetDiskBX       ;Perform the Reset
R50:                     ;Done with this Drive Entry
  ADD  BX,DiskInfoSize   ;Point at the next Drive Entry
  LOOP R10               ;Keep going until we're done
  POP  CX,BX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESET A DISK
;Inputs:   DS  = TSR Data Area
;         [BX] = Disk Info Entry to Reset
;Outputs:
;Changes: Rezeroes Disk
;         Flushes Internal Caches
;         Seeks to Sector 0 (Track 0)
;NOTE: Not all USB Disks support all (or any) of the functions performed, so
;        this may not actually do anything at all.  Because some of the
;        functions may not be supported, there could be long delays while
;        a drive times out.
;------------------------------------------------------------------------------
ResetDiskBX:
  CALL SCSISyncCacheFG ;Synchronize the Cache
  JNC >R20             ;If it worked, continue
  OR   [BX].DskFlags2,DskFlagNoSync ;If not, don't issue it again
R20:                   ;Sync Cache is completed
  CALL SCSISeek0FG     ;Seek to Track Zero
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;MISCELLANEOUS SUPPORT CODE FOR INT 13h FUNCTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET THE NUMBER OF INT 13h DRIVE NUMBERS
;Inputs:
;Outputs: DL = Number of Int 13h Drive Numbers
;Changes:
;------------------------------------------------------------------------------
GetNumDrivesDL:
  PUSH AX                   ;Save used registers
  MOV  DL,80h               ;DL = First Physical Disk Number
N10:                        ;Loop to here for each Drive
  MOV  AH,I13CmdCheckReady  ;AH = Function = Check Ready
  INT  13h                  ;Do it
  CMP  AH,I13ErrInvalidFunc ;Is it a Valid Drive Number?
  JE  >N90                  ;If not, we're done
  INC  DL                   ;Fi so, go to the next drive
  CMP  DL,0FEh              ;Done all of them yet?
  JBE  N10                  ;If not, keep testing
N90:                        ;Done
  SUB  DL,80h               ;Convert Drive Number to a Drive Count
  POP  AX                   ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CONVERSION OF CHS (Cylinder-Head-Sector) TO LBA (Large Block Address)
;  We accomodate the maximum allowed CHS values, which requires LBA's
;    larger than 16-bits.  Therefore, we use 32-bit values, and
;    therefore 32-bit math, and therefore require a 32-bit CPU.
;  It would be possible to do the math with a 16-bit CPU, but we won't.
;    This is a USB Driver, and USB hardware requires a 32-bit CPU, so
;    it's pointless for this program when it makes things more difficult.
;    If this program were used as a basis to create another program that
;    wouldn't require a 32-bit CPU, or was only for floppy drives and very
;    small hard drives, this code would need to be changed.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST INT 13h CYLINDER/HEAD/SECTOR PARAMETERS FOR VALIDITY
;Inputs:  DS = TSR Data Area
;         CH = Low 8 bits of Cylinder Number
;         CL = Sector Number (1-63) in bits 0-5
;              High 2 bits of Cylinder Number (bits 6-7)
;         DH = Head Number
;         [SI] = Disk Info Entry
;         SS:[BP] = Int 13h Input Registers
;Outputs: CF = Clear if OK
;            = Set if Error (Illegal values in CHS)
;              SS:[BP].I13StkAX = Error Code
;Changes:
;NOTES: The Input Format (in CX & DH) is the format used by many standard
;         INT 13h functions.
;------------------------------------------------------------------------------
TestCHSParamsSI:
  PUSH AX                       ;Save used registers
  MOV  AX,CX                    ;Put 1-based
  SHR  AX,6                     ;  Cylinder Number
  INC  AX                       ;  in AX
  CMP  AX,[SI].DskNumTracks     ;Is it too big?
  JA  >P70                      ;If so, Error
  XOR  AX,AX                    ;Put 1-based
  MOV  AL,DH                    ;  Head Number
  INC  AX                       ;  in AX
  CMP  AX,[SI].DskNumHeads      ;Is it too big?
  JA  >P70                      ;If so, error
  XOR  AX,AX                    ;Put 1-based
  MOV  AL,CL                    ;  Sector Number
  AND  AX,3Fh                   ;  in AX
  JZ  >P70                      ;If too small, error
  CMP  AX,[SI].DskSectsPerTrack ;Is it too big?
  JBE >P80                      ;If not, everything's OK
P70:                            ;Error
  MOV  W SS:[BP].I13StkAX[0],(I13ErrInvalidFunc SHL 8) ;Error = Invalid Param
  STC                           ;Set return flag
  JMP >P90                      ;Done
P80:                            ;OK
  CLC                           ;Set return flag
P90:                            ;Done
  POP  AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A CHS SECTOR NUMBER TO A 32-bit LBA SECTOR NUMBER
;Inputs:  DS = TSR Data Area
;         CH = Low 8 bits of Cylinder Number
;         CL = Sector Number (1-63) in bits 0-5
;              High 2 bits of Cylinder Number (bits 6-7)
;         DH = Head Number
;         [SI] = Disk Info Entry
;         CHS Values (CX, DH) already tested for validity
;Outputs: Clear if OK
;              EAX = LBA Number (Logical Sector Address)
;            = Set if Error (Sector Number too big)
;              EAX = Unchanged
;              SS:[BP].I13StkAX = Error Code
;Changes:
;NOTES: The Input Format (in CX & DH) is the format used by many standard
;         INT 13h functions.
;       LBA = ((Cylinder * HeadsPerCyl + Head) * SectsPerTrack) + Sector - 1
;     or    = (Sector-1)+(Head*TotSects)+(Cyl*(TotHeads+1)*TotSects)
;------------------------------------------------------------------------------
CHS2LBA32:
  PUSH EBX,EDX,EDI              ;Save used registers
  MOV  EDI,EAX                  ;Save original EAX
  AND  EDX,0000_FFFFh           ;Set high word of EDX to 0
  XOR  EBX,EBX                  ;Set high word of EBX to 0
  XOR  EAX,EAX                  ;Set high word of EAX to 0
  MOV  AX,CX                    ;Put Cylinder Number
  SHR  AX,6                     ;  in EAX
  PUSH EDX                      ;Save Head #
  MOV  BX,[SI].DskNumHeads      ;Multiply by
  MUL  EBX                      ;  Heads-Per-Cylinder
  POP  EDX                      ;Get Head # back again
  SHR  DX,8                     ;Put Head # in DL
  ADD  EAX,EDX                  ;Add it to our Accumulator
  MOV  BX,[SI].DskSectsPerTrack ;Multiply by
  MUL  EBX                      ;  Sectors-per-Track
  MOV  BL,CL                    ;Add
  AND  BL,3Fh                   ;  the
  ADD  EAX,EBX                  ;  Sector #
  DEC  EAX                      ;Convert to 0-based LBA Sector Number
  CMP  EAX,[SI].DskMaxLBA       ;Too big?
  JBE >L80                      ;If not, we're done
L70:                            ;Error
  MOV  EAX,EDI                  ;Restore original EAX
  STC                           ;Set return flag
  JMP >L90                      ;Done
L80:                            ;OK
  CLC                           ;Set return flag
L90:                            ;Done
  POP  EDI,EDX,EBX              ;Restore used registers
  RET

;;------------------------------------------------------------------------------
;;CONVERT A 32-bit LBA SECTOR NUMBER TO A CHS SECTOR NUMBER
;;Inputs:  DS = TSR Data Area
;;         EAX = LBA Number (Logical Sector Address)
;;         [SI] = Disk Info Entry
;;Outputs: CH = Low 8 bits of Cylinder Number
;;         CL = Sector Number (1-63) in bits 0-5
;;              High 2 bits of Cylinder Number (bits 6-7)
;;         DH = Head Number
;;Changes:
;;NOTES: The Output Format (in CX & DH) is the format used by many standard
;;         INT 13h functions.
;;       Cylinder = LBA  / (HeadsPerCyl * SectsPerTrack)
;;       Temp     = LBA  % (HeadsPerCyl * SectsPerTrack)
;;       Head     = Temp / SectsPerTrack
;;       Sector   = Temp % SectsPerTrack + 1
;;
;;  or   Sector   = ((LBA % TotalSects)+1)
;;       CylHead  = (LBA / TotSects)
;;       Head     = (CylHead % (TotHeads + 1))
;;       Cylinder = (CylHead / (TotHeads + 1))
;;
;;       We do not test to see if the LBA is too big to be valid for the
;;         Drive parameters.
;;------------------------------------------------------------------------------
;LBA32ToCHS:
;  PUSH EAX,EBX,EDI              ;Save used registers
;  MOV  EDI,EDX                  ;Save original EDX
;  XOR  EDX,EDX                  ;Set high DWord of Dividend to 0
;  XOR  EBX,EBX                  ;Set high Word of EBX to 0
;  MOV  BX,[SI].DskSectsPerTrack ;Divide LBA by the
;  DIV  EBX                      ;  Sectors-per-Track
;  INC  DX                       ;Increment remainder by 1 (Remainder is Sector # - 1)
;  MOV  CL,DL                    ;Store Sector Number (bits 0-5)
;  XOR  DX,DX                    ;Set high DWord of Dividend to 0
;  MOV  BX,[SI].DskNumHeads      ;Divide LBA/SectorsPerTrack by
;  DIV  EBX                      ;  Heads-per-Cylinder
;  MOV  CH,AL                    ;Put first 8 bits of Cylinder # in CH
;  SHL  AH,6                     ;Mask the last two bits of the
;  OR   CL,AH                    ;  Cylinder # into CL
;  MOV  AL,DL                    ;Save Head #
;  MOV  EDX,EDI                  ;Restore original EDX
;  MOV  DH,AL                    ;Put Head # in DH
;  POP  EDI,EBX,EAX              ;Restore used registers
;  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO HANDLE INT 21h (DOS), INT 25h & 26h (ABSOLUTE DISK READ & WRITE)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HAVE INTERRUPT 21h (DOS) RUN THIS EVERY TIME IT OCCURS
;Inputs: AX = DOS Function Number
;        Other registers dependent on Specific Function
;Outputs: Reads/Writes data to/from disk, if call is appropriate
;Changes:
;------------------------------------------------------------------------------
Int21Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int21:
  PUSH BP                          ;Save used registers
  MOV  BP,SP                       ;SS:[BP+0] = BP
                                   ;SS:[BP+2] = IP
                                   ;SS:[BP+4] = CS
                                   ;SS:[BP+6] = Flags
  PUSHF                            ;Save flags
                                   ;SS:[BP-2] = Our Flags
  PUSH BX,DX,DI,DS,ES              ;Save used registers
  STI                              ;Enable interrupts
  CLD                              ;Go forward with string functions
  CMP  AX,0D00h                    ;Function 0D00h (Reset Disk)?
  JNE >O30                         ;If not try other possibilities
O10:                               ;Reset Disk
  PUSH W SS:[BP-2]                 ;Call the Original
  CALL D CS:Int21Hdr.OldVector     ;  Int 21h Code
;  JC  >O70                         ;If error, quit
  MOV  DS,CS                       ;If OK, point DS at the TSR Data Area
  CALL ResetAllDisks               ;Reset our USB Disks
  JMP >O80                         ;Done
O30:                               ;Not Reset Disk
  CMP  AX,7305h                    ;FAT32 Extended Absolute Disk Read/Write?
  JNE >O99                         ;If not, it's not for us
  CMP  CX,-1                       ;CX correct value?
  JNE >O99                         ;If not, it''s not for us
  MOV  DI,BX                       ;ES:[DI] =
  MOV  ES,DS                       ;  Data Packet
  MOV  DS,CS                       ;DS = TSR Data Area
  DEC  DL                          ;Convert Drive Number (DL) to 0-based
  CALL DrvNum2OffsetDLBX           ;Get the Drive Info Offset DS:[BX]
  JC  >O99                         ;If it's not for us, quit
  ;OR   TSRFlags,Int21Call          ;Mark as an Int 21h Call
  MOV  DX,DoInt25Call              ;Assume it's a Read
  TEST SI,I21XRWWrite              ;Is it a Read?
  JZ  >O40                         ;If so, continue
  MOV  DX,DoInt26Call              ;If not, it's Write
O40:                               ;[DX] = Code to call, ES:[DI] = Packet,
                                   ;  CX = -1
  CALL DX                          ;Do it
  JNC >O80                         ;If it worked, we're done

;Make sure to set correct error code here!

  MOV  AX,DOSXErrGeneralFail       ;Set Error Code
O70:                               ;Error (AX contains Error Code)
  OR   B SS:[BP+6],CarryFlag       ;Mark as an error
  JMP >O90                         ;Done
O80:                               ;OK
  AND  B SS:[BP+6],(NOT CarryFlag) ;Mark as OK
O90:                               ;Done
  ;AND  TSRFlags,(NOT Int21Call)    ;Unset INT 21h Flag
  POP  ES,DS,DI,DX,BX              ;Restore used registers
  POPF                             ;Restore flags
  POP  BP                          ;Restore used registers
  IRET

Int21Old:
O99:
  POP  ES,DS,DI,DX,BX          ;Restore used registers
  POPF                         ;Restore flags
  POP  BP                      ;Restore used registers
  JMP  D CS:Int21Hdr.OldVector ;Let the Old Interrupt Handler process it

;------------------------------------------------------------------------------
;HAVE INTERRUPT 25h (ABSOLUTE DISK READ) RUN THIS EVERY TIME IT OCCURS
;Inputs:      AL  = Drive Number (0=A:, 1=B:, etc.)
;         DS:[BX] = Data Buffer if (CX != -1)
;                 = Request Packet (if CX = -1)
;             CX  = Number of Sectors to Read
;             DX  = Starting Sector Number (if CX != -1)
;Outputs: Reads data from disk, if call is appropriate
;Changes:
;NOTES: Returns with original flags still left on the stack!
;------------------------------------------------------------------------------
Int25Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int25:
  PUSH BX,DI,DS,ES       ;Save used registers
  PUSHF                  ;Save flags
  STI                    ;Enable interrupts
  CLD                    ;Go forward with string functions
  MOV  DI,BX             ;ES:[DI] =
  MOV  ES,DS             ;  Data Buffer
  MOV  DS,CS             ;DS = TSR Data Area
  CALL DrvNum2OffsetALBX ;Get the Drive Info Offset DS:[BX]
  JC  >W99               ;If it's not one of ours, pass to the old handler
W20:                     ;Check Device Ready
  CALL WaitForDrvBX      ;Wait for Media
  JNC >W40               ;If OK, continue
  MOV  AX,((I25ErrAHTimeout SHL 8)+I25ErrALNotReady) ;AX = Error Code
  JMP >W70               ;Error
W40:                     ;Device is Ready
  CALL DoInt25Call       ;Process the Call (rtns CF, AX)
  JNC >W80               ;If it worked, we're done
W70:                     ;Error (AX contains Error Code)
  POPF                   ;Restore flags
  STC                    ;Set return flag
  JMP >W90               ;Done
W80:                     ;OK
  POPF                   ;Restore flags
  CLC                    ;Set return flag
W90:                     ;Done
  POP  ES,DS,DI,BX       ;Restore used registers
  RETF                   ;NOT IRET!  Original Flags left on stack!

Int25Old:
W99:
  POPF                         ;Restore flags
  POP  ES,DS,DI,BX             ;Restore used registers
  JMP  D CS:Int25Hdr.OldVector ;Let the Old Interrupt Handler process it

;------------------------------------------------------------------------------
;HAVE INTERRUPT 26h (ABSOLUTE DISK WRITE) RUN THIS EVERY TIME IT OCCURS
;Inputs:      AL  = Drive Number (0=A:, 1=B:, etc.)
;         DS:[BX] = Data Buffer if (CX != -1)
;                 = Request Packet (if CX = -1)
;             CX  = Number of Sectors to Write
;             DX  = Starting Sector Number (if CX != -1)
;Outputs: Writes data to disk, if call is appropriate
;Changes:
;NOTES: Returns with original flags still left on the stack!
;------------------------------------------------------------------------------
Int26Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int26:
  PUSH BX,DI,DS,ES       ;Save used registers
  PUSHF                  ;Save flags
  STI                    ;Enable interrupts
  CLD                    ;Go forward with string functions
  MOV  DI,BX             ;ES:[DI] =
  MOV  ES,DS             ;  Data Buffer
  MOV  DS,CS             ;DS = TSR Data Area
  CALL DrvNum2OffsetALBX ;Get the Drive Info Offset DS:[BX]
  JC  >X99               ;If it's not one of ours, pass to the old handler
X20:                     ;Check Device Ready
  CALL WaitForDrvBX      ;Wait for Media
  JNC >X40               ;If OK, continue
  MOV  AX,((I25ErrAHTimeout SHL 8)+I25ErrALNotReady) ;AX = Error Code
  JMP >X70               ;Error
X40:                     ;Device is Ready
  CALL DoInt26Call       ;Process the Call (rtns CF, AX)
  JNC >X80               ;If it worked, we're done
X70:                     ;Error (AX contains Error Code)
  POPF                   ;Restore flags
  STC                    ;Set return flag
  JMP >X90               ;Done
X80:                     ;OK
  POPF                   ;Restore flags
  CLC                    ;Set return flag
X90:                     ;Done
  POP  ES,DS,DI,BX       ;Restore used registers
  RETF                   ;NOT IRET!  Original Flags left on stack!

Int26Old:
X99:
  POPF                         ;Restore flags
  POP  ES,DS,DI,BX             ;Restore used registers
  JMP  D CS:Int26Hdr.OldVector ;Let the Old Interrupt Handler process it

;------------------------------------------------------------------------------
;PERFORM THE INT 25h (READ), INT 26h (WRITE), OR INT 21h/7305h CALL
;Inputs:  DS:[BX] = Drive Info Entry
;         ES:[DI] = Data Buffer/Request Packet (if CX = -1)
;             CX  = Number of Sectors to Read/Write
;             DX  = Starting Sector (if CX = -1)
;         TSRFlags.Int21Call (set if call is INT 21h instead of 25h/26h)
;Outputs: CF = Clear if OK (Request was performed)
;              AX = Unchanged
;            = Set if Error
;              AX = Error Code
;Changes:
;NOTES: Technically, INT 25h/26h calls are only supposed to work with
;         drives up to 2GB in size, and we're supposed to return Error
;         Code 0207h to tell the caller to use INT 21h/7305h to get data
;         for Drives > 2GB (FAT32).
;       However, there is absolutely no legitimate reason that INT 25h/26h
;         cannot return data for drives > 2GB, so we will process the calls
;         and not return errors.
;       The only time I could imagine this potentially causing a problem
;         is if there is a program out there that uses error code 0207h
;         as the sole "test" for the recognizition of a FAT32 drive.  I
;         can't imagine a program actually doing that, so I think we'll
;         be OK.
;------------------------------------------------------------------------------
DoInt25Call:
  PUSH BP               ;Save used registers
  MOV  BP,SCSIReadFG    ;[BP] = Code to call
  JMP >Y00              ;Do it
DoInt26Call:
  PUSH BP               ;Save used registers
  MOV  BP,SCSIWriteFG   ;[BP] = Code to call
;  JMP >Y00              ;Do it
Y00:
  PUSH SI               ;Save used registers
  MOV  SI,AX            ;Save original AX
  PUSH EAX,BX,CX,DI,ES  ;Save used registers
  XOR  EAX,EAX          ;Start at Sector 0
  OR   CX,CX            ;Valid # of Sectors?
  JZ  >Y70              ;If not, error
  CMP  CX,-1            ;Extended call?
  JE  >Y30              ;If so, handle it
Y10:                    ;Normal call
  MOV  AX,DX            ;Store the Starting Sector
  JMP >Y50              ;We're ready to send it
Y30:                    ;Extended call
;  TEST TSRFlags,Int21Call ;Is it an Int 21h Call?
;  JNZ >Y35              ;If so, process it
;  CMP  [BX].DrvPartOS,POSFAT32 ;If not, is the Drive FAT 32?
;  JAE >Y73              ;If so, error (need to use INT 21h, AX = 7305h)
;Y35:                    ;Process call
  MOV  EAX,ES:[DI].I25PktSectNum ;EAX = Starting Sector Number
  MOV  CX,ES:[DI].I25PktNumSects ;CX = Number of Sectors to transfer
  LES  DI,ES:[DI].I25PktXferAddr ;ES:[DI] = Transfer Address
Y50:                    ;Parameters are Ready (EAX = Sector, CX = Sectors,
                        ;  DS:[BX] = Drive Info, ES:[DI] = Buffer)
  ADD  EAX,[BX].DrvBootSector ;Adjust for Hidden Sectors
  JC  >Y71              ;If overflow, error
  CALL TestSectInPartBX ;Are all of the Sectors in the Partition?
  JC  >Y71              ;If not, error
  MOV  BX,[BX].DrvDskOffset ;[BX] = Disk Info Entry
  CMP  BP,SCSIWriteFG   ;Are we writing?
  JNE >Y60              ;If not, continue
  TEST [BX].DskFlags,DskFlagWriteProt ;If so, is the Disk Write Protected?
  JNZ >Y73              ;If so, error
Y60:                    ;OK to issue Request
  CALL BP               ;Issue the Request
  JNC >Y80              ;If it worked, we're done
  MOV  SI,((I25ErrAHTimeout SHL 8)+I25ErrALGeneral) ;Set Error Code
  JMP >Y78              ;Done
Y70:                    ;Error in Command
  MOV  SI,((I25ErrAHBadCmd SHL 8)+I25ErrALUnknCmd) ;Set Error Code
  MOV  SI,0103h         ;Error = Bad Command, Unknown Command
  JMP >Y78              ;Done
Y71:                    ;Sector too big
  MOV  SI,((I25ErrAHNoSector SHL 8)+I25ErrALNoSector) ;Set Error Code
  JMP >Y78              ;Done
Y73:                    ;Write Protection Error
  MOV  SI,((I25ErrAHWriteProt SHL 8)+I25ErrALWriteProt) ;Set Error Code
;  JMP >Y78              ;Done
Y78:                    ;Error (SI contains Error Code)
  STC                   ;Set return flag
  JMP >Y90              ;Done
Y80:                    ;OK
  CLC                   ;Set return flag
Y90:                    ;Done
  POP  ES,DI,CX,BX,EAX  ;Restore used registers
  MOV  AX,SI            ;Set AX for the return
  POP  SI               ;Restore used registers
  POP  BP               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST TO MAKE SURE A RANGE OF SECTORS ARE IN A PARTITION
;Inputs:   DS  = TSR Data Area
;         [BX] = Drive Info Entry
;         EAX  = Starting Sector (adjusted for Boot Sector)
;          CX  = Number of Sectors
;Outputs:  CF = Clear if OK (All Sectors are in the Partition)
;             = Set if Error (Sectors are no in the Partition)
;Changes:
;------------------------------------------------------------------------------
TestSectInPartBX:
  PUSH EAX,ECX                 ;Save used registers
  CMP  EAX,[BX].DrvBootSector  ;Is it below the Boot Sector?
  JB  >S70                     ;If so, error
  AND  ECX,0000_FFFFh          ;If OK, get rid of high word of Sector Count
  ADD  ECX,EAX                 ;ECX = Final Sector of Read/Write + 1
  JNC >S20                     ;If no overflow, continue
  OR   ECX,ECX                 ;Did it overflow to 0?
  JNZ >S70                     ;If not, it's a true overflow
S20:                           ;Overflow handled, if appropriate
  DEC  ECX                     ;ECX = Final Sector of Read/Write
  MOV  EAX,[BX].DrvBootSector  ;EAX = Sector difference from Boot Record
  ADD  EAX,[BX].DrvSectsInPart ;Add in the Size of the Partition
  CMP  EAX,ECX                 ;Is the Last Sector in the Partition?
  JAE >S80                     ;If so, it's OK
S70:                           ;Error
  STC                          ;Set return flag
  JMP >S90                     ;Done
S80:                           ;OK
  CLC                          ;Set return flag
S90:                           ;Done
  POP  ECX,EAX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A DRIVE NUMBER (0-31) TO A DRIVE INFO TABLE OFFSET
;Inputs:  DS = TSR Data Area
;         AL = Drive Number (0-31)
;              or DL = Drive Number
;Outputs: CF = Clear if OK (Drive Number is ours)
;              [BX] = Drive Info Table Offset
;            = Set if Error
;              BX = Unchanged
;Changes:
;------------------------------------------------------------------------------
DrvNum2OffsetDLBX:
  PUSH AX                ;Save used registers
  MOV  AL,DL             ;Put Drive Number in AL
  CALL DrvNum2OffsetALBX ;Do it
  POP  AX                ;Restore used registers
  RET

DrvNum2OffsetALBX:
  PUSH CX,DX              ;Save used registers
  MOV  DX,BX              ;Save original BX
  MOV  BX,DriveInfoOffset ;[BX] = Drive Info Table
  MOV  CX,NumDrives       ;CX = Number of entries in the Table
L10:                      ;Loop to here for each Drive Entry
  TEST [BX].DrvFlags,DrvFlagInUse ;Already being used?
  JZ  >L20                ;If not, skip it
  CMP  AL,[BX].DrvDPB.DPBDriveNum ;Is this the right entry?
  JE  >L80                ;If so, we're done
L20:                      ;Not correct table entry
  ADD  BX,DriveInfoSize   ;Point at the next table entry
  LOOP L10                ;Keep looking
L70:                      ;Error (Drive Letter not found)
  MOV  BX,DX              ;Restore original BX
  STC                     ;Set return flag
  JMP >L90                ;Done
L80:                      ;OK (Drive Letter found)
  CLC                     ;Set return flag
L90:                      ;Done
  POP  DX,CX              ;Restore used registers
RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO DELAY FOR A LITTLE WHILE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;DELAY FOR A GIVEN NUMBER OF MILLISECONDS
;Inputs:  AX = number of milliseconds to wait (0-65,535)
;Outputs:
;Changes:
;------------------------------------------------------------------------------
DelayMSAX:
  PUSH AX,BX,DX  ;Save used registers
  OR   AX,AX     ;Is there anything to do?
  JZ  >D90       ;If not, just quit
  MOV  DX,1000   ;Convert
  MUL  DX        ;  to
  MOV  BX,AX     ;  microseconds (DX:BX)
D10:             ;Loop to here for each 65535 uS
  OR   DX,DX     ;Counted down high word yet?
  JZ  >D30       ;If so, handle it
  DEC  DX        ;Decrement high word
  MOV  AX,-1     ;Maximum microseconds
  JMP >D50       ;Do it
D30:             ;Counted down high word
  OR   BX,BX     ;Anything to do?
  JZ  >D90       ;If not, we're done
  MOV  AX,BX     ;Get Low Word
  XOR  BX,BX     ;Make sure it's zero next time
D50:             ;AX = Microseconds to wait
  CALL DelayUSAX ;Delay the number of microseconds specified
  JMP  D10       ;See if we need to wait some more
D90:             ;We're done
  POP  DX,BX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DELAY FOR A GIVEN NUMBER OF MICROSECONDS
;Inputs:  AX = number of microseconds to wait (0-65535)
;Outputs:
;Changes:
;   NOTE: Delays will be slightly longer than what's asked for, never shorter.
;         Accuracy decreases with small delays or slow computers!
;------------------------------------------------------------------------------
DelayUSAX:
  PUSH AX,BX           ;Save used registers
  OR   AX,AX           ;Is there anything to do?
  JZ  >D90             ;If not, just quit
  MOV  BX,AX           ;Put it in BX
  MOV  AX,(0FFFFh/3)+1 ;Maximum time for each sub-delay
D10:                   ;Loop to here for each sub-delay
  CMP  BX,AX           ;Is it more than the maximum?
  JA  >D40             ;If so, just do the sub-delay
  MOV  AX,BX           ;If not, just do the remainder that's left
D40:                   ;Do the delay
  CALL DoDelayUS       ;Do the US Delay
  SUB  BX,AX           ;SUbtract out how long we just waited
  JNZ  D10             ;If not 0 yet, do the sub-delay again
D90:                   ;We're done
  POP  BX,AX           ;Restore used registers
  RET

DoDelayUS:
  PUSH AX,BX,CX,DX ;Save used registers
  PUSHF            ;Save Flags
  SHL  AX,1        ;Multiply by 2
  MOV  BX,11932    ;Compensate for the fact
  MUL  BX          ;  that the clock frequency
  MOV  BX,10000    ;  is actually
  DIV  BX          ;  1.19318 MHz
  MOV  DX,AX       ;Save it
  CLI              ;Disable interrupts
  CALL GetTimer    ;Get the starting timer tick counter
  MOV  CX,AX       ;Save it
D20:               ;Keep looping to here until we've waited long enough
  MOV  BX,CX       ;Get the starting timer tick counter
  CALL GetTimer    ;Get the current timer tick counter
  SUB  BX,AX       ;Calculate the elapsed time
  CMP  BX,DX       ;Has it been long enough?
  JB   D20         ;If not, keep waiting
D90:               ;We're done
  POPF             ;Restore Flags
  POP  DX,CX,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET CURRENT TIMER COUNTER FROM PORT 40h (THE CLOCK INTERRUPT)
;Inputs:
;Outputs: AX = Current timer counter word
;Changes:
;------------------------------------------------------------------------------
GetTimer:
  PUSHF       ;Save flags
  CLI         ;DIsable interrupts
  MOV  AL,06h ;Bits 7:6 =  00 = Timer 0
              ;Bits 5:4 =  00 = Latch Counter
              ;Bits 3:1 = 011 = Mode 3 (Square Wave)
              ;Bit    0 =   0 = Binary Counter (16 bits)
  OUT  43h,AL ;Tell the PIT what wer'e going to do
  IN   AL,40h ;Get LSB of timer counter
  MOV  AH,AL  ;Save it
  IN   AL,40h ;Get MSB of timer counter
  XCHG AH,AL  ;Put things in the right order
  POPF        ;Restore flags
  RET


;;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;;DEBUGGING CODE - NOT NEEDED IN FINAL RELEASE OF PROGRAM!!!
;;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;
;  VideoStartRow    EQU 12
;  VideoEndRow      EQU 50
;  VideoStartColumn EQU 40
;
;  VideoOffsetFirst EQU ((80*2*(VideoStartRow-1))+((VideoStartColumn-1)*2))
;  VideoOffsetLast  EQU ((80*2)*VideoEndRow)
;
;  VideoOffset DW VideoOffsetFirst ;Video Offset to use this time
;;
;;WriteCL:
;;  PUSH AX,DI,ES
;;  PUSHF
;;  CLD
;;  CALL GetVideoOffset ;(ES:[DI])
;;  MOV  AL,CL
;;  CALL WriteALByte
;;  POPF
;;  POP  ES,DI,AX
;;  RET
;
;WriteAXBXCXDX:
;  PUSHF               ;Save Flags
;  PUSH AX,DI,ES       ;Save used registers
;  PUSH BP             ;Save used registers
;  MOV  BP,SP          ;SS:[BP+0] = BP
;                      ;SS:[BP+2] = ES
;                      ;SS:[BP+4] = DI
;                      ;SS:[BP+6] = AX
;  CALL GetVideoOffset ;Get video offset to use (ES:[DI])
;  CALL WriteAXWord    ;Write AX
;  MOV  AX,BX          ;Write
;  CALL WriteAXWord    ;  BX
;  MOV  AX,CX          ;Write
;  CALL WriteAXWord    ;  CX
;  MOV  AX,DX          ;Write
;  CALL WriteAXWord    ;  DX
;;  MOV  AX,SS:[BP+4]   ;Write
;;  CALL WriteAXWord    ;  DI
;;  MOV  AX,SI          ;Write
;;  CALL WriteAXWord    ;  SI
;;  MOV  AX,SS:[BP+0]   ;Write
;;  CALL WriteAXWord    ;  BP
;;  MOV  AX,DS          ;Write
;;  CALL WriteAXWord    ;  DS
;;  MOV  AX,SS:[BP+2]   ;Write
;;  CALL WriteAXWord    ;  ES
;  POP  BP             ;Restore used regsiters
;  POP  ES,DI,AX       ;Restore used registers
;  POPF                ;Restore flags
;  RET
;
;WriteAXWord:
;  PUSH AX,CX         ;Save used registers
;  MOV  CH,4          ;Need to write 4 characters
;  MOV  CL,4          ;Need to shift 4 bits at a time
;W30:                 ;Loop to here for each Nibble we write
;  ROL  AX,CL         ;Put bits to write in low nibble
;  CALL WriteNibbleC  ;Write the Nibble
;  XOR  B ES:[DI],77h ;Toggle the Color
;  INC  DI            ;Skip over the Attribute Byte
;  DEC  CH            ;Decrement the Loop Counter
;  JNZ  W30           ;If not 0 yet, keep writing
;  MOV  AL,' '        ;Write a
;  STOSB              ;  Space
;  XOR  B ES:[DI],77h ;Toggle the Color
;  INC  DI            ;Skip over the Attribute Byte
;  POP  CX,AX         ;Restore used registers
;  RET
;
;;WriteALByte:
;;  PUSH AX,CX         ;Save used registers
;;  MOV  CH,2          ;Need to write 4 characters
;;  MOV  CL,4          ;Need to shift 4 bits at a time
;;W30:                 ;Loop to here for each Nibble we write
;;  ROL  AL,CL         ;Put bits to write in low nibble
;;  CALL WriteNibbleC  ;Write the Nibble
;;  XOR  B ES:[DI],77h ;Toggle the Color
;;  INC  DI            ;Skip over the Attribute Byte
;;  DEC  CH            ;Decrement the Loop Counter
;;  JNZ  W30           ;If not 0 yet, keep writing
;;  MOV  AL,' '        ;Write a
;;  STOSB              ;  Space
;;  XOR  B ES:[DI],77h ;Toggle the Color
;;  INC  DI            ;Skip over the Attribute Byte
;;  POP  CX,AX         ;Restore used registers
;;  RET
;
;WriteEAX:
;  PUSH EAX,CX,DI,ES   ;Save used registers
;  PUSHF               ;Save Flags
;  CALL GetVideoOffset ;Get video offset to use (ES:DI)
;  MOV  CH,8           ;Need to write 4 characters
;  MOV  CL,4           ;Need to shift 4 bits at a time
;F20:                  ;Loop to here for each Nibble we write
;  ROL  EAX,CL         ;Put bits to write in low nibble
;  CALL WriteNibbleC   ;Write the Nibble
;  XOR  B ES:[DI],77h  ;Toggle the Color
;  INC  DI             ;Skip over the Attribute Byte
;  DEC  CH             ;Decrement the Loop Counter
;  JNZ  F20            ;If not 0 yet, keep writing
;  POPF                ;Restore flags
;  POP  ES,DI,CX,EAX   ;Restore used registers
;  RET
;
;WriteAX:
;  PUSH AX,CX,DI,ES    ;Save used registers
;  PUSHF               ;Save Flags
;  CALL GetVideoOffset ;Get video offset to use (ES:DI)
;  MOV  CH,4           ;Need to write 4 characters
;  MOV  CL,4           ;Need to shift 4 bits at a time
;F20:                  ;Loop to here for each Nibble we write
;  ROL  AX,CL          ;Put bits to write in low nibble
;  CALL WriteNibbleC   ;Write the Nibble
;  XOR  B ES:[DI],77h  ;Toggle the Color
;  INC  DI             ;Skip over the Attribute Byte
;  DEC  CH             ;Decrement the Loop Counter
;  JNZ  F20            ;If not 0 yet, keep writing
;  POPF                ;Restore flags
;  POP  ES,DI,CX,AX    ;Restore used registers
;  RET
;
;WriteNibbleC:
;  PUSH AX             ;Save used register
;  AND  AL,0Fh         ;Get rid of the high nibble
;  ADD  AL,'0'         ;Convert it to a number
;  CMP  AL,'9'         ;Should it be a number?
;  JBE >N90            ;If so, we're done
;  ADD  AL,('A'-'9'-1) ;If not, convert it to a letter
;N90:                  ;We're done
;  STOSB               ;Write it to the string
;  POP  AX             ;Restore used register
;  RET                 ;We're done
;
;;Outputs:  ES = 0B800h (Video Segment)
;;          [DI] = Video Offset to use
;GetVideoOffset:
;  MOV  DI,0B800h                       ;Point ES at
;  MOV  ES,DI                           ;  Video Memory
;  MOV  DI,CS:VideoOffset               ;Point at Video Offset we want to change
;  ADD  CS:VideoOffset,160              ;Go to next row for next time
;  CMP  CS:VideoOffset,VideoOffsetLast  ;Gone too far yet?
;  JB  >V90                             ;If not, we're done
;  MOV  CS:VideoOffset,VideoOffsetFirst ;If so, reset it to the top
;V90:                                   ;Video Offset updated for next time
;  RET
;
;  TRow EQU 49 ;Row to Toggle Color in (1-based)
;  TCol EQU 80 ;Column to Toggle Color in (1-based)
;
;ToggleColor:
;  PUSH BX,DS        ;Save used registers
;  PUSHF             ;Save Flags
;  MOV  BX,0B800h    ;Point DS at
;  MOV  DS,BX        ;  video memory
;  MOV  BX,((TRow-1)*160)+((TCol-1)*2)
;  INC  B [BX]       ;Change the character
;  XOR  B [BX+1],77h ;Toggle the Color
;  POPF              ;Restore flags
;  POP  DS,BX        ;Restore used registers
;  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;STACK-RELATED FUNCTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;CREATE/DELETE OUR OWN STACK
;Inputs:  CS = TSR Data Area
;         StackInUse
;Outputs: Interrupts Enabled
;Changes: SS,SP to/from our stack
;------------------------------------------------------------------------------
MakeStack:
  CLI                  ;Disable interrupts
  PUSHF                ;Save
  POP  CS:TempFlags    ;  Flags
  INC  CS:StackInUse   ;Increment number-of-calls counter
  CMP  CS:StackInUse,1 ;Is this the first call?
  JNE >M90             ;If not, the stack is already in use
  MOV  CS:TempBX,BX    ;  BX in memory
  POP  BX              ;Save MakeStack's return address in BX
  MOV  CS:OldSS,SS     ;Save original SS
  MOV  CS:OldSP,SP     ;Save original SP
  MOV  SP,CS           ;Put our CS
  MOV  SS,SP           ;  into SS
  MOV  SP,SectorBuff   ;SP = Top of Stack
  PUSH BX              ;Restore MakeStack's return address to stack
  MOV  BX,CS:TempBX    ;Restore BX from memory
M90:                   ;Done
  PUSH CS:TempFlags    ;Restore
  POPF                 ;  Flags
  STI                  ;Enable interrupts
  RET

ReturnStack:
  CLI                ;Disable interrupts
  PUSHF              ;Save
  POP  CS:TempFlags  ;  Flags
  DEC  CS:StackInUse ;Decrement number-of-calls counter
  JNZ >R90           ;If sack is still in use, quit
  MOV  CS:TempBX,BX  ;Save BX in memory
  POP  BX            ;Save MakeStack's return address in BX
  MOV  SS,CS:OldSS   ;Restore original SS
  MOV  SP,CS:OldSP   ;Restore original SP
  PUSH BX            ;Restore MakeStack's return address to stack
  MOV  BX,CS:TempBX  ;Restore BX from memory
R90:                 ;Done
  PUSH CS:TempFlags  ;Restore
  POPF               ;  Flags
  STI                ;Enable interrupts
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SPACE FOR OUR TSR STACK
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

  EVEN 16
  DB (StackSize/8) DUP ('TSRStack')


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SPACE FOR TSR BUFFERS THAT HAVE A VARIABLE SIZE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;NOTE: SectorBuff must be large enough to contain and entire sector from
;        the largest possibility in DOS (LOLBytesPerSect from the
;        List of Lists).  Our various data tables will be placed after
;        the Sector Buffer, and they must all be initialized to all zeroes.
;        We don't know how big any of the buffers (even SectorBuff) needs to
;        be until we start running the program, so we need to leave ourselves
;        a bunch of space that we may never use (SectorBuff will almost always
;        be 512 bytes, but we need to allow for the possiblity of up to
;        8192 bytes).

SectorBuff:
  DB (DefSectorSize/16) DUP ('Sector Data Buff')
  DB (MaxSectorSize-DefSectorSize) DUP (0)

  DB (MaxDevices*DeviceInfoSize) DUP (0) ;Space for Device Info Table
  DB (MaxDisks  *DiskInfoSize  ) DUP (0) ;Space for Disk Info Table
  DB (MaxDrives *DriveInfoSize ) DUP (0) ;Space for Drive Info Table


;ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
;ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;DATA NEEDED TO INSTALL/UPDATE/SHOW STATUS (NOT NEEDED DIRECTLY IN TSR)
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;==============================================================================
;TSR Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Table of Interrupt Numbers that the TSR Intercepts
  ;First byte of each entry is the Interrupt Number
  ;Second word is the Pointer to our Interrupt Handler Code Header
  ;----------------------------------------------------------------------------
  IntNumTable:
    DB 2Fh       ;TSR Multiplex
     DW Int2FHdr
    DB 26h       ;Absolute Disk Write
     DW Int26Hdr
    DB 25h       ;Absolute Disk Read
     DW Int25Hdr
    DB 13h       ;Disk BIOS
     DW Int13Hdr
    DB 08h       ;Timer Tick
     DW Int08Hdr
    DB 0         ;End of Table

  ;----------------------------------------------------------------------------
  ;Data needed to install as a TSR, Hooking into the Multiplex Int
  ;----------------------------------------------------------------------------
  FirstHandle DB 0 ;First available user handle for Int 2Fh

  ;----------------------------------------------------------------------------
  ;Pointer to last byte of TSR
  ;----------------------------------------------------------------------------
  LastTSRByteOffset DW ?


;==============================================================================
;Drive/Device Driver Related
;==============================================================================
  EVEN 2
  NULDvcHeader DD ? ;Memory Address of NUL Device Header
                    ;  (Always the first Device in the Driver Chain)
  FirstDPBPtr  DD ? ;Pointer to first Drive Parameter Block
  NumAvailDrv  DB ? ;Number of Available Drive Letters (LASTDRIVE)
  FirstDrive   DB 2 ;First Drive Letter to use (A:=0, Default = C:)


;==============================================================================
;Miscellaneous
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Miscellaneous Yes/No flags (individual bits)
  ;----------------------------------------------------------------------------
  ProgFlags        DB 00h ;Yes/No Test bits #1
    Help          EQU 01h ;User wants help?
    Uninstall     EQU 02h ;Uninstall resident program?
    InMemory      EQU 04h ;Already installed in memory?
    UseLowMemory  EQU 08h ;User does not want us in High Memory
    MemoryMoved   EQU 10h ;TSR Memory has been moved by our Auto-Code
    FoundSuptFile EQU 20h ;Found Support File in the Path

  ProgFlags2   DB 00h ;Yes/No Test bits #2
    DoEnvir   EQU 01h ;Parsing/Testing Environment variable
    DoStdIn   EQU 02h ;Parsing/Testing StdIn buffer
    WriteBuff EQU 10h ;Write contents of Segment Buffer
    Inquiry   EQU 20h ;Display SCSI Inquiry Data

  StatusFlags    DB 00h ;Yes/No Test bits #2
    Report      EQU 01h ;Show HID Report Data
    Status      EQU 02h ;Show Program/Disk Status
    Descriptors EQU 04h ;Show Device/Config Descriptors Data
    Reset       EQU 08h ;Do a Hardware Reset
    BadDevices  EQU 10h ;Print Bad Device Table
    Alias       EQU 20h ;Write the Alias List to the Screen
    ErrLvl      EQU 40h ;Write ErrorLevel Table
    DrvStatus   EQU 80h ;Show Drives Status

  ;----------------------------------------------------------------------------
  ;Miscellaneous Strings we need to write to the screen
  ;----------------------------------------------------------------------------
  HexString: DB '0000',0
  CrLfMsg:   DB CR,LF,0
  SingleMsg: DB ' '
  NoMsg:     DB 0
  Space4Msg: DB ' '
  Space3Msg: DB ' '
  Space2Msg: DB ' '
  SpaceMsg:  DB ' ',0


;==============================================================================
;Pause Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings and Data needed to Pause the screen
  ;----------------------------------------------------------------------------
  PauseMsg:
    DB CR,LF
    DB ' MORE   (Esc stops Pausing, Ctrl-C stops Completely, any other Continues)',CR,0
  PauseNMsg:
    DB ' MORE                                                                    ',CR,LF,0
  PauseDMsg:
    DB '                                                                               ',CR,0
  PauseRows       DW ? ;Number of rows per screen
  PauseHeaderPtr  DW 1 ;Pointer to Header Message (start with a fake one <> 0)
  PauseHeaderSize DW 2 ;Number of lines in the Header Message
  PauseRowCount   DW 2 ;Current Row Counter


;==============================================================================
;DOS Environment Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Variables to search for our Environment Variable
  ;----------------------------------------------------------------------------
  EnvVarString:  DB 'USBDRIVE='    ;Environment Variable String
  EnvVarSize    EQU $-EnvVarString ;Length of String
  EnvVarPointer  DW -1             ;Pointer to Program Environment Variable

  ;----------------------------------------------------------------------------
  ;Variables to search for an extended Command Line String
  ;This should only be valid/needed if the Command Line Size (PSP:[80h]) is 7Eh
  ;----------------------------------------------------------------------------
  CmdLineVarString:  DB 'CMDLINE='         ;Environment Variable String
  CmdLineVarSize    EQU $-CmdLineVarString ;Length of String
  CmdLineVarPointer  DW -1                 ;Pointer to Program Environment Variable


;==============================================================================
;EXEC Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Size of our program stack (in bytes)
  ;----------------------------------------------------------------------------
  ProgStackSize EQU 512

  ;----------------------------------------------------------------------------
  ;Variables to Locate and Run another Program (EXEC Child Program)
  ;----------------------------------------------------------------------------
  PathToUse:      DB MaxPathSize DUP (0) ;Path to Use
  OurPathPointer  DW -1                  ;Pointer to our Path String
  CurrentPath:    DB  0                  ;Current Path (Zero-Length ASCIIZ)
  PathVarPointer  DW -1                  ;Pointer to PATH Environment Variable
  SupportFile:    DB 'USBSUPT1.COM',0    ;Support File Name to Look for
  PathVarString1: DB 'PATH='             ;PATH Environment String Header (DOS)
  PathVarString2: DB 'Path='             ;PATH Environment String Header (NT?)
  PathVarSize    EQU $-PathVarString2    ;Length of String

  ;----------------------------------------------------------------------------
  ;Variables needed to do EXEC Call
  ;----------------------------------------------------------------------------
  CmdTailSize DB CmdTailMax-2           ;Length of command tail (Maximize it)
  CmdTail:    DB CmdTailMax DUP (CR)    ;Command Tail for EXEC Call
  ParamBlock: DB ParamBlockSize DUP (?) ;Parameter Block for EXEC Call
  FCB1:       DB FCBSize DUP (?)        ;File Control Block #1
  FCB2:       DB FCBSize DUP (?)        ;File Control Block #2
  OldSPExec   DW ?                      ;SP may be destroyed by EXEC Call

  ;----------------------------------------------------------------------------
  ;Strings needed to write Descriptor Header Information to the screen
  ;----------------------------------------------------------------------------
  HostIndexMsg:  DB 'USB HOST INDEX: ',0
  DvcAddressMsg: DB 'DEVICE ADDRESS: ',0

  ;----------------------------------------------------------------------------
  ;Strings needed to set up Command Tail for Exec Calls
  ;----------------------------------------------------------------------------
  ReportDescrMsg:     DB 'ReportDescriptor '
  ReportDescrMsgAddr: DB 'xxxx:xxxx '
  ReportDescrCallBk:  DB 'xxxx:xxxx'
                      DB  0

  DescriptorMsg:     DB 'Descriptor '
  DescriptorMsgAddr: DB 'xxxx:xxxx '
  DescriptorMsgHost: DB 'xxh '
  DescriptorMsgDvc:  DB 'xxh '
  DescriptorCallBk:  DB 'xxxx:xxxx'
                     DB  0

  TDStatusMsg:    DB 'TDStatusCode '
  TDStatusCode:   DB 'xxxxh '
  TDStatusCallBk: DB 'xxxx:xxxx'
                  DB 0

  Int14ErrMsg:    DB 'Int14ErrorCode '
  Int14ErrCode:   DB 'xxxxh '
  Int14ErrCallBk: DB 'xxxx:xxxx'
                  DB 0

  ;----------------------------------------------------------------------------
  ;Error Message for when the Support File is not found
  ;----------------------------------------------------------------------------
  NoSuptFileMsg:
    DB 'Error! Need Support File ',0


;==============================================================================
;Help Screen Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Data needed if the User has changed the name of the program from USBKEYB
  ;----------------------------------------------------------------------------
  RealName:
    DB 'USBDRIVE',0 ;Real name of our program (MUST end in 0)
                    ;  & MUST have enough space for 8-char name
  RealNameSz DW 8   ;Size of RealName (not incl 0)

  ;----------------------------------------------------------------------------
  ;Syntax Help String (if user asks for, or otherwise needs, Help)
  ;----------------------------------------------------------------------------
  SyntaxMsgHdr:
    DB 'SYNTAX: ',0
  SyntaxMsg:
    DB '[Options]',CR,LF
    DB LF
    DB '  /?     Í Show this HELP screen',CR,LF
    DB '  /A     Í Show all ALIASES for these command line Options',CR,LF
    DB '  /E     Í Show all ERRORLEVELs (DOS Return Codes)',CR,LF
    DB '  /U     Í UNINSTALL from memory',CR,LF
    DB '  /L:Y|N Í Force installation into LOW memory (Default = No)',CR,LF
    DB LF
    DB '  /Dvcs:#  Í Support a maximum of # USB Device/Interfaces (1-8, Default = 4)',CR,LF
    DB '  /Dsks:#  Í Support a maximum of # Disk/LUNs (1-16, Default = 8)',CR,LF
    DB '  /Drvs:#  Í Support a maximum of # DOS Drive Letters (1-16, Default = 8)',CR,LF
    DB '  /Ltr:#   Í Assign drive LETTERS starting with # (C:-Z:, default = C:)',CR,LF
    DB LF
    DB '  /Dly:# Í Delay # seconds before accessing new disks (0-60, Default = 0)',CR,LF
    DB '  /T:Y|N Í Assign drive letters to FAT32 partitions (Default = Yes if DOS 7.1+)',CR,LF
    DB LF
    DB '  /X:# Í Transfer a maXimum of # sectors at a time (1-64, Default = 1)',CR,LF
    DB LF
    DB '  /R:#      Í Reset USB Device Index # (0-7)',CR,LF
    DB '  /Format # Í Low-level Format Disk # (80h-FFh)',CR,LF
    DB LF
    DB '  /S        Í Display current STATUS of program & disks',CR,LF
    DB '  /D        Í Display current status of USB DRIVES',CR,LF
    DB '  /I        Í Display INQUIRY data for all SCSI-compatible disks',CR,LF
    DB '  /C        Í Diplay CONFIGURATION (& other) descriptors of last device found',CR,LF
    DB '  /B        Í Show list of BAD (incompatible) devices found',CR,LF
    DB '  /F        Í Show contents of various buFfers in TSR',CR,LF
    DB '  /Q:#      Í Show SCSI Additional Sense Code & QUALIFIER history for disk #',CR,LF
    DB '  /Beep:Y/N Í BEEP Speaker when bad device is found (Default = Yes)'
    DB 0


;==============================================================================
;Program/Disk Status Related
;==============================================================================

  InitDelayMsg:
    DB  CR,LF
    DB  'Initialization Delay: ',0
  DOSVersionMsg:
    DB  ' seconds'
    DB  CR,LF
    DB  'DOS Version:          ',0
  MaxSectorSizeMsg:
    DB  CR,LF
    DB 'Max Bytes per Sector:',0
  MountFAT32Msg:
    DB  CR,LF
    DB 'Mount FAT32 Volumes:   ',0
  XferSectsMsg:
    DB  CR,LF
    DB 'Max Sectors per Xfer:  ',0

  StatusMsg:
    DB '   USB INFO                       DISK/LUN                        DOS DRIVE',CR,LF
    DB '   ÍÍÍÍÍÍÍÍÍ  ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ  ÍÍÍÍÍÍÍÍÍÍÍ',CR,LF
    DB ' I                  R W                                          D',CR,LF
    DB ' n  H   A  I    INT m r                                          r',CR,LF
    DB ' d  o   d  n  L 13h v P            Sect Byte                     i',CR,LF
    DB ' e  s   d  t  U Dsk M r Num   Num  Per  Per    Total    Approx   v   Approx',CR,LF
    DB ' x  t   r  f  N Num d t Head  Cyl  Cyl  Sect  Sectors  Capacity  e  Capacity',CR,LF
    DB 'ÄÄ ÄÄ ÄÄÄ ÄÄ  Ä ÄÄÄ Ä Ä ÄÄÄÄ ÄÄÄÄÄ ÄÄÄÄ ÄÄÄÄ ÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄ  ÄÄ ÄÄÄÄÄÄÄÄ',CR,LF,0
       ;15 15 127 10  0 81h Y Y   32    32   32  512 12345678h 65000 MB  D: 65000 MB

  InitializingMsg:
    DB                     '# # #####  Initializing  ######### ########',0

  UnusedDevicesMsg:
    DB 'Unused USB Dvc/Intf Indexes: ',0
  UnusedDisksMsg:
    DB 'Unused INT 13h Disk Numbers: ',0
  UnusedDrivesMsg:
    DB 'Unused DOS Drive Letters:    ',0

  Prefixes:
    DB 'kMGTPEZY' ;kilo, Mega, Giga, Tera, Peta, Exa, Zetta, Yotta

  YesMsg: DB 'Yes',0
  NoMsgS: DB ' No',0


;==============================================================================
;Drive Status Related
;==============================================================================

  DrvStatusMsg:
    DB 'D',CR,LF
    DB 'r  INT',CR,LF
    DB 'i  13h            Partition                       Byte',CR,LF
    DB 'v  Dsk ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ   Boot    Per    Total    Approx',CR,LF
    DB 'e  Num  Sector   Idx        Type         Sector   Sect  Sectors  Capacity',CR,LF
    DB 'ÄÄ ÄÄÄ ÄÄÄÄÄÄÄÄÄ ÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄ ÄÄÄÄ ÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄ',CR,LF,0
       ;D: 81h 12345678h   0 01h FAT32 ó2TB     12345678h  512 12345678h 65000 MB
  SuperFloppyMsg:
    DB        '°°°°°°°°° °°° °°° (Super)Floppy  ',0

;Write Unknown for Capacity if not DOS!

  POSStringTbl: ;Strings must be MAX 14 characters
                      ;12345678901234X
    DB POSNone,       'None',0 ;00h
    DB POSFAT12,      'FAT12 <15MB',0    ;01h
    DB POSFAT16,      'FAT16 <32MB',0    ;04h
    DB POSDOSExt,     'DOS Extended',0   ;05h
    DB POSFAT16H,     'FAT16 <2GB',0     ;06h
    DB POSFAT32,      'FAT32 <2TB',0     ;0Bh
    DB POSFAT32LBA,   'FAT32 LBA <2TB',0 ;0Ch
    DB POSLBAVFAT16H, 'FAT16 LBA <2GB',0 ;0Eh
    DB POSLBAVFATExt, 'DOS Ext LBA',0    ;0Fh
    ;Below this line are the ones we don't know how to access!
    DB POSXenixRoot,  'XENIX',0          ;02h
    DB POSXenixUsr,   'XENIX',0          ;03h
    DB POSQNX,        'HPFS, FAT64',0    ;07h
    DB POSAIXBoot,    'OS/2',0           ;08h
    DB POSAIXData,    'AIX',0            ;09h
    DB POSOS2,        'OS/2',0           ;0Ah
    DB POSOpus,       'OPUS',0           ;10h
    DB POSOS2FAT12H,  'OS/2',0           ;11h
    DB POSCompaqDiag, 'Compaq',0         ;12h
    DB POSOS2FAT16H,  'OS/2',0           ;14h
    DB POSOS2FAT16HH, 'OS/2',0           ;16h
    DB POSOS2HPFSH,   'OS/2',0           ;17h
    DB POSASTSwap,    'AST',0            ;18h
    DB POSPhoton,     'Photon',0         ;19h
    DB POSFAT32H,     'FAT32 Hide',0     ;1Bh
    DB POSFAT32HH,    'FAT32 LBA Hide',0 ;1Ch
    DB POSLBAVFATH,   'VFAT LBA Hide',0  ;1Eh
    DB POSOFS1,       'OFS1',0           ;20h
    DB POSReserv21,   'Oxygen',0         ;21h
    DB POSReserv22,   'Oxygen',0         ;22h
    DB POSNECDOS,     'NEC DOS',0        ;24h
    DB POSAlien,      'Alien NOS',0      ;32h
    DB POSOS2JFS,     'OS/2',0           ;35h
    DB POSTheos,      'Theos',0          ;38h
    DB POSPartMagic,  'PartitionMagic',0 ;3Ch
    DB POSNWHidden,   'Novell',0         ;3Dh
    DB POSVenix,      'VENIX 80286',0    ;40h
    DB POSPersRISC,   'Personal RISC',0  ;41h
    DB POSSFS,        'SFS',0            ;42h
    DB POSPTSDOS,     'PTS-DOS',0        ;43h
    DB POSGoBack,     'GoBack',0         ;44h
    DB POSEumel1,     'EUMEL',0          ;45h
    DB POSEumel2,     'EUMEL',0          ;46h
    DB POSEumel3,     'EUMEL',0          ;47h
    DB POSEumel4,     'EUMEL',0          ;48h
    DB POSAdaOS,      'AdaOS',0          ;4Ah
    DB POSOberon1,    'Oberon',0         ;4Ch
    DB POSQNX1,       'QNX',0            ;4Dh
    DB POSQNX2,       'QNX',0            ;4Eh
    DB POSQNX3,       'QNX',0            ;4Fh
    DB POSOnTrack1,   'OnTrack',0        ;50h
    DB POSOnTrack2,   'OnTrack',0        ;51h
    DB POSCPM1,       'CP/M',0           ;52h
    DB POSOnTrack3,   'OnTrack',0        ;53h
    DB POSOnTrack4,   'OnTrack',0        ;54h
    DB POSEZDrive,    'EZ-Drive',0       ;55h
    DB POSGoldenBow,  'GoldenBow',0      ;56h
    DB POSPriam,      'Priam',0          ;5Ch
    DB POSSpeedSto1,  'SpeedStore',0     ;61h
    DB POS386IX,      'Unix/386',0       ;63h
    DB POSNovell1,    'Novell',0         ;64h
    DB POSNovell2,    'Novell',0         ;65h
    DB POSNovell3,    'Novell',0         ;67h
    DB POSNovell4,    'Novell',0         ;68h
    DB POSNovell5,    'Novell',0         ;69h
    DB POSDiskSecur,  'DiskSecure',0     ;70h
    DB POSPCIX,       'PC/IX',0          ;75h
    DB POSFIX,        'F.I.X.',0         ;7Eh
    DB POSMinix1,     'Minix',0          ;80h
    DB POSMinix2,     'Minix',0          ;81h
    DB POSLinuxSwap,  'Linux',0          ;82h
    DB POSLinuxNFS,   'Linux',0          ;83h
    DB POSOS2Renum,   'OS/2',0           ;84h
    DB POSLinuxExt,   'Linux',0          ;85h
    DB POSFAT16Str,   'Windows NT',0     ;86h
    DB POSHPFSMir,    'HPFS, NTFS',0     ;87h
    DB POSAmoebaFS,   'Amoeba',0         ;93h
    DB POSAmoebaBad,  'Amoeba',0         ;94h
    DB POSDataLight,  'Datalight',0      ;98h
    DB POSMylex,      'Mylex',0          ;99h
    DB POSNoteBIOS,   'Phoenix',0        ;A0h
    DB POSFreeBSD,    'BSD',0            ;A5h
    DB POSOpenBSD,    'OpenBSD',0        ;A6h
    DB POSNeXTStep,   'NeXTStep',0       ;A7h
    DB POSNetBSD,     'NetBSD',0         ;A9h
    DB POSDarwin,     'Apple',0          ;ABh
    DB POSBSDI,       'BSDI, NTFS',0     ;B7h
    DB POSBSDISwap,   'BSDI',0           ;B8h
    DB POSSolarisBt,  'Solaris',0        ;BEh
    DB POSCTOS,       'DR-DOS',0         ;C0h
    DB POSFAT12Log,   'DR-DOS',0         ;C1h
    DB POSFAT16Log,   'DR-DOS',0         ;C4h
    DB POSDDLogin,    'DR-DOS',0         ;C6h
    DB POSSyrinx,     'Syrinx',0         ;C7h
    DB POSFAT12SMU,   'Multiuser DOS',0  ;D0h
    DB POSFAT12MU,    'Multiuser DOS',0  ;D1h
    DB POSEOSGEFAT1,  'OSG',0            ;D2h
    DB POSEOSGEFAT2,  'OSG',0            ;D3h
    DB POSFAT16MU,    'Multiuser DOS',0  ;D4h
    DB POSMUSecExt,   'Multiuser DOS',0  ;D5h
    DB POSFAT16HMU,   'Multiuser DOS',0  ;D6h
    DB POSCPM2,       'CP/M-86',0        ;D8h
    DB POSCPM3,       'Concurrent',0     ;DBh
    DB POSBootItNG,   'Boot-It NG',0     ;DFh
    DB POSFAT12XSS,   'SpeedStore',0     ;E1h
    DB POSPainke,     'XFDISK',0         ;E2h
    DB POSDOSROSD,    'Storage Dimens',0 ;E3h
    DB POSFAT16XSS,   'SpeedStore',0     ;E4h
    DB POSBeOS,       'BeOS',0           ;EBh
    DB POSGPT,        'GUID',0           ;EEh
    DB POSPARISC,     'Linux',0          ;F0h
    DB POSStorDim,    'Storage Dimens',0 ;F1h
    DB POSDOS33Sec,   'DOS Secondary',0  ;F2h
    DB POSSpeedSto2,  'SpeedStore',0     ;F4h
    DB POSPrologue,   'Prologue',0       ;F5h
    DB POSOSGEFAT3,   'OSG',0            ;F7h
    DB POSBochs,      'Bochs',0          ;FAh
    DB POSVMWareFS,   'VMWare',0         ;FBh
    DB POSVMWareSwap, 'VMWare',0         ;FCh
    DB POSLinuxRAID,  'Linux',0          ;FDh
    DB POSLANStep,    'LANstep',0        ;FEh
    DB POSXenixBad,   'Xenix',0          ;FFh

    DB -1,-1 ;End of Table

  UnknownPOSMsg:
    DB                'Unknown',0


;==============================================================================
;Buffer Related
;==============================================================================

  BufferHdr1:
    DB 'CONTENTS OF ',0
  BufferHdr2:
    DB ' BUFFER',CR,LF
    DB 'ÄÄÄÄ  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ',CR,LF,0
    ;   0000  xx xx xx xx xx xx xx xx-xx xx xx xx xx xx xx xx   xxxxxxxxxxxxxxxx

  InquiryMsg:     DB 'INQUIRY',0
  FmtCapacityMsg: DB 'FORMAT '
  CapacityMsg:    DB 'CAPACITY',0
  ModeSenseMsg:   DB 'MODE SENSE',0
  SectorMsg:      DB 'SECTOR (xxxxxxxxh)',0


;==============================================================================
;Format Related
;==============================================================================

  DiskToFormat DB 0 ;INT 13h Disk # to Low-level Format (0 = None)


;==============================================================================
;Bad Device Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings needed to print Bad Device Table to the screen
  ;----------------------------------------------------------------------------
  BadDeviceHdr:
    DB '                       BAD (INCOMPATIBLE) DISK DRIVES',CR,LF
    DB 'ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ',CR,LF
    DB '                                              SCSI REQUEST',CR,LF
    DB 'HOST DVC  INTF STAGE ERROR  ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ',CR,LF
    DB 'INDX ADDR NUM   NUM  CODE   REQ STP DAT STS CSW  RESIDUE  KEY   INFO    ASC/Q',CR,LF
    DB 'ÄÄÄÄ ÄÄÄÄ ÄÄÄÄ ÄÄÄÄÄ ÄÄÄÄÄ  ÄÄÄ ÄÄÄ ÄÄÄ ÄÄÄ ÄÄÄ ÄÄÄÄÄÄÄÄÄ ÄÄÄ ÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄ',CR,LF
    DB  0

  NoneFoundMsg:
    DB '#ÄÄ# #ÄÄ# None #ÄÄÄ# #ÄÄÄ#',CR,LF,0
  BadBeepMsg:
    DB 'Beep for Bad Disk Drives: ',0

  RequestTypeMsg:
    DB 'SCSI Request Type ',0
  SetupErrMsg:
    DB 'Setup Stage (USB) ',0
  DataStgErrMsg:
    DB 'Data Stage (USB)  ',0
  StatusStgErrMsg:
    DB 'Status Stage (USB)',0
  CSWErrMsg:
    DB 'Sts Wrapper (SCSI)',0
  SenseKeyErrMsg:
    DB 'Sense Key (SCSI)  ',0
  ASCErrMsg:
    DB "Add'l Sense (SCSI)",0

  SectorRWMsg1:
    DB ' (LBA ',0
  SectorRWMsg2:
    DB ')',0

  ;----------------------------------------------------------------------------
  ;List of SCSI Request Types where a Sector is accessed
  ;  (a Sector Number is Required)
  ;----------------------------------------------------------------------------
  SectorRWTable:
    DB SCmdReadSeq06
    DB SCmdWriteSeq06
    DB SCmdSeek06
    DB SCmdReadReverse
    DB SCmdWriteFilemarks
    DB SCmdRead10
    DB SCmdWrite10
    DB SCmdSeek10
    DB SCmdErase10
    DB SCmdReadUpdatedBlk
    DB SCmdWriteVerify10
    DB SCmdVerify10
    DB SCmdSearchDataHigh10
    DB SCmdSearchDataEqual10
    DB SCmdSearchDataLow10
    DB SCmdPreFetch
    DB SCmdMediumScan
    DB SCmdCompare
    DB SCmdCopyVerify
    DB SCmdWriteBuff
    DB SCmdReadBuff
    DB SCmdUpdateBlk
    DB SCmdReadLong
    DB SCmdWriteLong
    DB SCmdRelease10
    DB SCmdPersResvIn
    DB SCmdPersResvOut
    DB SCmdXDWriteX
    DB SCmdRead12
    DB SCmdWrite12
    DB SCmdErase12
    DB SCmdWriteVerify12
    DB SCmdVerify12
    DB SCmdSearchDataHigh12
    DB SCmdSearchDataEqual12
    DB SCmdSearchDataLow12
    DB -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;Indent needed to properly align certain status messages
  ;----------------------------------------------------------------------------
  Indent DB 0

  ;----------------------------------------------------------------------------
  ;Command Status Wrapper Error Codes
  ;----------------------------------------------------------------------------
  CSWErrTbl:
    DB 0, 'No Error',0
    DB 1, 'Failure',0
    DB 2, 'Phase Error',0
    DB 3, 'Persistent Error',0
    DB -1, -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;SCSI Command Codes
  ;----------------------------------------------------------------------------
  SCSICmdTable:
    DB SCmdTestUnitReady,     'Test Unit Ready',0
    DB SCmdRewind,            'Rewind Unit / Rezero Unit',0
    DB SCmdRequestSense,      'Request Sense Data',0
    DB SCmdFormatUnit,        'Format Unit',0
    DB SCmdReadBlockLimits,   'Read Block Size Limits',0
    DB SCmdReassignBlocks,    'Reassign Blocks / Initialize Element Status',0
    DB SCmdReadSeq06,         'Read / Get Message / Receive (6)',0
    DB SCmdWriteSeq06,        'Write / Send Message / Send / Print (6)',0
    DB SCmdSeek06,            'Seek / Slew & Print (6)',0
    DB SCmdReadReverse,       'Read Reverse',0
    DB SCmdWriteFilemarks,    'Write Filemarks / Synchronize Print Buffer',0
    DB SCmdSpace,             'Space Set Position',0
    DB SCmdInquiry,           'Inquiry',0
    DB SCmdVerifyTape,        'Verify Tape',0
    DB SCmdRecoverBuffData,   'Recover Buffered Data',0
    DB SCmdModeSelect06,      'Mode Select (6)',0
    DB SCmdReserveUnit,       'Reserve Unit',0
    DB SCmdReleaseUnit,       'Release Unit',0
    DB SCmdCopy,              'Copy',0
    DB SCmdErase,             'Erase',0
    DB SCmdModeSense06,       'Mode Sense (6)',0
    DB SCmdStartStop,         'Start / Stop / Load / Unload / Scan',0
    DB SCmdRxDiagResults,     'Receive Diagnostic Results',0
    DB SCmdSendDiagnostics,   'Send Diagnostics / Request Self-check',0
    DB SCmdSetMediaRemoval,   'Prevent / Allow Media Removal',0
    DB SCmdReadFmtCap,        'Read Format Capacities',0
    DB SCmdSetWindow,         'Set Window Parameters',0
    DB SCmdReadCapacity,      'Read Capacity / Get Window',0
    DB SCmdRead10,            'Read / Get Message (10)',0
    DB SCmdReadGeneration,    'Read Generation',0
    DB SCmdWrite10,           'Write / Send Message (10)',0
    DB SCmdSeek10,            'Seek / Locate / Position Element (10)',0
    DB SCmdErase10,           'Erase (10)',0
    DB SCmdReadUpdatedBlk,    'Read Updated Block',0
    DB SCmdWriteVerify10,     'Write & Verify (10)',0
    DB SCmdVerify10,          'Verify (10)',0
    DB SCmdSearchDataHigh10,  'Search Data High (10)',0
    DB SCmdSearchDataEqual10, 'Search Data Equal / Object Position (10)',0
    DB SCmdSearchDataLow10,   'Search Data Low (10)',0
    DB SCmdSetLimits10,       'Set Limits (10)',0
    DB SCmdPreFetch,          'Pre-Fetch / Read Position / Get Data Buffer Status',0
    DB SCmdSyncCache,         'Synchronize Cache',0
    DB SCmdLockUnlockCache,   'Lock/Unlock Cache',0
    DB SCmdReadDefects,       'Read Defect Data',0
    DB SCmdMediumScan,        'Medium Scan',0
    DB SCmdCompare,           'Compare',0
    DB SCmdCopyVerify,        'Copy & Verify',0
    DB SCmdWriteBuff,         'Write Buffer',0
    DB SCmdReadBuff,          'Read Buffer',0
    DB SCmdUpdateBlk,         'Update Block',0
    DB SCmdReadLong,          'Read Long',0
    DB SCmdWriteLong,         'Write Long',0
    DB SCmdChangeDef,         'Change Definition',0
    DB SCmdWriteSame,         'Write Same',0
    DB SCmdReadSubChan,       'Read Sub-Channel',0
    DB SCmdReadTOC,           'Read Table of Contents',0
    DB SCmdReadHdr,           'Read Header',0
    DB SCmdPlayAudio10,       'Play Audio (10)',0
    DB SCmdPlayAudioMSF,      'Play Audio MSF',0
    DB SCmdPlayAudioTrkIdx,   'Play Audio Track/Index',0
    DB SCmdPlayTrkRel10,      'Play Track Relative (10)',0
    DB SCmdPauseResume,       'Pause/Resume',0
    DB SCmdLogSelect,         'Log Select',0
    DB SCmdLogSense,          'Log Sense',0
    DB SCmdXDWrite,           'XD Write',0
    DB SCmdXPWrite,           'XP Write',0
    DB SCmdXDRead,            'XD Read',0
    DB SCmdModeSelect10,      'Mode Select (10)',0
    DB SCmdReserve10,         'Reserve (10)',0
    DB SCmdRelease10,         'Release (10)',0
    DB SCmdModeSense10,       'Mode Sense (10)',0
    DB SCmdPersResvIn,        'Persistent Reserve In',0
    DB SCmdPersResvOut,       'Persistent Reserve Out',0
    DB SCmdXDWriteX,          'XD Write Extended',0
    DB SCmdRegnerate,         'Regenerate',0
    DB SCmdReportLUNs,        'Report LUNs',0
    DB SCmdPlayAudio12,       'Play Audio / Move Medium (12)',0
    DB SCmdExchangeMedium,    'Exchange Medium',0
    DB SCmdRead12,            'Read / Get Message (12)',0
    DB SCmdPlayTrkRel12,      'Play Track Relative (12)',0
    DB SCmdWrite12,           'Write / Send Message (12)',0
    DB SCmdErase12,           'Erase (12)',0
    DB SCmdWriteVerify12,     'Write & Verify (12)',0
    DB SCmdVerify12,          'Verify (12)',0
    DB SCmdSearchDataHigh12,  'Search Data High (12)',0
    DB SCmdSearchDataEqual12, 'Search Data Equal (12)',0
    DB SCmdSearchDataLow12,   'Search Data Low (12)',0
    DB SCmdSetLimits12,       'Set Limits (12)',0
    DB SCmdReadElementSts,    'Read Element Status',0
    DB SCmdReqVolElementAddr, 'Request Volume Element Address',0
    DB SCmdSendVolTag,        'Send Volume Tag',0
    DB SCmdReadDefects12,     'Read Defect Data (12)',0
    DB -1, -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;SCSI Request Sense Keys
  ;  One of the fields returned by a SCSI Request Sense
  ;----------------------------------------------------------------------------
  SenseKeyTbl:
    DB SenseKeyNone,      'None',0
    DB SenseKeyRecover,   'Recovered Error',0
    DB SenseKeyNotReady,  'Unit Not Ready',0
    DB SenseKeyMedium,    'Medium Error',0
    DB SenseKeyHardware,  'Hardware Error (Unrecoverable)',0
    DB SenseKeyRequest,   'Illegal Request (Bad Parameter)',0
    DB SenseKeyAttention, 'Unit Attention (Target Reset)',0
    DB SenseKeyProtect,   'Data Protect',0
    DB SenseKeyBlank,     'Blank Check',0
    DB SenseKeyVendor,    'Vendor Specific',0
    DB SenseKeyCopyAbort, 'Copy Aborted',0
    DB SenseKeyCmdAbort,  'Command Aborted',0
    DB SenseKeyEqual,     'Equal (Search)',0
    DB SenseKeyOverflow,  'Volume Overflow',0
    DB SenseKeyCompare,   'Miscompare (Search)',0
    DB SenseKeyReserved,  'Reserved',0
    DB -1, -1 ;End of Table


  ;  For Persistent Failure, issue Request Sense, then try issuing
  ;    Command Block Reset before attempting a Hard Reset.

  ;----------------------------------------------------------------------------
  ;SCSI ASC/ASCQ Codes (Additional Sense Code / Qualifiers)
  ;
  ;Note: For UFI Devices ONLY, the ASC/ASCQ codes are returned by the Interrupt
  ;  EndPoint.  For all other CBI devices the interrupt returns low byte = 0,
  ;  high byte:
  ;  Bits 7-4 = Vendor-specific
  ;       3-2 = Reserved (0)
  ;       1-0 = 00 Pass
  ;             01 Fail
  ;             10 = Phase Error
  ;             11 = Persistent Failure
  ;
  ;This table only includes ASC/Q codes that are listed in the SCSI-2 spec
  ;  as applying to Disk-type devices (DASD, WORM, CD-ROM, Tape, etc.).
  ;If we end up creating a separate "SCSISPT1" program, we'll need to add
  ;  back in the ones that we took out (that aplly only to Procesors,
  ;  Scanners, Printers, etc.) and should probably also add SCSI-3 additions.
  ;----------------------------------------------------------------------------
  ASCQTable:  ;Format = ASC in High Byte, ASCQ in Low Byte
              ;         (backwards from the way it is normally sent)
    DW 0000h
       DB 'No Additional Sense Information',0
    DW 0006h
       DB 'I/O Process Terminated',0
    DW 0011h
       DB 'Audio Play Operation in Progress',0
    DW 0012h
       DB 'Audio Play Operation Paused',0
    DW 0013h
       DB 'Audio Play Operation Successfully Completed',0
    DW 0014h
       DB 'Audio Play Operation Stopped Due to Error',0
    DW 0015h
       DB 'No Current Audio Status to Return',0
    DW 0100h
       DB 'No Index / Sector Signal',0
    DW 0200h
       DB 'No Seek Complete',0
    DW 0300h
       DB 'Peripheral Device Write Fault',0
    DW 0301h
       DB 'No Write Current',0
    DW 0302h
       DB 'Excessive Write Errors',0
    DW 0400h
       DB 'Logical Unit Not Ready, Cause Not Reportable',0
    DW 0401h
       DB 'Logical Unit in Process of Becoming Ready',0
    DW 0402h
       DB 'Logical Unit Not Ready, Initialize Required',0
    DW 0403h
       DB 'Logical Unit Not Ready, Need Manual Intervention',0
    DW 0404h
       DB 'Logical Unit Not Ready, Format in Progress',0
    DW 04FFh
       DB 'Logical Unit Not Ready, Device is Busy',0
    DW 0500h
       DB 'Logical Unit Does Not Respond to Selection',0
    DW 0600h
       DB 'Reference Position Not Found',0
    DW 0700h
       DB 'Multiple Peripheral Devices Selected',0
    DW 0800h
       DB 'Logical Unit Communication Failure',0
    DW 0801h
       DB 'Logical Unit Communication Time-out',0
    DW 0802h
       DB 'Logical Unit Communication Parity Error',0
    DW 0880h
       DB 'Logical Unit Communication Overrun',0
    DW 0900h
       DB 'Track Following Error',0
    DW 0901h
       DB 'Tracking Servo Failure',0
    DW 0902h
       DB 'Focus Servo Failure',0
    DW 0903h
       DB 'Spindle Servo Failure',0
    DW 0A00h
       DB 'Error Log Overflow',0
    DW 0C00h
       DB 'Write Error',0
    DW 0C01h
       DB 'Write Error Recovered w/ Auto Reallocation',0
    DW 0C02h
       DB 'Write Error Auto Reallocation Failed',0
    DW 1000h
       DB 'ID CRC or ECC Error',0
    DW 1100h
       DB 'Unrecovered Read Error',0
    DW 1101h
       DB 'Read Retries Exhausted',0
    DW 1102h
       DB 'Error Too Long to Correct',0
    DW 1103h
       DB 'Multiple Read Errors',0
    DW 1104h
       DB 'Unrecovered Read Error - Auto Reallocate Failed',0
    DW 1105h
       DB 'L-EC Uncorrectable Error',0
    DW 1106h
       DB 'CIRC Unrecovered Error',0
    DW 1107h
       DB 'Data Resynchronization Error',0
    DW 1108h
       DB 'Incomplete Block Read',0
    DW 1109h
       DB 'No Gap Found',0
    DW 110Ah
       DB 'Miscorrected Error',0
    DW 110Bh
       DB 'Unrecovered Read Error - Recommend Reassignment',0
    DW 110Ch
       DB 'Unrecovered Read Error - Recommend Data Re-Write',0
    DW 1200h
       DB 'Address Mark Not Found for ID Field',0
    DW 1300h
       DB 'Address Mark Not Found for Data Field',0
    DW 1400h
       DB 'Recorded Entity Not Found',0
    DW 1401h
       DB 'Record Not Found',0
    DW 1402h
       DB 'Filemark or Setmark Not Found',0
    DW 1403h
       DB 'End-of-Data Not Found',0
    DW 1404h
       DB 'Block Sequence Error',0
    DW 1500h
       DB 'Random Positioning Error',0
    DW 1501h
       DB 'Mechanical Positioning Error',0
    DW 1502h
       DB 'Positioning Error Detected by Read of Medium',0
    DW 1600h
       DB 'Data Synchronization Mark Error',0
    DW 1700h
       DB 'Recovered Data w/ No ECC Applied',0
    DW 1701h
       DB 'Recovered Data w/ Retries',0
    DW 1702h
       DB 'Recovered Data w/ Positive Head Offset',0
    DW 1703h
       DB 'Recovered Data w/ Negative Head Offset',0
    DW 1704h
       DB 'Recovered Data w/ Retries and/or CIRC Applied',0
    DW 1705h
       DB 'Recovered Data Using Previous Sector ID',0
    DW 1706h
       DB 'Recovered Data w/ No ECC - Data Auto Reallocated',0
    DW 1707h
       DB 'Recovered Data w/ No ECC - Recommend Reassignment',0
    DW 1708h
       DB 'Recovered Data w/ No ECC - Recommend Re-Write',0
    DW 1800h
       DB 'Recovered Data w/ ECC',0
    DW 1801h
       DB 'Recovered Data w/ ECC & Retries',0
    DW 1802h
       DB 'Recovered Data - Data Auto-Reallocated',0
    DW 1803h
       DB 'Recovered Data w/ CIRC',0
    DW 1804h
       DB 'Recovered Data w/ LEC',0
    DW 1805h
       DB 'Recovered Data - Recommend Reassignment',0
    DW 1806h
       DB 'Recovered Data - Recommend Re-Write',0
    DW 1900h
       DB 'Defect List Error',0
    DW 1901h
       DB 'Defect List Not Available',0
    DW 1902h
       DB 'Defect List Error in Primary List',0
    DW 1903h
       DB 'Defect List Error in Grown List',0
    DW 1A00h
       DB 'Parameter List Length Error',0
    DW 1B00h
       DB 'Synchronous Data Transfer Error',0
    DW 1C00h
       DB 'Defect List Not Found',0
    DW 1C01h
       DB 'Primary Defect List Not Found',0
    DW 1C02h
       DB 'Grown Defect List Not Found',0
    DW 1D00h
       DB 'Miscompare During Verify Operation',0
    DW 1E00h
       DB 'Recovered ID w/ ECC',0
    DW 2000h
       DB 'Invalid Command Operation Code',0
    DW 2100h
       DB 'Logical Block Address Out of Range',0
    DW 2200h
       DB 'Illegal Function (should use 20 00, 24 00, 26 00)',0
    DW 2400h
       DB 'Invalid Field in CDB',0
    DW 2500h
       DB 'Logical Unit Not Supported',0
    DW 2600h
       DB 'Invalid Field in Parameter List',0
    DW 2601h
       DB 'Parameter Not Supported',0
    DW 2602h
       DB 'Parameter Value Invalid',0
    DW 2603h
       DB 'Threshold Parameters Not Supported',0
    DW 2700h
       DB 'Write Protected',0
    DW 2800h
       DB 'Not Ready to Ready Transition, Medium Change',0
    DW 2900h
       DB 'Power on, Reset, or Bus Device Reset Occurred',0
    DW 2A00h
       DB 'Parameters Changed',0
    DW 2A01h
       DB 'Mode Parameters Changed',0
    DW 2A02h
       DB 'Log Parameters Changed',0
    DW 2B00h
       DB 'Copy Cannot Execute Since Host Cannot Disconnect',0
    DW 2C00h
       DB 'Command Sequence Error',0
    DW 2D00h
       DB 'Overwrite Error on Update in Place',0
    DW 2F00h
       DB 'Command(s) Cleared by Another Initiator',0
    DW 3000h
       DB 'Incompatible Medium Installed',0
    DW 3001h
       DB 'Cannot Read Medium - Unknown Format',0
    DW 3002h
       DB 'Cannot Read Medium - Incompatible Format',0
    DW 3003h
       DB 'Cleaning Cartridge Installed',0
    DW 3100h
       DB 'Medium Format Corrupted',0
    DW 3101h
       DB 'Format Command Failed',0
    DW 3200h
       DB 'No Defect Spare Location Available',0
    DW 3201h
       DB 'Defect List Update Failure',0
    DW 3300h
       DB 'Tape Length Error',0
    DW 3700h
       DB 'Rounded Parameter',0
    DW 3900h
       DB 'Saving Parameters Not Supported',0
    DW 3A00h
       DB 'Medium Not Present',0
    DW 3B00h
       DB 'Sequential Positioning Error',0
    DW 3B01h
       DB 'Tape Position Error at Beginning-of-Medium',0
    DW 3B02h
       DB 'Tape Position Error at End-of-Medium',0
    DW 3B08h
       DB 'Reposition Error',0
    DW 3D00h
       DB 'Invalid Bits in Identify Message',0
    DW 3E00h
       DB 'Logical Unit Has Not Self-Configured Yet',0
    DW 3F00h
       DB 'Target Operating Conditions Have Changed',0
    DW 3F01h
       DB 'Microcode Has Been Changed',0
    DW 3F02h
       DB 'Changed Operating Definition',0
    DW 3F03h
       DB 'Inquiry Data Has Changed',0
    DW 4000h
       DB 'RAM Failure (should use 40 NN)',0
;    DW 40NNh
;       DB 'Diagnostic Failure on Component NN (80h-FFh)',0
    DW 4100h
       DB 'Data Path Failure (should use 40 NN)',0
    DW 4200h
       DB 'Power-On or Self-Test Failure (should use 40 NN)',0
    DW 4300h
       DB 'Message Error',0
    DW 4400h
       DB 'Internal Target Failure',0
    DW 4500h
       DB 'Select or Re-select Failure',0
    DW 4600h
       DB 'Unsuccessful Soft Reset',0
    DW 4700h
       DB 'SCSI Parity Error',0
    DW 4800h
       DB 'Initiator Detected Error Message Received',0
    DW 4900h
       DB 'Invalid Message Error',0
    DW 4A00h
       DB 'Command Phase Error',0
    DW 4B00h
       DB 'Data Phase Error',0
    DW 4C00h
       DB 'Logical Unit Failed Self-Configuration',0
    DW 4E00h
       DB 'Overlapped Commands Attempted',0
    DW 5000h
       DB 'Write Append Error',0
    DW 5001h
       DB 'Write Append Position Error',0
    DW 5002h
       DB 'Position Error Related to Timing',0
    DW 5100h
       DB 'Erase Failure',0
    DW 5200h
       DB 'Cartridge Fault',0
    DW 5300h
       DB 'Media Load or Eject Failed',0
    DW 5301h
       DB 'Unload Tape Failure',0
    DW 5302h
       DB 'Medium Removal Prevented',0
    DW 5400h
       DB 'SCSI/USB to Host System Interface Failure',0
    DW 5500h
       DB 'System Resource Failure',0
    DW 5700h
       DB 'Unable to Recover Table-of-Contents',0
    DW 5800h
       DB 'Generation Does Not Exist',0
    DW 5900h
       DB 'Updated Block Read',0
    DW 5A00h
       DB 'Operator Request or State Change Input Unspecified',0
    DW 5A01h
       DB 'Operator Medium Removal Request',0
    DW 5A02h
       DB 'Operator Selected Write Protect',0
    DW 5A03h
       DB 'Operator Selected Write Permit',0
    DW 5B00h
       DB 'Log Exception',0
    DW 5B01h
       DB 'Threshold Condition Met',0
    DW 5B02h
       DB 'Log Counter at Maximum',0
    DW 5B03h
       DB 'Log List Codes Exhausted',0
    DW 5C00h
       DB 'RPL Status Change',0
    DW 5C01h
       DB 'Spindles Synchronize',0
    DW 5C02h
       DB 'Spindles Not Synchronized',0
    DW 6300h
       DB 'End of User Area Encountered on This Track',0
    DW 6400h
       DB 'Illegal Mode for This Track',0
    DW 8000h
       DB 'Insufficient Resources',0

    DW -1     ;End of Table
       DB -1


;==============================================================================
;ErrorLevel Related
;==============================================================================

  ;------------------------------------------------------------------------------
  ;ErrorLevels, and Table for ErrorLevel Description Strings
  ;------------------------------------------------------------------------------
  ErLvlOption   EQU  1 ;Bad Option on the command line
  ErLvlMemory   EQU  2 ;Memory problem with the computer
  ErLvlUninst   EQU  3 ;Not in memory yet, can't Uninstall
  ErLvlStatus   EQU  4 ;Not in memory yet, can't show Status
  ErLvlVersion  EQU  5 ;Another version of the program already installed
  ErLvlDOSVer   EQU  6 ;DOS Version too old
  ErLvlStdIn    EQU  7 ;StdIn file too big
  ErLvlBadCPU   EQU  8 ;Incompatible CPU
  ErLvlNoHost   EQU  9 ;No USB Host Driver installed
  ErLvlHostInit EQU 10 ;Error while trying to initialize host
  ErLvlNoData   EQU 11 ;No Report/Descriptor Data to Print
  ErLvlSuptFile EQU 12 ;Could not Find Support File
  ErLvlNoDevice EQU 13 ;No Devices installed, can't show Raw Data
  ErLvlCurrDrv  EQU 14 ;Can't Uninstall if a USB Drive is current
  ErLvlFormat   EQU 15 ;Unable to Format Disk


  ErrLvlHdr:
    DB  CR,LF
    DB '                      ERRORLEVELS (DOS RETURN CODES)',CR,LF
    DB '  ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ',CR,LF
    DB '   0 No Error.',CR,LF
    DB 0

  ErrLvlTbl:
    DB ErLvlOption
       DB "Bad Command-line Option.",0
    DB ErLvlMemory
       DB "Memory problem with the computer.",0
    DB ErLvlUninst
       DB "USBDRIVE is not installed in memory yet -- can't Uninstall.",0
    DB ErLvlStatus
       NoStatusMsg:
       DB "USBDRIVE is not installed in memory yet -- can't show Status.",0
    DB ErLvlVersion
       DB "A different version of USBDRIVE is already installed in memory.",0
    DB ErLvlDOSVer
       DOSVerMsg:
       DB "DOS must be at least version 4.00.",0
    DB ErLvlStdIn
       StdInTooBigMsg:
       DB "The Redirected Input Option File (USBDRIVE < InFile) is too big.",0
    DB ErLvlBadCPU
       BadCPUMsg:
       DB "This program requires at least an 80386 CPU.",0
    DB ErLvlNoHost
       DB "Could not find a compatible USB Host Driver in memory.",0
    DB ErLvlHostInit
       HostInitErrMsg:
       DB "Could not properly initialize the USB Host Driver.",0
    DB ErLvlNoData
       DB "There is no Configuration Descriptor data to write.",0
    DB ErLvlSuptFile
       DB "Could not find the required USBSUPT1.COM support file.",0
    DB ErLvlNoDevice
       DB "No Disk Drive is available to show the Raw Data for.",0
    DB ErLvlCurrDrv
       CurrDrvErrMsg:
       DB "Cannot Uninstall if the current DOS drive is on a USB bus.",0
    DB ErLvlFormat
       FormatErrMsg:
       DB "Unable to Low-level Format Disk.",0

    DB -1,-1 ;End of Table


;==============================================================================
;Alias Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings needed to print Command Line Aliases to the screen
  ;----------------------------------------------------------------------------
  AliasHdrMsg:
    DB '                       ALIASES FOR COMMAND-LINE OPTIONS',CR,LF
    DB 'ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ',CR,LF
    DB 0

  YesNoHdrMsg:
    DB '       ALIASES FOR YES & NO',CR,LF
    DB 'ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ',CR,LF
    DB 0

  ;----------------------------------------------------------------------------
  ;Table needed to temporarily store Aliases.
  ;They are originally sorted in reverse alphabetical order.
  ;To write them in forward alphabetical order, we temporarily store
  ;  the String Pointers, in the original reverse order, in this table.
  ;  We then write the strings, starting with the last entry in this table
  ;  and moving backwards.
  ;The number of entries in this table must be AT LEAST as big as the largest
  ;  number of Aliases for a single command Option.  Most Options don't have
  ;  more than a dozen or so Aliases.
  ;----------------------------------------------------------------------------
  AliasSortTbl: DW 50 DUP (?) ;Table to store Alias Strings (to reverse order)


;==============================================================================
;Additional Sense Code & Qualifier Hostory Related
;==============================================================================

  ASCQHistoryDsk DB -1 ;Disk Number to Get ASC/Q History for

  ASCQHistoryHdr1:
    DB '  SCSI ADDITIONAL SENSE CODE & QUALIFIER HISTORY FOR INT 13h DISK NUMBER ',0
  ASCQHistoryHdr2:
    DB CR,LF
    DB 'ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ',CR,LF,0

  NoASCQHistoryMsg: DB 'No History available for this disk',0

  SCSIReqMsg:  DB 'SCSI Request   ',0
  SenseKeyMsg: DB '  Sense Key    ',0
  ASCQMsg:     DB '  ASC/Q Code ',0
  SpEqualsMsg: DB ' = ',0


;==============================================================================
;Inquiry Related
;==============================================================================

  InqFmtStruc:
    DB (TYPE I13SCSIStruc) DUP (0) ;Inquiry/Format Request Structure

  InquiryHdr:
    DB '  INQUIRY RESPONSES FROM COMPATIBLE SCSI DISKS',CR,LF
    DB 'ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ',CR,LF
    DB  LF
    DB 'DSK                                 ANSI    DATA',CR,LF
    DB 'NUM  VENDOR      PRODUCT      REV  VERSION FORMAT',CR,LF
    DB 'ÄÄÄ ÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ ÄÄÄÄ ÄÄÄÄÄÄÄ ÄÄÄÄÄÄ',CR,LF
    DB  0
  InquiryNoneMsg:
    DB '### ###  No compatible SCSI Disks Found  # ######',0

  ANSIVersionTbl:
    DB 00, 'ANSI?  ',0
    DB 01, 'SCSI-1 ',0
    DB 02, 'SCSI-2 ',0
    DW -1 ;End of Table
  UnknownMsg:
    DB     'Unknown',0

  DataFormatTbl:
    DB 00, 'SCSI-1',0
    DB 01, 'Common',0
    DB 02, 'SCSI-2',0
    DW -1 ;End of Table (Legacy)
  LegacyMsg:
    DB     'Legacy',0


;==============================================================================
;Command-line (Parsing) Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Extra Memory Segment (used to store compressed contents of STDIN)
  ;----------------------------------------------------------------------------
  ExtraMemSegment DW ?

  ;----------------------------------------------------------------------------
  ;Data needed to Parse the command line for Options
  ;----------------------------------------------------------------------------
  ParseTest  DB Yes ;Testing the command for errors?
  ParseError DB  No ;Error while Parsing Command Line?

  ;----------------------------------------------------------------------------
  ;Various Parsing-related messages we may need to print to the screen
  ;----------------------------------------------------------------------------
  ParseCmdMsg:
    DB 'Error in the command-line Options for USBDRIVE:',0
  ParseEnvMsg:
    DB 'Error in the Environment variable "USBDRIVE":',0
  ParseStdInMsg:
    DB 'Error in the redirected input file ("USBDRIVE < {FileName}"):',0
  ParseErrMsg:
    DB '^ Error',CR,LF,LF,0
  ParseEnvMsg2:
    DB 'Reset the Environment variable (type "SET USBDRIVE=") and then',CR,LF
  ParseErrMsg2:
    DB 'Type "USBDRIVE ?" for Help.',CR,LF,0

  Copyright:
    DB "USBDRIVE 0.18, (C) 2007-2009, Bret E. Johnson.",CR,LF
    DB "DOS Driver for up to 8 SCSI-compatible USB Mass Storage Devices.",CR,LF
    DB  LF,0
  EnvMsg:
    DB 'Environment: ',0
  InstallMsg1:
    DB 'USBDRIVE has been ',0
  InstallMsgAuto:
    DB 'automatically ',0
  InstallMsgHigh:
    DB 'installed into Upper Memory.',0
  InstallMsgHole:
    DB 'installed into a Low Memory "Hole".',0
  InstallMsgNorm:
    DB 'installed into Low Memory.',0
  InstallMsgLast:
    DB CR,LF
    DB 'Type "USBDRIVE U" to Uninstall USBDRIVE from memory.',CR,LF,0
  NoHostMsg:
    DB 'There must be a compatible USB Host Driver installed in memory',CR,LF
    DB '  (something like USBUHCI.COM) before this program can be installed.',0
  NoEnvironMsg:
    DB 'There is no DOS Environment.',CR,LF
    DB 'There is something WIERD going on here!',0
  ExtraMemoryMsg:
    DB 'There is not enough available memory to run this program!',0
  WrongVerMsg:
    DB 'Another version of USBDRIVE was found in memory.',CR,LF
    DB 'Please UNINSTALL the other version before continuing.',0
  NoDescrDataMsg:
    DB 'There is no Descriptor Data to Write!',0
  NoSuptFileMsg1:
    DB 'Support File ',0
  NoSuptFileMsg2:
    DB ' could not be found.',0
  ResettingMsg:
    DB 'Resetting the USB Disks (this may take several seconds) ...',0
  UninstallMsg:
    DB 'USBDRIVE has been Uninstalled from memory.',CR,LF,0
  NoUninstallMsg:
    DB 'Unable to Uninstall USBDRIVE from memory.',CR,LF
    DB "Remove any TSR's installed after USBDRIVE and try again.",0
  UninstallErrMsg:
    DB "Can't find USBDRIVE in memory.",CR,LF
    DB 'You must install it before it can be Uninstalled.',0
  UpdateMsg:
    DB 'Resident USBDRIVE has been updated with new information.',0
  FirstDriveMsg:
    DB 'First USB Drive attached will be designated as ',0

  BadDvcErrMsg:
    DB 'Bad Device',0
  ReportErrMsg:
    DB 'Report '
  DescrErrMsg:
    DB 'Descriptor',0
  DataErrMsg:
    DB ' Data is not available until after',CR,LF
    DB '  USBDRIVE has been installed into memory.',0
  NoneMsg:
    DB 'None',0

  FormatMsg0:
    DB 'You are about to Low-level Format Disk ',0
  FormatMsg00:
    DB '.',CR,LF,LF
    DB 'This will COMPLETELY DESTROY any data that may be on the disk.',CR,LF
    DB LF
    DB 'Are you ABSOLUTELY SURE that you want to continue? ',0

  ;----------------------------------------------------------------------------
  ;Strings needed to Format a Drive
  ;----------------------------------------------------------------------------
  FormatMsg1:
    DB 'Formatting Disk ',0
  FormatMsg2:
    DB ' (this may take several minutes) ...',0
  FormatDoneMsg:
    DB  CR,LF,LF
    DB 'Format Complete.',0


  ;----------------------------------------------------------------------------
  ;Strings needed to write the Command-line error message
  ;----------------------------------------------------------------------------
  MoreLeftMsg:   DB '<<-More}  ',0
  MoreRightMsg:  DB '  {More->>',0
  MoreMsgSize   EQU $-MoreRightMsg

  ;----------------------------------------------------------------------------
  ;Command Line Options with no single-character equivalents
  ;These must be in the same numerical order that we want the
  ;  Alias Option to Sort them in!
  ;----------------------------------------------------------------------------
  OptionBeep    EQU 01h ;Beep the speaker
  OptionDelay   EQU 02h ;Delay during Drive Initialization
  OptionDevices EQU 03h ;Number of Device/Interfaced
  OptionDisks   EQU 04h ;Number of Disk/LUNs
  OptionLetter  EQU 05h ;First Drive Letter
  OptionDrives  EQU 06h ;Number of DOS Drive Letters
  OptionFormat  EQU 07h ;Low-level Format Disk

  ;----------------------------------------------------------------------------
  ;Command Line Options
  ;----------------------------------------------------------------------------
  SwitchList:
    DB 'Help',0
    DB  0, '?'
      ; ^              Beginning-of-List Marker
      ;    ^   ^        Code(s) to use

    DB 'UseLowMemory',0
    DB 'UseLowMem',0
    DB 'UseLowerMemory',0
    DB 'UseLowerMem',0
    DB 'UseLow',0
    DB  0, 'L'

    DB 'UseFAT32',0
    DB  0, 'T'

    DB 'Uninstall',0
    DB  0, 'U'

    DB 'StatusTbl',0
    DB 'StatusTable',0
    DB  0, 'S'

    DB 'Status',0
    DB  0, 'S'

    DB 'Sounds',0
    DB 'Sound',0
    DB  0, OptionBeep

    DB 'ShowStatusTbl',0
    DB 'ShowStatusTable',0
    DB 'ShowStatus',0
    DB  0, 'S'

    DB 'SectorBufferContents',0
    DB 'SectorBuffer',0
    DB 'SectorBuffContents',0
    DB 'SectorBuff',0
    DB  0, 'F'

    DB 'SCSIInquiryData',0
    DB 'SCSIInquiry',0
    DB  0, 'I'

    DB 'RstUSBDvc',0
    DB 'RstUSBDevice',0
    DB 'RstDvc',0
    DB 'RstDevice',0
    DB 'Rst',0
    DB  0, 'R'

    DB 'ResetUSBDvc',0
    DB 'ResetUSBDevice',0
    DB 'ResetDvc',0
    DB 'ResetDevice',0
    DB 'Reset',0
    DB  0, 'R'

    DB 'Remove',0
    DB  0, 'U'

    DB 'Qualifiers',0
    DB 'QualifierHistory',0
    DB 'Qualifier',0
    DB  0, 'Q'

    DB 'Partitions',0
    DB  0, OptionDrives

    DB 'Out',0
    DB  0, 'U'

    DB 'OptionAliases',0
    DB 'OptionAlias',0
    DB  0, 'A'

    DB 'NumPartitions',0
    DB  0, OptionDrives

    DB 'NumLUNs',0
    DB  0, OptionDisks

    DB 'NumIntfs',0
    DB 'NumInterfaces',0
    DB  0, OptionDevices

    DB 'NumDvcs',0
    DB  0, OptionDevices

    DB 'NumDsks',0
    DB  0, OptionDisks

    DB 'NumDrvs',0
    DB  0, OptionDrives

    DB 'NumDrives',0
    DB  0, OptionDrives

    DB 'NumDisks',0
    DB  0, OptionDisks

    DB 'NumDevices',0
    DB  0, OptionDevices

    DB 'NumberOfPartitions',0
    DB  0, OptionDrives

    DB 'NumberOfLUNs',0
    DB  0, OptionDisks

    DB 'NumberOfIntfs',0
    DB 'NumberOfInterfaces',0
    DB  0, OptionDevices

    DB 'NumberOfDvcs',0
    DB  0, OptionDevices

    DB 'NumberOfDsks',0
    DB  0, OptionDisks

    DB 'NumberOfDrvs',0
    DB  0, OptionDrives

    DB 'NumberOfDrives',0
    DB  0, OptionDrives

    DB 'NumberOfDisks',0
    DB  0, OptionDisks

    DB 'NumberOfDevices',0
    DB  0, OptionDevices

    DB 'ModeSenseBufferContents',0
    DB 'ModeSenseBuffer',0
    DB 'ModeSenseBuffContents',0
    DB 'ModeSenseBuff',0
    DB  0, 'F'

    DB 'MaxSects',0
    DB 'MaxSectors',0
    DB  0, 'X'

    DB 'MaximumSects',0
    DB 'MaximumSectors',0
    DB  0, 'X'

    DB 'LUNs',0
    DB  0, OptionDisks

    DB 'Ltrs',0
    DB 'Ltr',0
    DB  0, OptionLetter

    DB 'LowMemory',0
    DB 'LowMem',0
    DB  0, 'L'

    DB 'LowLvlFmt',0
    DB 'LowLvlFormat',0
    DB  0, OptionFormat

    DB 'LowLevelFmt',0
    DB 'LowLevelFormat',0
    DB  0, OptionFormat

    DB 'LowerMemory',0
    DB 'LowerMem',0
    DB  0, 'L'

    DB 'Low',0
    DB  0, 'L'

    DB 'Letters',0
    DB 'Letter',0
    DB  0, OptionLetter

    DB 'Intfs',0
    DB  0, OptionDevices

    DB 'IntfDescriptor',0
    DB 'IntfDescr',0
    DB  0, 'C'

    DB 'Interfaces',0
    DB  0, OptionDevices

    DB 'InterfaceDescriptor',0
    DB 'InterfaceDescr',0
    DB  0, 'C'

    DB 'InquiryData',0
    DB  0, 'I'

    DB 'InquiryBufferContents',0
    DB 'InquiryBuffer',0
    DB 'InquiryBuffContents',0
    DB 'InquiryBuff',0
    DB  0, 'F'

    DB 'Inquiry',0
    DB  0, 'I'

    DB 'Hlp',0
    DB  0, '?'

    DB 'H',0
    DB  0, '?'

    DB 'Format',0
    DB  0, OptionFormat

    DB 'ForceLowMemory',0
    DB 'ForceLowMem',0
    DB 'ForceLowerMemory',0
    DB 'ForceLowerMem',0
    DB 'ForceLow',0
    DB  0, 'L'

    DB 'Fmt',0
    DB  0, OptionFormat

    DB 'FirstLtr',0
    DB 'FirstLetter',0
    DB 'FirstDrvLtr',0
    DB 'FirstDrvLetter',0
    DB 'FirstDriveLtr',0
    DB 'FirstDriveLetter',0
    DB 'FirstDOSDrvLtr',0
    DB 'FirstDOSDrvLetter',0
    DB 'FirstDOSDriveLtr',0
    DB 'FirstDOSDriveLetter',0
    DB  0, OptionLetter

    DB 'FAT32',0
    DB  0, 'T'

    DB 'ErrorLvlTbl',0
    DB 'ErrorLvlTable',0
    DB 'ErrorLvls',0
    DB 'ErrorLvl',0
    DB 'ErrorLevelTbl',0
    DB 'ErrorLevelTable',0
    DB 'ErrorLevels',0
    DB 'ErrorLevel',0
    DB  0, 'E'

    DB 'ErrLvlTbl',0
    DB 'ErrLvlTable',0
    DB 'ErrLvls',0
    DB 'ErrLvl',0
    DB 'ErrLevelTbl',0
    DB 'ErrLevelTable',0
    DB 'ErrLevels',0
    DB 'ErrLevel',0
    DB  0, 'E'

    DB 'ErLvlTbl',0
    DB 'ErLvlTable',0
    DB 'ErLvls',0
    DB 'ErLvl',0
    DB 'ErLevelTbl',0
    DB 'ErLevelTable',0
    DB 'ErLevels',0
    DB 'ErLevel',0
    DB  0, 'E'

    DB 'EndPointDescriptor',0
    DB 'EndPointDescr',0
    DB 'EndPoint',0
    DB  0, 'C'

    DB 'EndPtDescriptor',0
    DB 'EndPtDescr',0
    DB 'EndPt',0
    DB  0, 'C'

    DB 'Dvcs',0
    DB  0, OptionDevices

    DB 'DvcDescriptor',0
    DB 'DvcDescr',0
    DB  0, 'C'

    DB 'Dsks',0
    DB  0, OptionDisks

    DB 'Drvs',0
    DB  0, OptionDrives

    DB 'Drives',0
    DB  0, OptionDrives

    DB 'DriveStatus',0
    DB  0, 'D'

    DB 'DriveLtrs',0
    DB 'DriveLtr',0
    DB 'DriveLetters',0
    DB 'DriveLetter',0
    DB  0, OptionLetter

    DB 'DOSDrvs',0
    DB  0, OptionDrives

    DB 'DOSDrvLtrs',0
    DB 'DOSDrvLtr',0
    DB 'DOSDrvLetters',0
    DB 'DOSDrvLetter',0
    DB  0, OptionLetter

    DB 'DOSDriveStatus',0
    DB  0, 'D'

    DB 'DOSDrives',0
    DB  0, OptionDrives

    DB 'DOSDriveLtrs',0
    DB 'DOSDriveLtr',0
    DB 'DOSDriveLetters',0
    DB 'DOSDriveLetter',0
    DB  0, OptionLetter

    DB 'Dly',0
    DB  0, OptionDelay

    DB 'Disks',0
    DB  0, OptionDisks

    DB 'Devices',0
    DB  0, OptionDevices

    DB 'DeviceDescriptor',0
    DB 'DeviceDescr',0
    DB  0, 'C'

    DB 'Descriptors',0
    DB 'Descriptor',0
    DB 'Descrs',0
    DB 'Descr',0
    DB  0, 'C'

    DB 'Delay',0
    DB  0, OptionDelay

    DB 'ConfigurationDescriptor',0
    DB 'ConfigurationDescr',0
    DB 'Configuration',0
    DB  0, 'C'

    DB 'ConfigDescriptor',0
    DB 'ConfigDescr',0
    DB 'Config',0
    DB  0, 'C'

    DB 'CommandLineAliases',0
    DB 'CommandLineAlias',0
    DB  0, 'A'

    DB 'CmdLineAliases',0
    DB 'CmdLineAlias',0
    DB  0, 'A'

    DB 'CapacityBufferContents',0
    DB 'CapacityBuffer',0
    DB 'CapacityBuffContents',0
    DB 'CapacityBuff',0
    DB  0, 'F'

    DB 'Buffers',0
    DB 'BufferContents',0
    DB 'Buffer',0
    DB 'BuffContents',0
    DB 'Buff',0
    DB  0, 'F'

    DB 'Beeps',0
    DB 'Beep',0
    DB  0, OptionBeep

    DB 'Bad',0
    DB  0, 'B'

    DB 'AssignFAT32',0
    DB  0, 'T'

    DB 'ASCQHistory',0
    DB 'ASCQ',0
    DB 'ASCHistory',0
    DB 'ASC',0
    DB  0, 'Q'

    DB 'AllowFAT32',0
    DB  0, 'T'

    DB 'Aliases',0
    DB 'Alias',0
    DB  0, 'A'

    DB 0            ;End of list


  ;----------------------------------------------------------------------------
  ;Switches for Yes/No Options
  ;----------------------------------------------------------------------------
  SwitchListYesNo:
    DB  'Yes',0
    DB   0, 'Y'

    DB  'True',0
    DB  'T',0
    DB   0, 'Y'

    DB  'On',0
    DB   0, 'Y'

    DB  'Off',0
    DB   0, 'N'

    DB  'No',0
    DB   0, 'N'

    DB  'False',0
    DB  'F',0
    DB   0, 'N'

    DB  'Enabled',0
    DB  'Enable',0
    DB   0, 'Y'

    DB  'Disabled',0
    DB  'Disable',0
    DB   0, 'N'

    DB  '1',0
    DB   0, 'Y'

    DB  '0',0
    DB   0, 'N'

    DB  0            ;End of list


  ;----------------------------------------------------------------------------
  ;TABLE OF SUBROUTINE OFFSETS TO PROCESS THE VARIOUS COMMAND LINE OPTIONS
  ;----------------------------------------------------------------------------
  SwitchTbl:
    DB  '?'
       DW DoSwitchH       ;Help
    DB  'A'
       DW DoSwitchA       ;Command Line Aliases
    DB  'B'
       DW DoSwitchB       ;Bad Device Table
    DB  'C'
       DW DoSwitchC       ;Device/Config/Interface/HID/EndPoint Descriptors
    DB  'D'
       DW DoSwitchD       ;Drive Status
    DB  'E'
       DW DoSwitchE       ;ErrorLevels
    DB  'F'
       DW DoSwitchF       ;Contents of Sector Buffer
    DB  'I'
       DW DoSwitchI       ;SCSI Inquiry Data
    DB  'L'
       DW DoSwitchL       ;Low Memory
    DB  'Q'
       DW DoSwitchQ       ;ASC/Q History
    DB  'R'
       DW DoSwitchR       ;Reset USB Device
    DB  'S'
       DW DoSwitchS       ;Status
    DB  'T'
       DW DoSwitchT       ;Allow FAT32
    DB  'U'
       DW DoSwitchU       ;Uninstall
    DB  'X'
       DW DoSwitchX       ;Maximum Sectors to Transfer

    DB  OptionBeep
       DW DoSwitchBeep    ;Beep the Speaker
    DB  OptionDelay
       DW DoSwitchDelay   ;Delay during Drive Initialization
    DB  OptionDevices
       DW DoSwitchDevices ;Number of USB Device/Interfaces
    DB  OptionDisks
       DW DoSwitchDisks   ;Number of DIsk/LUNs
    DB  OptionLetter
       DW DoSwitchLetter  ;First DOS Drive Letter to use
    DB  OptionDrives
       DW DoSwitchDrives  ;Number of DOS Drive Letters
    DB  OptionFormat
       DW DoSwitchFormat  ;Low-level Format

    DB  0                 ;End of Table


  ;----------------------------------------------------------------------------
  ;TABLE TO BE ABLE TO PRINT ALIASES FOR SwitchListYesNo
  ;----------------------------------------------------------------------------
  SwitchTblYesNo:
    DB 'N'  ;No
      DW -1
    DB 'Y'  ;Yes
      DW -1

    DB 0


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;PROGRAM CODE (NOT NEEDED IN TSR)
;Needed to initialize/update/show status of TSR, but not actually needed
;  in memory while TSR is running
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;------------------------------------------------------------------------------
;INITIALIZE/UPDATE THE PROGRAM
;Inputs:
;Outputs: Lots of Stuff
;Changes: Everything
;------------------------------------------------------------------------------
Main:
  CLD                          ;Go forward with string functions
  MOV  SP,LastProgByte         ;Reset Stack Pointer
  CALL ResizeMemory            ;Resize our Memory Allocation
  CALL CopyNameToMCB           ;Copy our Program name to the MCB
  CALL SetupPauseNoHdr         ;Set up the Pause
  MOV  DX,Copyright            ;Write the
  CALL WriteZPause             ;  Copyright message
  CALL SetupExtraMem           ;Set up the Extra Memory Segment (Quits if Err)
  CALL TestMemory              ;See if we're already installed in memory
                               ;QUIT if another version is installed
                               ;Returns ES = TSR data area (if already installed)
  CALL GetDOSVersion           ;Get the DOS version
  CALL GetRealName             ;Get the Real Program Name
  CALL SetupExec               ;Setup Exec Parameters
  CALL GetOurPath              ;Get the Pointer to Our Path
  CALL GetEnvVars              ;Get the Environment Variable Pointers
  CALL ParseIt                 ;Parse the conmmand line
  CALL ReleaseExtraMem         ;Release the Extra Memory Segment
  CALL DoHelp                  ;Print Help and Quit, if necessary
  CALL DoAliases               ;Print Aliases and Quit, if necessary
  CALL DoErrLvls               ;Print ErrorLevel Table and Quit, if necessary
  CALL DoInquiry               ;Print Inquiry Data and Quit, if necessary
  CALL DoFormat                ;Format Disk and Quit, if necessary
  CALL TestCompatibility       ;Test for compatibility (quit if not)
  CALL DoUninstall             ;Uninstall and quit, if necessary
;Don't do these unless we're already installed in memory?
  CALL DoBadDevices            ;Print Bad Devices and Quit, if necessary
  CALL DoWriteBuffers          ;Print Buffer Contents, if necessary
  CALL DoDescriptors           ;Print USB Descriptors, Quit if Error
  CALL DoStatus                ;Print Program/Disk Status, if necessary
  CALL DoDrvStatus             ;Print Drive Status, if necessary
  CALL DoWriteASCQHistory      ;Print ASCQ History, if necessary
  TEST ProgFlags,InMemory      ;If so, are we already Installed?
  JZ  >M50                     ;If not, Install as a TSR
M40:                           ;Already Installed
  MOV  DX,UpdateMsg            ;If so, point at Update message
  XOR  AL,AL                   ;Errorlevel = 0
  JMP  Exit                    ;QUIT

M50:                           ;First-time installation (install as TSR)
  CALL DelEnvironment          ;Delete environment space (don't need it now)
  CALL GetLOLPointers          ;Get Pointers we need from the List of Lists
                               ;  Quit if No Available Drives
  CALL InitTblOffsets          ;Initialize Data Table Offsets
  CALL MoveProgramToUMB        ;Move Program to Upper Memory, if possible
   ;All Subroutines after this MUST assume ES is TSR Segment, NOT CS!!
  MOV  DS,ES                   ;Point DS at TSR Data Area
  CALL GetInt13DriveNums       ;Get the Int 13h Drive Numbers we can use
  CALL SetupFDPTs              ;Setup the Fixed Disk Parameter Tables, if Approp
  CALL InitDPBCDS              ;Initialize Drive Values in DOS
                               ;  (Quits if No Drive Letters Available)
  CALL AddDvcHeader            ;Add our Device Header to the DOS Chain
  CALL InitTables              ;Initialize all Tables
  CALL ChangeInts              ;Change the interrupts to point at us
  CALL InitInts                ;Initialize periodic "Search for New Devices"
                               ;  (quits if there's a problem)
  CALL AdjustBIOSData          ;Adjust the Number of Drives in the BIOS Data Area
  CALL AdjustNumBlkDvcs        ;Adjust the Number of Drives in the List of Lists
  CALL GetFormatFiller         ;Get the Format Filler Byte
  MOV  DS,CS                   ;Point DS at Local Data Area
  CALL WriteFirstDrive         ;Write the first Drive Letter
  XOR  AL,AL                   ;ErrorLevel = 0
  MOV  BX,DS                   ;Point BX at the Local Segment
  MOV  CX,ES                   ;Point CX at the TSR Segment
  MOV  DX,InstallMsg1          ;Write the first part of the
  CALL WriteZPause             ;  Install Message
  TEST ProgFlags,MemoryMoved   ;Did we move the TSR Memory?
  JZ  >M90                     ;If not, use TSR Exit
  MOV  DX,InstallMsgAuto       ;Write
  CALL WriteZPause             ;  "automatically"
  MOV  DX,InstallMsgHole       ;Assume we installed in a Low Memory Hole
  CMP  BX,CX                   ;Did we install in a UMB or a Low Memory Hole?
  JA  >M80                     ;If a Low Memory Hole, leave the message as is
  MOV  DX,InstallMsgHigh       ;If a UMB, point at Installed High message
M80:                           ;[DX] = appropriate Memory Message
  CALL WriteZPause             ;Write the Memory Message
  MOV  DX,InstallMsgLast       ;Point at the last part of the Installed Message
  JMP  Exit                    ;Done

M90:                           ;Exit Program as a TSR
  MOV  DX,InstallMsgNorm       ;Assume we're in Low Memory
  CMP  CX,0A000h               ;Are we in Low Memory?
  JB  >M95                     ;If so, continue
  MOV  DX,InstallMsgHigh       ;If not, point at the High Memory message
M95:                           ;[DX] = appropriate Memory Message to write
  CALL WriteZPause             ;Write the Memory Message
  MOV  DX,InstallMsgLast       ;Write the last part of the
  CALL WriteZPause             ;  Install Message
  MOV  DX,CS:LastTSRByteOffset ;DX =
  SHR  DX,4                    ;  Number of TSR Paragraphs
  MOV  AH,31h                  ;Function 31h (TSR), ErrorLevel in AL (0)
  INT  21h                     ;Do it

;------------------------------------------------------------------------------
;MAKE SURE THE MCB (MEMORY CONTROL BLOCK) CONTAINS OUR PROGRAM NAME
;Inputs:  DS = Local Data Area
;         DS:RealName = ASCIIZ Real Name of our program
;         CLD Already Issued
;Outputs:
;Changes: Data in MCB
;NOTES:   This makes sure that the MCB (Memory Control Block) for our
;           program contains our program name.  DOS 4+ does this
;           automatically, but DOS versions 1-3 do not.  This code
;           does not verify whihc DOS version is in use, but simply
;           fills in the MCB no matter what.
;         Our program name is needed inthe MCB to make sure other programs
;           can identify that we are installed in memory.  This code should
;           be added to all TSR's, so that memory-mapping programs
;           (like MAPMEM or ISLOADED) can tell which TSR's are installed
;           in memory.  It should also be added to all programs that
;           EXEC other programs, so that the EXEC'd program can figure out
;           who called it.
;         Programs that are not TSR's and do not EXEC other programs
;           do not need this code.
;------------------------------------------------------------------------------
CopyNameToMCB:
  PUSH CX,DI,SI,ES              ;Save used registers
  MOV  CX,DS                    ;Point ES:[DI]
  DEC  CX                       ;  at the Owners Name
  MOV  ES,CX                    ;  in the MCB
  MOV  DI,(OFFSET MCBOwnerName) ;  of our program
  MOV  SI,RealName              ;Point DS:[SI] at our Program Name
  MOV  CX,4                     ;Copy 4 words (8 bytes)
  REP  MOVSW                    ;Copy our program name to the MCB
  POP  ES,SI,DI,CX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SETUP/RELEASE AN EXTRA 64K MEMORY SEGMENT FOR OUR PROGRAM
;Inputs:  DS = Local Data Area
;Outputs: ExtraMemSegment = Segment of New Segment
;         Quits Program with Error Message if Memory Problem
;Changes:
;------------------------------------------------------------------------------
SetupExtraMem:
  PUSH AX,BX                 ;Save used registers
  MOV  BX,4096               ;Number of Paragraphs in 64k Program
  MOV  AH,4Ah                ;Service 4Ah (Modify memory allocation)
  INT  21h                   ;Do it (uses ES = Segment, BX = # Paragraphs)
  JC  >X70                   ;If Error, Quit
  MOV  AH,48h                ;Service 48h (Allocate Memory Block)
  INT  21h                   ;Do it (uses BX = # paragraphs, rtns AX = Sgmt)
  JC  >X70                   ;If Error, Quit
  MOV  CS:ExtraMemSegment,AX ;If OK, store the segment
  JMP >X90                   ;Done
X70:                         ;Error
  MOV  DX,ExtraMemoryMsg     ;Point at Error Message
  MOV  AL,ErLvlMemory        ;ErrorLevel = Memory Problem
  JMP  Exit                  ;Quit
X90:                         ;Done
  POP  BX,AX                 ;Restore used registers
  RET

ReleaseExtraMem:
  PUSH AX,BX,ES ;Save used registers
  MOV  BX,OFFSET ExtraMemSegment ;Point [BX] at the Extra Memory Segment
  CMP  W [BX],0 ;Did we already Release it?
  JE  >X90      ;If so, quit
  MOV  ES,[BX]  ;If not, ES = Segment to Remove
  MOV  AH,49h   ;Service 49h (Free Memory)
  INT  21h      ;Do it
  MOV  W [BX],0 ;Mark it as released
X90:            ;Done
  POP  ES,BX,AX ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED BECAUSE WE ARE A TSR.  NEEDED TO FIND EXISTING PROGRAM
;  IN MEMORY, UNINSTALL FROM MEMORY, ETC.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;CHECK MEMORY FOR COPY OF CODE TO SEE IF PROGRAM IS ALREADY INSTALLED
;Inputs:  ProgFlags.InMemory = No
;Outputs: ES = TSR program segment, whether a TSR yet or not
;         InMemory  = Yes if program is already installed as TSR
;                   = No if not
;         HandleNum = Multiplex interrupt handle number for Interrupt 2F
;Changes:
;------------------------------------------------------------------------------
TestMemory:
  PUSH AX,BX,CX,DX        ;Save all registers that might change
  PUSH DI,SI,BP,DS        ;  (includes everything except SS & SP)
  MOV  AH,0C0h            ;Function C0, (first available user handle)
M10:                      ;Loop to here for each handle number
  CLD                     ;Go forward with string functions
  XOR  BX,BX              ;Make sure
  XOR  CX,CX              ;  all registers
  XOR  DX,DX              ;  are zero
  MOV  HandleNum,AH       ;Store the handle number
  MOV  AL,MuxInstallChk   ;Install Check Function
  INT  2Fh                ;Do it
  CMP  AL,0FFh            ;Is this function installed?
  JNE >M40                ;If not, our code can't be installed yet
M12:                      ;Test Program Name
  MOV  AH,HandleNum       ;Get the handle number back again
  MOV  AL,MuxGetProgName  ;Get Program Name
  XOR  DI,DI              ;  Function
  INT  2Fh                ;Do it
  MOV  SI,ProgName        ;Point at our name
  MOV  CX,ProgNameLen     ;Get the string length
  REPE CMPSB              ;Compare the two strings
  JNE >M50                ;If not the same, it's not us
M14:                      ;Test Author
  MOV  AH,HandleNum       ;Get the handle number back again
  MOV  AL,MuxGetAuthor    ;Get Author Function
  INT  2Fh                ;Do it (returns ES:[DI])
  MOV  SI,Author          ;Point at our name
  MOV  CX,AuthorLen       ;Get the string length
  REPE CMPSB              ;Compare the two strings
  JNE >M50                ;If no match, it's somebody elses TSR, not ours
M16:                      ;Test Program Version
  MOV  AH,HandleNum       ;Get the handle number back again
  MOV  AL,MuxGetProgVer   ;Get Program Version Function
  INT  2Fh                ;Do it
  CMP  AX,ProgVer         ;Is it the same version as us?
  JE  >M80                ;If so, we're already installed in memory
M30:                      ;A different version is installed in memory
  MOV  AL,ErLvlVersion    ;If not, ErrorLevel = Wrong version
  MOV  DX,WrongVerMsg     ;Point to error message
  JMP  Exit               ;Quit
M40:                      ;No function installed at this handle at all
  CMP  FirstHandle,0      ;Have we already located an available handle?
  JNE >M50                ;If so, just keep searching
  MOV  AH,HandleNum       ;If not, store this one
  MOV  FirstHandle,AH     ;  as the first available
M50:                      ;Increment the Handle number and try again
  MOV  DS,CS              ;Make sure another
  MOV  ES,CS              ;  Int 2F installation check routine
  MOV  AH,HandleNum       ;  hasn't changed things
  ADD  AH,1               ;Look at the next handle number
  JNC  M10                ;If still less than FFh, keep looking
  MOV  AH,FirstHandle     ;If we've searched them all, we're not in memory
  MOV  HandleNum,AH       ;  so go ahead and store our handle number
  JMP >M90                ;And we're done
M80:                      ;We've already been installed (ES contains segment)
  OR   ProgFlags,InMemory ;Mark as already installed
M90:                      ;We're done
  POP  DS,BP,SI,DI        ;Restore
  POP  DX,CX,BX,AX        ;  all registers
  RET

;------------------------------------------------------------------------------
;PRINT MESSAGE IN DX AND QUIT WITH ERRORLEVEL IN AL
;Inputs:  AL = Errorlevel to exit program with
;         CS:[DX] = Message to Print (to ERR)
;Outputs:
;Changes: Quits program
;------------------------------------------------------------------------------
Exit:
  MOV  DS,CS           ;Point DS at Segment where Error Message is Located
  CALL ReleaseExtraMem ;Release the Extra memory Segment
  OR   AL,AL           ;Was there an Error?
  JZ  >X80             ;If not, jump to handle a normal termination
  CALL BeepErr         ;If error, Beep Once
  CALL WriteZErr       ;Write message to ERR
  CALL WriteCrLfErr    ;Move down
  JMP >X90             ;Jump to quit
X80:                   ;No Error - Write to CON
  CALL WriteZPause     ;Write the message to CON
  CALL WriteCrLfPause  ;Write a New Line
X90:                   ;We're done!!
  MOV  AH,4Ch          ;Service 4Ch (terminate program)
  INT  21h             ;Do it

;------------------------------------------------------------------------------
;FINISH UP A "CAN'T PERFORM REQUEST BECAUSE WE'RE NOT INSTALLED YET" ERROR
;Inputs:  DS:[DX] = First message to Print
;Outputs: Writes Message pointed at by DS:[DX]
;         Sets Exit ErrorLevel (ErLvlUninst)
;         Writes Second Half of Error Message
;Changes: Terminates Program
;------------------------------------------------------------------------------
FinishDataErr:
  CALL WriteZErr      ;Write first part of Error Message
  MOV  AL,ErLvlUninst ;ErrorLevel = not installed yet
  MOV  DX,DataErrMsg  ;Point at second part of Error Message
  JUMP Exit           ;Terminate program

;------------------------------------------------------------------------------
;UNINSTALL RESIDENT PROGRAM
;Inputs:  ES = TSR Data Segment
;Outputs:
;Changes: Attempts to Uninstall Program from memory
;         If it can't be Uninstalled, it is Disabled
;------------------------------------------------------------------------------
DoUninstall:
  TEST ProgFlags,Uninstall ;Are we supposed to Uninstall?
  JNZ >U00                 ;If so, continue
  RET

U00:
  TEST ProgFlags,InMemory  ;If so, are we even installed yet?
  JZ  >U60                 ;If not, there's an error
  CALL TestCurrDrv         ;Quit if we're controlling the current drive
  CALL GetLOLPointers      ;Get the List of List Pointers we need
  MOV  ES:NewDvcCounter,0  ;Disable TSR from looking for more drives
  CALL StopNewDrives       ;Stop pending LookForNewDrive calls
  CALL DoStopsUnlocks      ;Process all pending Unit Stops & Unlocks
U10:                       ;Wait for pending TSR processes to complete
  TEST ES:TSRFlags,(Int14ReqInUse+SectBuffInUse) ;Resources in use?
  JNZ  U10                  ;If so, keep waiting
  MOV  SI,IntNumTable      ;Point at the Interrupt Address Table
  CALL CompareInts         ;Can we Uninstall the Interrupt Vectors?
  JC  >U70                 ;If not, we can't Uninstall
  MOV  DX,ResettingMsg     ;Tell user that we're
  CALL WriteZPause         ;  Resetting the Disks
  CALL ResetUSBDisks       ;Reset all of our Disks (Flushes Buffers/Caches)
  CALL WriteCrLfPause2     ;Move Down
  CALL UnconfigureDevices  ;Disable all of the Devices that are configured
  JC  >U70                 ;If we can't there's an error
  CALL RmvOurCDSs          ;Remove our Current Directory Structures
  CALL RmvOurDPBsFromChain ;Remove our Drive Parameter Blocks
  CALL RemoveDvcHeader     ;Remove our Device Driver Header
  MOV  AH,49h              ;Service 49h (Release Memory, uses ES)
  INT  21h                 ;Do it
  JC  >U70                 ;If unable to do it, quit with error
U20:                       ;OK to Restore Interrupts
  CALL UnRegDvc0Owner      ;Unregister as a Device 0 Owner
  CALL RestoreFBPTs        ;Restore the original Fixed Disk Parameter Tables
  CALL RestoreInts         ;Restore Int's back to normal
  CALL AdjustBIOSData      ;Restore the Number of Drives in the BIOS Data Area
  CALL RestoreNumBlkDvcs   ;Restore the Number of Drives in the List of Lists
  MOV  AX,50               ;Wait a little while
  CALL DelayMSAX           ;  for things to take effect
  MOV  CX,((SectorBuff-StackSize)/2) ;Number of Words in TSR
  XOR  DI,DI               ;Start of TSR Data Area
  XOR  AX,AX               ;Fill with Zeroes
  REP  STOSW               ;Do it
  MOV  DX,UninstallMsg     ;Point to successful uninstall message
  XOR  AL,AL               ;Errorlevel = 0
  JUMP Exit                ;QUIT
U60:                       ;Not in memory yet - can't Uninstall
  MOV  DX,UninstallErrMsg  ;Point at error message
  MOV  AL,ErLvlUninst      ;Errorlevel = Not Installed Yet
  JUMP Exit                ;QUIT
U70:                       ;Another TSR is in the way - can't Uninstall
  MOV  DX,NoUninstallMsg   ;Point at error message
  MOV  AL,ErLvlMemory      ;Errorlevel = Memory Problem
  JMP  Exit                ;QUIT

;------------------------------------------------------------------------------
;TEST AND SEE IF WE ARE CONTROLLING THE CURRENT DRIVE
;Inputs:  CS = DS = Local Data Area
;         ES = TSR Data Segment
;Outputs: If OK, (current drive is not USB), simply returns
;         If Error (current Drive is USB), quits with Error
;Changes:
;------------------------------------------------------------------------------
TestCurrDrv:
  PUSH AX,BX,DX,ES       ;Save used registers
  MOV  AH,19h            ;Function 19h (Get Current Drive)
  INT  21h               ;Do it (Rtns AL = Drive: 0=A, 1=B, etc.)
  XOR  AH,AH             ;Convert to a Word
  MOV  BX,CDSSize        ;Convert to
  MUL  BX                ;  an offset
  MOV  DX,ES             ;Save TSR Segment
  LES  BX,ES:FirstCDSPtr ;ES:[BX] = CDS Pointer for Drive A:
  ADD  BX,AX             ;Add in the Offset to the Current Drive
  CMP  DX,W ES:[BX].CDSDPBPtr[2] ;Is the CDS segment ours (one of our drives)?
  JNE >C80               ;If not, quit
C70:                     ;Error
  MOV  AL,ErLvlCurrDrv   ;ErrorLevel = Controlling Current Drive
  MOV  DX,CurrDrvErrMsg  ;[DX] = Error Message to write
  JMP  Exit              ;Quit Program
C80:                     ;OK
  POP  ES,DX,BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;STOP ALL PENDING LOOKFORNEWDRIVE CALLS IN THE TSR
;Inputs:  DS = Local Data Area
;         ES = TSR Data ARea
;Outputs: Stops Pending LookForNewDrive calls in teh TSR
;Changes:
;------------------------------------------------------------------------------
StopNewDrives:
  PUSH BX,CX,DS           ;Save used registers
  MOV  DS,ES              ;DS = TSR Data ARea
  MOV  BX,DiskInfoOffset  ;[BX] = Disk Info Table
  MOV  CX,NumDisks        ;CX = Number of Table Entries
W10:                      ;Loop to here for each Table Entry
  CLI                     ;Disable Interrupts
  TEST [BX].DskFlags,DskFlagInUse ;Valid Table Entry?
  JZ  >W50                ;If not, skip it
  TEST [BX].DskFlags,DskFlagReqInProg ;TSR SCSI Request currently in progress?
  JZ  >W20                ;If not, continue
  STI                     ;If so, Enable Interrupts
  JMP  W10                ;Keep waiting
W20:                      ;TSR SCSI Request not currently in progress
  CMP  [BX].DskDrvTimer,DskStageInProc ;In process of looking for new Drives?
  JB  >W30                ;If not, continue
  STI                     ;If so, enable interrupts (let the process complete)
  JMP  W10                ;Keep waiting
W30:                      ;OK to stop LookForNewDrives process
  MOV  [BX].DskDrvTimer,0 ;Mark as Media inserted (stops LookForNewDrives)
W50:                      ;Done with this entry
  STI                     ;Enable Interrupts
  ADD  BX,DiskInfoSize    ;Point at next Table Entry
  LOOP W10                ;If not done, keep looking
  POP  DS,CX,BX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE PENDING UNIT STOP & UNLOCK REQUESTS IMMEDIATELY
;Inputs:  DS = Local Data Area
;         ES = TSR Data ARea
;Outputs: Issues Pending Requests to Stop & Unlock Disks Immediately
;Changes:
;------------------------------------------------------------------------------
DoStopsUnlocks:
  PUSH BX,CX,DS            ;Save used registers
  MOV  DS,ES               ;DS = TSR Data ARea
  MOV  BX,DiskInfoOffset   ;[BX] = Disk Info Table
  MOV  CX,NumDisks         ;CX = Number of Table Entries
P10:                       ;Loop to here for each Table Entry
  CLI                      ;Disable Interrupts
  TEST [BX].DskFlags,DskFlagInUse ;Valid Table Entry?
  JZ  >P30                 ;If not, skip it
  CMP  [BX].DskStopTimer,2 ;Stops/Unlock still pending for this Device?
  JBE >P30                 ;If not, skip it
  MOV  [BX].DskStopTimer,2 ;If so, issue it as soon as possible
P30:                       ;Done with this entry
  STI                      ;Enable Interrupts
  ADD  BX,DiskInfoSize     ;Point at next Table Entry
  LOOP P10                 ;If not done, keep looking
P90:                       ;Done
  POP  DS,CX,BX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CLOSE ALL OPEN HANDLES & UNCONFIGURE DEVICES THAT WE'RE CONTROLLING
;Inputs:  ES = TSR Data Segment
;Outputs:
;Changes: Closes Open Handles, Unconfigures Devices
;------------------------------------------------------------------------------
UnconfigureDevices:
  PUSH AX,CX,DI,SI,DS             ;Save used registers
  MOV  DS,ES                      ;Point DS at TSR Data
  MOV  SI,Int14Request            ;Point at Request Structure
  MOV  DI,DeviceInfoOffset        ;Point at Table
  MOV  CX,NumDevices              ;Number of Table Entries
G10:                              ;Loop to here for each Entry
  TEST [DI].DvcFlags,DvcFlagInUse ;Valid Entry?
  JZ  >G30                        ;If not, skip it
  CALL RlsDvcDoResetDI            ;Release & Reset the Device
G30:                              ;Done with this entry
  ADD  DI,DeviceInfoSize          ;Point at next entry
  LOOP G10                        ;Keep going until we're done
  OR   TSRFlags,Uninstalled       ;Mark as uninstalled
  POP  DS,SI,DI,CX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE A RESET TO ALL OF OUR USB DISKS
;Inputs:  ES = TSR Data Segment
;Outputs:
;Changes: Issues Reset Requests to all of our USB Disks
;           (Flushes buffers & caches)
;------------------------------------------------------------------------------
ResetUSBDisks:
  PUSH AX,CX,DX,SI,DS             ;Save used registers
  MOV  DS,ES                      ;DS = TSR Data Area
  MOV  CX,NumDisks                ;CX = Number of Table Entries
  MOV  SI,DiskInfoOffset          ;[SI] = Disk Info Table
R10:                              ;Loop to here for each table entry
  TEST [SI].DrvFlags,DrvFlagInUse ;Currently being used?
  JZ  >R50                        ;If not, skip it
  MOV  DL,[SI].DskInt13DrvNum     ;Get Int 13h Drive Number
  OR   DL,DL                      ;Is it valid?
  JZ  >R50                        ;If not, skip it
  XOR  AH,AH                      ;If OK, function 0 (Reset Disk System)
  INT  13h                        ;Do it (DL = Drive Number)
R50:                              ;Done with this Drive Entry
  ADD  SI,DiskInfoSize            ;Point at the next entry
  LOOP R10                        ;Keep going until we're done
  POP  DS,SI,DX,CX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;UNREGISTER AS A DEVICE 0 (NEW DEVICE) OWNER
;Inputs:  DS = Local Data Area
;         ES = TSR Data Segment
;Outputs:
;Changes: Unregisters as Device 0 Owner
;NOTES: We do this as a separate item from UnconfigureDevices, and perform it
;         after we've verified that we can actually Uninstall the program.
;       If we are unable to Uninstall and simply Disable ourselves, we don't
;         want to go through the bother of re-Registering as a Device 0 Owner
;         again.  We leave our Device 0 Registration in effect, but effectively
;         just ignore it until we re-Enable ourselves.
;------------------------------------------------------------------------------
UnRegDvc0Owner:
  PUSH AX,SI,DS                      ;Save used registers
  MOV  DS,ES                         ;Point DS at TSR Data
  MOV  SI,Int14Request               ;Point at Request Structure
  MOV  W [SI].I14RCallBackAddr[0],-1 ;Set CallBackAddr to nothing
  MOV  [SI].I14RRequestType,I14RRTUnRegIntfOwner ;Unregister as owner
  MOV  [SI].I14RHostIndex,-1         ;All Hosts
  MOV  [SI].I14RDeviceAddress,0      ;Address 0 (New Connects)
  MOV  AX,Reg0Handle                 ;Handle Number
  MOV  [SI].I14RRequestHandle,AX     ;  returned by Host
  CALL DoInt14CallSaveAllSI          ;Do it
  POP  DS,SI,AX                      ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO COPY DATA FROM THE REDIRECTED INPUT FILE, "COMPRESSING" IT AND
;  STORING IT IN OUR LOCAL MEMORY BUFFER.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;READ THE DATA FROM STDIN (REDIRECTED INPUT) AND STORE IT IN OUR BUFFER
;Inputs:  ExtraMemSegment
;Outputs:
;Changes: Fills up StdInBuffer
;         As data is read, multiple spaces are converted to single spaces,
;           and EOL's (CR/LF) are also changed to spaces
;         Last character of buffer is a 0
;         Quits with error message if StdIn is too big for buffer
;------------------------------------------------------------------------------
FillStdInBuffer:
  PUSH AX,DI,ES             ;Save used registers
  CALL FlushKbdBuff         ;Don't let keyboard buffer mess with File Input
  MOV  ES,ExtraMemSegment   ;Point ES:DI at
  XOR  DI,DI                ;  our Buffer
  MOV  AL,' '               ;Start the buffer
  STOSB                     ;  with a space
B10:                        ;Loop to here for each character
  CALL ReadStdInChar        ;Get the next character
  JZ  >B80                  ;If end of input, we're done
B15:                        ;AL contains the next character
  CMP  AL,EOF               ;Is it End-of-File?
  JE  >B80                  ;If so, it's the end of input
B20:                        ;Test for Comment
  CMP  AL,';'               ;Is it the start of a comment?
  JNE >B30                  ;If not, try the next possibility
  CALL SkipOverStdInComment ;If so, skip over the comment
  JC  >B80                  ;If EOF, we're done
  JMP  B10                  ;If not EOF, continue
B30:                        ;Test for String
  CMP  AL,'"'               ;Double Quote?
  JE  >B35                  ;If so, handle a string
  CMP  AL,"'"               ;Single Quote?
  JE  >B35                  ;If so, handle a string
  CMP  AL,"`"               ;Left Quote?
  JNE >B40                  ;If not, try the next possibility
B35:                        ;It's a String
  CALL GetStdInString       ;Get the rest of the String
  JC  >B80                  ;If error, just quit (Error handled later)
  JMP  B10                  ;If OK, continue
B40:                        ;Test for EOL
  CMP  AL,CR                ;Carriage Return?
  JE  >B45                  ;If so, handle it
  CMP  AL,LF                ;Carriage Return?
  JNE >B50                  ;If not, it's a regular character
B45:                        ;End of Line
  CALL AddSpace2StdInBuff   ;Add a Space to the Buffer, if needed
  JMP  B10                  ;Continue
B50:                        ;Is a regular character
  CALL AddChar2StdInBuff    ;Add the character to the buffer
  JMP  B10                  ;Continue
B80:                        ;Done, no error
  XOR  AL,AL                ;Mark the end
  STOSB                     ;  of the buffer
B90:                        ;Done
  POP  ES,DI,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER A COMMENT IN THE REDIRECTED INPUT FILE
;Inputs:  DS = Local Data Area
;         ES:[DI] = StdInBuffer
;         AL = Semicolon (the start of the Comment)
;Outputs: CF = Clear if OK (not EOF)
;            = Set if we've reached EOF
;         Quits Program with error message if Buffer gets full
;Changes:
;NOTES: This looks for either an EOF or LF character to indicate the end of
;         the comment.  If we see a CR, we simply skip it and wait for the LF
;         that should immediately follow the CR.
;       If a line ends in a CR or CR/LF combination, this will not work
;         this will not work correctly.  However, no file we work with
;         should ever be in that format.
;------------------------------------------------------------------------------
SkipOverStdInComment:
  PUSH AX                 ;Save used registers
C10:                      ;Loop to here for each character on the line
  CALL ReadStdInChar      ;Get the next character (AL)
  JZ  >C70                ;If no characters available, EOF
  CMP  AL,EOF             ;End-of-File character?
  JE  >C70                ;If so, we're done
  CMP  AL,CR              ;Carriage Return?
  JE  >C20                ;If so, End of Comment
  CMP  AL,LF              ;Line Feed?
  JNE  C10                ;If not, keep looking
C20:                      ;End of Line
  CALL AddSpace2StdInBuff ;Add a Space to the Buffer if we need it
  JMP >C80                ;Done
C70:                      ;EOF
  STC                     ;Set EOF Flag
  JMP >C90                ;Done
C80:                      ;Not EOF
  CLC                     ;Set not EOF Flag
C90:                      ;Done
  POP  AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY A STRING FROM STDIN TO THE STDINBUFFER
;Inputs:  DS = Local Data Area
;         ES:[DI] = StdInBuffer
;         AL = Quote Characer (the start of the String)
;Outputs: CF = Clear if OK (not EOF)
;            = Set if we've reached EOF (Bad String)
;         Quits Program with error message if Buffer gets full
;Changes:
;NOTES: This looks for the matching Quote Character to indicate the end of
;         the String.
;       If we find an EOF, CR, or LF in the string, we return a CF to indicate
;         a bad String.
;------------------------------------------------------------------------------
GetStdInString:
  PUSH AX                 ;Save used registers
  MOV  AH,AL              ;Save quote character
  CALL AddSChar2StdInBuff ;Add the Quote Character to the Buffer
S10:                      ;Loop to here for each character of string
  CALL ReadStdInChar      ;Get the next character (AL)
  JZ  >S70                ;If no characters available, Error
  CMP  AL,EOF             ;End-of-File character?
  JE  >S70                ;If so, Error
  CMP  AL,CR              ;Carriage Return?
  JE  >S70                ;If so, Error
  CMP  AL,LF              ;Line Feed?
  JE  >S70                ;If so, Error
  CALL AddSChar2StdInBuff ;Add the Character to the Buffer
  CMP  AL,AH              ;Is it the end-of-string character?
  JNE  S10                ;If not, keep looking
  JMP >S80                ;Done
S70:                      ;EOF (Bad String)
  STC                     ;Set EOF Flag
  JMP >S90                ;Done
S80:                      ;String is OK
  CLC                     ;Set OK flag
S90:                      ;Done
  POP  AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ A CHARACTER FROM STDIN (REDIRECTED INPUT)
;Inputs:
;Outputs: AL = Next character from StdIn
;              ZF Clear
;            = 0 if no character to get
;              ZF Set
;Changes:
;------------------------------------------------------------------------------
ReadStdInChar:
  PUSH DX      ;Save used registers
  MOV  DH,AH   ;Save original AH
  MOV  AH,06h  ;Function 06h
  MOV  DL,0FFh ;  (Direct Console Input)
  INT  21h     ;Do it (returns AL and ZF)
  MOV  AH,DH   ;Restore original AH
  POP  DX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADD A CHARACTER OR STRING CHARACTER TO THE END OF THE STDIN BUFFER
;Inputs:  DS = Local Data Area
;         ES:[DI] = StdInBuffer
;         AL = Character to add to end of Buffer
;         CLD already issued
;Outputs: Returns to calling program if Character was added OK
;         Quits Program with Error if Buffer is already full
;Changes: DI (maybe)
;------------------------------------------------------------------------------
AddSpace2StdInBuff:
  PUSH AX                ;Save used registers
  MOV  AL,' '            ;Add a Space to the Buffer
  CALL AddChar2StdInBuff ;  if we need it
  POP  AX                ;Restore used registers
  RET

AddChar2StdInBuff:
  CMP  AL,' '            ;Are we adding a space?
  JNE >B00               ;If not, just add it
  CMP  B ES:[DI-1],AL    ;If so, is there already a space?
  JNE >B00               ;If not, just add it
  JMP >B90               ;If so, we're done
AddSChar2StdInBuff:
B00:                     ;Add the character to the Buffer
  CMP  DI,65534          ;Is the Buffer full?
  JAE >B70               ;If so, Error
  STOSB                  ;If not, Store the Character
  JMP >B90               ;Done
B70:                     ;Buffer already Full
  MOV  DX,StdInTooBigMsg ;Point at error message
  MOV  AL,ErLvlStdIn     ;ErrorLevel = problem with StdIn
  JMP  Exit              ;Quit
B90:                     ;Done
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO INITIALIZE VARIOUS TABLES AND STRUCTURES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;INITIALIZE TABLES AND STRUCTURES TO THEIR APPROPRIATE VALUES
;Inputs:  DS = ES = TSR Data Area
;Outputs:
;Changes: Various things
;------------------------------------------------------------------------------
InitTables:
  PUSH CX,DI               ;Save used registers
I10:                       ;Int 14 Requests
  MOV  DI,Int14Request     ;Point at first Table Entry
  MOV  CX,2                ;Number of Table Entries
I15:                       ;Loop to here for each Table Entry
  CALL InitInt14Req        ;Fill it up
  ADD  DI,Int14RequestSize ;Point at the next one
  LOOP I15                 ;Keep going until we're done
I20:                       ;Device Table
  MOV  DI,DeviceInfoOffset ;Point at first Table Entry
  MOV  CX,NumDevices       ;Number of Table Entries
I25:                       ;Loop to here for each Table Entry
  PUSH DI                  ;Save Pointer
  ADD  DI,(OFFSET DvcInt14Request) ;Point at the Int 14h Request
  CALL InitInt14Req        ;Fill it up
  POP  DI                  ;Restore the Pointer
  ADD  DI,DeviceInfoSize   ;Point at the next one
  LOOP I25                 ;Keep going until we're done
I30:                       ;Disk Table
  MOV  DI,DiskInfoOffset   ;Point at first Table Entry
  MOV  CX,NumDisks         ;Number of Table Entries
I35:                       ;Loop to here for each Table Entry
  MOV  D [DI].DskCBW.CBWSignature,4342_5355h ;Set the CBW Signature
;Set CBW User Tag to something?
  ADD  DI,DiskInfoSize     ;Point at the next one
  LOOP I35                 ;Keep going until we're done
I90:                       ;Done
  POP  DI,CX               ;Restore used registers
  RET

InitInt14Req:
  MOV  [DI].I14RDvcClass,DvcClassNone          ;Device Class
  MOV  [DI].I14RDvcSubClass,DvcSubClassNone    ;Device SubClass
  MOV  [DI].I14RDvcProtocol,DvcProtocolNone    ;Device Protocol
  MOV  [DI].I14RIntfClass,IntfClassMassStorage ;Interface Class
  MOV  [DI].I14RIntfSubClass,IntfSubClassAny   ;Interface SubClass
  MOV  [DI].I14RIntfProtocol,IntfProtocolAny   ;Interface Protocol
  MOV  [DI].I14RVendorID,-1                    ;Vendor ID = Don't Care
  MOV  [DI].I14RProductID,-1                   ;Product ID = Don't Care
  MOV  W [DI].I14RDataAddress[2],ES            ;Set Segment
  MOV  W [DI].I14RCallBackAddr[2],ES           ;  Registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE NECESSARY INTERRUPTS TO CHECK FOR A NEW DEVICE
;Inputs:  DS = ES = TSR Data Area
;Outputs:
;Changes:
;------------------------------------------------------------------------------
InitInts:
  PUSH CX,DI                    ;Save used registers
I10:                            ;Register Interface 0 Owner
  MOV  DI,Int14Request          ;Point at Request Structure
  MOV  [DI].I14RRequestType,I14RRTRegIntfOwner ;Register as Owner
  MOV  [DI].I14RHostIndex,-1    ;Any/All Hosts
  MOV  [DI].I14RDeviceAddress,0 ;New Device
  MOV  W [DI].I14RCallBackAddr[0],DvcOwnerFarCall ;Code to call
  MOV  [DI].I14RUserPktID,0     ;Packet ID 0
  CALL DoInt14CallCXDI          ;Do it
  JC  >I70                      ;If error, quit
  MOV  Reg0Handle,CX            ;Save Registry Handle
  JMP >I90                      ;Done
I70:                            ;Error

;If this fails, we need to release Interrupts & Drive Parameter Chains!
;Also need to do this in other programs!

  MOV  DX,HostInitErrMsg        ;If not, point at Err Msg
  MOV  AL,ErLvlHostInit         ;Error Initializing Host
  JMP  Exit                     ;Done
I90:                            ;It worked
  POP  DI,CX                    ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED TO MANAGE (SETUP AND TEAR DOWN) DEVICE HEADERS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;ADD OUR DEVICE HEADER TO THE DEVICE HEADER CHAIN
;Inputs:   DS = ES = TSR Data Area
;          CS = Local Data Area
;          DvcDriverHdr = Our Device Header
;                  (everything filled in except DHNextHeader)
;          NULDvcHeader already found (GetLOLPointers already issued)
;Outputs:
;Changes: Adds Our Device Header to beginning of DOS Chain
;------------------------------------------------------------------------------
AddDvcHeader:
  PUSH BX,ES                        ;Save used registers
  CLI                               ;Disable interrupts
  LES  BX,CS:NULDvcHeader           ;ES:[BX] = NUL Device Header
A10:                                ;Loop to here to find the end of the Chain
  CMP  W ES:[BX].DHNextHeader[0],-1 ;Is this the end of the Device Driver Chain?
  JE  >A30                          ;If so, jump to add ours to the end
  LES  BX,ES:[BX].DHNextHeader      ;If not, get the next one in the Chain
  JMP  A10                          ;Keep looking until we get to the end
A30:                                ;ES:[BX] = Last Device Driver in CHain
  MOV  W ES:[BX].DHNextHeader[0],DvcDriverHdr ;Copy our Driver Address
  MOV  W ES:[BX].DHNextHeader[2],DS ;  into the previous Drivers Next Address
  STI                               ;Enable interrupts
  POP  ES,BX                        ;Restore used registers
  RET

;AddDvcHeader:
;  PUSH EAX,BX,DI,ES                 ;Save used registers
;  CLI                               ;Disable interrupts
;  MOV  DI,DvcDriverHdr              ;DS:[DI] = Our Device Driver Header
;  LES  BX,CS:NULDvcHeader           ;ES:[BX] = NUL Device Header
;  MOV  EAX,ES:[BX].DHNextHeader     ;Copy the next Driver Address
;  MOV  [DI].DHNextHeader,EAX        ;  into our Header
;  MOV  W ES:[BX].DHNextHeader[0],DI ;Copy our Driver Address
;  MOV  W ES:[BX].DHNextHeader[2],DS ;  into the NUL Header
;  STI                               ;Enable interrupts
;  POP  ES,DI,BX,EAX                 ;Restore used registers
;  RET


;------------------------------------------------------------------------------
;RESTORE THE DEVICE HEADER CHAIN BACK TO NORMAL
;Inputs:  ES = TSR Data Area
;         DvcDriverHdr
;Outputs: Restores Device Driver Chain back to the way it was,
;           if it was not done already
;Changes:
;------------------------------------------------------------------------------
RemoveDvcHeader:
  PUSH EAX,BX,DI,DS,ES              ;Save used registers
  CLI                               ;Disable interrupts
  MOV  DS,ES                        ;Point DS at TSR Data Area
  MOV  DI,DvcDriverHdr              ;DS:[DI] = Our Device Driver Header
  PUSH DS                           ;EAX =
  PUSH DI                           ;  Our Device
  POP  EAX                          ;  Driver Header
  LES  BX,CS:NULDvcHeader           ;ES:[BX] = NUL Device Header
R10:                                ;Loop to here to find last Device Header
  CMP  W ES:[BX].DHNextHeader[0],-1 ;Is this the Last Device Header?
  JE  >R90                          ;If so, we've already done this
  CMP  ES:[BX].DHNextHeader,EAX     ;If not, is it us?
  JE  >R30                          ;If so, handle it
  LES  BX,ES:[BX].DHNextHeader      ;If not, get the next Device Header Pointer
  JMP  R10                          ;Keep looking
R30:                                ;ES:[BX] = Device Header previous to us
  MOV  EAX,[DI].DHNextHeader        ;Remove our Driver
  MOV  ES:[BX].DHNextHeader,EAX     ;  from the Chain
R90:                                ;Done
  STI                               ;Enable interrupts
  POP  ES,DS,DI,BX,EAX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE MEMORY ADDRESSES OF VARIOUS LIST OF LIST POINTERS
;Inputs:  DS = ES = TSR Data Area
;         CS = Local (non-TSR) Data Area
;Outputs: NULDvcHeader = Address of NUL Device Header
;
;Changes:
;NOTES: This assumes that we have already verified that DOS is at least
;         version 4.0.
;------------------------------------------------------------------------------
GetLOLPointers:
  PUSH EAX,BX,DS,ES               ;Save used registers
  MOV  AH,52h                     ;Function 52h (Get DOS list of Lists)
  INT  21h                        ;Do it (returns ES:[BX])
  LEA  AX,[BX].LOLNULDvcHdr       ;Store the
  MOV  W CS:NULDvcHeader[0],AX    ;  NUL Device
  MOV  W CS:NULDvcHeader[2],ES    ;  Header Pointer
  MOV  EAX,ES:[BX].LOLDPBPtr      ;Store the
  MOV  CS:FirstDPBPtr,EAX         ;  First Drive Parameter Block Pointer
  MOV  EAX,ES:[BX].LOLCDSPtr      ;Store the
  MOV  FirstCDSPtr,EAX            ;  First Current Directory Structure Pointer
  MOV  AX,ES:[BX].LOLBytesPerSect ;Store the
  MOV  MaxBytesPerSect,AX         ;  Maximum bytes per Sector
  MOV  AL,ES:[BX].LOLNumAvailDrv  ;Store the
  MOV  CS:NumAvailDrv,AL          ;  Number of Available Drive Letters
L90:                              ;Done
  POP  ES,DS,BX,EAX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE OUR DRIVE PARAMETER BLOCKS & CURRENT DIRECTORY STRUCTURES
;Inputs:  DS = ES = TSR Data Area
;         CS = Local Data Area
;         CS:FirstDrive = First Drive Number to use
;         GetLOLPointers already issued (Pointers already copied)
;         Our DPBs are uninitialized
;Outputs: Sets up DPB & CDS in DOS for us to use
;Changes:
;------------------------------------------------------------------------------
InitDPBCDS:
  PUSH EAX,BX,CX,DX,DI,ES         ;Save used registers
  MOV  AL,CS:FirstDrive           ;Get the First Drive Number to use
  CMP  AL,2                       ;Is it at least C:?
  JB  >I04                        ;If not, jump to make it C:
  CMP  AL,CS:NumAvailDrv          ;Is it within LASTDRIVE boundaries?
  JB  >I06                        ;If so, it's OK
I04:                              ;Make First Drive C:
  MOV  AL,2                       ;First Drive = C:
I06:                              ;AL = First Drive Number to use
  MOV  CS:FirstDrive,AL           ;Store First Drive Number we're using
  XOR  CH,CH                      ;CH = DPB Index
  MOV  CL,AL                      ;CL = CDS Index
  MOV  AH,CDSSize                 ;Calculate the
  MUL  AH                         ;  CDS Offset to use (AX)
  LES  DI,FirstCDSPtr             ;ES:[DI] = Current Dir Struc
  ADD  DI,AX                      ;  for First Drive Letter
  MOV  AX,DvcDriverHdr            ;EAX =
  PUSH DS                         ;  Our Device Driver
  PUSH AX                         ;  Header
  POP  EAX                        ;  Address
  MOV  BX,DriveInfoOffset         ;DS:[BX] = First Drive Info Table Entry
  CLI                             ;Disable Interrupts
I10:                              ;Loop to here for each CDS
  CMP  ES:[DI].CDSDriveAttr,0     ;CDS already assigned?
  JNE >I50                        ;If so, don't use it
  CMP  ES:[DI].CDSDPBPtr,0        ;If not, is there a valid DPB Pointer?
  JNE >I50                        ;If so, we can't use it
I20:                              ;ES:[DI] = Unused CDS entry
  CALL ResetDPBBX                 ;Reset DPB Data
  OR   [BX].DrvFlags,DrvFlagValid ;Mark as a Valid Entry
  MOV  [BX].DrvDPB.DPBDriveNum,CL ;Store the Drive Number
  MOV  [BX].DrvDPB.DPBUnitNum,CH  ;Store the Unit Number (Index)
  MOV  D [BX].DrvDPB.DPBDvcDriverPtr,EAX ;Store our Device Driver Pointer
  CALL AddDPBToChain              ;Add our DPB to the DOS DBP Chain
  MOV  W ES:[DI].CDSDPBPtr[2],DS  ;Fill in the
  LEA  DX,[BX].DrvDPB             ;  Pointer
  MOV  W ES:[DI].CDSDPBPtr[0],DX  ;  to our DPB
  MOV  ES:[DI].CDSDriveAttr,DAttrPhysical ;Set Attributes
  ADD  BX,DriveInfoSize           ;Update the DPB Pointer
  INC  CH                         ;Increment the Counter
  CMP  CH,B NumDrives[0]          ;Have we filled them all yet?
  JE  >I90                        ;If so, we're done
I50:                              ;Done with this CDS
  ADD  DI,CDSSize                 ;Point at the next CDS
  INC  CL                         ;Increment the CDS Counter
  CMP  CL,CS:FirstDrive           ;Done testing all possibile Drive Leters?
  JE  >I90                        ;If so, quit
  CMP  CL,CS:NumAvailDrv          ;Have we done them all yet?
  JB   I10                        ;If not, keep assigning
  CMP  CS:FirstDrive,2            ;Is the First Drive Number = C:?
  JE  >I90                        ;If so, we're done
  MOV  CL,2                       ;If not,
  MOV  DI,W FirstCDSPtr[0]        ;  point CL & ES:[DI]
  ADD  DI,(CDSSize*2)             ;  at the CDS for C:
  JMP  I10                        ;Keep looking
I90:                              ;Done
  STI                             ;Enable interrupts
  POP  ES,DI,DX,CX,BX,EAX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADD A DPB POINTER TO THE END OF THE DPB CHAIN
;Inputs:  DS = ES = TSR Data Area
;         CS = Local Data Area
;         DS:[BX] our Drive Entry to add to the chain
;         GetLOLPointers already issued (Pointers already copied)
;         CLI issued
;Outputs: Adds DPB to the end of the DOS Chain
;Changes: Writes DPBNextDPBPtr as -1 (end of Chain)
;------------------------------------------------------------------------------
AddDPBToChain:
  PUSH AX,DI,ES                       ;Save used registers
  MOV  D [BX].DrvDPB.DPBNextDPBPtr,-1 ;Fill in our Next Pointer
  LES  DI,CS:FirstDPBPtr              ;Get the First DPB Pointer
A10:                                  ;Loop to here to find the end of the chain
  CMP  W ES:[DI].DPBNextDPBPtr[0],-1  ;Is this the end of the Chain?
  JE  >A20                            ;If so, handle it
  LES  DI,ES:[DI].DPBNextDPBPtr       ;If not, point at the next DPB
  JMP  A10                            ;Keep looking
A20:                                  ;ES:[BX] = End of Existing Chain
  LEA  AX,[BX].DrvDPB                 ;Store our
  MOV  W ES:[DI].DPBNextDPBPtr[0],AX  ;  DPB Address
  MOV  W ES:[DI].DPBNextDPBPtr[2],DS  ;  as the next one
  POP  ES,DI,AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE DEVICE/DISK/DRIVE TABLE OFFSET & SIZE VALUES
;Inputs:  CS = DS = ES = Local Data Area
;                          (not installed, not copied to USB yet)
;         MaxBytesPerSect filled in (from DOS)
;         NumDevices, NumDisks, NumDrives filled in
;Outputs: Various Table Offsets & Values
;Changes:
;NOTES: This must only be called when the program is first being installed
;         into memory!  Doing it afterwards will screw up the TSR!
;------------------------------------------------------------------------------
InitTblOffsets:
  PUSH AX,BX,DX                    ;Save used registers
I10:                               ;Calculate Device/Disk/Drive offsets
  MOV  BX,SectorBuff               ;[BX] =
  ADD  BX,MaxBytesPerSect          ;  First available Data Space
  MOV  DeviceInfoOffset,BX         ;Store Device Info Table Pointer
  MOV  AX,DeviceInfoSize           ;Calculate the size
  MUL  NumDevices                  ;  of the Device Info Table
  ADD  BX,AX                       ;Store the
  MOV  DiskInfoOffset,BX           ;  Disk Info Table Pointer
  MOV  AX,DiskInfoSize             ;Calculate the size
  MUL  NumDisks                    ;  of the Disk Info Table
  ADD  BX,AX                       ;Store the
  MOV  DriveInfoOffset,BX          ;  Drive Info Table Pointer
  MOV  AX,DriveInfoSize            ;Calculate the size
  MUL  NumDrives                   ;  of the Drive Info Table
  ADD  BX,AX                       ;Store the Last
  ADD  BX,15                       ;  TSR Byte
  AND  BL,0F0h                     ;  Pointer
  MOV  LastTSRByteOffset,BX        ;  (must be paragraph-aligned)
I30:                               ;Copy miscellaneous offsets
  MOV  AX,DeviceInfoOffset         ;Store Last Device Found
  MOV  LastDeviceFound,AX          ;  Pointer
  MOV  AL,B NumDrives[0]           ;Copy the Number of Drives
  MOV  DvcDriverHdr.DHNumDrives,AL ;  into out Device Driver Header
I90:                               ;Done
  POP  DX,BX,AX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE FORMAT FILLER BYTE
;Inputs:  DS = ES = TSR Data Area
;Outputs:
;------------------------------------------------------------------------------
GetFormatFiller:
  PUSH AX,BX,ES          ;Save used registers
  MOV  AX,351Eh          ;AH = Function = 35h (Get Interrupt Vector)
                         ;AL = INT # = 1Eh = Floppy Disk Parameters
  INT  21h               ;Do it (returns ES:[BX])
  MOV  AL,ES:[BX].Int1EFormatFiller ;Get the Filler Byte
  MOV  FormatFillByte,AL            ;  data
  POP  ES,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FILL IN THE INT 13h DRIVE NUMBERS FOR A TSR
;Inputs:  DS = ES = TSR Data Area
;Outputs: Fills in Disk Info Entries with INT 13h Drive Numbers
;Changes:
;NOTES: We use the INT 13h "Check Ready" function to see if an INT 13h Drive
;         Number is already being used or not.  Some BIOSes don't set CF
;         correctly on return, so we can't use that as a viable error test
;         (even though we should be able to).  Instead, we need to test AH
;         on return for the Error Code. If it's anything other than 1
;         (Invalid Parameter), we'll assume that it's a valid Drive Number
;         and that we can't use it.
;       Even if we don't get any Drive Numbers (which I don't think will ever
;         happen), we can still install as a TSR, but need to warn the user
;         that they can't use INT 13h Functions to access the USB disks.
;         Our Device Driver code does not use INT 13h Functions, it issues
;         USB requests directly, so we don't need any INT 13h Drive Numbers
;         to give DOS access to the drives.
;------------------------------------------------------------------------------
GetInt13DriveNums:
  PUSH AX,DX,DI               ;Save used registers
  MOV  DI,DiskInfoOffset      ;[DI] = Table to fill in
  MOV  DH,B NumDisks[0]       ;DH = Number of Table Entries
  MOV  DL,80h                 ;DL = Physical Disk Number
V10:                          ;Loop to here for each Drive
  MOV  AH,I13CmdCheckReady    ;AH = Function = Check Ready
  INT  13h                    ;Do it
  CMP  AH,I13ErrInvalidFunc   ;Is it a Valid Drive Number?
  JNE >V30                    ;If so, we can't use it
V20:                          ;Drive Number is Invalid = we can use it
  MOV  [DI].DskInt13DrvNum,DL ;Store the Drive Number
  ADD  DI,DiskInfoSize        ;Point at the next Table Entry
  DEC  DH                     ;Decrement the Loop Counter
  JZ  >V90                    ;If the Table is full, we're done
V30:                          ;Done with this Drive
  INC  DL                     ;Go to the next drive
  CMP  DL,0FEh                ;Done all of them yet?
  JBE  V10                    ;If not, keep testing
V90:                          ;Done
  POP  DI,DX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SETUP THE FIXED DRIVE PARAMETER TABLES, IF APPROPRIATE
;Inputs:  DS = ES = TSR Data Area
;         DiskInfoTable already filled in with Int 13h Drive Numbers
;Outputs: OldInt41Vect, OldInt46Vect
;         FDPT80h, FDPT81h
;         As Appropriate
;Changes:
;------------------------------------------------------------------------------
SetupFDPTs:
  PUSH AX,BX,DI,SI             ;Save used registers
  MOV  BX,DiskInfoOffset       ;[BX] = First Disk Info Entry
  CMP  [BX].DskInt13DrvNum,81h ;Is it the first or second hard drive?
  JA  >P90                     ;If not, we're done
  JE  >P20                     ;If the second, handle it
P10:                           ;First USB Drive is 80h
  MOV  AL,41h                  ;Work with
  MOV  SI,OFFSET OldInt41Vect  ;  Interrupt
  MOV  DI,FDPT80h              ;  41h
  MOV  W [SI+2],ES             ;Initialize the
  MOV  W [SI],DI               ;  Vector Data
  CALL CopyFDPT10MB            ;Initialize the Table Data
  CALL SwapIntVect             ;Swap the Interrupt Vector
  ADD  BX,DiskInfoSize         ;Point at the second Disk Entry
  CMP  [BX].DskInt13DrvNum,81h ;Is it the second hard drive?
  JNE >P90                     ;If not, we're done
P20:                           ;Fill in second drive
  MOV  AL,46h                  ;Work with
  MOV  SI,OFFSET OldInt46Vect  ;  Interrupt 46h
  MOV  DI,FDPT81h              ;  41h
  MOV  W [SI+2],ES             ;Initialize the
  MOV  W [SI],DI               ;  Vector Data
  CALL CopyFDPT10MB            ;Initialize the Table Data
  CALL SwapIntVect             ;Swap the Interrupt Vector
P90:                           ;Done
  POP  SI,DI,BX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESTORE THE FIXED DRIVE PARAMETER TABLES TO THEIR ORIGINAL STATE
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         ES:OldInt41Vect, ES:OldInt46Vect
;Outputs: Restores INT 41h & INT 46h Vectors if we changed them
;Changes:
;------------------------------------------------------------------------------
RestoreFBPTs:
  PUSH AX,SI,DS               ;Save used registers
  MOV  DS,ES                  ;DS = TSR Data Area
R10:                          ;Restore first Drive
  MOV  AL,41h                 ;Work with
  MOV  SI,OFFSET OldInt41Vect ;  INT 41h Vector
  CMP  W [SI],-1              ;Did we replace this Vector?
  JE  >R20                    ;If not, try the other one
  CALL SwapIntVect            ;If so, restore it
R20:                          ;Restore second Drive
  MOV  AL,46h                 ;Work with
  MOV  SI,OFFSET OldInt46Vect ;  INT 41h Vector
  CMP  W [SI],-1              ;Did we replace this Vector?
  JE  >R90                    ;If not, we're done
  CALL SwapIntVect            ;If so, restore it
R90:                          ;Done
  POP  DS,SI,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADJUST/RESTORE THE NUMBER OF PHYSICAL HARD DRIVES IN THE BIOS DATA AREA
;Inputs:
;Outputs:
;Changes: Changes the Number of Hard Drives Entry in the BIOS Data Area
;           (0040:0075h)
;------------------------------------------------------------------------------
AdjustBIOSData:
  PUSH DX,DS          ;Save used registers
  MOV  DX,0040h       ;Point DS at
  MOV  DS,DX          ;  the BIOS Data Area
  CALL GetNumDrivesDL ;DL = Number of Hard Drives
  MOV  [0075h],DL     ;Adjust the BIOS Value
  POP  DS,DX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADJUST/RESTORE THE NUMBER OF BLOCK DEVICES IN THE LIST OF LISTS
;Inputs:  ES = TSR Data Area
;Outputs:
;Changes: Changes the Number of Block Devices in the List of Lists
;NOTES: I don't know if this actually does anything or not, but we'll try
;         it to see if it fixes any problems
;------------------------------------------------------------------------------
AdjustNumBlkDvcs:
  PUSH AX                        ;Save used registers
  MOV  AL,B ES:NumDrives[0]      ;AL = Value to add
  JMP >K00                       ;Do it
RestoreNumBlkDvcs:
  PUSH AX                        ;Save used registers
  MOV  AL,B ES:NumDrives[0]      ;AL =
  NEG  AL                        ;  Value to add
;  JMP >K00                       ;Do it
K00:
  PUSH BX,ES                     ;Save used registers
  MOV  AH,52h                    ;Function 52h (Get List of Lists)
  INT  21h                       ;Do it (ES:[BX])
  ADD  ES:[BX].LOLNumBlockDvc,AL ;Adjust the LOL Value
  POP  ES,BX                     ;Restore used registers
  POP  AX                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;REMOVE ALL OF OUR CDS ENTRIES
;Inputs:  ES = TSR Data Area
;         DS = Local Data Area
;         GetLOLPointers already issued (Pointers already copied)
;         Verified that we are no tthe current drive
;Outputs: Removes all of our CDS entries
;Changes:
;------------------------------------------------------------------------------
;Verify they have not been ASSIGNed or SUBSTd, and are otherwise still valid
;Must do this before we remove DPBs, since DPB's will have data we need to
;  find the correct CDSs

;For now, let's assume that we don't need to worry about ASSIGNed, SUBSTed, or
;  JOINed drives (that the appropriate programs simply look at the
;  CDS/DPB/whatever tables to see what they have done.  Let's simply assume
;  that when we remove our entries that they can adjust themselves
;  accordingly.  If that turns out to be a problem (I suspect it will),
;  we'll not be able to uninstall.  But, we need to experiment first.


RmvOurCDSs:
  PUSH AX,CX,DI,DS            ;Save used registers
  MOV  CX,ES                  ;CX = TSR Data Area
  MOV  AL,2                   ;Start with CDS for C: Drive (Index 2)
  LDS  DI,ES:FirstCDSPtr      ;[DI] = CDS
  ADD  DI,(CDSSize * 2)       ;  for C:
V10:                          ;Loop to here for each CDS
  CMP  W [DI].CDSDPBPtr[2],CX ;Is it one of ours?
  JNE >V30                    ;If not, skip it
  CALL ResetCDS               ;If it is, Reset It
  MOV  D [DI].CDSDPBPtr,0     ;Point it at nothing
V30:                          ;Done with this CDS
  ADD  DI,CDSSize             ;Point at the next entry
  INC  AL                     ;Increment the Index
  CMP  AL,CS:NumAvailDrv      ;Done with all of them yet?
  JB   V10                    ;If not, keep looking
  POP  DS,DI,CX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESET A CDS TO A NORMAL (UNUSED) STATE
;Inputs:  ES = TSR Data Area
;         GetLOLPointers already issued (Pointers already copied)
;         AL = Drive Number (Index) of CDS to Reset
;Outputs: Resets all appropriate CDS Values
;Changes:
;NOTES: This is done when a USB Device is removed, so we need to keep some
;         "basic" information (like the DPB Pointer) intact.  We basically
;         just want the drive to look like it's never been installed.
;------------------------------------------------------------------------------
ResetCDS:
  PUSH EAX,BX,DS                 ;Save used registers
  MOV  AH,CDSSize                ;Calculate the
  MUL  AH                        ;  Drive Offset
  LDS  BX,ES:FirstCDSPtr         ;[BX] =
  ADD  BX,AX                     ;  CDS Entry to Reset
  XOR  EAX,EAX                   ;Set things to zero mostly
  MOV  B [BX].CDSPathName[3],AL  ;Path = Root
  MOV  [BX].CDSDriveAttr,AX      ;Attributes = Nothing
  ;Leave CDSDPBPtr Intact
  MOV  [BX].CDSCurrDirClust,-1   ;Current Directory Cluster = Unknown
  MOV  [BX].CDSRootOffset,2      ;Root Offset = 2
  MOV  [BX].CDSDeviceType,AL     ;DeviceType = 0
  MOV  [BX].CDSRedirBlockPtr,EAX ;Redirect Block Pointer = 0
  POP  DS,BX,EAX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;REMOVE ALL OF OUR DPB POINTERS FROM THE DPB CHAIN
;Inputs:  ES = TSR Data Area
;         DS = Local Data Area
;         GetLOLPointers already issued (Pointers already copied)
;         Verified that we are not the current drive
;Outputs: Removes all of our DPB's from the Chain
;Changes: Writes DPBNextDPBPtr as -1 (end of Chain)
;NOTES: This assumes that we are never the first DPB (which should always
;         be the case, since we can only be installed after the computer
;         has booted).
;------------------------------------------------------------------------------
RmvOurDPBsFromChain:
  PUSH EAX,BX,CX,ES                  ;Save used registers
  MOV  CX,ES                         ;ES = TSR Data Segment
  LES  BX,FirstDPBPtr                ;Get the First DPB Pointer
R10:                                 ;Loop to here for each Entry
  CMP  ES:[BX].DPBNextDPBPtr,-1      ;Is this the end of the Chain?
  JE  >R90                           ;If so, we're done
  CMP  W ES:[BX].DPBNextDPBPtr[2],CX ;Is the next one one of ours?
  JNE >R40                           ;If not, skip it
R20:                                 ;The next one is one of ours
  PUSH BX,ES                         ;Save registers momentarily
  LES  BX,ES:[BX].DPBNextDPBPtr      ;Point at the next DPB
  MOV  EAX,ES:[BX].DPBNextDPBPtr     ;Get it's next Pointer
  POP  ES,BX                         ;Restore registers
  MOV  ES:[BX].DPBNextDPBPtr,EAX     ;Store the pointer after us in previous DPB
  JMP  R10                           ;Keep looking
R40:                                 ;Done with this DPB
  LES  BX,ES:[BX].DPBNextDPBPtr      ;Point at the next DPB
  JMP  R10                           ;Keep looking
R90:                                 ;Done
  POP  ES,CX,BX,EAX                  ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO SAVE/INITIALIZE/RESTORE INTERRUPT VECTORS
;THIS CODE IS NEEDED IN EVERY PROGRAM THAT INTERCEPTS INTERRUPT VECTORS.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;INITIALIZE ALL APPROPRIATE INTERRUPT VECTORS TO OUR TSR CODE
;Inputs:  ES = Data area to store Interrupt Vectors in (Presumably a UMB)
;         CS = Data Area where Interrupt Number Table is stored
;         CLD Already Issued!
;Outputs:
;Changes: Various Int vectors
;------------------------------------------------------------------------------
ChangeInts:
  PUSH AX,DI,SI,DS    ;Save used registers
  MOV  DS,ES          ;Point DS at TSR Data Area
  MOV  SI,IntNumTable ;Point at our Interrupt Nubmer Table
C10:                  ;Loop to here for each table entry
  MOV  AL,CS:[SI]     ;Get Interrupt Number
  OR   AL,AL          ;Is it the end of the table?
  JZ  >C90            ;If so, we're done
  MOV  DI,CS:[SI+1]   ;If valid, get our Code Header Offset
  CALL ChangeInt      ;Point the Interrupt at our code
  ADD  SI,3           ;Point at the next table entry
  JMP  C10            ;Keep going until we're done
C90:                  ;Done with the Interrupt Table
  POP  DS,SI,DI,AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHANGE INTERRUPT VECTOR TO THIS PROGRAMS INTERRUPT ROUTINE, AND SAVE THE OLD
;Inputs:  DS:[DI] = Pointer to our new interrupt header
;         AL = Interrupt number to change
;Outputs:
;Changes: Interrupt vector
;------------------------------------------------------------------------------
ChangeInt:
  PUSH AX,BX,DX,ES            ;Save used registers
  CALL InitIntHdr             ;Initialize our Interrupt Header
  MOV  AH,35h                 ;Service 35h (Get interrupt vector)
  INT  21h                    ;Do it (returns ES:BX)
  MOV  W [DI].OldVector,BX    ;Save it
  MOV  W [DI].OldVector[2],ES ;  in [DI]
  LEA  DX,[DI].CodeJmp        ;Point DS:DX at our code address
  MOV  AH,25h                 ;Service 25h (Set interrupt vector)
  INT  21h                    ;Do it
  POP  ES,DX,BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE THE DATA IN A REMOVABLE INTERRUPT VECTOR HEADER
;Inputs:  DS:[DI] = Pointer to Our Interrupt Header Structure
;Outputs:
;Changes: The Interrupt Header Data
;------------------------------------------------------------------------------
InitIntHdr:
  MOV  [DI].HdwreRst,0CBh   ;Hardware Reset Code = CBh = RETF
  MOV  [DI].CodeJmp,10EBh   ;Jump to Real Code = EBh 10h = JMP ENDS
  MOV  [DI].Signature,424Bh ;Signature for Removable Vector Header = 424Bh
  MOV  [DI].EOIFlag,0       ;We will not be issuing EOI's
  MOV  [DI].HdwreJmp,0F4EBh ;Jump to Hardware Reset = EBh F4h = JMP HdwreRst
  RET

;------------------------------------------------------------------------------
;CHECK THE INTERRUPT VECTORS TO SEE IF THEY'VE BEEN REHOOKED BY ANOTHER PROGRAM
;Inputs:  ES = TSR Data area
;         CLD Already Issued!
;Outputs: CF = Clear if Vectors are OK (We can safely Uninstall our Program)
;            = Set if at least one Vector is unchangeably rehooked
;Changes:
;------------------------------------------------------------------------------
CompareInts:
  PUSH AX,DX,SI          ;Save used registers
  MOV  SI,IntNumTable    ;Point at our interrupt number table
C10:                     ;Loop to here for each table entry
  LODSB                  ;Get the Interrupt Number
  OR   AL,AL             ;Is it the end of the table?
  JZ  >C80               ;If so, we're done
  MOV  DX,[SI]           ;If valid, get our Code Header Offset
  ADD  DX,OFFSET CodeJmp ;Add the Offset to the actual Vector Address
  CALL CompareInt        ;Has it been unchangeably rehooked?
  JC  >C70               ;If so, we can't Uninstall our Program
  INC  SI,2              ;Point at the next table entry
  JMP  C10               ;Keep going until we're done
C70:                     ;At lest one Interupt has been rehooked
  STC                    ;Set the Rehooked flag
  JMP >C90               ;We're done
C80:                     ;Vectors can be Uninstalled
  CLC                    ;Set the OK flag
C90:                     ;We're done
  POP  SI,DX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COMPARE OUR INTERRUPT ADDRESS TO MEMORY SEE IF IT'S BEEN REHOOKED
;Inputs:  ES:[DX] = Vector address to test (our TSR's address)
;         AL = Interrupt number to test
;Outputs: CF = Clear if OK to remove
;         CF = Set if rehooked and can't be removed
;Changes:
;------------------------------------------------------------------------------
CompareInt:
  PUSH BX,CX,ES ;Save used registers
  MOV  CX,ES    ;Point CX:DX at our vector
  CALL FindInt  ;Look for it (returns ES:BX and CF
  POP  ES,CX,BX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESTORE ALL INTERRUPT VECTORS BACK TO THEIR ORIGINAL STATE
;Inputs:  ES = Data Area where original Vector information is stored
;         CLD already issued!
;Outputs:
;Changes: Various Int vectors
;------------------------------------------------------------------------------
RestoreInts:
  PUSH AX,DI,SI       ;Save used registers
  MOV  SI,IntNumTable ;Point at our Interrupt Nubmer Table
R10:                  ;Loop to here for each table entry
  LODSB               ;Get the Interrupt Number
  OR   AL,AL          ;Is it the end of the table?
  JZ  >R90            ;If so, we're done
  MOV  DI,[SI]        ;If valid, get our Code Header Offset
  CALL RestoreInt     ;Restore Interrupt Vector back to original
  INC  SI,2           ;Point at the next table entry
  JMP  R10            ;Keep going until we're done
R90:                  ;We're done
  POP  SI,DI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESTORE INTERRUPT VECTOR TO ITS ORIGINAL PLACE
;Inputs:  ES:[DI] = Pointer to our Interrupt Header
;         AL = Interrupt number to restore
;Outputs:
;Changes: Interrupt vector back to where it belongs
;Notes:   If we got to here, nothing should have intercepted
;           an interrupt that we haven't checked for.
;         We shouldn't have to worry about running into a road-block!
;------------------------------------------------------------------------------
RestoreInt:
  PUSHF                          ;Save flags
  PUSH BX,CX,DX,SI,BP,ES         ;Save used registers
  MOV  SI,W ES:[DI].OldVector    ;Put the address we'll need to store
  MOV  BP,W ES:[DI].OldVector[2] ;  in BP:SI
  MOV  CX,ES                     ;Point CX:DX
  LEA  DX,[DI].CodeJmp           ;  at our address
  CALL FindInt                   ;Search for it (returns ES:BX)
  CLI                            ;Disable interrupts
  MOV  ES:[BX],SI                ;Store the
  MOV  ES:[BX+2],BP              ;  address
  POP  ES,BP,SI,DX,CX,BX         ;Restore used registers
  POPF                           ;Restore flags
  RET

;------------------------------------------------------------------------------
;SEARCH FOR AN INTERRUPT VECTOR ADDRESS (TO SEE IF OUR CODE CAN BE REMOVED)
;Inputs:  CX:DX = Interrupt Vector address to find (address of our TSR code)
;         AL = Interrupt number to find
;Outputs: CF = Clear if OK to remove
;           ES:BX = address where it is stored
;         CF = Set if rehooked and can't be removed
;           ES:BX = unknown state
;Changes:
;------------------------------------------------------------------------------
FindInt:
  PUSH AX                                ;Save used registers
  XOR  AH,AH                             ;Point ES:BX
  ADD  AX,AX                             ;  at the
  ADD  AX,AX                             ;  main
  MOV  BX,AX                             ;  interupt
  XOR  AX,AX                             ;  vector
  MOV  ES,AX                             ;  table
  CMP  ES:[BX],DX                        ;Is the offset the same as ours?
  JNE >F20                               ;If not, it can't be ours
  CMP  ES:[BX+2],CX                      ;Is the segment the same as ours?
  JE  >F80                               ;If so, it's ours - we're done
F20:                                     ;The main interrupt vector has changed
  LES  BX,ES:[BX]                        ;Get the current vector address
F30:                                     ;Loop for each removable interrupt
  CALL TestIntHdr                        ;Is this a removable interrupt?
  JC  >F70                               ;If not, we can't be removed
  CMP  W ES:[BX-IntOfst].OldVector,DX    ;If so, is the old offset ours?
  JNE >F50                               ;If not, keep looking
  CMP  W ES:[BX-IntOfst].OldVector[2],CX ;If so, is old segment ours?
  JNE >F50                               ;If not, keep looking
  ADD  BX,(OFFSET OldVector) - IntOfst   ;If so, ES:BX = old vector pointer
  JMP >F80                               ;And we're done
F50:                                     ;Removable, but doesn't point at us
  LES  BX,ES:[BX-IntOfst].OldVector      ;Get its old vector address
  JMP  F30                               ;And keep looking for our vector
F70:                                     ;Been rehooked and can't be removed
  STC                                    ;Set the "rehooked" flag
  JMP >F90                               ;We're done
F80:                                     ;It's not rehooked, or it's removable
  CLC                                    ;Set the "OK to remove" flag
F90:                                     ;We're done
  POP  AX                                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN INTERRUPT POINTER TO SEE IF IT'S REMOVABLE
;Inputs:  ES:BX = Interrupt Vector to test
;Outputs: CF = Set if it's not a removable vector
;            = Clear if it is removable
;Changes:
;Notes:   The references to [BX-IntOfst] instead of [BX] are because of
;           our "unusual" Interrupt Header Structure design
;         We have included the (unneeded) Hardware Reset Routine code
;           (a simple RETF) in our Header Structure for efficiency
;------------------------------------------------------------------------------
TestIntHdr:
  PUSH AX,BX,DS                      ;Save used registers
  MOV  DS,ES                         ;Point DS at the interrupt segment
  CMP  B [BX-IntOfst].CodeJmp,0EBh   ;Is the first instruction a Short JMP?
  JNE >H70                           ;If not, it's not removable
  CMP  [BX-IntOfst].Signature,0424Bh ;Is there a Removeable Interrupt Signature?
  JNE >H70                           ;If not, it's not removable
  MOV  AL,[BX-IntOfst].EOIFlag       ;Get the EOI flag
  OR   AL,AL                         ;Is it zero?
  JZ  >H10                           ;If so, continue checking
  CMP  AL,80h                        ;Is it 80h?
  JNE >H70                           ;If not, it's not removable
H10:                                 ;EOI flag is OK
  CMP  B [BX-IntOfst].HdwreJmp,0EBh  ;Is the HdwreJmp instruction a Short JMP?
  JE  >H80                           ;If so, it's removable!
H70:                                 ;Vector is not removable
  STC                                ;Set the "not removable" flag
  JMP >H90                           ;We're done
H80:                                 ;Vector is removable
  CLC                                ;Set the "removable" flag
H90:                                 ;We're done
  POP  DS,BX,AX                      ;Restore used registers
  RET

;;------------------------------------------------------------------------------
;;TEST AND SEE IF AN INTERRUPT VECTOR HAS A VALID ADDRESS (other than 0)
;;Inputs:  AL = Interrupt number to test
;;Outputs: ZF = Set if invalid address (Segment = 0)
;;            = Clear if valid address (Segment <> 0)
;;Changes:
;;------------------------------------------------------------------------------
;TestInt:
;  PUSH BX,DS      ;Save used registers
;  XOR  BX,BX      ;Point DS at the
;  MOV  DS,BX      ;  Interrupt Table
;  MOV  BL,AL      ;Point BX
;  SHL  BX,1       ;  at the Interrupt
;  SHL  BX,1       ;  we're looking for
;  CMP  W [BX+2],0 ;Is the Segment valid (set the return flag)?
;  POP  DS,BX      ;Restore used registers
;  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO CHANGE INTERRUPT VECTORS TO/FROM OUR CODE
;The code above is used for "regular" interrupt vectors, where we want to
;  use the IBM Interrupt Sharing Protocol.  This code is used when the
;  pointer in the Interrupt Vector Table is not a real Interrupt Vector
;  (points at an Interrupt Service Routine),  but rather is a pointer to
;  some sort of table.
;In this program (USBDRIVE), Interrupts 41h & 46h are not real Interrupt
;  Vectors, but rather pointers to Fixed Disk parameter Tables (FDPTs).
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;-----------------------------------------------------------------------------
;SWAP OR CHANGE INTERRUPT VECTOR TO/FROM OUR CODE
;Inputs:  AL = Interrupt Number to Change
;         DS:[SI] = What we want it swapped with
;Outputs:
;Changes: Interrupt vector ->, <-, or <-> New Address
;-----------------------------------------------------------------------------
SwapIntVect:
  PUSH CX              ;Save used register
  XOR  CL,CL           ;If Swap, CL=00
;  JMP >V10             ;Jump to do it
;MoveToIntVect:
;  PUSH CX              ;Save used register
;  MOV  CL,01           ;If Move To, CL=01
;  JMP >V10             ;Jump to do it
;MoveFromIntVect:
;  PUSH CX              ;Save used register
;  MOV  CL,02           ;If Move From, CL=02
;;  JMP >V10             ;Jump to do it
V10:                   ;Swap or change Int vect
  PUSH AX,DI,SI,ES     ;Save used registers
  MOV  CH,AL           ;Save Int # in CH
  XOR  AX,AX           ;AX=0000
  MOV  ES,AX           ;ES=0000 (Int Vector Table)
  MOV  AL,CH           ;Get Int # Back
  ADD  AX,AX           ;Multiply Int #
  ADD  AX,AX           ;  by 4 (to get offset)
  MOV  DI,AX           ;Put it in DI
  CLI                  ;Disable Interrupts
  CALL ChangeIntVectDo ;Change the IP
  INC  SI,2            ;Point to New CS
  INC  DI,2            ;Point to old CS
  CALL ChangeIntVectDo ;Change the CS
  STI                  ;Enable Interrupts
  POP  ES,SI,DI,AX     ;Restore used registers
  POP  CX              ;Restore used register
  RET

;-----------------------------------------------------------------------------
;SWAP OR CHANGE ES:[DI] TO/FROM DS:[SI]
;Inputs:  CL=00 ES:[DI] <-> DS:[SI]
;         CL=01 ES:[DI] <-  DS:[SI]
;         CL=02 ES:[DI]  -> DS:[SI]
;Outputs:
;Changes: AX
;-----------------------------------------------------------------------------
ChangeIntVectDo:
  CMP  CL,02      ;Are we Moving From?
  JNE >D10        ;If so, skip the next few steps
  MOV  AX,ES:[DI] ;If no, put old vector in AX
  JMP >D20        ;Jump to change it
D10:              ;Move to or Swap
  MOV  AX,[SI]    ;If Move To or Swap, Put New Vector in AX
  XCHG AX,ES:[DI] ;Swap new & old vectors
  CMP  CL,01      ;Are we Moving To?
  JE  >D90        ;If so, skip the next step
D20:              ;Move from or Swap
  MOV  [SI],AX    ;If Move From or Swap, Put old vector in DS:[BX]
D90:              ;We're done
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED TO SET UP AND DO SCREEN PAUSES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SETUP PARAMETERS FOR DOING A SCREEN PAUSE (FOR PRINTING A LARGE TABLE)
;Inputs:  DS = Local Data Area
;         DS:[DX] = ASCIIZ Header to Print at top of each screen
;                   Last character of the Header MUST be an LF
;                   If SetupPauseNoHdr, we "inject" NoMsg as the Header
;Outputs: Pauses the screen with a MORE message every time it gets full
;NOTES:   If a Screen Header is really large (almost taking up the whole
;           screen itself, with little room for data), this procedure
;           may not work correctly.  This procedure does not validate
;           the size of the Header -- it simply assumes that it is a
;           "reasonable" size compared to the size of the screen.  Most
;           anything that needs a Screen Header (a long data table) will
;           only have a few lines of Header, so this should be OK as a
;           general purpose procedure.
;         After this Setup is complete (which should be near the beginning
;           of MAIN, before anything is sent to the screen), WriteZPause
;           must be called for ALL screen writing to CON:, not WriteZCon!
;         The Pausing occurs in "real time", meaning we can send things
;           to the Pause routine a byte, line, or several screens at a
;           time for processing.  Because we do it in "real time",
;           we can end up with extra MORE's and screen Headers appearing
;           on screen than are actually needed.  During a screen
;           transition (or a transition to a new Header) whether we
;           actually need to write anything or not depends on if there
;           is actually any real data coming afterward (in time), which
;           of course we don't know (since it hasn't happened yet).
;           So, we must assume there is more data to come and process the
;           MORE's and Screen Headers accordingly.  This only causes problems
;           (in the form of extraneous MORE's and Screen Headers)
;           when things happen near the bottom of the screen.
;           DOS's MORE utiltiy (and other programs of similar ilk) do not
;           process in "real time", but rather store things in a Temporary
;           File and then process the file.
;------------------------------------------------------------------------------
SetupPauseNoHdr:
  PUSH DX         ;Save used registers
  MOV  DX,NoMsg   ;Point at 0-length Message
  CALL SetupPause ;Setup the Pause
  POP  DX         ;Restore used registers
  RET

SetupPause:
  PUSH AX,BX,CX,DI,SI     ;Save used registers
  MOV  SI,OFFSET PauseHeaderPtr ;Point [SI] at PauseHeaderPtr
  CMP  W [SI],-1          ;Has the user already cancelled us?
  JE  >S90                ;If so, just quit
  CMP  W [SI],0           ;Has the user stopped pausing already?
  JE  >S85                ;If so, just write the header
  CALL TestRedir          ;Is our output redirected?
  JNC >S10                ;If not, setup our Headers
  MOV  W [SI],0           ;Mark as Redirected or Pausing Stopped/Disabled
  JMP >S85                ;Jump to write the Header and Quit
S10:                      ;Output not redirected
  CALL GetScreenRows      ;Store the number of rows
  MOV  PauseRows,AX       ;  on the screen
  CALL CountZLinesCX      ;Calculate the number of lines
  INC  CX,2               ;  in the new Header
  MOV  DI,PauseRowCount   ;Get the Current Row count
  ADD  DI,CX              ;Add the size of the new header
  SUB  DI,3               ;Adjust for Headers
  DEC  AX                 ;Will writing the new Header
  CMP  DI,AX              ;  cause a Pause event?
  JB  >S50                ;If not, handle it
S20:                      ;New Header is too big to fit on screen
  MOV  W [SI],NoMsg       ;Point Header for second page at nothing
  MOV  PauseHeaderSize,2  ;Set Pause Header Size
  PUSH CX                 ;Save New Header Size
  SUB  AX,PauseRowCount   ;Calculate how many rows to fill up the screen
  MOV  CX,AX              ;Put number of rows in CX
  INC  CX                 ;Adjust it
S30:                      ;Loop to here to fill up the screen
  CALL WriteCrLfPause     ;Write a new line
  LOOP S30                ;Keep going until we're done
  POP  CX                 ;Restore New Header Size
  CMP  W [SI],-1          ;Did the user cancel during the header transition?
  JE  >S90                ;If so, we're done
  CMP  W [SI],0           ;Did the user stop Pausing during the transition?
  JE  >S85                ;If so, just write the Header
S50:                      ;Need to adjust current Row Count
  SUB  PauseRowCount,2    ;Adjust things for the previous Header
S80:                      ;Store new Header Info
  MOV  [SI],DX            ;Store the Header Address
  MOV  PauseHeaderSize,CX ;Store the Header Size
  ADD  PauseRowCount,CX   ;Add the Header Size to the Row Count
  MOV  AX,PauseRows       ;Compensate if
  CMP  AX,PauseRowCount   ;  the new header
  JAE >S85                ;  put us past
  DEC  AX                 ;  the end
  MOV  PauseRowCount,AX   ;  of hte screen
S85:                      ;Write Header
  CALL WriteZCon          ;Write the Header
S90:                      ;We're done
  POP  SI,DI,CX,BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHECK TO SEE IF STDOUT HAS BEEN REDIRECTED
;Inputs:
;Outputs: CF = Clear if STDOUT is normal (usually the screen)
;            = Set if STDOUT been redirected
;Changes:
;------------------------------------------------------------------------------
TestRedir:
  PUSH AX,BX,DX        ;Save used registers
  MOV  AX,4400h        ;Function 4400h (Get Device Info)
  MOV  BX,StdOutHandle ;Device = STDOUT
  INT  21h             ;Do it (returns DX, changes AX)
  JC  >R80             ;If error, assume not Redirected
  AND  DL,(DvcInfoIsDevice+DvcInfoIsStdOut) ;Mask out unwanted bits
  CMP  DL,(DvcInfoIsDevice+DvcInfoIsStdOut) ;Is it still the STDOUT Device?
  JE  >R80             ;If so, it's not Redirected
R70:                   ;STDOUT has been Redirected
  STC                  ;Set the Redirected flag
  JMP >R90             ;Done
R80:                   ;STDOUT is not Redirected
  CLC                  ;Set the Not-Redirected flag
R90:                   ;Done
  POP  DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NUMBER OF VIDEO ROWS ON THE SCREEN
;Inputs:
;Outputs: AX = Number of text rows on the screen
;                (usually 25, 43, or 50)
;Changes:
;------------------------------------------------------------------------------
GetScreenRows:
  PUSH BX,CX,DS  ;Save used registers
  MOV  AX,40h    ;Point ES to
  MOV  DS,AX     ;  BIOS data area
  MOV  AH,12h    ;Function 12h (EGA Alternate Select)
  MOV  BX,0FF10h ;Subfunction (BL) 10h (Return EGA information)
                 ;  Preset unrealistic return value (BH)
  INT  10h       ;Do it (returns AX, BX, CX)
  CMP  BL,10h    ;Is the function supported (EGA or better)?
  JE  >R50       ;If not, jump to handle MDA/CGA
  CMP  BH,0FFh   ;Is the return value valid?
  JE  >R50       ;If not, jump to handle MDA/CGA
  TEST B [87h],8 ;If so, is bit 3 of the EGA information byte set?
  JNZ >R50       ;If so, EGA is not the active display
  XOR  AX,AX     ;Get # of
  MOV  AL,[84h]  ;  rows - 1
  JMP >R90       ;We're done
R50:             ;Video card is less than EGA (MDA or CGA)
  MOV  AX,24     ;Number of rows must be 25
R90:             ;We're done
  INC  AX        ;Bump the number of rows by 1
  POP  DS,CX,BX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ASCIIZ STRING(s) TO THE SCREEN, PAUSING WHEN IF NECESSARY
;Inputs:  DS:[DX] = String to write
;         PauseRows, PauseHeaderPtr, PauseHeaderSize, PauseRowCount,
;         Indent
;         CS = Local Data Area
;Outputs: PauseRowCount
;Changes: Pauses the screen and waits for user input, if necessary
;NOTES: This should be called instead of WriteZCon every time something
;         is written during the Pausing.
;       A string can be written by WriteZCon during the pausing, as long
;         as the string does not contain a Line Feed.  Any line containing
;         a Line Feed must come through here or the Line Count will get
;         screwed up!
;------------------------------------------------------------------------------
WriteZPauseFar:
  CMP  CS:Indent,0  ;Do we need to worry about indents?
  JE  >F50          ;If not, just write things verbatim
F10:                ;Need to process indents
  PUSHF             ;Save flags
  CLD               ;Go forward with string functions
  PUSH AX,CX,SI     ;Save used registers
  MOV  SI,DX        ;[SI] = String to Write
  MOV  CL,CS:Indent ;CL = Number of spaces to Indent
F20:                ;Loop to here for each character in the string
  LODSB             ;Get the next character
  OR   AL,AL        ;End of String?
  JZ  >F40          ;If so, we're done
  PUSH DS           ;If not, save string segment
  MOV  DS,CS        ;DS = Local Data Area
  CALL WriteAL      ;Write the character
  CMP  AL,LF        ;Was it a Line Feed?
  JNE >F30          ;If not, continue
  CALL WriteSpaces  ;If so, write the indent
F30:                ;Done writing the character
  POP  DS           ;Restore string segment
  JMP  F20          ;Keep going until we're done
F40:                ;Done processing the Indented String
  POP  SI,CX,AX     ;Restore used registers
  POPF              ;Restore flags
  JMP >F90          ;Done
F50:                ;Write the string verbatim
  CALL WriteZPause  ;Write the string
F90:                ;Done
  RETF

WriteZPause:
  PUSH AX,BX,CX,DX          ;Save used registers
  MOV  AX,CS:PauseHeaderPtr ;Put Header Pointer in AX
  CMP  AX,-1                ;Has the Output been cancelled by the user?
  JE  >P90                  ;If so, don't write anything at all
  OR   AX,AX                ;Is STDOUT Redirected?
  JZ  >P80                  ;If so, just write it with no Pausing
  CALL CountZLinesCX        ;Count how many Lines are in the string
  MOV  AX,CS:PauseRowCount  ;Add the new lines
  ADD  AX,CX                ;  to the current lines
  CMP  AX,CS:PauseRows      ;Will we be at or past the end of the screen?
  JB  >P70                  ;If not, just write it
  JE  >P20                  ;If at the end of the screen, handle it
  SUB  AX,CS:PauseRows      ;If not, find
  SUB  CX,AX                ;  the end of the String
  CALL FindEndOfLines       ;  we need to write ([BX])
  MOV  AL,[BX]              ;Save the character that's there now
  MOV  B [BX],0             ;Replace it with a 0
  CALL WriteZPause          ;Write it (will Pause correctly)
  MOV  [BX],AL              ;Restore original character
  MOV  DX,BX                ;Use the new string pointer
  CALL WriteZPause          ;Write it (Pausing if necessary)
  JMP >P90                  ;Done
P20:                        ;At end of screen
  CALL WriteZCon            ;Write the String
  CALL HandlePause          ;Handle the Pause (may change Pointers/Counters)
  JMP >P90                  ;We're done for now
P70:                        ;Store new Row Count
  MOV  CS:PauseRowCount,AX  ;Save the new Row Count
P80:                        ;Write the String
  CALL WriteZCon            ;Write the string
P90:                        ;Done
  POP  DX,CX,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE PAUSE LINE, AND WAIT FOR A KEYSTROKE
;Inputs:  CS = Local Data Area
;         PauseRows, PauseHeaderPtr, PauseHeaderSize, PauseRowCount
;Outputs: PauseRowCount, PauseHeaderPtr
;Changes: Pauses the screen and waits for user input, if necessary
;------------------------------------------------------------------------------
HandlePause:
  PUSH AX,BX,DX,DS        ;Save String Segment
  MOV  DS,CS              ;Point DS at our Data Segment
  MOV  BX,OFFSET PauseHeaderPtr ;Point [BX] at the Pause Header
  MOV  DX,PauseMsg        ;Write the
  CALL WriteZCon          ;  Enter a Keystroke message
  CALL FlushKbdBuff       ;Clear the keyboard buffer
L10:                      ;Loop to here to wait for a keystroke
  CALL GetKey             ;Is there a key in the keystroke buffer?
  JZ   L10                ;If not, keep waiting until there is
  MOV  DX,PauseDMsg       ;Delete the
  CALL WriteZCon          ;  MORE Message
  CMP  AL,CtrlC           ;Was the keystroke a Control-C?
  JE  >L40                ;If so, jump to handle it
  CMP  AL,Escape          ;Was the keystroke an Escape?
  JNE >L20                ;If not, just keep going
  MOV  W [BX],0           ;If so, mark us as redirected (stop Pausing)
  JMP >L90                ;And quit
L20:                      ;Continue with the Pause
  MOV  DX,PauseNMsg       ;Write the
  CALL WriteZCon          ;  MORE Replacement Line
  MOV  DX,[BX]            ;Point DX at the Header
  CALL WriteZCon          ;Write it
  MOV  AX,PauseHeaderSize ;Reset the Row Count
  MOV  PauseRowCount,AX   ;Store the new Row Count
  JMP >L90                ;We're done for now
L40:                      ;Ctrl-C (stop altogether)
  MOV  W [BX],-1          ;Mark as stopped
L90:                      ;Done
  POP  DS,DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE NUMBER OF LINES IN AN ASCIIZ STRING (COUNT CR/LF COMBINATIONS)
;Inputs:  DS:[DX] = Pointer to String to measure
;         CLD already issued
;Outputs: CX = Number of LF's in the String (may be 0)
;         ZF = Set if CX = 0
;            = Clear if CX > 0
;Changes:
;------------------------------------------------------------------------------
CountZLinesCX:
  PUSH AX,SI ;Save used registers
  MOV  SI,DX ;Put the pointer in DI
  XOR  CX,CX ;Initialize Lines Counter
Z10:         ;Loop to here for each character
  LODSB      ;Get the next character
  OR   AL,AL ;Is it the end of the string?
  JZ  >Z90   ;If so, we're done
  CMP  AL,LF ;Is it a Line Feed?
  JNE  Z10   ;If not, it's not a new line
  INC  CX    ;If so, Increment the Line Counter
  JMP  Z10   ;Keep looking
Z90:         ;We're done
  OR   CX,CX ;Set return flag
  POP  SI,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE POINTER AFTER THE FIRST SEVERAL LINES OF A STRING
;Inputs:  DS:[DX] = String to use
;         CX = Number of lines to "skip"
;         CLD already issued
;Outputs: DS:[BX] = "New" String Pointer (after the last line written)
;Changes:
;NOTES: This assumes that the string actually has MORE than the number of
;         lines in AX (it does not look for the end of an ASCIIZ string).
;------------------------------------------------------------------------------
FindEndOfLines:
  PUSH AX,CX  ;Save used registers
  PUSH DI,ES  ;Save used registers
  MOV  BX,CX  ;BX = Line Counter
  MOV  ES,DS  ;Point ES:[DI] at
  MOV  DI,DX  ;  the string
  MOV  AL,LF  ;Look for Line Feeds
  MOV  CX,-1  ;Maximize counter
L10:          ;Loop to here for each new line
  REPNE SCASB ;Look for the end-of-line character
  DEC  BX     ;Decrement the Line Counter
  JNZ  L10    ;If not 0 yet, keep looking
  MOV  BX,DI  ;Store the new string beginning
L90:          ;Done
  POP  ES,DI  ;Restore used registers
  POP  CX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FLUSH KEYBOARD BUFFER
;Inputs:
;Outputs:
;Changes: Flushes the Keyboard Buffer
;------------------------------------------------------------------------------
FlushKbdBuff:
  PUSH AX     ;Save used registers
F10:          ;Loop to here for each key
  CALL GetKey ;Get a key from the keyboard buffer
  JNZ  F10    ;If there was one, get another
  POP  AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ CHARACTER FROM THE KEYBOARD BUFFER
;Inputs:
;Outputs: AH = Keyboard scan code
;         AL = ASCII value of keypress (0 if extended ASCII)
;         AX = 0 if no key is waiting
;Changes: ZF = Set if no key in buffer (AX = 0)
;            = Clear if a key was found (AX = key)
;------------------------------------------------------------------------------
GetKey:
  MOV  AH,1  ;Service 1 (Keystroke waiting?)
  INT  16h   ;Do It
  JZ  >K10   ;If no key waiting, we're done
  XOR  AH,AH ;If a key is waiting, service 0 (Get keystroke)
  INT  16h   ;Do It
  JMP >K90   ;We're done
K10:         ;No keystroke waiting
  XOR  AX,AX ;Make sure AX=0
K90:         ;We're done
  OR   AX,AX ;Set the found/not found flag
  RET

;------------------------------------------------------------------------------
;WRITE A CR/LF TO THE CONSOLE WITH A PAUSE
;Inputs:
;Outputs: To Screen, Updates Pause Counters
;Changes:
;------------------------------------------------------------------------------
WriteCrLfPause:
  PUSH DX          ;Save used registers
  MOV  DX,CrLfMsg  ;Write a Cr/Lf to
  CALL WriteZPause ;  the Pause Device
  POP  DX          ;Restore used registers
  RET

WriteCrLfPause2:
  CALL WriteCrLfPause ;Move down
  CALL WriteCrLfPause ;  2 lines
  RET

WriteCrLfErr:
  PUSH DX         ;Save used registers
  MOV  DX,CrLfMsg ;Write a Cr/Lf to
  CALL WriteZErr  ;  the ERR Device
  POP  DX         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SOME GENERIC CODE TO WRITE STRINGS, ETC.
;THIS CODE IS NEEDED IN ALMOST EVERY PROGRAM WE WRITE.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GETS RID OF ENVIRONMENT INFORMATION - NOT NEEDED IN TSR
;Inputs:
;Outputs:
;Changes: Quits if problem releasing memory
;------------------------------------------------------------------------------
DelEnvironment:
  PUSH AX,ES            ;Save used registers
  MOV  ES,[PSPEnvirSeg] ;Point ES at the Environment Segment
  MOV  AH,49h           ;Service 49h (free up memory)
  INT  21h              ;Do it
  JNC >E90              ;If no error occurred, Quit
  MOV  DX,NoEnvironMsg  ;If error, point to message
  MOV  AL,ErLvlMemory   ;Errorlevel = Memory Problem
  JMP  Exit             ;QUIT
E90:                    ;We're done
  POP  ES,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;BEEP THE SPEAKER
;Inputs:
;Outputs: Beeps the speaker
;Changes:
;------------------------------------------------------------------------------
BeepErr:
  PUSH AX,BX    ;Save used registers
  XOR  BX,BX    ;BH = Video page = 0
  MOV  AX,0E07h ;AH = 0Eh = Function = Write TTY
                ;AL = 07h = Character to write = BEL
  INT  10h      ;Do it
  POP  BX,AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CAPITALIZE A CHARACTER (Byte)
;Inputs:  AL = character to be capitalized
;Outputs: AL = capitalized character
;Changes:
;------------------------------------------------------------------------------
Capitalize:
  CMP  AL,'a'     ;Is it less than 'a'?
  JB  >C90        ;If so, quit
  CMP  AL,'z'     ;Is it more than 'z'?
  JA  >C90        ;If so, quit
  SUB  AL,'a'-'A' ;If between 'a' and 'z', capitalize it
C90:
  RET

;------------------------------------------------------------------------------
;WRITE A SPECIFIC CHARACTER OR SET OF CHARACTERS TO THE SCREEN
;Inputs:
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
WriteAL:
  PUSH DX              ;Save used registers
  MOV  DL,AL           ;Write what's in AL
  JMP >C00             ;Do it
WriteBlock:
  PUSH DX              ;Save used registers
  MOV  DL,'±'          ;Write a Block Character
  JMP >C00             ;Do it
WriteColon:
  PUSH DX              ;Save used registers
  MOV  DL,':'          ;Write a Colon
  JMP >C00             ;Do it
WriteComma:
  PUSH DX              ;Save used registers
  MOV  DL,','          ;Write a Comma
  JMP >C00             ;Do it
WriteDash:
  PUSH DX              ;Save used registers
  MOV  DL,'-'          ;Write a Hyphen
  JMP >C00             ;Do it
WriteDot:
  PUSH DX              ;Save used registers
  MOV  DL,'.'          ;Write a Period
  JMP >C00             ;Do it
WriteEquals:
  PUSH DX              ;Save used registers
  MOV  DL,'='          ;Write an Equals
  JMP >C00             ;Do it
WriteHexEnd:
  PUSH DX              ;Save used registers
  MOV  DL,'h'          ;Write an h
  JMP >C00             ;Do it
WriteNone:
  PUSH DX              ;Save used registers
  MOV  DX,NoneMsg      ;Point at Message
  JMP >C10             ;Do it
WriteSpace:
  PUSH DX              ;Save used registers
  MOV  DX,SpaceMsg     ;Point at Message
  JMP >C10             ;Do it
Write2Spaces:
  PUSH DX              ;Save used registers
  MOV  DX,Space2Msg    ;Point at Message
  JMP >C10             ;Do it
C00:
  MOV  SingleMsg[0],DL ;Put the character in the Single Character String
  MOV  DX,SingleMsg    ;Point at Single Character String
C10:                   ;DX is pointed at String
  CALL WriteZPause     ;Write the String
  POP  DX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE SOME SPACES TO THE SCREEN
;Inputs:  CL = Number of spaces to write
;         SpaceMsg
;Outputs: To the screen
;Changes:
;------------------------------------------------------------------------------
;WriteSpacesErr:
;  PUSH AX                 ;Save used registers
;  MOV  AL,-1              ;Mark as ERR
;  JMP >S00                ;Do it
WriteSpaces:
  PUSH AX                 ;Save used registers
  XOR  AL,AL              ;Mark as CON
;  JMP >S00                ;Do it
;S00:
  PUSH CX,DX              ;Save used registers
  OR   CL,CL              ;Should we write 0 spaces?
  JZ  >S90                ;If so, we're done
  XOR  CH,CH              ;If OK, change it to a word
  MOV  DX,SpaceMsg        ;Point at the message
  OR   AL,AL              ;Write to CON?
  JNZ >S30                ;If not, Handle ERR
S10:                      ;Loop to here for each space
  CALL WriteZPause        ;Write the space
  LOOP S10                ;Keep going until we're done
  JMP >S90                ;Done
S30:                      ;Write to Err
  CALL WriteZERR          ;Write the space
  LOOP S10                ;Keep going until we're done
S90:                      ;We're done
  POP  DX,CX              ;Restore used registers
  POP  AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT NIBBLE, BYTE, WORD,OR DWORD TO HEX CHARACTER STRING, AND WRITE IT
;Inputs:  AL/AX/EAX = Nibble/Byte/Word/DWord to be written
;         CLD must be set already!
;Outputs: Writes to the Screen
;Changes: HexString
;------------------------------------------------------------------------------
WriteDWordHex:
  ROR  EAX,16       ;Write the
  CALL WriteWordHex ;  High Word
  ROR  EAX,16       ;Write the
  CALL WriteWordHex ;  Low Word
  RET

;WriteNibbleHex:
;  PUSH BX             ;Save used registers
;  MOV  BX,3           ;Need to start of offset 3 in string
;  JMP >H00            ;Jump to do it
WriteByteHex:
  PUSH BX             ;Save used registers
  MOV  BX,2           ;Need to start of offset 2 in string
  JMP >H00            ;Jump to do it
WriteWordHex:
  PUSH BX             ;Save used registers
  XOR  BX,BX          ;Need to start of offset 0 in string
  JMP >H00            ;Jump to do it
H00:                  ;Start converting the strings
  PUSH DX,DI          ;Save used registers
  MOV  DI,HexString   ;Point DS:[DI] at HexString
  MOV  DX,DI          ;Point DS:[DX] at HexString
  CALL Word2HexString ;Convert the entire Word to a String
  ADD  DX,BX          ;Point DX at the beginning of where we write
  CALL WriteZPause    ;Write it
  POP  DI,DX          ;Restore used registers
  POP  BX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A BYTE OR WORD TO A HEXADECIMAL STRING (2 OR 4 CHARACTERS)
;Inputs:  AX = Word to Convert to a Hex String
;         DS = Local Data Area
;         [DI] = Where to Store the String
;         CLD already issued
;Outputs: DS:[DI]
;Changes: DI
;------------------------------------------------------------------------------
Byte2HexString:
  PUSH AX,ES            ;Save used registers
  MOV  ES,DS            ;Point ES:[DI] at the String
  CALL Word2HexString10 ;Convert it
  POP  ES,AX            ;Restore used registers
  RET

Word2HexString:
  PUSH AX,BX,ES         ;Save used registers
  MOV  BX,AX            ;Save original Word
  MOV  ES,DS            ;Point ES:[DI] at
  CALL Word2HexString00 ;Convert it
  POP  ES,BX,AX         ;Restore used registers
  RET

Word2HexString00:
  MOV  AL,BH            ;Convert High Byte
  CALL Word2HexString10 ;  to ASCII
  MOV  AL,BL            ;Work with Low Byte
Word2HexString10:       ;Convert Byte to ASCII
  AAM  10h              ;Separate Low & High Nibbles
  XCHG AH,AL            ;Put High Nibble in AL
  CALL Word2HexString20 ;Convert High Nibble to ASCII
  XCHG AH,AL            ;Work with Low Nibble
Word2HexString20:       ;Convert Nibble to ASCII
  ADD  AL,90h           ;Convert BCD
  DAA                   ;  to Decimal
  ADC  AL,40h           ;Convert Decimal
  DAA                   ;  to ASCII
  STOSB                 ;Store the Nibble
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE OR WORD TO THE SCREEN AS A DECIMAL
;Inputs:  AL/AX = Byte/Word to Write
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteByteMin:
  PUSH AX,BX         ;Save used registers
  XOR  AH,AH         ;Make sure high byte is 0
  MOV  BH,1          ;Mark as doing minimum
  JMP >W00           ;Do it
;WriteWordMin:
;  PUSH AX,BX         ;Save used registers
;  MOV  BH,1          ;Mark as doing minimum
;  JMP >W00           ;Do it
ByteToString:
  PUSH AX,BX         ;Save the original word & BP
  XOR  AH,AH         ;Make sure high byte is 0
  XOR  BH,BH         ;BH = No Minimum, Byte
  JMP >W00           ;Jump to start the loop
WordToString:
  PUSH AX,BX         ;Save the original word
  MOV  BH,2          ;BP = No Minimum, Word
W00:                 ;Do a word or a byte
  PUSH CX,DX,SI      ;Save used registers
  MOV  SI,SingleMsg  ;Point at the single character message
  XOR  BL,BL         ;Test for first non-zero character is false
  MOV  CX,10000      ;First divisor is 10,000
W20:                 ;Loop to here for each character
  XOR  DX,DX         ;High word of Dividend = 0
  DIV  CX            ;Divide DX:AX by current divisor
  OR   AX,AX         ;Is this a non-zero character?
  JNZ >W30           ;If so, we need to write it
  OR   BL,BL         ;Has there already been a non-zero character?
  JNZ >W30           ;If so, we need to write it
  CMP  CX,1          ;Is this the last character?
  JE  >W30           ;If so, we need to write it
  TEST BH,1          ;Are we doing a minimum?
  JNZ >W40           ;If not, don't write anything
  MOV  AL,' '        ;Assume a space
  TEST BH,2          ;Doing a word?
  JNZ >W35           ;If so, write the space
  CMP  CX,100        ;If not, doing the hundreds character?
  JBE >W35           ;If so, write the space
  JMP >W40           ;If not, don't write anything
W30:                 ;We need to write this character
  INC  BL            ;Test for first non-zero character is true
  ADD  AL,'0'        ;Convert the Number to ASCII
W35:                 ;Write the character
  MOV  [SI],AL       ;Write the
  CALL WriteZPauseSI ;  character
W40:                 ;Skip this character - just make it a space
  CMP  CX,1          ;Was this the last division to do?
  JE  >W90           ;If so, we're done
  MOV  AX,DX         ;If not, start next loop with remainder of division
  PUSH AX            ;Save register for a second
  XOR  DX,DX         ;So dividend won't be messed up
  MOV  AX,CX         ;Want to divide divisor in CX
  MOV  CX,10         ;Want to divide by 10
  DIV  CX            ;Divide it
  MOV  CX,AX         ;Store it back in CX
  POP  AX            ;Restore register
  JMP  W20           ;And do it again
W90:                 ;We're done
  POP  SI,DX,CX      ;Restore used registers
  POP  BX,AX         ;Restore original word & BP
  RET

;------------------------------------------------------------------------------
;SKIP OVER AN ASCIIZ STRING
;Inputs:  DS:[SI] = ASCIIZ String to Skip Over
;Outputs:
;Changes: [SI] points at character after the 0
;------------------------------------------------------------------------------
SkipOverStringSI:
  PUSH CX            ;Save used registers
  CALL CalcStrSizeSI ;Calculate the size of the string
  ADD  SI,CX         ;Add it to the pointer
  INC  SI            ;Skip over the 0
  POP  CX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LENGTH OF AN ASCIIZ STRING
;Inputs:  DS:[SI] = ASCIIZ String to wrok with
;Outputs: CX = Length of String
;         ZF = Set if string is 0 length
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
CalcStrSizeSI:
  PUSH DX            ;Save used registers
  MOV  DX,SI         ;Calculate the
  CALL CalcStrSizeDX ;  length of the string
  POP  DX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE AN ASCIIZ STRING, POINTED AT BY SI, TO PAUSE
;Inputs:  DS:[SI] = ASCIIZ String to Write
;Outputs: To Screen (CON)
;Changes:
;------------------------------------------------------------------------------
WriteZPauseSI:
  PUSH DX          ;Save used registers
  MOV  DX,SI       ;Write the
  CALL WriteZPause ;  string
  POP  DX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ASCIIZ STRING TO CON OR TO ERR
;Inputs:  DS:[DX] = Pointer to string
;         CS = Local Data Area
;Outputs: Writes the string to CON or ERR
;Changes:
;------------------------------------------------------------------------------
WriteZCon:                  ;Write to CON
  CMP  CS:PauseHeaderPtr,-1 ;Should we write anything?
  JE  >Z90                  ;If not, just quit
  PUSH BX                   ;Save used register
  MOV  BX,StdOutHandle      ;Write to STDOUT
  JMP >Z00                  ;Jump to do it
WriteZErr:                  ;Write to ERR
  PUSH BX                   ;Save used register
  MOV  BX,StdErrHandle      ;Write to STDERR
Z00:
  PUSH AX,CX                ;Save used registers
  CALL CalcStrSizeDX        ;Calculate the size of the string (returns CX)
  JZ  >Z80                  ;If nothing to write, just quit
  MOV  AH,40h               ;Function 40h (Write to Device)
  INT  21h                  ;Do it
Z80:                        ;We're done
  POP  CX,AX                ;Restore used registers
  POP  BX                   ;Restore used register
Z90:                        ;We're done
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LENGTH OF AN ASCIIZ STRING
;Inputs:  DS:[DX] = Pointer to the string
;Outputs: CX = Length of the string
;         ZF = Set if string is 0 length
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
CalcStrSizeDX:
  PUSH AX,DI  ;Save used registers
  PUSH ES     ;Save used registers
  MOV  ES,DS  ;Point ES:[DI]
  MOV  DI,DX  ; at the string
  XOR  AL,AL  ;Look for a 0
  MOV  CX,-1  ;Start with max count for REPNE
  REPNE SCASB ;Find the end of the string
  NOT  CX     ;Calculate the size
  DEC  CX     ;  of the string (sets ZF)
  POP  ES     ;Restore used registers
  POP  DI,AX  ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PARSE THE COMMAND LINE FOR SWITCHES, AND PRINT ERRORS.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PARSE THE COMMAND LINE FOR SWITCHES
;Inputs:
;Outputs: All kinds of stuff!
;Changes:
;------------------------------------------------------------------------------
ParseIt:
  CALL FixCmdLineCR    ;Replace CR at end of Command Line with a 0
  CALL FillStdInBuffer ;Copy redirected input to our buffer, if needed
                       ;  Quits if error
  MOV  ParseTest,Yes   ;Test input strings for errors
  CALL ParseThings     ;Do all input strings
  MOV  ParseTest,No    ;Parse string for real
  CALL ParseThings     ;Do all input strings
P90:
  RET

ParseThings:
  PUSH SI                       ;Save used registers
  MOV  SI,EnvVarPointer         ;Point at our Environment Variable
  CMP  SI,-1                    ;Is there an Environment Variable to parse?
  JE  >P30                      ;If no, skip it
  OR   ProgFlags2,DoEnvir       ;Mark as doing the Environment
  CMP  ParseTest,Yes            ;Just doing the Test Run?
  JE  >P20                      ;If so, don't write the variable contents yet
  MOV  DX,EnvMsg                ;Write the first part of the
  CALL WriteZPause              ;  environment message to the screen
  CALL WriteEnvCon              ;Write the environment variable contents
  CALL WriteCrLfPause2          ;Move down
P20:                            ;Do the Environment Variable
  CALL ParseCmdLine             ;Parse the Environment (quits if Error)
P30:                            ;Do StdIn
  AND  ProgFlags2,(NOT DoEnvir) ;Mark as doing Command Line
  OR   ProgFlags2,DoStdIn       ;Parse the
  XOR  SI,SI                    ;  StdIn buffer
  CALL ParseCmdLine             ;  Quit if error
  AND  ProgFlags2,(NOT DoStdIn) ;  is found
  MOV  SI,81h                   ;Assume "real" Command Line
  CMP  CmdLineVarPointer,-1     ;Have a CMDLINE Environment variable?
  JE  >P50                      ;If not, just do regular command line
  MOV  SI,CmdLineVarPointer     ;If so, point at the variable
P50:                            ;Pointed at Command Line Tail
  CALL ParseCmdLine             ;Parse Command Line
  POP  SI                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PARSE THE COMMAND LINE FOR SWITCHES
;Inputs:  ParseTest
;         [SI] = Option String to Parse
;Outputs:
;Changes: SI
;------------------------------------------------------------------------------
ParseCmdLine:
  PUSH AX             ;Save used registers
P10:                  ;Look for the next switch
  CALL IsSpaceOrEOX   ;Look for a valid character
  JZ  >P90            ;If EOL, we're done
  CMP  AL,'/'         ;Is it a slash?
  JE  >P20            ;If so, jump to handle it
  CMP  AL,'-'         ;Is it a dash?
  JE  >P20            ;If so, jump to handle it
  DEC  SI             ;If not, point back at the first character
  JMP >P30            ;Continue
P20:                  ;It's a slash or a dash
  CALL IsSpaceOrEOL   ;Look for a valid switch character
  JZ  >P70            ;If no character, there's an error
P30:                  ;Look for the switch
  CALL GetSwitch      ;See if it matches one of our switches
  JNZ  P10            ;If a match, look for the next switch
P70:                  ;Error - tell the user where it was
  CALL WriteCmdErr    ;Display the error for the user
  MOV  AL,ErLvlOption ;ErrorLevel = Bad Option on command line
  MOV  DX,NoMsg       ;Point at an empty message
  JMP  Exit           ;Print error message and quit
P90:                  ;We're done
  POP  AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE SWITCH CHARACTERS, AND DO WHATEVER IT IS THEY'RE ASKING
;Inputs:  DS:[SI] = Command line pointer
;Outputs: Lots of stuff!!!
;         ParseError
;         ZF = Set if Error
;            = Clear if OK
;Changes:
;------------------------------------------------------------------------------
GetSwitch:
  PUSH AX,BX,DI,BP         ;Save used registers
  MOV  BX,SwitchList       ;Point at the list of switch code words
  CALL GetCode             ;See if its a match
  JNC >S10                 ;If so, jump to test it
  CALL GetNextChar         ;If not, it's a single character
  CALL Capitalize          ;Capitalize it
S10:                       ;We have a Switch to test!
  MOV  BX,SwitchTbl        ;Point at the Table of Offsets
S20:                       ;Loop to here for each table entry
  MOV  AH,[BX]             ;Get the switch from our table?
  OR   AH,AH               ;Is it the end of the table?
  JZ  >S70                 ;If so, there's an error
  CMP  AL,AH               ;If a valid entry, is it a match?
  JE  >S30                 ;If so, jump to handle it
  ADD  BX,3                ;If not, point at the next table entry
  JMP  S20                 ;And keep looking
S30:                       ;It's a match from the table
  MOV  DI,OFFSET ProgFlags ;Point [DI] at ProgFlags
  MOV  BP,OFFSET TSRFlags  ;Point [BP] at TSRFlags
  MOV  AH,ParseTest        ;Pass the "Testing" flag
  OR   AH,AH               ;Set the ZF for Testing
  CALL W [BX+1]            ;Do the Switch stuff
  JMP >S90                 ;And quit
S70:                       ;There's an error
  MOV  ParseError,Yes      ;Mark the error flag
S90:                       ;We're done
  CMP  ParseError,Yes      ;Set/Clear the error flag
  POP  BP,DI,BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Display Help (Syntax) Message
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchH:
  OR   B [DI],Help ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Display ErrorLevel Table
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchE:
  OR   B [DI+2],ErrLvl ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Display list of Command-line (Option) Aliases
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchA:
  OR   B [DI+2],Alias ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Uninstall Program from Memory
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchU:
  OR   B [DI],Uninstall ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Install Program in Lower Memory, even if Upper Memory is available
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchL:
  PUSH AX                   ;Save used registers
  MOV  AL,UseLowMemory      ;Bit mask to use
  CALL DoSwitchWithYNPrgFwd ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Show Program/Disk(s) Status
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchS:
  OR   B [DI+2],Status ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Show Drive(s) Status
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchD:
  OR   B [DI+2],DrvStatus ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Show Contents of Sector Buffer
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchF:
  OR   B [DI+1],WriteBuff ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Display SCSI Inquiry Data
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchI:
  OR   B [DI+1],Inquiry ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Display list of Bad Devices
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchB:
  OR   B [DI+2],BadDevices ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display USB Descriptors of Last Device found
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchC:
  OR   B [DI+2],Descriptors ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Assign Drive Letters to FAT32 Partitions
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchT:
  PUSH AX                   ;Save used registers
  MOV  AL,UseFAT32          ;Bit mask to use
  CALL DoSwitchWithYNTsrFwd ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Beep Speaker when "Bad" Devices are discovered
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchBeep:
  PUSH AX                   ;Save used registers
  MOV  AL,NoBeep            ;Bit mask to use
  CALL DoSwitchWithYNTsrRvs ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;First DOS Drive Letter
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchLetter:
  PUSH AX              ;Save used registers
  CALL SkipColonEquals ;Skip Colon/Equals (if there)
  CALL GetNextChar     ;Get the next character
  CALL Capitalize      ;If valid character, Capitalize it
  CMP  AL,'C'          ;Valid Drive Letter?
  JB  >L70             ;If not, error
  CMP  AL,'Z'          ;Valid Drive Letter?
  JA  >L70             ;If not, error
  MOV  AH,AL           ;If OK, save it in AH
  CALL GetNextChar     ;Get the next character
  CMP  AL,':'          ;Is it a Colon?
  JE  >L20             ;If so, continue
  DEC  SI              ;If not, point back at the character
L20:                   ;[SI] points past colon after drive letter, if there
  CMP  ParseTest,Yes   ;Just the test run?
  JE  >L90             ;If so, we're done
  SUB  AH,'A'          ;If for real,
  MOV  FirstDrive,AH   ;  store it
  JMP >L90             ;Done
L70:                   ;Error
  MOV  ParseError,Yes  ;Set Error Flag
L90:                   ;Done
  POP  AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Maximum Number of Sectors to Transfer at one time
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchX:
  PUSH AX              ;Save used registers
  CALL SkipColonEquals ;Skip Colon/Equals (if there)
  CALL GetNumber       ;Get the number of sectors
  JC  >X70             ;If no number, error
  CMP  AX,MaxXferSects ;Is it too big?
  JA  >X70             ;If so, error
  CMP  AX,MinXferSects ;Is it too small?
  JB  >X70             ;If so, error
  CMP  ParseTest,Yes   ;Just the test run?
  JE  >X90             ;If so, we're done
  MOV  ES:XferSects,AX ;If for real, store it
  JMP >X90             ;Done
X70:                   ;Error
  MOV  ParseError,Yes  ;Set Error Flag
X90:                   ;Done
  POP  AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Maximum Number of Device/Interfaces
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;NOTES: This must not change the value in the TSR if the TSR has already
;         been installed into memory!
;------------------------------------------------------------------------------
DoSwitchDevices:
  PUSH AX              ;Save used registers
  CALL SkipColonEquals ;Skip Colon/Equals (if there)
  CALL GetNumber       ;Get the number of Device/Interfaces
  JC  >C70             ;If no number, error
  CMP  AX,MaxDevices   ;Is it too big?
  JA  >C70             ;If so, error
  OR   AL,AL           ;Is it too small?
  JZ  >C70             ;If so, error
  CMP  ParseTest,Yes   ;Just the test run?
  JE  >C90             ;If so, we're done
  MOV  NumDevices,AX   ;If for real, store it
  JMP >C90             ;Done
C70:                   ;Error
  MOV  ParseError,Yes  ;Set Error Flag
C90:                   ;Done
  POP  AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Maximum Number of Disk/LUNs
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;NOTES: This must not change the value in the TSR if the TSR has already
;         been installed into memory!
;------------------------------------------------------------------------------
DoSwitchDisks:
  PUSH AX              ;Save used registers
  CALL SkipColonEquals ;Skip Colon/Equals (if there)
  CALL GetNumber       ;Get the number of Disk/LUNs
  JC  >K70             ;If no number, error
  CMP  AX,MaxDisks     ;Is it too big?
  JA  >V70             ;If so, error
  OR   AL,AL           ;Is it too small?
  JZ  >K70             ;If so, error
  CMP  ParseTest,Yes   ;Just the test run?
  JE  >K90             ;If so, we're done
  MOV  NumDisks,AX     ;If for real, store it
  JMP >K90             ;Done
K70:                   ;Error
  MOV  ParseError,Yes  ;Set Error Flag
K90:                   ;Done
  POP  AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Maximum Number of DOS Drive Letters
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;NOTES: This must not change the value in the TSR if the TSR has already
;         been installed into memory!
;------------------------------------------------------------------------------
DoSwitchDrives:
  PUSH AX              ;Save used registers
  CALL SkipColonEquals ;Skip Colon/Equals (if there)
  CALL GetNumber       ;Get the number of Disk/LUNs
  JC  >V70             ;If no number, error
  CMP  AX,MaxDrives    ;Is it too big?
  JA  >V70             ;If so, error
  OR   AL,AL           ;Is it too small?
  JZ  >V70             ;If so, error
  CMP  ParseTest,Yes   ;Just the test run?
  JE  >V90             ;If so, we're done
  MOV  NumDrives,AX    ;If for real, store it
  JMP >V90             ;Done
V70:                   ;Error
  MOV  ParseError,Yes  ;Set Error Flag
V90:                   ;Done
  POP  AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Delay during Drive Initialization
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchDelay:
  PUSH AX,BX,DX        ;Save used registers
  CALL SkipColonEquals ;Skip Colon/Equals (if there)
  CALL GetNumber       ;Get the number of seconds
  JC  >D70             ;If no number, error
  CMP  AX,MaxDelay     ;Is it too big?
  JA  >D70             ;If so, error
  CMP  ParseTest,Yes   ;Just the test run?
  JE  >D90             ;If so, we're done
  MOV  BX,182          ;If OK,
  MUL  BX              ;  convert
  MOV  BX,10           ;  seconds to
  DIV  BX              ;  timer ticks
  MOV  ES:InitDelay,AX ;Store it
  JMP >D90             ;Done
D70:                   ;Error
  MOV  ParseError,Yes  ;Set Error Flag
D90:                   ;Done
  POP  DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Show ASCQ History
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchQ:
  PUSH AX,BX                ;Save used registers
  CALL SkipColonEquals      ;Skip Colon/Equals (if there)
  CALL GetNumber            ;Get the Int 13h Disk Number
  JC  >Q70                  ;If no number, error
  OR   AH,AH                ;Is the number too big?
  JNZ >Q70                  ;If so, error
  MOV  BX,ES:DiskInfoOffset ;[BX] = Disk Info Table
  MOV  BL,ES:[BX].DskInt13DrvNum ;BL = First Int 13h Disk Number
  CMP  AL,BL                ;Is the number too little?
  JB  >Q70                  ;If so, error
  ADD  BL,B ES:NumDisks[0]  ;Is the number
  CMP  AL,BL                ;  too big?
  JAE >Q70                  ;If so, error
  MOV  ASCQHistoryDsk,AL    ;If OK, store it
  JMP >Q90                  ;Done
Q70:                        ;Error
  MOV  ParseError,Yes       ;Set Error Flag
Q90:                        ;Done
  POP  BX,AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Low-level Format a Disk
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchFormat:
  PUSH AX              ;Save used registers
  CALL SkipColonEquals ;Skip Colon/Equals (if there)
  CALL GetNumber       ;Get the disk number
  JC  >F70             ;If no number, error
  OR   AH,AH           ;Valid Disk #?
  JNZ >F70             ;If not error
  OR   AL,AL           ;Valid Disk #?
  JZ  >F70             ;If not, error
  MOV  DiskToFormat,AL ;If OK, store it
  JMP >F90             ;Done
F70:                   ;Error
  MOV  ParseError,Yes  ;Set Error Flag
F90:                   ;Done
  POP  AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Reset USB Device
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchR:
  PUSH AX,CX,DI                      ;Save used registers
  CALL SkipColonEquals               ;Skip Colon/Equals (if there)
  CALL GetNumber                     ;Get the disk number
  JC  >R70                           ;If no number, error
  CMP  AX,ES:NumDevices              ;Is it too big?
  JAE >R70                           ;If so, error
  MOV  CL,AL                         ;If OK, get
  CALL DIIndex2Offset                ;  the Table Entry Pointer (ES:[DI])
  TEST ES:[DI].DvcFlags,DvcFlagInUse ;Valid Table Entry?
  JZ  >R70                           ;If not, error
  CMP  ParseTest,Yes                 ;Is this just the test run?
  JE  >R90                           ;If so, we're done
  PUSH SI                            ;Save used registers
  MOV  SI,Int14Request               ;[SI] = Int 14 Request
  MOV  AX,W ES:[DI].DvcHostIndex     ;Copy the Host Index
  MOV  W [SI].I14RHostIndex,AX       ;  and Device Address
  MOV  [SI].I14RRequestType,I14RRTResetDevice ;Request = Reset Device
  MOV  W [SI].I14RCallBackAddr[2],0  ;Do nothing when done
  CALL DoInt14CallSaveAllSI          ;Issue the Request
  POP  SI                            ;Restore used registers
  JMP >R90                           ;Done
R70:                                 ;Error
  MOV  ParseError,Yes                ;Set Error Flag
R90:                                 ;Done
  POP  DI,CX,AX                      ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT ROUTINES FOR PROCESSING SWITCHES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET A YES/NO OPTION FOR A COMMAND-LINE SWITCH
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK
;              ZF = Set if No
;                   AL = 0 (No)
;                 = Clear if Yes
;                   AL = -1 (Yes)
;            = Set if Error
;              AL = 0
;Changes:
;------------------------------------------------------------------------------
GetYesNo4Switch:
  PUSH BX,CX              ;Save used registers
  MOV  CH,AH              ;Save original AH
  CALL SkipColonEquals    ;Skip Colon/Equals (if there)
  MOV  BX,SwitchListYesNo ;Point at the list of code words
  CALL GetCode            ;See if its a match
  JNC >Y20                ;If so, jump to test it
  CALL GetNextChar        ;If not, get a single character
  JZ  >Y70                ;If end-of-line, error
  CALL Capitalize         ;Capitalize it
Y20:                      ;Got a character
  CMP  AL,'Y'             ;Is it Yes?
  JE  >Y40                ;If so, handle it
  CMP  AL,'N'             ;Is it No?
  JNE >Y70                ;If not, error
Y30:                      ;No
  XOR  AL,AL              ;If so, make it No
  JMP >Y80                ;Done
Y40:                      ;Yes
  MOV  AL,Yes             ;Mark it as a Yes
  JMP >Y80                ;Done
Y70:                      ;Error
  XOR  AL,AL              ;Set AL to 0
  STC                     ;Set Error Flag
  JMP >Y90                ;Done
Y80:                      ;OK
  OR   AL,AL              ;Set Zero Flag for Return
  CLC                     ;Set OK Flag
Y90:                      ;Done
  MOV  AH,CH              ;Restore original AH
  POP  CX,BX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A SWITCH WITH A YES/NO OPTION
;Inputs:  [SI] = Command Line Pointer
;         ES = TSR Data Area
;         DS = Local Data Area
;         AL = Bit mask to Set/Unset
;         AH = ParseTest status
;Outputs: Sets/Unsets bit in ES:TSRFlags or DS:ProgFlags as appropriate
;Changes:
;NOTES: If we are changing the resident (TSR) part of the program
;         (ES:TSRFlags), we do not actually change anything unless
;         ParseTest is set to No.  If we are changing the transient
;         part of the program (DS:ProgFlags), we change it no matter
;         what ParseTest is set to.
;       Forward and Reverse refer to Forward and Reverse Logic.  With
;         Forward Logic, if the user says Yes, we set the particular bit
;         to 1.  With Reverse Logic, when the user says Yes, we set
;         to bit to 0.
;------------------------------------------------------------------------------
DoSwitchWithYNTsrRvs:
  PUSH CX                  ;Save used registers
  MOV  CL,-1               ;Mark as Reverse Logic
  JMP >Y000                ;Jump to do ES:TSRFlags
DoSwitchWithYNTsrFwd:
  PUSH CX                  ;Save used registers
  XOR  CL,CL               ;Mark as Forward Logic
  JMP >Y000                ;Jump to do ES:TSRFlags
;DoSwitchWithYNPrgRvs:
;  PUSH CX                  ;Save used registers
;  MOV  CL,-1               ;Mark as Reverse Logic
;  JMP >Y001                ;Jump to do DS:ProgFlags
DoSwitchWithYNPrgFwd:
  PUSH CX                  ;Save used registers
  XOR  CL,CL               ;Mark as Forward Logic
  JMP >Y001                ;Jump to do DS:ProgFlags
Y000:                      ;ES:TSRFlags
  PUSH BX                  ;Save used registers
  MOV  BX,OFFSET TSRFlags  ;Point at TSR Flags
  JMP >Y00                 ;Do it
Y001:                      ;DS:ProgFlags
  PUSH BX                  ;Save used registers
  MOV  BX,OFFSET ProgFlags ;Point at TSR Flags
;  JMP >Y00                 ;Do it
Y00:
  PUSH AX                  ;Save used registers
  MOV  CH,AL               ;Save Bit Mask to set
  CALL GetYesNo4Switch     ;Get the Yes/No parameter (AL)
  JC  >Y70                 ;If error, handle it
  OR   AL,AL               ;Is it Yes?
  JNZ >Y20                 ;If so, jump to handle it
Y10:                       ;No
  OR   CL,CL               ;Is it Forward Logic?
  JZ  >Y40                 ;If so, jump to handle it
  JMP >Y50                 ;If not, jump to handle Reverse Logic
Y20:                       ;Yes
  OR   CL,CL               ;Is it Forward Logic?
  JZ  >Y50                 ;If so, jump to handle it
Y40:                       ;Unset the Bit
  NOT  CH                  ;Need to Unset
  CMP  BX,SectorBuff       ;Is it for ProgFlags?
  JAE >Y45                 ;If so, jump to handle it
Y42:                       ;Unset ES:TSRFlags
  OR   AH,AH               ;Just the Test Run?
  JNZ >Y90                 ;If so, quit
  AND  ES:[BX],CH          ;Unset the appropriate flag
  JMP >Y90                 ;Done
Y45:                       ;Unset DS:ProgFlags
  AND  [BX],CH             ;Unset the appropriate flag
  JMP >Y90                 ;Done
Y50:                       ;Set the Bit
  CMP  BX,SectorBuff       ;Is it for ProgFlags?
  JAE >Y55                 ;If so, jump to handle it
Y52:                       ;Set ES:TSRFlags
  OR   AH,AH               ;Just the Test Run?
  JNZ >Y90                 ;If so, quit
  OR   ES:[BX],CH          ;Set the appropriate flag
  JMP >Y90                 ;Done
Y55:                       ;Set DS:ProgFlags
  OR   [BX],CH             ;Set the appropriate flag
  JMP >Y90                 ;Done
Y70:                       ;Error
  MOV  ParseError,Yes      ;Mark as an Error
Y90:                       ;Done
  POP  AX                  ;Restore used registers
  POP  BX                  ;Restore used registers
  POP  CX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;REPLACE THE CARRIAGE RETURN AT THE END OF THE CMD LINE TAIL WITH A 0
;Inputs:  CS = DS = PSP Segment
;Outputs:
;Changes: Last Byte of Command Tail
;------------------------------------------------------------------------------
FixCmdLineCR:
  PUSH AX,CX,DI,ES   ;Save used registers
  MOV  AL,CR         ;Look for a CR
  MOV  CX,7Fh        ;Maximize Byte Counter
  MOV  ES,DS         ;Point ES:[DI]
  MOV  DI,81h        ;  at the Command Line Tail
  REPNE SCASB        ;Look for the CR
  MOV  B ES:[DI-1],0 ;Replace the CR with a 0
  POP  ES,DI,CX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT CHARACTER FROM THE ENVIRONMENT OR COMMAND LINE
;Inputs:  [SI] = Pointer (Command Line or Environment)
;Outputs: AL = The next character
;         ZF = Set if End-Of-Line (Character = ASCII 0)
;            = Clear if "real" character
;Changes: SI
;------------------------------------------------------------------------------
GetNextChar:
  PUSH DS                   ;Save used registers
  TEST ProgFlags2,DoStdIn   ;Are we doing StdIn?
  JNZ >N20                  ;If so, jumpto handleit
  TEST ProgFlags2,DoEnvir   ;Are we doing the Program Environment Variable?
  JNZ >N10                  ;If so, handle it
  CMP  CmdLineVarPointer,-1 ;Need to use the CMDLINE Environment variable?
  JE  >N90                  ;If not, just do the "real" command line
N10:                        ;Get next character from the Environment
  MOV  DS,[PSPEnvirSeg]     ;Point at the Environment Segment
  JMP >N90                  ;Continue
N20:                        ;StdIn
  MOV  DS,ExtraMemSegment   ;Poitn DS at the correct Segment
N90:                        ;DS:[SI] points at the next character
  LODSB                     ;Get the character from the "real" command line
  OR   AL,AL                ;Set ZF if EOL
  POP  DS                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER SPACES TO FIND THE NEXT LEGITIMATE CHARACTER, TESTING FOR EOL
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: ZF = Set if EOL
;               AL  = Unchanged
;              [SI] = End-of-Line Character
;            = Clear if not EOL
;               AL  = First non-space character
;              [SI] = Character AFTER the next non-space character
;Changes:
;------------------------------------------------------------------------------
IsSpaceOrEOX:
  CALL IsSpaceOrEOL ;Skip over the spaces
  JZ  >X90          ;If end-of-line, we're done
  CALL GetNextChar  ;If not, get the next character
  OR   AL,AL        ;Set return flag
X90:                ;Done
  RET

;------------------------------------------------------------------------------
;SKIP OVER SPACES TO FIND LEGITIMATE CHARACTERS, AND TEST FOR EOL
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: ZF = Set if EOL
;            = Clear if legitimate character
;              [SI] = The Next non-Space Character
;Changes:
;------------------------------------------------------------------------------
IsSpaceOrEOL:
  PUSH AX          ;Save used registers
L10:               ;Loop to here to skip over spaces
  CALL GetNextChar ;Get the next character
  CMP  AL,' '      ;Is it a space?
  JE   L10         ;If so, get the next character
  CMP  AL,Tab      ;Is it a Tab?
  JE   L10         ;If so, get the next character
  DEC  SI          ;If not, point back at the character
  OR   AL,AL       ;Set EOL flag
  POP  AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER A COLON OR EQUALS, IF THERE
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: CF = Clear if Colon or Equals was found (and skipped)
;              [SI] = First non-Space Character after the Colon/Equals
;            = Set if No Colon or Equals was found
;              [SI] = First non-Space Character after where we were looking
;Changes:
;------------------------------------------------------------------------------
SkipColonEquals:
  PUSH AX           ;Save used registers
  CALL IsSpaceOrEOX ;Skip over the Spaces
  JZ  >Q75          ;If End-of-Line, nothing to get
  CMP  AL,':'       ;Is it a Colon?
  JE  >Q80          ;If so, we're done
  CMP  AL,'='       ;Is it an equals?
  JE  >Q80          ;If so, we're done
Q70:                ;No Colon/Equals Found
  DEC  SI           ;Point back at the character
Q75:                ;[SI] correct
  STC               ;Set return flag
  JMP >Q90          ;Done
Q80:                ;Colon/Equals Found
  CALL IsSpaceOrEOL ;Go to the next character
  CLC               ;Set return flag
Q90:                ;Done
  POP  AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A CODE WORD FROM THE COMMAND LINE TO A BYTE FROM THE LOOKUP TABLE
;Inputs:  DS:[SI] = Command Line Pointer
;         DS:[BX] = List to Test
;Outputs: CF = Clear if a match was found
;              AL = Entry from Table
;              [SI] = Next character after the Code Match
;         CF = Set if no match found (error)
;              AL = Unchanged
;              SI = Unchanged
;Changes: SI if valid match found
;------------------------------------------------------------------------------
GetCode:
  PUSH BX,DX         ;Save used registers
  MOV  DX,AX         ;Save AX in case there's no match
C10:                 ;Loop to here for each list of words
  CMP  B [BX],0      ;Are we at the end of our table?
  JE  >C80           ;If so, we couldn't find a match
  XOR  AH,AH         ;Assume it's a match
  PUSH SI            ;Save our command line pointer for a second
C20:                 ;Loop to here for each character in a word
  CALL GetNextChar   ;Get the next character
  CALL Capitalize    ;Capitalize it
  CALL CmpALBXNoCase ;Is it a match?
  JZ  >C30           ;If so, handle it
  INC  AH            ;If not, mark us as no match
C30:                 ;The character is tested
  INC  BX            ;Point at the next character in our test word
  CMP  B [BX],0      ;Are we at the end of the word?
  JNE  C20           ;If not, keep going until we're done
  INC  BX            ;Point at the next word or code list
  OR   AH,AH         ;Was it a match?
  JZ  >C50           ;If so, jump to handle it
  POP  SI            ;If not, restore our command line pointer
  CMP  B [BX],0      ;Is this the end of our word list?
  JNE  C10           ;If not, just test the next word
  INC  BX,2          ;If so, skip over the codes
  JMP  C10           ;Keep going until we're done with our list
C50:                 ;We've found a match!
  POP  AX            ;Lose our original command line pointer
  DEC  BX            ;Point back at the end-of-word marker
C60:                 ;Loop to here to find the end-of-list
  MOV  AX,[BX]       ;Get the next two characters in our list
  INC  BX            ;Point at the next character for next time
  OR   AX,AX         ;Is this the start of our code list?
  JNE  C60           ;If not, keep looking
  INC  BX            ;If so, point at the character we're looking for
  MOV  DL,[BX]       ;Get the character from the table
  CLC                ;Mark our OK flag
  JMP >C90           ;And we're done
C80:                 ;No match found
  STC                ;Mark us as no match
C90:                 ;We're done
  MOV  AX,DX         ;Set AX to the correct value
  POP  DX,BX         ;Restore used registers
  RET

CmpALBXNoCase:
  PUSH AX         ;Save used registers
  CALL Capitalize ;Capitalize AL
  MOV  AH,AL      ;Store it in AH
  MOV  AL,[BX]    ;Get [BX]
  CALL Capitalize ;Capitalize it
  CMP  AL,AH      ;Compare AL & [BX]
  POP  AX         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO GET A NUMBER FROM A STRING (HEX OR DECIMAL)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET A NUMBER FROM A STRING (CAN BE DECIMAL OR HEX)
;Inputs:  [SI] = String Pointer
;Outputs: CF = Clear if we got a valid number
;              AX = Number
;            = Set if Error (no number found)
;              AX = Unchanged
;Changes: [SI] = next byte after the number
;NOTES: A Hex String must start with '0x' and/or end in 'H'!
;       This assumes we MUST return a number, so if no number is found,
;         [SI] = first character that should have been a numeral.
;------------------------------------------------------------------------------
GetNumber:
  PUSH BX           ;Save used registers
  MOV  BX,AX        ;Save original AX
  CALL IsSpaceOrEOL ;Skip past spaces
  JZ  >N70          ;If End-of-Line, Error
  CALL TestForHex   ;Is it a Hex Number?
  JC  >N20          ;If not, try a decimal
  CALL Test0xPrefix ;Skip over the 0x (C-style) prefix, if there
  CALL GetHex       ;If so, get it
  JNC >N80          ;If OK, we're done
  JMP >N70          ;If not, Error
N20:                ;Not Hex
  CALL GetDecimal   ;Try a Decimal
  JNC >N80          ;If OK, we're done
N70:                ;Error
  MOV  AX,BX        ;Restore original AX
  STC               ;Set Error Flag
  JMP >N90          ;Done
N80:                ;OK
  CLC               ;Set OK Flag
N90:                ;Done
  POP  BX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII STRING TO SEE IF IT IS A HEX STRING (ENDS IN H)
;Inputs:  [SI] = String to test
;Outputs: CF = Clear if it is a Hex String
;            = Set if Error (not a Hex String)
;Changes:
;NOTES: A valid Hex String will contain numerals 0-9, A-F, and Underscores,
;         and will end in an H.  It cannot contain spaces.
;------------------------------------------------------------------------------
TestForHex:
  PUSH AX,SI        ;Save used registers
  CALL Test0xPrefix ;Test for the 0x (C-style) prefix (changes SI)
  JNC >H80          ;If so, it's Hex
  CALL GetNextChar  ;Get the
  DEC  SI           ;  first character
  CALL IsHexNumber  ;A valid Hex Number?
  JC  >H70          ;If not, Error
H40:                ;Loop to here for each character
  CALL GetNextChar  ;Get the next character
  CALL IsHexNumber  ;A valid Hex Number?
  JNC  H40          ;If so, keep looking
  CMP  AL,'_'       ;An Underscore?
  JE   H40          ;If so, keep looking
  CALL IsHexEnd     ;End of the Hex Number?
  JZ  >H80          ;If so, we're done
H70:                ;Not Hex
  STC               ;Set error Flag
  JMP >H90          ;Done
H80:                ;Is Hex
  CLC               ;Set OK Flag
H90:                ;Done
  POP  SI,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST FOR A 0x (C-STYLE) HEX PREFIX
;Inputs:  [SI] = String to test
;Outputs: CF = Set if not a 0x Prefix
;              SI unchanged
;            = Clear if not a 0x Prefix
;              [SI] = Character after the 0x
;Changes:
;------------------------------------------------------------------------------
Test0xPrefix:
  PUSH AX,BX       ;Save used registers
  MOV  BX,SI       ;Save original Pointer
  CALL GetNextChar ;Get the next character
  CMP  AL,'0'      ;Is it a 0?
  JNE >X70         ;If not, it's not a Prefix
X20:               ;Loop to here to skip over all zeroes
  CALL GetNextChar ;Get the next charcter
  CMP  AL,'0'      ;Is it another 0?
  JE   X20         ;If so, keep skipping the zeroes
  CALL Capitalize  ;If not, capitalize it
  CMP  AL,'X'      ;Is it an X?
  JNE >X70         ;If not, it's not a 0x Prefix
  CALL GetNextChar ;Get the next charcter
  CALL IsHexNumber ;Is it a Hex Number?
  JNC >X80         ;If so, it's a 0x Prefix
X70:               ;Not a 0x Prefix
  MOV  SI,BX       ;Restore original pointer
  STC              ;Set return flag
  JMP >X90         ;Done
X80:               ;Is a 0x Prefix
  DEC  SI          ;Point back at the first hex number
  CLC              ;Set return flag
X90:               ;Done
  POP  BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT SERIES OF HEX CHARACTERS, AND CONVERT THEM TO A NUMBER
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK
;              AX = Character string converted to a number, ?? if not
;            = Set if Error
;              AX = Unchanged
;Changes:
;NOTES: The string can either have an H at the end or not, and this code
;         will work.
;------------------------------------------------------------------------------
GetHex:
  PUSH BX,CX,DX    ;Save used registers
  MOV  DX,AX       ;Save original AX
  XOR  BX,BX       ;Start with zero
  MOV  CX,4        ;CL = bits to shift by, CH = Character Counter
  XOR  AH,AH       ;Set High byte to 0
D10:               ;Loop to here for each character
  CALL GetNextChar ;Get the next character
  CALL IsHexNumber ;A valid Hex Number?
  JNC >D20         ;If so, continue
  CMP  AL,'_'      ;If not, is it an Underscore?
  JE  >D45         ;If so, keep looking
  JMP >D50         ;If not, we're done
D20:               ;Valid Hex Number
  INC  CH          ;Increment the character counter
  SHL  BX,CL       ;Make room for the New Nibble
  JNC >D40         ;If we're not too big yet, keep going
  DEC  SI          ;If too big, Point back at bad character
  JMP >D70         ;Error
D40:               ;OK to add in new Nibble
  ADD  BX,AX       ;Add in the new Nibble
D45:               ;Done with this character
  JMP  D10         ;Jump to get next character
D50:               ;Done getting string
  DEC  SI          ;Point back at the bad character
  OR   CH,CH       ;Any valid characters at all?
  JZ  >D70         ;If not, error
  CALL GetNextChar ;Is the next character
  CALL IsHexEnd    ;  an H?
  JZ  >D80         ;If so, we're done
  DEC  SI          ;If not, point back at the non-H
  JMP >D80         ;Done
D70:               ;There was an error
  MOV  AX,DX       ;Restore original AX
  STC              ;Mark the error flag
  JMP >D90         ;And quit
D80:               ;We have a good number
  MOV  AX,BX       ;Put the value where it belongs
  CLC              ;Mark the OK flag
D90:               ;We're done
  POP  DX,CX,BX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT SERIES OF NUMERIC CHARACTERS, AND CONVERT THEM TO A NUMBER
;Inputs:  [SI] = Command Line Pointer
;Outputs: AX = decimal character string converted to a number, ?? if not
;         CF = Clear if AX is OK
;            = Set if no decimal found
;Changes: SI points at character after the number
;------------------------------------------------------------------------------
GetDecimal:
  PUSH BX,CX,DX     ;Save used registers
  XOR  AX,AX        ;Start with zero
  XOR  BX,BX        ;  "    "    "   - accumulator
  MOV  CX,10        ;CX = multiplier & digit limit comparer
  CALL IsSpaceOrEOX ;Skip over the spaces
  JZ  >D70          ;If EOL, Error
  SUB  AL,'0'       ;If not, convert it to a number
  CMP  AL,9         ;Is it really a number?
  JA  >D70          ;If not, there's an error
  DEC  SI           ;If so, step back to the number
D10:                ;Loop to here for each character
  CALL GetNextChar  ;Get the next character
  SUB  AL,'0'       ;Change it to 0-9 range
  XOR  AH,AH        ;Extend byte to word
  CMP  AX,CX        ;Is it a digit?
  JAE >D80          ;If not, we're done
  CMP  BX,6553      ;Is our number getting too big?
  JB  >D20          ;If not, jump to store it
  CMP  AL,5         ;If so, will this number make it too big?
  JA  >D70          ;If so, there's an error
D20:                ;Add the digit to our number
  XCHG AX,BX        ;Swap accumulation into AX, new digit into BX
  MUL  CX           ;Multiply the previous accumulation by 10
  ADD  BX,AX        ;Add in the new digit
  JMP  D10          ;Jump to get next character
D70:                ;There was an error
  STC               ;Mark the error flag
  JMP >D90          ;And quit
D80:                ;We have a good number
  DEC  SI           ;Point back at the non-number
  MOV  AX,BX        ;Put the value where it belongs
  CLC               ;Mark the OK flag
D90:                ;We're done
  POP  DX,CX,BX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A HEX NUMERAL (BETWEEN 0 AND F)
;Inputs:  AL = ASCII Character to Test
;Outputs: CF = Clear if it is a Number
;              AL = ASCII Code converted to a real Number
;            = Set if Error (not a Number)
;              AL = Unchanged
;Changes:
;------------------------------------------------------------------------------
IsHexNumber:
  PUSH BX          ;Save used registers
  MOV  BL,AL       ;Save the character in case we need to restore it
  CALL IsNumber    ;A Decimal Number?
  JNC >H85         ;If so, we're done
  CALL Capitalize  ;If not, Capitalize it
  CMP  AL,'A'      ;A Hex Number?
  JB  >H70         ;If not, Error
  CMP  AL,'F'      ;A Hex Number?
  JBE >H80         ;If so, handle it
H70:               ;Not a Number
  MOV  AL,BL       ;Restore original character
  STC              ;Set Error Flag
  JMP >H90         ;Done
H80:               ;A Number > 9
  SUB  AL,('A'-10) ;Convert it to a real number
  JMP >H90         ;Done
H85:               ;OK (is a Number)
  CLC              ;Set OK Flag
H90:               ;Done
  POP  BX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A NUMERAL (BETWEEN 0 AND 9)
;Inputs:  AL = ASCII Character to Test
;Outputs: CF = Clear if it is a Number
;              AL = ASCII Code converted to a real Number
;            = Set if Error (not a Number)
;              AL = Unchanged
;Changes:
;------------------------------------------------------------------------------
IsNumber:
  CMP  AL,'0' ;A Number?
  JB  >N70    ;If not, Error
  CMP  AL,'9' ;A Number?
  JBE >N80    ;If so, handle it
N70:          ;Not a Number
  STC         ;Set Error Flag
  JMP >N90    ;Done
N80:          ;A number
  SUB  AL,'0' ;Convert it to a real number
  CLC         ;Set OK Flag
N90:          ;Done
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A PARTICULAR CHARACTER
;Inputs:  AL = ASCII Character to Test
;Outputs: ZF = Set if it is the appropriate character
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
IsHexEnd:
  PUSH AX         ;Save used registers
  CALL Capitalize ;Capitalize the Character
  CMP  AL,'H'     ;See if it matches
  POP  AX         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE THE TELL THE USER WHERE THE COMMAND LINE ERROR OCCURRED
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE THE COMMAND LINE OR ENVIRONMENT ERROR INFORMATION TO THE SCREEN
;Inputs:  [SI] = Command line Pointer (if Command Line)
;              = StdIn Buffer Pointer (if StdIn String)
;              = Environment Pointer (if Environment Variable)
;         ProgFlags2.DoEnvir, ProgFlags2.DoStdIn
;Outputs:
;Changes: Writes information to screen
;------------------------------------------------------------------------------
WriteCmdErr:
  PUSH AX,BX,CX,DX        ;Save used registers
  PUSH DI,SI,BP           ;Save used registers
  CALL FindBadChar        ;Find the actual bad character in the string (SI)
  CALL SetupCmdErrStrings ;Set up the String Pointers and Sizes
                          ;DI:[AX] = Command Line String
                          ;DS:[BX] = Program name at beginning of String
                          ;    CX  = Size of BX String
                          ;DS:[DX] = Header String
                          ;DS:[BP] = Footer String
  CALL WriteZErr          ;Write the Header
  CALL WriteCrLfErr       ;Move
  CALL WriteCrLfErr       ;  down
  SUB  SI,AX              ;Calculate the number
  ADD  CX,SI              ;  of spaces
  DEC  CX                 ;  to write
  CALL WriteCmdString     ;Write the Command-line String (may modify CX)
  CALL WriteCrLfErr       ;Move down
  MOV  B SingleMsg[0],' ' ;Want to write spaces
  MOV  DX,SingleMsg       ;Point at the string
E60:                      ;Loop to here to write each space (number in CX)
  CALL WriteZErr          ;Write the space
  LOOP E60                ;Keep writing them until we're done
  MOV  DX,ParseErrMsg     ;Write the Pointer Part
  CALL WriteZErr          ;  of the Error Message
  MOV  DX,BP              ;Write the last part
  CALL WriteZErr          ;  of the message
  POP  BP,SI,DI           ;Restore used registers
  POP  DX,CX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GO BACKWARDS IN AN ERRORED OPTION STRING TO INDICATE TO USER WHERE ERROR WAS
;Inputs:  SI = Option String Pointer (Environment, StdIn, or Command Line)
;                where error was found
;Outputs: SI = Options String Pointer, adjusted to point at a "Real" character
;Changes:
;------------------------------------------------------------------------------
FindBadChar:
  PUSH AX          ;Save used registers
  DEC  SI          ;Go back 1 character to start
B10:               ;Loop to here to find a legitimate character
  CALL GetNextChar ;Get the character
  JZ  >B40         ;If end-of-line, keep going back
  CMP  AL,' '      ;Is it a space?
  JNE >B90         ;If not, we're done
B40:               ;Need to keep going back
  SUB  SI,2        ;Go back to the previous character
  JMP  B10         ;Keep looking
B90:               ;Done
  POP  AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SET UP THE STRING POINTERS AND SIZES TO BE ABLE TO WRITE THE COMMAND ERROR
;Inputs:  DS = Local Data Area
;Outputs: DI:[AX] = Command-line String to write
;         DS:[DX] = First Error Message (Header) to write
;         DS:[BX] = Second message to write (first part of Command string)
;             CX  = Number of Bytes to add to String Size
;         DS:[BP] = Third message to write (Footer)
;Changes:
;------------------------------------------------------------------------------
SetupCmdErrStrings:
  TEST ProgFlags2,DoEnvir   ;Working with the Environment?
  JNZ >S40                  ;If so, handle it
  TEST ProgFlags2,DoStdIn   ;Working with StdIn?
  JNZ >S50                  ;If so, handle it
S10:                        ;Command Line
  MOV  AX,81h               ;DI:[AX] =
  MOV  DI,DS                ;  Command-line Tail
  MOV  BX,RealName          ;DS:[BX] = Program Name
  MOV  CX,RealNameSz        ;CX = Size of [BX] String
  CMP  CmdLineVarPointer,-1 ;Real Command Line?
  JE  >S30                  ;If so, continue
S20:                        ;CMDLINE Environment Variable
  MOV  DI,[PSPEnvirSeg]     ;DI:[AX] =
  MOV  AX,CmdLineVarPointer ;  CMDLINE
  SUB  AX,CmdLineVarSize    ;  Environment Variable
S30:                        ;Have Command-line parameters set up
  MOV  DX,ParseCmdMsg       ;DS:[DX] = Header String
  MOV  BP,ParseErrMsg2      ;DS:[BP] = Footer String
  JMP >S90                  ;Done
S40:                        ;Environment
  MOV  DI,[PSPEnvirSeg]     ;DI:[AX] =
  MOV  AX,EnvVarPointer     ;  USBKEYB
  SUB  AX,EnvVarSize        ;  Environment Variable
  MOV  BX,NoMsg             ;DS:[BX] = Second message to write
  XOR  CX,CX                ;CX = Size of [BX] String
  MOV  DX,ParseEnvMsg       ;DS:[DX] = Header String
  MOV  BP,ParseEnvMsg2      ;DS:[BP] = Footer String
  JMP >S90                  ;Done
S50:                        ;StdIn
  MOV  DI,ExtraMemSegment   ;DI:[AX] =
  XOR  AX,AX                ;  StdIn Buffer
  MOV  BX,NoMsg             ;DS:[BX] = Second message to write
  XOR  CX,CX                ;CX = Size of [BX] String
  MOV  DX,ParseStdInMsg     ;DS:[DX] = Header String
  MOV  BP,ParseErrMsg2      ;DS:[BP] = Footer String
S90:                        ;Done
  RET

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF THE COMMAND STRING, WITH MORE MESSAGES AS NEEDED
;Inputs:  CS = DS = Local Data Area
;         DS:[BX] = First String to write (may not be needed!)
;         DI:[AX] = Second String (main part) to write
;             CX  = Number of Spaces to write at beginning (if normal)
;Outputs: CX = Adjusted number of spaces to write
;Changes:
;------------------------------------------------------------------------------
WriteCmdString:
  PUSH AX,BX,DX,DI,SI      ;Save used registers
  PUSH BP,DS,ES            ;Save used registers
  MOV  BP,CX               ;Save the original Space Counter in BP
  MOV  ES,DI               ;Save the second string Pointer
  MOV  SI,AX               ;  in ES:[SI]
  MOV  DX,BX               ;Save the length
  CALL CalcStrSizeDX       ;  of the first string
  MOV  DI,CX               ;  in DI
  MOV  DS,ES               ;Save the length
  CALL CalcStrSizeSI       ;  of the second string
  MOV  AX,CX               ;  in AX
  CMP  BP,70               ;Are there too many spaces to fit on one line?
  JBE >G20                 ;If not, continue
G10:                       ;Need to lop off the beginning
  SUB  BP,DI               ;We will not be
  XOR  DI,DI               ;  writing the
  MOV  BX,NoMsg            ;  first string
  CMP  BP,70               ;Are there still too many spaces to fit?
  JBE >G20                 ;If not, continue
  MOV  BX,MoreLeftMsg      ;Point at the More Message
  ADD  BP,MoreMsgSize      ;Compensate number of spaces for More Message
  MOV  DI,60               ;We want the number of spaces to be 60
  SUB  DI,BP               ;Calculate how far into the Second string
  NEG  DI                  ;  we need to start to accomplish that
  MOV  BP,59               ;BP = New Number of Spaces
  ADD  SI,DI               ;  where we need to start writing
  SUB  AX,DI               ;  of second string
  MOV  DI,MoreMsgSize      ;DI = Size of new first string (More Message)
G20:                       ;Beginning of line is accounted for
  MOV  DS,CS               ;Write the
  MOV  DX,BX               ;  first
  CALL WriteZErr           ;  string
  MOV  DS,ES               ;Point DS:[DX] at the
  MOV  DX,SI               ;  second string
  ADD  DI,AX               ;Calculate total length of both strings
  CMP  DI,79               ;Will it fit on one line?
  JBE >G40                 ;If so, continue
  MOV  BX,(80-MoreMsgSize) ;Calculate how many characters
  SUB  BX,DI               ;  of the second string
  ADD  BX,AX               ;  we need to write
  MOV  AL,[SI+BX]          ;Save the old character in the string
  MOV  B [SI+BX],0         ;Convert it to an end-of-string character
  CALL WriteZErr           ;Write the truncated string
  MOV  [SI+BX],AL          ;Restore the original character of the string
  MOV  DS,CS               ;Write the
  MOV  DX,MoreRightMsg     ;  More Message
G40:                       ;Write last message
  CALL WriteZErr           ;Write it
G90:                       ;Done
  MOV  CX,BP               ;Return CX = number of spaces to write
  POP  ES,DS,BP            ;Restore used registers
  POP  SI,DI,DX,BX,AX      ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;MISCELLANEOUS COMMAND-LINE RELATED STUFF
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET OUR REAL PROGRAM NAME
;Inputs:
;Outputs: RealName, RealNameSz
;Changes:
;------------------------------------------------------------------------------
GetRealName:
  PUSH AX,CX,DI,SI      ;Save used registers
  PUSH DS,ES            ;Save used registers
  MOV  DS,[PSPEnvirSeg] ;Point DS and ES
  MOV  ES,DS            ;  at the environment segment
  XOR  DI,DI            ;Point at the beginning of Environment variable list
  MOV  CX,-1            ;Max out the count limiter
  XOR  AX,AX            ;Need to look for a double 0
N10:                    ;Loop to here to skip over environment variables
  REPNE SCASB           ;Look for the end of this environment variable
  CMP  B [DI],0         ;Is it the end of the variable list (double zero)?
  JNE  N10              ;If not, keep skipping over environment variables
  CMP  W [DI+1],0       ;If so, is there at least one string after the env?
  JE  >N90              ;If not, we're done
  LEA  SI,[DI+3]        ;If so, point DS:[SI] at the True Name
  MOV  ES,CS            ;Point ES (for ES:[DI]) at our local data
N20:                    ;Loop to here to skip over drive/path info
  MOV  DI,RealName      ;Point at the beginning of our data area
  XOR  CX,CX            ;Start the length counter at 0
N30:                    ;Loop to here for each character in the name
  LODSB                 ;Get the next character of the name
  CMP  AL,'.'           ;Is it a dot?
  JE  >N40              ;If so, we may have the name
  CMP  AL,BackSlash     ;Is it a path separator?
  JE   N20              ;If so, start looking for the name again
  CALL Capitalize       ;If part of a name, capitalize the character
  STOSB                 ;Store it in our data area
  INC  CX               ;Increment the size counter
  JMP  N30              ;And keep looking for more characters
N40:                    ;We may have the name
  LODSB                 ;Get the next character of the name
  OR   AL,AL            ;End of the name?
  JZ  >N50              ;If so, it really was our program name
  CMP  AL,BackSlash     ;Was it a Directory with a dotted name?
  JE   N20              ;If so, keep looking for a file name
  JMP  N40              ;If not, keep looking for the end of the name
N50:                    ;Have the name
  XOR  AL,AL            ;Store
  STOSB                 ;  a 0
  MOV  CS:RealNameSz,CX ;Store the Size
N90:                    ;We're done
  POP  ES,DS            ;Restore used registers
  POP  SI,DI,CX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE POINTERS TO THE ENVIRONMENT VARIABLES WE NEED
;Inputs:  CS = DS = Local Data Area (also PSP Data Area)
;Outputs: Various Environment Pointers
;Changes:
;------------------------------------------------------------------------------
GetEnvVars:
  PUSH BX,CX,SI                    ;Save used registers
  MOV  SI,PathVarString1           ;Get
  MOV  BX,OFFSET PathVarPointer    ;  the
  MOV  CX,PathVarSize              ;  PATH
  CALL GetEnvVarPointer            ;  Pointer
  JNZ >V20                         ;If OK, continue
  MOV  SI,PathVarString2           ;If no, try
  CALL GetEnvVarPointer            ;  "Path" instead of "PATH"
V20:                               ;Get Program Variable
  MOV  SI,EnvVarString             ;Get
  MOV  BX,OFFSET EnvVarPointer     ;  our
  MOV  CX,EnvVarSize               ;  Program Variable
  CALL GetEnvVarPointer            ;  Pointer
V50:                               ;Get CMDLINE string
  CMP  B [80h],7Eh                 ;Is command line size maxed out?
  JB  >V90                         ;If not, don't worry about CMDLINE Env Var
  MOV  SI,CmdLineVarString         ;Get
  MOV  BX,OFFSET CmdLineVarPointer ;  the
  MOV  CX,CmdLineVarSize           ;  CMDLINE
  CALL GetEnvVarPointer            ;  Pointer
  CALL AdjustCmdLine               ;Compensate CMDLINE Pointer for Program Name
V90:                               ;Done
  POP  SI,CX,BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE POINTER TO AN ENVIRONMENT VARIABLE
;Inputs:   CS = DS = Local Data Area (also contains PSP)
;         [BX] = Where to store the Pointer at
;          CX  = Length of String
;         [SI] = Environment Variable String to Look for (ends in =)
;Outputs: ZF = Set if Error (Variable not found)
;               [BX] = -1
;             = Clear if OK (variable was found)
;               [BX] = Pointer to String (in Environment Segment, NOT PSP!!)
;Changes:
;------------------------------------------------------------------------------
GetEnvVarPointer:
  PUSH AX,CX,SI,BP      ;Save used registers
  PUSH DS,ES            ;Save used registers
  MOV  W [BX],-1        ;Default = -1 (does not exist)
  MOV  ES,[PSPEnvirSeg] ;ES:[DI] =
  XOR  DI,DI            ;  Environment Variable List
  MOV  DX,CX            ;Save the Size
  MOV  BP,SI            ;Save the original Pointer
  XOR  AL,AL            ;Need to look for 0's
V10:                    ;Loop to here for each Environment variable
  MOV  CX,DX            ;CX = Number of bytes to test
  MOV  SI,BP            ;DS:[SI] = String to Test for
  REPE CMPSB            ;Is it a match?
  JZ   >V30             ;If so, continue
  MOV  CX,-1            ;Max out the count limiter
  REPNE SCASB           ;Look for the end of this environment variable
  CMP  B ES:[DI],AL     ;End of Environment?
  JNE  V10              ;If not, keep looking
  JMP >V90              ;If so, no variable
V30:                    ;Found it!
  MOV  [BX],DI          ;Store the Pointer
V90:                    ;Done
  CMP  W [BX],-1        ;Set return flag
  POP  ES,DS            ;Restore used registers
  POP  BP,SI,CX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADJUST THE CMDLINE ENVIRONMENT VARIABLE POINT TO POINT AT THE COMMAND TAIL
;Inputs:  DS = Local Data Area (and PSP Segment)
;         CmdLineVarPtr (-1 if does not exist)
;           Unadjusted for Program Path/Name
;Outputs: CmdLineVarPtr
;           Adjusted (Program Path/Name skipped over to leave Command Tail)
;Changes:
;NOTES: The CMDLINE environment variable, which is only set by SOME
;         versions of DOS, contains the entire contents of the command
;         line.  The "entire contents" includes our executable file name
;         (including the path, if it was provided), but does not include
;         the redirection and/or piping parameters.
;       This routine skips over the executable file name part and simply
;         points at the command tail (the "Options" part of the command line).
;       The CMDLINE variable is used by some versions of DOS (such as 4DOS/NDOS
;         and DOS 95) to allow the command-line to be longer than the 126
;         characters normally allowed by DOS.
;------------------------------------------------------------------------------
AdjustCmdLine:
  PUSH AX,DX,SI,DS             ;Save used registers
  MOV  SI,CmdLineVarPointer    ;[SI] = CMDLINE environment variable contents
  CMP  SI,-1                   ;Anything there?
  JE  >J90                     ;If not, no need for changes
  MOV  DL,"/"                  ;Assume Get SwitchChar function is unsupported
  MOV  AX,3700h                ;Function 3700h (Get DOS SwitchChar)
  INT  21h                     ;Do it (returns DL)
  MOV  DS,[PSPEnvirSeg]        ;DS:[SI] = CMDLINE contents
J10:                           ;Loop to here to skip initial spaces & tabs
  LODSB                        ;Get the next character
  CMP  AL,' '                  ;Space?
  JE   J10                     ;If so, keep skipping
  CMP  AL,Tab                  ;Tab?
  JE   J10                     ;If so, keep skipping
J20:                           ;Skipped initial Tabs & Spaces
  DEC  SI                      ;Point back at the first character
  XOR  AH,AH                   ;Assume no quotes
  CMP  AL,Quote2               ;Double Quote (part of LFN Path & File Name)?
  JNE >J30                     ;If not, continue
  MOV  AH,AL                   ;If so, mark as a quote
  INC  SI                      ;Update the Pointer
J30:                           ;Loop to here for each character
  LODSB                        ;Get next character
  OR   AH,AH                   ;Are we looking for a Quoted Path/File Name?
  JZ  >J40                     ;If not, continue
J35:                           ;Looking for the Closing Quote
  CMP  AL,AH                   ;Is it the Closing Quote?
  JNE >J50                     ;If not, keep looking
  JMP >J85                     ;If so, we're done
J40:                           ;Not a Quoted Path/File Name
  OR   AL,AL                   ;End of variable?
  JE  >J80                     ;If so, handle it
  CMP  AL,' '                  ;Space?
  JE  >J80                     ;If so, we're done
  CMP  AL,Tab                  ;Tab?
  JE  >J80                     ;If so, we're done
  CMP  AL,'/'                  ;Slash?
  JE  >J80                     ;If so, we're done
  CMP  AL,DL                   ;SwitchChar?
  JE  >J80                     ;If so, we're done
J50:                           ;Not end-of-name
  JMP  J30                     ;Keep looking
J80:                           ;[SI-1] = CMDLINE Pointer
  DEC  SI                      ;Point at beginning of string
J85:                           ;[SI] = New CMDLINE Pointer
  MOV  CS:CmdLineVarPointer,SI ;Store it
J90:                           ;Done
  POP  DS,SI,DX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE ENVIRONMENT VARIABLE CONTENTS TO THE SCREEN
;Inputs:  EnvVarPointer (-1 if no Environment variable exists)
;Outputs:
;Changes: Writes to CON or ERR
;------------------------------------------------------------------------------
WriteEnvCon:
  PUSH AX               ;Save used registers
  XOR  AL,AL            ;Flag to write to CON
;  JMP >W00              ;Do it
;WriteEnvErr:
;  PUSH AX               ;Save used registers
;  MOV  AL,1             ;Flag to write to ERR
;W00:                    ;Write the Environment string to CON or ERR
  PUSH DX,DS            ;Save used registers
  MOV  DX,EnvVarPointer ;Get the Environment Variable Offset
  CMP  DX,-1            ;Valid Pointer?
  JE  >W90              ;If not, quit
  SUB  DX,EnvVarSize    ;Point DX at beginning of the Variable
  MOV  DS,[PSPEnvirSeg] ;Point DS at the Environment Segment
  OR   AL,AL            ;Should we write to CON?
  JZ  >W70              ;If so, jump to do it
  CALL WriteZErr        ;If not, write to ERR
  JMP >W90              ;And quit
W70:                    ;Write to CON
  CALL WriteZPause      ;Write it
W90:                    ;We're done
  POP  DS,DX            ;Restore used registers
  POP  AX               ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO WRITE SPECIAL MESSAGES TO THE SCREEN (HELP, STATUS, ETC.)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;Write Program Help Message
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;PRINT THE SYNTAX HELP MESSAGE AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;Outputs: Writes Help Message to the screen
;Changes: Quits program
;------------------------------------------------------------------------------
DoHelp:
  TEST ProgFlags,Help  ;Does the user want help?
  JZ  >H90             ;If not, we're done
  MOV  DX,SyntaxMsgHdr ;Write the first part
  CALL WriteZPause     ;  of the Help Message
  MOV  DX,RealName     ;Write the
  CALL WriteZPause     ;  Real Program Name
  CALL WriteSpace      ;Write a space
  MOV  DX,SyntaxMsg    ;Point at the last part of the Help Message
  XOR  AL,AL           ;ErrorLevel = 0
  JMP  Exit            ;Quit
H90:                   ;No need to do help
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE BAD DEVICE LIST
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;PRINT THE BAD DEVICE TABLE AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;         ES = TSR Data Area
;Outputs: Writes contents of Bad Device Table to the screen
;Changes: Quits program
;         Lots of Registers
;------------------------------------------------------------------------------
DoBadDevices:
  TEST StatusFlags,BadDevices ;Does the user want the Bad Device List?
  JZ  >B000                   ;If not, we're done
  TEST ProgFlags,InMemory     ;Are we installed in memory yet?
  JNZ >B00                    ;If so, continue
  MOV  DX,BadDvcErrMsg        ;If not, point at the first part of Error Message
  JMP  FinishDataErr          ;Terminate program
B000:
  RET

B00:                               ;Write it
  MOV  DX,BadBeepMsg               ;Write the
  CALL WriteZPause                 ;  Beep Header
  MOV  DX,YesMsg                   ;Assume Yes
  TEST ES:TSRFlags,NoBeep          ;Is it Yes?
  JZ  >B05                         ;If so, continue
  MOV  DX,NoMsgS                   ;If not, point at No Message
B05:                               ;Have Beep Status Message
  CALL WriteZPause                 ;Write the Beep Status
  CALL WriteCrLfPause2             ;Move down
  MOV  DX,BadDeviceHdr             ;Write the
  CALL WriteZPause                 ;  Header
  CALL TestSupportFile             ;Look for the Support File in the Path
  XOR  BL,BL                       ;Start Bad Counter at 0
  MOV  SI,BadDeviceTable           ;Point at Bad Table
  MOV  CX,MaxBadDevices            ;Number of Table Entries
B10:                               ;Loop to here for each table entry
  TEST ES:[SI].BDFlags,BDFlagInUse ;Valid Entry?
  JZ  >B40                         ;If not, skip it
  INC  BL                          ;Increment Bad Counter
  CALL WriteSpace                  ;Write
  MOV  AL,ES:[SI].BDHostIndex      ;  the
  CALL ByteToString                ;  Host Index
  CALL Write2Spaces                ;Write
  MOV  AL,ES:[SI].BDDvcAddress     ;  the
  CALL ByteToString                ;  Device Address
  CALL Write2Spaces                ;Write
  MOV  AL,ES:[SI].BDInterfaceNum   ;  the
  CALL ByteToString                ;  Interface Number
  CALL WriteBadStage               ;Write the Stage details
B40:                               ;Go to next entry
  ADD  SI,BadDeviceStrucSize       ;Point at next Entry
  LOOP B10                         ;Keep going until we're done
  OR   BL,BL                       ;Were there any Bad Devices?
  JNZ >B70                         ;If so, we're done
  MOV  DX,NoneFoundMsg             ;If not, write
  CALL WriteZPause                 ;  "None Found" Message
B70:                               ;Done
  MOV  DX,NoMsg                    ;Write nothing when done
  XOR  AL,AL                       ;ErrorLevel=0
  JMP  Exit                        ;And QUIT

;------------------------------------------------------------------------------
;WRITE THE BAD STAGE INFORMATION TO THE SCREEN
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [SI] = Bad Device Table Entry
;                Already checked for Validity (BDFlagInUse = True)
;                Host Index, Device Address, & Interface Number alread written
;Outputs: Write Try, Stage, and Error Code Numbers to the Table
;Changes:
;------------------------------------------------------------------------------
WriteBadStage:
  PUSH AX,CX                       ;Save used registers
  CALL WriteSpace                  ;Move over
  XOR  AH,AH                       ;Write the
  MOV  AL,ES:[SI].BDNewDeviceStage ;  Stage
  CALL WordToString                ;  Number
  CALL WriteSpace                  ;Move over
  MOV  CX,ES:[SI].BDNewDeviceError ;Write the
  CALL WriteBadError               ;  Error Code
  CALL WriteCrLfPause              ;Move down
  POP  CX,AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE ERROR CODE AND APPROPRIATE DESCRIPTION TO THE SCREEN
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;          AL  = Stage Number
;          CX  = Error Code to write
;         [SI] = Bad Device Entry
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteBadError:
  PUSH AX,CX,DX         ;Save used registers
  MOV  Indent,28        ;Use 32 space indent
  XCHG AX,CX            ;AX = Error Code, CL = Stage
  CALL WriteWordHex     ;Write the Error Code
  CALL WriteHexEnd      ;Write an h
  CMP  CL,100           ;Is the Stage less than 100?
  JB  >E20              ;If so, it's a legitimate TD or Int 14 Error
E10:                    ;Is a SCSI Error
  CALL WriteBadSCSI     ;Write the SCSI Codes
  MOV  Indent,30        ;Adjust Indent
  CALL WriteSCSIErrs    ;Write the Error Descriptions
  JMP >E90              ;Done
E20:                    ;Valid TD or Int14 Error
  CALL Write2Spaces     ;Move over
  TEST ProgFlags,FoundSuptFile ;Is there a Support File in the Path?
  JNZ >E40              ;If so, continue
E30:                    ;No Support File
  MOV  DX,NoSuptFileMsg ;If not, write first part
  CALL WriteZPause      ;  of Error Message
  MOV  DX,SupportFile   ;Write the Support
  CALL WriteZPause      ;  File Name
  JMP >E90              ;Done
E40:                    ;OK to call support File
  CMP  CL,100           ;Is the stage more than 100?
  JAE >E60              ;If so, it's a TD Status Error
  TEST CL,1             ;If not, is it even (TD Status) or odd (Int 14h Error)?
  JZ  >E60              ;If Even, jump to handle it
E50:                    ;Int 14h Error Code (Stage is Odd)
  CALL WriteInt14Err    ;Write the Int 14h Error Code
  JMP >E90              ;Done
E60:                    ;TD Status Code (Stage is Even)
  CALL WriteTDStsErr    ;Write the TD Status Error Code
E90:                    ;Done
  MOV  Indent,0         ;Reset Indent
  POP  DX,CX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE CODES ASSOCIATED WITH A SCSI REQUEST FOR A BAD DEVICE
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [SI] = Bad Device Entry
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteBadSCSI:
  PUSH EAX                          ;Save used registers
  CALL Write2Spaces                 ;Move over
  MOV  AL,ES:[SI].BDSCSIRequest     ;Get the Request Type
  CALL WriteByteHex                 ;Write the
  CALL WriteHexEnd                  ;  Request Type
  CALL WriteSpace                   ;Move over
  MOV  EAX,D ES:[SI].BDSCSISetupErr ;Get Error Data (Stp, Dta, Sts, CSW)
  CALL WriteByteHex                 ;Write the
  CALL WriteHexEnd                  ;  Setup Error
  CALL WriteSpace                   ;Move over
  SHR  EAX,8                        ;Write the
  CALL WriteByteHex                 ;  Data
  CALL WriteHexEnd                  ;  Error
  CALL WriteSpace                   ;Move over
  SHR  EAX,8                        ;Write the
  CALL WriteByteHex                 ;  Status
  CALL WriteHexEnd                  ;  Error
  CALL WriteSpace                   ;Move over
  SHR  EAX,8                        ;Write the
  CALL WriteByteHex                 ;  CSW
  CALL WriteHexEnd                  ;  Status
  CALL WriteSpace                   ;Move over
  MOV  EAX,ES:[SI].BDCSWResidue     ;Get Residue
  CALL WriteDWordHex                ;Write
  CALL WriteHexEnd                  ;  Residue
  CALL WriteSpace                   ;Move over
  MOV  AL,ES:[SI].BDSCSISenseKey    ;Get Sense Key
  CALL WriteByteHex                 ;Write
  CALL WriteHexEnd                  ;  Sense Key
  CALL WriteSpace                   ;Move over
  MOV  EAX,ES:[SI].BDSCSISenseInfo  ;Get Sense Info
  CALL WriteDWordHex                ;Write
  CALL WriteHexEnd                  ;  Sense Info
  CALL WriteSpace                   ;Move over
  MOV  AX,W ES:[SI].BDSCSIASC       ;Get ASC & ASCQ
  XCHG AL,AH                        ;Write
  CALL WriteWordHex                 ;  ASC &
  CALL WriteHexEnd                  ;  ASCQ
  CALL WriteCrLfPause               ;Move down
  POP  EAX                          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE ERROR DESCRIPTIONS FOR A BAD SCSI REQUEST
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [SI] = Bad Device Entry
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteSCSIErrs:
  PUSH AX,BX,DX                   ;Save used registers
  XOR  AX,AX                      ;AH = 0
E00:                              ;SCSI Request Type
  MOV  DX,RequestTypeMsg          ;[DX] = Header String
  MOV  AL,ES:[SI].BDSCSIRequest   ;Get the Request Type
  CALL WriteSCSIErrHdrB           ;Write the Header
  MOV  BX,SCSICmdTable            ;Write the
  CALL WriteByte2String           ;  Description
  CALL WriteSectorRW              ;Write the Sector Number, if appropriate
E10:                              ;Setup Stage
  MOV  DX,SetupErrMsg             ;Assume Setup Stage Error
  MOV  AL,ES:[SI].BDSCSISetupErr  ;Get the Error Code
  CALL WriteSCSIErr               ;Write it, if appropriate
E20:                              ;Data Stage
  MOV  DX,DataStgErrMsg           ;Assume Data Stage Error
  MOV  AL,ES:[SI].BDSCSIDataErr   ;Get the Error Code
  CALL WriteSCSIErr               ;Write it, if appropriate
E30:                              ;Status Stage
  MOV  DX,StatusStgErrMsg         ;Assume Status Stage Error
  MOV  AL,ES:[SI].BDSCSIStatusErr ;Get the Error Code
  CALL WriteSCSIErr               ;Write it, if appropriate
E40:                              ;Command Status Wrapper
  MOV  DX,CSWErrMsg               ;Assume Command Status Wrapper Error
  MOV  AL,ES:[SI].BDSCSICSWStatus ;Get the Error Code
  OR   AX,AX                      ;Error?
  JZ  >E50                        ;If not, skip it
  CMP  AL,-1                      ;Valid?
  JE  >E50                        ;If not, skip it
  CALL WriteSCSIErrHdrB           ;Write the Header
  AND  AL,0Fh                     ;Mask out vendor-specific bits
  MOV  BX,CSWErrTbl               ;Write the
  CALL WriteByte2String           ;  Error Description
E50:                              ;Sense Key
  MOV  DX,SenseKeyErrMsg          ;Assume Sense Key Error
  MOV  AL,ES:[SI].BDSCSISenseKey  ;Get the Error Code
  OR   AX,AX                      ;Error?
  JZ  >E60                        ;If not, skip it
  CMP  AL,-1                      ;Valid?
  JE  >E60                        ;If not, skip it
  CALL WriteSCSIErrHdrB           ;Write the Header
  AND  AL,SReqRespSenseMask       ;Mask out unwanted bits
  MOV  BX,SenseKeyTbl             ;Write the
  CALL WriteByte2String           ;  Error Description
E60:                              ;ASC/ASCQ
  MOV  DX,ASCErrMsg               ;Assume Additional Status Codes
  MOV  AX,W ES:[SI].BDSCSIASC     ;Get the Code
  OR   AX,AX                      ;Error?
  JZ  >E90                        ;If not, skip it
  CMP  AX,-1                      ;Error?
  JE  >E90                        ;If not, skip it
  XCHG AL,AH                      ;  the
  CALL WriteSCSIErrHdrW           ;Write the Header
  MOV  BX,ASCQTable               ;Write
  CALL WriteWord2String           ;  Description
E90:                              ;Done
  CALL WriteCrLfPause             ;Move down
  POP  DX,BX,AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE LAST ACCESSED SECTOR, IF APPROPRIATE
;Inputs:      AL  = SCSI Request Code
;         ES:[SI] = Bad Device Structure
;             DS  = Local Data Area
;         CLD already issued
;Outputs: To screen, if appropriate
;Changes
;------------------------------------------------------------------------------
WriteSectorRW:
  PUSH EAX,DX,DI,SI     ;Save used registers
  MOV  DI,SI            ;[DI] = Bad Device Structure
  MOV  SI,SectorRWTable ;[SI] = Table to search
  MOV  AH,AL            ;Save SCSI Request Code
S10:                    ;Loop to here for each table entry
  LODSB                 ;Get the next table entry
  CMP  AL,-1            ;End of the Table?
  JE  >S90              ;If so, we're done
  CMP  AL,AH            ;If not, does it match what we're looking for?
  JNE  S10              ;If not, keep looking
S20:                    ;It's a match
  MOV  DX,SectorRWMsg1  ;Write
  CALL WriteZPause      ;  the Header
  MOV  EAX,ES:[DI].BDLastSectorRW ;Write
  CALL WriteDWordHex              ;  the
  CALL WriteHexEnd                ;  Sector Number
  MOV  DX,SectorRWMsg2  ;Write
  CALL WriteZPause      ;  the Footer
S90:                    ;Done
  POP  SI,DI,DX,EAX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE ERROR DESCRIPTION FOR A SINGLE BAD SCSI (USB STAGE) REQUEST
;Inputs:   AL  = USB Error Code
;          AH  = 0
;         [DX] = Header string to write for error
;Outputs: To screen, if appropriate
;Changes:
;------------------------------------------------------------------------------
WriteSCSIErr:
  PUSH DX               ;Save used registers
  OR   AX,AX            ;Is there an error?
  JZ  >C90              ;If not, skip it
  CMP  AL,-1            ;Is there an error?
  JE  >C90              ;If not, skip it
  CALL WriteSCSIErrHdrB ;Write the Header
  TEST ProgFlags,FoundSuptFile ;Is there a Support File in the Path?
  JZ  >C70              ;If not, handle it
  CALL WriteTDStsErr    ;Write the Error Description
  JMP >C90              ;Done
C70:                    ;Error (No Support File)
  MOV  DX,NoSuptFileMsg ;If not, write first part
  CALL WriteZPause      ;  of Error Message
  MOV  DX,SupportFile   ;Write the Support
  CALL WriteZPause      ;  File Name
C90:                    ;Done
  POP  DX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE HEADER (FIRST PART) OF A SCSI REQUEST ERROR STATUS
;Inputs:   DS  = Local Data Area
;         [DX] = Header String to write
;          AL/AX  = Code to Write
;Outputs: To screen
;         Moves down a line, writes Header, Code, and Equals
;Changes:
;------------------------------------------------------------------------------
WriteSCSIErrHdrB:
  PUSH CX,BP           ;Save used registers
  MOV  CL,2            ;CL = Number of Spaces
  MOV  BP,WriteByteHex ;BP = Code to Call
  JMP >H00             ;Do it
WriteSCSIErrHdrW:
  PUSH CX,BP           ;Save used registers
  XOR  CL,CL           ;CL = Number of Spaces
  MOV  BP,WriteWordHex ;BP = Code to Call
;  JMP >H00             ;Do it
H00:
  CALL WriteCrLfPause  ;Move down
  CALL Write2Spaces    ;Move over
  CALL WriteZPause     ;Write the Header
  CALL WriteColon      ;Write
  CALL WriteSpace      ;  a Colon
  CALL WriteSpaces     ;Write
  CALL BP              ;  the
  CALL WriteHexEnd     ;  Error Code
  CALL WriteSpace      ;Write
  CALL WriteEquals     ;  an
  CALL WriteSpace      ;  Equals
  POP  BP,CX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE TD STATUS OR INT 14H ERROR DESCRIPTION TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         AX = TD Status Code to write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteTDStsErr:
  PUSH BX,CX,DX           ;Save used registers
  MOV  BX,TDStatusCode    ;[BX] = Where to write Code Number
  MOV  CX,TDStatusCallBk  ;[CX] = Where to write Screen-writing Address
  MOV  DX,TDStatusMsg     ;[DX] = Start of command-tail string
  JMP >R00                ;Do it
WriteInt14Err:
  PUSH BX,CX,DX           ;Save used registers
  MOV  BX,Int14ErrCode    ;[BX] = Where to write Code Number
  MOV  CX,Int14ErrCallBk  ;[CX] = Where to write Screen-writing Address
  MOV  DX,Int14ErrMsg     ;[DX] = Start of command-tail string
;  JMP >R00               ;Do it
R00:
  PUSH AX                 ;Save used registers
  CALL WriteWordToString  ;Write the Error Code to our string
  MOV  BX,CX              ;Write our
  MOV  AX,CS              ;  screen-writing
  MOV  CX,WriteZPauseFar  ;  code address
  CALL WriteSegmentOffset ;  to the string
  MOV  BX,DX              ;Copy our String
  CALL CopyToCmdTail      ;  to the Command Tail String
  CALL DoExec             ;Write the Description
  POP  AX                 ;Restore used registers
  POP  DX,CX,BX           ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE COMMAND-LINE ALIASES
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;PRINT THE COMMAND LINE ALIASES AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;Outputs: Writes Aliases to the screen
;Changes: Quits program
;------------------------------------------------------------------------------
DoAliases:
  TEST StatusFlags,Alias  ;Does user want to see the Aliases?
  JZ  >A95                ;If not, we're done
  PUSH BX,DX,SI           ;Save used registers
  CALL WriteCrLfPause     ;Move down
  MOV  DX,AliasHdrMsg     ;Set up
  CALL SetupPause         ;  the Header
  MOV  SI,SwitchList      ;Point at Tbl of Aliases
  MOV  BX,'?'+('Z' SHL 8) ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNoNum   ;Write the Aliases
  MOV  BX,1+(31 SHL 8)    ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNoNum   ;Write the Aliases
  CALL WriteCrLfPause2    ;Move down
  MOV  DX,YesNoHdrMsg     ;Set up
  CALL SetupPause         ;  the Header
  MOV  SI,SwitchListYesNo ;Point at Table of Aliases
  MOV  BX,'N'+('Y' SHL 8) ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNoNum   ;Write the Aliases
A90:                      ;Done
  POP  SI,DX,BX           ;Restore used registers
  MOV  DX,NoMsg           ;Don't write anything
  XOR  AL,AL              ;ErrorLevel = 0
  JMP  Exit               ;Quit
A95:                      ;No need to write Aliases
  RET

;------------------------------------------------------------------------------
;WRITE THE LIST OF SWITCH CHARACTERS TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         BL = Minimum Value to look for in the Table
;         DH = Maximum Value to look for in the Table
;         SI = Switch List ("Code Word") Table
;Outputs: Writes List of Switch Characters to the Screen
;Changes:
;NOTES:   Sets CH =  0 if we write Blocks for Switches < " "
;                 = -1 if we write numbers for the all Switches (0-255)
;                 = -2 if we subtract 128 from the numbers (128-255)
;------------------------------------------------------------------------------
;DoAliasesGoNum80h:
;  PUSH CX               ;Save used registers
;  MOV  CH,2             ;Mark as writing Numbers, needing to subtract 128
;  JMP >G00              ;Continue
DoAliasesGoNum:
  PUSH CX               ;Save used registers
  MOV  CH,1             ;Mark as writing Numbers, not needing to modify
  JMP >G00              ;Continue
DoAliasesGoNoNum:
  PUSH CX               ;Save used registers
  XOR  CH,CH            ;Mark as not writing Numbers
;  JMP >G00              ;Continue
G00:
  PUSH AX,DI            ;Save used registers
  MOV  DI,AliasSortTbl  ;Point at the Alias Sort Table
  MOV  AL,BL            ;Start with the Lower Limit
G10:                    ;Loop to here for each Alias
  CALL GetAliasPointers ;Get the Alias Pointers
  JZ  >G60              ;If none for this entry, go to the next one
G20:                    ;Have at least one valid Alias
  CALL WriteCrLfPause   ;If valid, move down
  OR   CH,CH            ;Writing Single characters?
  JNZ >G40              ;If not, handle full numbers
  MOV  CL,78            ;Write this many characters per line
  CMP  AL,' '           ;Is there a valid single-character equivalent?
  JB  >G30              ;If not, don't write it
  CALL WriteAL          ;If so, write it
  JMP >G50              ;Continue
G30:                    ;Not a writable character
  CALL WriteBlock       ;Write a Block Character
  JMP >G50              ;Continue
G40:                    ;Need to write Numbers
  MOV  CL,76            ;Write this many characters per line
  PUSH AX               ;Save the number for a second
  CMP  CH,2             ;Do we need to modify the Number?
  JNE >G45              ;If not, continue
  AND  AL,(NOT 80h)     ;Subtract 128 from it
G45:                    ;Write the Number
  CALL ByteToString     ;Write the Switch as a Number
  POP  AX               ;Restore the Number
G50:                    ;Done writing single character
  CALL WriteAliases     ;Write the Alias List
G60:                    ;Done with this Code
  CMP  AL,BH            ;Have we done the whole list yet?
  JE  >G90              ;If so, we're done
  INC  AL               ;If not, go to the next possibility
  JMP  G10              ;Keep going until we're done
G90:                    ;Done
  POP  DI,AX            ;Restore used registers
  POP  CX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET STRING POINTERS FOR ALL ALIASES FOR A SINGLE CHARACTER OPTION
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;          AL  = Switch Table entry to look for (not 0)
;         [SI] = Switch Table to look through, sorted backwards
;         [DI] = Alias Sort Table
;Outputs:  ZF = Clear if OK
;               [DI] = Filled with String Pointers, sorted backwards
;                      Last Entry is always a 0
;             = Set if no matches found
;                      First Entry is 0
;Changes:
;------------------------------------------------------------------------------
GetAliasPointers:
  PUSH AX,BX,CX,DX      ;Save used registers
  PUSH DI,SI            ;Save used registers
  MOV  CX,DI            ;Sve original pointer
P10:                    ;Loop to here for each Table Entry
  MOV  DX,SI            ;Save beginning Alias Pointer
P20:                    ;Loop to here to find the end of an Alias List Entry
  CMP  B [SI],0         ;End of Alias List?
  JE  >P30              ;If so, handle it
  CALL SkipOverStringSI ;If not, skip over the string
  JMP  P20              ;Keep looking
P30:                    ;End of Alias List Entry
  MOV  BX,SI            ;Save End-of-Entry Pointer
  CMP  AL,[SI+1]        ;Is this entry a match?
  JNE >P50              ;If not, go to the next one
  MOV  SI,DX            ;Point at Alias String
P40:                    ;Loop to here for each Alias String
  CMP  B [SI],0         ;End of the entry?
  JE  >P50              ;If so, we're done
  MOV  [DI],SI          ;If not, store it in the sort table
  INC  DI,2             ;Update the Table Pointer
  CALL SkipOverStringSI ;Skip over the string
  JMP  P40              ;Keep going until we have all of the strings
P50:                    ;Done with this entry
  MOV  SI,BX            ;Get End-of-Entry Pointer
  INC  SI,2             ;Skip over End-of-Entry stuff
  CMP  B [SI],0         ;End of Table?
  JNE  P10              ;If not, keep looking
P90:                    ;Done
  MOV  W [DI],0         ;Make sure last entry is a 0
  CMP  CX,DI            ;Set return flag
  POP  SI,DI            ;Restore used registers
  POP  DX,CX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ALL ALIAS STRINGS FOR A SINGLE CHARACTER OPTION
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = Alias String Pointer Table (Sorted backwards)
;                  Last Entry is a 0
;          CL  = Number of characters left available to write on first line
;                 (76 if Writing Numbers, 78 if Writing Characters)
;         CLD already issued
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteAliases:
  PUSH AX,BX,CX,DX    ;Save used registers
  PUSH DI,SI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at the Local Data Area
  MOV  BL,CL          ;BL = Character Countdown Measurer
  MOV  BH,CL          ;BH = Original Counter
  MOV  DX,DI          ;Save start-of-table Pointer
  MOV  CX,-1          ;Maximize counter
  XOR  AX,AX          ;Find the last
  REPNE SCASW         ;  entry in
  SUB  DI,4           ;  the Table
W10:                  ;Loop to here for each Alias String
  CMP  DI,DX          ;Are we done writing?
  JB  >W90            ;If so, quit
  MOV  SI,[DI]        ;Get the next string
  DEC  DI,2           ;Update the table pointer
  CALL CalcStrSizeSI  ;See how long the string is
  OR   BL,BL          ;Is the character counter down to 0?
  JZ  >W20            ;If so, we need to reset it
  CMP  CL,BL          ;Is this string too long to fit on this line?
  JB  >W40            ;If not, go ahead and write it
W20:                  ;Need to start a new line
  CALL WriteCrLfPause ;Start a new line
  PUSH CX             ;Save String Size for a second
  MOV  CL,79          ;Calculate how many
  SUB  CL,BH          ;  spaces to write
  CALL WriteSpaces    ;Write the spaces
  POP  CX             ;Restore String Size
  MOV  BL,BH          ;Reset the character counter
W40:                  ;Write the Alias String
  SUB  BL,CL          ;Update the
  DEC  BL             ;  character counter
  CALL WriteSpace     ;Write a Space
  CALL WriteZPauseSI  ;Write the string
  JMP  W10            ;Keep writing
W90:                  ;Done
  CALL WriteCrLfPause ;Move down
  POP  ES,SI,DI       ;Restore used registers
  POP  DX,CX,BX,AX    ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE THE ERRORLEVEL TABLE
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE ERRORLEVEL TABLE TO THE SCREEN AND QUIT
;Inputs:  CS = DS = Local Data Area
;Outputs: Writes ErrorLevel Table to the Screen
;Changes: Quits Program
;         Several registers
;------------------------------------------------------------------------------
DoErrLvls:
  TEST StatusFlags,ErrLvl   ;Does the user want to see the ErrorLevels?
  JZ  >V95                  ;If not quit
  MOV  DX,ErrLvlHdr         ;Write the
  CALL SetupPause           ;  Table Header
  MOV  AL,1                 ;Start with ErrorLevel 1
V10:                        ;Loop to here for each table entry
  MOV  BX,ErrLvlTbl         ;Table to search
  CALL SearchByte2StringTbl ;Valid ErrorLevel?
  JC  >V50                  ;If not, keep looking
  CALL WriteSpace           ;Move Over
  CALL ByteToString         ;If valid, write the Number
  CALL WriteSpace           ;Write a space
  MOV  DX,BX                ;Write the
  CALL WriteZPause          ;  Description String
  CALL WriteCrLfPause       ;Write a New Line
V50:                        ;Done with this entry
  INC  AL                   ;Increment ErrorLevel
  JNZ  V10                  ;If not rolled over yet, keep looking
V90:                        ;Done
  MOV  DX,NoMsg             ;Don't write anything
  XOR  AL,AL                ;ErrorLevel = 0
  JMP  Exit                 ;Quit
V95:                        ;No need to write Aliases
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE THE FIRST DRIVE LETTER
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE FIRST DRIVE LETTER WE WILL USE TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteFirstDrive:
  PUSH AX,BX,DX              ;Save used registers
  MOV  DX,FirstDriveMsg      ;Write the
  CALL WriteZPause           ;  Header
  MOV  BX,ES:DriveInfoOffset ;[BX] = Drive Info Table
  TEST ES:[BX].DrvFlags,DrvFlagValid ;Valid Drive Number?
  JZ  >W70                   ;If not, write None
  MOV  AL,ES:[BX].DrvDPB.DPBDriveNum ;Get the first Drive Number
  ADD  AL,'A'                ;Convert it to a Drive Letter
  CALL WriteAL               ;Write it
  CALL WriteColon            ;Write a Colon
  JMP >W90                   ;Done
W70:                         ;No Drive Available
  CALL WriteNone             ;Write "None"
W90:                         ;Done
  CALL WriteCrLfPause2       ;Move down
  POP  DX,BX,AX              ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE PROGRAM/DISK STATUS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE CURRENT STATUS TO THE SCREEN
;Inputs:  ES = TSR Data Area
;         Status (Flag)
;Outputs: Writes a bunch of stuff to the screen if Status Flag is True
;Changes:
;------------------------------------------------------------------------------
DoStatus:
  TEST StatusFlags,Status ;Need to to anything?
  JZ  >S99                ;If not, quit
  TEST ProgFlags,InMemory ;If so, are we installed as a TSR yet?
  JNZ >S00                ;If so, continue
  MOV  DX,NoStatusMsg     ;If not, write first part
  MOV  AL,ErLvlStatus     ;ErrorLevel = not installed yet
  JMP  Exit               ;Terminate program
S99:                      ;No need to show Status
  RET

S00:                          ;Need to do Status
  PUSH AX,BX,DX,DI            ;Save used registers
  MOV  DX,InitDelayMsg        ;Write the
  CALL WriteZPause            ;  Header
  MOV  AX,ES:InitDelay        ;Get the Delay Timer Ticks
  MOV  BX,10                  ;Convert
  MUL  BX                     ;  Timer
  MOV  BX,182                 ;  Ticks
  DIV  BX                     ;  to Seconds
  CMP  DX,91                  ;  Round
  JBE >S05                    ;  Up
  INC  AX                     ;  if necessary
S05:                          ;AX = Initialization Delay in seconds
  CALL WriteByteMin           ;Write the Initialization Delay

  MOV  DX,DOSVersionMsg       ;Write the
  CALL WriteZPause            ;  Header
  MOV  AX,ES:DOSVersion       ;Get the DOS version
  XCHG AL,AH                  ;Write the
  CALL WriteByteMin           ;  Major Version
  CALL WriteDot               ;Write a Dot
  XCHG AL,AH                  ;Convert the Minor Version
  AAM                         ;  to BCD characters
  XCHG AL,AH                  ;Write the first character
  CALL WriteByteMin           ;  of the Minor Version
  XCHG AL,AH                  ;Write the second character
  CALL WriteByteMin           ;  of the Minor Version

  MOV  DX,MaxSectorSizeMsg    ;Write the
  CALL WriteZPause            ;  Header
  MOV  AX,ES:MaxBytesPerSect  ;Write the
  CALL WordToString           ;  Maximum Bytes per Sector

  MOV  DX,MountFAT32Msg       ;Write the
  CALL WriteZPause            ;  Header
  MOV  DX,NoMsgS              ;Assume no mounting of FAT32 volumes
  TEST ES:TSRFlags,UseFAT32   ;Do we mount FAT32 volumes?
  JZ  >S10                    ;If not, continue
  MOV  DX,YesMsg              ;If so, write Yes
S10:                          ;[DX] = Message to write
  CALL WriteZPause            ;Write the Status Message

  MOV  DX,XferSectsMsg        ;Write the
  CALL WriteZPause            ;  Header
  MOV  AL,B ES:XferSects[0]   ;Write the
  CALL ByteToString           ;  value
  CALL WriteCrLfPause         ;Move
  CALL WriteCrLfPause2        ;  down

  MOV  DX,StatusMsg           ;Write
  CALL SetupPause             ;  the Header
  MOV  DI,ES:DeviceInfoOffset ;[DI] = Device Info Table
  XOR  AH,AH                  ;AH = Starting Index
S20:                          ;Loop to here for each Device
  TEST ES:[DI].DvcFlags,DvcFlagInUse ;Valid table entry?
  JZ  >S50                    ;If not, skip it
  CALL DoDvcStatus            ;If so, write the Device Info
  MOV  AL,-1                  ;Start with Disk Index 0
S30:                          ;Loop to here for each Disk Entry
  INC  AL                     ;INcrement Disk Index
  CALL GetDiskForDevice       ;Get the Disk Info ([BX])
  JC  >S50                    ;If none, we're done with this Device
  CALL DoDiskStatus           ;If so, write the Disk Info
  JMP  S30                    ;Keep going until we're done
S50:                          ;Done with this Device
  ADD  DI,DeviceInfoSize      ;Point at next Device Entry
  INC  AH                     ;Increment Device Index
  CMP  AH,B ES:NumDevices[0]  ;Done all of the Table Entries yet?
  JB   S20                    ;If not, keep looking
S60:                          ;Done with valid Devices
  CALL WriteCrLfPause         ;Move down
  CALL WriteUnusedDevices     ;Write Unused Device/Interface Indexes
  CALL WriteCrLfPause         ;Move down
  CALL WriteUnusedDisks       ;Write Unused INT 13h Disk Numbers
  CALL WriteCrLfPause         ;Move down
  CALL WriteUnusedDrives      ;Write Unused DOS Drive Letters
  CALL WriteCrLfPause2        ;Move down
  POP  DI,DX,BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE STATUS INFO FOR A SPECIFIC DEVICE
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;          AH  = Device Index
;         [DI] = Device Info Entry
;Outputs: Writes USB Device Status Info to the Screen
;Changes:
;------------------------------------------------------------------------------
DoDvcStatus:
  PUSH AX                         ;Save used registers
  MOV  AL,AH                      ;AL = Device Index
  CMP  AL,10                      ;Is it a double-digit number?
  JAE >V20                        ;If so, continue
V10:                              ;Indent written, if appropriate
  CALL WriteSpace                 ;Write a Space
V20:                              ;Space handled, if necessary
  CALL WriteByteMin               ;Write the Host Index
  CALL WriteSpace                 ;Move over
  MOV  AL,ES:[DI].DvcHostIndex    ;Get Host Index
  CMP  AL,10                      ;Is it a double-digit number?
  JAE >V40                        ;If so, continue
V30:                              ;Indent handled, if necessary
  CALL WriteSpace                 ;Write a Space
V40:                              ;Space handled, if necessary
  CALL WriteByteMin               ;Write the Host Index
  CALL WriteSpace                 ;Move over
  MOV  AL,ES:[DI].DvcAddress      ;Write the
  CALL ByteToString               ;  Device Address
  MOV  AL,ES:[DI].DvcInterfaceNum ;Write the
  CALL ByteToString               ;  Interface Number
  POP  AX                         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE STATUS INFO FOR A SPECIFIC DISK
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [BX] = Disk Info Entry
;          AL  = DIsk Index on the Device
;Outputs: Writes USB Disk Status Info to the Screen
;Changes:
;------------------------------------------------------------------------------
DoDiskStatus:
  PUSH EAX,CX,SI                   ;Save used registers
  OR   AL,AL                       ;Is it Index 0?
  JZ  >K20                         ;If so, handle it
K10:                               ;Not Index 0
  MOV  CL,12                       ;Move
  CALL WriteSpaces                 ;  over
K20:                               ;Appropriate Indent Written
  MOV  AL,ES:[BX].DskLUN           ;Write the
  CALL ByteToString                ;  LUN
  CALL WriteSpace                  ;Move over
  MOV  AL,ES:[BX].DskInt13DrvNum   ;Write the
  CALL WriteByteHex                ;  INT 13h
  CALL WriteHexEnd                 ;  Drive Number
  CALL WriteSpace                  ;Move over
  CMP  ES:[BX].DskDrvTimer,DskStageOnHold ;Are we still initializing?
  JB  >K25                         ;If not, continue
  MOV  DX,InitializingMsg          ;If so,
  CALL WriteZPause                 ;  write "Initializing"
  JMP >K45                         ;We're done
K25:                               ;Not initializing
  MOV  AL,'Y'                      ;Write
  CMP  ES:[BX].DskAccessTimer,-1   ;  the
  JNE >K30                         ;  Removable
  MOV  AL,'.'                      ;  Media
K30:                               ;  Status
  CALL WriteAL                     ;  Flag
  CALL WriteSpace                  ;Move over
  MOV  AL,'Y'                      ;Write
  TEST ES:[BX].DskFlags,DskFlagWriteProt ;the
  JNZ >K40                         ; Write-
  MOV  AL,'.'                      ; Protect
K40:                               ; Status
  CALL WriteAL                     ; Flag
  MOV  AX,ES:[BX].DskNumHeads      ;Write Number
  CALL WordToString                ;  of Heads
  CALL WriteSpace                  ;Move over
  MOV  AX,ES:[BX].DskNumTracks     ;Write Number
  CALL WordToString                ;  of Cylinders (Tracks)
  MOV  AX,ES:[BX].DskSectsPerTrack ;Write Number of
  CALL WordToString                ;  Sectors Per Track
  MOV  AX,ES:[BX].DskBytesPerSect  ;Write Number of
  CALL WordToString                ;  Bytes Per Sector
  CALL WriteSpace                  ;Move over
  MOV  EAX,ES:[BX].DskMaxLBA       ;Write
  INC  EAX                         ;  Number
  CALL WriteDWordHex               ;  of
  CALL WriteHexEnd                 ;  Sectors
  CALL WriteSpace                  ;Move over
  CALL WriteCapacity               ;Write Disk Capacity
  CALL Write2Spaces                ;Move over
K45:                               ;DOne with Disk
  MOV  AL,-1                       ;Start with Drive Index 0
K50:                               ;Loop to here for each Drive Entry
  INC  AL                          ;Increment Disk Index
  CALL GetDriveForDisk             ;Get the Drive Info ([SI])
  JC  >K90                         ;If none, we're done with this Disk
  CALL DoDriveStatus               ;If so, write the Drive Info
  JMP  K50                         ;Keep going until we're done
K90:                               ;Done
  OR   AL,AL                       ;Did we write any Drive Information?
  JNZ >K95                         ;If so, we're done
  CALL WriteCrLfPause              ;If not, move down
K95:                               ;Really done
  POP  SI,CX,EAX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE STATUS INFO FOR A SPECIFIC DRIVE
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [BX] = Disk Info Entry
;         [SI] = Drive Info Entry
;          AL  = Drive Index on the Disk
;Outputs: Writes Drive Status Info to the Screen
;Changes:
;------------------------------------------------------------------------------
DoDriveStatus:
  PUSH EAX,CX                        ;Save used registers
  OR   AL,AL                         ;Is it Index 0?
  JZ  >R20                           ;If so, handle it
R10:                                 ;Not Index 0
  MOV  CL,65                         ;If not, just write
  CALL WriteSpaces                   ;  some spaces
R20:                                 ;Appropriate Indent written
  MOV  AL,ES:[SI].DrvDPB.DPBDriveNum ;Write
  ADD  AL,'A'                        ;  DOS
  CALL WriteAL                       ;  Drive Letter
  CALL WriteColon                    ;Write a Colon
  CALL WriteSpace                    ;Move over
  MOV  EAX,ES:[SI].DrvSectsInPart    ;Write
  CALL WriteCapacity                 ;  Drive Capacity
R90:                                 ;Done
  CALL WriteCrLfPause                ;Move down
  POP  CX,EAX                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE APPROXIMATE CAPACITY OF A DRIVE
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         EAX  = Number of Sectors to calculate size of
;         [BX] = Disk Info Entry (contains Byte Per Sector)
;Outputs: Writes Approximate Capacity to the Screen
;Changes:
;------------------------------------------------------------------------------
WriteCapacity:
  PUSH EAX,EBX,EDX,SI ;Save used registers
  AND  EBX,0000_FFFFh             ;EBX =
  MOV  BX,ES:[BX].DskBytesPerSect ;  Bytes Per Sector
  MUL  EBX            ;Multiply (EDX:EAX = Total Bytes)
  MOV  EBX,1000       ;Divide by 1000
  DIV  EBX            ;  (convert to kB)
  ;Assume no Overflow here - for a "normal" drive (512 Bytes/Sector) we're fine
  MOV  SI,Prefixes    ;Point at Prefix List
C10:                  ;Loop to here to divide into a manageable size
  CMP  EAX,65535      ;Is it still too big?
  JBE >C50            ;If not, we're done
C20:                  ;Numbers are still too big
  XOR  EDX,EDX        ;Divide by 1000
  DIV  EBX            ;  (go to next possible Prefix)
  INC  SI             ;Update Prefix Pointer
  JMP  C10            ;Keep dividing if we need to
C50:                  ;Done dividing for manageability
  CALL WordToString   ;Write the Number
  CALL WriteSpace     ;Move over
  MOV  AL,[SI]        ;Write the
  CALL WriteAL        ;  Prefix
  MOV  AL,'B'         ;Write the
  CALL WriteAL        ;  Bytes symbol
  POP  SI,EDX,EBX,EAX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE UNUSED (RESERVED) DEVICE INDEXES, INT 13h DISKS, OR DOS DRIVE LETTERS
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;Outputs: To Screen:
;           List of Disk Numbers/Ranges in an appropriate format
;Changes:
;------------------------------------------------------------------------------
WriteUnusedDevices:
  PUSH BX,CX,DX               ;Save used registers
  PUSH DI,SI,BP               ;Save used registers
  MOV  DX,UnusedDevicesMsg    ;[DX] = Header String
  MOV  DI,-1                  ;[DI] = Flag for Index
  MOV  BX,ES:DeviceInfoOffset ;[BX] = Device Info Table
  MOV  CL,B ES:NumDevices[0]  ;CL = Number of Table Entries
  MOV  SI,DeviceInfoSize      ;SI = Size of each Table Entry
  MOV  BP,WriteDeviceRange    ;[BP] = Writing Subroutine to Call
  JMP >U00                    ;Do it
WriteUnusedDisks:
  PUSH BX,CX,DX               ;Save used registers
  PUSH DI,SI,BP               ;Save used registers
  MOV  DX,UnusedDisksMsg      ;[DX] = Header String
  MOV  DI,(OFFSET DskInt13DrvNum) ;[DI] = Offset of Disk Number
  MOV  BX,ES:DiskInfoOffset   ;[BX] = Disk Info Table
  MOV  CL,B ES:NumDisks[0]    ;CL = Number of Table Entries
  MOV  SI,DiskInfoSize        ;SI = Size of each Table Entry
  MOV  BP,WriteInt13Range     ;[BP] = Writing Subroutine to Call
  JMP >U00                    ;Do it
WriteUnusedDrives:
  PUSH BX,CX,DX,DI,SI,BP      ;Save used registers
  MOV  DX,UnusedDrivesMsg     ;[DX] = Header String
  MOV  DI,((OFFSET DrvDPB)+(OFFSET DPBDriveNum)) ;[DI] = Offset of Drive Code
  MOV  BX,ES:DriveInfoOffset  ;[BX] = Drive Info Table
  MOV  CL,B ES:NumDrives[0]   ;CL = Number of Table Entries
  MOV  SI,DriveInfoSize       ;SI = Size of each Table Entry
  MOV  BP,WriteDriveRange     ;[BP] = Writing Subroutine to Call
;  JMP >U00                    ;Do it
U00:
  PUSH AX                     ;Save used registers
  CALL WriteZPause            ;Write the Header
  XOR  CH,CH                  ;CH = Number of Ranges Written
  MOV  AL,-2                  ;AL = Low Number of Range
  MOV  AH,-2                  ;AH = High Number of Range
U10:                          ;Loop to here for each Table Entry
  CMP  BP,WriteDriveRange     ;Which kind of value are we writing?
  JNE >U20                    ;If not Drives, we don't care about the Valid Flag
U15:                          ;Test Valid Flag
  TEST ES:[BX].DrvFlags,DrvFlagValid ;Valid Entry?
  JZ  >U50                    ;If not, skip it
U20:                          ;Handled Valid Flag, if appropriate
  TEST ES:[BX].DskFlags,DskFlagInUse ;Empty/Reserved Entry?
  JNZ >U50                    ;If not, handle it
U25:                          ;Empty Entry
  MOV  DL,ES:[BX+DI]          ;DL = Disk Number/Drive Code
  CMP  DI,-1                  ;Do we need to write the Device Index?
  JNE >U27                    ;If not, continue
  CALL DvcIndex2OffsetDL      ;If so, calculate the Index (DL)
U27:                          ;DL = Value to Write
  CMP  AL,-2                  ;Do we need to start a new Range?
  JNE >U35                    ;If not, handle it
U30:                          ;Start a new Range
  MOV  AL,DL                  ;Store the Range Start value
  MOV  AH,DL                  ;  and End value
  JMP >U60                    ;one for now
U35:                          ;Not a new Range
  DEC  DL                     ;Is it an addition to
  CMP  DL,AH                  ;  the existing Range?
  JNE >U45                    ;If not, handle it
U40:                          ;Addition to Existing Range
  INC  AH                     ;Increment Ending Range value
  JMP >U60                    ;Done with this one
U45:                          ;Not addition to existing Range
  CALL BP                     ;Write the Range
  MOV  AL,DL                  ;Start a
  INC  AL                     ;  New
  MOV  AH,AL                  ;  Range
  JMP >U60                    ;Keep looking
U50:                          ;Not an empty entry
  CALL BP                     ;Write the Range Data
U60:                          ;Done with this entry
  ADD  BX,SI                  ;Point at next Table Entry
  DEC  CL                     ;Decrement the Loop Counter
  JNZ  U10                    ;If not done yet, keep looking
  CALL BP                     ;Write the Final Range, if there is one
  OR   CH,CH                  ;Did we write any ranges?
  JNZ >U90                    ;If so, we're done
  CALL WriteNone              ;If not, write None
U90:                          ;Done
  POP  AX                     ;Restore used registers
  POP  BP,SI,DI               ;Restore used registers
  POP  DX,CX,BX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A DEVICE INFO OFFSET TO AN INDEX
;Inputs:   ES  = TSR Data Area
;         [BX] = Device Info Entry
;Ouptuts:  DL  = Device Info Indes
;Changes:
;------------------------------------------------------------------------------
DvcIndex2OffsetDL:
  PUSH BX                     ;Save used registers
  XOR  DL,DL                  ;Start by assuming Index 0
O10:                          ;Loop to here to find the Index
  CMP  BX,ES:DeviceInfoOffset ;Is this the offset to the table beginning?
  JBE >O90                    ;If so, we're done
  SUB  BX,DeviceInfoSize      ;If not, point at the previous table entry
  INC  DL                     ;Increment the Index
  JMP  O10                    ;Keep testing
O90:                          ;Done
  POP  BX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A RANGE OF DEVICE INDEXES, INT 13h DISK NUMBERS, OR DOS DRIVE LETTERS
;Inputs:  CH = Ranges Written Counter
;         AL = Low End of Range
;         AH = High End of Range
;Outputs: To Screen:
;           If CH != 0, Writes Comma Space
;           If AL = AH or AH = -2, writes a single Number/Letter
;             else Writes AL-AH (dash in between)
;         Increments CH
;         Resets AL/AH = -2
;Changes:
;------------------------------------------------------------------------------
WriteDeviceRange:
  PUSH BX           ;Save used registers
  XOR  BL,BL        ;Mark as Device Indexes
  JMP >W00          ;Do it
WriteInt13Range:
  PUSH BX           ;Save used registers
  MOV  BL,1         ;Mark as INT 13h Disk Numbers
  JMP >W00          ;Do it
WriteDriveRange:
  PUSH BX           ;Save used registers
  MOV  BL,2         ;Mark as DOS Drive Letters
;  JMP >W00          ;Do it
W00:
  CMP  AL,-2        ;Valid Range?
  JE  >W90          ;If not, just quit
  OR   CH,CH        ;Is this the first Range?
  JZ  >W20          ;If so, don't write any commas
W10:                ;Write comma separator
  CALL WriteComma   ;Write a comma
  CALL WriteSpace   ;  and a space
W20:                ;Comma handled, if appropriate
  CMP  BL,1         ;What kind of value are we writing?
  JB  >W24          ;If Device Indexes, jumpt to handle it
  JE  >W26          ;If Disk Numbers, jump to handle it
W22:                ;Writing Drive Letters
  ADD  AL,'A'       ;Write the
  CALL WriteAL      ;  Drive Letter
  CALL WriteColon   ;Write a Colon
  SUB  AL,'A'       ;Restore Drive Code
  JMP >W30          ;Continue
W24:                ;Writing Device Indexes
  CALL WriteByteMin ;Write the Low End of the Range
  JMP >W30          ;Continue
W26:                ;Writing Disk Numbers
  CALL WriteByteHex ;Write the Low End
  CALL WriteHexEnd  ;  of the Range
W30:                ;Done writing Low End of Range
  CMP  AH,-2        ;Is there a Range?
  JE  >W50          ;If not, we're done
  CMP  AL,AH        ;Is there a Range?
  JE  >W50          ;If not, we're done
  CALL WriteDash    ;Write a Dash
  XCHG AL,AH        ;AL = High End of Range
  CMP  BL,1         ;What kind of value are we writing?
  JB  >W34          ;If Device Indexes, jumpt to handle it
  JE  >W36          ;If Disk Numbers, jump to handle it
W32:                ;Writing Drive Letters
  ADD  AL,'A'       ;Write the
  CALL WriteAL      ;  Drive Letter
  CALL WriteColon   ;Write a Colon
  SUB  AL,'A'       ;Restore Drive Code
  JMP >W50          ;Continue
W34:                ;Writing Device Indexes
  CALL WriteByteMin ;Write the Low End of the Range
  JMP >W50          ;Continue
W36:                ;Writing Disk Numbers
  CALL WriteByteHex ;Write the Low End
  CALL WriteHexEnd  ;  of the Range
W50:                ;Done writing second number, if appropriate
  INC  CH           ;Increment Ranges Written Counter
W90:                ;Done
  MOV  AL,-2        ;Reset
  MOV  AH,-2        ;  Range
  POP  BX           ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE DRIVES STATUS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE CURRENT DRIVES STATUS TO THE SCREEN
;Inputs:  ES = TSR Data Area
;         DrvStatus (Flag)
;Outputs: Writes a bunch of stuff to the screen if DrvStatus Flag is True
;Changes:
;------------------------------------------------------------------------------
DoDrvStatus:
  TEST StatusFlags,DrvStatus         ;Need to to anything?
  JNZ >V00                           ;If so, continue
  RET

V00:                                 ;Need to do Status
  PUSH EAX,BX,CX,DX,SI               ;Save used registers
  MOV  DX,DrvStatusMsg               ;Write
  CALL SetupPause                    ;  the Header
  MOV  SI,ES:DriveInfoOffset         ;[SI] = Drive Info Table
  MOV  CX,ES:NumDrives               ;CX = Number of Table Entries
V10:                                 ;Loop to here for each Drive
  TEST ES:[SI].DrvFlags,DrvFlagValid ;Valid Table Entry?
  JZ  >V50                           ;If not, skip it
  TEST ES:[SI].DrvFlags,DrvFlagInUse ;Valid Table Entry?
  JZ  >V50                           ;If not, skip it
  MOV  AL,ES:[SI].DrvDPB.DPBDriveNum ;Write
  ADD  AL,'A'                        ;  DOS
  CALL WriteAL                       ;  Drive Letter
  CALL WriteColon                    ;Write a Colon
  CALL WriteSpace                    ;Move over
  MOV  BX,ES:[SI].DrvDskOffset       ;Write the
  MOV  AL,ES:[BX].DskInt13DrvNum     ;  Int 13h
  CALL WriteByteHex                  ;  Drive
  CALL WriteHexEnd                   ;  Number
  CALL WriteSpace                    ;Move over
  MOV  EAX,ES:[SI].DrvPartSector     ;Get the Partition Sector
  CMP  EAX,-1                        ;Is it a (Super)Floppy?
  JNE >V30                           ;If not, handle a hard disk
  MOV  DX,SuperFloppyMsg             ;If so, write
  CALL WriteZPause                   ;  "(Super)Floppy"
  JMP >V40                           ;Continue
V101:                                ;To avoid JMP > 128
  JMP  V10                           ;Repeat Loop
V30:                                 ;Is a Hard Disk
  CALL WriteDWordHex                 ;Write the
  CALL WriteHexEnd                   ;  Partition Sector
  CALL WriteSpace                    ;Move over
  MOV  AL,ES:[SI].DrvPartIndex       ;Write the
  CALL ByteToString                  ;  Partition Index
  CALL WriteDrvPOS                   ;Write the Partition Operating System
V40:                                 ;Done with partition info
  MOV  EAX,ES:[SI].DrvBootSector     ;Write the
  CALL WriteDWordHex                 ;  Boot
  CALL WriteHexEnd                   ;  Sector
  MOV  AX,ES:[BX].DskBytesPerSect    ;Write the
  CALL WordToString                  ;  Number of Bytes Per Sector
  CALL WriteSpace                    ;Move over
  MOV  EAX,ES:[SI].DrvSectsInPart    ;Write the
  CALL WriteDWordHex                 ;  Number of
  CALL WriteHexEnd                   ;  Sectors
  CALL WriteSpace                    ;Move over
  CALL WriteCapacity                 ;Write Drive Capacity
  CALL WriteCrLfPause                ;Move down
V50:                                 ;Done with this Drive
  ADD  SI,DriveInfoSize              ;Point at next Drive Entry
  LOOP V101                          ;Keep going until we're done
V60:                                 ;Done with valid Devices
  CALL WriteCrLfPause                ;Move down
  CALL WriteUnusedDrives             ;Write Unused DOS Drive Letters
  CALL WriteCrLfPause2               ;Move down
  POP  SI,DX,CX,BX,EAX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE DRIVE PARTITION OPERATING SYSTEM TO THE SCREEN
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [SI] = Drive Info Entry
;Outputs: Writes POS to the Screen, with a Description
;Changes:
;------------------------------------------------------------------------------
WriteDrvPOS:
  PUSH AX,BX,CX,DX          ;Save used registers
  CALL WriteSpace           ;Move over
  MOV  AL,ES:[SI].DrvPartOS ;Write the
  CALL WriteByteHex         ;  POS
  CALL WriteHexEnd          ;  Number
  CALL WriteSpace           ;Move over
  MOV  BX,POSStringTbl      ;Look for the
  CALL SearchByte2StringTbl ;  POS Description
  JC  >P30                  ;If not in Table, handle Unknown
P10:                        ;[BX] = Description String
  MOV  DX,BX                ;[DX] = Description
  JMP >P40                  ;Done
P30:                        ;POS number not in description table
  MOV  DX,UnknownPOSMsg     ;Write
P40:                        ;[DX] = String to write
  CALL CalcStrSizeDX        ;Calculate
  SUB  CX,15                ;  how many Spaces
  NEG  CX                   ;  to write (CX)
  CALL WriteZPause          ;Write the Description
P90:                        ;Done
  CALL WriteSpaces          ;Move over
  POP  DX,CX,BX,AX          ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;ISSUE AND WRITE CONTENTS OF SCSI INQUIRY REQUEST
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;DOWNLOAD AND WRITE THE CONTENTS OF SCSI INQUIRY REQUESTS
;Inputs:  ES = TSR Data Area
;         ProgFlags2.Inquiry
;Outputs: Downloads and Writes Inquiry data for all SCSI-compatible Devices,
;           then quits program
;Changes:
;------------------------------------------------------------------------------
DoInquiry:
  TEST ProgFlags2,Inquiry ;Need to to anything?
  JNZ >Q00                ;If so, continue
  RET

Q00:                         ;Need to display Inquiry Data
  MOV  DX,InquiryHdr         ;Write the
  CALL SetupPause            ;  Header
  MOV  ES,DS                 ;ES:[BX] =
  MOV  BX,InqFmtStruc        ;  Request Structure
  MOV  [BX].I13SID,'SCSI'    ;ID String
  MOV  [BX].I13SFlags,I13SFlagIn                      ;Direction = In
  MOV  [BX].I13SDataSize,SInquiryRespSize             ;Data Size
  MOV  W [BX].I13SDataPtr[2],DS                       ;Data
  MOV  W [BX].I13SDataPtr[0],SectorBuff               ;  Buffer
  MOV  W [BX].I13SCmdBlock.SCSIReqCommand,SCmdInquiry ;SCSI Command Code
  MOV  [BX].I13SCmdBlock.SInquiryLen,SInquiryRespSize ;Data Size
  XOR  DX,DX                 ;DH = Valid Disk Counter
                             ;DL = Disk Number
Q10:                         ;Loop to here for each potential disk
  MOV  AH,I13CmdCheckReady   ;AH = Function = Check Ready
  STC                        ;Preset error flag
  INT  13h                   ;Do it
  JC  >Q50                   ;If error, skip this disk
  MOV  AX,((I13CmdIssueSCSIReq SHL 8)+1) ;Function = Issue SCSI Request
                             ;ES:[BX] = Request Structure
  STC                        ;Preset error flag
  INT  13h                   ;Issue the Request
  JC  >Q50                   ;If error, skip this disk
  CMP  [BX].I13SCmdStatus,0  ;Did the request work?
  JE  >Q40                   ;If so, continue
  CMP  [BX].I13SCmdStatus,-1 ;Did the request work?
  JNE >Q50                   ;If not, skip it
Q40:                         ;Got the Inquiry Data
  INC  DH                    ;If OK, increment Counter
  CALL WriteInquiryData      ;Write the Data
Q50:                         ;Done with this Disk
  INC  DL                    ;Increment disk number
  JNZ  Q10                   ;If we haven't done them all yet, keep testing
Q60:                         ;Done all of the disks
  OR   DH,DH                 ;Were there any valid disks?
  JNZ >Q90                   ;If so, we're done
  MOV  DX,InquiryNoneMsg     ;If not, write
  CALL WriteZPause           ;  "None Found"
Q90:                         ;Done
  MOV  DX,NoMsg              ;Don't write anything
  XOR  AL,AL                 ;ErrorLevel = 0
  JMP  Exit                  ;Quit

;------------------------------------------------------------------------------
;WRITE THE DATA FROM AN INQUIRY RESPONSE
;Inputs:  DS = ES = Local Data Area
;         DL = Int 13h Disk Number
;         DH = Number of Disks Found Counter
;         SectorBuff contains Inquiry Response Data
;         CLD already issued
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteInquiryData:
  PUSH AX,BX,CX,DX,SI           ;Save used registers
  CMP  DH,1                     ;Is this the first one?
  JE  >D10                      ;If so, no need for a new line
  CALL WriteCrLfPause           ;If not, move down
D10:                            ;New line handled, if necessary
  MOV  AL,DL                    ;Write the
  CALL WriteByteHex             ;  Int 13h
  CALL WriteHexEnd              ;  Disk Number
  CALL WriteSpace               ;Move over
  MOV  SI,SectorBuff+(OFFSET SInqRespVendorID) ;[SI] = Vendor ID String
  MOV  CX,8                     ;Write the
  CALL WriteInquiryString       ;  Vendor ID String
  CALL WriteSpace               ;Move over
  ADD  SI,CX                    ;[SI] = Product ID String
  MOV  CX,16                    ;Write the
  CALL WriteInquiryString       ;  Product ID String
  CALL WriteSpace               ;Move over
  ADD  SI,CX                    ;[SI] = Version String
  MOV  CX,4                     ;Write the
  CALL WriteInquiryString       ;  Version String
  CALL WriteSpace               ;Move over
  MOV  SI,SectorBuff            ;[SI] = Inquiry Response Data
  MOV  AL,[SI].SInqRespVersions ;AL =
  AND  AL,ANSIVerMask           ;  ANSI Version
  MOV  BX,ANSIVersionTbl        ;Search for the
  CALL SearchByte2StringTbl     ;  Description String
  JNC >D20                      ;If found, continue
  MOV  BX,UnknownMsg            ;If not, write "Unknown"
D20:                            ;[BX] = String to write
  MOV  DX,BX                    ;Write the
  CALL WriteZPause              ;  Description
  CALL WriteSpace               ;Move over
  MOV  AL,[SI].SInqRespDataFmt  ;AL =
  AND  AL,RDFMask               ;  Response Data Format
  MOV  BX,DataFormatTbl         ;Search for the
  CALL SearchByte2StringTbl     ;  Description String
  JNC >D30                      ;If found, continue
  MOV  BX,LegacyMsg             ;If not, write "Legacy"
D30:                            ;[BX] = String to write
  MOV  DX,BX                    ;Write the
  CALL WriteZPause              ;  Description
  POP  SI,DX,CX,BX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A STRING FROM AN INQUIRY RESPONSE (VENDOR, PRODUCT, OR VERSION)
;Inputs:   DS = ES = Local Data Area
;         [SI] = String to Write
;          CX  = Length of String
;         CLD already issued
;Outputs: To Screen
;Changes:
;NOTES: This converts all control characters (like ASCII NULs) to spaces
;         before writing.
;------------------------------------------------------------------------------
WriteInquiryString:
  PUSH AX,CX,SI ;Save used registers
  MOV  AH,' '   ;Compare to and write spaces
S10:            ;Loop to here for each character
  LODSB         ;Get the next character
  CMP  AL,AH    ;Is it a Control Character?
  JAE >S20      ;If so, just write it
S15:            ;Invalid character
  MOV  AL,AH    ;Write a space
S20:            ;AL = character to write
  CALL WriteAL  ;Write the character
  LOOP S10      ;Keep going until we're done
  POP  SI,CX,AX ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;LOW-LEVEL FORMAT A DRIVE
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;LOW-LEVEL FORMAT A DRIVE
;Inputs:  ES = TSR Data Area
;         DiskToFormat (0 = None)
;Outputs: Low=level formats a SCSI-compatible Disk, then quits program
;Changes:
;------------------------------------------------------------------------------
DoFormat:
  CMP  DiskToFormat,0 ;Need to do anything?
  JNE >F00            ;If so, continue
  RET

F00:                          ;Need to display Inquiry Data
  MOV  ES,DS                  ;ES = Local Data Area
  MOV  DL,DiskToFormat        ;DL = INT 13h Disk Number
  MOV  AH,I13CmdCheckReady    ;AH = Function = Check Ready
  STC                         ;Preset error flag
  INT  13h                    ;Do it
  JC  >F70                    ;If error, handle it
F10:                          ;Disk is Valid & Ready -- Verify User's Intent
  MOV  DX,FormatMsg0          ;Write
  CALL WriteZPause            ;  the Header
  MOV  AL,DiskToFormat        ;Write
  CALL WriteByteHex           ;  the
  CALL WriteHexEnd            ;  Disk Number
  MOV  DX,FormatMsg00         ;Write the rest
  CALL WriteZPause            ;  of the Header
  CALL FlushKbdBuff           ;Clear the keyboard buffer
F20:                          ;Loop to here to wait for a keystroke
  CALL GetKey                 ;Is there a key in the keystroke buffer?
  JZ   F20                    ;If not, keep waiting until there is
  CALL Capitalize             ;Capitalize the character
  CMP  AL,'Y'                 ;Is it Yes?
  JE  >F30                    ;If so, continue
F25:                          ;User does not want to continue
  MOV  AL,'N'                 ;Write
  CALL WriteAL                ;  "N"
  JMP >F90                    ;Done
F30:                          ;Need to Issue Request
  CALL WriteAL                ;Write the "Y"
  CALL WriteCrLfPause2        ;Move down
  MOV  DX,FormatMsg1          ;Tell
  CALL WriteZPause            ;  the
  MOV  AL,DiskToFormat        ;  user
  CALL WriteByteHex           ;  we're
  CALL WriteHexEnd            ;  formatting
  MOV  DX,FormatMsg2          ;  the
  CALL WriteZPause            ;  disk
  MOV  DL,DiskToFormat        ;DL = INT 13h Disk Number
  MOV  BX,InqFmtStruc         ;ES:[BX] = Request Structure
  MOV  [BX].I13SID,'SCSI'     ;ID String
  MOV  W [BX].I13SCmdBlock.SCSIReqCommand,SCmdFormatUnit ;SCSI Command Code
  MOV  AX,((I13CmdIssueSCSIReq SHL 8)+1) ;Function = Issue SCSI Request
                              ;ES:[BX] = Request Structure
  STC                         ;Preset error flag
  INT  13h                    ;Issue the Request
  JC  >F70                    ;If error, quit
  CMP  W [BX].I13SSenseASC,0  ;Did the request work?
  JE  >F60                    ;If so, we're done
  CMP  W [BX].I13SSenseASC,-1 ;Did the request work?
  JNE >F70                    ;If not, error
F60:                          ;Done formatting
  MOV  DX,FormatDoneMsg       ;[DX] = Message to write
  JMP >F92                    ;Quit
F70:                          ;Error

;call WriteFmtErr

  MOV  AL,ErLvlFormat         ;ErrorLevel = Can't Format
  MOV  DX,FormatErrMsg        ;[DX] = Message to Write
  JMP >F95                    ;Quit program
F90:                          ;Done
  MOV  DX,NoMsg               ;Don't write anything
F92:                          ;No error
  XOR  AL,AL                  ;ErrorLevel = 0
F95:                          ;Quit Program
  JMP  Exit                   ;Quit


;WriteFmtErr:
;  PUSH EAX
;  MOV  AL,[BX].I13SSetupErr
;  CALL WriteByteHex
;  CALL Write2Spaces
;  MOV  AL,[BX].I13SDataErr
;  CALL WriteByteHex
;  CALL Write2Spaces
;  MOV  AL,[BX].I13SStatusErr
;  CALL WriteByteHex
;  CALL Write2Spaces
;  MOV  AL,[BX].I13SCmdStatus
;  CALL WriteByteHex
;  CALL Write2Spaces
;  MOV  EAX,[BX].I13SDataResidue
;  CALL WriteDWordHex
;  CALL WriteCrLfPause
;  MOV  AL,[BX].I13SSenseErrCode
;  CALL WriteByteHex
;  CALL Write2Spaces
;  MOV  AL,[BX].I13SSenseKey
;  CALL WriteByteHex
;  CALL Write2Spaces
;  MOV  AX,W [BX].I13SSenseASC
;  XCHG AL,AH
;  CALL WriteWordHex
;  CALL Write2Spaces
;  MOV  EAX,[BX].I13SSenseInfo
;  CALL WriteDWordHex
;  CALL WriteCrLfPause
;  POP  EAX
;  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE CONTENTS OF SEGMENT BUFFER
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF THE VARIOUS TSR BUFFERS TO THE SCREEN
;Inputs:  ES = TSR Data Area
;         WriteBuff (Flag)
;Outputs: Writes a bunch of stuff to the screen if WriteBuff Flag is True
;Changes:
;------------------------------------------------------------------------------
DoWriteBuffers:
  TEST ProgFlags2,WriteBuff    ;Need to to anything?
  JNZ >F00                     ;If so, continue
  RET

DoWriteBuffersGo:
F00:
  PUSH EAX,BX,CX,DX,DI         ;Save used registers
F10:                           ;Inquiry Buffer
  MOV  BX,InquiryBuff          ;[BX] = Buffer
  MOV  CX,SInquiryRespSize     ;CX = Buffer Size
  MOV  DX,InquiryMsg           ;[DX] = Header
  CALL WriteBuffer             ;Write the contents
  CALL WriteCrLfPause          ;Move down
F20:                           ;Format Capacity Buffer
  MOV  BX,FmtCapacityBuff      ;[BX] = Buffer
  MOV  CX,FmtCapacityRespSize  ;CX = Buffer Size
  MOV  DX,FmtCapacityMsg       ;[DX] = Header
  CALL WriteBuffer             ;Write the contents
  CALL WriteCrLfPause          ;Move down
F30:                           ;Capacity Buffer
  MOV  BX,CapacityBuff         ;[BX] = Buffer
  MOV  CX,FormatDescrSize      ;CX = Buffer Size
  MOV  DX,CapacityMsg          ;[DX] = Header
  CALL WriteBuffer             ;Write the contents
  CALL WriteCrLfPause          ;Move down
F40:                           ;Format Capacity Buffer
  MOV  BX,ModeSenseBuff        ;[BX] = Buffer
  MOV  CX,MSenseRespSize       ;CX = Buffer Size
  MOV  DX,ModeSenseMsg         ;[DX] = Header
  CALL WriteBuffer             ;Write the contents
  CALL WriteCrLfPause          ;Move down
F50:                           ;Format Capacity Buffer
  MOV  DI,(SectorMsg+8)        ;Store the
  MOV  AX,W ES:LBAInBuffer[2]  ;  Sector Number
  CALL Word2HexString          ;  in
  MOV  AX,W ES:LBAInBuffer[0]  ;  the
  CALL Word2HexString          ;  Header
  MOV  BX,SectorBuff           ;[BX] = Buffer
  MOV  CX,ES:[MaxBytesPerSect] ;CX = Buffer Size
  MOV  DX,SectorMsg            ;[DX] = Header
  CALL WriteBuffer             ;Write the contents
  CALL WriteCrLfPause          ;Move down
  POP  DI,DX,CX,BX,EAX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF A SINGLE BUFFER TO THE SCREEN
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [BX] = Buffer (in TSR)
;          CX  = Buffer Size (Bytes)
;         [DX] = Header string to write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteBuffer:
  PUSH AX,BX,CX,DX    ;Save used registers
  CALL WriteBuffHdr   ;Write the Header
  PUSH DI,SI          ;Save used registers
  XOR  DI,DI          ;DI = Offset Counter
  MOV  SI,BX          ;Store starting pointer
B10:                  ;Loop to here for each line
  MOV  AX,DI          ;Write the
  CALL WriteWordHex   ;  Offset
  CALL Write2Spaces   ;Move over
  XOR  AH,AH          ;AH = Characters written on this line
B12:                  ;Loop to here for each character
  INC  AH             ;Increment characters written
  MOV  AL,ES:[BX]     ;Get the next byte
  INC  BX             ;Increment the pointer
  DEC  CX             ;Decrement the counter
  CALL WriteByteHex   ;Write the byte value
  MOV  AL,' '         ;Assume we need to write a space
  CMP  AH,8           ;Need to write a space or a dash?
  JNE >B15            ;If a space, continue
  OR   CX,CX          ;Is this the last byte?
  JZ  >B15            ;If so, write a space
  MOV  AL,'-'         ;If a dash, store a dash
B15:                  ;Write space or dash
  CALL WriteAL        ;Write the character
  JCXZ >B20           ;If no more characters, jump to write ASCII
  CMP  AH,16          ;End of the line?
  JB   B12            ;If not, keep writing
B20:                  ;Done writing byte values
  PUSH CX             ;Calculate
  MOV  CL,50          ;  how many
  SUB  CL,AH          ;  spaces
  SUB  CL,AH          ;  to write
  SUB  CL,AH          ;Write them
  CALL WriteSpaces    ;Move over
  POP  CX             ;Restore used registers
B25:                  ;Loop to here for each character
  MOV  AL,ES:[SI]     ;Get the next character
  INC  SI             ;Increment the pointer
  CMP  AL,' '         ;Is it a control character?
  JB  >B30            ;If so, handle it
  CMP  AL,127         ;Is it a control character?
  JNE >B35            ;If not, it's writable
B30:                  ;It's a control character (write a space)
  MOV  AL,' '         ;Store a space
B35:                  ;AL = character to write
  CALL WriteAL        ;Write the character
  DEC  AH             ;Decrement the counter
  JNZ  B25            ;If not 0 yet, keep writing
  CALL WriteCrLfPause ;Move down
B50:                  ;Done with this line
  JCXZ >B90           ;If done, quit
  ADD  DI,16          ;Increment Offset value
  MOV  SI,BX          ;Store starting pointer
  JMP  B10            ;Keep writing
B90:                  ;Done
  CALL WriteCrLfPause ;Move down
  POP  SI,DI          ;Restore used registers
  POP  DX,CX,BX,AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE HEADER FOR A BUFFER OUTPUT SCREEN
;Inputs:  [DX] = Specific Header Type String to Write (SECTOR, CAPACITY, etc.)
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteBuffHdr:
  PUSH CX,Si         ;Save used registers
  CALL CalcStrSizeDX ;Calculate
  SHR  CX,1          ;  how many
  NEG  CL            ;  spaces
  ADD  CL,20         ;  to write
  CALL WriteSpaces   ;Write them
  MOV  SI,BufferHdr1 ;Write the first part
  CALL WriteZPauseSI ;  of the Header
  CALL WriteZPause   ;Write the Buffer Type
  MOV  SI,BufferHdr2 ;Writ the last part
  CALL WriteZPauseSI ;  of the Header
  POP  SI,CX         ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE CONTENTS OF AN ASC/Q HISTORY BUFFER
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF AN ASC/Q HISTORY TABLE
;Inputs:  ES = TSR Data Area
;         ASCQHistoryDsk
;Outputs: Writes a bunch of stuff to the screen if Flag is True,
;           then quits program
;Changes:
;------------------------------------------------------------------------------
DoWriteASCQHistory:
  CMP  ASCQHistoryDsk,-1 ;Need to to anything?
  JNZ >Q00               ;If so, continue
  RET

Q00:
  MOV  DX,ASCQHistoryHdr1        ;Write
  CALL WriteZPause               ;  the Header
  MOV  AL,ASCQHistoryDsk         ;Write
  CALL WriteByteHex              ;  the
  CALL WriteHexEnd               ;  Disk Number
  MOV  DX,ASCQHistoryHdr2        ;Finish
  CALL WriteZPause               ;  the Header
  MOV  SI,ES:DiskInfoOffset      ;[SI] = Disk Info Table
  MOV  CX,ES:NumDisks            ;CX = Number of Table Entries
  MOV  AL,ASCQHistoryDsk         ;AL = Disk Number (INt 13h) to Find
Q10:                             ;Loop to here to find the correct Disk Entry
  CMP  AL,ES:[SI].DskInt13DrvNum ;Correct Drive Entry?
  JE  >Q20                       ;If so, write it
  ADD  SI,DiskInfoSize           ;If not, point at the next possibility
  LOOP Q10                       ;Keep going until we're done
;  JMP >Q70                       ;If none found, we're done
Q20:                             ;[SI] = DIsk Entry to Write
  MOV  CX,ASCQBuffEntries        ;CX = Number of Table Entries
  ADD  SI,(OFFSET DskASCQTable)  ;If so, [BX] = Storage Table
Q30:                             ;Loop to here for each Table Entry
  MOV  AX,ES:[SI+1]              ;Get the ASCQ Code
  OR   AX,AX                     ;Valid Entry?
  JZ  >Q60                       ;If not, handle it
  CMP  AX,-1                     ;Valid Entry?
  JE  >Q60                       ;If not, handle it
Q35:                             ;SCSI Command Code
  CALL WriteCrLfPause            ;Move down
  MOV  DX,SCSIReqMsg             ;Write
  CALL WriteZPause               ;  the Header
  MOV  AL,ES:[SI]                ;AL = SCSI Command Code
  CALL WriteByteHex              ;Write
  CALL WriteHexEnd               ;  the Number
  MOV  DX,SpEqualsMsg            ;Write
  CALL WriteZPause               ;  an Equals
  MOV  BX,SCSICmdTable           ;Write the
  CALL WriteByte2String          ;  Description
  CALL WriteCrLfPause            ;Move down
Q40:                             ;Sense Key
  MOV  DX,SenseKeyMsg            ;Write
  CALL WriteZPause               ;  the Header
  MOV  AL,ES:[SI+1]              ;AL = Sense Key
  CALL WriteByteHex              ;Write
  CALL WriteHexEnd               ;  the Number
  MOV  DX,SpEqualsMsg            ;Write
  CALL WriteZPause               ;  an Equals
  MOV  BX,SenseKeyTbl            ;Write the
  CALL WriteByte2String          ;  Description
  CALL WriteCrLfPause            ;Move down
Q40:                             ;ASC/Q Code
  MOV  DX,ASCQMsg                ;Write
  CALL WriteZPause               ;  the Header
  MOV  AX,ES:[SI+2]              ;Get the ASCQ Code
  CALL WriteWordHex              ;Write
  CALL WriteHexEnd               ;  the Number
  MOV  DX,SpEqualsMsg            ;Write
  CALL WriteZPause               ;  an Equals
  MOV  BX,ASCQTable              ;Write the
  CALL WriteWord2String          ;  Description
  CALL WriteCrLfPause            ;Move down
  ADD  SI,4                      ;Point at next entry
  LOOP Q30                       ;Keep going until we're done
Q60:                             ;No more valid entries
  CMP  CX,ASCQBuffEntries        ;Did we write anything?
  JNE >Q90                       ;If so, we're done
  MOV  DX,NoASCQHistoryMsg       ;If not,
  CALL WriteZPause               ;  write "None"
Q90:                             ;Done
  MOV  DX,NoMsg                  ;Write nothing
  XOR  AL,AL                     ;ErrorLevel = 0
  JMP  Exit                      ;Quit


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE DEVICE/CONFIG DESCRIPTORS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE DESCRIPTORS OF THE LAST DEVICE TO THE SCREEN, IF NECESSARY
;Inputs:  ES:DescriptorData
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoDescriptors:
  TEST StatusFlags,Descriptors ;Does the user want to see the Descriptors?
  JZ  >D000                    ;If not, quit
  TEST ProgFlags,InMemory      ;Are we installed in memory yet?
  JNZ >D00                     ;If so, go ahead and do it
  MOV  DX,DescrErrMsg          ;If not, point at first part of Error Message
  JMP  FinishDataErr           ;Terminate program
D000:
  RET

D00:
  CALL TestLastDevice          ;Anything to do (quits if not)?
  MOV  DI,ES:LastDeviceFound   ;Get Info Table Pointer
  MOV  AX,ES                   ;Write the address
  MOV  CX,DvcDescrData         ;  of the Descriptor Data
  MOV  BX,DescriptorMsgAddr    ;  to the
  CALL WriteSegmentOffset      ;  Command Line Parameters
  MOV  BX,DescriptorMsgHost    ;Write
  MOV  AL,ES:[DI].DvcHostIndex ;  the
  CALL WriteByteToString       ;  Host Index
  INC  BX                      ;  and the
  MOV  AL,ES:[DI].DvcAddress   ;  Device Address
  CALL WriteByteToString       ;  to the string
  MOV  AX,CS                   ;Write our
  MOV  CX,WriteZPauseFar       ;  Call-Back Address
  MOV  BX,DescriptorCallBk     ;  to the
  CALL WriteSegmentOffset      ;  Command Tail String
  MOV  BX,DescriptorMsg        ;Copy our String
  CALL CopyToCmdTail           ;  to the Command Tail String
  CALL DoExec                  ;Write the Descriptors
  MOV  DX,NoMsg                ;Write nothing
  XOR  AL,AL                   ;ErrorLevel = 0
  JMP  Exit                    ;Quit


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE NEEDED TO WRITE USB DESCRIPTORS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST AND SEE IF WE CAN PRINT A DESCRIPTOR (LASTDEVICEFOUND & SUPPORTFILE)
;Inputs:  ES = TSR Data Area
;         LastDeviceFound
;Outputs: Quits program if error
;         Initializes PathToUse, Prints Header if OK
;Changes:
;------------------------------------------------------------------------------
TestLastDevice:
  PUSH AX,DX,DI,SI             ;Save used registers
  MOV  SI,ES:LastDeviceFound   ;Get the Device Pointer that this is for
  TEST ES:[SI].DvcFlags,DvcFlagInUse ;Device still there?
  JNZ >L10                     ;If so, continue
  MOV  DX,NoDescrDataMsg       ;Point at Error Message
  MOV  AL,ErLvlNoData          ;ErrorLevel = No Data
  JMP  Exit                    ;Quit
L10:                           ;Have some Data
  MOV  DI,SupportFile          ;FileName to Look For
  CALL FindSupportFile         ;Look for the File
  JNC >L20                     ;If OK, continue
  MOV  DX,NoSuptFileMsg1       ;If not, write the first part
  CALL WriteZErr               ;  of the Error Message
  MOV  DX,SupportFile          ;Write the
  CALL WriteZErr               ;  File Name
  MOV  DX,NoSuptFileMsg2       ;Point at the last part of the Error Message
  MOV  AL,ErLvlSuptFile        ;ErrorLevel = No Support File
  JMP  Exit                    ;Quit
L20:                           ;Everything is OK
  MOV  DX,HostIndexMsg         ;Write
  CALL WriteZPause             ;  the
  MOV  AL,ES:[SI].DvcHostIndex ;  Host
  CALL ByteToString            ;  Index
  CALL WriteCrLfPause          ;Write a new line
  MOV  DX,DvcAddressMsg        ;Write
  CALL WriteZPause             ;  the
  MOV  AL,ES:[SI].DvcAddress   ;  Device
  CALL ByteToString            ;  Address
  CALL WriteCrLfPause2         ;Write 2 new lines
L90:                           ;Done
  POP  SI,DI,DX,AX             ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO TEST AND SEE IF THE COMPUTER IS COMPATIBLE OR NOT.
;TESTS DOS VERSION, HARDWARE INSTALLED, ETC. AS APPROPRIATE TO MAKE SURE
;  WE DON'T DO SOMETHING THAT COULD CRASH THE COMPUTER.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST THE COMPUTER TO SEE IF IT'S COMPATIBLE (CPU, DOS VERSION, WHATEVER)
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         ProgFlags.InMemory
;Outputs: Quits the program if Computer is Incompatible
;         Returns if Computer is OK
;         Stores all kinds of values in memory variables
;Changes:
;------------------------------------------------------------------------------
TestCompatibility:
  PUSH AX,DX                   ;Save used registers
  TEST ProgFlags,InMemory      ;Are we already installed?
  JNZ >C90                     ;If so, no need to test again
  MOV  AL,ErLvlDOSVer          ;Assume incorrect
  MOV  DX,DOSVerMsg            ;  DOS Version
  CMP  ES:DOSVersion,MinDOSVer ;Is the DOS version too old?
  JB  >C70                     ;If so, error
  MOV  AL,ErLvlBadCPU          ;Assume incorrect
  MOV  DX,BadCPUMsg            ;  CPU
  CALL Test80386               ;Is the CPU OK?
  JC  >C70                     ;If not, error
  MOV  AL,ErLvlNoHost          ;Assume Host Driver
  MOV  DX,NoHostMsg            ;  is not installed
  CALL TestUSBHost             ;Is there a USB Host Driver installed?
  JNC >C90                     ;If not, we're OK
C70:                           ;The computer is incompatible for some reason
  JMP  Exit                    ;Quit!
C90:                           ;The computer is compatible!
  POP  DX,AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET AND STORE THE DOS VERSION
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         ProgFlags.InMemory already filled in
;Outputs: DOSVersion, TSRFlags.UseFAT32, TSRFlags.IsFreeDOS
;Changes:
;------------------------------------------------------------------------------
GetDOSVersion:
  PUSH AX,BX,CX           ;Save used registers
  TEST ProgFlags,InMemory ;Are we already installed as a  TSR?
  JNZ >V90                ;If so, we've already done this
  XOR  BX,BX              ;Initialize BX to 0
  MOV  AX,3000h           ;Service 30h (get DOS version number)
                          ;  DOS 5.0 requires AL = 00h, may change BX and CX
  INT  21h                ;Do it (Returns AL= Major, AH = Minor)
  CMP  BH,0FDh            ;Is it FreeDOS?
  JNE >V20                ;If not, continue
V10:                      ;It's FreeDOS
  OR   TSRFlags,IsFreeDOS ;Mark as FreeDOS
V20:                      ;FreeDOS handled, if appropriate
  XCHG AL,AH              ;Swap Major and Minor versions for testing
  MOV  DOSVersion,AX      ;Store the DOS Version in the TSR
  CMP  AX,070Ah           ;DOS version 7.1+?
  JB  >V90                ;If not, don't allow FAT32
  OR   TSRFlags,UseFAT32  ;If so, allow FAT32
V90:                      ;Done
  POP  CX,BX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THE CPU IS AN 80386+ (CAN HANDLE 32-BIT INSTRUCTIONS)
;Inputs:
;Outputs: CF = Clear if the CPU is an 80386+
;            = Set if CPU is not an 80386+
;Changes:
;------------------------------------------------------------------------------
Test80386:
  PUSH AX,BX     ;Save used registers
  PUSHF          ;Save flags
  CALL Test8086  ;Is it an 8086?
  JNC >E70       ;If so, it can't be an 80386
  MOV  BX,0F000h ;Flags mask for testing (these bits always clear on 80286)
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  OR   AX,BX     ;Try to set the
  PUSH AX        ;  four high bits
  POPF           ;  of the flags
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  TEST AX,BX     ;Are any of the four high bits set?
  JNZ >E80       ;If so, it's not an 80286 - it must be an 80386+
E70:             ;It's not an 80386
  POPF           ;Restore flags
  STC            ;Set the not 80386 flag
  JMP >E90       ;We're done
E80:             ;It is an 80386
  POPF           ;Restore flags
  CLC            ;Set the 80386 flag
E90:             ;We're done
  POP  BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THE CPU IS AN 8086/8088
;Inputs:
;Outputs: CF = Clear if the CPU is an 8086/8088
;            = Set if not at 8086/8088
;Changes:
;NOTE: Unlike the other CPU tests, this is not a "greater than or equal to".
;      The CPU must be EXACTLY an 8086/8088, or this returns with CF set.
;------------------------------------------------------------------------------
Test8086:
  PUSH AX,BX     ;Save used registers
  PUSHF          ;Save flags
  MOV  BX,0F000h ;Flags mask for testing (these bits always set on 8086/8088)
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  AND  AX,0FFFh  ;Try to clear the
  PUSH AX        ;  four high bits
  POPF           ;  of the flags
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  AND  AX,BX     ;Are the four high bits
  CMP  AX,BX     ;  of the flags set?
  JE  >E80       ;If so, it's an 8086/8088
  POPF           ;Restore flags
E70:             ;It is not an 8086/8088
  STC            ;Set the not 8086/8088 flag
  JMP >E90       ;We're done
E80:             ;It is an 8086/8088
  POPF           ;Restore flags
  CLC            ;Set the 8086/8088 flag
E90:             ;We're done
  POP  BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A COMPATIBLE USB HOST DRIVER IS INSTALLED
;Inputs:
;Outputs: CF = Set if error (No Host Driver Installed)
;            = Clear if OK
;Changes:
;------------------------------------------------------------------------------
TestUSBHost:
  PUSH AX,BX,CX ;Save used registers
  MOV  AX,5000h ;Function 5000h (Install Check)
  MOV  BX,'US'  ;Set
  MOV  CX,'B!'  ;  registers
  STC           ;Preset Error Flag
  INT  14h      ;Do it
  JC  >U70      ;If Error, USB Host can't be installed
  OR   AX,AX    ;Is AX Correct?
  JNZ >U70      ;If not, Error
  CMP  BX,'B!'  ;Is BX correct?
  JNE >U70      ;If not, Error
  CMP  CX,'US'  ;Is CX correct?
  JE  >U80      ;If so, it's installed
U70:            ;Not installed
  STC           ;Set Error Flag
  JMP >U90      ;Done
U80:            ;Installed
  CLC           ;Set OK flag
U90:            ;Done
  POP  CX,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEARCH FOR AND WRITE THE STRING FROM A LOOKUP TABLE
;Inputs:  DS:[BX] = Table to search
;         AL/AX   = Byte/Word to search for
;         CLD already issued
;Outputs: If entry is found in the table, writes the string
;         If entry not found, writes "Unknown"
;Changes:
;NOTES:
;------------------------------------------------------------------------------
WriteByte2String:
  PUSH CX                      ;Save used registers
  MOV  CX,SearchByte2StringTbl ;CX = Code to Call
  JMP >W00                     ;Do it
WriteWord2String:
  PUSH CX                      ;Save used registers
  MOV  CX,SearchWord2StringTbl ;CX = Code to Call
;  JMP >W00                     ;Do it
W00:
  PUSH BX,DX                   ;Save used registers
  CALL CX                      ;Do the search
  JNC >W30                     ;If found in table, handle it
  MOV  BX,UnknownMsg           ;If not, point at "Unknown" string
W30:                           ;[BX] = String to write
  MOV  DX,BX                   ;Write
  CALL WriteZPause             ;  the string
  POP  DX,BX                   ;Restore used registers
  POP  CX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEARCH A BYTE-TO-STRING OR WORD-TO-STRING LOOKUP TABLE FOR A MATCHING ENTRY
;Inputs:  DS:[BX] = Table to search
;         AL/AX   = Byte/Word to search for
;Outputs: CF = Clear if a byte match as found in table
;              BX = Pointer to the String
;            = Set if no match found in table
;              BX = unchanged
;Changes:
;NOTES: Last Entry in Table (end-of-table marker) = -1/-1
;------------------------------------------------------------------------------
SearchWord2StringTbl:
  PUSH CX,DX            ;Save used registers
  MOV  CX,AX            ;CX = Word to look for
  MOV  DL,1             ;DL = Word Flag
  JMP >S00              ;Do it
SearchByte2StringTbl:
  PUSH CX,DX            ;Save used registers
  XOR  AH,AH            ;CX = Word to look for,
  MOV  CX,AX            ;AH = 0
  XOR  DL,DL            ;DL = Byte Flag
;  JMP >S00              ;Do it
S00:
  PUSH AX,SI            ;Save used registers
  MOV  SI,BX            ;Put pointer in SI
S10:                    ;Loop to here for each table entry
  OR   DL,DL            ;Doing a byte or a word?
  JNZ >S30              ;If a word, jump to handle it
S20:                    ;Doing bytes
  LODSB                 ;Get the next table entry
  CMP  AL,-1            ;Is it possibly the end of the table?
  JNE >S50              ;If not, continue
  JMP >S40              ;If so, see if it really is the end-of-table
S30:                    ;Doing words
  LODSW                 ;Get the next table entry
  CMP  AX,-1            ;Is it possibly the end of the table?
  JNE >S50              ;If not, continue
S40:                    ;[SI] = Possible end-of-table marker
  CMP  B [SI],-1        ;Is it actually the end of the table?
  JE  >S70              ;If so, error (not found)
S50:                    ;Not end of table
  CMP  AX,CX            ;Is it a match?
  JE  >S80              ;If so, handle it!
  CALL SkipOverStringSI ;If not, skip over the string
  JMP  S10              ;And keep looking
S70:                    ;No entry found
  STC                   ;Set the not found flag
  JMP >S90              ;Quit
S80:                    ;Entry found [SI]
  MOV  BX,SI            ;Point BX at the String
  CLC                   ;Set the found flag
S90:                    ;Done
  POP  SI,AX            ;Restore used registers
  POP  DX,CX            ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO SET UP COMMAND TAIL WITH PROPER PARAMETERS FOR EXEC CALL
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE A SEGMENT:OFFSET COMBINATION TO A STRING VARIABLE
;Inputs:   AX  = Segment to Write
;          CX  = Offset to Write
;         [BX] = String to Write to
;Outputs: Converts AX:CX to a Hex String and stores at [BX]
;Changes:
;------------------------------------------------------------------------------
WriteSegmentOffset:
  PUSH AX,DI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at Local Data Area
  MOV  DI,BX          ;Point DI at String
  CALL Word2HexString ;Store the Segment
  MOV  AL,':'         ;Store the
  STOSB               ;  Colon
  MOV  AX,CX          ;Store
  CALL Word2HexString ;  the Offset
  POP  ES,DI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A WORD AS HEX TO A STRING
;Inputs:   AX  = Word to Write
;         [BX] = String to write to
;Outputs:
;Changes: BX
;------------------------------------------------------------------------------
WriteWordToString:
  PUSH AX,DI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at Local Data Area
  MOV  DI,BX          ;Point DI at String
  CALL Word2HexString ;Store the Word
  MOV  AL,'h'         ;Write the
  STOSB               ;  'h'
  ADD  BX,5           ;Update Pointer
  POP  ES,DI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE AS HEX TO A STRING
;Inputs:   AL  = Byte to Write
;         [BX] = String to write to
;Outputs:
;Changes: BX
;------------------------------------------------------------------------------
WriteByteToString:
  PUSH AX,DI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at Local Data Area
  MOV  DI,BX          ;Point DI at String
  CALL Byte2HexString ;Store the Byte
  MOV  AL,'h'         ;Write the
  STOSB               ;  'h'
  ADD  BX,3           ;Update Pointer
  POP  ES,DI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY A STRING INTO THE COMMAND TAIL
;Inputs:  [BX] = ASCIIZ String to Copy
;Outputs: To CmdTail
;Changes:
;------------------------------------------------------------------------------
CopyToCmdTail:
  PUSH AX,CX,DX,DI,SI,ES ;Save used registers
  MOV  ES,DS             ;Point ES at Local Data Area
  MOV  CX,(CmdTailMax/2) ;Number of Words to Copy
  MOV  AX,CR+(CR SHL 8)  ;Fill with CR's
  MOV  DI,CmdTail        ;Point at Command Tail
  PUSH DI                ;Save Pointer
  REP  STOSW             ;Fill the Command Tail
  POP  DI                ;Restore Pointer
  MOV  DX,BX             ;Calculate number of bytes
  CALL CalcStrSizeDX     ;  to copy
  MOV  CmdTailSize,CL    ;Store the Command Tail Size
  MOV  SI,BX             ;Copy the string
  REP  MOVSB             ;  to the Command Tail
  POP  ES,SI,DI,DX,CX,AX ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO EXEC ANOTHER PROGRAM
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SETUP PARAMETERS TO BE ABLE TO PERFORM THE EXEC FUNCTION
;Inputs:
;Outputs:
;Changes: Lots of stuff
;------------------------------------------------------------------------------
SetupExec:
  PUSH AX,SI                       ;Save used registers
  MOV  SI,ParamBlock               ;Point at Parameter Block
  MOV  AX,CS                       ;Use our data segment
  MOV  [SI].PBEnvirSegment,0       ;Use Copy of our Environment
  MOV  W [SI].PBCmdTailPtr[0],OFFSET CmdTailSize
  MOV  W [SI].PBCmdTailPtr[2],AX   ;Command Tail Pointer
  MOV  W [SI].PBFCB1Offset[0],FCB1
  MOV  W [SI].PBFCB1Offset[2],AX   ;FCB #1 Pointer
  MOV  W [SI].PBFCB2Offset[0],FCB2
  MOV  W [SI].PBFCB2Offset[2],AX   ;FCB #2 Pointer
  POP  SI,AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PERFORM THE EXEC FUNCTION
;Inputs:  ParamBlock set up with appropriate data
;         CmdTail/CmdTailSize set up with appropriate Info
;         PathToUse contains Child Program to Call
;         DS = Our data Area
;Outputs: CF = Clear if Program Returned ErrorLevel 0
;Changes: Performs EXEC Function
;------------------------------------------------------------------------------
DoExec:
  PUSH ES            ;Save used register
  MOV  ES,DS         ;Point ES at our Data Area
  PUSH AX,BX,CX,DX   ;Save all registers
  PUSH DI,SI,BP      ;Save all registers
  MOV  OldSPExec,SP  ;Save the Stack Pointer (may be destroyed by Call)
  MOV  DX,PathToUse  ;DS:[DX] = Child Program to Run
  MOV  BX,ParamBlock ;ES:BX = Parameter Block
  MOV  AX,4B00h      ;Function 4B00h (Load and Execute child program)
  INT  21h           ;Do it (May Destroy BX & DX)
  JC  >X70           ;If Error, quit
X00:                 ;When the Child Program Exits, here we are!
  CLD                ;Go forward with string functions
  CLI                ;Disable interrupts
  MOV  DS,CS         ;Restore
  MOV  ES,DS         ;  all
  MOV  SS,CS         ;  Segments
  MOV  SP,OldSPExec  ;Restore Stack Pointer
  STI                ;Enable interrupts
  MOV  AH,4Dh        ;Function 4Dh (Get ErrorLevel)
  INT  21h           ;Do it (Returns AH = Term Type, AL = ErrorLevel)
  OR   AL,AL         ;ErrorLevel 0?
  JZ  >X80           ;If so, it was OK
X70:                 ;Error
  STC                ;Set Error Flag
  JMP >X90           ;Done
X80:                 ;OK
  CLC                ;Set OK Flag
X90:                 ;Done
  POP  BP,SI,DI      ;Restore all registers
  POP  DX,CX,BX,AX   ;Restore all registers
  POP  ES            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;LOOK FOR THE SUPPORT FILE SOMEWHERE IN THE PATH
;Inputs:  DS = Local Data Area
;         SupportFile
;         ProgFlags.FoundSuptFile = False
;Outputs: ZF = Clear if Support File Found
;              ProgFlags.FoundSuptFile = True
;Outputs: ZF = Set if Support File Not Found
;              ProgFlags.FoundSuptFile = False
;Changes:
;------------------------------------------------------------------------------
TestSupportFile:
  PUSH DI,SI                ;Save used registers
  MOV  SI,OFFSET ProgFlags  ;Point [SI] at ProgFlags
  MOV  DI,SupportFile       ;Look for the
  CALL FindSupportFile      ;  Support File
  JC  >S90                  ;If not found, quit
  OR   B [SI],FoundSuptFile ;If found, mark it as found
S90:                        ;Done
  TEST B [SI],FoundSuptFile ;Set return flag
  POP  SI,DI                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE LOCATION OF THE SUPPORT FILE
;Inputs:  [DI] = FIleName to Look for
;Outputs: CF = Clear if OK (File Found)
;              PathToUse = Path & FileName Concatenated Together
;            = Set if Error (File not Found)
;              PathToUse = Undefined
;Changes: Various Path pointer Registers (OurPathPointer, PathVarPointer, etc.)
;------------------------------------------------------------------------------
FindSupportFile:
  PUSH AX,SI,DS,ES       ;Save used registers
F10:                     ;Do Our Path
  MOV  SI,OurPathPointer ;Point SI at our Path pointer
  CMP  SI,-1             ;Valid?
  JE  >F20               ;If not, skip it
  MOV  AX,[PSPEnvirSeg]  ;Point ES at
  MOV  ES,AX             ;  Environment Segment
  CALL CopyPathName      ;Copy it
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F20:                     ;Do Current Path
  MOV  ES,CS             ;Point ES at us
  MOV  SI,CurrentPath    ;If not, try the Current Path
  CALL CopyPathName      ;Copy it
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F30:                     ;Do Environment PATH
  MOV  SI,PathVarPointer ;SI = Environment PATH Pointer
  CMP  SI,-1             ;Is it valid?
  JE  >F70               ;If not, we're done
  MOV  AX,[PSPEnvirSeg]  ;Point ES at Path
  MOV  ES,AX             ;  (Environment) Segment
F35:                     ;Loop to here for each element in PATH
  CALL CopyPathName      ;Copy the PATH element
  JC  >F70               ;If End of Path, we're done
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F40:                     ;Loop to here to skip over PATH Element
  MOV  AL,ES:[SI]        ;Get next character
  INC  SI                ;Increment Pointer
  OR   AL,AL             ;End of PATH?
  JZ  >F70               ;If so, we're done
  CMP  AL,';'            ;End of PATH Element?
  JNE  F40               ;If not, Keep looking
  JMP  F35               ;Try the next Element
F70:                     ;Error
  STC                    ;Set Error Flag
  JMP >F90               ;Done
F80:                     ;Found our File
  CLC                    ;Set OK flag
F90:                     ;Done
  POP  ES,DS,SI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEE IF THE SUPPORT FILE EXISTS
;Inputs:  PathToUse
;Outputs: CF = Clear if OK (File Found)
;            = Set if Error (File not Found)
;Changes:
;------------------------------------------------------------------------------
FindFile:
  PUSH AX,BX,CX,DX   ;Save used registers
  PUSH DS,ES         ;Save used registers
  MOV  AH,2Fh        ;Function 2Fh (Get DTA Address)
  INT  21h           ;Do it (returns ES:BX)
  MOV  AH,1Ah        ;Function 1Ah (Set DTA Address)
  MOV  DX,FCB1       ;DS:DX = New DTA Address
  INT  21h           ;Do it
  MOV  AX,4E00h      ;Function 4Eh (Find First Matching File)
  MOV  CX,FAttrToUse ;Search for any file, including Hidden
  MOV  DX,PathToUse  ;DS:DX = ASCIIZ FileName to search for
  INT  21h           ;Do it (returns CF)
  PUSHF              ;Save return flag
  MOV  DS,ES         ;Point DS:DX
  MOV  DX,BX         ;  at the old DTA
  MOV  AH,1Ah        ;Function 1Ah (Set DTA Address)
  INT  21h           ;Do it
  POPF               ;Restore return flag
  POP  ES,DS         ;Restore used registers
  POP  DX,CX,BX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CREATE A COMPLETE PATH NAME GIVEN A PATH AND A FILE NAME
;Inputs:  ES:[SI] = Path name to Copy
;         DS:[DI] = FileName to Append to the Path
;Outputs: PathToUse = Path & File Concatenated Together
;NOTES: The Path String can either end with a 0 (ASCIIZ String) or a SemiColon
;         (the way strings are stored in the PATH Environment variable).
;       This code will properly handle an empty Path String, which will
;         simply set PathToUse to the FileName.
;       The FileName must be an ASCIIZ String.
;------------------------------------------------------------------------------
CopyPathName:
  PUSH AX,BX,CX,DI,SI,DS,ES  ;Save used registers
  PUSH DS                    ;Point ES
  PUSH ES                    ;  at our data,
  POP  DS                    ;  DS at
  POP  ES                    ;  Path Data
  MOV  BX,DI                 ;Save File Name Pointer
  XOR  AX,AX                 ;Fill with Zeroes
  MOV  CX,(MaxPathSize/2)    ;Number of Words to Write
  MOV  DI,PathToUse          ;Where to write them
  PUSH DI                    ;Save Pointer
  REP  STOSW                 ;Reset the Buffer
  POP  DI                    ;Restore Pointer
  XOR  CL,CL                 ;Start String Length Counter at 0
N10:                         ;Loop to here for each character in Path
  LODSB                      ;Get next character
  OR   AL,AL                 ;End of Path?
  JZ  >N20                   ;If so, do Filename
  CMP  AL,';'                ;End of Path (Environment PATH)?
  JE  >N20                   ;If so, do FileName
  INC  CL                    ;Increment String Length Counter
  STOSB                      ;If not, store the character
  JMP  N10                   ;Keep going
N20:                         ;Done with Path
  OR   CL,CL                 ;Any characters at all in the Path?
  JZ  >N30                   ;If so, is Current Path, and don't want backslash!
  CMP  B ES:[DI-1],Backslash ;Path ends in a Backslash?
  JE  >N30                   ;If so, it's OK
  MOV  AL,Backslash          ;If not, store
  STOSB                      ;  a Backslash
N30:                         ;Path is OK
  MOV  DS,ES                 ;Point DS:[SI]
  MOV  SI,BX                 ;  at the File Name
N40:                         ;Loop to here for each character in File name
  LODSB                      ;Get next character
  OR   AL,AL                 ;End of File Name?
  JZ  >N90                   ;If so, we're done
  STOSB                      ;If not, store it
  JMP  N40                   ;Keepgoing
N90:                         ;Done
  POP  ES,DS,SI,DI,CX,BX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE PATH THAT OUR PROGRAM IS IN
;Inputs:
;Outputs: OurPathPointer = Pointer to Our Path String (in Environment Segment)
;                        = -1 if we couldn't find our own Path
;Changes:
;------------------------------------------------------------------------------
GetOurPath:
  PUSH AX,CX,DI,SI,DS,ES    ;Save used registers
  MOV  AX,[PSPEnvirSeg]     ;Point DS & ES
  MOV  DS,AX                ;  at the
  MOV  ES,AX                ;  Environment segment
  XOR  DI,DI                ;Point at the beginning of Environment list
  MOV  CX,-1                ;Max out the count limiter
  XOR  AX,AX                ;Need to look for a double 0
U10:                        ;Loop to here to skip over Environment vars
  REPNE SCASB               ;Look for the end of this environment variable
  CMP  [DI],AL              ;Is it the end of the variable list (double 0)?
  JNE  U10                  ;If not, keep skipping over Environment vars
  CMP  [DI+1],AX            ;If so, is there a string after the Envir?
  JE  >U70                  ;If not, we're done
  ADD  DI,3                 ;Point DI and SI at the
  MOV  SI,DI                ;  True Name
  MOV  CS:OurPathPointer,DI ;Store the Pointer
U20:                        ;Loop to here to find the end of the PATH
  LODSB                     ;Get the next character of the name
  CMP  AL,':'               ;Is it a Colon?
  JE  >U30                  ;If so, possible end-of-path
  CMP  AL,Backslash         ;Is it backslash?
  JE  >U30                  ;If so, possible end-of-path
  OR   AL,AL                ;End of File Name?
  JZ  >U50                  ;If so, we're done
  JMP >U40                  ;If not, keep looking
U30:                        ;Update end-of-path Pointer
  MOV  DI,SI                ;Save possible end-of-path pointer
U40:                        ;Not end-of-path yet
  JMP  U20                  ;Keep looking
U50:                        ;At end of Path
  CMP  DI,CS:OurPathPointer ;Was there a real path?
  JE  >U70                  ;If not, error
  MOV  B [DI],0             ;If OK, put 0 at end of Path
  JMP >U90                  ;Done
U70:                        ;No Path
  MOV  CS:OurPathPointer,-1 ;Set Pointer
U90:                        ;Done
  POP  ES,DS,SI,DI,CX,AX    ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO AUTOMATICALLY MOVE THE PROGRAM INTO UPPER MEMORY
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TRY TO ALLOCATE A UMB, AND COPY THE PROGRAM TO THE UMB SEGMENT
;Inputs:  DS = ES = Current Data Segment
;Outputs: ES = New Data Segment (in UMB or Low Memory Hole)
;              If no UMB or Low Memory Hole is available, ES remains unchanged
;         Entire TSR Portion of Program is copied to new Segment
;Changes:
;------------------------------------------------------------------------------
MoveProgramToUMB:
  PUSH AX,BX,CX,DX,DI,SI      ;Save used registers
  MOV  AX,DS                  ;Save original Data Segment
  CMP  AX,0A000h              ;Already in Upper Memory?
  JAE >U90                    ;If so, just quit
  TEST ProgFlags,UseLowMemory ;Does user want us in Low Memory?
  JNZ >U90                    ;If so, just quit
  MOV  BX,LastTSRByteOffset   ;BX =
  SHR  BX,4                   ;  Number of Paragraphs to Allocate
  CALL AllocateUMBDOS         ;Try to get a UMB from DOS (Returns ES)
  JZ  >U90                    ;If it didn't work, quit
  MOV  DX,ES                  ;Save new Segment
  PUSH DS                     ;Save data Segment
  MOV  AX,DS                  ;Point DS
  DEC  AX                     ;  at current
  MOV  DS,AX                  ;  MCB
  MOV  AX,ES                  ;Point ES
  DEC  AX                     ;  at new
  MOV  ES,AX                  ;  MCB
  MOV  SI,OFFSET MCBOwnerName ;Copy
  MOV  DI,SI                  ;  the
  MOV  CX,4                   ;  Owner
  REP  MOVSW                  ;  Name
  POP  DS                     ;Restore Data Segment
  MOV  ES:[MCBOwnerID],DX     ;Make itself the Owner
  MOV  AH,26h                 ;Function 26h (Create new PSP, DX = Segment)
  INT  21h                    ;Do it
  MOV  ES,DX                  ;Point ES at new Segment again
  ADD  DX,BX                  ;Calculate where next Segment will be
  MOV  ES:[PSPNextSegment],DX ;Store it in the PSP
  MOV  CL,3                   ;Calculate
  SHL  BX,CL                  ;  number
  MOV  CX,BX                  ;  of words
  SUB  CX,(PSPStrucSize/2)    ;  to Copy
  MOV  SI,PSPStrucSize        ;SI = Old Data
  MOV  DI,SI                  ;DI = New Data
  REP  MOVSW                  ;Copy Program to new Segment
  OR   ProgFlags,MemoryMoved  ;Mark memory as having been moved
U90:                          ;Done
  POP  SI,DI,DX,CX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TRY TO ALLOCATE A UMB THROUGH DOS
;Inputs:  BX = Number of Paragraphs to Allocate
;Outputs: ZF = Clear if OK
;              ES = Segment of Allocated UMB
;            = Set if Error
;              ES = Unchanged
;Changes:
;NOTES: Allocating USB's through DOS normally requires a
;         DOS=HIGH,UMB line in CONFIG.SYS
;------------------------------------------------------------------------------
AllocateUMBDOS:
  PUSH AX,BX,CX,DX   ;Save used registers
  PUSH DI,SI         ;Save used registers
  MOV  CX,ES         ;Save original ES
  MOV  DI,BX         ;Save Number of Paragraphs to Allocate
  MOV  AX,5800h      ;Function 5800h (Get Memory Allocation Strategy)
  INT  21h           ;Do it (returns AX)
  JC  >D90           ;If error, quit
  MOV  SI,AX         ;If OK, save it
  MOV  AX,5802h      ;Function 5802h (Get UMB Link State - DOS 5+ Only)
  INT  21h           ;Do it (Returns AL)
  JC  >D90           ;If error, quit
  MOV  DL,AL         ;If OK, Save it
  MOV  BX,UMBLinkYes ;Enable USB's in DOS Memory Chain
  MOV  AX,5803h      ;Function 5803h (Set UMB Link State)
  INT  21h           ;Do it
  JC  >D90           ;If error, quit
  MOV  BX,StrategyHighLowBest ;Strategy = Try High, then Low, Best Fit
  MOV  AX,5801h      ;Do
  INT  21h           ;  it
  JC  >D80           ;If error, quit
D20:                 ;Strategy is set
  MOV  BX,DI         ;BX = # of Paragraphs to Allocate
  MOV  AH,48h        ;Function 48h (Allocate Memory)
  INT  21h           ;Do it (returns AX = Segment)
  JC  >D80           ;If error, quit
  MOV  ES,AX         ;If OK, put Segment in ES
  CMP  AX,0A000h     ;Is it really a UMB?
  JAE >D80           ;If so, continue
  MOV  DI,CS         ;If not, is it a memory "hole" lower in memory
  CMP  AX,DI         ;  than we are (from a previously removed TSR)?
  JB  >D80           ;If so, continue
  MOV  AH,49h        ;Function 49h (Free Memory, Segment in ES)
  INT  21h           ;Do it
  MOV  ES,CX         ;Restore original ES
D80:                 ;Restore original UMB Link State & Strategy
  XOR  BH,BH         ;Restore
  MOV  BL,DL         ;  original
  MOV  AX,5803h      ;  USB
  INT  21h           ;  Link State
  MOV  BX,SI         ;Restore original
  MOV  AX,5801h      ;  Memory Allocation
  INT  21h           ;  Strategy
D90:                 ;Done
  MOV  AX,ES         ;Set
  CMP  CX,AX         ;  Return Flag
  POP  SI,DI         ;Restore used registers
  POP  DX,CX,BX,AX   ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SPACE AND CODE TO PROCESS OUR PROGRAM STACK
;  This code and must be physically at the END of the Program,
;    but must be one of the FIRST procedures called by the Program.
;  In addition, the Stack Pointer (SP) must be set properly
;    (to LastProgByte - 2) BEFORE this code is called.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;RESIZE OUR MEMORY ALLOCATION TO THE MINIMUM SIZE NEEDED
;Inputs:  SP = LastProgByte - 2
;         ES = Local Segment
;Outputs: Rellocates Memory to the minimum size required to run the program
;Changes:
;------------------------------------------------------------------------------
ResizeMemory:
  PUSH AX,BX  ;Save used registers
  MOV  AH,4Ah ;Function 4Ah (Resize Memory Block pointed at by ES)
  MOV  BX,(LastProgByte SHR 4) ;BX = Number of Paragraphs to Resize to
  INT  21h    ;Do it
  POP  BX,AX  ;Restore used registers
  RET

  EVEN 16
  DB (ProgStackSize/8) DUP ('PrgStack')

LastProgByte:
