  JMP Main ;Skip over TSR Code to Main Program


;==============================================================================
;NOTE: This program is written for and compiled with Eric Isaacson's A386
;      assembly language compiler, using Options +P3 -F (80386 CPU and
;      no FPU).
;==============================================================================

;==============================================================================
;NOTE: This is actually the source code for two different programs,
;      USBUHCI.COM & USBUHCIL.COM.  If the LITE variable is set in the
;      A386 Assembler, this will create USBUHCIL (the "Lite" version
;      of USBUHCI).  If the LITE variable is not set, this will create
;      USBUHCI.
;==============================================================================

;Changes in version 0.15:



;Still to do:

;Test Physical Address Memory Continuity

;Create Debugging Program to monitor all Requests.  Just loads pointers,
;  which we call when appropriate (beginning & end of calls).  We call with
;  registers set at various values.  On entry: Pointer to Int14 Request,
;  Time Stamp.  On exit: Error Codes, Time Stamp.  Need a way to match up
;  exit values & entry values (CloseID/Handle).  May also need filters
;  (Host, Address, EndPoint) but can probably let Debug program do the
;  filtering.

;USB Forum -- Monitor ports for being disabled??

;Be clearer about Index 0 in the docs
;USBCORE, UHCICORE
;  Create a separate "core", don't directly attach first host to it.
;  This will allow removal of hosts in literally ANY order.
;  Install core on first host installation, remove on last removal.
;Option to install for all Hosts at Once.
;Change SIDs to leave "holes" for future growth/changes
;Move variable-sized tables to end of TSR (don't "reserve" room for them?

;Separate into separate segments, Segment that needs to have physical addresses
;  needs to be in lower memory (not UMB) when UMBPCI is installed

;Add EndPoint queries to the API?

;Via controllers won't work on first PIC (IRQ's 0-7)???

;Instead of fixed-size tables, create a "TSR Heap" from memory and allocate
;  things dynamically.  Increases overhead (need a "Heap Control Block"
;  of some sort), but increases flexibility (number of interfaces vs number
;  of endpoints, etc.)

;Instead of two separate programs (USBUHCI & USBUHCIL), just have one with
;  a /Devices:# or /Addresses:# option, and adjust TSR Heap size accordingly

;Handle PCMCIA (removable Host Controller) properly without locking up?
;  Need to warn user to unistall drivers before removing in any case.

;Add "Ownership confirmed" call to ownership registration?   Have a "Send
;  test to Owner" call?

;May need to fix CalcTDBits??
;LIke OHCI, keep track internally of full 16-bit Frame Number?
;  Makes several calculations easier & smaller

;Should we change our scheduling priorities in UHCI to something more similar
;  to OHCI (Bulk/Ctl for 10% of time, Int, Isoch, then Bulk/Ctl again)?
;  Which should really happen first, Int or Isoch?

;Finish testing Isoch.  It stores Frame Index rather than Frame Number, so we
;  need to play some games.  We either need to change it to store Frame
;  Number, or make Max Isoch Period 512 or 1000.

;In DOCS, talk about 7 port hub as cascaded 4 port hubs.

;Intel P55 Chipset doesn't have EHCI + UHCI, just EHCi with a built-in Hub

;Add support for EMS, possibly DPMS

;Direct PCI I/O access if no PCI BIOS, or BIOS doesn't seem to work right
;  for some reason.




;In DOCS:

;Assumes Host is permanent (e.g., not part of a PCMCIA card plugged into a
;  laptop).  Could possibly be modified to include that possibility, but
;  for now will need to uninstall this program before removing host hardware,
;  or computer will likely crash.

;SOME Host/BIOS combinations (Dell Studio 540, e.g.) do not process
;  IRQ's correctly, and as a result do not allow a Host Stop call to occur
;  as a background process (all background processes depend on correct IRQ
;  processing).  Without proper IRQ processing, it is impossible for a
;  background process to determine how long it it taking to do something,
;  and cannot generate its own Timeout ("This is taking too long -- something's
;  wrong") error.  Therefore, when performing a Host Stop, or any process
;  that requires stopping the Host (Suspend, Reset, Debug) there must be a
;  "timing and verification wrapper" placed around the Host Stop background
;  process call to deteermine when IRQ's are being processed incorrectly.
;  The USBUHCI{L} program  contains the appropriate "wrapper" if you request
;  that USBUHCI{L} Stop the Host (Directly or Indirectly) via appropriate
;  command-line switches (Stop 0, Stop 1, Uninstall, Debug, etc.).
;  However, if you are issuing an INT 14h Request from an external program
;  with I14RRTHostStop, I14RRTHostDebug,, etc., you MUST provide your own
;  timing & verification wrapper.

;Index 1 usually locks up on Laptop, unless Index 0 is already loaded.

;Need user to install in Low Memory if using UMBPCI until we make changes.
;  It's possible, though very unlikely, that a computer with UMBPCI will
;  work with PCI Bus mastering -- don't know for sure.  Can try it, and
;  if it doesn't work, use EMM386 instead.  You can usually get more
;  total memory with EMM386, since you can use the Monochrome Video
;  Buffer (B000h-B7FFh) for UMB's whihc generally isn't available in
;  UMBPCI.

;Programs have not been tested with a heavily loaded bus, requiring
;  lots of transactions and lots of time-sensitive IRQ processing.
;  It is possible that it could fail, or at least run very inefficiently
;  under a heavy load.

;No current (direct) support for APM/ACPI, but should be possible to add

;Numbers can be input as Decimal or Hex (Hex ends in H)

;Periodic TD's LOOK Un-Scheduled sometimes (when showing FL)??
;  Warn User!

;Sometimes even Assigning IRQ/IO won't cause it to work! (DeskTop never
;  works if we tell BIOS to not assign a USB IRQ)

;Can force EHCI controller to route everything to Companion Controller.
;  On Dell Desktop this fixed some issues??  Is slow to route through EHCI!

;Added Program Debugging Option.  Shows data during install & uninstall.
;  Also slows everything down.

;Command-Line Options simply issue appropriate requests to TSR, but do
;  not "follow through" to make sure what actually happened.  Need to warn
;  user about that.

;In setting Config option, does not verify Device actually changed.  Checks
;  current config value & if same does nothing, else issues appropriate
;  Request and returns.
;  Remote Wakeup & Test Mode are same.  Verify, if not same, issue Request
;  and return.  User needs to check afterwards with other Options.
;For all three, program must be installed in memory first!

;Option to Reset all Bad Devices on All Hosts

;Some Hosts/Legacy software mess around with INT 08, wreaking havoc with
;  timing and other issues (Dell desktop).  Sometimes, it looks like
;  your computer is locked up when it actually isn't.  You may need to
;  wait several dozen seconds for the old software to do what it needs
;  to do (my programs don't work that way).

;CardBus/PCMCIA Host Controllers can be a problem.  Never owned one, so
;  can't say for sure.  USBUHCI{L} is designed assuming that the
;  Host Controller is permanent and cannot/will not be removed while the
;  USBUHCI{L} software is installed.  If you want to unplg the Host
;  Controller, you need to make certain that you uninstall the software
;  first.  This may change in the future if there is ever a BIOS-level
;  PCMCIA/CardBus standard developed that allows for registration &
;  notification processes similar to what is provided in this API for
;  USB Devices.

;If DisableLegacySupport option is not set on Dell Desktop on install, the
;  keyboard keeps pressing "y".  Problem with Legacy Support??
;  If we don't disable EHCI controllers before we assume control of
;  keyboard UHCI controller, we keep getting <Enters> (the last key
;  we typed).  Disabling EHCI controller with USBHOSTS before installing
;  USBUHCI{L} fixes the problem.

;If taking over keyboard from Legacy Support BIOS, you MUST use a batch
;  file: {USBHOSTS Stop #}, USBUHCI{L}, {USBHUB}, USBKEYB.  You CANNOT do
;  it manually one line at a time, because your USB keyboard will stop
;  working in the middle of the process.  Not a problem if you have a
;  "real" PS2 keyboard as a backup, but many new computers do not even
;  have PS2 ports so that is not always an option.

;IRQ's don't always happen for some reason.  Seems to happen just on Dell
;  -- laptop works fine, at least with just mouse (not keyboard).

;WriteCR fixed Report Descriptor on Dell.  Clueless as to why.
;  Maybe sharing IRQ with Video interrupt?

;Descriptor Option w/ Optional Address (not necessarily last Device Enumerated).
;  May cause Device to stop responding and needs to be Reset (HP Wireless
;  Mouse).  If last enumerated devices, gets data from TSR -- does not
;  download anything from Device except string descriptors (if there are any).

;ReportDescriptor Option

;Run Device will not recover from Config Value 0 -- need to Reset to change
;  Config value.

;Doesn't round-robin addresses any more

;IncDataX, GetDataX must have direction in EP!  (EP 01h is different than 81h)


COMMENT 

  UHCI has a process called Bandwidth Reclamation.  Basically, as the end
    of a Frame draws near, it doesn't start any new Packet Transactions.
  Bandwidth Reclamation may make sense in a different environment, but
    in our DOS Environment I can't figure out a way for it to be useful.
  Because we need to be very conservative with our memory usage, we don't
    create multiple Transfer Descriptors for the same Transaction if we
    can help it.
  TD's use a LOT of memory (32 bytes each), so we simply try to modify and
    reschedule TD's until an entire transaction is complete.  In addition
    to using less memory, this also INSURES that everything occurs in the
    correct order.  Sending packets out of order could REALLY screw things up
    badly.
  Therefore, we do not have a special "Bandwidth Reclamation" process (I did
    try to set one up, but there was really no good, efficient way to implement
    it, so I gave up on the idea).

END COMMENT ;

COMMENT 

  Full-Speed Bit Times for Full-Speed and Low-Speed Packets:

           Sync PID Addr/EndPt Data CRC16 EOP InterPkt  Total  When Needed
           ---- --- ---------- ---- ----- --- --------  -----  -------------
    Token:    8   8       16                3       18     53  All Packets
     Data:    8   8               N    16   3       18   N+53  DataSize > 0
   Status:    8   8                         3       18     37  All exc Isoch
   ------- ---- --- ---------- ---- ----- --- --------  -----  -------------
   TOTAL:                                               N+143

  For Low-Speed Transactions, the data above is actually sent at 1.5 Mbps.
    Therefore, above numbers must be multiplied by 8 (multiplication factor
    between 1.5 Mbps and 12 Mbps) to determine the total time.
  In addition, for a Low-Speed Transaction, the following bits are sent
    as a Preamble at Full Speed (12 Mbps).  The Preamble informs the Hub
    that the Device is attached to that it must transition into a Low-Speed
    State.  The Hub will automatically revert back to Full Speed when it
    receives an End-Of-Packet.
  Note also that Low-Speed Devices are not allowed to do Bulk or Isoch,
    only Int & Control.

              Sync PID HubTransition Total
              ---- --- ------------- -----
       Token:    8   8             4    20
     Data In:                            0
    Data Out:    8   8             4    20
      Status:    8   8             4    20

  This data was used to set the Bit Overhead EQUates.

END COMMENT ;

COMMENT 

  When Resetting a Device attached to a "real" (remote) Hub, we simply send
    a Reset Signal to the Hub, and it has an internal timer which
    automatically turns off the Reset Signal (after an optimal 20ms).
  In a UHCI Root Hub (and possibly in OHCI and EHCI also), there is no
    internal timer that automatically does that.  We need to do the timing
    ourselves and turn off the Reset Signal manually.  Also, according to the
    USB specification, a Reset Signal from the Root Hub should last
    at least 50ms, rather than the standard 20ms that a Remote Hub is supposed
    to do.  I have no idea why a Root Hub signal needs to last that long,
    but that's what the USB spec says.
  In addition, on at least some UHCI Hosts, while a Reset Signal is being
    issued, the Bus does not generate any timing.  The implication of that,
    of course, is that we can't use the USB Bus itself to time the duration
    of the Reset Signal.
  So, controlling the duration of the Reset Signal is quite a bit more
    complicated on the Root Hub than it is on the Remote Hub.
  On the Flip side, though, we have Direct, Immediate access to the Root Hub
    Status (we just need to read from an I/O Port or a Memory Address).
    To get any details about a Remote Hub, we actually have to send
    Control Packets across the USB Bus to the Hub, and wait for the Hub to
    respond (which will always take at least a few milliseconds).
  In addition to Resetting a Device, almost all other Aspects of Controlling
    a Device have similar issues.  Enabling, Disabling, Suspending, Resuming,
    etc., are in some respects much simpler from the Root Hub, and in other
    respects are much more compicated from the Root Hub.
  The result of all this is to simply point out that the way we Control a
    Device from the Root Hub is VERY different than the way we do it from a
    Remote Hub.  To the "outside world", they need to look exactly the same,
    though.  Compare the details from this program to those in USBHUB if you
    want to know more.

END COMMENT ;

COMMENT 

  On the UCHI card in the DeskTop at home, USB Hardware Interrupts are not
    issued while the Root Hub Ports have a reset signal on them (go figure).
    USB Hardware Interrupts are not Disabled on the Dell Computers at work.
    Unfortunately, this Program must work on ALL Computers, so we need to
    assume that the Hardware Interrupts are always Disabled when there
    is a Reset Signal on the USB Host.  Since we cannot use the USB Interrupt
    to control the timing of the Reset Signal, we will use Int 08 to control
    the Timing instead.
  Int 70h would be "nicer" to use than Int 8, because it has a much finer
    resolution (1ms as opposed to 55ms).  But, Int 70h is not reliable enough
    that we can be SURE it will really work.  This is not a huge dilemma,
    though, since a Reset Signal from a ROOT Hub must last AT LEAST 50ms.
    The way the Root Hub Reset fuctions works here, the Reset signal will
    last somewhere between 55 and 110 ms.

END COMMENT ;

COMMENT 

  The DelayMS and DelayUS SubRoutines allow delays of fairly precise intervals
    (microseconds or milliseconds).  They are pretty accurate if the computer
    is Fast and the Delays are relatively small.
  There is a small amount of extra delay due to the overhead of how the
    routine works, which is cumulative as the requested delay times get big,
    which decreases the accuracy.
  Again, because of the overhead associated with the routines, the faster
    a computer is the more accurate the timing is.  It simply takes a slower
    computer longer to process the overhead, which consequently decreases
    the accuracy.
  In spite of that, the routines actually work very well.

  Instead of using these routines, we could also use the Int 15h Function 86h
    Delay Function.  Unfortunately, the BIOS routine has some fairly
    significant problems with it that make it unreliable enough that we
    won't use it.
  The first problem with the BIOS Routine is that even though you give it the
    number of Microseconds to Delay, the actual resolution of the Delay
    is in increments of approximately 1 millisecond in size.  That is, the
    smallest Delay available is actually approximately 1 ms, and increases
    in increments of approximately 1 ms.  Our routine here can truly do
    Delays with microsecond resolution.
  The second problem with the BIOS delay function is that it doesn't always
    work.  The Timer it uses to measure the Delays is user programmable,
    and quite a few different programs use it and reprogram it.  If this
    happens, it's possible that the Delay Routine either won't work at all
    or the Delay times could be wrong.  I know that on at least one LapTop
    I have the Timer associated with the BIOS Delay sometimes simply stops
    working for no apparent reason.  When this happens, I need to COMPLETELY
    remove power from the LapTop (including removing the Battery) for several
    seconds before it will start working again.  Simply turning the computer
    off and on again (a "Cold Boot") doesn't fix it.
  The last problem with the BIOS Delay Function is that it doesn't exist
    on really old (XT-class) computers.  The Timer this Code
    uses is associated with Int 08h (the Computer Timer Tick Clock Interrupt),
    which all computers have and is not something that programs are EVER
    supposed to mess with.  So, this should be a very reliable and accurate
    Delay Method.

  Also note that you must be very cautious about using any kind of Delays
    in a TSR, especially if they are tied to a hardware Interrupt of some
    sort.  It's real easy to have the machine completely lock up on you.
    In this program, we do in fact use these Delay routines, and do in fact
    tie them to hardware interrupts (very carefully).  We keep the Delay times
    Short, and only use these routines when we are actually trying
    to do something to the USB Host Controller when the USB Bus is stopped.
    In this Program, the first choice for Delay timing is to use the USB
    Bus itself, but of course that only works if the Bus is Running!  We
    need to get our Delay Timing from somewhere else if the Bus is Stopped
    (which is what these routines allow us to do).

END COMMENT ;

COMMENT 

  We will initialize all QH's to point at each other in sequence.
  When a QH needs to do something, we'll just fill it with TD's, and won't
    need to worry about adding the QH to the end of a "QH Queue".
  The disadvantage to this is that, if the Bus is fairly busy (there are
    several Bulk Transactions being processed at the same time), and if we're
    not careful, things will not always be first-come, first served.  New Bulk
    Transactions may be able to jump "in front" of other Bulk Transactions
    that are already in progress.  That may or may not be a problem.  For now,
    we won't worry about it.  Bulk Transactions are the lowest priority
    anyway, so it shouldn't be a big deal.  I do need to emphasize again that
    his will NOT be a problem except on a very busy Bus.  A Bus that does not
    have several Bulk Devices trying to issue Requests that overlap in
    time should not experience any issues at all.
  It could be an issue if trying to write to a CD or something, which is in
    effect a time-critical Bulk function, which USB is not inherently
    designed to handle anyway.  If trying to do a time-critical Bulk Transfer,
    the user will be responsible for not trying to do something else at the
    same time (like printing) that can cause Bus Latency issues.  This is also
    true in Windows (the user is responsible).  In fact, it will probably
    be even less of a problem in DOS, because DOS is not capable of
    multitasking, and something like a DOS CD-Writing program would most
    likely be a foreground application rather than a background (TSR)
    application, anyway.

END COMMENT ;

COMMENT 

  For our "Fake" Periodic & One-Time Interrupts, we send Transactions to
    Device 1 (the Root Hub), EndPoint 0.  This device does not actually
    exist on the USB Bus, so the Transaction will always fail.  This is OK,
    since all we really care about is the TIMING of when it happens, and are
    never actually trying to send any data across the bus.  However, we do
    actually attempt to send the transaction across the Bus, and actually
    allow the hardware to process the Errors we know are going to happen.
    This process does, in fact, consume Bus Bandwidth and Host Processing
    power.
  It might also be possible to process these "Fake" transactions using
    less Bus bandwidth, by monitoring the transactions with some CPU Code
    instead of letting the USB Host process and retire the (errored) Transfer
    Descriptors for us.  For a highly-utilized bus, this might be a
    more efficient way to do things (at least if you consider CPU bandwidth
    to be "cheaper" than USB Bus Bandwidth).  In the future, we may need to
    modify the program to do that, but we will not worry about it for now.

END COMMENT ;

COMMENT 

  We only allow a fairly limited number of New Device Request Registrations
    (a total of 128 for all Hosts).  Theoretically, this is an overly-limited
    number, since a full complement of 16 Hosts could easily have
    at least 128 Devices.  While it is theoretically highly limited, in
    reality it should be more than sufficient.
  Any Application Registering as a New Device Owner will either need to be
    a TSR (where the Registering Callback Code is ALWAYS in memory), or it
    will need to be the current foreground Application.  Before a Foreground
    Application can be terminated, it must unRegister itself (assuming that
    it did, in fact, Register in the first place).  If it does not unRegister,
    disaster will ensue shortly thereafter.  Just because of the way DOS works
    (non-multitasking with limited memory resources), a Foreground Application
    would probably not even Register at all, and would just periodically Poll
    the Host Driver for new Device(s), anyway.
  In addition, a single New Device Registration can process several "related"
    Devices, or at least handle all Devices of the same Type, even if they
    span multiple Hosts.  So, 128 should be enough to handle any "reasonable"
    machine, though it is very possible to add more if it becomes an issue.

END COMMENT ;


COMMENT 

  For the most part, we will not automatically handle any Power Issues.
    We will simply assume that the user can figure out Power issues and
    resolve them for themselves.  We will take this approach for a couple
    of different reasons.
  The first reason is that some Devices simply lie about their Power
    requirements.  At least one Hub I have claims that it is Self-Powered
    when it really isn't.  So, ultimately the Hub that it is attached to
    would need to provide the Power for that Hub and all Devices attached to
    it, although we could never tell that from the Hub Descriptors.
    If we were to actually believe what the Hub told us, we could run
    into some pretty serious problems.
  The other reason we won't really handle this is because the Descriptors
    return MAXIMUM power, which may or may not be anything close to
    steady-state reality.  I don't believe we can correctly state that
    a Device either will or will not work based on any Power calculations
    that are derived from the USB Descriptors.
  Basically, although the USB Spec TRIES to provide a mechanism for Power
    Management, it doesn't do a good enough job to be all that useful.
    And, since at least one manufacturer outright lies about its specs,
    all bets are off.  You really won't be able to believe anything you see.
    Any calculations done based on the the Descriptors will at best probably
    be inaccurate, and at worst will lead to failures.
  I suspect Power issues are going to be one of the major sources of problems,
    which is a shame.  We'll need to mention this in the documenation,
    but ultimately it will be the responsibility of the user to figure it
    out and fix it.
  We will be able to provide the user with a little bit of information,
    but have no way of guaranteeing its accuracy.

END COMMENT ;


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;EQUATE/STRUCTURE/MACRO DEFINITIONS
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;EQUATES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;==============================================================================
;TSR Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special Interrupt 2Fh (TSR Multiplex) Function Numbers we monitor/use
  ;----------------------------------------------------------------------------
  MuxInstallChk  EQU 0 ;Handle # Install Check
  MuxGetProgName EQU 1 ;Get Program Name
  MuxGetProgVer  EQU 2 ;Get Program Version
  MuxGetAuthor   EQU 3 ;Get Program Author

  ;These is a special function we use for this program.  There can be
  ;  multiple instances of this program in memory, though only the
  ;  first instance actually contains the program code.  Any instances
  ;  after the first one only contain data (not code).  This Multiplex
  ;  Function helps us find the first instance.  Other programs will
  ;  generally not have this function, though they will have the ones
  ;  detailed above.
  MuxGetPCIIndex EQU 4 ;Get PCI Search Index


  ;----------------------------------------------------------------------------
  ;Alternate Multiplex Interface Specification AMIS (Int 2D) Function Numbers.
  ;This is the AMIS version 3.6 list.
  ;INT 2Dh called with AH = Multiplex Number, AL = Function Number.
  ;In general, returns AL = 0 if invalid/unimplemented function
  ;Multiplex Numbers are dynamic.  On installation, programs scan from 0-FFh,
  ;  remember first available handle, and use it.
  ;Functions 0, 2, 4 always required, 5 if Hot-Keys are used,
  ;  6 if Devices exist.
  ;INT's use IBM Interrupt Sharing Protocol (IISP).
  ;
  ;NOTE: The spec says that AMIS version 3.6 compliant programs must not
  ;        implement functions 1-3 of the Get Int functions, which are
  ;        only included as a historicaly reference for version 3.3.
  ;        This doesn't make sense, though, since a version 3.3 program
  ;        doesn't know about function 4 (the List) so will be unable to
  ;        properly scan for interrupts.
  ;      AMIS appears to be shooting itself in the foot (though, admittedly,
  ;        RBIL says that it doesn't believe any programs ever
  ;        actually implemented this feature).
  ;----------------------------------------------------------------------------
  AMISInstallChk    EQU   00h ;Installation Check.  If installed, returns:
                              ;  AL = -1
                              ;  CX = Version (CH = Major, CL = Minor)
                              ;  DX:[DI] = Signature String
                              ;    8 bytes space-padded Vendor Name
                              ;    8 bytes space-padded Product Name
                              ;    ASCIIZ Program Descr, up to 64 bytes,
                              ;      Optional
  AMISGetPrvEntry   EQU   01h ;Get Private Entry Point.  Returns:
                              ;  AL = 0 if none (all calls via INT 2Dh)
                              ;     = -1 if entry point supported
                              ;       DX:[BX] = Entry Point
  AMISUninstall     EQU   02h ;Uninstall TSR.  Called with DX:[BX] = Return
                              ;  Address to use if Uninstall is Successful
                              ;  (may be ignored).  Returns in AL:
    AMISUnNotImp    EQU   00h ;  Uninstall not implemented (not allowed by spec)
    AMISUnNoSuccess EQU   01h ;  Unsuccessful
    AMISUnLater     EQU   02h ;  Will Uninstall Later - Can't do it now
    AMISUnSafeEn    EQU   03h ;  No Resident Uninstaller, TSR still Enabled
    AMISUnSafeDis   EQU   04h ;  No Resident Uninstaller, TSR Disabled
    AMISUnUnsafe    EQU   05h ;  Not Safe, try again later
    AMISUnCONFIG    EQU   06h ;  Loaded via CONFIG.SYS, can't Uninstall,
                              ;    Disabled
    AMISUnExternal  EQU   07h ;  No resident Uninstaller, Disabled,
                              ;    External Uninstaller can Unlink Devices,
                              ;    Unhook INT's, and Free Memory
                              ;  Also returns BX = TSR Segment to Free
    AMISUnSuccess   EQU   -1  ;  Uninstalled Successfuly
  AMISReqPopup      EQU   03h ;Request Popup.  Returns in AL:
    AMISPopNotImp   EQU   00h ;  Popup not implemented
    AMISPopNotNow   EQU   01h ;  Can't pop up now, try again later
    AMISPopLater    EQU   02h ;  Can't pop up now, will do so when able
    AMISPopAlready  EQU   03h ;  Already popped up
    AMISPopUser     EQU   04h ;  User intervention required, BX = Reason
                              ;    If Reason !=0, CX = Application Reason
      AMISPRUnknown EQU 0000h ;    Unknown Failure
      AMISPRMemSwap EQU 0001h ;    Int Chain passes through memory which must
                              ;      be swapped out in order to pop up
      AMISPRInFail  EQU 0002h ;    Swap In Failed
    AMISPopSuccess  EQU   -1  ;  Pop-up occurred & exited Successfully,
                              ;    BX = Return Value (Exit Code)
      AMISPXNone    EQU 0000h ;    No Return Value
      AMISPXUnload  EQU 0001h ;    TSR Uninloaded (Uninstalled)
      ;0002h-00FFh = Reserved for future AMIS enhancements
      ;0100h+      = Can be used for Internal Purposes
  AMISGetInts       EQU   04h ;Determine Chained Interrupts
                              ;  Input BL = INT # (INT 2Dh not needed)
                              ;  Returns in AL:
    AMISIntNotImp   EQU   00h ;  Interrupt determination not implemented
    AMISIntUnknown  EQU   01h ;  Unable to Determine (Obsolete)
    AMISIntHooked   EQU   02h ;  Interrupt is Hooked (Obsolete)
    AMISIntAddress  EQU   03h ;  Interrupt is Hooked, DX:[BX] = Handler Address
                              ;    (Obsolete)
    AMISIntList     EQU   04h ;  Interrupt List returned in DX:[BX]
                              ;    (Interrupt Number in BL is ignored)
                              ;    Format of List:
                              ;      DB INT #
                              ;      DW Handler Offset (using DX as segment)
                              ;    Last entry in list is for INT 2Dh
  AMISGetHotKeys    EQU   05h ;Get HotKey List.  Returns in AL:
    AMISKeyNotImp   EQU   00h ;  Hot-keys not implemented
    AMISKeySupport  EQU   -1  ;  Hot-keys supported, DX:[BX] = Hot-key List
                              ;  Format of List:
                              ;    DB Type of Hot-Key Checking
                              ;        01h = Checks before chaining to INT 09
                              ;        02h = Checks after chaining to INT 09
                              ;        04h = Checks before chaining to Int15.4F
                              ;        08h = Checks after chaining to Int15.4F
                              ;        10h = Checks on INT 16h, AH = 00, 01, 02
                              ;        20h = Checks on INT 16h, AH = 10, 11, 12
                              ;        40h = Checks on INT 16h, AH = 20, 21, 22
                              ;        80h = Reserved (0)
                              ;    DB Number of Hot-keys (may be 0 if Disabled)
                              ;       Followed by 6-byte Hot-key definitions
                              ;       Hot-key definition entry:
                              ;         DB Scancode (00h = Modifier Keys Only)
                              ;            Bit 7 (80h) set if Release Trigger
                              ;         DW Required Shift State
                              ;            0001h Right Shift Pressed
                              ;            0002h Left Shift Pressed
                              ;            0004h Either Control Pressed
                              ;            0008h Either Alt Pressed
                              ;            0010h ScrollLock Active
                              ;            0020h NumLock Active
                              ;            0040h CapsLock Active
                              ;            0080h Either Shift Pressed*
                              ;            0100h Left Control Pressed*
                              ;            0200h Left Alt Pressed*
                              ;            0400h Right Control Pressed*
                              ;            0800h Right Alt Pressed*
                              ;            1000h ScrollLock Pressed*
                              ;            2000h NumLock Pressed*
                              ;            4000h CapsLock Pressed*
                              ;            8000h SysReq Pressed*
                              ;            NOTE: Except for bit 7 (Either Sft),
                              ;                    this matches Int16.12h
                              ;         DW Disallowed Shift State
                              ;         DB Flags
                              ;            01h = Chained Before Processing
                              ;            02h = Chained After Processing
                              ;            04h = Others should pass through so
                              ;                    key can be monitored
                              ;            08h = Will not activate if other keys
                              ;                    are changed before completion
                              ;            10h = Key is remapped into another
                              ;            20h = Sometimes chained, sometimes
                              ;                    swallowed
                              ;            bits 6-7 = Reserved (0)
                              ;  Examples:
                              ;    Ctrl-Alt-Del: 53h 000Ch 0003h 06h
                              ;    Alt-key tap:  B8h 0000h 0007h 08h
                              ;    Shf-Shf-N:    31h 0003h 000Ch 00h
  AMISGetDevices    EQU   06h ;Get Device Driver Information.  Returns:
                              ;  AL = Number of Device Drivers
                              ;  AH = Flags
                              ;       01h = Loaded via CONFIG.SYS
                              ;       02h = Not linked into Device Driver Chain
                              ;       04h = Drivers are re-entrant
                              ;       bits 3-7 = Reserved (0)?
                              ;  DX:[BX] = First Device Driver Header
  ;Functions 07h-0Fh = Reserved for future AMIS enhancements
  ;Functions 10h+    = Can be used for Internal Purposes
  ;In our TSR's, we will reserve functions 10h-1Fh for additional functions
  ;  we may want to use in ALL of our TSR's, but are not part of the AMIS
  ;  standard.  I have no idea what those might be right now, but who knows
  ;  what ideas we could come with next several years.
  ;We will also reserve functions 20h-2Fh for "class-specific" functions.
  ;  For example, if we need a special function for all of the USB drivers,
  ;  or all of the "screen display" programs (CLOCK, SERIAL, LOCKEYS),
  ;  or some other set of programs that are "related" to each other.
  ;Functions 30h+ will be used for program-specific functions, if a
  ;  program needs them.

  ;----------------------------------------------------------------------------
  ;This is a special function we use for this program.  There can be
  ;  multiple instances of this program in memory, though only the
  ;  first instance actually contains the program code.  Any instances
  ;  after the first one only contain data (not code).  This Multiplex
  ;  Function helps us find the first instance.  Other programs will
  ;  generally not have this function, though they will have the ones
  ;  detailed above.
  ;----------------------------------------------------------------------------
  AMISGetPCIIndex EQU 30h ;Get PCI Search Index


;==============================================================================
;Miscellaneous
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special Codes
  ;----------------------------------------------------------------------------
  No  EQU  0 ;Miscellaneous Yes/No tests
  Yes EQU -1 ;      "        "  "    "


;==============================================================================
;CPU Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Bit masks in the CPU Flags Register
  ;----------------------------------------------------------------------------
  CarryFlag  EQU 0001h ;Carry Flag
  ;Bit 1 always set
  ParityFlag EQU 0004h ;Parity Flag
  ;Bit 3 always clear
  AuxFlag    EQU 0010h ;Auxiliary Flag
  ;Bit 5 always clear
  ZeroFlag   EQU 0040h ;Zero Flag
  SignFlag   EQU 0080h ;Sign Flag
  TrapFlag   EQU 0100h ;Trap Flag
  IntFlag    EQU 0200h ;Interrupt Flag
  DirFlag    EQU 0400h ;Direction Flag
  OFFlag     EQU 0800h ;Overflow Flag
  ;Bits 12-15 always set on 8086
  ;Bits 12-15 always clear on 80286
  IOPLMask   EQU 3000h ;I/O Privelege Level (80286+)
  NestedFlag EQU 4000h ;Nested Task Flag (80286+)
  ;Bit 15 always clear on 80386+

  ;----------------------------------------------------------------------------
  ;Special CPU OpCodes we need to concern ourselves with
  ;----------------------------------------------------------------------------
  OpCodeIntXX    EQU 0CDh ;Int XX
  OpCodeRETF     EQU 0CBh ;RETF
  OpCodeJMPShort EQU 0EBh ;JMP Short (+128/-127 bits max)


;==============================================================================
;CONsole/Screen Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special ASCII Characters
  ;----------------------------------------------------------------------------
  Tab       EQU  9 ;Tab
  LF        EQU 10 ;Line Feed
  FormFeed  EQU 12 ;FormFeed
  CR        EQU 13 ;Carriage Return
  EOF       EQU 26 ;End-of-File
  Quote2    EQU 34 ;Double quote
  Quote1    EQU 39 ;Single quote
  BackSlash EQU 92 ;BackSlash (\)

  ;----------------------------------------------------------------------------
  ;Special Keys that can be pressed during Pause routine
  ;----------------------------------------------------------------------------
  CtrlC  EQU  3 ;Control-C Keystroke
  Escape EQU 27 ;Escape Keystroke


;==============================================================================
;DOS Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;;Minimum DOS Version required to use this program
  ;----------------------------------------------------------------------------
  MinDOSVer EQU 0300h

  ;----------------------------------------------------------------------------
  ;Default Number of Entries in the Job File Table in the PSP
  ;----------------------------------------------------------------------------
  JFTEntries EQU 20

  ;----------------------------------------------------------------------------
  ;DOS Memory Allocation Strategies
  ;----------------------------------------------------------------------------
  StrategyLowFirst     EQU 00h ;First Fit, Low Memory Only
  StrategyLowBest      EQU 01h ;Best Fit, Low Memory Only
  StrategyLowLast      EQU 02h ;Last Fit, Low Memory Only
  ;For DOS 3&4, anything >2 is Last Fit Low Memory
  ;Below are for DOS 5+ Only
  StrategyHighFirst    EQU 40h ;First Fit, High Memory Only
  StrategyHighBest     EQU 41h ;Best Fit, High Memory Only
  StrategyHighLast     EQU 42h ;Last Fit, High Memory Only
  StrategyHighLowFirst EQU 80h ;First Fit, Try High Memory then Low Memory
  StrategyHighLowBest  EQU 81h ;Best Fit, Try High Memory then Low Memory
  StrategyHighLowLast  EQU 82h ;Last Fit, Try High Memory then Low Memory

  ;----------------------------------------------------------------------------
  ;UMB Link States
  ;----------------------------------------------------------------------------
  UMBLinkNo  EQU 00h ;UMB's are not part of DOS Memory Chain
  UMBLinkYes EQU 01h ;UMB's are in DOS Memory Chain (DOS=HIGH,UMB in CONFIG.SYS)

  ;----------------------------------------------------------------------------
  ;Sizes of various DOS data structures
  ;----------------------------------------------------------------------------
  FCBSize     EQU  44 ;Size of DOS File Control Block
  CmdTailMax  EQU 128 ;Maximum size of a DOS Command Tail
  MaxPathSize EQU  64 ;Maximum Size of a DOS Path/FileName String

  ;----------------------------------------------------------------------------
  ;Special "hard-coded" DOS Device Handles.
  ;These Handles are permanently hard-coded in DOS, and are always open.
  ;There is no need to issue Find, Open, or Close calls to these
  ;  devices - you can just use them at will.
  ;----------------------------------------------------------------------------
  StdInHandle  EQU 0 ;Standard Input Device Handle
  StdOutHandle EQU 1 ;Standard Output Device Handle
  StdErrHandle EQU 2 ;Standard Error Device Handle
  StdAuxHandle EQU 3 ;Standard Auxiliary Device Handle (COM1 by default)
  StdPrnHandle EQU 4 ;Standard Printer Device Handle (LPT1 by default)

  ;----------------------------------------------------------------------------
  ;Values to return in AL from Critical Error Handler (INT 24h)
  ;----------------------------------------------------------------------------
  CritErrIgnore    EQU 00h ;Ignore Error and Continue Operation
  CritErrRetry     EQU 01h ;Retry Operation
  CritErrTerminate EQU 02h ;Terminate program
  CritErrFail      EQU 03h ;Fail System Call

  ;----------------------------------------------------------------------------
  ;Codes returned by INT 21h, Function 4400h (Get Device Information)
  ;----------------------------------------------------------------------------
  ;If bit 7 is Set (is a Device):
  DvcInfoIsStdIn    EQU 0001h ;STDIN
  DvcInfoIsStdOut   EQU 0002h ;STDOUT
  DvcInfoIsNUL      EQU 0004h ;NUL
  DvcInfoIsClock    EQU 0008h ;CLOCK$
  DvcInfoInt29h     EQU 0010h ;Uses Int 29h (Special Device)
  DvcInfoBinary     EQU 0020h ;Binary (Raw) Mode
  DvcInfoEOF        EQU 0040h ;EOF on Input
  DvcInfoIsDevice   EQU 0080h ;Is a Device (not a File)
  DvcInfoKEYB       EQU 0100h ;Unknown (set by DOS 6.2x KEYB program)
  DvcInfoOpenClose  EQU 0800h ;Supports Open/Close calls
  DvcInfoOutputBusy EQU 2000h ;Supports Output until Busy
  DvcInfoIOCTL      EQU 4000h ;Can process IOCTL requests (INT 21h, Func 4402h)

  ;If bit 7 is Clear (is a File):
  DvcInfoDriveMask    EQU 003Fh ;Drive number (0 = A:)
  DvcInfoNotWritten   EQU 0040h ;File has not been written (Dirty Buffer?)
  ;Bit 7 = Clear!
  DvcInfoInt24h       EQU 0100h ;Generate Int 24h on Errors (DOS 4 only)
  DvcInfoNotRemovable EQU 0800h ;Media Not Removable
  DvcInfoNoDateTime   EQU 4000h ;Don't set File Date/Time on Closing (DOS 3.0+)
  DvcInfoRemote       EQU 8000h ;File is Remote (DOS 3.0+)


;==============================================================================
;PIC-Related (for handling IRQ's)
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Programmable Interrupt Controller (PIC) I/O Addresses
  ;----------------------------------------------------------------------------
  PIC1Addr EQU  20h ;Address of PIC #1 (IRQ's 0-7)
  PIC2Addr EQU 0A0h ;Address of PIC #2 (IRQ's 8-15)

  ;----------------------------------------------------------------------------
  ;PIC Output Control Word 2
  ;----------------------------------------------------------------------------
  ;Bits 0-2 = IRQ Selection
  OCW2IRQNumMask     EQU 00000111xb ;IRQ Number that specific EOI applies to
  ;Bits 3-4 = OCW Selection
  OCW2SelectOCW2     EQU 00000000xb ;Select OCW2
  ;Bits 5-7 = Operation to Perform
  OCW2RotateClear    EQU 00000000xb ;Rotate in Auto-EOI mode (Clear)
  OCW2NonSpecificEOI EQU 00100000xb ;Non-specific EOI (20h)
  OCW2NoOp           EQU 01000000xb ;No Operation
  OCW2SpecificEOI    EQU 01100000xb ;Specific EOI
  OCW2RotateSet      EQU 10000000xb ;Rotate in Auto-EOI mode (Set)
  OCW2RotateNonSpec  EQU 10100000xb ;Rotate on Non-specific EOI
  OCW2SetPriority    EQU 11000000xb ;Set Priority
  OCW2RotateSpecific EQU 11100000xb ;Rotate on Specific EOI

  ;----------------------------------------------------------------------------
  ;PIC Output Control Word 3
  ;----------------------------------------------------------------------------
  ;Bits 0-1 = Interrupt Register Operations
  OCW3ReadNoOp0   EQU 00000000xb ;Read Register NoOp
  OCW3ReadNoOp1   EQU 00000001xb ;Read Register NoOp
  OCW3ReadIRR     EQU 00000010xb ;Read Interrupt Request Register
  OCW3ReadISR     EQU 00000011xb ;Read Interrupt In-service Register
  ;Bit 2 = Poll Command
  OCW3PollCommand EQU 00000100xb ;Poll Command
  ;Bits 3-4 = OCW Selection
  OCW3SelectOCW3  EQU 00001000xb ;Select OCW3
  ;Bits 5-6 = Special Mask Operations
  OCW3SpMaskNoOp0 EQU 00000000xb ;Special Mask NoOp
  OCW3SpMaskNoOp1 EQU 00100000xb ;Special Mask NoOp
  OCW3SpMaskReset EQU 01000000xb ;Reset Special Mask
  OCW3SpMaskSet   EQU 01100000xb ;Set Special Mask
  ;Bit 7 = Reserved (0)


;==============================================================================
;INT 14h Related
;INT 14h is the Entry Point into our API
;These are various Codes/Values required to issue certain requests,
;  or returned by the requests
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Number of times to retry a Reset/Enumeration Request
  ;----------------------------------------------------------------------------
  ResetRetries EQU 5

  ;----------------------------------------------------------------------------
  ;Size of our Int 14 Request Structure
  ;----------------------------------------------------------------------------
  Int14RequestSize EQU 64 ;Size of an Int 14 Request Data Structure

  ;----------------------------------------------------------------------------
  ;Special Host Index Requesting a Command be sent to All Hosts
  ;Certain kinds of Int 14h Requests can/must be sent to ALL USB Hosts,
  ;  not just a specific Host
  ;Individual Hosts are numbered from 0-15, All Hosts = -1 (255)
  ;----------------------------------------------------------------------------
  AllHostsIndex EQU -1 ;Code for All Hosts Requests

  ;----------------------------------------------------------------------------
  ;Different USB Host & Bus Types returned by GetHostHardwareInfo
  ;Unlike most other Status bits, these are NOT bit-mapped.
  ;In today's environment, the only type of Bus anybody makes USB hardware
  ;  for is PCI, so that's the only option we have right now.  That could
  ;  change some time in the future.
  ;----------------------------------------------------------------------------
  ;Host Type is in Low Nibble
  USBHostTypeUHCI EQU 01h ;UHCI
  USBHostTypeOHCI EQU 02h ;OHCI
  USBHostTypeEHCI EQU 03h ;EHCI

  ;Bus Type is in High Nibble
  USBBusTypePCI   EQU 10h ;PCI

  ;----------------------------------------------------------------------------
  ;Different Flags returned by GetDvcPowerInfo
  ;----------------------------------------------------------------------------
  DvcPwrInfoSelfPwr  EQU 01h ;Device is Self-Powered
  DvcPwrInfoHubPPP   EQU 40h ;Device is Per-Port-Powered Hub
  DvcPwrInfoDvcIsHub EQU 80h ;Device is a Hub

  ;----------------------------------------------------------------------------
  ;Different Flags returned by GetAltIntfInfo
  ;----------------------------------------------------------------------------
  AltIntfInfoSelected EQU 01h ;Alt Interface is selected
  AltIntfInfoOwned    EQU 02h ;(Alt) Interface is Owned

  ;----------------------------------------------------------------------------
  ;INT 14h API Version Number returned by GetSoftwareInfo
  ;----------------------------------------------------------------------------
  APIVersion EQU 0005h ;Version 00.05: High Byte = Major, Low Byte = Minor

  ;----------------------------------------------------------------------------
  ;Maximum Timeout Value we will accept
  ;  Timeout Values are in DeciSeconds
  ;----------------------------------------------------------------------------
  MaxTimeout EQU 18000 ;1/2 Hour = 1800 Seconds = 18000 Deciseconds

  ;----------------------------------------------------------------------------
  ;Default Timeout Values for Transfer Descriptors
  ;  Timeout Values are in DeciSeconds
  ;----------------------------------------------------------------------------
  DefControlTimeout  EQU 10 ;Default Timeout for Control TD
  DefBulkTimeout     EQU 50 ;Default Timeout for Bulk TD
  DefDontLookTimeout EQU 20 ;Default Timeout for Don't Look Timeouts

  ;----------------------------------------------------------------------------
  ;Default Values for Beeping
  ;----------------------------------------------------------------------------
  DefBeepTimeout   EQU     3 ;Default Timeout for Beeps (deciseconds)
  DefBeepFrequency EQU  1000 ;Default Beep Frequency (Hertz)
  MinBeepFrequency EQU    20 ;Minimum Frequency = 20Hz
  MaxBeepFrequency EQU 20000 ;Minimum Frequency = 20kHz

  ;----------------------------------------------------------------------------
  ;Status Codes returned by GetHostStatus
  ;----------------------------------------------------------------------------
  HostStatusRunning   EQU  01h ;Host is running Normally
  HostStatusStopped   EQU  02h ;Host is Stopped/Halted
  HostStatusSuspended EQU  03h ;Host is in Global Suspend Mode
  HostStatusDebugMode EQU  04h ;Host is in Debug (Single-Step) Mode
  ;Need a Test Mode?
  HostStatusUnknown   EQU 0FFh ;Host is in a Unknown/Unrecognized Mode

  ;----------------------------------------------------------------------------
  ;Error Codes Returned by Int 14h Requests
  ;Error Codes are returned in AX
  ;If the Error Code is 0 (no Error), various other values will be returned
  ;  in BX, CX, and DX, depending on exactly what the call was
  ;----------------------------------------------------------------------------
  ;Problems with Our Program (like not enough space in a table)
  I14RErrResources      EQU 0001h ;Insufficient Resources/Memory
  I14RErrHostHardware   EQU 0002h ;Unknown/Hardware Problem with Host
  I14RErrReqTypeNoSupt  EQU 0003h ;Request Type recognized, but not Supported

  ;Errors we can recognize in USB Data Structure Data
  I14RErrRequestType    EQU 0011h ;Invalid Request Type
  I14RErrFlags          EQU 0012h ;Invalid Flags
  I14RErrHostIndex      EQU 0013h ;Invalid Host Index
  I14RErrDeviceAddress  EQU 0014h ;Invalid Device Address         |Same
  I14RErrHubAddress     EQU 0014h ;Invalid Hub Address            |Same
  I14RErrEndPoint       EQU 0015h ;Invalid EndPoint                |Same
  I14RErrHubPort        EQU 0015h ;Invalid Hub Port                |Same
  I14RErrAltIntf        EQU 0015h ;Invalid Alternate Interface     |Same
  I14RErrConfigValue    EQU 0016h ;Invalid Configuration Value    |Same
  I14RErrCloseID        EQU 0016h ;Invalid Closure ID             |Same
  I14RErrInterfaceNum   EQU 0017h ;Invalid Interface Number
  I14RErrSearchIndex    EQU 0018h ;Invalid Search Index
  I14RErrVendorProdID   EQU 0019h ;Invalid Vendor ID
  I14RErrDvcIntf        EQU 001Ah ;Invalid Device/Interface value
  I14RErrRequestHandle  EQU 001Bh ;Invalid Request Handle
  I14RErrPeriodicity    EQU 001Ch ;Invalid Periodicity             |Same
  I14RErrBeepFrequency  EQU 001Ch ;Invalid Beep Frequency          |Same
  I14RErrTimeOut        EQU 001Dh ;Invalid Timeout
  I14RErrDataAddress    EQU 001Eh ;Invalid Data Address
  I14RErrDataSize       EQU 001Fh ;Invalid Data Size (Low Speed <= 8)
  I14RErrCallBackAddr   EQU 0021h ;Invalid Call Back Address       |Same
  I14RErrLCRtnCode      EQU 0021h ;Invalid Large Call Return Code  |Same
  I14RErrUserPktID      EQU 0022h ;Invalid User Pkt ID (matches on unregistry)
  I14RErrSetupReqData   EQU 0023h ;Invalid Setup Request Data
  I14RErrFrameTiming    EQU 0024h ;Invalid Frame Timing            |Same
  I14RErrFrameIndex     EQU 0024h ;Invalid Frame Index             |Same
  I14RErrIsochArray     EQU 0025h ;Invalid Entry in Isoch Array Data

  ;Not User Input Errors (bad data), but failure codes
  I14RErrHostHalted     EQU 0031h ;Host is Halted/Suspended
  I14RErrIntfNotFound   EQU 0032h ;Interface not found (on FindIntf/RegIntf)
  I14RErrIntfInConfig   EQU 0033h ;Interface already being Configured on Device
  I14RErrIntfAlreadyReg EQU 0034h ;Interface already Registered
  I14RErrHostCallInUse  EQU 0035h ;Host Run/Stop/etc. already running
  I14RErrNoPortPower    EQU 0036h ;Per-Port-Power not Supported by Hub
  I14RErrAlreadyBeeping EQU 0037h ;Another Beep Request is already being handled

  ;Errors related to Debug Requests
  I14RErrDebugMode      EQU 0041h ;Tried to Single Step with No Debug Mode

  ;Errors related to Frame Timing Requests
  I14RErrTimingOwned    EQU 0051h ;Problem with Frame Timing Owner
                                  ;Can only have one Owner, and there must be
                                  ;  an owner before timing can be changed
  I14RErrTimingLimit    EQU 0052h ;Frame Timing is already at the Limit
  I14RErrTmgChgInProg   EQU 0053h ;Timing Change already in progress


  ;----------------------------------------------------------------------------
  ;Statuses sent to Device Owners
  ;The Device Owners CallBack Address is called when something happens to a
  ;  Host or a Device
  ;The value in this Table is in AX for the Call, and the User Packet ID is
  ;  in BX
  ;CX and DX contain other values as appropriate for the particular type of call
  ;----------------------------------------------------------------------------
  ;Device Connect/Disconnect
  OwnerCallNewDvc      EQU 0001h ;A new Device has been attached (matches Class)
                                 ;This is sent to Registered Device 0 Owners,
                                 ;  only if the new Device matches the Class
                                 ;  specification declared when Registered
                                 ;CL = Host Index, CH = Device Address, DX = 0
  OwnerCallDvcDisc     EQU 0002h ;Registered Device has been disconnected
                                 ;The Host Driver releases all TD's with same
                                 ;  address before Calling
                                 ;Device Driver must release all TD's with
                                 ;  Different Address (like Address 1)
                                 ;Only sent to THE Registered Interface Owner(s)
                                 ;  of this Device
                                 ;CL = Host Index, CH = Device Address, DX = 0
  OwnerCallDvc0Disc    EQU 0003h ;Unreg Device Disconnected (matches Class)
                                 ;This is sent to Registered Device 0 Owners,
                                 ;  only if the disco'd Device matches the Class
                                 ;  specification declared when Registered
                                 ;CL = Host Index, CH = Device Address, DX = 0
  OwnerCallDontLook    EQU 0007h ;Stop Looking for an Interface for a while
                                 ;CL = Host Index, CH = Device Address,
                                 ;DL = Interface Num, DH = Timeout (deciseconds)

  ;Device Enable/Disable/Reset/Suspend/Resume
  OwnerCallDvcEnable   EQU 0008h ;Device Enabled
                                 ;CL = Host Index, CH = Device Address, DX = 0
  OwnerCallDvcDisable  EQU 0009h ;Device Disabled
                                 ;CL = Host Index, CH = Device Address, DX = 0
  OwnerCallDvcReset    EQU 000Ah ;Device Resetting
                                 ;CL = Host Index, CH = Device Address, DX = 0
  OwnerCallDvcSuspend  EQU 000Bh ;Device Suspended
                                 ;CL = Host Index, CH = Device Address, DX = 0
  OwnerCallDvcResume   EQU 000Ch ;Device Resumed
                                 ;CL = Host Index, CH = Device Address, DX = 0
  OwnerCallDvcPwrOn    EQU 000Dh ;Device Powered On
                                 ;CL = Host Index, CH = Device Address, DX = 0
  OwnerCallDvcPwrOff   EQU 000Eh ;Device Powered Off
                                 ;CL = Host Index, CH = Device Address, DX = 0
  OwnerCallDvcPwrReset EQU 000Fh ;Device Power Reset
                                 ;CL = Host Index, CH = Device Address, DX = 0

  ;Host Connect/Disconnect/Error
  OwnerCallNewHost     EQU 0011h ;A new Host Driver has been Installed
                                 ;CL = Host Index, CH = DX = 0
  OwnerCallHostDisc    EQU 0012h ;An existing Host Driver has been Uninstalled
                                 ;CL = Host Index, CH = DX = 0
  OwnerCallHostHWErr   EQU 0017h ;Host System/Processor Error (will Reset Host)
                                 ;CL = Host Index, CH = DX = 0
  ;Host Enable/Disable/Reset/Suspend/Resume
  OwnerCallHostRun     EQU 0018h ;Host Running
                                 ;CL = Host Index, CH = DX = 0
  OwnerCallHostStop    EQU 0019h ;Host Stopped
                                 ;CL = Host Index, CH = DX = 0
  OwnerCallHostReset   EQU 001Ah ;Host Reset
                                 ;CL = Host Index, CH = DX = 0
  OwnerCallHostSuspend EQU 001Bh ;Host Suspended
                                 ;CL = Host Index, CH = DX = 0
  OwnerCallHostResume  EQU 001Ch ;Host Resumed
                                 ;CL = Host Index, CH = DX = 0
  OwnerCallHostDebug   EQU 001Dh ;Host in Debug Mode
                                 ;CL = Host Index, CH = DX = 0
  OwnerCallHostSST     EQU 001Eh ;Host Single-Stepped
                                 ;CL = Host Index, CH = DX = 0

  ;Timing Changes
  OwnerCallTimingChg   EQU 0021h ;Timing Change on Host
                                 ;CL = Host Index, CH = 0, DX = New Timing

  ;Upstream Device Changes
  OwnerCallDvcDiscUS     EQU (OwnerCallDvcDisc OR 0080h)     ;Dvc Disc Upstream
  OwnerCallDvcEnableUS   EQU (OwnerCallDvcEnable OR 0080h)   ;Dvc Enable Upstream
  OwnerCallDvcDisableUS  EQU (OwnerCallDvcDisable OR 0080h)  ;Dvc Disable Upstream
  OwnerCallDvcResetUS    EQU (OwnerCallDvcReset OR 0080h)    ;Dvc Reset Upstream
  OwnerCallDvcSuspendUS  EQU (OwnerCallDvcSuspend OR 0080h)  ;Dvc Suspend Upstream
  OwnerCallDvcResumeUS   EQU (OwnerCallDvcResume OR 0080h)   ;Dvc Resume Upstream
  OwnerCallDvcPwrOnUS    EQU (OwnerCallDvcPwrOn OR 0080h)    ;Dvc PwrOn Upstream
  OwnerCallDvcPwrOffUS   EQU (OwnerCallDvcPwrOff OR 0080h)   ;Dvc PwrOff Upstream
  OwnerCallDvcPwrResetUS EQU (OwnerCallDvcPwrReset OR 0080h) ;Dvc PwrReset Upstream

  ;Stuff below this line is only sent to Hub Drivers
  ;  Sent w/ BX = User Pkt ID, CL = Hub Address, CH = Port Number,
  ;    DL = Host Index, DH = New Address
  HubCallEnumerated EQU 0077h ;New/Reset Device has been Enumerated
  ;  Sent w/ BX=UserPktID, CL=HubAdr, CH=Port, DL=HostIndex, DH=DvcAddr
  HubCallEnable     EQU 0078h ;Enable Device
  HubCallDisable    EQU 0079h ;Disable Device
  HubCallReset      EQU 007Ah ;Reset Device
  HubCallSuspend    EQU 007Bh ;Suspend Device (Selective Suspend)
  HubCallResume     EQU 007Ch ;Resume Device
  HubCallPwrOn      EQU 007Dh ;Power On Device
  HubCallPwrOff     EQU 007Eh ;Power Off Device
  HubCallPwrReset   EQU 007Fh ;Power Reset Device

  ;----------------------------------------------------------------------------
  ;Possible Error Codes to return to calling program on completion of TD
  ;----------------------------------------------------------------------------
  ;Category 0 = Valid Response from Device, or Timeout
  TDStsOK             EQU 0000h ;ACK Received (TD completed OK / no errors)
    ;OHCI = NoError
  TDStsNAKReceived    EQU 0001h ;NAK Received
    ;OHCI = ??
  TDStsStalled        EQU 0002h ;TD is Stalled
    ;OHCI = Stall
    ;UHCI sets stall in combination with lots of other errors also!
  TDStsTimeout        EQU 0004h ;TD has timed out (Bulk/Control)
  TDStsOverDue        EQU 0008h ;TD is OverDue (Int/Isoch)

  ;Category 1 = Error from Device / Bus
  TDStsShortPacket    EQU 0010h ;TD Short Packet Detected (w/ SPD Enabled)
    ;OHCI = DataUnderRun
  TDStsBabbleDetected EQU 0020h ;Babble Detected
    ;OHCI = DataOverrun?
  TDStsCRCTOReceived  EQU 0040h ;CRC/TimeOut Error Received
    ;OHCI = CRC
    ;OHCI = DeviceNotResponding?
  TDStsBitStuffError  EQU 0080h ;Rx Data contained > 6 ones in a row
    ;OHCI = BitStuffing
    ;OHCI = DataToggleMismatch
    ;OHCI = PIDCheckFailure
    ;OHCI = Unexpected PID

  ;Category 2 = Host Problem
  TDStsDataBuffErr    EQU 0100h ;Data Buffer Error
    ;OHCI = BufferOverrun?  (Writing to System Memory)
    ;OHCI = BufferUnderrun? (Reading from System Memory)

  ;Category 3 = Other types of Errors
  TDStsControlSetup   EQU 1000h ;Error actually occurred during Control Setup
                                ;  (Byte count is for Setup Packet, not Data!)
  TDStsDvcRemoved     EQU 2000h ;Device removed while TD was in progress
  TDStsLargeCallErr   EQU 8000h ;Error during Large Call
                                ;  (Error during a "sub-call")

  ;============================================================================
  ;Values Used Internally to keep track of what's going on
  ;Never seen by the Outside World
  ;============================================================================

  ;----------------------------------------------------------------------------
  ;Address types returned by CalcPhysAddrType
  ;The TD types must be IN THE SAME ORDER as the TDTypes (Isoch, Int, ...)
  ;----------------------------------------------------------------------------
  PhysAddrClassNul              EQU 10h ;Empty/FrameList/Error
    PhysAddrTypeNone            EQU 10h ;None/Empty (all zeroes)
    PhysAddrTypeFL              EQU 11h ;Frame List Entry
    PhysAddrTypeErr             EQU 12h ;Unknown/Error
  PhysAddrClassQH               EQU 20h ;Queue Head
    PhysAddrTypeControlQH       EQU 20h ;Control Queue Head
    PhysAddrTypeBulkQH          EQU 21h ;Bulk Queue Head
    PhysAddrTypeIntQH           EQU 22h ;Interrupt Queue Head
  PhysAddrClassTD               EQU 40h ;Transfer Descriptor
    PhysAddrTypeAvailTD         EQU 40h ;Available Transfer Descriptor
    PhysAddrTypeReservedTD      EQU 41h ;Reserved Transfer Descriptor
    PhysAddrTypeIsochTD         EQU 42h ;Isochronous Transfer Descriptor
    PhysAddrTypeInt1TimeTD      EQU 43h ;One-Time Interrupt Transfer Descriptor
    PhysAddrTypeIntPerTD        EQU 44h ;Periodic Interrupt Transfer Descriptor
    PhysAddrTypeControlSetupTD  EQU 45h ;Control Transfer Descriptor
    PhysAddrTypeControlDataTD   EQU 46h ;Control Transfer Descriptor
    PhysAddrTypeControlStatusTD EQU 47h ;Control Transfer Descriptor
    PhysAddrTypeBulkTD          EQU 48h ;Bulk Transfer Descriptor


;==============================================================================
;Program Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Maximum Delay between Program Debug Steps
  ;----------------------------------------------------------------------------
  MaxDebugDelay EQU 2000 ;Two seconds

  ;----------------------------------------------------------------------------
  ;Minimum size of TSR Stack
  ;UHCI requires the Frame List to be a contiguous 4k page of data which
  ;  MUST be 4k-page aligned.  Since we have no idea where in memory our
  ;  TSR will end up being, we need to reserve 8K of space for the Frame List,
  ;  and put the start of the Frame List wherever in the 8K page the
  ;  boundary alignment happens to be.  This leaves us 4K of "extra" space,
  ;  most likely in 2 chunks (1 chunk before the Frame List and one after).
  ;We use this extra space for our Stack.  We will actually have two separate
  ;  stacks, but do not have any direct control over how big each of them
  ;  will be.  A small stack is useless and will only cause problems.
  ;This parameter controls the minimum size of stack we will allow.  If one
  ;  of the stacks is smaller than this, we will not use it (we will only
  ;  have one stack).  If both of them are at least this big, we will use
  ;  both stacks.
  ;----------------------------------------------------------------------------
  TSRStackSize EQU 1024 ;Minimum size of a stack before we'll use it

  ;----------------------------------------------------------------------------
  ;Extra bytes allowed for a Complete Configuration Descriptor during
  ;  the Device Enumeration process.
  ;A Complete Configuration Descriptor includes Interface and EndPoint
  ;  Descriptors, and may include other descriptors as well (depending
  ;  on the exact type of device).  Complicated Devices (like Audio/Video)
  ;  can have really large descriptors.
  ;----------------------------------------------------------------------------
  CfgDescrXBytes EQU 800

  ;----------------------------------------------------------------------------
  ;Maximum number of data frames we will allow in an Isoch Transaction
  ;----------------------------------------------------------------------------
  MaxIsochFrames EQU 256

  ;----------------------------------------------------------------------------
  ;Number of entries required by various tables
  ;Our TSR does some basic multitasking (allowing multiple Devices and
  ;  Drivers to be doing things at the same time), but we don't have
  ;  "unlimited" access to memory.  We set up static tables to manage
  ;  it all.  The number of entries in various tables determines how
  ;  many things we can do at the same time.
  ;----------------------------------------------------------------------------
  FLEntries    EQU 1024 ;Number of Frame List entries
  NDEntries    EQU  128 ;Number of New Device Notification Entries
  I8Entries    EQU   20 ;Number of Int 08 Delay Entries
  MaxHosts     EQU   16 ;Maximum number of Hosts
  CtlQHEntries EQU    1 ;Number of Control Queues

  #IF !LITE ;Full program (USBUHCI)

    BulkQHEntries    EQU 12 ;Number of Bulk Queues
    IntQHEntries     EQU 12 ;Number of Interrupt Overflow Queues
    QHEntries        EQU (CtlQHEntries+BulkQHEntries+IntQHEntries) ;Total

    TDEntries EQU  256 ;Number of Transfer Descriptor entries
    ADEntries EQU  128 ;Number of entries in Address Data Table
                       ;  0 = New, 1 = Root Hub, 2-127 = Actual Device
    InEntries EQU  160 ;Number of entries in Interface Data Table
                       ;  Most Devices have only one Interface!
    AIEntries EQU  256 ;Number of entries in Alternate Interface Data Table
                       ;  Each Interface typically has several
                       ;    Alternate (Sub) Interfaces
    EnEntries EQU  256 ;Number of entries in EndPoint Data Table
                       ;  Most Devices have only a couple of EndPoints,
                       ;    and we do not keep track of Isoch EP's,
                       ;    so this table doesn't need to be very big.
    SREntries EQU   32 ;Number of SetupRequest entries
                       ;We copy the actual Setup Request Header into the TSR
                       ;  data area to facilitate multitasking by device drivers!
    TTEntries EQU   48 ;Number of TimeOut Table Entries
    LCEntries EQU   16 ;Number of Large Call Entries
    RsEntries EQU   16 ;Reset Entries

   #ELSE    ;LITE program (USBUHCIL)

    BulkQHEntries    EQU 6 ;Number of Bulk Queues
    IntQHEntries     EQU 6 ;Number of Interrupt Overflow Queues
    QHEntries        EQU (CtlQHEntries+BulkQHEntries+IntQHEntries) ;Total

    TDEntries EQU   80 ;Number of Transfer Descriptor entries
    ADEntries EQU   18 ;Number of entries in Address Data Table
                       ;  0 = New, 1 = Root Hub, 2-17 = Actual Device
    InEntries EQU   32 ;Number of entries in Interface Data Table
                       ;  Most Devices have only one Interface!
    AIEntries EQU   64 ;Number of entries in Alternate Interface Data Table
                       ;  Each Interface typically has several
                       ;    Alternate (Sub) Interfaces
    EnEntries EQU   64 ;Number of entries in EndPoint Data Table
                       ;  Most Devices have only a couple of EndPoints,
                       ;    and we do not keep track of Isoch EP's,
                       ;    so this table doesn't need to be very big.
    SREntries EQU   12 ;Number of SetupRequest entries
                       ;We copy the actual Setup Request Header into the TSR
                       ;  data area to facilitate multitasking by device drivers!
    TTEntries EQU   16 ;Number of TimeOut Table Entries
    LCEntries EQU    6 ;Number of Large Call Entries
    RsEntries EQU    4 ;Reset Entries

   #ENDIF


;==============================================================================
;UHCI/PCI Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;IRQ Range we are allowed to use for the PCI IRQ
  ;IRQ 0 = Clock, IRQ 1 = Keyboard, IRQ 2 = Cascade to second PIC,
  ;  so none of those are available for "general" use.  We don't assign
  ;  (change) the IRQ if it was issued by the BIOS (which it should be),
  ;  unless the user specifically requests us to.  This is necessary in
  ;  the case of certain controllers where the IRQ listed in the PCI
  ;  configuration space is not the one the controller actually uses
  ;  (certain Intel Controllers do this).
  ;----------------------------------------------------------------------------
  MinIRQ EQU  3 ;Minimum IRQ number allowed
  MaxIRQ EQU 15 ;Maximum IRQ number allowed

  ;----------------------------------------------------------------------------
  ;Default IRQ to use.
  ;This is only needed if one has not already been assigned (presumably
  ;  by the PCI BIOS), and the User does not specify one, and we cannot
  ;  find another "sharable" PCI IRQ, and there are no free IRQ's.
  ;----------------------------------------------------------------------------
  DefaultIRQ EQU 9 ;IRQ to use as a Last Resort

  ;----------------------------------------------------------------------------
  ;I/O Base Range we are allowed to use for the PCI I/O
  ;As with the IRQ, we don't assign an I/I Base Address if one has already
  ;  been assigned by the BIOS (which it should be) unless the user
  ;  specifically requests us to do it.
  ;This is the Base I/O Address.  We need a total of 32 bytes of I/O space
  ;  for the controller.
  ;----------------------------------------------------------------------------
  MinIOBase EQU   256 ;Maximum I/O Address user can enter
  MaxIOBase EQU 65504 ;Maximum I/O Address user can enter (65536 - 32)

  ;----------------------------------------------------------------------------
  ;Various fixed UHCI/USB Maximums, Minimums, Offsets, etc.
  ;----------------------------------------------------------------------------
  SOFModifyBase EQU 11936 ;Base of Start-of-Frame Modify Register
                          ;  SOFModify adds to this to get the bus rate
  MaxLSBytes    EQU     8 ;Maximum Data Bytes in a Low-Speed Transfer
  MaxFSBytes    EQU  1023 ;Maximum Data Bytes in a Full-Speed Transfer
  MaxHSBytes    EQU  1024 ;Maximum Data Bytes in a High-Speed Transfer

  ;----------------------------------------------------------------------------
  ;Offsets of PCI registers required to obtain UHCI configuration data
  ;----------------------------------------------------------------------------
  PCIVendorID           EQU   00h ;Vendor ID Register
  PCIProductID          EQU   02h ;Product ID Register
  PCICfgCmd             EQU   04h ;Configuration Command Register
    PCICfgIOAccess      EQU 0001h ;I/O Access Enable
    PCICfgMemoryAccess  EQU 0002h ;Memory Access Enable
    PCICfgBusMaster     EQU 0004h ;Bus Master Enable
    PCICfgSpecialCycle  EQU 0008h ;Special Cycle Recognition Enable
    PCICfgMemWriteInv   EQU 0010h ;Memory Write and Invalidate Enable
    PCICfgVGASnoop      EQU 0020h ;VGA Palette Snoop Enable
    PCICfgParityErr     EQU 0040h ;Parity Error Response Enable
    PCICfgWaitCycles    EQU 0080h ;Wait Cycles Enable
    PCICfgSysErrLine    EQU 0100h ;System Error Line (SERR#) Enable
    PCICfgBack2Back     EQU 0200h ;Fast Back-to-Back Transactions Enable
    PCICfgIntDisable    EQU 0400h ;Do NOT allow Interrupts to be generated
    ;Bits 11-15 = Reserved
  PCIStatus             EQU   06h ;PCI Status Register (all bits R/WC, NOT R/W)
    ;Bits 0-2 = Reserved
    PCIStsIntAsserted   EQU 0008h ;Interrupt is Asserted
    PCIStsCapabilities  EQU 0010h ;Capabilities List
    PCISts66MHzCapable  EQU 0020h ;Capable of 66 MHz
    PCIStsUserFeatures  EQU 0040h ;User Defined Features
    PCIStsBack2Back     EQU 0080h ;Fast Back-to-Back Capable
    PCIStsDataParityErr EQU 0100h ;Data Parity Error Detected
    PCIStsDevSelTiming  EQU 0600h ;Device Select # Timing Status (2 bits)
    PCIStsSigTargAbort  EQU 0800h ;Signaled Target Abort
    ;Bit 12 = Reserved (0)
    PCIStsRxMasterAbort EQU 2000h ;Received Master Abort
    ;Bit 14 = Reserved (0)
    PCIStsDetParityErr  EQU 8000h ;Detected Parity Error
  PCIRevisionID         EQU   08h ;Revision Identification Register
  PCIProgramIntf        EQU   09h ;Programming Interface Register
  PCISubClass           EQU   0Ah ;Sub Class Code Register
  PCIClassCode          EQU   0Bh ;Base Class Code Register
  PCILatencyTimer       EQU   0Dh ;Master Latency Timer Register
  PCIHeaderType         EQU   0Eh ;Header Type Register
  PCIBaseIOAddr         EQU   20h ;Base I/O Address (bit 0 = 1, 1-4 = Reserved)
  PCISubSysVendorID     EQU   2Ch ;Subsystem Vendor ID Register
  PCISubSysID           EQU   2Eh ;Subsystem ID Register
  PCIIRQNum             EQU   3Ch ;IRQ Number
                                  ;  Not used by some Intel Chips!!
  PCIIntPin             EQU   3Dh ;Interrupt Pin Register
  PCIUSBVersion         EQU   60h ;USB Version Number
  PCILegacySupp         EQU  0C0h ;Legacy Support Info
    LSA20EndPassThruSts EQU 8000h ;End of A20 Gate Pass Through Status  RWC
                                  ;Bit 14 = Reserved
    LSUSBPIRQEn         EQU 2000h ;USB PIRQD Enable (1=IRQ Enabled)   RW
    LSUSBIRQSts         EQU 1000h ;USB IRQ Status (1=USB IRQ Active)  RO
    LSTrap64W           EQU 0800h ;Trap by Port 64h Write Status  RWC
    LSTrap64R           EQU 0400h ;Trap by Port 64h Read Status  RWC
    LSTrap60W           EQU 0200h ;Trap by Port 60h Write Status  RWC
    LSTrap60R           EQU 0100h ;Trap by Port 60h Read Status  RWC
    LSSMIEndPassThruEn  EQU 0080h ;SMI# at End of Pass Through Enable  RW
    LSA20PassThruSts    EQU 0040h ;A20 Gate Pass Through Status  RO
    LSA20PassThruEn     EQU 0020h ;A20 Gate Pass Through Enable  RW
    LSSMIUSBIRQEn       EQU 0010h ;SMI# on USB IRQ Enable  RW
    LSSMI64WEn          EQU 0008h ;SMI# on Port 64h Write Enable  RW
    LSSMI64REn          EQU 0004h ;SMI# on Port 64h Read Enable  RW
    LSSMI60WEn          EQU 0002h ;SMI# on Port 60h Write Enable  RW
    LSSMI60REn          EQU 0001h ;SMI# on Port 60h Read Enable  RW
  PCIResumeEnable       EQU  0C4h ;USB Resume Enable Register
                                  ;  Not valid on all Controllers?
    PCIResPort0Enable   EQU   01h ;Enable Port 0 to respond to Wakeup
                                  ;  and Connect/Disconnect Events
    PCIResPort1Enable   EQU   02h ;Enable Port 1 to respond to Wakeup
                                  ;  and Connect/Disconnect Events


;==============================================================================
;USB Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Bits of overhead data for different types of Packets
  ;Need these to make sure Isoch and Int only use 90% of Bandwidth
  ;----------------------------------------------------------------------------
  TokenOHBits      EQU    53 ;Bits in a Token Packet
  DataOHBits       EQU    53 ;Bits in a Data Packet (in addition to Data itself)
  StatusOHBits     EQU    37 ;Bits in a Status Packet
  LowSpeedOHBits   EQU    20 ;Bits of overhead for each Low-Speed Hub Preamble
  FrameBits        EQU 12000 ;Total number of Bits in a Frame
  SOFBits          EQU    27 ;Number of bits in the Start-of-Frame Packet
  IsochIntBits     EQU 10775 ;(FrameBits-SOFBits) * 90%
                             ;90% of BW in each frame reserved for Isoch & Int
;  MaxPerIntBytesFS EQU  1043 ;Maximum number of Periodic Interrupt bytes that
;                             ;  can be transmitted in a single frame without
;                             ;  using more than 90% of the bandwidth (assuming
;                             ;  that particular transaction is the ONLY one
;                             ;  in the Frame)
;  MaxPerIntBytesLS EQU    48 ;Above is for Full-speed Device, this is Low Speed


  ;----------------------------------------------------------------------------
  ;Language IDs for Strings (This is from the Microsoft Web Site for Win2K)
  ;----------------------------------------------------------------------------
  LangIDArabic             EQU 0401h
  LangIDBrazilian          EQU 0416h
  LangIDChineseSimplified  EQU 0804h
  LangIDChineseTraditional EQU 0404h
  LangIDCzech              EQU 0405h
  LangIDDanish             EQU 0406h
  LangIDDutch              EQU 0413h
  LangIDEnglish            EQU 0409h
  LangIDFinnish            EQU 040Bh
  LangIDFrench             EQU 040Ch
  LangIDGerman             EQU 0407h
  LangIDGreek              EQU 0408h
  LangIDHebrew             EQU 040Dh
  LangIDHungarian          EQU 040Eh
  LangIDItalian            EQU 0410h
  LangIDJapanese           EQU 0411h
  LangIDKorean             EQU 0412h
  LangIDNorwegian          EQU 0414h
  LangIDPolish             EQU 0415h
  LangIDPortuguese         EQU 0816h
  LangIDRussian            EQU 0419h
  LangIDSpanish            EQU 0C0Ah
  LangIDSwedish            EQU 041Dh
  LangIDTurkish            EQU 041Fh

  ;----------------------------------------------------------------------------
  ;Descriptor Types
  ;Put in High Byte of SRValue for GetDescriptor & SetDescriptor Requests
  ;  (Descriptor Index in low byte)
  ;Returned in DescrType of Descriptor Structures
  ;----------------------------------------------------------------------------
  ;----------------------------------------------------------------------------
  ;USB Descriptor Types
  ;----------------------------------------------------------------------------
  DescrTypeDevice    EQU 01h ;Device
  DescrTypeConfig    EQU 02h ;Configuration
  DescrTypeString    EQU 03h ;String
  DescrTypeInterface EQU 04h ;Interface
  DescrTypeEndPoint  EQU 05h ;EndPoint
  DescrTypeDvcQual   EQU 06h ;Device Qualifier
  DescrTypeOtherSpd  EQU 07h ;Other Speed Configuration
  DescrTypeIntfPower EQU 08h ;Interface Power
  DescrTypeOnTheGo   EQU 09h ;On-the-Go
  DescrTypeDebug     EQU 0Ah ;Debug
  DescrTypeIntfAssoc EQU 0Bh ;Interface Association
  ;Types 12 - 17 (0Ch - 11h) are added for Wireless USB
  DescrTypeWSecurity EQU 0Ch ;Wireless USB Security
  DescrTypeWKey      EQU 0Dh ;Wireless USB Key
  DescrTypeWEncrType EQU 0Eh ;Wireless USB Encryption Type
  DescrTypeWBOS      EQU 0Fh ;Wireless USB Binary-device Object Store
  DescrTypeWDvcCap   EQU 10h ;Wireless USB Device Capability
  DescrTypeWEndPtCmp EQU 11h ;Wireless USB Endpoint Companion
  ;HID Class-Specific Descriptor Types
  DescrTypeHID         EQU 21h ;Human Interface Device
  DescrTypeHIDReport   EQU 22h ;Report (from HID)
  DescrTypeHIDPhysical EQU 23h ;Physical Descriptor (from HID)

  ;----------------------------------------------------------------------------
  ;General USB-Defined Device and Interface Classes, SubClasses, and Protocols
  ;These are returned in the Device and Interface Descriptors
  ;----------------------------------------------------------------------------
  DvcClassHub  EQU 09h ;Device = Hub
  IntfClassHub EQU 09h ;Interface = Hub
  IntfClassHID EQU 03h ;Interface = Human Interface Device

  ;----------------------------------------------------------------------------
  ;PCI Class/SubClass/ProgrammingInterface Codes
  ;These are the same codes used by Plug-and-Play BIOS's
  ;----------------------------------------------------------------------------
  PCIClsReserved       EQU 00h
  PCIClsMassStorage    EQU 01h ;Mass Storage
    PCISClsSCSI        EQU 00h
    PCISClsIDE         EQU 01h
    PCISClsFloppy      EQU 02h ;  NEC 765-compatible
    PCISClsIPI         EQU 03h
    PCISClsRAID        EQU 04h
    PCISClsMSOther     EQU 80h
  PCIClsNIC            EQU 02h ;Network Interface Controller
    PCISClsEthernet    EQU 00h
    PCISClsTokenRing   EQU 01h
    PCISClsFDDI        EQU 02h
    PCISClsATM         EQU 03h
    PCISClsNICOther    EQU 80h
  PCIClsDisplay        EQU 03h ;Video Display
    PCISClsVGA         EQU 00h
      PCIPIntfVGA      EQU 00h ;  VGA registers
      PCIPIntf8514A    EQU 01h ;  8514/A-compatible registers
    PCISClsSVGA        EQU 01h ;  SuperVGA
    PCISClsXGA         EQU 02h
    PCISClsDispOther   EQU 80h
  PCIClsMultiMedia     EQU 04h ;Multi-Media
    PCISClsVideo       EQU 00h
    PCISClsAudio       EQU 01h
    PCISClsMMOther     EQU 80h
  PCIClsMemory         EQU 05h ;Memory
    PCISClsRAM         EQU 00h
    PCISClsFlashMem    EQU 01h
    PCISClsMemOther    EQU 80h
  PCIClsBridgeCtrlr    EQU 06h ;Bridge Controller
    PCISClsHostProc    EQU 00h ;  Host Processor
    PCISClsISA         EQU 01h
    PCISClsEISA        EQU 02h
    PCISClsMCA         EQU 03h ;  MicroChannel
    PCISClsPCI         EQU 04h
    PCISClsPCMCIA      EQU 05h
    PCISClsNuBus       EQU 06h
    PCISClsCardBus     EQU 07h
    PCISClsBridgeOther EQU 80h
  PCIClsComm           EQU 07h ;Communications Device
    PCISClsRS232       EQU 00h ;  XT-compatible RS-232 Serial Port
    PCISClsCentronics  EQU 01h ;  AT-compatible Centronics Parallel Port
    PCISClsCommOther   EQU 80h
  PCIClsSysPeripheral  EQU 08h ;System Peripherals
    PCISClsPIC         EQU 00h ;  8259-compatible Programmable Interrupt Controller
    PCISClsDMA         EQU 01h ;  8237-compatible Direct Memory Access Controller
    PCISClsSysTimer    EQU 02h ;  8254-compatible System Timer
    PCISClsRTC         EQU 03h ;  Real-Time Clock
    PCISClsPeriphOther EQU 80h
  PCIClsInputDvc       EQU 09h ;Input Device
    PCISClsKeyboard    EQU 00h
    PCISClsDigitizer   EQU 01h ;  Digitizer/Pen
    PCISClsMouse       EQU 02h
    PCISClsInputOther  EQU 80h
  PCIClsDockingStn     EQU 0Ah ;Docking Station
    PCISClsDockingStn  EQU 00h ;  Generic Docking Station
    PCISClsDOckOther   EQU 80h
  PCIClsCPU            EQU 0Bh ;CPU
    PCISCls386         EQU 00h
    PCISCls486         EQU 01h
    PCISClsPentium     EQU 02h
    PCISClsPentiumPro  EQU 03h ;  Pentium-Pro (P6)
    PCISClsDECAlpha    EQU 10h
    PCISClsCoProcessor EQU 40h
    PCISClsCPUOther    EQU 80h
  PCIClsSerialBus      EQU 0Ch ;Serial Bus controller
    PCISClsFireWire    EQU 00h ;  Firewire (IEEE 1394)
    PCISClsAccessBus   EQU 01h ;  ACCESS.bus
    PCISClsSSA         EQU 02h
    PCISClsUSB         EQU 03h ;  Universal Serial Bus
      PCIPIntfUHCI     EQU 00h ;    Universal Host Controller Interface
      PCIPIntfOHCI     EQU 10h ;    Open Host Controller Interface
      PCIPIntfEHCI     EQU 20h ;    Enhanced Host Controller Interface (USB 2.0)
    PCISClsFiberChan   EQU 04h ;  Fiber Channel
    PCISClsSBOther     EQU 80h


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;STRUCTURES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;==============================================================================
;TSR Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;This is a Structure to use at the beginning of Interrupt Routines in
  ;  TSR's.  Using this header, along with the appropriate code,
  ;  will allow the installation and removal of TSR's (actually,
  ;  the redirected interrupt vectors of a TSR) in any order.
  ;Note that the real Interrupt code MUST IMMEDIATELY follow this Header!!
  ;----------------------------------------------------------------------------
  IntHdr STRUC
    HdwreRst  DB      0CBh ;Hardware Reset Routine (CBh = RETF)
    CodeJmp   DW    010EBh ;Jump to real Interrupt Handler (JMP ENDS)
      iHPFS  EQU    0EA90h ;iHPFS Unused Entry
    OldVector DD        ?  ;Old interrupt Vector
    Signature DW    0424Bh ;Signature for this type of Interrupt routine
    EOIFlag   DB        0  ;=80h if we issue End-of-Interrupt, else 0
    HdwreJmp  DW    0F4EBh ;Jump to Hardware Reset Routine (JMP HdwreRst)
    FutureUse DB 7 DUP (0) ;Reserved for future use
   ENDS
  IntOfst EQU OFFSET CodeJmp ;Offset from beginning of our Structure


;==============================================================================
;DOS Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Program Segment Prefix
  ;----------------------------------------------------------------------------
  PSPStruc      STRUC
    PSPDOSExit     DW       20CDh ;Int 20h Call
    PSPNextSegment DW          ?  ;Segment of First Byte of Memory beyond Program
    PSPCPMCall5    DB   6 DUP (?) ;CPM Far Call 5
    PSPInt22Addr   DD          ?  ;Stored Int 22h (Program Termination) Handler
    PSPInt23Addr   DD          ?  ;Stored Int 23h (Ctrl-C) Handler
    PSPInt24Addr   DD          ?  ;Stored Int 24h (Critical Error) Handler
    PSPParentPSP   DW          ?  ;Segment of Parent PSP
    PSPJFT         DB JFTEntries DUP (?) ;Job File Table (20 File Handles)
    PSPEnvirSeg    DW          ?  ;Environment Segment for PSP
    PSPSSSPOnEntry DD          ?  ;Processes SS:SP on Entry to last Int 21h Call
    PSPJFTSize     DW JFTEntries  ;Number of entries in JFT (default = 20)
    PSPJFTPointer  DD          ?  ;Pointer to JFT (Default = PSP:0018h)
    PSPPreviousPSP DD          ?  ;Pointer to previous PSP (Default = FFFF:FFFF)
    PSPFiller1     DB  18 DUP (?) ;Misc stuff used by SHARE, Windows, etc.
                                  ;Memory Below here available to TSR!
    PSPFiller2     DB   2 DUP (?) ;Unused in DOS <= 6.00
    PSPInt21       DW       21CDh ;Int 21h Call
    PSPRETF        DB        0CBh ;RETF Call
    PSPFiller3     DB   9 DUP (?) ;Can be used to make Extended FCB from FCB1
    PSPFCB1        DB  16 DUP (?) ;First File Control Block
    PSPFCB2        DB  16 DUP (?) ;Second File Control Block
    PSPFiller4     DB   4 DUP (?) ;Unused
    PSPCmdLineLen  DB          ?  ;Command Line Length & DTA
    PSPCmdLine     DB 127 DUP (?) ;Command Line String
   ENDS
  PSPStrucSize EQU (TYPE PSPStruc) ;Should be 256 bytes

  ;----------------------------------------------------------------------------
  ;Memory Control Block
  ;----------------------------------------------------------------------------
  MCBStruc STRUC
    MCBID              DB        ?  ;Memory Control Block ID
      MCBIDValid      EQU       'M' ;Memory Block is Valid
      MCBIDLastInList EQU       'Z' ;Memory Block is Last in List
    MCBOwnerID         DW        ?  ;PSP Segment of Owner
                                    ;   0 = Owns Self
                                    ;   6 = DR-DOS XMS UMB
                                    ;   7 = DR-DOS Excluded Upper Memory
                                    ;   8 = Belongs to DOS
                                    ;FFFx = 386Max
    MCBSize            DW        ?  ;Size in Paragraphs
    MCBFiller          DB 3 DUP (?) ;Filler (used by some DOS incarnations)
    MCBOwnerName       DB 8 DUP (?) ;Owner Name (ASCIIZ if < 8 characters)
   ENDS
  MCBStrucSize EQU (TYPE MCBStruc) ;Should be 16 bytes (one paragraph)

  ;----------------------------------------------------------------------------
  ;Structure needed to Initialize DOS EXEC Function
  ;----------------------------------------------------------------------------
  ParamBlockStruc STRUC
    PBEnvirSegment   DW ? ;Environment Segment to use (0 = Copy Callers Segment)
    PBCmdTailPtr     DD ? ;Pointer to Command Tail
    PBFCB1Offset     DD ? ;Pointer to File Control Block #1
    PBFCB2Offset     DD ? ;Pointer to File Control Block #2
    PBSSSPOnReturn   DD ? ;Holds Childs Initial SS:SP on Return (if AL = 01)
    PBCSIPOnReturn   DD ? ;Holds Entry Point (CS:IP) on Return (if AL = 01)
   ENDS
  ParamBlockSize EQU (TYPE ParamBlockStruc) ;Size of EXEC Parameter Block

  ;----------------------------------------------------------------------------
  ;DTA (Disk Transfer Area) after Find First Matching File (INT 21h, Func 4Eh)
  ;The first several bytes of the DTA are DOS version specific, and
  ;  we don't care about that data anyway.  We only care about the data
  ;  that is documented and the same across all versions of DOS.
  ;----------------------------------------------------------------------------
  FindFirstStruc   STRUC            ;Find First Matching File
    FFVerSpecific     DB 21 DUP (0) ;DOS Version-specific Data
    FFAttribs         DB         ?  ;File Attributes
      FAttrReadOnly  EQU        01h ;Read-Only
      FAttrHidden    EQU        02h ;Hidden
      FAttrSystem    EQU        04h ;System
      FAttrVolume    EQU        08h ;Volume Label
      ;Bit 3 = Execute-only (Novell Netware)
      FAttrDirectory EQU        10h ;Directory
      FAttrArchive   EQU        20h ;Archive
      FAttrUnused    EQU        40h ;Unused
                                    ;DOS 3+ returns this bit set if file
                                    ;  is actually a character device
                                    ;DOS Window underneath Windows XP doesn't
      ;Bit 7 = Delete Pending (OpenDOS, NovellDOS)
      ;      = Shareable (Novell Netware)
   FFTime            DW         ?  ;File Creation Time
    FFDate            DW         ?  ;File Creation Date
    FFSize            DD         ?  ;File Size
    FFName            DB 13 DUP (?) ;ASCIIZ File Name & Extension
   ENDS

   FAttrToUse EQU FAttrHidden+FAttrSystem
     ;Attributes to use in DOS's Find First Matching File Function
     ;DOS ignores the Read-Only and and Archive bits, so they don't matter


;==============================================================================
;Program-Specific Structures
;==============================================================================

  ;----------------------------------------------------------------------------
  ;This is the format for a request sent to Int 14 to Send/Receive Data.
  ;It contains the type of request, etc.
  ;This is the structure used by other USB-related programs
  ;  (Device/Interface Drivers, Support/Control Programs) to communicate
  ;  with the Host Driver(s).
  ;
  ;A call will immediately return:
  ;  CF = Set on Error, AX = Error Code, BX = CX = DX = 0
  ;  CF = Clear if OK, AX = 0, BX, CX, DX Depend on exact Call Type
  ;NOTE that his ALWAYS changes AX, BX, CX, and DX!
  ;  NEVER assume they will be preserved across the Call!
  ;If the call does not require scheduling on the USB Bus, the call is done.
  ;If the call does require scheduling, the CallBack Address and User Packet ID
  ;  contained in the structure will be used to inform that it is complete.
  ;  AX again contains Error Code (0 for No Error), BX = User Packet ID,
  ;  CX & DX vary by type of Request it was (usually, CX contains bytes Xfered)
  ;----------------------------------------------------------------------------
  Int14RequestStruc         STRUC      ;Structure for an Int 14 Request
    I14RRequestType            DB   ?  ;Type of Request (High Nibble = Class)
      I14RRTHostClass         EQU  00h ;Host/System/OS Class
        I14RRTGetHostSWInfo   EQU  01h ;Get Host Software Info
        I14RRTGetHostHWInfo   EQU  02h ;Get Host Hardware Info
        I14RRTGetHostVendInfo EQU  03h ;Get Host Vendor Info
        I14RRTGetHostStatus   EQU  04h ;Get Current Host Status
        I14RRTHostRun         EQU  08h ;Start/Run/Resume Host
        I14RRTHostStop        EQU  09h ;Stop Host
        I14RRTHostReset       EQU  0Ah ;Reset Host
        I14RRTHostSuspend     EQU  0Bh ;Global Suspend Host
        I14RRTHostResume      EQU  0Ch ;Force Global Resume on Host
      I14RRTTimingClass       EQU  10h ;Frame Timing Class
        I14RRTRegTmgOwner     EQU  11h ;Register as Timing Owner
        I14RRTUnRegTmgOwner   EQU  12h ;UnRegister as Timing Owner
        I14RRTIncTiming       EQU  13h ;Increment (Slow Down) Frame Timing
        I14RRTDecTiming       EQU  14h ;Decrement (Speed Up) Frame Timing
        I14RRTChangeTiming    EQU  15h ;Change Frame Timing (by Large Amount)
      I14RRTHubClass          EQU  20h ;Hub Class
        I14RRTGetDvcHubInfo   EQU  21h ;Get Hub Info for Device
        I14RRTNewDvcConn      EQU  24h ;Hub has Detected new Device
        I14RRTDvcDisc         EQU  25h ;Device has been Disconnected
        I14RRTSendHubChar     EQU  27h ;Send Hub Characteristics to Host
        I14RRTEnableHubPort   EQU  28h ;Enable Device given Hub & Port
        I14RRTDisableHubPort  EQU  29h ;Disable Device given Hub & Port
        I14RRTResetHubPort    EQU  2Ah ;Reset Device given Hub & Port
        I14RRTSuspendHubPort  EQU  2Bh ;Suspend Device given Hub & Port
        I14RRTResumeHubPort   EQU  2Ch ;Resume Device given Hub & Port
        I14RRTPwrOnHubPort    EQU  2Dh ;Power On Device given Hub & Port
        I14RRTPwrOffHubPort   EQU  2Eh ;Power Off Device given Hub & Port
        I14RRTPwrResetHubPort EQU  2Fh ;Power Reset Device given Hub & Port
      I14RRTTPowerClass       EQU  30h ;Power Class
        I14RRTGetDvcPowerInfo EQU  31h ;Get Power Info for Device
        I14RRTGetHubPowerDraw EQU  32h ;Get Power Draw for Hub
        I14RRTPwrOnDevice     EQU  3Dh ;Power On Device given Dvc Addr
        I14RRTPwrOffDevice    EQU  3Eh ;Power Off Device given Dvc Addr
        I14RRTPwrResetDevice  EQU  3Fh ;Power Reset Device given Dvc Addr
      I14RRTDeviceClass       EQU  40h ;Device Class
        I14RRTGetDvcClassInfo EQU  41h ;Get Device Class Info
        I14RRTGetDvcVendInfo  EQU  42h ;Get Device Vendor Info
        I14RRTGetDvcStatus    EQU  43h ;Get Device Status
        I14RRTEnableDevice    EQU  48h ;Enable/Resume Device given Dvc Addr
        I14RRTDisableDevice   EQU  49h ;Disable Device given Dvc Addr
        I14RRTResetDevice     EQU  4Ah ;Reset Device given Dvc Addr
        I14RRTSuspendDevice   EQU  4Bh ;Suspend Device given Dvc Addr
        I14RRTResumeDevice    EQU  4Ch ;Resume Device given Dvc Addr
      I14RRTConfigClass       EQU  50h ;Configuration Class
        I14RRTConfigingIntf   EQU  51h ;Driver is Configuring an Interface
        I14RRTConfigIntfDone  EQU  52h ;Interface Configuration is Complete
        I14RRTSetNewConfig    EQU  58h ;Set/Change Device Config Value
      I14RRTInterfaceClass    EQU  60h ;Interface Class
        I14RRTFindRegIntf     EQU  62h ;Look for Registered Interface
        I14RRTFindUnRegIntf   EQU  63h ;Look for Unregistered Interface
        I14RRTRegIntfOwner    EQU  64h ;Register as Interface Owner
        I14RRTUnRegIntfOwner  EQU  65h ;Unregister as Interface Owner
        I14RRTIntfDontLook    EQU  68h ;Existing Interface Owner Don't Look
      I14RRTAltIntfClass      EQU  70h ;Alternate Interface Class
        I14RRTGetAltIntfInfo  EQU  71h ;Get Alternate Interface Info
      I14RRTEndPointClass     EQU  80h ;End Point Class
        I14RRTGetDataX        EQU  81h ;Get Current DataX Value
        I14RRTIncDataX        EQU  88h ;Increment/Toggle DataX Value
      I14RRTPacketClass       EQU  90h ;Packet Class
        I14RRTDoIsoch         EQU  94h ;Schedule Isochronous Transaction
        I14RRTDoInterruptPer  EQU  95h ;Schedule Periodic Interrupt
        I14RRTDoControl       EQU  96h ;Schedule Control/Setup Request
        I14RRTDoBulk          EQU  97h ;Schedule Bulk Transaction
        I14RRTDoInterrupt1T   EQU  98h ;Schedule One-Time Interrupt
        I14RRTCloseHandle     EQU  9Ch ;Close/Remove Scheduled Transaction
        I14RRTChangeIntPer    EQU  9Dh ;Change Periodicity of Interrupt
        I14RRTGetTransStatus  EQU  9Fh ;Get Status of Packet Transaction
      I14RRTMiscClass         EQU 0A0h ;Miscellaneous Class
        I14RRTLargeCallDone   EQU 0A1h ;Large (Complicated) Call Complete
        I14RRTBeepSpeaker     EQU 0AFh ;Beep the Speaker
      I14RRTInterHostClass    EQU 0E0h ;Inter-Host Communication Class
        I14RRTHostAdded       EQU 0E1h ;New Host Driver has been installed
        I14RRTHostDeleted     EQU 0E2h ;Host Driver is being removed from Mem
        I14RRTRegDvc0Host     EQU 0E3h ;Inform other Hosts of Device 0 Reg
        I14RRTUnRegDvc0Host   EQU 0E4h ;Inform other Hosts of Device 0 UnReg
        I14RRTCopyNDTable     EQU 0E5h ;Copy New Device Ownership Table
      I14RRTInternalClass     EQU 0F0h ;Host Internal/Troubleshooting Class
                                       ;Implementation-Specific
        I14RRTHostDebug       EQU 0FDh ;Put Host Into Debug Mode
        I14RRTHostSingleStep  EQU 0FEh ;Single-Step the Host (Debug Mode)
    I14RFlags                  DB   ?  ;Bit-level flags
      I14RFlagIn              EQU  01h ;In Direction
      I14RFlagLowSpeed        EQU  02h ;Low-Speed Device
      I14RFlagHiSpeed         EQU  04h ;High-Speed Device
      I14RFlagNoRetries       EQU  10h ;No Auto Retries for Control
      I14RFlagShortPktOK      EQU  20h ;No Retries for Short Packets
      I14RFlagSpecificFrame   EQU  40h ;Use Specific Frame Number
      I14RFlagAddrIsPhys      EQU  80h ;Data Address is Physical
    I14RHostIndex              DB   ?  ;Host Index
    I14RDeviceAddress          DB   ?  ;USB Device Address
      I14RHubAddress          EQU (OFFSET I14RDeviceAddress)
    I14REndPoint               DB   ?  ;EndPoint or Port or Alt Interface
      I14RHubPort             EQU (OFFSET I14REndPoint)
      I14RAltInterface        EQU (OFFSET I14REndPoint)
    I14RConfigValue            DB   ?  ;Configuration Value
      I14RCloseID             EQU (OFFSET I14RConfigValue)
      I14RDataX               EQU (OFFSET I14RConfigValue)
    I14RInterfaceNum           DB   ?  ;Interface Number
    I14RSearchIndex            DB   ?  ;Search Index
    I14RVendorID               DW   ?  ;Vendor ID
    I14RProductID              DW   ?  ;Product ID
    I14RDvcClass               DB   ?  ;Device Class
    I14RDvcSubClass            DB   ?  ;Device SubClass
    I14RDvcProtocol            DB   ?  ;Device Protocol
    I14RIntfClass              DB   ?  ;Interface Class
    I14RIntfSubClass           DB   ?  ;Interface SubClass
    I14RIntfProtocol           DB   ?  ;Interface Protocol
    I14RRequestHandle          DW   ?  ;Request Handle Number
    I14RPeriodicity            DW   ?  ;Interrupt Periodicity/Duration
      I14RBeepFrequency       EQU (OFFSET I14RPeriodicity)
    I14RTimeout                DW   ?  ;Transaction Time Out Value
    I14RDataAddress            DD   ?  ;Data Address
    I14RDataSize               DW   ?  ;Size of Data (Bytes)
    I14RCallBackAddr           DD   ?  ;Call Back Address (CS:IP format)
      I14RLargeCallRtnCode    EQU (OFFSET I14RCallBackAddr)
    I14RUserPktID              DW   ?  ;User Packet ID
    I14RSetupReqData           DQ   ?  ;Setup Request Data (8 bytes)
    I14RFrameTiming            DW   ?  ;Frame Timing Value (def = 12000)
      I14RFrameIndex          EQU (OFFSET I14RFrameTiming)
                                       ;Starting Frame of Isoch Schedule
    I14RIsochSchedAddr         DD   ?  ;Address of Isoch Schedule
    I14RFiller  DB (Int14RequestSize-$) DUP (0)

   ENDS

  ;----------------------------------------------------------------------------
  ;This contains data about all Device Drivers who have registered as
  ;  the Owner of Device Address 0 (newly Attached Devices).
  ;All entries in this table will be notified when a new Device is attached
  ;  that matches the Class/SubClass/Protocol the Driver Registered with.
  ;There is only one copy of the table based on this structure that all
  ;  Host Drivers share.
  ;----------------------------------------------------------------------------
  NewDvcNotifyStruc STRUC    ;Table of New Device Owners (to be notified when
                             ;  a new Device is attached)
    NDVendorID         DW  ? ;Vendor ID          |
    NDProductID        DW  ? ;Product ID         |
    NDDvcClass         DB  ? ;Device Class       |If these are filled in,
    NDDvcSubClass      DB  ? ;Device SubClass    |  the Call will only be made
    NDDvcProtocol      DB  ? ;Device Protocol    |  if the right kind of dvc
    NDIntfClass        DB  ? ;Interface Class    |  attached (not just any dvc)
    NDIntfSubClass     DB  ? ;Interface SubClass |-1 in these is a "don't care"
    NDIntfProtocol     DB  ? ;Interface Protocol |
    NDUserPktID        DW  ? ;User Pkt ID to have in BX during the Call
    NDCallBackAddr     DD  ? ;Address to Call when the Device is attached
                             ;0 in the Segment is an Empty Table Entry
   ENDS
  NDSize EQU (TYPE NewDvcNotifyStruc)


  ;============================================================================
  ;The following are internal structures used by our program to keep
  ;  track of things.  They are not directly seen by the outside world.
  ;============================================================================

  ;----------------------------------------------------------------------------
  ;Address Data is a small structure to store information about
  ;  devices that have been enumerated (given an address)
  ;This will be used to return information to a Device Driver requesting
  ;  information about which devices are installed
  ;----------------------------------------------------------------------------
  AddressData       STRUC     ;Basic data for enumerated devices
    ADFlags            DB  ?  ;Yes/No type flags
      ADFlagInUse     EQU 01h ;Address currently in use
      ADFlagLowSpeed  EQU 02h ;Device is Low Speed
      ADFlagHiSpeed   EQU 04h ;Device is High-Speed
      ADFlagSelfPwr   EQU 08h ;Device is Self-Powered
      ADFlagConfig0OK EQU 10h ;Configuration value of 0 is OK for this Device
                              ;  (Device does not comply with the specs)
      ADFlagHubPPP    EQU 40h ;Device is Per-Port-Powered Hub
    ADFlags2           DB  ?  ;Yes/No type flags #2
                              ;This is stored in the same order as the return
                              ;  values for I14RRTGetDvcStatus!
      ADFlagBadDvc    EQU 01h ;Device is Bad (did not enumerate properly)
      ADFlagRWkUpSupt EQU 02h ;Device supports Remote Wakeup
      ADFlagRWkUpOn   EQU 04h ;Remote Wakeup is Enabled
      ADFlagTestMode  EQU 08h ;Device currently in Test Mode
      ADFlagConfiging EQU 80h ;Device is currently being enumerated/configured
    ADUSBVersion       DB  ?  ;USB Version Number (bcd)
    ADConfigValue      DB  ?  ;Current Configuration Value
    ADNumConfigs       DB  ?  ;Number of Configs
    ADDvcClass         DB  ?  ;Device Class
    ADDvcSubClass      DB  ?  ;Device SubClass
    ADDvcProtocol      DB  ?  ;Device Protocol
    ADVendorID         DW  ?  ;Vendor ID
    ADProductID        DW  ?  ;Product ID
    ADBusPower         DB  ?  ;Bus Power Draw (2mA units)
    ADHubAddress       DB  ?  ;Address of Hub this device is attached to
    ADHubPort          DB  ?  ;Port off of Hub that this device is attached to
    ADNumPorts         DB  ?  ;Number of Ports (if Hub)
    ADFiller           DB  ?  ;To align data at even addresses
    ADMaxPktSizeEP0    DB  ?  ;Max Packet for EndPoint 0
    ADNewDeviceStage   DB  ?  ;New Device Stage
    ADConfigingIntf    DB  ?  ;An Interface on the Device is being configured
    ADNewDeviceError   DW  ?  ;New Device Error Code
   ENDS
  ADSize EQU (TYPE AddressData)

  ;----------------------------------------------------------------------------
  ;Interface Data is a small structure to store information about
  ;  Interfaces on devices
  ;A Device can have more than one Interface, though most Devices only have one.
  ;An Interface typically has several Alternate (Sub) Interfaces
  ;----------------------------------------------------------------------------
  InterfaceData      STRUC   ;Interface Data
    InFlags           DB  ?  ;Flags
      InFlagInUse    EQU 01h ;Entry in Use
    InFiller          DB  ?  ;To align at Even Addresses
    InDeviceAddress   DB  ?  ;Device Address this Interface is on
    InInterfaceNum    DB  ?  ;Interface Number
    InCallBackAddr    DD  ?  ;CS:IP address of FAR CALL to issue
                             ;  for Interface-Level Errors (Interface Owner)
    InUserPktID       DW  ?  ;User Packet ID
   ENDS
  InSize EQU (TYPE InterfaceData)

  ;----------------------------------------------------------------------------
  ;Alternate Interface Data is a small structure to store information about
  ;  Alternate (Sub) Interfaces for Interfaces
  ;An Interface can only be using one Alternate (Sub) Interface at a time
  ;----------------------------------------------------------------------------
  AltInterfaceData   STRUC   ;Alternate (Sub) Interface Table
    AIFlags           DB  ?  ;Flags
      AIFlagInUse    EQU 01h ;Entry in Use
      AIFlagSelected EQU 02h ;This Alternate Interface is the one being used
    AIAltIntfNum      DB  ?  ;Alternate Interface Number
    AIIntfClass       DB  ?  ;Interface Class
    AIIntfSubClass    DB  ?  ;Interface SubClass
    AIIntfProtocol    DB  ?  ;Interface Protocol
    AIFiller          DB  ?  ;To align at Even Address
    AIInterfaceOffset DW  ?  ;Offset of Interface Table Entry
   ENDS
  AISize EQU (TYPE AltInterfaceData)

  ;----------------------------------------------------------------------------
  ;EndPoint Data is a small structure to store information about
  ;  Control & Bulk EndPoints (other than EndPoint 0, which is stored
  ;  directly in the Device Address Table).  We actually do not store
  ;  complete information about all EndPoints, but rather simply store
  ;  the maximum data sizes for certain kinds of EndPoints.  We do not
  ;  store information about the type of EndPoint (Control, Bulk, Isoch,
  ;  or Int), or about the direct relationships between EndPoints and
  ;  Alternate Interfaces.
  ;We do not need to keep track of the sizes of Isochronous End Points,
  ;  since a single Isochronous Packet Request cannot be subdivided by
  ;  us.  The Device Driver issuing the Isochronous Packet request is
  ;  responsible for setting the appropriate data size that the EndPoint can
  ;  process correctly.
  ;The other three EndPoint types (Control, Bulk, & Interrupt) may
  ;  need to be subdivided by us into smaller packets, which we do
  ;  automatically.
  ;We associate Max EndPoint Sizes with a Device rather than with an
  ;  Interface or an Alternate Interface.  In reality, an EndPoint
  ;  "belongs" to an Alternate Interface, but we assume that it doesn't
  ;  matter.  I have yet to see a Device where a particular Control or
  ;  Bulk EndPoint actually changes size between different Interfaces,
  ;  so we will assume for now that it never happens.  It would theoretically
  ;  be possible to do it, but I don't think any manufacturer would ever
  ;  actually do it (it would make the Device MUCH more difficult to
  ;  manufacture, for a multitiude of reasons).  If this ever becomes an
  ;  issue, we would need to modify this program so that EndPoints get
  ;  associated directly with Alternate Interfaces, rather than the indirect
  ;  association we have now.  Associating EndPoints with anything other
  ;  than Devices would lead to a larger EndPoint table (more memory),
  ;  and also lead to more complicated code.
  ;Our intent here is not to "monitor" a Device Driver to make sure it
  ;  follows all of the rules.  It is simply to facilitate getting transactions
  ;  scheduled onto the USB Bus.  If the Device Driver wants to do some
  ;  "illegal" or "unusual" things, we will let it.
  ;----------------------------------------------------------------------------
  EndPointData    STRUC     ;EndPoint Data (Control & Bulk EndPoints > 0)
    EnFlags          DB  ?  ;Flags
      EnFlagInUse   EQU 01h ;Table Entry in use
      EnFlagData1   EQU 02h ;Set Data1 on next packet (Bulk & Ctl)
    EnDeviceAddress  DB  ?  ;Device Address the EndPoint is on (2-127)
                            ;0 in the Device Address is an empty Table entry
    EnEndPointNum    DB  ?  ;EndPoint Number (1-15), with Direction
      EnEndPointIn  EQU 80h ;  Direction = In
    EnMaxPktSize     DB  ?  ;Max Packet Size
   ENDS
  EnSize EQU (TYPE EndPointData)

  ;----------------------------------------------------------------------------
  ;This temporarily stores data (Hub/Port) while a device is being Reset.
  ;A device loses all of its "brains" (its Address and Configuration values)
  ;  during a Reset.  So, after a Reset a Device is Enabled and has address 0.
  ;Because there can only be one Device with Address 0 on the Bus at a time,
  ;  we need to Queue the Resets and only allow one at a time to be
  ;  performed.  This Structure Queues the Resets.
  ;----------------------------------------------------------------------------
  ResetStruc        STRUC     ;Reset structure
    RsFlags            DB  ?  ;Flags
      RsFlagInUse     EQU 01h ;Table Entry in use
      RsFlagLowSpeed  EQU 02h ;Device is Low Speed
      RsFlagSetConfig EQU 08h ;Set Configuration Value after Reset
      RsFlagCfgRetry  EQU 10h ;Trying the Config the second time (Default Cfg)
    RsRetries          DB  ?  ;Retry Counter (= 0 if when retries are exhausted)
    RsDelayCounter     DB  ?  ;Retry delay Counter
    RsDeviceAddress    DB  ?  ;Address assigned to Device
    RsFiller           DB  ?  ;To align data at even addresses
    RsConfigValue      DB -1  ;Set Config Value to this (if Flag is set)
    RsHubAddress       DB  ?  ;Hub Address of Newly connected Device
    RsHubPort          DB  ?  ;Hub Port Number of newly connected Device
    RsCallBackAddr     DD  ?  ;Call Back Address
    RsUserPktID        DW  ?  ;User Packet ID
   ENDS
  RsSize EQU (TYPE ResetStruc)

  ;----------------------------------------------------------------------------
  ;This contains Data to keep track of several Int 08-based Delays at the
  ;  same time.
  ;Most of the time, we will use the USB bus itself for timing, because
  ;  we can get a 1ms resolution.  But, there are times when the USB Bus
  ;  is inactive or for some other reason unusable.
  ;Int 08 is always available, even though it does not have enough resolution
  ;  (55ms) to provide accurate timing.
  ;----------------------------------------------------------------------------
  Int08DelayStruc STRUC     ;Table of Int 08-based Delay Factors
    I8Flags          DB  ?  ;Flags
      I8FlagInUse   EQU 01h ;Entry is in use
    I8Delay          DB  ?  ;Countdown Delay Timer
    I8UserPktID      DW  ?  ;User Packet ID to return in BX
    I8CallBackAddr   DD  ?  ;Far Call Address to call at end of Delay
   ENDS
  I8Size EQU (TYPE Int08DelayStruc)

  ;----------------------------------------------------------------------------
  ;This contains Data to keep track of Timeouts for Bulk and Control
  ;  Transactions.
  ;----------------------------------------------------------------------------
  TransactionTimeoutStruc STRUC ;Table of Transaction Timeout Counters
    TTFlags          DB   ?  ;Flags
      TTFlagInUse   EQU  01h ;Entry is in use
      TTFlagOnHold  EQU  02h ;Entry is on Hold
      TTFlagSPktOK  EQU  10h ;No Retry if Short Packet is only Error
      TTFlagRetries EQU 0E0h ;Retry Counter Mask (bits 5-7, allows 8 total tries)
    TTCloseID        DB   ?  ;ID needed to Close Transaction prematurely
    TTDelayCounter   DW   ?  ;Delay Counter (in Timer Ticks)
    TTOrigDelay      DW   ?  ;Original Delay Counter (in Timer Ticks)
   ENDS
  TTSize EQU (TYPE TransactionTimeoutStruc)

  ;----------------------------------------------------------------------------
  ;This contains Data to keep track of returns from "Large" Calls.
  ;Typically, a Call to a Host (Run/Stop/Reset/Suspend/Resume) or a Hub
  ;  (Enable/Disable/Reset/Suspend/Resume) to control a Device will take
  ;  several milliseconds (or even several hundred milliseconds) to complete.
  ;This is particularly true of remote Hubs, who must do EVERYTHING by
  ;  sending transactions across the Bus.  In effect, a call to do
  ;  something to a Device attached to the Hub will in turn generate one
  ;  or more "sub-calls" which require scheduling on the Bus.
  ;Rather than simply assuming that the entire transaction was completed
  ;  successfully, and "guessing" at what point in time it may ACTUALLY
  ;  have been completed, we need to have a special process for Hub-related
  ;  (and other Complicated) calls.  That's what this Table is for.
  ;This Table stores the FarCall Addresses and UserPktID's for an entire
  ;  Large transaction.  The Host will issue a call to the Hub Driver
  ;  and include a Handle (a pointer to an entry in this Table).  The Hub
  ;  Driver will process the Request and keep track of each of the "sub-calls"
  ;  it may need to do to process the entire transaction.  After the Hub has
  ;  completed the entire Transaction, it will inform the Host Driver
  ;  that it is completed, and will include a Return Code and also a reference
  ;  to the Handle Number (Index into this Table).  The Host Driver will then
  ;  handle the Far Calls & other notifications for the entire Transaction.
  ;----------------------------------------------------------------------------
  LargeCallStruc     STRUC     ;Table for Large Call Requests
    LCFlags             DB  ?  ;Flags
      LCFlagInUse      EQU 01h ;This Entry is in use
      LCFlagHostCall   EQU 02h ;Call is a Host-Level Call
      LCFlagDeviceCall EQU 04h ;Call is a Device-Level Call
    LCFiller            DB  ?  ;To align things at even addresses
    LCUserPktID         DW  ?  ;User Packet ID to return in BX
    LCCallBackAddr      DD  ?  ;Far Call Address to call at end of Transaction
    LCOwnerCallAX       DW  ?  ;Value to put in AX for Owner Call when Done
    LCOwnerCallCX       DW  ?  ;Value to put in CX for Owner Call when Done
    LCOwnerCallDX       DW  ?  ;Value to put in DX for Owner Call when Done
   ENDS
  LCSize EQU (TYPE LargeCallStruc)


;==============================================================================
;UHCI-Defined Structures
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Frame List Entry is DWord containing a 32-bit physical address and some flags
  ;The Frame List Table must contain 1024 of these structures.  Each one of
  ;  the entries is the start of a Frame.  The UHCI Host updates the Frame Index
  ;  (the Index of the Entry in the Table) every millisecond (1000 times a
  ;  second).  To schedule something on a UHCI Host, you change the appropriate
  ;  Frame List Entry to point directly at a Transfer Descriptor, or indirectly
  ;  at a Transfer Descriptor via a Queue Head.  QH's and TD's can in turn
  ;  point at additional QH's and TD's, so that a lot of things can end up
  ;  getting done in one Frame.  But, this Frame List is where it all begins --
  ;  this is the what the UHCI Host Looks at to tell it what to do.
  ;An unusual thing about the Frame List is that it MUST start on a 4K Page
  ;  Boundary in Memory.  DOS does not align things to 4K Page boundaries,
  ;  but rather aligns them to 16 byte Paragraph boundaries.  With real-mode
  ;  DOS, you have absolutely no control over where the Frame List table
  ;  will actually get installed in memory relative to a 4K Page Boundary.
  ;On the surface, that could be a problem.  Well, not actually a problem per se,
  ;  but it means we can potentially have 4K of memory being completely wasted.
  ;  In order to align the Frame List Table on a 4K Boundary, we actually need
  ;  to "reserve" twice as much memory as we actually need for the Frame List.
  ;  That is, we need to "reserve" 8K of memory for the Frame List.  Only after
  ;  we are loaded into memory can we determine exactly where a 4K page boundary
  ;  actually is in that 8K of "reserved" space, and put the start of the Frame
  ;  List there.  Potentially, the 4K of "extra" space in that 8K is wasted.
  ;  In addition, you don't know ahead of time whether the majority of the
  ;  extra "space" will be in front of the Frame List or behind it.
  ;What we do is use the extra 4K of space for the Stack.  Depending on exactly
  ;  where in Memory we get installed, we can end up with one really big stack,
  ;  or two "half-sized" stacks, or one relatively large stack and one
  ;  relatively small stack.  This program is set up to handle all of the
  ;  different scenarios appropriately.
  ;This Structure is defined by the UHCI Spec.
  ;----------------------------------------------------------------------------
  FrameList     STRUC             ;Header for Frame List Entries
    FLLinkPointer  DD          ?  ;Frame List Link Pointer
     FLAddrMask   EQU 0FFFF_FFF0h ;Physical Address of TD/QH
      ;Bits 03:02 = Reserved (0)
      FLQHSelect  EQU  0000_0002h ;1 = Points at QH, 0 = Points at TD
      FLTerminate EQU  0000_0001h ;1 = Ptr is invalid, 0 = Ptr is valid
   ENDS
  FLSize  EQU TYPE (FrameList)

  ;----------------------------------------------------------------------------
  ;Transfer Descriptor is a large structure, containing many addresses & flags
  ;Start of each TD MUST BE PARAGRAPH-ALIGNED!!!!
  ;This first Paragraph of this Structure is defined by the UHCI Spec
  ;The second Paragrah is defined by USBUHCI (Me)
  ;----------------------------------------------------------------------------
  TransferDescriptor    STRUC             ;Header for Transfer Descriptors
    TDLinkPointer          DD          ?  ;Transfer Descriptor Link Pointer
      TDAddrMask          EQU 0FFFF_FFF0h ;Physical Address of next TD/QH
      ;Bit     03 = Reserved (0)
      TDDepthFirst        EQU  0000_0004h ;1 = Depth First , 0 = Breadth first
      TDQHSelect          EQU  0000_0002h ;1 = Points at QH, 0 = Points at TD
      TDTerminate         EQU  0000_0001h ;1 = Pointer is invalid, 0 = valid
    TDControlStatus        DD          ?  ;TD Control and Status
      ;Bits 31:30 = Reserved
      TDShortPacketDetect EQU  2000_0000h ;1 = Enabled, 0 = Disabled
      ;Bits 28:27 = Error Counter (Counts down)
        TDErrorCount3     EQU  1800_0000h ;Error Counter = 3
        TDErrorCount2     EQU  1000_0000h ;Error Counter = 2
        TDErrorCount1     EQU  0800_0000h ;Error Counter = 1
        TDErrorCountSft   EQU         27  ;Bits to Shift ErrorCount
      TDLowSpeedDevice    EQU  0400_0000h ;1 = Low Speed, 0 = Full Speed
      TDIsochSelect       EQU  0200_0000h ;1 = Isoch TD, 0 = Non-Isoch TD
      TDIntOnComplete     EQU  0100_0000h ;1 = Issue IOC at end of TD Frame
      ;Bits 23:16 = Status Byte
        TDActive          EQU  0080_0000h ;1 = TD is still Active
        TDStalled         EQU  0040_0000h ;1 = TD is Stalled
        TDDataBuffErr     EQU  0020_0000h ;1 = Data Buffer Error
        TDBabbleDetected  EQU  0010_0000h ;1 = Babble Detected
        TDNAKReceived     EQU  0008_0000h ;1 = NAK Received
        TDCRCTOReceived   EQU  0004_0000h ;1 = CRC/TimeOut Error Received
        TDBitStuffError   EQU  0002_0000h ;1 = Rx Data has > 6 ones in a row
        TDAllErrorsMask   EQU  (TDStalled+TDDataBuffErr+TDBabbleDetected+TDNAKReceived+TDCRCTOReceived+TDBitStuffError)
                                          ;All errors in one bit mask!
      ;Bit  16 = Reserved
        ;TDStatusByteSft   EQU         27  ;Bits to Shift StatusByte
      ;Bits 15:11 = Reserved
      TDActualLengthMask  EQU  0000_07FFh ;Actual Length is stored in bits 10:0
                                          ;  (Max size = 1023 bytes)
        TDActualLengthNUL EQU  0000_07FFh ;Actual Length for a NUL Packet
    TDToken                DD          ?  ;TD Token (Packet Header)
      TDMaxLengthMask     EQU 0FFE0_0000h ;Maximum bytes to transfer
                                          ;  n-1, max = 1023 = 3FEh)
                                          ;  7FFh = Null Packet
        TDMaxLengthSft    EQU         21  ;Bits to Shift TDMaxLength
        TDMaxLengthNUL    EQU 0FFE0_0000h ;TD Token to send for Null Packet
      ;Bit 20 = Reserved
      TDData1             EQU  0008_0000h ;0 = Data0, 1 = Data1
      TDEndPointMask      EQU  0007_8000h ;TDEndPoint in bits 18:15 (0-15)
        TDEndPointSft     EQU         15  ;Bits to shift TDEndPoint
      TDDeviceAddrMask    EQU  0000_7F00h ;Device Address in bits 14:8 (0-127)
        TDDeviceAddrSft   EQU          8  ;Bits to shift TDDeviceAddr
      TDPacketIDMask      EQU  0000_00FFh ;Packet ID in bits 7:0
        TDPacketIn        EQU         69h ;Token for IN Packet
        TDPacketOut       EQU        0E1h ;Token for OUT Packet
        TDPacketSetup     EQU         2Dh ;Token for SETUP Packet
    TDBuffPointer          DD          ?  ;TD Data Buffer Pointer
                                          ;  Physical Address (not Seg:Off)
  ;----------------------------------------------------------------------------
  ;The above data is "standard" (required) for a Transfer Descriptor
  ;The below data is "local" (for our own internal use)
  ;Each TD must be paragraph aligned, so we are allowed 16 bytes of Local Data
  ;  (or a multiple of 16 bytes)
  ;In order to try and preserve memory, we will be limiting the number of TD's
  ;TD's will be reused for a "transaction" (an entire series of packets
  ;  to the same device/endpoint until all data has been transferred)
  ;Reusing TD's requires more local data per TD than otherwise would be
  ;  required, but decreases the total number of TD's
  ;If we required far less (or far more) than 16 bytes of local data, it would
  ;  probably be better to set up a separate structure and "link" it indirectly
  ;  to the real TD.  Because we currently require approximately 16 bytes of
  ;  local data, we'll just leave it all as one big structure (this makes
  ;  finding things much less convoluted).
  ;----------------------------------------------------------------------------
    TDFlags                   DB   ?  ;Local Flags for USBUHCI purposes
      ;Notes: The following must be IN THE SAME ORDER as PhysAddrClassTD!!
      TDTypeMask             EQU  0Fh ;Type of TD (4 bits)
        TDTypeAvailable      EQU  00h ;Available (Invalid/Empty TD)
        TDTypeReserved       EQU  01h ;Reserved, but not in use yet
        TDTypeIsoch          EQU  02h ;Isochronous
        TDTypeInterrupt1Time EQU  03h ;1-Time Interrupt
        TDTypeInterruptPer   EQU  04h ;Periodic Interrupt
        TDTypeControlSetup   EQU  05h ;Control Setup Packet
        TDTypeControlData    EQU  06h ;Control Data Packet
        TDTypeControlStatus  EQU  07h ;Control Status packet
        TDTypeBulk           EQU  08h ;Bulk
      TDFlagIn               EQU  10h ;Direction = IN
      TDFlagSpecificFrame    EQU  20h ;Use Specific Frame (don't "slide")
                                      ;  for Periodic Interrupt
      TDFlagOnHold           EQU  40h ;TD Currently On Hold, waiting for
                                      ;  another Control TD to the same
                                      ;  EndPoint (EP0) to complete
                                      ;If this bit is set, the TD is completely
                                      ;  set up, except for the TDActive bit.
                                      ;When the other TD is completed,
                                      ;  we simply unset this bit and set
                                      ;  the TDActive bit.
      TDFlagLastBulkTD       EQU  80h ;Last TD in Bulk Queue (Transaction is
                                      ;  complete when this one is done)
    TDTimeoutIndex            DB   ?  ;TimeOut Table Entry to use
                                      ;  Used only in Bulk and Control
      TDIsochSequence        EQU (OFFSET TDTimeoutIndex)
                                      ;Isochronous Packet Sequence Number
      TDCloseID              EQU (OFFSET TDTimeoutIndex)
                                      ;One Time Interrupt Closure ID
    TDDataAddress             DD   ?  ;If Control Pkt, is "Real" Data Address
      TDPeriodicity          EQU (OFFSET TDDataAddress[0])
      TDLastFrameUsed        EQU (OFFSET TDDataAddress[2])
                                      ;If Interrupt or Isoch,
                                      ;  Low Word is Periodicity
                                      ;If Isoch or Periodic Int w/ Specific
                                      ;  Frame, High Word is Frame Number used
                                      ;  last time
    TDBytesToXfer             DW   ?  ;Number of total bytes to transfer
                                      ;  in this transaction (0-65535)
                                      ;When 0, we're done!
    TDBytesXfered             DW   ?  ;Running Count of Bytes transferred
                                      ;  so far in this transaction (0-65535)
      TDIsochHandle          EQU (OFFSET TDBytesXfered)
      TDBulkQHOffset         EQU (OFFSET TDBytesXfered)
      TDIntQHOffset          EQU (OFFSET TDBytesXfered)
                                      ;Isoch cannot span multiple Frames w/
                                      ;  same Packet (each packet must be
                                      ;  <= max packet Size), so don't need
                                      ;  to keep track of Bytes Xfered
                                      ;Also, on Isoch, we need a single
                                      ;  Handle Number to refer to all Packets
                                      ;So, for Isoch Packets, this will store
                                      ;  the Handle Number (the First TD
                                      ;  of the Isoch Series)
                                      ;If Bulk, is Memory Offset of Bulk QH
                                      ;If Periodic Int, Memory Offset of Int QH
                                      ;  0 if no QH needed (single TD)
    TDCallBackAddr            DD   ?  ;Address to "Call" on IOC
                                      ;  = 0 if No Call Back required
                                      ;Segment:Offset!!
    TDUserPktID               DW   ?  ;Packet ID designated by the User
                                      ;Returned as part of IOC to the user
   ENDS
  TDSize  EQU TYPE (TransferDescriptor)

  ;----------------------------------------------------------------------------
  ;Queue Head is a small structure, containing two 32-bit addresses & some flags
  ;Start of each QH MUST BE PARAGRAPH-ALIGNED!!!!
  ;This Structure is defined by the UHCI Spec
  ;----------------------------------------------------------------------------
  QueueHead        STRUC             ;Header for Control & Bulk Transfers
    QHLinkPointer     DD          ?  ;Queue Head Link Pointer
      QHAddrMask     EQU 0FFFF_FFF0h ;Physical Address of next TD/QH
      ;Bits 03:02 = Reserved (0)
      QHQHSelect     EQU  0000_0002h ;1 = Points at QH, 0= Points at TD
      QHTerminate    EQU  0000_0001h ;1 = Ptr invalid (Last QH), 0 = valid
    QHElementPointer  DD          ?  ;Queue Element Link Pointer
      ;Bits 31:04 = Address of next Vertical (Depth) Object to Process
      ;        03 = Reserved (0)
      ;        02 = Reserved
      ;Last two bits are same as QHLinkPointer (QHQHSelect & QHTerminate)
  ;----------------------------------------------------------------------------
  ;The 8 bytes of data above are defined by the UHCI spec.
  ;A QH must be paragraph aligned, but the UHCI spec only declares a use
  ;  for the first 8 bytes of the paragraph.  So, we have 8 bytes worth
  ;  of space in each QH that we can use for our own purposes.
  ;The 8 bytes of data below are defined by this program (USBUHCI), and are
  ;  used to keep track of things as a Bulk/Int Transaction is being processed.
  ;----------------------------------------------------------------------------
    QHFlags             DB          ?  ;Bit-level Flags
      QHFlagInUse      EQU         01h ;QH being used (Bulk/Int QH)
      QHFlagLastTDSent EQU         02h ;Last Bulk TD has been sent
    QHBulkTimeoutIndex  DB          ?  ;Timeout Counter Table Index (Bulk)
                                       ;  0  = unused
                                       ;  -1 = None/Reserved
                                       ;  1 - ?? = Actual Timeout Table Index
      QHIntNumTDs      EQU (OFFSET QHBulkTimeoutIndex)
                                       ;Number of TD's in Int Queue
    QHBulkBytesLeft     DW          ?  ;Bytes left to complete Bulk Transaction
      QHIntPeriodicity EQU (OFFSET QHBulkBytesLeft)
                                       ;Periodicity of Int Queue
    QHBulkNextAddress   DD          ?  ;Physical Address of next TD Data (Bulk)
      QHIntTotalBits   EQU (OFFSET QHBulkNextAddress)
                                       ;Total full-speed bit times in Int Queue
      QHIntTDOffset    EQU ((OFFSET QHBulkNextAddress)+2)
                                       ;Offset of first TD in Queue
   ENDS
  QHSize  EQU TYPE (QueueHead)


;==============================================================================
;USB-Defined Structures
;These are needed by all Drivers, not just UHCI Host Drivers
;==============================================================================

  ;--------------------------------------------------------------------------
  ;Device Request is a structure containing data required by a USB Setup Packet
  ;  It's always 8 bytes long, containing data relevant to EVERY USB device
  ;  ALL devices, even if not configured or addressed, must respond to
  ;    certain kinds of Setup Packets to address 0 (the default address)
  ;This base Structure is defined by the USB Organization
  ;We add an extra word at the end so we can internally keep track of things!
  ;--------------------------------------------------------------------------
  SetupRequest           STRUC     ;Structure for a Standard Setup Pkt
    SRRequestType           DB  ?  ;Request Type
      SRRTOut              EQU 00h ;0=Out (Host to Device)
      SRRTIn               EQU 80h ;1=In (Device to Host)
      SRRTTypeMask         EQU 60h ;Mask for Type
        SRRTTypeStandard   EQU 00h ;Type 0 = Standard
        SRRTTypeClass      EQU 20h ;Type 1 = Class
        SRRTTypeVendor     EQU 40h ;Type 2 = Vendor
                                   ;Type 3 = Reserved
      SRRTRecipientMask    EQU 1Fh ;Mask for Recipient Type
        SRRTRecipDevice    EQU 00h ;Recipient Type 0 = Device
        SRRTRecipInterface EQU 01h ;Recipient Type 1 = Interface
        SRRTRecipEndPoint  EQU 02h ;Recipient Type 2 = EndPoint
        SRRTRecipOther     EQU 03h ;Recipient Type 3 = Other
                                   ;Types 4-31 = Reserved
    SRRequest               DB  ?  ;Specific Request
      SRRQGetStatus        EQU  0  ;Request  0 = Get Status
      SRRQClearFeature     EQU  1  ;Request  1 = Clear Feature
      SRRQGetState         EQU  2  ;Request  2 = Get State
      SRRQSetFeature       EQU  3  ;Request  3 = Set Feature
                                   ;Request  4 = Reserved
      SRRQSetAddress       EQU  5  ;Request  5 = Set Address
      SRRQGetDescriptor    EQU  6  ;Request  6 = Get Descriptor
      SRRQSetDescriptor    EQU  7  ;Request  7 = Set Descriptor
      SRRQGetConfig        EQU  8  ;Request  8 = Get Configuration
      SRRQSetConfig        EQU  9  ;Request  9 = Set Configuration
      SRRQGetAltInterface  EQU 10  ;Request 10 = Get Alternate Interface
      SRRQSetAltInterface  EQU 11  ;Request 11 = Set Alternate Interface
      SRRQSynchFrame       EQU 12  ;Request 12 = Synch Frame
    SRValue                 DW  ?  ;Value depends on Request Type
    SRIndex                 DW  ?  ;Index depends on Request Type
      ;If EndPoint,  Bits 3:0 = EndPoint Number
      ;              Bit    7 = 1 if IN EndPoint, 0 if OUT EndPoint
      ;              All other bits are 0
      ;If Interface, Bits 7:0 = Interface Number (low word)
      ;              All other bits are 0 (high word)
    SRLength                DW  ?  ;Length of Data (if there is Data)
   ;This word is the one we add for ourselves!
    SRTDOffset              DW  ?  ;Offset (Pointer) of TD this SR is for
   ENDS
  SetupReqSize EQU (TYPE (SetupRequest) - 2) ;Actual Request Size (8 bytes)
  SRSize       EQU (SetupReqSize+2)      ;Size of Structure (10 bytes)

  ;----------------------------------------------------------------------------
  ;Device Descriptor Structure
  ;----------------------------------------------------------------------------
  DeviceDescriptor  STRUC   ;Structure for a Device Descriptor
    DDLength           DB ? ;Size of Descriptor in bytes
    DDDescrType        DB DescrTypeDevice
    DDUSBRelease       DW ? ;USB Compliance  bcd (0210h=v2.10)
    DDDvcClass         DB ? ;Device Class (defined by USB-IF)
    DDDvcSubClass      DB ? ;Device SubClass (defined by USB-IF)
    DDDvcProtocol      DB ? ;Device Protocol (defined by USB-IF)
    DDMaxPktSize       DB ? ;Max Packet Size for EndPoint 0
                            ;  MUST be 8, 16, 32, or 64
    DDVendorID         DW ? ;Vendor ID (defined by USB-IF)
    DDProductID        DW ? ;Product ID (defined by manufacturer)
    DDDeviceRelease    DW ? ;Device Release Number (bcd)
    DDManufacturerIndx DB ? ;Index of Manufacturer String
    DDProductIndx      DB ? ;Index of Product String
    DDSerialNumberIndx DB ? ;Index of Serial Number String
    DDNumConfigs       DB ? ;Number of possible Configurations
   ENDS
  DvcDescrSize EQU TYPE (DeviceDescriptor)

  ;----------------------------------------------------------------------------
  ;Configuration Descriptor Structure
  ;This same Structure is used by the Get Other Speed Configuration Request
  ;----------------------------------------------------------------------------
  ConfigDescriptor     STRUC     ;Structure for a Config Descriptor
    CDLength              DB  ?  ;Size of Descriptor in bytes
    CDDescrType           DB DescrTypeConfig
    CDTotalLength         DW  ?  ;Total length of data returned for
                                 ;  this configuration (ALL data)
    CDNumInterfaces       DB  ?  ;Number of Interfaces in this Config
    CDConfigValue         DB  ?  ;Value to use in SetRequest to
                                 ;  set this configuration
    CDConfigurationIndx   DB  ?  ;Index of Configuration String
    CDAttributes          DB  ?  ;Configuration Attributes
      CDAttrBit7         EQU 80h ;Bit 7 must be set to 1
      CDAttrSelfPowered  EQU 40h ;Self Powered
      CDAttrRemoteWakeup EQU 20h ;Remote Wakeup Supported
      CDAttrBatteryPower EQU 10h ;Battery Powered
      ;Bits 3:0 = Reserved (0)
    CDMaxBusPower         DB  ?  ;Maximum Power Consumption FROM BUS
                                 ;  in 2mA units (*2 to get mA)
   ENDS
  CfgDescrSize EQU TYPE (ConfigDescriptor)

  ;----------------------------------------------------------------------------
  ;On-The-Go Descriptor Structure
  ;----------------------------------------------------------------------------
  OnTheGoDescriptor    STRUC   ;Structure for a Config Descriptor
    GDLength            DB  ?  ;Size of Descriptor in bytes
    GDDescrType         DB DescrTypeOnTheGo
    GDAttributes        DB  ?  ;On-The-Go Attributes
      ;Bits 7:2 = Reserved (0)
      GDAttrHNPSupport EQU 20h ;Host Negotiation Protocol Supported
      GDAttrSRPSupport EQU 10h ;Session Request Protocol Supported
   ENDS
  OnTheGoDescriptorSize EQU TYPE (OnTheGoDescriptor)

  ;----------------------------------------------------------------------------
  ;Debug Descriptor Structure (USB 2.0/EHCI)
  ;----------------------------------------------------------------------------
  DebugDescrStruc STRUC ;Struc for an Interface Association Descriptor
    DbgLength    DB ? ;Size of Descriptor in bytes (4)
    DbgDescrType DB DescrTypeDebug
    DbgEndPtIn   DB ? ;Debug In EndPoint
    DbgEndPtOut  DB ? ;Debug out EndPoint
   ENDS

  ;----------------------------------------------------------------------------
  ;Interface Association Descriptor Structure
  ;----------------------------------------------------------------------------
  IntfAssocDescrStruc STRUC ;Struc for an Interface Association Descriptor
    IADLength       DB ? ;Size of Descriptor in bytes (8)
    IADDescrType    DB DescrTypeIntfAssoc
    IADFirstInst    DB ? ;First Interface Number Associated with this Function
    IADIntfCount    DB ? ;# of contiguous Intf's associated with this Function
    IADFuncClass    DB ? ;Class Code
    IADFuncSubClass DB ? ;SubClass Code
    IADFuncProt     DB ? ;Protocol Code
    IADFuncString   DB ? ;Index of String Descriptor for this Function
   ENDS

  ;----------------------------------------------------------------------------
  ;String Descriptor 0 is a structure containing the data returned by a
  ;  GetDescriptor Request for a String with Language ID 0
  ;This Structure is defined by the USB Organization
  ;----------------------------------------------------------------------------
  StringDescriptor0 STRUC ;Structure for a String Descriptor w/ Lang ID = 0
    SD0Length    DB ? ;Size of Descriptor in bytes
    SD0DescrType DB DescrTypeString
    SD0LangID0   DW ? ;Language ID Code 0
    SD0LangID1   DW ? ;Language ID Code 1
;      ...
    SD0LangIDn   DW ? ;Language ID Code n
   ENDS
  StringDescriptor0Size EQU TYPE (StringDescriptor0)

  MaxStrSize EQU 255  ;Maximum Size of a String Descriptor
                      ;Verify how big this can really be!!

  ;----------------------------------------------------------------------------
  ;String Descriptor Structure
  ;----------------------------------------------------------------------------
  StringDescriptor STRUC              ;Structure for a String Descriptor
                                      ;  with Language ID > 0
    SDLength    DB                 ?  ;Size of Descriptor in bytes
    SDDescrType DB   DescrTypeString  ;Desc riptor Type
    SDString    DB MaxStrSize DUP (0) ;The String Itself
                                      ;  in UniCode!  Not terminated!
                                      ;  Length = (SDLength - 2)
   ENDS
  StringDescriptorSize EQU TYPE (StringDescriptor)

  ;----------------------------------------------------------------------------
  ;Interface Descriptor Structure
  ;----------------------------------------------------------------------------
  InterfaceDescriptor STRUC  ;Structure for an Interface Descr
    IDLength            DB ? ;Size of Descriptor in bytes
    IDDescrType         DB DescrTypeInterface
    IDInterfaceNumber   DB ? ;Interface Number (0-based Index)
    IDAlternateSetting  DB ? ;Value used to select this alternate
                             ;  setting for the InterfaceNumber
    IDNumEndPoints      DB ? ;Number of End Points, excl 0
    IDInterfaceClass    DB ? ;Interface Class (defined by USB-IF)
    IDInterfaceSubClass DB ? ;Interface SubClass (def by USB-IF)
    IDInterfaceProtocol DB ? ;Interface Protocol (def by USB-IF)
    IDInterfaceIndx     DB ? ;Index of Interface String
   ENDS
  InterfaceDescriptorSize EQU TYPE (InterfaceDescriptor)

;Add a couple more bytes here!

  ;----------------------------------------------------------------------------
  ;Device Qualifier Structure, returned by a
  ;  GetDescriptor Request for a Device Qualifier (USB version 2.0+)
  ;If device is operating Full-Speed (12Mbps), this returns info about
  ;  what the device does at High-Speed (480Mbps), and vice-versa.
  ;----------------------------------------------------------------------------
  DeviceQualifierDescriptor STRUC ;Structure for a Device Qualifier Descriptor
    DQLength      DB ? ;Size of Descriptor in bytes
    DQDescrType   DB DescrTypeDvcQual
    DQUSBRelease  DW ? ;USB Compliance  bcd (0210h=v2.10)
    DQDvcClass    DB ? ;Device Class (defined by USB-IF)
    DQDvcSubClass DB ? ;Device SubClass (defined by USB-IF)
    DQDvcProtocol DB ? ;Device Protocol (defined by USB-IF)
    DQMaxPktSize  DB ? ;Max Packet Size for other speed
    DQNumConfigs  DB ? ;Number of other-speed Configurations
    DQReserved    DB 0 ;Reserved
   ENDS
  DeviceQualifierDescriptorSize EQU TYPE (DeviceQualifierDescriptor)

  ;----------------------------------------------------------------------------
  ;EndPoint Descriptor Structure
  ;----------------------------------------------------------------------------
  EndPointDescriptor    STRUC     ;Structure for an EndPoint Descr
    EDLength               DB  ?  ;Size of Descriptor in bytes
    EDDescrType            DB DescrTypeEndPoint
    EDEndPointNumber       DB  ?  ;EndPoint Number
      EDDirectionIn       EQU 80h ;Direction = In (Ignored in Control EP's)
      ;Bits 6:4 = Reserved (0)
      EDNumberMask        EQU 0Fh ;EndPoint Number (0-15)
    EDAttributes           DB  ?  ;EndPoint attributes
      ;Bits 7:6 = Reserved (0)
      EDUsageTypeMask     EQU 30h ;Bits 5:4 = Usage Type
      EDUsageTypeSft      EQU  4  ;Bits to Shift by
        EDAttrImplicitFB  EQU 20h ;2 = Implicit Feedback Data EndPoint
        EDAttrFeedback    EQU 10h ;1 = Feedback EndPoint
        EDAttrData        EQU 00h ;0 = Data EndPoint
      EDSynchTypeMask     EQU 0Ch ;Bits 3:2 = Synchronization Type
      EDSynchTypeSft      EQU  2  ;Bits to Shift By
        EDAttrSynch       EQU 0Ch ;3 = Synchronous
        EDAttrAdaptive    EQU 08h ;2 = Adaptive
        EDAttrAsynch      EQU 04h ;1 = Asynchronous
      EDAttrTransTypeMask EQU 03h ;Bits 1:0 = Transfer Type
        EDAttrInterrupt   EQU 03h ;3 = Interrupt
        EDAttrBulk        EQU 02h ;2 = Bulk
        EDAttrIsoch       EQU 01h ;1 = Isochronous
        EDAttrControl     EQU 00h ;0 = Control
    EDMaxPktSize           DW  ?  ;Max Packet Size EndPoint can handle
    EDPollInterval         DB  ?  ;Polling Interval for Data Transfers
    ;The following two bytes only appear in some Isochronous Applications
    EDRefreshRate          DB  ?  ;Refresh Rate (1-9, power of 2 mS)
    EDSynchEndPoint        DB  ?  ;Synchronization EndPoint
   ENDS
  EndPointDescriptorSize EQU TYPE (EndPointDescriptor)

  ;----------------------------------------------------------------------------
  ;Format of data returned by an HID (Human Interface Device) Descriptor
  ;----------------------------------------------------------------------------
  HIDDescriptor       STRUC     ;Structure for an HID Descriptor
    HIDDLength           DB ?   ;Size of Descriptor in bytes
    HIDDDescrType        DB DescrTypeHID
    HIDDClassRelease     DW ?   ;HID Class Release Spec (BCD)
    HIDDCountryCode      DB ?   ;Country Code
                                ;0 = None/NA, 21h = US
    HIDDNumClasses       DB ?   ;Number of Class Descriptors
    HIDDDescriptorType   DB ?   ;Type of Class Descriptor
                                ;DescrTypeHIDReport (22h) or
                                ;DescrTypeHIDPhysical (23h)
    HIDDDescriptorLength DW ?   ;Length of Class Descriptor
     ;Repeat Type and Length for each Class Descriptor
   ENDS
  HIDDescriptorSize EQU 9


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;MACROS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

  SwapDSES MACRO ;Exchange DS & ES with each other
    PUSH DS
    PUSH ES
    POP  DS
    POP  ES
   #EM


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;TSR DATA, UNIQUE TO EACH INSTANCE OF THE PROGRAM IN MEMORY
;We can have multiple instances of this program in memory, each controlling
;  a separate Host.  When we do, only the first TSR instance of the program
;  in memory contains the code.  The first instance also contains the
;  data for the first Host.  Each instance after the first only contains
;  the data for the Host it is controlling.  This way all instances
;  other than the first use much less memory than they otherwise would.
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;==============================================================================
;TSR Related
;==============================================================================

  DB (TSRStackSize-PSPStrucSize-3) DUP (CR)
     ;Extra space for large TSR Stack
     ;The -3 accounts for the "JMP Main" at the beginning of the
     ;  the source code above.

  ;------------------------------------------------------------------------------
  ;INT2D Data (AMIS - Alternative Multiplex Interface Specification)
  ;This needs to be the first data at the top of the file!
  ;If the user does a "TYPE ProgName.COM" at the command line, this will
  ;  just show the program name and version, instead of sending all kinds of
  ;  annoying happy faces and BELs to the screen the way most programs do.
  ;This is also the same data that is used to test if the program is
  ;  already installed in memory.
  ;NOTE: The three ASCII items must stay together in this order (MfgName,
  ;        PrgName, PrgDescr), as part of the AMIS Spec!
  ;------------------------------------------------------------------------------
  AMISNoType1:  DB        CR  ;To handle TYPE from command line
  AMISMfgName:  DB 'Bret J. ' ;8 bytes, Space-Padded ASCII Manufacturer Name
 #IF LITE
  AMISPrgName:  DB 'USBUHCIL' ;8 bytes, Space-Padded ASCII Product/Program Name
 #ELSE
  AMISPrgName:  DB 'USBUHCI ' ;8 bytes, Space-Padded ASCII Product/Program Name
 #ENDIF
  AMISPrgDescr: DB         0  ;ASCIIZ Program Description, Max 64 bytes
  AMISVerTxt:   DB     '0.14' ;Program Version in Text
  AMISNoType2:  DB       EOF  ;To handle TYPE from command line
  AMISVersion  EQU      000Eh ;Version number (NOT BCD, must match AMISVerTxt)
  AMISHandle    DB        -1  ;AMIS Multiplex Handle Number (Filled in Later)

  ;----------------------------------------------------------------------------
  ;Table of Interrupt Numbers that the TSR Intercepts
  ;First byte of each entry is the Interrupt Number
  ;Second word is the Pointer to our Interrupt Handler Code Header
  ;Per the AMIS specification, INT 2Dh must be the LAST entry in the Table
  ;NOTE: Because the USB Interrupt can be different for each Host,
  ;        we need a separate copy for each instance of the program.
  ;----------------------------------------------------------------------------
  IntNumTable:
  USBIntNum:
    DB ?                  ;USB Host IRQ
     DW USBIntHdr+IntOfst
    DB 14h                ;Serial Services
     DW Int14Hdr+IntOfst
    DB 08h                ;Timer Tick
     DW Int08Hdr+IntOfst
    DB 2Dh                ;AMIS TSR Multiplex -- MUST BE LAST ENTRY IN TABLE!!
     DW Int2DHdr+IntOfst

  ;------------------------------------------------------------------------------
  ;Code Lookup Table for INT 2Dh (AMIS) Functions
  ;------------------------------------------------------------------------------
  Int2DFunctionTbl:
    DB AMISInstallChk      ;Installation Check
      DW DoAMISInstallChk
    ;DB AMISGetPrvEntry     ;Get Private Entry Point
    ;  DW DoAMISGetPrvEntry
    DB AMISUninstall       ;Uninstall
      DW DoAMISUninstall
    ;DB AMISReqPopup        ;Request Popup
    ;  DW DoAMISReqPopup
    DB AMISGetInts        ;Determine Chained Interrupts
      DW DoAMISGetInts
    ;DB AMISGetHotKeys     ;Get HotKey List
    ;  DW DoAMISGetHotKeys
    ;DB AMISGetDevices     ;Get Device Driver List
    ;  DW DoAMISGetDevices
    DB AMISGetPCIIndex    ;Get PCI Search Index
      DW DoAMISGetPCIIndex
    DB -1                 ;End of Table
     DW -1

  ;----------------------------------------------------------------------------
  ;Miscellaneous Yes/No TSR Flags
  ;----------------------------------------------------------------------------
  TSRFlags           DB 00h ;Miscellaneous Yes/No Flags
    GettingRootPort EQU 01h ;In process of handling a new device on Root Hub
    TimingChanging  EQU 02h ;In process of changing Frame Timing
    FirstInstance   EQU 04h ;This is the first instance of the Program in memory
    EnumeratingDvc  EQU 08h ;In process of Enumerating a new device
    DoRegIntf       EQU 10h ;Looking for Registered Intf (not UnRegistered)
    NoBeep          EQU 20h ;Don't Beep the Speaker for Bad Devices

  ;----------------------------------------------------------------------------
  ;My Dell desktop does not set the PtConnStChg bit like it's supposed to
  ;  when a new Device is connected to the Root Hub.  It does set it when
  ;  a Device is disconnected, however.  I don't know if the problem is with
  ;  the Intel Host Controllers, or with the Dell EHCI BIOS, though I very
  ;  much suspect Dell rather than Intel.  In any case, we need to keep track
  ;  of Connect status changes ourselves rather than depending on the
  ;  PtConnStatusChg bit like we're supposed to be able to do.
  ;Once again, we find ourselves needing to make the program larger and more
  ;  complicated because the hardware manufacturers don't do their job.
  ;
  ;This is a bit-map of Root Hub Port Connect Statuses.  Bit 0 is unused,
  ;  bit 1 is Port 1, bit 2 is Port 2, etc.  A bit is set if there was a
  ;  Device connected to the port last time we checked, clear if not.
  ;----------------------------------------------------------------------------
  PtConnLastTime DW 00h ;Start with no Devices connected

  EVEN 2

  ;----------------------------------------------------------------------------
  ;Segment of First Instance of this Program in Memory
  ;----------------------------------------------------------------------------
  FirstInstanceSeg DW ?


;==============================================================================
;Stack Related
;==============================================================================
  StackInUse DB 0 ;Counter to keep track of "setup stack" calls
  OldSS      DW ? ;Original Stack Segment
  OldSP      DW ? ;Original Stack Pointer
  TempBX     DW ? ;Temporary Storage for BX while setting up Stack
  TempFlags  DW ? ;Temporary Storage for Flags while setting up Stack


;==============================================================================
;Host Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;USB Host Index (this identifies this particular instance of a USB Host Driver,
  ;  so that we can have more than one Host running at the same time
  ;----------------------------------------------------------------------------
  USBHostIndex DB -2 ;USB Host Index
                     ;0-15, -1 = "All Hosts" Call

  EVEN 2

  USBHostMask  DW  0 ;Our Bit Mask associated with our Index

  ;----------------------------------------------------------------------------
  ;Physical Address of Offset 0 of the TSR in memory
  ;The PCI Bus directly controls the Address Bus, rather than going through
  ;  the CPU's normal real-mode Segment:Offset translation schemes.
  ;When we provide a memory address to the Host to send or receive data,
  ;  it MUST be a physical address rather than a segment:offset address.
  ;We calculate the physical address of our TSR memory space and store it
  ;  here, so we don't needlessly waste time calculating it each time
  ;  we need to know what it is.
  ;----------------------------------------------------------------------------
  BasePhysAddr DD ? ;Physical Address of Offset 0 of TSR

  ;----------------------------------------------------------------------------
  ;Needed to keep track of Host Start/Stop/Reset/etc. Requests
  ;----------------------------------------------------------------------------
  HostRunHandle      DW -1 ;Large Call Handle Number for Host Run
  HostStopHandle     DW -1 ;Large Call Handle Number for Host Stop
  HostResetHandle    DW -1 ;Large Call Handle Number for Host Reset
  HostSuspendHandle  DW -1 ;Large Call Handle Number for Host Suspend
  HostResumeHandle   DW -1 ;Large Call Handle Number for Host Resume
  HostDebugHandle    DW -1 ;Large Call Handle Number for Host Debug
  HostSSTHandle      DW -1 ;Large Call Handle Number for Host SingleStep
  HostSSTFrameNum    DW  ? ;Frame Number while single-stepping
  HostResetFrameNum  DW  ? ;Original Frame Number before a Host Reset
  HostResetSOFModify DB  ? ;Original Timing Value before a Host Reset

  ;----------------------------------------------------------------------------
  ;Data Tables & Offsets
  ;----------------------------------------------------------------------------

  EVEN 16
  QHTable DW ? ;Queue Head Table

  EVEN 2
  #IF !LITE ;USBUHCI
   ADOffset: DB (ADEntries * ADSize) DUP (0) ;Address Table
   InOffset: DB (InEntries * InSize) DUP (0) ;Interface Table
   AIOffset: DB (AIEntries * AISize) DUP (0) ;Alternate Interface Table
  #ELSE     ;USBUHCIL
   ADTable DW ? ;Address Table Pointer
   InTable DW ? ;Interface Table Pointer
   AITable DW ? ;Alternate Interface Table Pointer
  #ENDIF

   EnTable DW ? ;EndPoint Table Pointer
   SRTable DW ? ;Setup Request Table Pointer
   TTTable DW ? ;Timeout Table Pointer
   LCTable DW ? ;Large Call Table Pointer
   RsTable DW ? ;Reset Table Pointer

  ;----------------------------------------------------------------------------
  ;Space for Data to be returned by Main Descriptors
  ;----------------------------------------------------------------------------
  DvcDescrPtr DW ? ;Pointer to Device Descriptor Data
  CfgDescrPtr DW ? ;Pointer to Complete Configuration Descriptor Data

  ;----------------------------------------------------------------------------
  ;Frame List Offsets
  ;----------------------------------------------------------------------------
  FLOffsetW  DW ? ;Offset of Frame List
  FLOffsetDW DD ? ;Physical Address Frame List

  ;----------------------------------------------------------------------------
  ;Buffer for our Frame List and Stack Space
  ;The Frame List must start on a 4K boundary of physical memory, but we
  ;  have no control where our TSR gets installed in memory in relationship
  ;  to 4K page boundaries.
  ;So, we set up a space twice as big as we need, and later on figure
  ;  out where in the space the 4K page boundary is, and set up the
  ;  Frame List there.
  ;There will usually be space both before and after the Frame List,
  ;  which is where we set up a TSR stack and store several data tables.
  ;  We cannot fill up the entire 4k extra space with valid data, but we
  ;  are able to use a large amount of it.
  ;----------------------------------------------------------------------------

  EVEN 16
  FrameAndStackBuff:
    DB (FLSize*FLEntries*2) DUP (0) ;Frame and Stack Buffer

  ;----------------------------------------------------------------------------
  ;Table of Transfer Descriptors
  ;----------------------------------------------------------------------------
  EVEN 16
  TDOffset:
    DB (TDEntries*TDSize) DUP (0) ;Transfer Descriptor Table


;==============================================================================
;PCI Bus & IRQ Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;PCI Search Index (goes in SI when looking for PCI Devices)
  ;This allows us to have multiple UHCI Hosts on the same computer and know
  ;  which one to send our calls to
  ;----------------------------------------------------------------------------
  EVEN 2
  PCISearchIndex DW 0 ;PCI Search Index (Goes in SI)

  ;----------------------------------------------------------------------------
  ;;Original IRQ Mask (at entry into IRQ Code)
  ;----------------------------------------------------------------------------
  OrigIRQMask DB ?

  ;----------------------------------------------------------------------------
  ;;Counter to make sure USB Interrupt is occurring
  ;----------------------------------------------------------------------------
  USBIntCount DB 0

  ;----------------------------------------------------------------------------
  ;USB/PCI/IRQ Information - doesn't change, but we need to use it variously
  ;  and don't (or shouldn't) requery the Host Device to find out what it is
  ;----------------------------------------------------------------------------
  EVEN 2
  PCIDevFunc    DW ? ;PCI Bus, Device, & Function #'s for USB Host Controller
                     ;  High byte = Bus number
                     ;  Low byte bits 7-3 = Device, bits 2-0 = Function
  HostVendorID  DW ? ;PCI Vendor ID
  HostProductID DW ? ;PCI Product ID
  USBIRQNum     DB ? ;USB IRQ (Hardware Interrupt) Number (0-15)
  USBVersion    DB ? ;USB Host Version Compliance

  ;----------------------------------------------------------------------------
  ;Original USB/PCI/IRQ Information - needs to be restored when we Uninstall
  ;----------------------------------------------------------------------------
  EVEN 2
  OldFrameListAddr DD ? ;Original Frame List Address
  OldPCICfgCmd     DW ? ;Original PCI Configuration Command Register
  OldUSBCommand    DW ? ;Original USB Command Register
  OldUSBIntEnable  DW ? ;Original USB Interrupt Enable register
  OldFrameNum      DW ? ;Original Frame Number
  OldPortSC1       DW ? ;Original Port 1 Status & Control Word
  OldPortSC2       DW ? ;Original Port 2 Status & Control Word
  OldLegacySupp    DW ? ;Original Legacy Support Reg (For Mouse/Kbd)
  OldSOFModify     DB ? ;Original Start-of-Frame Modify Register
  OldIRQNum        DB ? ;Original IRQ Number
  OldResumeEnable  DB ? ;Original PCI USB Resume Enable Register

  ;----------------------------------------------------------------------------
  ;USB/PCI Data that we change/modify
  ;----------------------------------------------------------------------------
  EVEN 2
  BaseIOAddress        DW    ?  ;Base I/O Address of USB I/O Ports
    USBCommand        EQU 0000h ;Offset to USB Command Register (Word)  RW
      UCMaxPkt64      EQU 0080h ;Max Pkt Size = 64 bytes (Bandwidth Reclamation)
      UCConfigured    EQU 0040h ;Configure Flag = Host Controller Configured
      UCSoftDebug     EQU 0020h ;Software Debug Mode
      UCGlobalResume  EQU 0010h ;Force Global Resume
      UCGlobalSuspend EQU 0008h ;Enter Global Suspend Mode
      UCGlobalReset   EQU 0004h ;Global Reset
      UCHostReset     EQU 0002h ;Host Controller Reset
      UCRunStop       EQU 0001h ;Run/Stop
    USBStatus         EQU 0002h ;Offset to USB Status (Word)  RWC
      USHostHalted    EQU 0020h ;Host Controller Halted
      USProcessorErr  EQU 0010h ;Host Controller Processor Error
      USSystemErr     EQU 0008h ;Host Controller System Error
      USResumeDetect  EQU 0004h ;Resume Detect
      USUSBErrInt     EQU 0002h ;USB Error Interrupt
      USUSBInt        EQU 0001h ;USB Interrupt
      USErrorMask     EQU 001Fh ;All Errors Mask (excludes HC Halted)
    USBIntEnable      EQU 0004h ;Offset to USB Interrupt Enable Register (Word)
      UIShortPkt      EQU 0008h ;Short Packet Interrupt Enable
      UIIntOnComplete EQU 0004h ;Interrupt On Complete Enable
      UIResume        EQU 0002h ;Resume Interrupt Enable
      UITimeoutCRC    EQU 0001h ;Timeout/CRC Interrupt Enable
      UIIntAll        EQU (UIShortPkt+UIIntOnComplete+UIResume+UITimeoutCRC)
    FrameNum          EQU 0006h ;Offset to Current Frame Number (Word, 0-1023)RW
      FrNumIndexMask  EQU 03FFh ;Mask to convert Frame Number to Frame Index
                                ;  (Frame number actually goes from 0-2047)
      FrNumNumMask    EQU 07FFh ;To make sure no extra bits are there
    FrameListAddr     EQU 0008h ;Offset to Current Frame List Address (DWord) RW
    SOFModify         EQU 000Ch ;Offset to Start of Frame Modify (Byte)
                                ;SOF Timing = 11936 + this (0-127, def = 64)
    PortSC1           EQU 0010h ;Offset to Port 1 Status/Control (Word)
    PortSC2           EQU 0012h ;Offset to Port 2 Status/Control (Word)
      ;Bits 15-13 = Reserved
      PtSuspend       EQU 1000h ;Port in Suspend State  RW
      PtOverCurrChg   EQU 0080h ;OverCurrent Detection Change
                                ;  Only on some newer Controllers  RWC
      PtOverCurrSts   EQU 0080h ;OverCurrent Detected
                                ;  Only on some newer Controllers  RO
      PtPortReset     EQU 0200h ;Port in Reset State  RW
      PtLowSpeed      EQU 0100h ;Low Speed Device Attached  RO
      ;Bit 7 = Reserved (always 1)
      PtResumeDetect  EQU 0040h ;Resume Detect  RW
      PtLineStatM     EQU 0020h ;Line Status (Logical Level of D-)  RO
      PtLineStatP     EQU 0010h ;Line Status (Logical Level of D+)  RO
      PtPortEnChg     EQU 0008h ;Port Enabled/Disabled Status has changed  RWC
      PtPortEnable    EQU 0004h ;Port Enabled  RW
      PtConnStatChg   EQU 0002h ;Connect Status Change  RWC
      PtConnStatus    EQU 0001h ;Connect Status  RO


;==============================================================================
;Root Hub Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Delay Counter to control when we look for New Devices on the Root Hub
  ;----------------------------------------------------------------------------
  EnumerateDelay DB 5

  ;----------------------------------------------------------------------------
  ;Number of Root Hub Ports
  ;Always 2 for UHCI.  There is actually room in the I/O Space for more,
  ;  but the UHCI Spec only defines 2 and no hardware I've ever seen or
  ;  heard of has more than 2.  Some only have 1 useful port, since only
  ;  1 port is physically wired to the outside world.
  ;We make this a variable instead of an EQUate just in case we discover
  ;  a UHCI Host Controller with more than 2 ports, or we figure out a way
  ;  to determine if only one of the ports is physically wired.
  ;----------------------------------------------------------------------------
  NumRootHubPorts DB 2

  ;----------------------------------------------------------------------------
  ;Pause Counter (in deciSeconds) before we will start looking for
  ;  Devices attached to the Root Hub.  This seems to help fix some problems
  ;  with older hardware during the enumeration process.
  ;----------------------------------------------------------------------------
  PauseCounter DB 1

  ;----------------------------------------------------------------------------
  ;Variables to keep track of which Root Hub Port is being tested
  ;----------------------------------------------------------------------------
  RHPortOffset DB ? ;Offset of Root Hub Port being tested (Port SCx)
  RHPortNumber DB ? ;Root Hub Port Number being tested (1 or 2)

  ;----------------------------------------------------------------------------
  ;Port Offset of Resume Detect on Root Hub
  ;----------------------------------------------------------------------------
  ResDetPortOffset DB ?

  ;----------------------------------------------------------------------------
  ;Variables to keep track of Root Hub Reset & Resume Requests
  ;----------------------------------------------------------------------------
  EVEN 2
  HubResetPort1Handle DW ? ;Large Request Handle for Port 1 Reset Request
  HubResetPort2Handle DW ? ;Large Request Handle for Port 2 Reset Request


;==============================================================================
;Reset/Enumeration Process Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Needed to keep track of the last Enumerated Device
  ;----------------------------------------------------------------------------
  LastAddressUsed   DB ? ;Last Address we used
  EVEN 2
  LastAddressOffset DW ? ;Offset of Last Address Used in Address Table

  ;----------------------------------------------------------------------------
  ;Offset of Reset Table Entry currently being used
  ;----------------------------------------------------------------------------
  EVEN 2
  ResetTblOffset DW ?


;==============================================================================
;INT 14h Request Processing Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Needed to Close Bulk, Control, and OneTime Transactions prematurely
  ;----------------------------------------------------------------------------
  CloseID DB 80h ;Close Transaction ID

  ;----------------------------------------------------------------------------
  ;Data Structures needed to issue Scheduling Requests
  ;Since several different subroutines use these, we'll need more than one
  ;  so that we can "multitask" to avoid inadvertantly overwriting data
  ;  from one call with another call
  ;We need a total of 5 Request structures, but will only reserve space for
  ;  one of them here.  The other 4 will be stored in the PSP after we
  ;  install ourselves as a TSR.
  ;In most TSR's, we put the TSR stack in the PSP, but it's more convenient
  ;  in this program to put the Stack in the FrameAndStackBuff.  This is
  ;  due to the 4k page alignment requirement of the Frame List, and the
  ;  large stack space requirement we have (the PCI BIOS alones claims it
  ;  may need as much as 1024 byts of stack to make a call to it).
  ;----------------------------------------------------------------------------
  EVEN 2
  Int14Request:                 ;Handles New Device Searches on the Root
    DB Int14RequestSize DUP (0) ;  Hub, Global Resumes, and One-time Ints

  Int14Request2:                ;Handles New Device Attachments
    DB Int14RequestSize DUP (0) ;  from Any Hub

  Int14Request3:                ;Handles New Device Notifies
    DB Int14RequestSize DUP (0) ;  to all Device 0 Owners

  Int14Request4:                ;Handles Timing Change Requests
    DB Int14RequestSize DUP (0) ;  and Beep Reuests

  Int14Request5:                ;Handles Root Hub Calls & Large Calls
    DB Int14RequestSize DUP (0)


 #IF !LITE
  ;----------------------------------------------------------------------------
  ;Temporary storage for data needed while setting up an Isoch Transaction
  ;  (there are not enough General Purpose Registers to hold everything)
  ;----------------------------------------------------------------------------
  EVEN 2
  IsochStartFrame DW  ? ;Starting Frame Number for the Isoch Series
  IsochHandle     DW -1 ;Isoch Handle Number (First TD Index)
  IsochInt14Ptr   DD  ? ;Int 14h Request Pointer
  IsochSequence   DB  ? ;Isoschronous Packet Sequence Number
 #ENDIF


;==============================================================================
;Timing Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Call Back Address, Pkt ID, & Handle for Timing Owner
  ;----------------------------------------------------------------------------
  EVEN 2
  TimingCallBackAddr DD ? ;Call Back Address for Timing Owner
  TimingUserPktID    DW ? ;User Packet ID for Timing Owner
  TimingHandle       DW ? ;Request Handle returned to owner on Registration

  ;----------------------------------------------------------------------------
  ;Temp storage for Call Back Address & Pkt ID & Target Value for Timing Changes
  ;Called after a Frame Timing has been Changed
  ;----------------------------------------------------------------------------
  TimingChgCallBackAddr DD ? ;Call Back Address after Timing Change is done
  TimingChgUserPktID    DW ? ;User Packet ID after Timing Change is done
  TimingChangeTarget    DB ? ;Target Value for SOF Modify Register


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;TSR CODE, UNIQUE TO EACH INSTANCE OF THE PROGRAM IN MEMORY
;The "real" code for all TSR's is only in the first instance of the program
;  in memory.  All instances after the first one just have a small "stub"
;  of code, just enough to be able to "jump" to the code in the first instance.
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;------------------------------------------------------------------------------
;HAVE INTERRUPT 08 (TIMER) RUN THIS PROGRAM EVERY TIME IT OCCURS
;Inputs:
;Outputs:
;Changes:
;------------------------------------------------------------------------------
Int08Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int08:
  PUSH ES                    ;Save used registers
  MOV  ES,CS                 ;Point ES at our Segment
  PUSH ES:[FirstInstanceSeg] ;Put Code Address
  PUSH Int08Code             ;  on the Stack
  RETF                       ;Jump to do the Code

;------------------------------------------------------------------------------
;HAVE INTERRUPT 14h (SERIAL SERVICES) RUN THIS PROGRAM EVERY TIME IT OCCURS
;Inputs:  AX = 5000h (Install Check) or 5001h (Regular Function)
;         BX = "US"
;         CX = "B!"
;         DS:[DX] = Data Structure (for Regular Function)
;Outputs: CF = Clear if Valid Function
;              Various values in AX, BX, CX, and DX, Depending on Call Type
;            = Set if Error
;              Error Code in AX
;Changes: Intercepts various Serial calls, "translating" them into USB calls
;           as appropriate
;------------------------------------------------------------------------------
Int14Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int14:
  PUSH ES                    ;Save used registers
  MOV  ES,CS                 ;Point ES at our Segment
  PUSH ES:[FirstInstanceSeg] ;Put Code Address
  PUSH Int14Code             ;  on the Stack
  RETF                       ;Jump to do the Code

;------------------------------------------------------------------------------
;HAVE INTERRUPT 2Dh (AMIS) RUN THIS PROGRAM EVERY TIME IT OCCURS
;Inputs:  Varies, Depending on Function
;Outputs: Varies, Depending on Function
;Changes:
;------------------------------------------------------------------------------
Int2DHdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int2D:
  PUSH ES                    ;Save used registers
  MOV  ES,CS                 ;Point ES at our Segment
  PUSH ES:[FirstInstanceSeg] ;Put Code Address
  PUSH Int2DCode             ;  on the Stack
  RETF                       ;Jump to do the Code

;------------------------------------------------------------------------------
;DO THIS EVERY TIME THE USB INTERRUPT OCCURS
;Inputs:
;Outputs:
;Changes:
;------------------------------------------------------------------------------
USBIntHdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

USBIntCode0:
  PUSH ES                    ;Save used registers
  MOV  ES,CS                 ;Point ES at our Segment
  PUSH ES:[FirstInstanceSeg] ;Put Code Address
  PUSH USBIntCode            ;  on the Stack
  RETF                       ;Jump to do the Code


LastTSRByte0:


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;TSR DATA, GLOBAL TO THE PROGRAM (ONLY NEEDED ONCE FOR ALL INSTANCES OF PROG)
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;==============================================================================
;TSR Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Number of Instances of this Program in memory
  ;  (Number of UHCI Controllers we're controlling)
  ;If Uninstalling, and we're the First Instance, this must be 0, or else
  ;  we'll just Disable Functions (all other instances use our code and
  ;  need some of our data!!)
  ;Individual Instances must Increment/Decrement this appropriately when
  ;  Installing/Uninstalling
  ;Even when Disabled, we still need to process Host-related Requests
  ;  (Add/Delete Hosts), even though we ignore Device-related requests.
  ;----------------------------------------------------------------------------
  NumInstances DB 0 ;Number of Instances of us in memory - 1

  ;----------------------------------------------------------------------------
  ;Miscellaneous Yes/No TSR Flags
  ;----------------------------------------------------------------------------
  TSRFlags0    DB 00h ;Miscellaneous Yes/No Flags
    DoTheBeep EQU 01h ;Need to Try and Beep the Speaker


;==============================================================================
;Beeping the Speaker Related
;==============================================================================
  BeepFrequency DW 0 ;Frequency divider to beep with
  BeepCount     DW 0 ;Beep Timeout Counter (Timer Ticks)
  OldPort42     DW ? ;Variables needed to restore the I/O Ports "borrowed"
  OldPort61     DB ? ;  to control the Speaker back to their original state


;==============================================================================
;INT 14h Processing Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Bit Mask of all Valid Host Indexes (Bit Number = 1 if Host Index is Valid)
  ;----------------------------------------------------------------------------
  HostIndexes DW 0

  ;----------------------------------------------------------------------------
  ;New Device Notification Table - Only need 1 copy of this!
  ;----------------------------------------------------------------------------
  EVEN 2
  NDTable: DB (NDEntries * NDSize) DUP (0)


;==============================================================================
;Delay Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Int 08 Delay Table - Only need 1 copy of this!
  ;----------------------------------------------------------------------------
  EVEN 2
  I8Table: DB (I8Entries * I8Size) DUP (0)


;==============================================================================
;Control Packet Related
;==============================================================================

  ;============================================================================
  ;Standard Setup Descriptors that we use
  ;ALL of these are the same size (8 bytes)!!
  ;Because these are in the CS segment when our driver is running,
  ;  THESE MUST NOT BE CHANGED!  These should simply be copied into
  ;  INT 14h Request and then the appropriate parameters modified there.
  ;============================================================================

  EVEN 2
  ;----------------------------------------------------------------------------
  ;Set Address
  ;----------------------------------------------------------------------------
  SetAddressReq:
    DB SRRTOut+SRRTTypeStandard+SRRTRecipDevice
    DB SRRQSetAddress
    DB ? ;Address to Set
    DB 0
    DW 0
    DW 0

  I14RSetAddressValue EQU I14RSetupReqData.SRValue[0] ;Byte

  ;----------------------------------------------------------------------------
  ;Get Device Descriptor
  ;----------------------------------------------------------------------------
  GetDvcDescrReq:
    DB SRRTIn+SRRTTypeStandard+SRRTRecipDevice
    DB SRRQGetDescriptor
    DB 0
    DB DescrTypeDevice
    DW 0
    DW DvcDescrSize

  I14RGetDvcDescrSize EQU I14RSetupReqData.SRLength ;Word

  ;----------------------------------------------------------------------------
  ;Get Configuration Descriptor
  ;----------------------------------------------------------------------------
  GetCfgDescrReq:
    DB SRRTIn+SRRTTypeStandard+SRRTRecipDevice
    DB SRRQGetDescriptor
    DB 0 ;Configuration Value to Get (always 0?)
    DB DescrTypeConfig
    DW 0
    DW CfgDescrSize ;Size will change for a Complete Config

  I14RGetCfgDescrValue EQU I14RSetupReqData.SRValue[0] ;Byte
  I14RGetCfgDescrSize  EQU I14RSetupReqData.SRLength   ;Word

  ;----------------------------------------------------------------------------
  ;Set Configuration
  ;----------------------------------------------------------------------------
  SetConfigReq:
    DB SRRTOut+SRRTTypeStandard+SRRTRecipDevice
    DB SRRQSetConfig
    DB ? ;Config value to Set
    DB 0
    DW 0
    DW 0

  I14RSetConfigValue EQU I14RSetupReqData.SRValue[0] ;Byte

  ;----------------------------------------------------------------------------
  ;Standard Device Features
  ;----------------------------------------------------------------------------
  DvcFeatureRemoteWakeup EQU 01h
  DvcFeatureTestMode     EQU 02h

  ;----------------------------------------------------------------------------
  ;Set Device Feature
  ;----------------------------------------------------------------------------
  SetDvcFeatureReq:
    DB SRRTOut+SRRTTypeStandard+SRRTRecipDevice
    DB SRRQSetFeature
    DB ? ;Feature Select Value to Set
    DB 0
    DW 0
    DW 0

  I14RSetDvcFeatureFtrSel EQU I14RSetupReqData.SRValue[0] ; Byte

  ;----------------------------------------------------------------------------
  ;Get Himan Interface Device Report Descriptor
  ;----------------------------------------------------------------------------
  GetReportDescrReq:
    DB SRRTIn+SRRTTypeStandard+SRRTRecipInterface
    DB SRRQGetDescriptor
    DB ? ;Report ID             (0 = All Reports)
    DB DescrTypeHIDReport
    DB ? ;Interface Number
    DB 0
    DW ? ;Number of Bytes

  I14RGetReportDescrRptID EQU I14RSetupReqData.SRValue[0] ;Byte
  I14RGetReportDescrIntf  EQU I14RSetupReqData.SRIndex[0] ;Byte
  I14RGetReportDescrSize  EQU I14RSetupReqData.SRLength   ;Word


  ;============================================================================
  ;Standard Setup Descriptors that we don't use
  ;These Decriptors can, at least theoretically, be sent to any USB Device
  ;  and they should respond appropriately.  We don't need any of them
  ;  in this Driver to be able to do what we need to do, however.
  ;We will include them here for reference, even though we don't actually
  ;  need them.

  ;============================================================================

  ;----------------------------------------------------------------------------
  ;Get Interface Descriptor
  ;----------------------------------------------------------------------------
;  GetIntfDescrReq DB SRRTIn+SRRTTypeStandard+SRRTRecipDevice
;                  DB SRRQGetDescriptor
;  GetIntfIndex    DB ?                  ;Interface Number to get
;                  DB DescrTypeInterface ;Type = Interface (High Byte of SRValue)
;                  DW 0
;                  DW InterfaceDescriptorSize

  ;----------------------------------------------------------------------------
  ;Get Configuration
  ;----------------------------------------------------------------------------
;  GetConfigReq DB SRRTIn+SRRTTypeStandard+SRRTRecipDevice
;               DB SRRQGetConfig
;               DW 0
;               DW 0
;               DW 1

;  ;----------------------------------------------------------------------------
;  ;Get Alternate Interface Setting
;  ;----------------------------------------------------------------------------
;  GetAltIntfReq    DB SRRTIn+SRRTTypeStandard+SRRTRecipInterface
;                   DB SRRQGetAltInterface
;                   DW 0
;  GetAltIntfNumber DB ? ;Interface to Get
;                   DB 0
;                   DW 1

;  ;----------------------------------------------------------------------------
;  ;Set Alternate Interface
;  ;----------------------------------------------------------------------------
;  SetAltIntfReq     DB SRRTOut+SRRTTypeStandard+SRRTRecipInterface
;                    DB SRRQSetAltInterface
;  SetAltIntfAltIntf DB ? ;Alternate Value to set Interface to
;                    DB 0
;  SetAltIntfIntf    DB ? ;Interface to Set
;                    DB 0
;                    DW 0

   ;----------------------------------------------------------------------------
   ;Get Device Status
   ;----------------------------------------------------------------------------
;  GetDvcStatusReq      DB SRRTIn+SRRTTypeStandard+SRRTRecipDevice
;                       DB SRRQGetStatus
;                       DW 0
;                       DW 0
;                       DW 2
;Data returned by GetDeviceStatus:
;  Bit 0 = Self-Powered
;  Bit 1 = Remote WakeUp
;  All other bits 0

   ;----------------------------------------------------------------------------
   ;Get Interface Status
   ;----------------------------------------------------------------------------
;  GetIntfStatusReq      DB SRRTIn+SRRTTypeStandard+SRRTRecipInterface
;                        DB SRRQGetStatus
;                        DW 0
;  GetIntfStatusIntf     DB ? ;Interface to Get Interface of
;                        DB 0
;                        DW 2
;;Data returned by GetInterfaceStatus:
;;  All bits 0

   ;----------------------------------------------------------------------------
   ;Get EndPoint Status
   ;----------------------------------------------------------------------------
;  GetEndPtStatusReq      DB SRRTIn+SRRTTypeStandard+SRRTRecipEndPoint
;                         DB SRRQGetStatus
;                         DW 0
;  GetEndPtStatusEndPoint DB ? ;EndPoint to Get Status of
;                         DB 0
;                         DW 2
;;Data returned by GetEndPointStatus:
;;  Bit 0 = Halt
;;  All other bits 0


   ;----------------------------------------------------------------------------
   ;Clear EndPoint Feature
   ;----------------------------------------------------------------------------
;  ClearEndPtFeatureReq      DB SRRTOut+SRRTTypeStandard+SRRTRecipEndPoint
;                            DB SRRQClearFeature
;  ClearEndPtFeatureFeatSel  DB ? ;Feature Select Value to Clear
;                            DB 0
;  ClearEndPtFeatureEndPoint DB ? ;EndPoint to Clear Feature of
;                            DB 0
;                            DW 0

   ;----------------------------------------------------------------------------
   ;Set EndPoint Feature
   ;----------------------------------------------------------------------------
;  SetEndPtFeatureReq      DB SRRTOut+SRRTTypeStandard+SRRTRecipEndPoint
;                          DB SRRQSetFeature
;  SetEndPtFeatureFeatSel  DB ? ;Feature Select Value to Set
;                          DB 0
;  SetEndPtFeatureEndPoint DB ? ;EndPoint to Set Feature of
;                          DB 0
;                          DW 0
;;Standard EndPoint Features:
  EndPtFeatureHalt EQU 00h

   ;----------------------------------------------------------------------------
   ;Get Synchronization Frame
   ;----------------------------------------------------------------------------
;  SynchFrameReq      DB SRRTIn+SRRTTypeStandard+SRRTRecipEndPoint
;                     DB SRRQSynchFrame
;                     DW 0
;  SynchFrameEndPoint DB ? ;EndPoint to get Synch Frame of
;                     DB 0
;                     DW 2


;==============================================================================
;Program Related
;These tables contain byte-to-word (Code Offset) Lookup Tables
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Table of Code Offsets for Updating/Reusing Transfer Descriptors
  ;----------------------------------------------------------------------------
  UpdateTDTbl:
    DB  TDTypeInterrupt1Time
     DW  UpdateInterrupt1TimeTD
    DB  TDTypeInterruptPer
     DW  UpdateInterruptPerTD
    DB  TDTypeIsoch
     DW  UpdateIsochTD
    DB  TDTypeBulk
     DW  UpdateBulkTD
    DB  TDTypeControlSetup
     DW  UpdateControlTD
    DB  TDTypeControlData
     DW  UpdateControlTD
    DB  TDTypeControlStatus
     DW  UpdateControlTD
    DB  -1  ;End of
     DW  -1 ;  Table

  ;----------------------------------------------------------------------------
  ;Table of Code Offsets for Root Hub Calls
  ;----------------------------------------------------------------------------
  RootHubCallTbl:
    DB HubCallEnumerated
     DW RootHubDvcEnumerated
    DB HubCallEnable
     DW RootHubEnableDvc
    DB HubCallDisable
     DW RootHubDisableDvc
    DB HubCallReset
     DW RootHubResetDvc
    DB HubCallSuspend
     DW RootHubSuspendDvc
    DB HubCallResume
     DW RootHubResumeDvc
    DB HubCallPwrOn
     DW RootHubPowerOnDvc
    DB HubCallPwrOff
     DW RootHubPowerOffDvc
    DB HubCallPwrReset
     DW RootHubPowerResetDvc
    DB -1  ;End of
     DW -1 ;  Table

  ;----------------------------------------------------------------------------
  ;Table of Code Offsets for Get Transaction Status Requests
  ;----------------------------------------------------------------------------
  GetTStatusTbl:
   #IF !LITE
    DB TDTypeIsoch
      DW TStsIsoch
   #ENDIF
    DB TDTypeInterrupt1Time
      DW TStsInt1T
    DB TDTypeInterruptPer
      DW TStsIntPer
    DB TDTypeControlSetup
      DW TStsCtlSetup
    DB TDTypeControlData
      DW TStsCtlData
    DB TDTypeControlStatus
      DW TStsCtlStatus
    DB TDTypeBulk
      DW TStsBulk
    DB -1   ;End of
      DW -1 ;  Table

  ;----------------------------------------------------------------------------
  ;Table of Code Offsets for Int 14h Requests
  ;----------------------------------------------------------------------------
  Int14FunctionTbl:
   ;Host Class
    DB  I14RRTGetHostSWInfo
     DW  GetHostSWInfo
    DB  I14RRTGetHostHWInfo
     DW  GetHostHWInfo
    DB  I14RRTGetHostVendInfo
     DW  GetHostVendorInfo
    DB  I14RRTGetHostStatus
     DW  GetHostStatus
    DB  I14RRTHostRun
     DW  HostRun
    DB  I14RRTHostStop
     DW  HostStop
    DB  I14RRTHostReset
     DW  HostReset
    DB  I14RRTHostSuspend
     DW  HostSuspend
    DB  I14RRTHostResume
     DW  HostResume

   ;Frame Timing Class
    DB  I14RRTRegTmgOwner
     DW  RegTmgOwner
    DB  I14RRTUnRegTmgOwner
     DW  UnRegTmgOwner
    DB  I14RRTIncTiming
     DW  IncTiming
    DB  I14RRTDecTiming
     DW  DecTiming
    DB  I14RRTChangeTiming
     DW  ChangeTiming

   ;Hub Class
    DB  I14RRTGetDvcHubInfo
     DW  GetDvcHubInfo
    DB  I14RRTNewDvcConn
     DW  NewDvcConn
    DB  I14RRTDvcDisc
     DW  OldDvcDisc
    DB  I14RRTSendHubChar
     DW  SendHubCharacteristics
    DB  I14RRTEnableHubPort
     DW  EnableHubPort
    DB  I14RRTDisableHubPort
     DW  DisableHubPort
    DB  I14RRTResetHubPort
     DW  ResetHubPort
    DB  I14RRTSuspendHubPort
     DW  SuspendHubPort
    DB  I14RRTResumeHubPort
     DW  ResumeHubPort
    DB  I14RRTPwrOnHubPort
     DW  PowerOnHubPort
    DB  I14RRTPwrOffHubPort
     DW  PowerOffHubPort
    DB  I14RRTPwrResetHubPort
     DW  PowerResetHubPort

   ;Power Class
    DB  I14RRTGetDvcPowerInfo
     DW  GetDvcPowerInfo
    DB  I14RRTGetHubPowerDraw
     DW  GetHubPowerDraw
    DB  I14RRTPwrOnDevice
     DW  PowerOnDevice
    DB  I14RRTPwrOffDevice
     DW  PowerOffDevice
    DB  I14RRTPwrResetDevice
     DW  PowerResetDevice

   ;Device Class
    DB  I14RRTGetDvcClassInfo
     DW  GetDvcClassInfo
    DB  I14RRTGetDvcVendInfo
     DW  GetDvcVendorInfo
    DB  I14RRTGetDvcStatus
     DW  GetDvcStatus
    DB  I14RRTEnableDevice
     DW  EnableDevice
    DB  I14RRTDisableDevice
     DW  DisableDevice
    DB  I14RRTResetDevice
     DW  ResetDevice
    DB  I14RRTSuspendDevice
     DW  SuspendDevice
    DB  I14RRTResumeDevice
     DW  ResumeDevice

   ;Config Requests
    DB  I14RRTConfigingIntf
     DW  ConfigingIntf
    DB  I14RRTConfigIntfDone
     DW  ConfigIntfDone
    DB  I14RRTSetNewConfig
     DW  SetNewConfig

   ;Interface Requests
    DB  I14RRTGetAltIntfInfo
     DW  GetAltIntfInfo
    DB  I14RRTFindRegIntf
     DW  FindRegIntf
    DB  I14RRTFindUnRegIntf
     DW  FindUnRegIntf
    DB  I14RRTRegIntfOwner
     DW  RegIntfOwner
    DB  I14RRTUnRegIntfOwner
     DW  UnRegIntfOwner
    DB  I14RRTIntfDontLook
     DW  IntfDontLook

   ;EndPoint Requests
    DB  I14RRTGetDataX
     DW  GetDataX
    DB  I14RRTIncDataX
     DW  IncDataX

   ;Packet Requests
    DB  I14RRTDoIsoch          ;Not tested
     DW  StartIsochPacket
    DB  I14RRTDoInterruptPer
     DW  StartIntPerPacket
    DB  I14RRTDoControl
     DW  StartControlPacket
    DB  I14RRTDoBulk
     DW  StartBulkPacket
    DB  I14RRTDoInterrupt1T
     DW  StartInt1TPacket
    DB  I14RRTCloseHandle
     DW  CloseHandle
    DB  I14RRTChangeIntPer
     DW  ChangePeriodicity
    DB  I14RRTGetTransStatus
     DW  GetTransStatus

   ;Misc Class
    DB  I14RRTLargeCallDone
     DW  LargeCallDone
    DB  I14RRTBeepSpeaker
     DW  BeepSpeaker

   ;Inter-Host Communication
    DB  I14RRTHostAdded
     DW  AddHostIndex
    DB  I14RRTHostDeleted
     DW  DeleteHostIndex
    DB  I14RRTRegDvc0Host
     DW  RegDvcOwner0
    DB  I14RRTUnRegDvc0Host
     DW  UnRegDvcOwner0
    DB  I14RRTCopyNDTable
     DW CopyNDTable

   ;Host Troubleshooting/Internal
    DB  I14RRTHostDebug
     DW  HostDebug
    DB  I14RRTHostSingleStep
     DW  HostSingleStep

    DB  -1  ;End of
     DW  -1 ;  Table


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;TSR CODE, GLOBAL TO THE PROGRAM (ONLY NEEDED ONCE FOR ALL INSTANCES OF PROG)
;
;USB is flaky and unreliable.  A good portion of the code is here because
;  USB hardware is unpredictable and, to be quite frank, does not actually
;  meet the USB specifications.  Even in my limited exposure to the USB
;  Devices (perhaps a couple of dozen different devices), almost all of them
;  have "quirks" that they shouldn't have.  Something to also keep in mind
;  is that just because something works underneath Windows does not actually
;  mean it is USB compliant (Windows Drivers do not actually follow the
;  USB specifications).
;Because I have had such limited exposure the USB Devices, I expect that I
;  have not yet seen all of the possible "issues" that can arise when working
;  with USB.  I'm sure more things will pop up in the future that I haven't
;  seen or thought of that will cause sause grief to somebody, and something
;  in here will need to change again to compensate for it.  Such is life in
;  the big city.
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO HANDLE INT 2Dh (Alternate TSR Multiplex)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HAVE INTERRUPT 2Dh RUN THIS PROGRAM EVERY TIME IT OCCURS
;Inputs:  ES = TSR Data Area (Original ES on Stack)
;         AH = Handle number, 00h-FFh
;         AL = Function number
;         Certain Functions also use BX and DX as input
;Outputs: Depends on Function, but may return various combinations of
;           AX, BX, CX, DX, and DI
;Changes:
;NOTES: We would normally have an INT2DHdr here, but because we can have
;         multiple instances of the program with shared code, the header
;         is in the individual instance piece, not the shared instance
;         piece (which is here).
;       Remember that the original ES is ON THE STACK when this code is
;         issued, so we need to restore it!
;------------------------------------------------------------------------------
Int2DCode:
  STI                                 ;Enable Interrupts
  PUSH BP                             ;Save used registers
  CMP  AH,ES:[AMISHandle]             ;Is this our handle?
  JNE >D70                            ;If not, it's not for us
  MOV  BP,BX                          ;Save original BX
  MOV  BX,Int2DFunctionTbl            ;[BX] = Function Lookup table
  CALL SearchByte2WordTblCS           ;Search for the Function Code Offset
  XCHG BX,BP                          ;BX = Original BX, [DI] = Code to Call
  JC  >D40                            ;If not, found, return AL = 0
  CALL BP                             ;Perform the Code
  JMP >D90                            ;Done
D40:                                  ;Function not supported
  XOR  AL,AL                          ;Return AL = 0
  JMP >D90                            ;Done
D70:                                  ;Not for us
  CMP  W ES:[Int2DHdr].OldVector[2],0 ;Is the Old Vector valid?
  JE  >D90                            ;If not, we're done
  POP  BP                             ;Restore used registers

  PUSH BP,BP                          ;Reserve space on stack for Segment:Offset
  PUSH BP                             ;Save used registers
  MOV  BP,SP                          ;Point at the stack
  PUSH AX                             ;Save used registers
  PUSHF                               ;Get the
  POP  AX                             ;  current flags
  CLI                                 ;Disable interrupts
  XCHG SS:[BP+6],AX                   ;Put flags on stack, get original ES
  PUSH D ES:[Int2DHdr].OldVector      ;Put the next vector pointer
  POP  D SS:[BP+2]                    ;  on the stack
  MOV  ES,AX                          ;Restore original ES
  POP  AX                             ;Restore used registers
  POP  BP                             ;Restore used registers
  IRET                                ;Jump to the previous Interrupt Handler

D90:                                  ;Done
  POP  BP                             ;Restore used registers
  POP  ES                             ;Restore original ES from stack
  IRET

;------------------------------------------------------------------------------
;PROCESS SUPPORTED AMIS FUNCTIONS
;Inputs:  ES = TSR Data Area
;         AH = Handle Number
;         AL = Function Number
;Outputs: Depends on Function, may change AX, BX, CX, DX
;Changes:
;------------------------------------------------------------------------------
DoAMISInstallChk:
  DEC  AL             ;AL = -1 (Installed)
  MOV  CX,AMISVersion ;CX = Version
  MOV  DX,ES          ;DX:[DI] =
  MOV  DI,AMISMfgName ;  Product ID strings
  RET

DoAMISGetInts:
;  MOV  AL,AMISIntList ;AL = Interrupt List (Same as Input)
  MOV  DX,ES          ;DX:[BX] =
  MOV  BX,IntNumTable ;  Interrupt Table
  RET

DoAMISUninstall:
  MOV  AL,AMISUnNoSuccess ;AL = Unsuccessful Uninstall
  RET

DoAMISGetPCIIndex:
  XOR  AL,AL                  ;AL = Success
  MOV  BX,ES:[PCISearchIndex] ;BX = PCI Search Index
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO HANDLE INT 14h (SERIAL SERVICES)
;THIS IS THE PLACE WHERE ALL USB REQUESTS ARE MADE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;CODE FOR INTERRUPT 14h (SERIAL SERVICES)
;Inputs:  ES = TSR Data Area (Original ES on Stack)
;         AX = 5000h (Install Check) or 5001h (Regular Function)
;         BX = "US"
;         CX = "B!"
;         DS:[DX] = Data Structure (for Regular Function)
;Outputs: CF = Clear if Valid Function
;              AX = 0
;              Various values in BX, CX, and DX, Depending on Call Type
;            = Set if Error
;              Error Code in AX
;              BX = CX = DX = 0
;Changes: Intercepts various Serial calls, "translating" them into USB calls
;           as appropriate
;------------------------------------------------------------------------------
Int14Code:
  PUSH BP                           ;Save used registers
  PUSHF                             ;Save flags
  STI                               ;Enable interrupts
  CLD                               ;Go forward with string functions
  CALL MakeStack                    ;  our own
  CMP  BX,'US'                      ;Is it for us?
  JNE  Int14Old                     ;If not, quit
  CMP  CX,'B!'                      ;Is it for us?
  JNE  Int14Old                     ;If not quit
  CMP  AX,5000h                     ;Is it the Install Check?
  JNE >F10                          ;If not, try a regular function
  XOR  AX,AX                        ;If OK,
  XCHG BX,CX                        ;  set return registers
  JMP >F80                          ;Return with CF Clear
F10:                                ;Not Install Check
  CMP  AX,5001h                     ;Is it a Regular Function?
  JNE  Int14Old                     ;If not, it's not for us
  CALL TestHostIndexValidity        ;See if the Host Index is even valid
  JC  >F70                          ;If invalid Host, Error
                                    ;Returns BP = Error Code, sets BX=CX=DX=0
  CALL TestHostIndex                ;See if it's for this Host or All hosts
  JNZ  Int14Old                     ;If not, quit
  CALL DoInt14Function              ;If so, see what it is
                                    ;  Returns with BP = Error Code
  JNC >F80                          ;If it worked, we're done
F70:                                ;Return with Error (Carry Flag Set)
  CALL ReturnStack                  ;Restore Stack Space
  MOV  AX,BP                        ;Put Error Code in AX
  MOV  BP,SP                        ;Point BP at the stack
  OR   B SS:[BP+10],CarryFlag       ;Set Carry Flag for the return
  JMP >F90                          ;We're done
F80:                                ;Return with OK (Carry Flag Clear)
  CALL ReturnStack                  ;Restore Stack Space
  XOR  AX,AX                        ;Error Code = 0
  MOV  BP,SP                        ;Point BP at the stack
  AND  B SS:[BP+10],(NOT CarryFlag) ;Clear Carry Flag for the return
F90:                                ;We're done
  POPF                              ;Restore flags
  POP  BP                           ;Restore used registers
  POP  ES                           ;Restore used registers
  IRET

Int14Old:                           ;It's not for us!
  CALL ReturnStack                  ;Restore Stack Space
  POPF                              ;Restore flags
  POP  BP                           ;Restore used registers

  PUSH BP,BP                        ;Reserve space on stack for Segment:Offset
  PUSH BP                           ;Save used registers
  MOV  BP,SP                        ;Point at the stack
  PUSH AX                           ;Save used registers
  PUSHF                             ;Get the
  POP  AX                           ;  current flags
  CLI                               ;Disable interrupts
  XCHG SS:[BP+6],AX                 ;Put flags on stack, get original ES
  PUSH D ES:[Int14Hdr].OldVector    ;Put the next vector pointer
  POP  D SS:[BP+2]                  ;  on the stack
  MOV  ES,AX                        ;Restore original ES
  POP  AX                           ;Restore used registers
  POP  BP                           ;Restore used registers
  IRET                              ;Jump to the previous Interrupt Handler

;------------------------------------------------------------------------------
;SEE IF THE HOST INDEX REFERS TO A VALID (EXISTING) HOST OR NOT
;Inputs:  DS:[DX] = USB Data Call Structure
;         ES      = TSR Data Area
;Outputs: CF = Clear if it's a valid Host Index
;              BX ,CX ,DX Unchanged
;            = Set if Host does not exist
;              BX = CX = DX = -1
;Changes:
;------------------------------------------------------------------------------
TestHostIndexValidity:
  PUSH AX,SI                 ;Restore used registers
  MOV  SI,DX                 ;Point at Request Data
  MOV  AL,[SI].I14RHostIndex ;Get the Host Index from the Request
  CMP  AL,AllHostsIndex      ;Is it Any/All Hosts?
  JE  >V80                   ;If so, it's OK
  CMP  AL,(MaxHosts-1)       ;Is it in the valid range?
  JA  >V70                   ;If not, it's an error
  CALL HostIndex2BitMask     ;Convert the Index to a Bit Mask
  TEST AX,CS:[HostIndexes]   ;Is it an existing Host?
  JNZ >V80                   ;If so, it's OK
V70:                         ;Error - Invalid Host Index
  MOV  BX,-1                 ;Set
  MOV  CX,BX                 ;  all
  MOV  DX,BX                 ;  return
  MOV  BP,I14RErrHostIndex   ;  registers
  STC                        ;Set error flag
  JMP >V90                   ;Done
V80:                         ;Valid Host Index
  CLC                        ;Set OK Flag
V90:                         ;Done
  POP  SI,AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A HOST INDEX NUMBER (0-15) TO A HOST INDEX BIT-MASK
;Inputs:  AL = Host Index Number (0-15)
;         ES = TSR Data Area
;Outputs: AX = Host Number as a Bit Mask (for [HostIndexes] Word)
;Changes:
;NOTES: Does NOT check AL for validity!
;------------------------------------------------------------------------------
HostIndex2BitMask:
  PUSH CX    ;Save used registers
  MOV  CL,AL ;Put Index into Shift Register
  MOV  AX,1  ;Start with Bit 0
  SHL  AX,CL ;Shift over by the correct Amount
  POP  CX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEE IF THE HOST INDEX MATCHES US OR NOT (IF WE'RE SUPPOSED TO RESPOND)
;Inputs:  DS:[DX] = USB Data Call Structure
;         ES      = TSR Data Area
;Outputs: ZF = Set if it's for us, or for All Hosts
;            = Clear if not for Us and not for All Hosts
;Changes:
;------------------------------------------------------------------------------
TestHostIndex:
  PUSH AX,BX                 ;Save used registers
  MOV  BX,DX                 ;Point at Request data
  MOV  AL,[BX].I14RHostIndex ;Get Host Index
  CMP  AL,ES:[USBHostIndex]  ;Is it for us?
  JE  >H90                   ;If so, it's OK
  CMP  AL,AllHostsIndex      ;Is it Any/All Hosts?
H90:                         ;Done
  POP  BX,AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEE WHAT KIND OF USB FUNCTION TO PERFORM, AND DO IT
;Inputs:  DS:[DX] = Int 14h Request Structure
;         ES      = TSR Data Area
;Outputs: CF = Clear if data structure is valid
;              BX, CX, DX = Return values appropriate for call
;            = Set if not
;              BP = Appropriate Error Code
;              BX, CX, DX will be UNDEFINED!
;Changes: Initiates/Performs the appropriate USB Function
;NOTES:  If no error, (Error Code will be 0), we do NOT change BP
;        Only if there is an error do we return the code in BP!
;------------------------------------------------------------------------------
DoInt14Function:
  PUSH AX,DI,SI                ;Save used registers
  MOV  SI,DX                   ;Point DS:[SI] at the USB call structure
  MOV  CX,-1                   ;  Return CX = DX = -1
  MOV  DX,CX                   ;  by Default
  MOV  DI,CX                   ;Will Return BX = -1 by Default
  MOV  AH,[SI].I14RHostIndex   ;Get the Host Index
  MOV  AL,[SI].I14RRequestType ;Get the Request Type
  MOV  BX,Int14FunctionTbl     ;Point at the Function table to search
  CALL SearchByte2WordTblCS    ;Look for the function
  XCHG DI,BX                   ;Put Call Address in DI, BX = 0
  JC  >I70                     ;If invalid function, it's an error
  CALL DI                      ;If OK, do the appropriate function
  JNC >I80                     ;If it worked OK, we're done
I70:                           ;Error
  STC                          ;Set the error flag
  JMP >I90                     ;We're done
I80:                           ;OK
  CLC                          ;Set the OK flag
I90:                           ;We're done
  POP  SI,DI,AX                ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO START/STOP/RESET/SUSPEND/RESUME/DEBUG/SINGLESTEP THE HOST
;These processes can take awhile to perform (several hundred milliseconds),
;  so we handle them using an interrupt-based timer (INT 08) as a
;  background process.
;We cannot use the USB Bus itself as the timer, because during some of
;  these processes (like Resetting or Stopping the Host) the USB Bus
;  does not generate Frame Timing.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO START/STOP/RESET/SUSPEND/RESUME/DEBUG/SST THE HOST
;Inputs:  DS:[SI] = Int 14h Request Structure
;         ES      = TSR Data area
;         AH      = HostIndex (-1 or ours)
;         AL      = Int14RRequestType (Host Run)
;         BX = CX = DX = -1
;Outputs: CF = Clear If OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;NOTES: If necessary, this will send a Global Resume signal before Enabling
;         the Host.
;------------------------------------------------------------------------------
HostRun:
  PUSH BX,DX                          ;Save used registers
  MOV  BX,OFFSET HostRunHandle        ;Handle Storage Area
  MOV  DX,HostRunGo                   ;Code to Call
  JMP >H00                            ;Do it
HostStop:
  PUSH BX,DX                          ;Save used registers
  MOV  BX,OFFSET HostStopHandle       ;Handle Storage Area
  MOV  DX,HostStopGo                  ;Code to Call
  JMP >H00                            ;Do it
HostReset:
  PUSH BX,DX                          ;Save used registers
  MOV  BX,OFFSET HostResetHandle      ;Handle Storage Area
  MOV  DX,HostResetGo                 ;Code to Call
  JMP >H00                            ;Do it
HostSuspend:
  PUSH BX,DX                          ;Save used registers
  MOV  BX,OFFSET HostSuspendHandle    ;Handle Storage Area
  MOV  DX,HostSuspendGo               ;Code to Call
  JMP >H00                            ;Do it
HostResume:
  PUSH BX,DX                          ;Save used registers
  MOV  BX,OFFSET HostResumeHandle     ;Handle Storage Area
  MOV  DX,HostResumeGo                ;Code to Call
  JMP >H00                            ;Do it
HostDebug:
  PUSH BX,DX                          ;Save used registers
  MOV  BX,OFFSET HostDebugHandle      ;Handle Storage Area
  MOV  DX,HostDebugGo                 ;Code to Call
  JMP >H00                            ;Do it
HostSingleStep:
  PUSH BX,DX                          ;Save used registers
  MOV  BX,OFFSET HostSSTHandle        ;Handle Storage Area
  MOV  DX,HostSSTGo                   ;Code to Call
  JMP >H00                            ;Do it
H00:
  PUSH EAX,CX,DI                      ;Save used registers
  CALL DoAllHostsFunction             ;Do it for all Hosts, if Necessary
  JC  >H80                            ;If it was for all Hosts, done
  MOV  BP,I14RErrHostCallInUse        ;Assume Call is already running
  CMP  W ES:[BX],-1                   ;Is it Already Running?
  JNE >H70                            ;If so, Error
  MOV  BP,I14RErrResources            ;Assume Resource Problem
  CALL GetAvailLC                     ;Get Large Call Table Entry (CX & DI)
                                      ;  CL = Handle, CH = Host Index
  JC  >H70                            ;If error, quit
  MOV  ES:[BX],CX                     ;Store the Handle Number & Host Index
  MOV  EAX,[SI].I14RCallBackAddr      ;Copy the
  MOV  ES:[DI].LCCallBackAddr,EAX     ;  Call Back Address
  MOV  AX,[SI].I14RUserPktID          ;Copy the
  MOV  ES:[DI].LCUserPktID,AX         ;  User Packet ID
  MOV  AL,ES:[USBHostIndex]           ;Copy the
  MOV  B ES:[DI].LCOwnerCallCX[0],AL  ;  Host Index
  OR   ES:[DI].LCFlags,LCFlagHostCall ;Mark as a Host Call
  CALL DX                             ;Do the function
  JNC >H80                            ;If it worked, we're done
H70:                                  ;Error
  STC                                 ;Set Error Flag
  JMP >H90                            ;Done
H80:                                  ;OK
  CLC                                 ;Set OK Flag
H90:                                  ;Done
  POP  DI,CX,EAX                      ;Restore used registers
  POP  DX,BX                          ;Restore used registers
  RET

;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;START (RUN) THE HOST
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO START THE HOST RUNNING
;Inputs:  DS:[SI] = Int 14h Request Structure
;         ES      = TSR Data area
;         ES:[DI] = Large Call Table Entry
;         ES:[BX] = Handle Number
;         CX      = Large Call Handle Number (filled in)
;         DX      = 0
;         ES:[HostRunHandle] Stored
;Outputs: CF = Clear If OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;NOTES: This will return right away as successful if Host is already Running.
;------------------------------------------------------------------------------
HostRunGo:
  PUSH AX,BX,CX,DX,DS      ;Save used registers
  MOV  DS,ES               ;Point DS at TSR Data
  MOV  DX,BX               ;[DX] = Handle Number
  MOV  [DI].LCOwnerCallAX,OwnerCallHostRun ;Mark Large Call as Run
  MOV  BL,USBIntEnable     ;Enable
  MOV  AX,-1               ;  all
  CALL WriteHostWord       ;  interrupt types
  CALL ReadUSBCommandWord  ;Read the USB Command Register
  TEST AL,UCGlobalSuspend  ;Are we in Global Suspend Mode?
  JNZ >R30                 ;If so, jump to Handle it
  CALL TestHostHalted      ;Is the Host Halted?
  JZ  >R80                 ;If not, it's already Running!
  MOV  AX,(UCRunStop+UCConfigured+UCMaxPkt64) ;Start the
  CALL WriteUSBCommandWord ;  Host Running
  MOV  AX,HostRunDone      ;Where to go when done
  CALL ScheduleInt08Dly2   ;Schedule 2 Timer Tick Delay (55-110ms)
  JMP >R85                 ;Done
R30:                       ;Global Suspend Mode
  MOV  AL,I14RRTHostResume ;Request = Host Resume
  MOV  BX,HostRunResumed   ;Where to go when done
  CALL HostCallInt14Req    ;Do it
  JMP >R85                 ;Done
R80:                       ;It's already Running
  CALL FinishHostCallOK    ;Finish up Host Call
R85:                       ;Call is OK
  CLC                      ;Set the OK flag
  POP  DS,DX,CX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;------------------------------------------------------------------------------
HostRunResumed:
  CALL CopyBX2DSES             ;Point DS & ES at correct Data Area
  MOV  DX,OFFSET HostRunHandle ;[DX] = Run Handle
  JNZ >E70                     ;If so, we're done
  MOV  AX,(UCRunStop+UCConfigured+UCMaxPkt64) ;Start
  CALL WriteUSBCommandWord     ;  it Running
  MOV  AX,HostRunDone          ;Where to go when done
  CALL ScheduleInt08Dly2       ;Schedule 2 Timer Tick Delay (55-110ms)
  JNC >E90                     ;If Delay is scheduled, quit
E70:                           ;Error
  CALL FinishHostCallErr       ;Tell host that we're done
E90:                           ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;------------------------------------------------------------------------------
HostRunDone:
  CALL CopyBX2DSES             ;Point DS & ES at correct Data Area
  MOV  DX,OFFSET HostRunHandle ;[DX] = Run Handle
  CALL TestHostHalted          ;Is the Host Halted?
  JZ  >D80                     ;If not, we're done
D70:                           ;Error
  CALL FinishHostCallErr       ;Tell host that we're done
  JMP >D90                     ;Done
D80:                           ;OK
  CALL FinishHostCallOK        ;Tell host that we're done
D90:                           ;Done
  RETF


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;STOP THE HOST
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO STOP (HALT) THE HOST
;Inputs:  DS:[SI] = Int 14h Request Structure
;         ES      = TSR Data area
;         ES:[DI] = Large Call Table Entry
;         ES:[BX] = Handle Number
;         CX      = Large Call Handle Number (filled in)
;         DX      = 0
;         ES:[HostStopHandle] Stored
;Outputs: CF = Clear If OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;NOTES: This will return right away as successful if Host is already Stopped.
;------------------------------------------------------------------------------
HostStopGo:
  PUSH AX,BX,DX,DS        ;Save used registers
  MOV  DS,ES              ;Point DS at TSR Data
  MOV  DX,BX              ;[DX] = Handle Number
  MOV  [DI].LCOwnerCallAX,OwnerCallHostStop ;Mark Large Call as Stop
  CALL TestHostHalted     ;Is it already Halted?
  JNZ >S80                ;If so, we're done
  MOV  BL,USBIntEnable    ;Enable all interrupt types
  MOV  AX,-1              ;  to make sure all pending
  CALL WriteHostWord      ;  interrupts are cleared
  MOV  AX,HostStopIntsClr ;Code to Call when Done
  CALL ScheduleInt08Dly2  ;Schedule 2 Timer Tick Delay (55-110ms)
  JMP >S85                ;Done
S80:                      ;It's already Halted
  CALL FinishHostCallOK   ;Finish up Host Call
S85:                      ;Call is OK
  CLC                     ;Set the OK flag
  POP  DS,DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;------------------------------------------------------------------------------
HostStopIntsClr:
  CALL CopyBX2DSES              ;Point DS & ES at correct Data Area
  MOV  DX,OFFSET HostStopHandle ;[DX] = Stop Handle
  CALL ReadUSBCommandWord       ;Read the USB Command Register
  AND  AL,(NOT UCRunStop)       ;Stop the Host
  CALL WriteUSBCommandWord      ;Write the USB Command Register
  MOV  AX,HostStopDone          ;Where to go when done
  CALL ScheduleInt08Dly2        ;Schedule 2 Timer Tick Delay (55-110ms)
  JNC >C90                      ;If Delay is scheduled, quit
C70:                            ;Error
  CALL FinishHostCallErr        ;Tell host that we're done
C90:                            ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;------------------------------------------------------------------------------
HostStopDone:
  CALL CopyBX2DSES       ;Point DS & ES at correct Data Area
  MOV  DX,OFFSET HostStopHandle ;[DX] = Stop Handle
  CALL TestHostHalted    ;Is it Halted?
  JNZ >D80               ;If so, we're done
D70:                     ;Error
  CALL FinishHostCallErr ;Tell host that we're done
  JMP >D90               ;Done
D80:                     ;OK
  CALL FinishHostCallOK  ;Tell host that we're done
D90:                     ;Done
  RETF


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;RESET THE HOST (ALSO STARTS IT RUNNING AGAIN)
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO RESET THE HOST
;Inputs:  DS:[SI] = Int 14h Request Structure
;         ES      = TSR Data area
;         ES:[DI] = Large Call Table Entry
;         ES:[BX] = Handle Number
;         CX      = Large Call Handle Number (filled in)
;         DX      = 0
;         ES:[HostResetHandle] Stored
;Outputs: CF = Clear If OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
HostResetGo:
  PUSH AX,BX,DX,DS             ;Save used registers
  MOV  DS,ES                   ;Point DS at TSR Data
  MOV  DX,BX                   ;[DX] = Handle Number
  MOV  BL,SOFModify            ;Save Original
  CALL ReadHostByte            ;  Timing Value
  MOV  [HostResetSOFModify],AL ;  (SOF Modify Register)
  CALL GetFrameNumber          ;Save Original
  MOV  [HostResetFrameNum],AX  ;  Frame Number
  MOV  [DI].LCOwnerCallAX,OwnerCallHostReset ;Mark Large Call as Reset
  MOV  AL,I14RRTHostStop       ;Request = Host Stop
  MOV  BX,HostResetStopped     ;Where to go when done
  CALL HostCallInt14Req        ;Do it (returns CF)
  POP  DS,DX,BX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;------------------------------------------------------------------------------
HostResetStopped:
  CALL CopyBX2DSES               ;Point DS & ES at correct Data Area
  MOV  DX,OFFSET HostResetHandle ;[DX] = Reset Handle
  JNZ >P70                       ;If so, we're done
  CALL RemoveAllAddresses        ;Remove all Device Addresses
  CALL ReadUSBCommandWord        ;Read the USB Command Register
  OR   AL,UCGlobalReset          ;Do a Global Reset
  CALL WriteUSBCommandWord       ;Write the USB Command Register
  MOV  AX,HostResetting          ;Where to go when done
  CALL ScheduleInt08Dly2         ;Schedule 2 Timer Tick Delay (55-110ms)
  JNC >P90                       ;If Delay is scheduled, quit
P70:                             ;Error
  CALL FinishHostCallErr         ;Tell host that we're done
P90:                             ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;------------------------------------------------------------------------------
HostResetting:
  CALL CopyBX2DSES               ;Point DS & ES at correct Data Area
  MOV [PtConnLastTime],0         ;Reset Root Hub Connect Status
                                 ;  (needed for Dell computer to work properly)
  MOV  DX,OFFSET HostResetHandle ;[DX] = Reset Handle
  CALL ReadUSBCommandWord        ;Read the USB Command Register
  AND  AL,(NOT UCGlobalReset)    ;Turn off Global Reset
  CALL WriteUSBCommandWord       ;Write the USB Command Register
  MOV  AX,HostResetted           ;Where to go when done
  MOV  CL,3                      ;Delay 3 Timer Ticks (110-165ms)
  CALL ScheduleInt08Delay        ;Do it
  JNC >T90                       ;If Delay is scheduled, quit
T70:                             ;Error
  CALL FinishHostCallErr         ;Tell host that we're done
T90:                             ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;------------------------------------------------------------------------------
HostResetted:
  CALL CopyBX2DSES               ;Point DS & ES at correct Data Area
  MOV  DX,OFFSET HostResetHandle ;[DX] = Reset Handle
  JNZ >H70                       ;If so, we're done
  CALL ReadUSBCommandWord        ;Read the USB Command Register
  TEST AL,UCGlobalReset          ;Has the Reset been completed?
  JNZ >H70                       ;If not, Error
  MOV  EAX,[FLOffsetDW]          ;Point EAX at our Frame List
  MOV  BL,FrameListAddr          ;Point the Frame List Address
  CALL WriteHostDWord            ;  at our Table
  MOV  BL,SOFModify              ;Restore Original
  MOV  AL,[HostResetSOFModify]   ;  Timing Value
  CALL WriteHostByte             ;  (SOF Modify Register)
  MOV  BL,FrameNum               ;Restore Original
  MOV  AX,[HostResetFrameNum]    ;  Frame
  CALL WriteHostWord             ;  Number
  MOV  AL,I14RRTHostRun          ;Request = Host Run
  MOV  BX,HostResetDone          ;Where to go when done
  CALL HostCallInt14Req          ;Do it
  JMP >H90                       ;Done
H70:                             ;Error
  CALL FinishHostCallErr         ;Tell host that we're done
H90:                             ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;------------------------------------------------------------------------------
HostResetDone:
  CALL CopyBX2DSES       ;Point DS & ES at correct Data Area
  MOV  DX,OFFSET HostResetHandle ;[DX] = Reset Handle
  JZ  >D80               ;If not, we're done
D70:                     ;Error
  CALL FinishHostCallErr ;Tell host that we're done
  JMP >D90               ;Done
D80:                     ;OK
  CALL FinishHostCallOK  ;Tell host that we're done
D90:                     ;Done
  RETF


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;SUSPEND THE HOST
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO SUSPEND THE BUS (GLOBAL SUSPEND)
;Inputs:  DS:[SI] = Int 14h Request Structure
;         ES      = TSR Data area
;         ES:[DI] = Large Call Table Entry
;         ES:[BX] = Handle Number
;         CX      = Large Call Handle Number (filled in)
;         DX      = 0
;         ES:[HostSuspendHandle] Stored
;Outputs: CF = Clear If OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;NOTES: This will return right away as successful if Host is already Suspended.
;------------------------------------------------------------------------------
HostSuspendGo:
  PUSH AX,BX,CX,DX,DS       ;Save used registers
  MOV  DS,ES                ;Point DS at TSR Data
  MOV  DX,BX                ;[DX] = Handle Number
  MOV  [DI].LCOwnerCallAX,OwnerCallHostSuspend ;Mark Large Call as Suspend
  CALL TestHostHalted       ;Is it Halted?
  JZ  >S30                  ;If not, jump to handle it
  CALL ReadUSBCommandWord   ;Read the USB Command Register
  TEST AL,UCGlobalSuspend   ;Already Suspended?
  JNZ >S80                  ;If so, we're done
S10:                        ;Host is Halted, not Suspended
  OR   AL,UCGlobalSuspend   ;Suspend
  CALL WriteUSBCommandWord  ;Write the USB Command Register
  MOV  AX,HostSuspendDone   ;Where to go when done
  CALL ScheduleInt08Dly2    ;Schedule 2 Timer Tick Delay (55-110ms)
  JMP >S85                  ;Done
S30:                        ;Host is not Halted
  MOV  AL,I14RRTHostStop    ;Request = Host Stop
  MOV  BX,HostSuspendHalted ;Where to go when done
  CALL HostCallInt14Req     ;Send it
  CALL DoInt14CallSI        ;Do it
  JMP >S85                  ;Done
S80:                        ;It's already Halted
  CALL FinishHostCallOK     ;Finish up Host Call
S85:                        ;Call is OK
  CLC                       ;Set the OK flag
  POP  DS,DX,CX,BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;------------------------------------------------------------------------------
HostSuspendHalted:
  CALL CopyBX2DSES         ;Point DS & ES at correct Data Area
  MOV  DX,OFFSET HostSuspendHandle ;[DX] = Suspend Handle
  JNZ >H70                 ;If so, we're done
  CALL ReadUSBCommandWord  ;Read the USB Command Register
  OR   AL,UCGlobalSuspend  ;Suspend the Host
  CALL WriteUSBCommandWord ;Write the USB Command Register
  MOV  AX,HostSuspendDone  ;Where to go when done
  CALL ScheduleInt08Dly2   ;Schedule 2 Timer Tick Delay (55-110ms)
  JNC >H90                 ;If Delay is scheduled, quit
H70:                       ;Error
  CALL FinishHostCallErr   ;Tell host that we're done
H90:                       ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;------------------------------------------------------------------------------
HostSuspendDone:
  CALL CopyBX2DSES        ;Point DS & ES at correct Data Area
  MOV  DX,OFFSET HostSuspendHandle ;[DX] = Suspend Handle
  CALL TestHostHalted     ;Is it Halted?
  JZ  >D70                ;If not, Error
  CALL ReadUSBCommandWord ;Read the USB Command Register
  TEST AL,UCGlobalSuspend ;Is the Host Suspended?
  JNZ >D80                ;If so, we're done
D70:                      ;Error
  CALL FinishHostCallErr  ;Tell host that we're done
  JMP >D90                ;Done
D80:                      ;OK
  CALL FinishHostCallOK   ;Tell host that we're done
D90:                      ;Done
  RETF


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;RESUME THE HOST
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO RESUME THE HOST
;Inputs:  DS:[SI] = Int 14h Request Structure
;         ES      = TSR Data area
;         ES:[DI] = Large Call Table Entry
;         ES:[BX] = Handle Number
;         CX      = Large Call Handle Number (filled in)
;         DX      = 0
;         ES:[HostResumeHandle] Stored
;Outputs: CF = Clear If OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;NOTES: This will return right away as successful if Host is not currently
;         in Global Suspend Mode.
;------------------------------------------------------------------------------
HostResumeGo:
  PUSH AX,CX,DX,DS         ;Save used registers
  MOV  DS,ES               ;Point DS at TSR Data
  MOV  DX,BX               ;[DX] = Handle Number
  MOV  [DI].LCOwnerCallAX,OwnerCallHostResume ;Mark Large Call as Resume
  CALL ReadUSBCommandWord  ;Read the USB Command Register
  TEST AL,UCGlobalSuspend  ;Are we in Global Suspend Mode?
  JZ  >R80                 ;If not, we're done
  OR   AL,UCGlobalResume   ;If so, send Global Resume
  CALL WriteUSBCommandWord ;Write the USB Command Register
  MOV  AX,HostResumed      ;Where to go when done
  CALL ScheduleInt08Dly2   ;Schedule 2 Timer Tick Delay (55-110ms)
  JMP >R85                 ;Done
R80:                       ;It's not Suspended
  CALL FinishHostCallOK    ;Finish up Host Call
R85:                       ;Call is OK
  CLC                      ;Set the OK flag
  POP  DS,DX,CX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;------------------------------------------------------------------------------
HostResumed:
  CALL CopyBX2DSES                  ;Point DS & ES at correct Data Area
  MOV  DX,OFFSET HostResumeHandle   ;[DX] = Resume Handle
  MOV  BL,USBCommand                ;Stop the
  MOV  AX,(UCConfigured+UCMaxPkt64) ;  Global Resume
  CALL WriteHostWord                ;  Signal
  MOV  AX,HostResumeDone            ;Where to go when done
  CALL ScheduleInt08Dly2            ;Schedule 2 Timer Tick Delay (55-110ms)
  JNC >E90                          ;If Delay is scheduled, quit
E70:                                ;Error
  CALL FinishHostCallErr            ;Tell host that we're done
E90:                                ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;------------------------------------------------------------------------------
HostResumeDone:
  CALL CopyBX2DSES                ;Point DS & ES at correct Data Area
  MOV  DX,OFFSET HostResumeHandle ;[DX] = Resume Handle
  CALL ReadUSBCommandWord         ;Read the USB Command Register
  TEST AL,(UCGlobalResume+UCGlobalSuspend) ;Is it un-Suspended?
  JZ  >D80                        ;If so, we're done
D70:                              ;Error
  CALL FinishHostCallErr          ;Tell host that we're done
  JMP >D90                        ;Done
D80:                              ;OK
  CALL FinishHostCallOK           ;Tell host that we're done
D90:                              ;Done
  RETF


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;PUT THE HOST INTO DEBUG MODE
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO PUT THE HOST INTO DEBUG MODE
;Inputs:  DS:[SI] = Int 14h Request Structure
;         ES      = TSR Data area
;         ES:[DI] = Large Call Table Entry
;         ES:[BX] = Handle Number
;         CX      = Large Call Handle Number (filled in)
;         DX      = 0
;         ES:[HostResumeHandle] Stored
;Outputs: CF = Clear If OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
HostDebugGo:
  PUSH AX,BX,DX,DS         ;Save used registers
  MOV  DS,ES               ;Point DS at TSR Data
  MOV  DX,BX               ;[DX] = Handle Number
  MOV  [DI].LCOwnerCallAX,OwnerCallHostDebug ;Mark Large Call as Debug
  MOV  AL,I14RRTHostStop   ;Request = Host Stop
  MOV  BX,HostDebugStopped ;Where to go when done
  CALL HostCallInt14Req    ;Send it (Sets CF)
  POP  DS,DX,BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;------------------------------------------------------------------------------
HostDebugStopped:
  CALL CopyBX2DSES         ;Point DS & ES at correct Data Area
  MOV  DX,OFFSET HostDebugHandle ;[DX] = Debug Handle
  JNZ >P70                 ;If so, we're done
  CALL ReadUSBCommandWord  ;Read the USB Command Register
  OR   AL,UCSoftDebug      ;Turn on Debug Mode
  CALL WriteUSBCommandWord ;Read the USB Command Register
  MOV  AX,HostDebugDone    ;Where to go when done
  CALL ScheduleInt08Dly2   ;Schedule 2 Timer Tick Delay (55-110ms)
  JNC >P90                 ;If Delay is scheduled, quit
P70:                       ;Error
  CALL FinishHostCallErr   ;Tell host that we're done
P90:                       ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;------------------------------------------------------------------------------
HostDebugDone:
  CALL CopyBX2DSES       ;Point DS & ES at correct Data Area
  MOV  DX,OFFSET HostDebugHandle ;[DX] = Debug Handle
  CALL TestHostDebug     ;Is the Host in Debug Mode?
  JNZ >D80               ;If so, we're done
D70:                     ;Error
  CALL FinishHostCallErr ;Tell host that we're done
  JMP >D90               ;Done
D80:                     ;OK
  CALL FinishHostCallOK  ;Tell host that we're done
D90:                     ;Done
  RETF


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;SINGLESTEP THE HOST
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO SINGLESTEP THE HOST
;Inputs:  DS:[SI] = Int 14h Request Structure
;         ES      = TSR Data area
;         ES:[DI] = Large Call Table Entry
;         ES:[BX] = Handle Number
;         CX      = Large Call Handle Number (filled in)
;         DX      = 0
;         ES:[HostResumeHandle] Stored
;Outputs: CF = Clear If OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;NOTES: This will return right away with an Error if the Host is not
;         in Debug Mode.
;------------------------------------------------------------------------------
HostSSTGo:
  PUSH AX,BX,CX,DX,DS       ;Save used registers
  MOV  DS,ES                ;Point DS at TSR Data
  MOV  DX,BX                ;[DX] = Handle Number
  MOV  [DI].LCOwnerCallAX,OwnerCallHostSST ;Mark Large Call as SST
  CALL TestHostHalted       ;Host Halted?
  JZ  >T80                  ;If not, Error
  CALL TestHostDebug        ;Debug Mode?
  JZ  >T80                  ;If not, Error
  CALL GetFrameNumber       ;Get Current Frame Number
  MOV  [HostSSTFrameNum],AX ;Save it
  CALL HostSSTSetRun        ;Set the Host to Run
  MOV  AX,HostSSTRun1       ;Where to go when done
  CALL ScheduleInt08Dly2    ;Schedule 2 Timer Tick Delay (55-110ms)
  JNC >T85                  ;If it worked, quit
T80:                        ;Host is Running
  CALL FinishHostCallErr    ;Finish up Host Call
  STC                       ;Set error Flag
  JMP >T90                  ;Done
T85:                        ;Call is OK
  CLC                       ;Set the OK flag
T90:                        ;Done
  POP  DS,DX,CX,BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;------------------------------------------------------------------------------
HostSSTRun1:
  XOR  CL,CL                     ;Mark as first try
  JMP >U00                       ;Continue
HostSSTRun2:
  MOV  CL,-1                     ;Mark as second try
;  JMP >U00                       ;Continue
U00:
  CALL CopyBX2DSES               ;Point DS & ES at correct Data Area
  MOV  DX,OFFSET HostDebugHandle ;[DX] = Debug Handle
  CALL TestHostHalted            ;Host Halted?
  JZ  >U70                       ;If not, it didn't work
  CALL GetFrameNumber            ;Did the
  CMP  AX,[HostSSTFrameNum]      ;  Frame Number change?
  JNE >U80                       ;If so, we're done
  OR   CL,CL                     ;Is this the second try?
  JNZ >U70                       ;If so, it didn't work
  CALL HostSSTSetRun             ;Set the Host to Run (Second Try)
  MOV  AX,HostSSTRun2            ;Where to go when done
  CALL ScheduleInt08Dly2         ;Schedule 2 Timer Tick Delay (55-110ms)
  JNC >U90                       ;If it worked, quit
U70:                             ;Error
  CALL FinishHostCallErr         ;Tell host that we're done
  JMP >U90                       ;Done
U80:                             ;OK
  CALL FinishHostCallOK          ;Tell Host that we're done
U90:                             ;Done
  RETF

HostSSTSetRun:
  PUSH AX                  ;Save used registers
  CALL ReadUSBCommandWord  ;Read the USB Command Register
  OR   AL,UCRunStop        ;Set the Run/Stop Bit to Run
  CALL WriteUSBCommandWord ;Write the USB Command Register
  POP  AX                  ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT FUNCTIONS NEEDED FOR HOST ENABLE/DISABLE/ETC.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SET UP AND ISSUE AN INT 14 REQUEST AS PART OF A HOST CALL
;Inputs:  DS = ES = TSR Data Area
;          AL  = I14RRequestType to issue
;          BX  = Return Address Offset
;         [DX] = Handle Number to return
;Outputs: CF = Clear if Request was issued OK
;         CF = Set if Request Failed
;              Automatically calls FinishHostCallErr
;Changes:
;------------------------------------------------------------------------------
HostCallInt14Req:
  PUSH AX,SI                         ;Save used registers
  MOV  SI,Int14Request5              ;Point at Request
  MOV  [SI].I14RRequestType,AL       ;Store Request Type
  MOV  W [SI].I14RCallBackAddr[0],BX ;Store Call Back Address
  CALL DoInt14CallSI                 ;Do it
  JNC >F80                           ;If it worked, we're done
F70:                                 ;Error
  CALL FinishHostCallErr             ;Tell the Host that we're done
  STC                                ;Set return flag
  JMP >F90                           ;Done
F80:                                 ;OK
  CLC                                ;Set return flag
F90:                                 ;Done
  POP  SI,AX                         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FINISH UP A HOST CALL (TELL HOST DRIVER THAT IT IS COMPLETED)
;Inputs:  [DX] = Handle Number to return
;Outputs: Informs Host Driver that the Host Call is Complete
;         Resets Handle Number ([DX]) to -1 when done
;Changes: AX, SI
;------------------------------------------------------------------------------
FinishHostCallOK:
  PUSH AX                             ;Save used registers
  XOR  AX,AX                          ;Error Code = 0
  JMP >F00                            ;Do it
FinishHostCallErr:
  PUSH AX                             ;Save used registers
  MOV  AX,TDStsLargeCallErr           ;Error Code = Large Call
;  JMP >F00                            ;Do it
F00:
  PUSH BX,SI                          ;Save used registers
  MOV  SI,Int14Request5               ;Point at Request Structure
  MOV  [SI].I14RRequestType,I14RRTLargeCallDone ;Request Type = Large Call Done
  MOV  W [SI].I14RLargeCallRtnCode,AX ;Return Code = AX
  MOV  BX,DX                          ;Store
  MOV  AX,[BX]                        ;  the
  MOV  [SI].I14RRequestHandle,AX      ;  Handle Number
  CALL DoInt14CallSI                  ;Tell the Host we're done
  MOV  W [BX],-1                      ;Mark us as Done
  POP  SI,BX                          ;Restore used registers
  POP  AX                             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEE IF THE HOST CONTROLLER HAS BEEN STOPPED OR NOT
;Inputs:  ES = TSR Data Area
;Outputs: ZF = Clear if the Host is Halted
;            = Set if it's Running
;Changes:
;------------------------------------------------------------------------------
TestHostHalted:
  PUSH AX,BX           ;Save used registers
  MOV  BL,USBStatus    ;Read the
  CALL ReadHostWord    ;  Host Status
  TEST AL,USHostHalted ;Is the Halted bit set?
  POP  BX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEE IF THE HOST CONTROLLER IS IN DEBUG MODE OR NOT
;Inputs:  ES = TSR Data Area
;Outputs: ZF = Clear if the Host is in Debug Mode
;            = Set if it's not
;Changes:
;------------------------------------------------------------------------------
TestHostDebug:
  PUSH AX                 ;Save used registers
  CALL ReadUSBCommandWord ;Read the USB Command Register
  TEST AL,UCSoftDebug     ;Is the Debug bit set?
  POP  AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEE IF THE HOST IS IN GLOBAL SUSPEND MODE
;Inputs:  ES = TSR Data Area
;Outputs: ZF = Clear if the Host is in Global Suspend Mode
;            = Set if it's not
;Changes:
;------------------------------------------------------------------------------
TestGlobalSuspend:
  PUSH AX                 ;Save used registers
  CALL ReadUSBCommandWord ;Read the USB Command Register
  TEST AL,UCGlobalSuspend ;Is the Global Suspend bit set?
  POP  AX                 ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS HOST CHANGES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO ADD OR DELETE A NEW HOST INDEX TO OUR HOST INDEX TABLE
;Inputs:  DS:[SI] = USB Data Call Structure
;         ES      = TSR Data area
;         AH      = HostIndex (-1 or ours)
;         AL      = Int14RRequestType (Add/Delete Host Index)
;Outputs: Adds/Deletes Host Index to our Table
;         CF = Clear if OK (Host Added/Deleted to Table)
;              BP = Undefined
;            = Set if Error
;              BP = Error Code (Bad Host Index)
;         Also Notifies all Registered Device & Device 0 Owners
;Changes:
;------------------------------------------------------------------------------
AddHostIndex:
  PUSH CX                      ;Save used registers
  MOV  CL,-1                   ;Mark as an Add
  JMP >I00                     ;Do it
DeleteHostIndex:
  PUSH CX                      ;Save used registers
  XOR  CL,CL                   ;Mark as a delete
;  JMP >I00                     ;Do it
I00:
  PUSH AX,BX,DX                ;Save used registers
  CALL DoAllHostsFunction      ;Do it for all Hosts, if Necessary
  JC  >I80                     ;If it was for all Hosts, we're done
  MOV  BP,I14RErrHostIndex     ;Assume Bad Host Index
  MOV  BX,CS:[HostIndexes]     ;Get current Table
  MOV  AL,[SI].I14RConfigValue ;Get Host Index to Add/Delete
  MOV  DL,AL                   ;Save it in DL
  CMP  AL,(MaxHosts-1)         ;Is it valid?
  JA  >I70                     ;If not, error
  CALL HostIndex2BitMask       ;If so, convert it to a bit mask (AX)
  OR   CL,CL                   ;Is it Add or Delete?
  JNZ >I20                     ;If Add, jump to handle it
I10:                           ;Delete
  NOT  AX                      ;Delete
  AND  BX,AX                   ;  it
  MOV  AX,OwnerCallHostDisc    ;Function = Disconnect Host
  JMP >I30                     ;Done
I20:                           ;Add
  OR   BX,AX                   ;Add it
  MOV  AX,OwnerCallNewHost     ;Function = New Host
I30:                           ;Notify Devices (AX = Function, DL = Host Index)
  MOV  CS:[HostIndexes],BX     ;Update the Table
  CALL NotifyDvcOwnersOfHost   ;Notify all Registered Owners of Host Change
  JMP >I80                     ;Done
I70:                           ;Error
  STC                          ;Set error flag
  JMP >I90                     ;Done
I80:                           ;OK
  CLC                          ;Set OK flag
I90:                           ;Done
  POP  DX,BX,AX                ;Restore used registers
  POP  CX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;NOTIFY ALL REGISTERED DEVICE OWNERS OF HOST ATTACHMENT/REMOVAL/ERROR
;Inputs:  ES = TSR Data Area
;         AX = Ower Call Code to issue (Host Added/Removed/Error)
;         DL = Host Index Issue is regarding
;Outputs: Notifies All Interface, Device 0, and Timing Owners of Host Issue
;Changes:
;------------------------------------------------------------------------------
NotifyDvcOwnersOfHost:
  PUSH BX,CX,DX            ;Save used registers
  MOV  CL,DL               ;CL = Host Index
  XOR  CH,CH               ;CH = 0
  XOR  DX,DX               ;DX = 0
  CALL NotifyIntfOwnersAll ;Notify All Interface Owners
  CALL NotifyTimingOwner   ;Notify the Timing Owner
  CALL NotifyDvc0Owners    ;Notify Device 0 Owners
H90:                       ;Done
  POP  DX,CX,BX            ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS BUS TIMING CHANGES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;NOTIFY TIMING OWNER THAT SOMETHING HAPPENED
;Inputs:  ES = TSR Data Area
;         AX = Value to put in AX for Far Call (Owner Call Code)
;         CX = Value to put in CX for Far Call
;         DX = Value to put in DX for Far Call
;Outputs: Notifies Timing Owner, using values in AX, CX, DX
;         Puts [TimingUserPktID] in BX before Call
;Changes:
;------------------------------------------------------------------------------
NotifyTimingOwner:
  PUSH BX,DI,DS                     ;Save used registers
  MOV  DS,ES                        ;Point DS at TSR Data Area
  MOV  DI,OFFSET TimingCallBackAddr ;[DI] = Timing Call Back Address
  CMP  D [DI],0                     ;Is the Timing even owned?
  JE  >T90                          ;If not, Quit
  MOV  BX,[TimingUserPktID]         ;If so, BX = User packet ID to use
  CALL DoFarCall                    ;Do the Far Call
T90:                                ;Done
  POP  DS,DI,BX                     ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO NOTIFY INTERFACE OWNERS OF CHANGES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;NOTIFY INTERFACE OWNER(S) THAT SOMETHING HAPPENED
;Inputs:  ES = TSR Data Area
;         AX = Value to put in AX for Far Call (Owner Call Code)
;         CX = Value to put in CX for Far Call
;         DX = Value to put in DX for Far Call
;         If NotifyIntfOwnersBL, BL contains single Address to send
;           Request to
;         If NotifyIntfOwnersAll, Notification is sent to ALL Interface
;           Owners, no matter what their Address is
;Outputs: Notifies appropriate Interface Owner(s), using values in AX, CX, DX
;         Puts appropriate UserPktID in BX before Call(s)
;Changes:
;------------------------------------------------------------------------------
NotifyIntfOwnersBL:
  PUSH BX                         ;Save used registers
  MOV  BH,-1                      ;Mark as having the Address in BL
  JMP >I00                        ;Do it
NotifyIntfOwnersAll:
  PUSH BX                         ;Save used registers
  XOR  BH,BH                      ;Mark as not caring about BL
;  JMP >I00                        ;Do it
I00:
  PUSH DI,SI,BP,DS                ;Save used registers
  MOV  DS,ES                      ;Point DS at TSR Data Area
 #IF !LITE
  MOV  DI,InOffset                ;[DI] = Interface Table
 #ELSE
  MOV  DI,DS:[InTable]            ;[DI] = Interface Table
 #ENDIF
  MOV  BP,InEntries               ;Number of Entries in Table
  MOV  SI,InSize                  ;Size of each entry
I10:                              ;Loop to here for each Entry
  TEST [DI].InFlags,InFlagInUse   ;Valid Entry?
  JZ  >I40                        ;If not, skip it
  OR   BH,BH                      ;Do we care about the Address in BL?
  JZ  >I20                        ;If not, do the Far Call
  CMP  BL,[DI].InDeviceAddress    ;If so, does the address match?
  JNE >I40                        ;If not, skip it
I20:                              ;Do the Far Call
  PUSH BX,DI                      ;Save used registers
  MOV  BX,[DI].InUserPktID        ;Set the User Packet ID
  ADD  DI,(OFFSET InCallBackAddr) ;Point at the Call Back Address
  CALL DoFarCall                  ;Call the User Code
  POP  DI,BX                      ;Restore used registers
I40:                              ;Go to next Interface Entry
  ADD  DI,SI                      ;Point at next Entry
  DEC  BP                         ;Decrement the Loop Counter
  JNZ  I10                        ;If not 0 yet, Keep looking
  POP  DS,BP,SI,DI                ;Restore used registers
  POP  BX                         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;NOTIFY ALL DEVICE 0 OWNER(S) THAT SOMETHING HAPPENED
;Inputs:  ES = TSR Data Area
;         ES:[FirstInstanceSeg] contains Segment that ND Table is in
;         AX = Value to put in AX for Far Call (Owner Call Code)
;         CX = Value to put in CX for Far Call
;         DX = Value to put in DX for Far Call
;Outputs: Notifies all Device 0 Owner(s), using values in AX, CX, DX
;         Puts appropriate UserPktID in BX before Call(s)
;Changes:
;------------------------------------------------------------------------------
NotifyDvc0Owners:
  PUSH BX,DI,DS                   ;Save used registers
  MOV  DS,ES:[FirstInstanceSeg]   ;Point DS at Correct Data Area
  MOV  DI,NDTable                 ;Point at Device 0 Table
Z10:                              ;Loop to here for each Entry
  CMP  W [DI].NDCallBackAddr[2],0 ;Valid Entry?
  JE  >Z20                        ;If not, skip it
  MOV  BX,[DI].NDUserPktID        ;Set the User Packet ID
  PUSH DI                         ;Save used registers
  ADD  DI,(OFFSET NDCallBackAddr) ;Point at the Call Back Address
  CALL DoFarCall                  ;Call the User Code
  POP  DI                         ;Restore used registers
Z20:                              ;Go to next Interface Entry
  ADD  DI,NDSize                  ;Point at the next Table Entry
  CMP  DI,(NDTable+(NDEntries*NDSize)) ;Done with the Table?
  JB   Z10                        ;If not, keep going
  POP  DS,DI,BX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;NOTIFY AN INTERFACE OWNER, AND ALL DOWNSTREAM OWNER(S), THAT SOMETHING HAPPENED
;Inputs:  ES = TSR Data Area
;         AX = Value to put in AX for Far Call (Owner Call Code)
;         CX = Value to put in CX for Far Call
;         DX = Value to put in DX for Far Call
;         BL = Device Address to use
;Outputs: Notifies Interface Owner(s) of Device, using values in AX, CX, DX
;         Notifies Downstream Interface Owner(s) (if Device is a Hub),
;           ORing AX with 0100h to indicate "Upstream" Status
;         Puts appropriate UserPktID in BX before Call(s)
;Changes:
;------------------------------------------------------------------------------
NotifyDownstreamDvcs:
  PUSH AX,BX,DI,SI,DS           ;Save used registers
  MOV  DS,ES                    ;Point DS at TSR Data Area
  CALL NotifyIntfOwnersBL       ;Notify the Owner(s) of the Device itself
  OR   AX,0080h                 ;Convert Call to Indicate Upstream Device
  CALL TestAddressIsHubBL       ;Is this Device a Hub?
  JNZ >D90                      ;If not, there can't be anything Downstream
  MOV  BH,1                     ;Start at Address 0
 #IF !LITE
  MOV  DI,ADOffset              ;  (Root Hub)
 #ELSE
  MOV  DI,DS:[ADTable]          ;  (Root Hub)
 #ENDIF
  MOV  SI,ADSize                ;Size of each entry
  ADD  DI,SI                    ;Point at Address 1 (Root Hub)
D10:                            ;Loop to here for each Entry
  TEST [DI].ADFlags,ADFlagInUse ;Valid Entry?
  JZ  >D20                      ;If not, skip it
  CALL TestDvcAncestry          ;Test Downstream-ivity of this Address
  JC  >D20                      ;If not Downstream, skip it
  XCHG BL,BH                    ;If Downstream, put Address in BL
  CALL NotifyIntfOwnersBL       ;Notify the Interface Owners of this Device
  XCHG BL,BH                    ;Restore Addresses to where they should be
D20:                            ;Go to next Interface Entry
  ADD  DI,SI                    ;Point at next Entry
  INC  BH                       ;Increment Address
  CMP  BH,ADEntries             ;Past the end of the Address Table yet?
  JB   D10                      ;If not, keep looking
D90:                            ;Done
  POP  DS,SI,DI,BX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A DEVICE ADDRESS IS DOWNSTREAM OF ANOTHER DEVICE ADDRESS
;Inputs:   DS = ES = TSR Data Area
;          BL  = Upstream Address to look for
;                If -1 (Host) or 1 (Root Hub), all Device match it!
;         [DI] = Address Table Entry to Test for downstream-ivity
;Outputs: CF = Clear if [DI] is Downstream of BL
;            = Set if NOT Downstream
;Changes:
;------------------------------------------------------------------------------
TestDvcAncestry:
  PUSH CX,DI          ;Save used registers
  CMP  BL,1           ;Upstream Device is Root Hub?
  JE  >A80            ;If so, it's definitely Downstream
  CMP  BL,-1          ;Upstream Device is Host (this IS the Root Hub)?
  JE  >A80            ;If so, it's definitely Downstream
A10:                  ;Loop to here for each Address entry
  MOV  CL,[DI].ADHubAddress ;Get the Hub Address for this Device
  CMP  CL,BL          ;Upstream Address we're looking for?
  JE  >A80            ;If so, it's Downstream
  OR   CL,CL          ;Invalid Address (should never see this!)?
  JZ  >A70            ;If so, it's not Downstream
  CMP  CL,-1          ;Host "Address" (should never see this!)?
  JE  >A70            ;If so, it's not Downstream
  CMP  CL,1           ;Reached the Root Hub without finding Upstream Addr?
  JE  >A70            ;If so, it's not Downstream
  CALL ADIndex2Offset ;If none of these, point at the Hub's Address entry
  JMP  A10            ;Keep looking
A70:                  ;Not Downstream
  STC                 ;Set return Flag
  JMP >A90            ;Done
A80:                  ;Is Downstream
  CLC                 ;Set return flag
A90:                  ;Done
  POP  DI,CX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF AN ADDRESS IS A HUB DEVICE
;Inputs:   ES = TSR Data Area
;          BL = Address to test
;Outputs: ZF = Set if it is a Hub
;            = Clear if not a Hub
;Changes:
;NOTES: This only tests the Device Protocol Field, which should be the only
;         one we ever need to test.
;------------------------------------------------------------------------------
TestAddressIsHubBL:
  PUSH CX,DI                          ;Save used registers
  MOV  CL,BL                          ;Point at the
  CALL ADIndex2Offset                 ;  Address Table Entry
  CMP  ES:[DI].ADDvcClass,DvcClassHub ;Set the return flag
  POP  DI,CX                          ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO REGISTER/UNREGISTER AS AN INTERFACE OWNER, AND HANDLE INTERFACE CONFIGS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE A REQUEST STATING THAT AN INTERFACE IS BEING CONFIGURED
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = TSR Data Area
;         CS = [FirstInstanceSeg]
;         AH = Host Index (-1 or ours)
;         AL = Int14RRequestType (Configing Interface)
;Outputs: CF = Clear if OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;NOTES: We return an error if the Device Address is 0 or 1, or if an Interface
;         on the Device is already being Configured.
;       We do not return a "Registration Code" of any sort with this Call,
;         so we are trusting Interface Drivers to not bump each other.
;       This simply sets a Timeout Counter (approximately 5 seconds), during
;         which the Interface Driver must complete its configuration.
;         A typical Interface Configuration process takes only a few dozen
;         milliseconds, so 5 seconds should be more than sufficient.
;------------------------------------------------------------------------------
ConfigingIntf:
  PUSH CX,DI                      ;Save used registers
  MOV  BP,I14RErrDeviceAddress    ;Assume Bad Device Address
  MOV  CL,[SI].I14RDeviceAddress  ;Get the Device Address
  CMP  CL,1                       ;Is the Address OK?
  JBE >G70                        ;If not, Error
  CALL ADIndex2Offset             ;If OK, point at the Device Address Entry
  MOV  BP,I14RErrIntfInConfig     ;Assume Interface already being Configured
  CMP  ES:[DI].ADConfigingIntf,0  ;Is an Interface Configuration in process?
  JNE >G70                        ;If so, Error
  MOV  ES:[DI].ADConfigingIntf,92 ;If not, start 5 second timeout
  JMP >G80                        ;Done
G70:                              ;Error
  STC                             ;Set Error Flag
  JMP >G90                        ;Done
G80:                              ;OK
  CLC                             ;Set OK Flag
G90:                              ;Done
  POP  DI,CX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST STATING THAT AN INTERFACE CONFIGURATION IS COMPLETE
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = TSR Data Area
;         CS = [FirstInstanceSeg]
;         AH = Host Index (-1 or ours)
;         AL = Int14RRequestType (Configing Interface)
;Outputs: CF = Clear if OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;NOTES: We return an error if the Device Address is 0 or 1, or if a
;         Configuration is not in progress or has timed out.
;------------------------------------------------------------------------------
ConfigIntfDone:
  PUSH CX,DI                     ;Save used registers
  MOV  BP,I14RErrDeviceAddress   ;Assume Bad Device Address
  MOV  CL,[SI].I14RDeviceAddress ;Get the Device Address
  CMP  CL,1                      ;Is the Address OK?
  JBE >D70                       ;If not, Error
  CALL ADIndex2Offset            ;If OK, point at the Device Address Entry
  CMP  ES:[DI].ADConfigingIntf,0 ;Is an Interface Configuration in process?
  MOV  ES:[DI].ADConfigingIntf,0 ;Mark it as completed
  JNE >D80                       ;If it was in progress, we're done
D70:                             ;Error
  STC                            ;Set Error Flag
  JMP >D90                       ;Done
D80:                             ;OK
  CLC                            ;Set OK Flag
D90:                             ;Done
  POP  DI,CX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO REGISTER AS AN INTERFACE OWNER
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = TSR Data Area
;         CS = [FirstInstanceSeg]
;         AH = HostIndex
;              If HostIndex = -1 (Any/All Hosts)
;                Device Address must be 0
;                We use Dvc Cls, SCls, Prot & Intf Cls, SCls, Prot
;                Error if Entry is already in the Table
;              If HostIndex = Ours
;                Device Address must be >= 2
;                We use Interface Number
;         AL = Int14RRequestType (Register Interface Owner)
;Outputs: CF = Clear if OK
;              CX = Handle Number
;              BP = Undefined
;            = Set if Error
;              CX = 0
;              BP = Error Code
;Changes:
;NOTES: For Device 0 Registrations, we assume that the owner will only try
;         to register once.  We do not check for duplications.
;------------------------------------------------------------------------------
RegIntfOwner:
  PUSH EAX,BX,DI                     ;Save used registers
  CALL TestI14RCallBackAddr          ;Legitimate Call Back Address (sets BP)?
  JZ  >R70                           ;If not, Error
  MOV  BP,I14RErrDeviceAddress       ;Assume Bad Device Address
  CMP  AH,AllHostsIndex              ;If not, is it All Hosts?
  JNE >R40                           ;If not, it's a Single Host
  CMP  [SI].I14RDeviceAddress,0      ;Is it Address 0?
  JNE >R70                           ;If not, Error
  MOV  DI,NDTable                    ;Point at the Table
  XOR  CX,CX                         ;Start with Index 0
R20:                                 ;Loop to here to find used ND Entries
  CMP  W CS:[DI].NDCallBackAddr[2],0 ;Empty Table Entry?
  JE  >R25                           ;If so, use it
  ADD  DI,NDSize                     ;Point at the next Table Entry
  INC  CX                            ;Increment Index
  CMP  CX,NDEntries                  ;Done with the table?
  JNE  R20                           ;If not, keep looking
  MOV  BP,I14RErrResources           ;Error = ND Table is Full
  JMP >R70                           ;Done
R25:                                 ;Pointed at an Empty entry
  MOV  BX,[SI].I14RRequestHandle     ;Save the Original Handle Number
  MOV  [SI].I14RRequestHandle,CX     ;Use our Handle Number
  MOV  [SI].I14RRequestType,I14RRTRegDvc0Host  ;Change to Host Request
  CALL DoAllHostsFunction            ;Notify all Hosts (including Us) (Needs AH!)
  MOV  [SI].I14RRequestType,I14RRTRegIntfOwner ;Restore Request
  MOV  [SI].I14RRequestHandle,BX     ;  back to the original state
  JMP >R80                           ;Done (needs CX set)
R40:                                 ;Not All Hosts Call
  CALL TestDvcIntfAddress            ;Are the Address & Interface valid?
                                     ;  (returns DI = Interface Table Entry)
  JC  >R70                           ;If not, error
  MOV  BP,I14RErrIntfAlreadyReg      ;Assume it's already Registered
  CMP  ES:[DI].InCallBackAddr,0      ;Is it already registered?
  JNE >R70                           ;If so, error
  MOV  EAX,[SI].I14RCallBackAddr     ;If OK, store the
  MOV  ES:[DI].InCallBackAddr,EAX    ;  new Owners Address
  MOV  AX,[SI].I14RUserPktID         ;Store the
  MOV  ES:[DI].InUserPktID,AX        ;  User Packet ID
  CALL InOffset2Index                ;Get the Handle Number
  JMP >R80                           ;Done
R70:                                 ;Error
  XOR  CX,CX                         ;Handle Number = 0
  STC                                ;Set error flag
  JMP >R90                           ;Done
R80:                                 ;Worked OK
  CLC                                ;Return flag = OK
R90:                                 ;Done
  POP  DI,BX,EAX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO REGISTER AS A DEVICE OWNER 0
;Inputs:  DS:SI = Int 14 Request Structure
;         ES = Our TSR Data Area
;         CS = [FirstInstanceSeg]
;Outputs: CF = Clear
;Changes:
;NOTES: The Original Call already tested this for Repeats, so we don't need
;         to do it here.  Also, the Orginal Call determined the Index, so
;         we just need to use the Index it calculated!!
;       We should never need to return an Error, since the Original
;         Call did all of the work!
;------------------------------------------------------------------------------
RegDvcOwner0:
  PUSH EAX,CX,DI                    ;Save used registers
  MOV  CX,[SI].I14RRequestHandle    ;Get the Handle Number
  CALL NDIndex2Offset               ;Convert it to an Offset
  MOV  EAX,D [SI].I14RDvcClass      ;Copy
  MOV  D CS:[DI].NDDvcClass,EAX     ;  Device and
  MOV  AX,W [SI].I14RIntfSubClass   ;  Interface
  MOV  W CS:[DI].NDIntfSubClass,AX  ;  Attributes
  MOV  EAX,D [SI].I14RCallBackAddr  ;Copy
  MOV  D CS:[DI].NDCallBackAddr,EAX ;  Call Back Address
  MOV  AX,[SI].I14RUserPktID        ;Copy
  MOV  CS:[DI].NDUserPktID,AX       ;  User Packet ID
  MOV  EAX,D [SI].I14RVendorID      ;Get Vendor ID & Product ID
  CALL ConvertVPID2Neg1             ;Convert 0's to -1's, if necessary
  MOV  D CS:[DI].NDVendorID,EAX     ;Store it
  CLC                               ;Set return flag
  POP  DI,CX,EAX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO UNREGISTER AS AN INTERFACE OWNER
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         ES:[FirstInstanceSeg]
;         AH = HostIndex
;              If HostIndex = -1 (Any/All Hosts)
;                Device Address must be 0
;              If HostIndex = Ours
;                Device Address must be >= 2
;                We use Interface Number
;         AL = Int14RRequestType (UnRegister Interface Owner)
;Outputs: CF = Clear if OK
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
UnRegIntfOwner:
  PUSH EAX,CX,DI                     ;Save used registers
  MOV  BP,I14RErrDeviceAddress       ;Assume Bad Device Address
  CMP  AH,AllHostsIndex              ;If not, is it All Hosts?
  JNE >U40                           ;If not, it's a Single Host
  CMP  [SI].I14RDeviceAddress,0      ;Is it Address 0?
  JNE >U70                           ;If not, Error
  MOV  BP,I14RErrRequestHandle       ;Error = Bad Handle
  MOV  CX,[SI].I14RRequestHandle     ;Get the Handle Number
  CALL NDIndex2Offset                ;Convert it to an Offset
  CMP  W CS:[DI].NDCallBackAddr[2],0 ;Valid Entry?
  JE  >U70                           ;If not, Error
  MOV  [SI].I14RRequestType,I14RRTUnRegDvc0Host  ;Change to Host Request
  CALL DoAllHostsFunction            ;Notify all Hosts (including Us)
  MOV  [SI].I14RRequestType,I14RRTUnRegIntfOwner ;Restore Original Request
  JMP >U80                           ;Done
U40:                                 ;Not All Hosts Call
  XOR  EAX,EAX                       ;Work with 0's
  MOV  BP,I14RErrRequestHandle       ;Error = Bad Handle
  MOV  CX,[SI].I14RRequestHandle     ;Get the Handle Number
  CALL InIndex2Offset                ;Convert it to an Offset
  CMP  ES:[DI].InCallBackAddr,EAX    ;Valid Entry?
  JE  >U70                           ;If not, Error
  MOV  ES:[DI].InCallBackAddr,EAX    ;Unregister
  MOV  ES:[DI].InUserPktID,AX        ;  it
  JMP >U80                           ;Done
U70:                                 ;Error
  STC                                ;Set error flag
  JMP >U90                           ;Done
U80:                                 ;Worked OK
  CLC                                ;Return flag = OK
U90:                                 ;Done
  POP  DI,CX,EAX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO UNREGISTER AS A DEVICE OWNER 0
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES      = TSR Data Area
;         ES:[FirstInstanceSeg]
;Outputs: CF = Clear
;Changes:
;NOTES: The Original Call already tested this, so we don't need to do it here.  Also, the Orginal Call determined the Index, so
;       We just need to process it as it sits.
;------------------------------------------------------------------------------
UnRegDvcOwner0:
  PUSH CX,ES                     ;Save used registers
  MOV  ES,ES:[FirstInstanceSeg]  ;Point ES at the correct Segment
  MOV  CX,[SI].I14RRequestHandle ;Get the Handle Number
  CALL ReleaseNDCX               ;Release the ND Table Entry
  CLC                            ;Set return flag
  POP  ES,CX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO INFORM AN INTERFACE OWNER TO NOT LOOK
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         AH = HostIndex
;              HostIndex Must be ours (All Hosts is Invalid)
;         AL = Int14RRequestType (Dont Look)
;Outputs: CF = Clear if OK
;            = Set if Error
;              BP = Error Code
;Changes:
;NOTE: Unlike the Timeout values for TD's which use the entire Timeout Word,
;        this only uses the lower byte.  Therefore, the maximum number
;        of deciseconds is 255, rather than 18000.
;------------------------------------------------------------------------------
IntfDontLook:
  PUSH AX,BX,CX,DX,DI,DS         ;Save used registers
  MOV  BP,I14RErrHostIndex       ;Assume Bad Host Index
  CMP  AH,AllHostsIndex          ;If not, is it All Hosts?
  JE  >L70                       ;If so, Error
  MOV  BP,I14RErrDeviceAddress   ;Assume Bad Device Address
  MOV  AL,[SI].I14RDeviceAddress ;Get the Address
  MOV  AH,[SI].I14RInterfaceNum  ;  & Interface Number
  CMP  AL,(ADEntries-1)          ;Valid Address?
  JA  >L70                       ;If not, Error
  MOV  DL,B [SI].I14RTimeOut     ;Get the TimeOut Value
  OR   DL,DL                     ;Is it 0?
  JNZ >L10                       ;If not, continue
  MOV  DL,DefDontLookTimeout     ;If so, make it the default
L10:                             ;Address valid, DL contains TimeOut
  MOV  DS,ES                     ;Point DS at the TSR Data Area
  MOV  CL,AL                     ;Is there
  CALL ADIndex2Offset            ;  a Device
  TEST [DI].ADFlags,ADFlagInUse  ;  with that Address?
  JZ  >L70                       ;If not, Error
  MOV  BP,I14RErrInterfaceNum    ;Assume Bad Interface Number
  CALL AddressIntf2Intf          ;Get the Interface Offset
  JC  >L70                       ;If invalid, Error
  CMP  [DI].InCallBackAddr,0     ;Is it really Registered?
  JE  >L70                       ;If not, Error
  MOV  CL,[USBHostIndex]         ;CL = Host Index
  MOV  CH,AL                     ;CH = Device Address
  MOV  DH,DL                     ;DH = Timeout Value (deciseconds)
  MOV  DL,AH                     ;DL = Interface Number
  MOV  AX,OwnerCallDontLook      ;AX = Dont Look
  MOV  BX,[DI].InUserPktID       ;BX = User Pkt ID
  ADD  DI,OFFSET InCallBackAddr  ;Inform the
  CALL DoFarCall                 ;  Owner
  JMP >L80                       ;Done
L70:                             ;Error
  STC                            ;Set Error Flag
  JMP >L90                       ;Done
L80:                             ;OK
  CLC                            ;Set OK Flag
L90:                             ;Done
  POP  DS,DI,DX,CX,BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A VENDOR AND/OR PRODUCT ID FROM 0 TO -1, IF NECESSARY
;Inputs:  EAX = Original Vendor & Product ID
;Outputs: EAX = Modified Vendor & Product ID
;Changes:
;------------------------------------------------------------------------------
ConvertVPID2Neg1:
  PUSH BX    ;Save used registers
  PUSH EAX   ;Put Low Word
  POP  AX    ;  in AX,
  POP  BX    ;  High Word in BX
  OR   AX,AX ;Is the Low Word 0?
  JNZ >N20   ;If not, handle High Word
  NOT  AX    ;If so, make it -1
N20:         ;Low Word is Handled
  OR   BX,BX ;Is the High Word 0?
  JNZ >N90   ;If not, we're done
  NOT  BX    ;If so, make it -1
N90:         ;Done
  PUSH BX    ;Put BX into High Word
  PUSH AX    ;Put AX into
  POP  EAX   ;  Low Word
  POP  BX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A DVC ADDR AND INTF NUM FROM INT14 STRUC ARE VALID FOR REGISTRY
;Inputs:  DS:[SI] = Pointer to Int14 Structure
;         ES = TSR Data area
;Outputs: CF = Clear if OK (between 2 & 127, Address is in use)
;                DI = Interface Address Table Offset
;                BP = Undefined
;            = Set if error (invalid address, or address not in use)
;                DI = Unchanged
;                BP = Error Code
;Changes:
;------------------------------------------------------------------------------
TestDvcIntfAddress:
  PUSH AX,CX                       ;Save used registers
  MOV  BP,I14RErrDeviceAddress     ;Error = Bad Address
  MOV  CL,[SI].I14RDeviceAddress   ;Get Device Address
  CMP  CL,1                        ;Is it too small?
  JBE >A70                         ;If so, error
  CMP  CL,(ADEntries-1)            ;Is it too big?
  JA  >A70                         ;If so, error
  CALL ADIndex2Offset              ;If OK, convert it to an Offset (ES:DI)
  TEST ES:[DI].ADFlags,ADFlagInUse ;Is there a valid device at this address?
  JZ  >A70                         ;If not, Error
  MOV  BP,I14RErrInterfaceNum      ;Error = Bad interface
  MOV  AL,CL                       ;Get the
  MOV  AH,[SI].I14RInterfaceNum    ;  Entry from the
  CALL AddressIntf2Intf            ;  Interface Table
  JNC >A80                         ;If OK, we're done
A70:                               ;Error
  STC                              ;Set error flag
  JMP >A90                         ;Done
A80:                               ;OK
  CLC                              ;Set OK flag
A90:                               ;Done
  POP  CX,AX                       ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS DataX CALLS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;Changes:
;------------------------------------------------------------------------------

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO GET OR INCREMENT A DATAX VALUE
;Inputs:  DS:[SI] = Int 14h Request Structure
;         ES      = TSR Data area
;         AH      = HostIndex (-1 or ours)
;         AL      = Int14RRequestType (Get/Inc DataX)
;         BX = CX = DX = -1
;Outputs: CF = Clear if OK
;              If call is GetDataX, BL = Current DataX Value
;              If call is IncDataX, BL = Unchanged
;              BH, CX, DX = Unchanged(-1)
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;              BX, CX, DX = Unchanged (-1)
;Changes:
;NOTES: This Call cannot be passed on to other Host Indexes!
;       These calls are only valid on Interrupt and Bulk EndPoints.
;         We do not keep track of DataX on Control and Isochronous
;         EndPoints -- they are both managed "automatically" because
;         of the way the USB protocol works.
;       For USB 1, IncDataX simply toggles betwen Data0 and Data 1, the
;         only two possibilities.  When we move the USB 2, there are more
;         than two.
;       The reason we even have this option is to handle problems with
;         Mass Storage Devices, which effectively "tie" In and Out EndPoints
;         together from a DataX togglig perspective.  A real pain in the
;         rear, these Mass Stoarge Devices.
;------------------------------------------------------------------------------
GetDataX:
IncDataX:
  PUSH AX,CX,DI,SI         ;Save used registers
  MOV  BP,I14RErrHostIndex ;Assume Bad Host Index
  CMP  AH,AllHostsIndex    ;Is it for All Hosts?
  JE  >X70                 ;If so, Error
  MOV  CH,AL               ;Save Request Type
  MOV  AX,W [SI].I14RDeviceAddress ;AL = Device Address, AH = End Point
  MOV  CL,AL               ;CL = Device Address
  CALL TestDvcAddress      ;Valid Device Address (uses CL, rtns BP, DI)?
  JC  >X70                 ;If not, error
  MOV  BP,I14RErrEndPoint  ;Assume Bad End Point
  TEST AH,0F0h             ;Valid End Point Number?
  JNZ >X70                 ;If not, Error
  TEST [SI].I14RFlags,I14RFlagIn ;Is it In?
  JZ  >X10                 ;If not, continue
  OR   AH,80h              ;If so, mark it as In
X10:                       ;In flag set, if applicable
  CALL FindEndPtEntry      ;If OK, look for an EndPoint (uses AX, rtns SI)
  JC  >X70                 ;If none found, Error
  CMP  CH,I14RRTGetDataX   ;Is it Get DataX?
  JE  >X30                 ;If so, handle it
X20:                       ;Call is Increment DataX
  XOR  ES:[SI].EnFlags,EnFlagData1 ;Toggle DataX
  JMP >X80                 ;Done
X30:                       ;Call is Get DataX
  XOR  BL,BL               ;Assume Data0
  TEST ES:[SI].EnFlags,EnFlagData1 ;Is it Data0?
  JZ  >X80                 ;If so, we're done
  INC  BL                  ;If not, set Data1
  JMP >X80                 ;Done
X70:                       ;Error
  STC                      ;Set Error Flag
  JMP >X90                 ;Done
X80:                       ;OK
  CLC                      ;Set OK Flag
X90:                       ;Done
  POP  SI,DI,CX,AX         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO ENABLE/DISABLE/SUSPEND/RESET ETC. DEVICES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO ENABLE A DEVICE, GIVEN A DEVICE ADDRESS OR HUB & PORT #
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES      = TSR Data Area
;Outputs: CF = Clear if OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
EnableDevice:
  PUSH BX                    ;Save used registers
  MOV  BX,DoDeviceHubThing   ;Code to Call
  JMP >E00                   ;Do it
EnableHubPort:
  PUSH BX                    ;Save used registers
  MOV  BX,DoHubPortThing     ;Code to Call
;  JMP >E00                   ;Do it
E00:
  PUSH AX,FS                 ;Save used registers
  MOV  AX,OwnerCallDvcEnable ;FS = Owner Call Code
  MOV  FS,AX                 ;  to issue when complete
  MOV  AX,HubCallEnable      ;AX = Far Call Code = Enable Device
  CALL BX                    ;Do it
  POP  FS,AX                 ;Restore used registers
  POP  BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO DISABLE A DEVICE, GIVEN A DEVICE ADDRESS OR HUB & PORT #
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES      = TSR Data Area
;Outputs: CF = Clear if OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
DisableDevice:
  PUSH BX                     ;Save used registers
  MOV  BX,DoDeviceHubThing    ;Code to Call
  JMP >D00                    ;Do it
DisableHubPort:
  PUSH BX                     ;Save used registers
  MOV  BX,DoHubPortThing      ;Code to Call
;  JMP >D00                    ;Do it
D00:
  PUSH AX,FS                  ;Save used registers
  MOV  AX,OwnerCallDvcDisable ;FS = Owner Call Code
  MOV  FS,AX                  ;  to issue when complete
  MOV  AX,HubCallDisable      ;AX = Far Call Code = Disable Device
  CALL BX                     ;Do it
  POP  FS,AX                  ;Restore used registers
  POP  BX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO RESET A DEVICE, GIVEN A HUB & PORT #
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES      = TSR Data Area
;Outputs: CF = Clear if OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes: Resets Device attached to the Hub/Port requested
;------------------------------------------------------------------------------
ResetHubPort:
  PUSH AX,FS                ;Save used registers
  MOV  AX,OwnerCallDvcReset ;FS = Owner Call Code
  MOV  FS,AX                ;  to issue when complete
  MOV  AX,HubCallReset      ;AX = Far Call Code = Reset Device
  CALL DoHubPortThing       ;Do it
  POP  FS,AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO RESET OR CHANGE CONFIGURATION OF A DEVICE
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES      = TSR Data Area
;         AH      = Host Index (-1 or ours)
;Outputs: CF = Clear if OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;NOTES: This simply queues the Reset Request to the end of the Reset Table.
;       The Reset Table is periodically polled for entries, and Resets
;         are performed when they are appropriate and manageable.
;------------------------------------------------------------------------------
SetNewConfig:
  PUSH EAX                             ;Save used registers
  MOV  AH,-1                           ;Mark as needing to set Config
  JMP >R00                             ; Do it
ResetDevice:
  PUSH EAX                             ;Save used registers
  XOR  AH,AH                           ;Mark as NOT needing to set Config
;  JMP >R00                             ;Do it
R00:
  PUSH BX,DI                           ;Save used registers
  PUSHF                                ;Save Flags
  CALL TestHostAndAddress2             ;Valid Address (rtns DI)?
  JC  >R70                             ;If Error, Quit
  MOV  BX,DI                           ;If OK, put Address Table Entry in BX
  OR   AH,AH                           ;Do we need to set the Config?
  JZ  >R20                             ;If not, no need to test Config value
  MOV  BP,I14RErrConfigValue           ;Error = Invalid Config Value
  MOV  AL,[SI].I14RConfigValue         ;Is the
  CMP  AL,ES:[BX].ADNumConfigs         ;  Config Value valid?
  JA  >R70                             ;If not, Error
R20:                                   ;Config value tested (if appropriate)
  CLI                                  ;Disable interrupts
  MOV  BP,I14RErrHostCallInUse         ;Assume Error = Already Resetting
  CALL TestResetEntryReset             ;Is there already a Reset Entry?
  JNC >R70                             ;If so, Quit
  MOV  BP,I14RErrResources             ;Assume Error = No Resources
  CALL GetAvailReset                   ;Get a Reset Table Entry (DI)
  JC  >R70                             ;If Error, Quit
  MOV  ES:[DI].RsRetries,ResetRetries  ;Initialize Retry Counter
  MOV  ES:[DI].RsConfigValue,-1        ;Assume no Config to set
  OR   AH,AH                           ;Do we need to set the Config?
  JZ  >R40                             ;If not, continue
  OR   ES:[DI].RsFlags,RsFlagSetConfig ;If so, store
  MOV  ES:[DI].RsConfigValue,AL        ;  the Config Value
R40:                                   ;Config set handled (if appropriate)
  TEST ES:[BX].ADFlags,ADFlagLowSpeed  ;Is the current Device Low Speed?
  JZ  >R50                             ;If not, continue
  OR   ES:[DI].RsFlags,RsFlagLowSpeed  ;If so, mark it as Low Speed for the Reset
R50:                                   ;Speed is handled
  MOV  AX,W ES:[BX].ADHubAddress       ;Store the Hub Address
  MOV  W ES:[DI].RsHubAddress,AX       ;  and Port
  MOV  EAX,[SI].I14RCallBackAddr       ;Store the
  MOV  ES:[DI].RsCallBackAddr,EAX      ;  Call Back Address
  MOV  AX,[SI].I14RUserPktID           ;Store the
  MOV  ES:[DI].RsUserPktID,AX          ;  User Packet ID
  MOV  AL,[SI].I14RDeviceAddress       ;Remove the Device
  CALL RemoveAddress                   ;  from the Address Table
  JMP >R80                             ;Done
R70:                                   ;Error
  POPF                                 ;Restore Flags
  STC                                  ;Set Error Flag
  JMP >R90                             ;Done
R80:                                   ;OK
  POPF                                 ;Restore Flags
  CLC                                  ;Set OK Flag
R90:                                   ;Done
  POP  DI,BX                           ;Restore used registers
  POP  EAX                             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST TO SEE IF THERE'S ALREADY A RESET TABLE ENTRY FOR THE REQUESTED HUB/PORT
;Inputs:  If TestResetEntryReset,
;           ES:[BX] = Address Table Entry of Device we're Resetting
;Inputs:  If TestResetEntryNewDvc,
;           DS:[SI] = INt 14 Request Entry of New Device Connect Request


;         ES      = TSR Data Area
;Outputs: CF = Clear if Existign Reset Table entry is found
;            = Set if no existing entry found
;Changes:
;------------------------------------------------------------------------------
TestResetEntryReset:
  PUSH AX                          ;Save used registers
  MOV  AX,W ES:[BX].ADHubAddress   ;AX = Hub Address & Port to test
  JMP >E00                         ;Do it
TestResetEntryNewDvc:
  PUSH AX                          ;Save used registers
  MOV  AX,W [SI].I14RHubAddress    ;AX = Hub Address & Port to test
;  JMP >E00                         ;Do it
E00:
  PUSH CX,DI                       ;Save used registers
  MOV  DI,ES:[RsTable]             ;ES:[DI] = Reset Table
  MOV  CX,RsEntries                ;CX = Number of Table Entries
E10:                               ;Loop to here for each Table Entry
  TEST ES:[DI].RsFlags,RsFlagInUse ;Valid Table Entry?
  JZ  >E50                         ;If not, skip it
  CMP  AX,W ES:[DI].RsHubAddress   ;Do the Address & Port match?
  JE  >E80                         ;If so, we're done
E50:                               ;DOne testing this Table Entry
  ADD  DI,RsSize                   ;Point at the next Table Entry
  LOOP E10                         ;Keep looking until the end of the Table
E70:                               ;No entry found
  STC                              ;Set return flag
  JMP >E90                         ;Done
E80:                               ;Existing entry found
  CLC                              ;Set return flag
E90:                               ;Done
  POP  DI,CX                       ;Restore used registers
  POP  AX                          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO SUSPEND A DEVICE, GIVEN A DEVICE ADDRESS OR HUB & PORT #
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES      = TSR Data Area
;Outputs: CF = Clear if OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
SuspendDevice:
  PUSH BX                     ;Save used registers
  MOV  BX,DoDeviceHubThing    ;Code to Call
  JMP >S00                    ;Do it
SuspendHubPort:
  PUSH BX                     ;Save used registers
  MOV  BX,DoHubPortThing      ;Code to Call
;  JMP >S00                    ;Do it
S00:
  PUSH AX,FS                  ;Save used registers
  MOV  BP,I14RErrHostHalted   ;Assume Error = Host Halted
  CALL TestGlobalSuspend      ;In Global Suspend Mode?
  JNZ >S70                    ;If so, Error
  MOV  AX,OwnerCallDvcSuspend ;FS = Owner Call Code
  MOV  FS,AX                  ;  to issue when complete
  MOV  AX,HubCallSuspend      ;AX = Far Call Code = Suspend Device
  CALL BX                     ;Do it
  JNC >S80                    ;If OK, we're done
S70:                          ;Error
  STC                         ;Set Error Flag
  JMP >S90                    ;Done
S80:                          ;OK
  CLC                         ;Set OK Flag
S90:                          ;Done
  POP  FS,AX                  ;Restore used registers
  POP  BX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO RESUME A DEVICE, GIVEN A DEVICE ADDRESS OR HUB & PORT #
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES      = TSR Data Area
;Outputs: CF = Clear if OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
ResumeDevice:
  PUSH BX                    ;Save used registers
  MOV  BX,DoDeviceHubThing   ;Code to Call
  JMP >R00                   ;Do it
ResumeHubPort:
  PUSH BX                    ;Save used registers
  MOV  BX,DoHubPortThing     ;Code to Call
;  JMP >R00                   ;Do it
R00:
  PUSH AX,FS                 ;Save used registers
  MOV  BP,I14RErrHostHalted  ;Assume Error = In Global Suspend
  CALL TestGlobalSuspend     ;In Global Suspend Mode?
  JNZ >R70                   ;If so, Error
  MOV  AX,OwnerCallDvcResume ;FS = Owner Call Code
  MOV  FS,AX                 ;  to issue when complete
  MOV  AX,HubCallResume      ;AX = Far Call Code = Resume Device
  CALL BX                    ;Do it
  JNC >R80                   ;If no error, done
R70:                         ;Error
  STC                        ;Set Error Flag
  JMP >R90                   ;Done
R80:                         ;OK
  CLC                        ;Set OK Flag
R90:                         ;Done
  POP  FS,AX                 ;Restore used registers
  POP  BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO POWER ON A DEVICE, GIVEN A DEVICE ADDRESS OR HUB & PORT #
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES      = TSR Data Area
;Outputs: CF = Clear if OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
PowerOnDevice:
  PUSH BX                   ;Save used registers
  MOV  BX,DoDeviceHubThing  ;Code to Call
  CALL TestHubPPPDevice     ;Test for PPP Support (Returns ZF)
  JMP >N00                  ;Do it
PowerOnHubPort:
  PUSH BX                   ;Save used registers
  MOV  BX,DoHubPortThing    ;Code to Call
  CALL TestHubPPPHubPort    ;Test for PPP Support (Returns ZF)
;  JMP >N00                  ;Do it
N00:
  PUSH AX,FS                ;Save used registers
  JZ  >N70                  ;If no PPP support, quit
  MOV  AX,OwnerCallDvcPwrOn ;FS = Owner Call Code
  MOV  FS,AX                ;  to issue when complete
  MOV  AX,HubCallPwrOn      ;AX = Far Call Code = Power On Device
  CALL BX                   ;Do it
  JNC >N80                  ;If no error, done
N70:                        ;Error
  STC                       ;Set Error Flag
  JMP >N90                  ;Done
N80:                        ;OK
  CLC                       ;Set OK Flag
N90:                        ;Done
  POP  FS,AX                ;Restore used registers
  POP  BX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO POWER OFF A DEVICE, GIVEN A DEVICE ADDRESS OR HUB & PORT #
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES      = TSR Data Area
;Outputs: CF = Clear if OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
PowerOffDevice:
  PUSH BX                    ;Save used registers
  MOV  BX,DoDeviceHubThing   ;Code to Call
  CALL TestHubPPPDevice      ;Test for PPP Support (Returns ZF)
  JMP >F00                   ;Do it
PowerOffHubPort:
  PUSH BX                    ;Save used registers
  MOV  BX,DoHubPortThing     ;Code to Call
  CALL TestHubPPPHubPort     ;Test for PPP Support (Returns ZF)
;  JMP >F00                   ;Do it
F00:
  PUSH AX,FS                 ;Save used registers
  JZ  >F70                   ;If no PPP support, quit
  MOV  AX,OwnerCallDvcPwrOff ;FS = Owner Call Code
  MOV  FS,AX                 ;  to issue when complete
  MOV  AX,HubCallPwrOff      ;AX = Far Call Code = Power Off Device
  CALL BX                    ;Do it
  JMP >F90                   ;Done
F70:                         ;Error
  STC                        ;Set Error Flag
  JMP >F90                   ;Done
F80:                         ;OK
  CLC                        ;Set OK Flag
F90:                         ;Done
  POP  FS,AX                 ;Restore used registers
  POP  BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO POWER RESET A DEVICE, GIVEN A DVC ADDRESS OR HUB & PORT #
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES      = TSR Data Area
;Outputs: CF = Clear if OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
PowerResetDevice:
  PUSH BX                      ;Save used registers
  MOV  BX,DoDeviceHubThing     ;Code to Call
  CALL TestHubPPPDevice        ;Test for PPP Support (Returns ZF)
  JMP >R00                     ;Do it
PowerResetHubPort:
  PUSH BX                      ;Save used registers
  MOV  BX,DoHubPortThing       ;Code to Call
  CALL TestHubPPPHubPort       ;Test for PPP Support (Returns ZF)
;  JMP >R00                     ;Do it
R00:
  PUSH AX,FS                   ;Save used registers
  JZ  >R70                     ;If no PPP support, quit
  MOV  AX,OwnerCallDvcPwrReset ;FS = Owner Call Code
  MOV  FS,AX                   ;  to issue when complete
  MOV  AX,HubCallPwrReset      ;AX = Far Call Code = Power Reset Device
  CALL BX                      ;Do it
  JMP >R90                     ;Done
R70:                           ;Error
  STC                          ;Set Error Flag
  JMP >R90                     ;Done
R80:                           ;OK
  CLC                          ;Set OK Flag
R90:                           ;Done
  POP  FS,AX                   ;Restore used registers
  POP  BX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A DEVICES HUB SUPPORTS PER-PORT-POWER SWITCHING
;Inputs:  DS:[SI] = Int14 Structure of Original Call
;         ES      = TSR Data Area
;Outputs: ZF = Clear if Hub Supports Per-Port-Power Switching
;            = Set if not PPP Support
;Changes:
;NOTES: This is called as part of the PowerOn/PowerOff/PowerReset calls
;         to a Device
;------------------------------------------------------------------------------
TestHubPPPDevice:
  PUSH CX,DI                        ;Save used registers
  MOV  BP,I14RErrNoPortPower        ;Assume Error = No Port Power Support
  MOV  CL,[SI].I14RDeviceAddress    ;Point at the Device
  CALL ADIndex2Offset               ;  Address Table entry
  MOV  CL,ES:[DI].ADHubAddress      ;Get the Hub Address
  CALL ADIndex2Offset               ;Point at the Hub Address Table entry
  TEST ES:[DI].ADFlags,ADFlagHubPPP ;Set Return Flag
  POP  DI,CX                        ;Restore used registers
  RET

TestHubPPPHubPort:
  PUSH CX,DI                        ;Save used registers
  MOV  BP,I14RErrNoPortPower        ;Assume Error = No Port Power Support
  MOV  CL,[SI].I14RDeviceAddress    ;Point at the Hub
  CALL ADIndex2Offset               ;  Address Table entry
  TEST ES:[DI].ADFlags,ADFlagHubPPP ;Set Return Flag
  POP  DI,CX                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS AND SEND A REQUEST TO A DEVICES HUB (ENABLE, DISABLE, ETC.)
;Inputs:  DS:[SI] = Int14 Request Structure
;         ES = TSR Data Area
;         AX = Function Call to put in AX (Actully sent to Hub, not Device)
;         If DoHubPortThing, [SI] contains Hub Address and Port Number
;         If DoDeviceHubThing, [SI] contains Device Address
;         FS = Owner Call Code to issue upon completion
;Outputs: CF = Clear if OK
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
DoHubPortThing:
  PUSH CX,DI,GS                 ;Save used Registers
  CALL TestHostAndAddress1      ;Test Host and Addr validity (rtns DI)
  JC  >P70                      ;If Error, quit
  MOV  CL,ES:[USBHostIndex]     ;Low byte of GS = Host Index
  XOR  CH,CH                    ;High byte of GS = Device Address (unknown)
  MOV  GS,CX                    ;Put it in GS
  MOV  CX,W [SI].I14RHubAddress ;CL = Hub Address, CH = Hub Port
  CALL DoHubThing               ;Do the Call
  JNC >P80                      ;If it worked OK, we're done
P70:                            ;Error
  STC                           ;Set Error Flag
  JMP >H90                      ;Done
P80:                            ;OK
  CLC                           ;Set OK Flag
  POP  GS,DI,CX                 ;Restore used registers
  RET

DoDeviceHubThing:
  PUSH CX,DI,GS                  ;Save used registers
  CALL TestHostAndAddress2       ;Test Host and Addr validity (rtns DI)
  JC  >H70                       ;If Error, quit
  MOV  CL,ES:[USBHostIndex]      ;Low byte of GS = Host Index
  MOV  CH,[SI].I14RDeviceAddress ;High byte of GS = Device Address
  MOV  GS,CX                     ;Put it in GS
  MOV  CX,W ES:[DI].ADHubAddress ;CL = Hub Address, CH = Hub Port
  CALL DoHubThing                ;Do the Call
  JNC >H80                       ;If it worked OK, we're done
H70:                             ;Error (Restore DI)
  STC                            ;Set error flag
  JMP >H90                       ;Done
H80:                             ;OK
  CLC                            ;Set OK flag
H90:                             ;Done
  POP  GS,DI,CX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FINISH UP A DEVICEHUBTHING OR A HUBPORTTHING
;Inputs:  DS:[SI] = Int 14 Request Structure
;              AX = Owner Call Code to issue
;              CL = Hub Address to Send Request to
;              CH = Hub Port to Send Request to
;              FS = Value to put in AX (Owner Call Code) upon completion
;              GS = Value to put in CX (Owner Call) upon completion
;Outputs: CF = Clear if OK
;            = Set if Error
;                BP = Error Code
;Changes:
;NOTES: This simply sends the Call to the Hub.  As part of the Call, this
;         indirectly gives the Hub the FarCallAddress to call when it is done
;         doing what it needs to do.  So, this will return right away with a
;         return value, but the Hub call will not actually be completed yet
;         and we will not know when it is completed.
;------------------------------------------------------------------------------
DoHubThing:
  PUSH AX,BX,CX,DX,DI,DS          ;Save used registers
  MOV  BP,I14RErrResources        ;Error = Resource Problem
  PUSH CX                         ;Save Hub Address & Port
  CALL GetAvailLC                 ;Get an Available Large Call Entry (CX, DI)
                                  ;  CL = Handle, CH = Host Index
  MOV  DX,CX                      ;Put Handle Number in DX
  POP  CX                         ;Restore Hub Address & Port
  JC  >H70                        ;If Error, Quit
  PUSH [SI].I14RUserPktID         ;Copy the
  POP  ES:[DI].LCUserPktID        ;  User Packet ID
  PUSH [SI].I14RCallBackAddr      ;Copy the
  POP  ES:[DI].LCCallBackAddr     ;  CallBack Address
  MOV  ES:[DI].LCOwnerCallAX,FS   ;Store the AX Owner Call Value
  MOV  ES:[DI].LCOwnerCallCX,GS   ;Store the CX Owner Call Value
  MOV  ES:[DI].LCOwnerCallDX,0    ;Store the DX Owner Call Value
  OR   ES:[DI].LCFlags,LCFlagDeviceCall ;Mark as a Device-level Call
  MOV  DS,ES                      ;Point DS at TSR Data area
;Could Have Problem Here if Hub is not Interface 0?
  PUSH AX                         ;Save Call Code
  MOV  AL,CL                      ;Get the
  CALL Address2Intf               ;  Far Call
  MOV  BX,[DI].InUserPktID        ;  ID and
  ADD  DI,(OFFSET InCallBackAddr) ;  Address to use
  POP  AX                         ;Restore the Call Code
  CALL DoFarCall                  ;Call it
  JMP >H80                        ;Done
H70:                              ;Error
  STC                             ;Set error flag
  JMP >H90                        ;Done
H80:                              ;OK
  CLC                             ;Set OK flag
H90:                              ;Done
  POP  DS,DI,DX,CX,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A HUB & PORT NUMBER TO AN ADDRESS
;Inputs:  AL = Hub Address
;         AH = Hub Port Number (1-based)
;         ES = TSR Data Area
;Outputs: ZF = Clear if Valid Address
;              AL = Address assigned to Port
;         ZF = Set if no Device Found
;              AL = 0
;Changes:
;------------------------------------------------------------------------------
HubAndPort2Addr:
  PUSH BX,CX           ;Save used registers
 #IF !LITE
  MOV  BX,ADOffset     ;[BX] = Address Table
 #ELSE
  MOV  BX,ES:[ADTable] ;[BX] = Address Table
 #ENDIF
  XOR  CL,CL           ;Start with Address 0
P10:                   ;Loop to here to find correct entry
  TEST ES:[BX].ADFlags,ADFlagInUse ;Valid Table Entry?
  JZ  >P50                         ;If not, skip it
  CMP  AX,W ES:[BX].ADHubAddress   ;Is it the correct Hub & Port?
  JE  >P90             ;If so, we're done
P50:                   ;Go to next Table Entry
  ADD  BX,ADSize       ;Point at next Table Entry
  INC  CL              ;Increment Address
  CMP  CL,ADEntries    ;Past the end of the Table?
  JB   P10             ;If not, keep looking
  XOR  CL,CL           ;If so, Address = 0
P90:                   ;Done
  MOV  AL,CL           ;Put Address in AL
  OR   AL,AL           ;Set return flag
  POP  CX,BX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DISABLE THE LAST ENUMERATED DEVICE
;Inputs:  ES = TSR Data Area
;         [LastAddressUsed]
;Outputs:
;Changes:
;NOTE: This actually sends the Request to the Hub, Not the Device itself
;------------------------------------------------------------------------------
DisableLastDevice:
  PUSH AX,SI,DS                      ;Save used registers
  MOV  DS,ES                         ;Point DS at TSR Data Area
  MOV  SI,Int14Request2              ;Point at Request Structure
  MOV  AL,[LastAddressUsed]          ;Address to Disable is
  MOV  [SI].I14RDeviceAddress,AL     ;  last Address Used
  MOV  [SI].I14RRequestType,I14RRTDisableDevice ;Request = Disable Device
  MOV  W [SI].I14RCallBackAddr[0],-1 ;Do nothing when Done
  CALL DoInt14CallSI                 ;Do it
  POP  DS,SI,AX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A REQUEST IS FOR A VALID (EXISTING), SPECIFIC DEVICE
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = TSR Data Area
;Outputs: CF = Clear if (Our Host Index, valid Address)
;              DI = Address Table Entry Pointer (Assumes ES)
;              BP = Undefined
;            = Set if All Hosts Index, or Invalid (non-existent) Address
;              DI = Unchanged
;              BP = Error Code
;Changes:
;NOTES: TestHostandAddress0 considers Addresses 0 and 1 to be valid,
;         while TestHostAndAddress2 does not
;------------------------------------------------------------------------------
TestHostAndAddress0:
  PUSH CX                        ;Save used registers
  XOR  CH,CH                     ;CH = Min Address Allowed = 0
  JMP >A00                       ;Do it
TestHostAndAddress1:
  PUSH CX                        ;Save used registers
  MOV  CH,1                      ;CH = Min Address Allowed = 1
  JMP >A00                       ;Do it
TestHostAndAddress2:
  PUSH CX                        ;Save used registers
  MOV  CH,2                      ;CH = Min Address Allowed = 2
;  JMP >A00                       ;Do it
A00:
  MOV  BP,I14RErrHostIndex       ;Assume bad Host Index
  CMP  [SI].I14RHostIndex,AllHostsIndex ;Is it for All Hosts?
  JE  >A70                       ;If so, Error
  MOV  BP,I14RErrDeviceAddress   ;Assume Bad Device Address
  MOV  CL,[SI].I14RDeviceAddress ;Get Device Address to change
  OR   CH,CH                     ;Is there a minimum address allowed?
  JZ  >A10                       ;If not, continue
  CMP  CL,CH                     ;Is it too small?
  JB  >A70                       ;If so, error
A10:                             ;Minimum Address is tested
  CALL TestDvcAddress            ;Is it valid (returns DI)?
  JNC >A80                       ;If so, it's OK
A70:                             ;Error
  STC                            ;Set error flag
  JMP >A90                       ;Done
A80:                             ;No error
  CLC                            ;Set OK flag
A90:                             ;Done
  POP  CX                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A DEVICE ADDRESS IS VALID
;Inputs:  CL = Device Address to Test
;         ES = TSR Data Area
;Outputs: CF = Set if Invalid Address (>126, or No Device Attached)
;              BP = Error Code
;              DI = Unchanged
;            = Clear if OK
;              BP = Undefined
;              DI = Address Table Offset
;Changes:
;------------------------------------------------------------------------------
TestDvcAddress:
  PUSH AX                          ;Save used registers
  MOV  AX,DI                       ;Save original DI
  MOV  BP,I14RErrDeviceAddress     ;Set Error Code
  CMP  CL,(ADEntries-1)            ;Valid Address?
  JA  >A70                         ;If not, Error
  CALL ADIndex2Offset              ;If valid, convert it to an offset
  TEST ES:[DI].ADFlags,ADFlagInUse ;Valid Device at the Address?
  JNZ >A80                         ;If so, it's OK
A70:                               ;Invalid/Non-Existent Address
  MOV  DI,AX                       ;Restore original DI
  STC                              ;Set Error Flag
  JMP >A90                         ;Done
A80:                               ;Valid Address
  CLC                              ;Set OK Flag
A90:                               ;Done
  POP  AX                          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CODE CALLED BY LARGE (COMPLICATED) ROUTINE AT THE END OF A CALL
;Inputs:  DS:[SI] = Int14 Request Structure
;         ES = TSR Data Area
;Outputs: CF = Clear if OK
;            = Set if Error
;              BP = Error Code
;Changes:
;NOTES: This is the "Return" call at the end of another Large, Complicated Call.
;       A Large Call by this definition is one that takes a long time to do,
;         and requires several Bus sub-transactions to be performed before
;         to overall call is truly complete.
;       This includes many Host-Level transactions
;         (Run/Stop/Reset/Suspend/Resume) and Hub-level transactions
;         (Enable/Disable/Reset/Suspend/Resume).  It also includes
;         Hub Disconnects.
;------------------------------------------------------------------------------
LargeCallDone:
  PUSH AX,BX,CX,DX,DI,DS            ;Save used registers
  MOV  BP,I14RErrRequestHandle      ;Assume Bad Handle
  MOV  AX,[SI].I14RLargeCallRtnCode ;Get the Return Code
  MOV  CL,B [SI].I14RRequestHandle  ;Get the Handle Number
  CMP  CL,(LCEntries-1)             ;Is it valid?
  JA  >C70                          ;If not, Error
  MOV  DS,ES                        ;Point DS at TSR Data area
  CALL LCIndex2Offset               ;Convert Index to an Offset
  TEST [DI].LCFlags,LCFlagInUse     ;Is it a valid entry in the Table?
  JZ  >C70                          ;If not, Error
  MOV  BX,[DI].LCUserPktID          ;BX = User Packet ID
  MOV  CX,-1                        ;CX = -1
  MOV  DX,CX                        ;DX = -1
  PUSH DI                           ;Save Pointer
  ADD  DI,(OFFSET LCCallBackAddr)   ;Do the
  CALL DoFarCall                    ;  Far Call
  POP  DI                           ;Restore Pointer
  CALL LargeCallNotifies            ;Notify Others of what happpened
  CALL ReleaseLCDI                  ;Release the Large Call Table Entry
  JMP >C80                          ;Done
C70:                                ;Error
  STC                               ;Set error flag
  JMP >C90                          ;Done
C80:                                ;OK
  CLC                               ;Set OK flag
C90:                                ;Done
  POP  DS,DI,DX,CX,BX,AX            ;Restore used registers
  RET

LargeCallNotifies:
  PUSH AX,BX,CX,DX                   ;Save used registers
  MOV  AX,[DI].LCOwnerCallAX         ;Get AX Value
  MOV  CX,[DI].LCOwnerCallCX         ;Get CX Value
  MOV  DX,[DI].LCOwnerCallDX         ;Get DX Value
  TEST [DI].LCFlags,LCFlagDeviceCall ;Device-level call?
  JNZ >O30                           ;If so, handle it
  TEST [DI].LCFlags,LCFlagHostCall   ;Host-level call?
  JZ  >O90                           ;If not, quit
O10:                                 ;Host-level call
  CALL NotifyTimingOwner             ;Notify Timing Owner
  CALL NotifyIntfOwnersAll           ;Notify all Interface Owners
  CALL NotifyDvc0Owners              ;Notify Device 0 Owners
  JMP >O90                           ;Done
O30:                                 ;Device-level call
  MOV  BL,CH                         ;Put Device Address in BL
  CALL NotifyDownstreamDvcs          ;Notify Downstream Devices
O90:                                 ;Done
  POP  DX,CX,BX,AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY NEW DEVICE DATA (LASTADDRESSUSED) TO ADDRESS 0 DATA AREA
;Inputs:  DS = ES = TSR Data Area
;         [LastAddressUsed]/[LastAddressOffset] = Address where data is stored
;         CLD already issued
;Outputs:
;Changes: Copies data to Address 0
;------------------------------------------------------------------------------
CopyToAddress0:
  PUSH CX,DI,SI               ;Save used registers
  CLI                         ;Disable interrupts
  MOV  SI,[LastAddressOffset] ;ES:[DI] = Address Table Entry
 #IF !LITE
  MOV  DI,ADOffset            ;DS:[SI] = Address 0 table Entry
 #ELSE
  MOV  DI,DS:[ADTable]        ;DS:[SI] = Address 0 table Entry
 #ENDIF
  MOV  CX,(ADSize/2)          ;Number of words to copy
  REP  MOVSW                  ;Do it
  POP  SI,DI,CX               ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO INITIATE/SCHEDULE PACKETS ON THE USB BUS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;START A BULK PACKET REQUEST ON THE USB BUS
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         AH = Host Index (-1 or Ours)
;Outputs: CF = Set if error
;              CX = DX = -1
;              BP =Error Code
;            = Clear if OK
;              CX = Handle (QH Index Number + An Offset)
;              DL = Closure ID
;              DH = -1
;              BP =Undefined
;Changes: Starts Bulk Transaction on USB Bus if data is valid
;------------------------------------------------------------------------------
StartBulkPacket:
  PUSH EAX,BX,DI                     ;Save used registers
  PUSHF                              ;Save Flags
  CALL TestHostAndHalted             ;Test for valid Host Index, not Halted (BP)
  JC  >B75                           ;If error, quit
  CLI                                ;Disable interrupts
  CALL CalcBulkTDsNeeded             ;Calc # of TD's to use (AX, DI, BP, ZF)
  JZ  >B75                           ;If problem, quit with Error
  MOV  BX,DI                         ;Put Bulk Pointer in BX
  MOV  DX,AX                         ;Save TD Counter
  CALL CopyBulkTimeout2QH            ;Copy the Timeout & Close ID information
  JC  >B72                           ;If error, quit
  CALL GetAvailTD                    ;Get a Transfer Descriptor (ES:DI)
                                     ;  Should not have an error here!
  CALL CopyI14PktInfo2TD             ;Copy the "generic" Info to the TD
                                     ;  (Dvc Addr, EndPoint, CallBack,
                                     ;   UserPktID, LowSpeed, Sizes)
  JC  >B70                           ;If error, quit
  MOV  BP,I14RErrDeviceAddress       ;Assume Low-speed Device
  MOV  AL,[SI].I14RDeviceAddress     ;Is it a
  CALL TestDvcLowSpeed               ;  low-speed device?
  JNZ >B70                           ;If so, error (Bulk is illegal for LS)
  MOV  AX,[SI].I14RDataSize          ;Store Bytes to Xfer
  MOV  ES:[BX].QHBulkBytesLeft,AX    ;  in the QH
  MOV  EAX,ES:[DI].TDBuffPointer     ;Store the Data Address
  MOV  ES:[BX].QHBulkNextAddress,EAX ;  in the QH
  CALL ReleaseTD                     ;Release the temporary TD
  MOV  CX,DX                         ;CX = # of TD's to use
B40:                                 ;Loop to here for each TD
  CALL GetAvailTD                    ;Get a TD (ES:DI, assume no error)
  CALL CopyI14PktInfo2TD             ;Copy the "generic" Info to the TD
                                     ;  (Dvc Addr, EndPoint, CallBack,
                                     ;   UserPktID, LowSpeed, Sizes)
  MOV  ES:[DI].TDDataAddress,EAX     ;Store Starting Data Address in TD
  MOV  W ES:[DI].TDBulkQHOffset,BX   ;Store QH Offset in TD
  CALL SetBulkTDAddr                 ;Fill it with correct Bulk Info
  CALL AddTD2BulkQH                  ;Schedule it
  LOOP B40                           ;Keep going until we're done
  JMP >B80                           ;Done
B70:                                 ;Error with TD & QH Reserved
  CALL ReleaseTD                     ;Release TD
B72:                                 ;Error with QH Reserved
  MOV  ES:[BX].QHElementPointer,QHTerminate ;Release
  MOV  ES:[BX].QHFlags,0             ;  the QH
B75:                                 ;Error, no TD Reserved yet
  MOV  CX,-1                         ;CX = -1
  XOR  DX,CX                         ;DX = -1
  POPF                               ;Restore Flags
  STC                                ;Set Error Flag
  JMP >B90                           ;We're done
B80:                                 ;Packet Sent
  MOV  DI,BX                         ;Get the
  CALL QHOffset2Index                ;  QH Index
  ADD  CX,(TDEntries-1)              ;Make it a Handle Number
  MOV  DH,-1                         ;DH = -1
  MOV  DL,ES:[CloseID]               ;DL = Closure ID
  POPF                               ;Restore Flags
  CLC                                ;Set the OK flag
B90:                                 ;We're done
  POP  DI,BX,EAX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE NUMBER OF TD'S TO USE FOR A BULK TRANSACTION
;Inputs:  DS:[SI] = Int 14 Request (Bulk Request)
;         ES      = TSR Data Area
;Outputs: ZF = Clear if OK
;              AX = # of TD's to use for Bulk Transaction
;              DI = Bulk QH Offset to use (Marked as Reserved)
;              BP = Undefined
;            = Set if Error (Insufficient TD's or no available QH)
;              AX = 0
;              DI = 0
;              BP = Error Code
;Changes:
;NOTES: The algorithm used by this routine will always leave some TD's
;         for other uses, and at most use 1/2 of the available TD's for
;         this particular transaction.  That should allow several Bulk
;         Transactions to be going on at the same time, thought the first
;         Bulk Transaction to grab TD's will have the most available.
;         Subsequent Bulk Transactions, if they are started before the
;         first one ends, will not have as many TD's, and may end up
;         running slower than the first one does.
;       Since DOS is not multitasking, and since Bulk Transactions will
;         tend to be foreground applications (e.g., file transfers), this
;         should work OK.
;------------------------------------------------------------------------------
CalcBulkTDsNeeded:
  PUSH BX,CX,DX             ;Save used registers
  MOV  AX,[SI].I14RDataSize ;Get Data Size
  MOV  BP,I14RErrResources  ;Assume not enough Resources
  CALL CalcAvailTDs         ;Calculate number of available TD's (CX)
  JZ  >N70                  ;If none available, error
  SUB  CX,8                 ;Is it less than 8?
  JC  >N70                  ;If so, error
  SHR  CX,1                 ;Divide by 2 (use at most 1/2 of remaining TD's)
  MOV  BX,CX                ;Save number of available TD's
  CALL GetEPMaxPktSizeI14   ;Get Max Pkt Size for the End Point (CX)
  JZ  >N70                  ;If error, quit
  XOR  DX,DX                ;Divide Data Size (AX)
  DIV  CX                   ;  by Max Pkt Size
  OR   DX,DX                ;  to Get
  JZ  >N10                  ;  Number of
  INC  AX                   ;  TD's needed
N10:                        ;AX = # of TD's actually needed
  OR   AX,AX                ;Is it 0 (DataSize 0)?
  JNZ >N20                  ;If not, continue
  INC  AX                   ;If so, we still need at least 1 TD
N20:                        ;DataSize 0 handled
  CMP  AX,BX                ;Enough TD's available?
  JBE >N30                  ;If so, done
  MOV  AX,BX                ;If not, just use max available
N30:                        ;AX contains nubmer of TD's
  CALL GetAvailQHBulk       ;Get an available Queue Head (DI)
  JNZ >N90                  ;If OK, we're done
N70:                        ;No TD's available/needed
  XOR  AX,AX                ;Set
  XOR  DI,DI                ;  return values
N90:                        ;Done
  OR   AX,AX                ;Set Return Flag
  POP  DX,CX,BX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SET THE DATA ADDRESS, SIZE, AND DATA1 IN A BULK TD
;Inputs:  ES:[DI] = Pointer to TD (contains QH Pointer)
;                   QH keeps track of Data Addresses, Data Sizes
;                   EndPt keeps track of Data1
;Outputs: Updates TD & QH Data appropriately
;Changes:
;------------------------------------------------------------------------------
SetBulkTDAddr:
  PUSH EAX,CX,SI,DS                  ;Save used registers
  MOV  DS,ES                         ;Point DS at TSR Data Area
  MOV  SI,W [DI].TDBulkQHOffset      ;Point SI at Queue Head Data
  MOV  AL,[SI].QHBulkTimeoutIndex    ;Copy the
  MOV  [DI].TDTimeoutIndex,AL        ;  Timeout Table Index
  MOV  EAX,[SI].QHBulkNextAddress    ;Copy the
  MOV  [DI].TDBuffPointer,EAX        ;  Data Address
  CALL GetEPMaxPktSizeTD             ;Get Max Packet Size (CX)
  MOVZX EAX,CX                       ;Put it in EAX
  CMP  [SI].QHBulkBytesLeft,AX       ;More bytes than this TD can handle?
  JA  >F20                           ;If so, handle it
  MOV  AX,[SI].QHBulkBytesLeft       ;If not, just do the amount of data we need
F20:                                 ;EBX contains Data Bytes needed in this TD
  ADD  [SI].QHBulkNextAddress,EAX    ;Update the Address for the next TD
  SUB  [SI].QHBulkBytesLeft,AX       ;Update the transaction byte counter
  CALL SetTDMaxLength                ;Set the Byte Counter in the TD
  CALL SetData1ForBulkIntTD          ;Set/Unset Data1 in the TD
  CMP  [SI].QHBulkBytesLeft,0        ;Any data left to send after this?
  JNE >F90                           ;If so, we're done
  OR   [DI].TDFlags,TDFlagLastBulkTD ;If not, mark it
  OR   [SI].QHFlags,QHFLagLastTDSent ;  as the last one
F90:                                 ;Done
  POP  DS,SI,CX,EAX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;START A PERIODIC INTERRUPT PACKET REQUEST ON THE USB BUS
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         AH = Host Index (-1 or Ours)
;Outputs: CF = Set if error
;              CX = -1
;              BP =Error Code
;            = Clear if OK
;              CX = Handle (TD Index Number)
;              BP =Undefined
;Changes: Starts Periodic Interrupt Packet on USB Bus if data is valid and
;           bus is not already too full.
;------------------------------------------------------------------------------
StartIntPerPacket:
  PUSH AX,BX,DI                     ;Save used registers
  PUSHF                             ;Save flags
  CALL TestHostAndHalted            ;Test for valid Host Index, not Halted (BP)
  JC  >P75                          ;If error, quit
  CLI                               ;Disable interrupts
  CALL CalcIntPerTDsNeeded          ;Get number of TD's needed
  JZ  >P75                          ;If error, quit (rtns AX, DI, BP)
  MOV  BX,DI                        ;Save QH Pointer in BX
  MOV  CX,AX                        ;Save number of TD's needed in CX
  MOV  BP,I14RErrPeriodicity        ;Assume Invalid Periodicity
  MOV  AX,[SI].I14RPeriodicity      ;Get the Periodicity
  OR   AX,AX                        ;Is it too small?
  JZ  >P75                          ;If so, error
  CMP  AX,FLEntries                 ;Is it too big?
  JA  >P75                          ;If so, Error
  CALL GetAvailTD                   ;Get a Transfer Descriptor (ES:DI)
                                    ;Should not have an error here!
  CALL CopyI14PktInfo2TD            ;Copy the "generic" Info to the TD
                                    ;  (Dvc Addr, EndPoint, CallBack,
                                    ;   UserPktID, LowSpeed, Data Sizes)
  JC  >P70                          ;If error, we're done (sets BP)
  CALL TestSpecificFrame            ;Is Specific Frame data valid?
  JC  >P70                          ;If not, error
  MOV  W ES:[DI].TDPeriodicity,AX   ;Store Periodicity in the TD
  MOV  W ES:[DI].TDLastFrameUsed,-1 ;Mark it as unscheduled
  OR   W ES:[DI].TDControlStatus[2],((TDErrorCount1+TDIntOnComplete+TDActive) SHR 16)
                                    ;Mark TD as Active
  MOV  AL,TDTypeInterruptPer        ;Mark it as
  CALL SetTDType                    ;  a periodic Interrupt
  CALL SetData1ForBulkIntTD         ;Set Data1 as appropriate
  OR   BX,BX                        ;Do we need to set up a Queue?
  JNZ >P20                          ;If so, jump to handle it
P10:                                ;No queue needed
  MOV  BP,I14RErrResources          ;Assume Bus is too full already
  CALL CalcBusPercentUsed           ;Get percent usage with this TD added (AL)
  CMP  AL,100                       ;Is it more than 100% with this TD?
  JA  >P70                          ;If so, Error
  JMP >P30                          ;If OK, schedule it
P20:                                ;Need to set up a Queue
  CALL SetupIntQH                   ;Setup the Interrupt QH
  JC  >P75                          ;If error, quit (sets BP, Deletes QH/TD's)
P30:                                ;Schedule the TD/QH!
  MOV  CX,3                         ;Assume not Specific Frame
  TEST [SI].I14RFlags,I14RFlagSpecificFrame ;Start in a specific Frame?
  JZ  >P50                          ;If not, continue
  MOV  AX,[SI].I14RFrameIndex       ;Get the Starting Frame Number
  SUB  AX,[SI].I14RPeriodicity      ;Compensate for the fact
  JNC >P40                          ;  that we add the Periodicity
  ADD  AX,FLEntries                 ;  before adding to the FL
P40:                                ;Starting Frame is Stored
  MOV  ES:[DI].TDLastFrameUsed,AX   ;If OK, Store it
P50:                                ;Add to the Schedule
  CALL AddPerIntTD2FL               ;Schedule it
  JMP >P80                          ;Done
P70:                                ;Error with a single TD already reserved
  CALL ReleaseTD                    ;Release TD - It's not needed
P75:                                ;Error, no TD Reserved yet
  MOV  CX,-1                        ;CX = -1
  POPF                              ;Restore flags
  STC                               ;Set the error flag
  JMP >P90                          ;We're done
P80:                                ;Packet Sent
  CALL TDOffset2Index               ;CX = TD Index # (Request Handle)
  POPF                              ;Restore flags
  CLC                               ;Set the OK flag
P90:                                ;We're done
  POP  DI,BX,AX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHECK FOR AND HANDLE A SPECIFIC FRAME REQUEST
;Inputs:  DS:[SI] = Int 14 Request
;         ES:[DI] = TD we're working with
;Outputs: CF = Clear if OK (No Specific Frame, or Specific Frame Number is OK)
;              Sets Specific Frame Flag in TD
;              BP = Undefined
;            = Set if Error (Specific Frame set, but invalid Frame Index)
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
TestSpecificFrame:
  MOV  BP,I14RErrFrameIndex                 ;Assume error
  TEST [SI].I14RFlags,I14RFlagSpecificFrame ;Start in a specific Frame?
  JZ  >F80                                  ;If not, it's OK
  OR   ES:[DI].TDFlags,TDFlagSpecificFrame  ;If so, mark the TD as Specific
  CMP  W [SI].I14RFrameIndex,(FLEntries-1)  ;Is it valid?
  JBE >F80                                  ;If so, it's OK
F70:                                        ;Error
  STC                                       ;Set error flag
  JMP >F90                                  ;Done
F80:                                        ;OK
  CLC                                       ;Set OK flag
F90:                                        ;Done
  RET

;------------------------------------------------------------------------------
;SETUP THE PERIODIC INTERRUPT QUEUE HEAD
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES      = TSR Data Area
;         ES:[DI] = First TD (set up already)
;         ES:[BX] = QH (Periodicity & Num TD's already stored)
;         CX (CL) = Total number of TD's needed
;Outputs: CF = Clear if OK (QH is set up)
;              BP = Undefined
;            = Set if Error (QH and TD's have been released)
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
SetupIntQH:
  PUSH EAX,BX,CX,EDX,DI,SI,DS             ;Save used registers
  MOV  DS,ES                              ;Point DS at TSR Data Area
  CALL SegOff2PhysAddrESDI                ;Convert the TD to Physical Address
  MOV  [BX].QHElementPointer,EAX          ;Store it in the QH
  MOV  AX,[DI].TDPeriodicity              ;Copy the Periodicity
  MOV  [BX].QHIntPeriodicity,AX           ;  to the QH
  MOV  [BX].QHIntNumTDs,CL                ;Store number of TD's in the QH
  MOV  [DI].TDIntQHOffset,BX              ;Store the QH Offset in the TD
  MOV  [BX].QHIntTDOffset,DI              ;Store the 1st TD Offset in the QH
  CALL GetTDMaxLength                     ;Get Max Packet Size (AX)
  MOVZX EDX,AX                            ;Put it in EDX
  MOV  BP,[DI].TDBytesToXfer              ;BP = Byte Counter
  DEC  CL                                 ;Decrement TD counter
Q20:                                      ;Loop to here for each TD
  PUSH CX                                 ;Save Loop Counter
  CALL CalcTDBits                         ;Add the number of full-speed
  ADD  [BX].QHIntTotalBits,CX             ;  bit times to the total
  MOV  SI,DI                              ;Point SI at old TD
  CALL GetAvailTD                         ;Point DI at a new TD
                                          ;  (assume no error here)
  MOV  CX,(TDSize/2)                      ;Number of words to copy
  PUSH DI,SI                              ;Save TD pointers
  REP  MOVSW                              ;Copy old TD to new TD
  POP  SI,DI                              ;Restore TD pointers
  POP  CX                                 ;Restore loop counter
  CALL SegOff2PhysAddrESDI                ;Convert new TD to Physical Address
  OR   AL,TDDepthFirst                    ;Mark it as Depth first
  MOV  [SI].TDLinkPointer,EAX             ;Store it in the old TD
  CALL SetData1ForBulkIntTD               ;Set Data1 as appropriate
  ADD  [DI].TDBuffPointer,EDX             ;Point at the correct Data Address
  SUB  BP,DX                              ;Subtract out the bytes for the TD
  DEC  CL                                 ;Decrement TD Counter
  JNZ  Q20                                ;If not last TD, continue
Q30:                                      ;This is the last TD
  MOV  [DI].TDLinkPointer[0],TDTerminate  ;Mark Link Pointer as invalid
  MOV  AX,BP                              ;Set the correct
  CALL SetTDMaxLength                     ;  Packet Size for the last TD
  CALL CalcTDBits                         ;Add in the correct Bits
  ADD  [BX].QHIntTotalBits,CX             ;  for the last TD
  MOV  BP,I14RErrDataSize                 ;Assume too many bytes sent
  CMP  W [BX].QHIntTotalBits,IsochIntBits ;Are there too many bytes?
  JA  >Q70                                ;If so, error
  MOV  BP,I14RErrResources                ;Assume Bus too full
  CALL CalcBusPercentUsed                 ;Will this make the
  CMP  AL,100                             ;  bus too full?
  JBE >Q80                                ;If not, we're done
Q70:                                      ;Error
  MOV  DI,BX                              ;Release the QH
  CALL ReleaseIntQH                       ;  and all of the TD's
  STC                                     ;Set Error Flag
  JMP >Q90                                ;Done
Q80:                                      ;OK
  CLC                                     ;Set OK flag
Q90:                                      ;Done
  POP  DS,SI,DI,EDX,CX,BX,EAX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;VERIFY THAT THERE ARE ENOUGH RESOURCES TO INITIALIZE A PERIODIC INT
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;Outputs: ZF = Clear if OK
;              AX = Number of TD's Needed
;              DI = Int QH Offset to use (if AX > 1)
;                 = 0 if no QH needed (AX <= 1)
;              BP = Undefined
;            = Set if Error
;              AX = 0
;              DI = 0
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
CalcIntPerTDsNeeded:
  PUSH CX,DX                ;Save used registers
  XOR  DI,DI                ;Assume no Queue needed
  MOV  BP,I14RErrEndPoint   ;Assume Bad End Point
  CALL GetEPMaxPktSizeI14   ;Get Max Packet Size for EndPoint (CX, ZF)
  JZ  >R70                  ;If Bad End Point, Error
  MOV  BP,I14RErrResources  ;Assume Lack of Resources
  MOV  AX,[SI].I14RDataSize ;Get total number of bytes
  XOR  DX,DX                ;  to Transfer
  DIV  CX                   ;Divide by Max Pkt Size
  OR   DX,DX                ;Any remainder from the Division?
  JZ  >R05                  ;If not, AX doesn't need to be rounded
  INC  AX                   ;If so, round it up
R05:                        ;AX is rounded up, if needed
  OR   AX,AX                ;Was it 0 bytes?
  JNZ >R10                  ;If not, continue
  INC  AX                   ;If so, we still need one TD
R10:                        ;AX = # TD's, DX = Last TD Bytes, BP = MaxPktSize
  CALL CalcAvailTDs         ;See how many TD's are available (CX & ZF)
  CMP  CX,AX                ;Are there enough to handle our request?
  JB  >R70                  ;If not, error
  CMP  AX,1                 ;Is it just 1 TD?
  JE  >R90                  ;If so, no QH is needed
  CALL GetAvailQHInt        ;Reserve an Interrupt QH
  JNZ >R90                  ;If OK, we're done
R70:                        ;Error (lack of resources)
  XOR  AX,AX                ;Set Error Flag
R90:                        ;Done
  OR   AX,AX                ;Set return flag
  POP  DX,CX                ;Restore used registers
  RET


#IF LITE ;StartIsochPacket and support routines

  StartIsochPacket:
    MOV  BP,I14RErrReqTypeNoSupt ;Error = Request Type not Supported
    STC                          ;Set Error Flag
    RET

#ELSE    ;StartIsochPacket and support routines

;------------------------------------------------------------------------------
;START AN ISOCHRONOUS PACKET SEQUENCE REQUEST ON THE USB BUS
;Inputs:  DS:[SI] = Int 14h Request
;         ES = Our TSR Data Area
;         AH = Host Index (-1 or Ours)
;Outputs: CF = Set if error
;              BX = CX = -1
;              BP =Error Code
;            = Clear if OK
;              BX = Starting Frame Number
;              CX = Handle (First TD Index Number)
;              BP = Undefined
;Changes: Starts Isoch Packet Request on USB Bus if data is valid
;------------------------------------------------------------------------------
StartIsochPacket:
  PUSH EAX,EDX,DI,SI,DS             ;Save used registers
  PUSHF                             ;Save Flags
  CALL TestHostAndHalted            ;Test for valid Host Index, not Halted
  JC  >I751                         ;If error, quit
  CLI                               ;Disable Interrupts
  MOV  ES:[IsochSequence],0         ;Start Sequence Number at 0
  CALL CalcIsochTDs                 ;See how many TD's it will take (CX)
  JC  >I751                         ;If problem, there's an error
  CALL CalcIsochBits                ;Will this make the Bus too full?
  JC  >I751                         ;If so, Error
  CALL GetAvailTD                   ;Get first Transfer Descriptor (ES:DI)
  JC  >I751                         ;If Error, quit (sets BP)
  MOV  W ES:[DI].TDLastFrameUsed,-1 ;Mark as not scheduled yet
  CALL CopyI14IsochInfo2TD          ;Copy the "generic" Info to the TD
                                    ;  (Dvc Addr, EndPt, Dir, Data Addr, Period)
  MOV  EDX,ES:[DI].TDBuffPointer    ;Save the Starting Data Address (Physical!)
  MOV  BX,[SI].I14RPeriodicity      ;Save the size of the Schedule Table
  JC  >I70                          ;If error, we're done (sets BP)
  CALL ReleaseTD                    ;If OK, Release the TD (we only wanted to
                                    ;  validate data, not actually set up TD)
  CALL CalcIsochStartFrame          ;Calculate the Starting Frame Number
                                    ;  (Returns CX, Sets ES:[IsochStartFrame])
  MOV  W ES:[IsochInt14Ptr][2],DS   ;Store the Pointer
  MOV  W ES:[IsochInt14Ptr][0],SI   ;  to the Int 14 Structure
  LDS  SI,[SI].I14RIsochSchedAddr   ;Point at the Isochronous Schedule
  XOR  EAX,EAX                      ;Need High Word of EAX = 0
  JMP >I30                          ;Do it
I751:
  JMP >I75                          ;To avoid JMP > 128
I30:                                ;Loop to here for each TD
  LODSW                             ;Get the next Table Entry
  OR   AX,AX                        ;Is it 0 bytes?
  JZ  >I50                          ;If so, we don't need a TD
  CALL GetAvailTD                   ;Get a TD (ES:DI) - No need to check for Err
  MOV  W ES:[DI].TDLastFrameUsed,-1 ;Mark as not scheduled yet
  CALL CopyI14IsochInfo2TD2         ;Copy the Data - No need to check for Err
  MOV  BP,ES:[IsochHandle]          ;Get the Handle Number
  CMP  BP,-1                        ;Is this the First TD of the series?
  JNE >I40                          ;If not, continue
  CALL TDOffset2IndexBP             ;If so, get the Index (BP)
  MOV  ES:[IsochHandle],BP          ;Store it in the TD
I40:                                ;Have Handle (BP)
  MOV  ES:[DI].TDIsochHandle,BP     ;Store the Handle Number
  MOV  ES:[DI].TDBuffPointer,EDX    ;Store the Correct Data Address
  ADD  EDX,EAX                      ;Update Data Address for next TD
  MOV  ES:[DI].TDBytesToXfer,AX     ;Store the number of Bytes
  CALL SetTDMaxLength               ;  to Transfer in this Frame
  MOV  ES:[DI].TDLastFrameUsed,CX   ;Store the Frame Number in the TD
  CALL StoreIsochSequence           ;Store the Isochronous Sequence Number

;Need to check for enough room here???
;  (Would call CalcFlBits)

  CALL AddIsochTD2FL                ;Schedule it
I50:                                ;Done with this Entry
  MOV  AX,CX                        ;Increment
  INC  AX                           ;  the
  CALL CvtFrNum2FrNum               ;  Frame
  MOV  CX,AX                        ;  Number
  DEC  BX                           ;Decrement the Schedule Entry Counter
  JNZ  I30                          ;If not done, continue
  JMP >I80                          ;Quit if we're done
I70:                                ;Error (need to Release TD)
  CALL ReleaseTD                    ;Release the TD
I75:                                ;Error (BP contains Error Type)
  MOV  BX,-1                        ;BX = -1
  MOV  CX,BX                        ;CX = -1
  POPF                              ;Restore Flags
  STC                               ;Set Error Flag
  JMP >I90                          ;Done
I80:                                ;OK
  MOV  CX,ES:[IsochHandle]          ;Store the Handle Number for the Return
  MOV  BX,ES:[IsochStartFrame]      ;Store the Starting Frame Index for the Rtn
  POPF                              ;Restore Flags
  CLC                               ;Set OK Flag
I90:                                ;Done
  MOV  ES:[IsochHandle],-1          ;Mark Handle as invalid for next time
  POP  DS,SI,DI,EDX,EAX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY THE ISOCHRONOUS PACKET SEQUENCE NUBMER TO THE TD
;Inputs:  ES = TSR Data Area
;         ES:[DI] = TD to Update
;         ES:[IsochSequence] = value to store
;Outputs: Copies [IsochSequence] to TD, Updates (Increments) [IsochSequence]
;Changes:
;------------------------------------------------------------------------------
StoreIsochSequence:
  PUSH AX                           ;Save used registers
  MOV  AL,ES:[IsochSequence]        ;Store the
  MOV  B ES:[DI].TDIsochSequence,AL ;  Sequence Number
  INC  AL                           ;Increment it for next time
  MOV  ES:[IsochSequence],AL        ;Store it for next time
  POP  AX                           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE STARTING FRAME NUMBER FOR AN ISOCHRONOUS TD
;Inputs:  DS:[SI] = Int 14 Structure
;         ES = TSR Data Area
;Outputs: CX = Starting Frame Number to use, Compensated for Periodicity
;         ES:[IsochStartFrame] = Actual Starting Frame Number
;Changes:
;------------------------------------------------------------------------------

;Do similar calculations for Specific Frame on Periodic TD!
;Specific Frame = Frames from now, as opposed to Actual Frame Number?
;  Minimum = 1, Max = 1024?  Truncate if too big (CvtFrNum2FrNum?)?

CalcIsochStartFrame:
  PUSH AX                      ;Save used registers
  MOV  AX,4                    ;Assume not Specific Frame
  TEST [SI].I14RFlags,I14RFlagSpecificFrame ;Use Specific Frame Index?
  JZ  >S30                     ;If not, AX is OK
S10:                           ;Specific Frame
  CALL GetFrameIndex           ;Calculate
  MOV  CX,[SI].I14RFrameIndex  ;  Number
  SUB  CX,AX                   ;  of Frames
  MOV  AX,CX                   ;  into
  JNC >S30                     ;  the
  ADD  AX,FLEntries            ;  Future
S30:                           ;AX = # Frames into Future
  CALL AddToFrameNumber        ;Add it (returns CX)
  SUB  CX,[SI].I14RPeriodicity ;Compenstate because
  JNC >S40                     ;  we will add Periodicity
  ADD  CX,(FLEntries*2)        ;  while scheduling
S40:                           ;CX = Corret Start Frame
  MOV  ES:[IsochStartFrame],CX ;Store Start Frame
  AND  ES:[IsochStartFrame],FrNumIndexMask ;Convert it to an Index
S90:                           ;Have starting Frame Number
  POP  AX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE NUMBER OF TD'S REQUIRED TO FULFILL AN ISOCH REQUEST
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES      = TSR Data Area
;         CLD already issued
;Outputs: CF = Clear if OK
;              CX = Number of TD's required to Set Up Isoch Transfer
;            = Set if Error
;              BP = Error Type
;              CX = 0
;Changes:
;NOTES:   Checks for errors in Periodicity, Data Sizes
;------------------------------------------------------------------------------
CalcIsochTDs:
  PUSH AX,BX,SI,DS                ;Restore used registers
  MOV  BP,I14RErrPeriodicity      ;Assume Bad Periodicity
  MOV  CX,[SI].I14RPeriodicity    ;Get number of table entries
  JCXZ >T70                       ;If invalid, error
  CMP  CX,FLEntries               ;Is it valid?
  JA  >T70                        ;If not, error
  XOR  BX,BX                      ;BX = TD Counter
  LDS  SI,[SI].I14RIsochSchedAddr ;Get Array of data sizes -- 1st Entry CAN = 0!
  MOV  BP,I14RErrIsochArray       ;Assume a problem with the Array
T20:                              ;Loop to here for each element in Array
  LODSW                           ;Get the next element
  OR   AX,AX                      ;Is it 0 bytes?
  JZ  >T40                        ;If so, go to the next one
  CMP  AX,MaxFSBytes              ;Is it too big?
  JA  >T70                        ;If so, error
  INC  BX                         ;If OK, increment our TD Counter
T40:                              ;Done with this element
  LOOP T20                        ;Keep going until we're done
  OR   BX,BX                      ;Any TD's at all?
  JZ  >T70                        ;If not, error
  CMP  BX,MaxIsochFrames          ;Is it more than we allow?
  JA  >T70                        ;If so, error
  MOV  BP,I14RErrResources        ;If so, assume not enough TD's Available
  CALL CalcAvailTDs               ;Calculate number of available TD's (CX)
  JZ  >T70                        ;If none available, error
  CMP  BX,CX                      ;Are there enough to handle this Request?
  JBE >T80                        ;If so, we're done
T70:                              ;Error (BP contains Error Code)
  XOR  CX,CX                      ;CX = 0
  STC                             ;Set Error Flag
  JMP >T90                        ;Done
T80:                              ;OK
  MOV  CX,BX                      ;Put number of TD's needed in CX
  CLC                             ;Set OK Flag
T90:                              ;Done
  POP  DS,SI,BX,AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHECK AND SEE IF THERE IS ENOUGH BANDWIDTH LEFT ON THE BUS FOR AN ISOCH TD
;Inputs:  DS:[DI] = Int 14h Request
;         ES = TSR Data Area
;         CalcIsochTDs has already been issued, checking for errors
;           (we do not do any error/validity checking in this routine)!
;         CLD already issued
;Outputs: CF = Clear if OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
CalcIsochBits:
  PUSH EAX,EBX,ECX,EDX,SI,DS        ;Save used registers
  MOV  BP,I14RErrResources          ;BP = Error Code (Lack of Resources)
  MOV  CX,[SI].I14RPeriodicity      ;Get number of Table entries
  MOV  DX,CX                        ;Save it in DX
  LDS  SI,[SI].I14RIsochSchedAddr   ;Point DS:[SI] at Array of data sizes
  XOR  EAX,EAX                      ;Make sure high word of EAX is 0
  XOR  EBX,EBX                      ;Make sure high word of EBX is 0
B10:                                ;Loop to here for each table entry
  LODSW                             ;Get the next table entry
  OR   AX,AX                        ;Valid entry?
  JZ  >B40                          ;If not, skip it
  SHL  AX,3                         ;Multiply by 8 (convert bytes to bits)
  ADD  AX,(TokenOHBits+DataOHBits)  ;Add in the Overhead bits
  ADD  EBX,EAX                      ;Add it to the Accumulator
B40:                                ;Go to next table entry
  LOOP B10                          ;Keep looking
  MOV  AX,FLEntries                 ;Compensate
  MOV  CX,DX                        ;  for the
  XOR  DX,DX                        ;  periodicity
  DIV  CX                           ;  (multiply
  SHR  CX,1                         ;   by the
  CMP  DX,CX                        ;   number of times
  JB  >B45                          ;   the TDs will occur
  INC  AX                           ;   in a
B45:                                ;   total
  MUL  EBX                          ;   frame period)
  CALL CalcBusBitsUsed              ;Get the bis already used by the Bus (ECX)
  ADD  EAX,ECX                      ;Add it to the Isoch Bits
  CMP  EAX,(IsochIntBits*FLEntries) ;Will the bus be too full?
  JBE >B80                          ;If not, it's OK
B70:                                ;Error
  STC                               ;Set Error Flag
  JMP >B90                          ;Done
B80:                                ;OK
  CLC                               ;Set OK Flag
B90:                                ;Done
  POP  DS,SI,EDX,ECX,EBX,EAX        ;Restore used registers
  RET

CopyI14IsochInfo2TD2:
  PUSH SI,DS                      ;Save used registers
  MOV  SI,W ES:[IsochInt14Ptr][0] ;Set DS:[SI] to point at
  MOV  DS,W ES:[IsochInt14Ptr][2] ;  the original Int 14 Structure
  CALL CopyI14IsochInfo2TD        ;Copy the Data
  POP  DS,SI                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY APPROPRIATE ISOCH INFORMATION FROM INT 14 STRUCTURE TO TD
;Inputs:  DS:[SI] = Int 14 Structure
;         ES:[DI] = TD to store it in
;Outputs: CF = Set if error (invalid Data somewhere)
;              BP = Error Code
;            = Clear if OK
;              BP = Undefined
;Changes: Copies Low Speed, End Point, Device Address
;                Max Packet Size, Bytes To Transfer (for Transaction),
;                User Packet ID, Call back Address, Data Buffer Address
;                Bytes to Transfer (Actual Packet TD), Direction (IN/OUT)
;                Also presets TDTransErrCount
;         Always starts with Data0!
;------------------------------------------------------------------------------
CopyI14IsochInfo2TD:
  PUSH EAX,BX                    ;Save used registers
  MOV  BL,[SI].I14RFlags         ;Get the Request Flags
  MOV  AL,TDPacketOut            ;Assume it's OUT
  TEST BL,I14RFlagIn             ;Is it a IN?
  JZ  >I05                       ;If not, leave things as OUT
  OR   ES:[DI].TDFlags,TDFlagIn  ;If so, mark it as IN
  MOV  AL,TDPacketIn             ;Packet Token needs to be IN
I05:                             ;Direction is handled
  MOV  B ES:[DI].TDToken[0],AL   ;Store the IN/OUT Packet Token
  MOV  BP,I14RErrDeviceAddress   ;Assume Bad Device Address
  MOV  AL,[SI].I14RDeviceAddress ;Get the Device Address
  CMP  AL,1                      ;Is it Device 0 or 1?
  JBE >I70                       ;If so, Error
  CMP  AL,(ADEntries-1)          ;Is it valid?
  JA  >I70                       ;If not, there's an error
  CALL TestDvcLowSpeed           ;Is it Low-Speed?
  JNZ >I70                       ;If so, Error (Isoch can't be Low Speed)
  CALL SetTDDeviceAddress        ;If OK, store it
  MOV  BP,I14RErrEndPoint        ;Assume Bad EndPoint
  MOV  AL,[SI].I14REndPoint      ;Get the EndPoint
  CMP  AL,15                     ;Is it valid?
  JA  >I70                       ;If not, there's an error
  CALL SetTDEndPoint             ;If OK, store it
  MOV  EAX,[SI].I14RDataAddress  ;Get Buffer Address
  TEST BL,I14RFlagAddrIsPhys     ;Is it a physical address (not seg:off)?
  JNZ >I20                       ;If so, no need to change it
  MOV  BP,I14RErrDataAddress     ;Assume we can't convert the address
  CALL SegOff2PhysAddrEAX        ;If not, convert it to a physical address
  JC  >I70                       ;If error, quit
I20:                             ;Physical Address1 is in EAX
  MOV  ES:[DI].TDBuffPointer,EAX ;Store the buffer address
  PUSH  [SI].I14RPeriodicity     ;Copy the Periodicity
  POP   W ES:[DI].TDPeriodicity  ;  (we checked validity earlier)
  CALL CopyI14RCallBack2TD       ;Copy Call Back Addr & User Pkt ID to TD
  JMP >I80                       ;We're done
I70:                             ;Error
  STC                            ;Set the error flag
  JMP >I90                       ;We're done
I80:                             ;OK
  CLC                            ;Set the OK flag
I90:                             ;We're done
  POP  BX,EAX                    ;Restore used registers
  RET

#ENDIF ;StartIsochPacket and support routines

;------------------------------------------------------------------------------
;START A CONTROL PACKET REQUEST ON THE USB BUS
;Inputs:  DS:[SI] = Int 14 Request Structure
;             ES  = Our TSR Data Area
;             AH  = Host Index (-1 or Ours)
;Outputs: CF = Set if error
;              CX = DX = -1
;              BP =Error Code
;            = Clear if OK
;              CX = Handle (TD Index Number)
;              DL = Closure ID
;              DH = -1
;              BP =Undefined
;Changes: Starts Control Packet Request on USB Bus if data is valid
;------------------------------------------------------------------------------
StartControlPacket:
  PUSH EAX,BX,DI                  ;Save used registers
  PUSHF                           ;Save flags
  CALL TestHostAndHalted          ;Test for valid Host Index, not Halted
  JC  >C75                        ;If error, quit
  CLI                             ;Disable interrupts
  CALL TestIllegalControls        ;Test for Illegal Control Packets
  JC  >C75                        ;If Illegal, quit
  CALL GetAvailTD                 ;Get a Transfer Descriptor (ES:DI)
  JC  >C75                        ;If error, we're done (sets BP)
  CALL CopyI14PktInfo2TD          ;Copy the "generic" Info to the TD
                                  ;  (Dvc Addr, EndPoint, CallBack, UserPktID
                                  ;   and LowSpeed)
  JC  >C70                        ;If error, we're done (sets BP)
  CALL CopyCtlTimeout2TD          ;Copy Timeout, [CloseID], Retries, Short Packet
  JC  >C70                        ;If error, quit
  CALL CopyCtlDirSize2TD          ;Get Direction & Size from Setup Request Pkt
  MOV  AX,SetupReqSize            ;Set number of byte to Transfer
  CALL SetTDMaxLength             ;  in TD
  PUSH D ES:[DI].TDBuffPointer    ;Store the
  POP  D ES:[DI].TDDataAddress    ;  "real" data address
  MOV  BP,I14RErrResources        ;Assume No setup Request available
  CALL GetAvailSetupReq           ;Get a blank SetupRequest Structure (BX)
  JC  >C70                        ;If none available, quit (sets BP)
  MOV  ES:[BX].SRTDOffset,DI      ;Store TD Offset in the SetupRequest
  MOV  BP,I14RErrDataAddress      ;Assume we can't convert the address
  PUSH ES                         ;Convert
  PUSH BX                         ;  Setup Request
  POP  EAX                        ;  Address
  CALL SegOff2PhysAddrEAX         ;  to a Physical Address
  JC  >C70                        ;If error, quit
  MOV  ES:[DI].TDBuffPointer,EAX  ;If OK, store it in the TD
  PUSH D [SI].I14RSetupReqData    ;Copy Control Request
  POP  D ES:[BX].SRRequestType    ;  from Int 14 Structure
  PUSH D [SI].I14RSetupReqData[4] ;  to
  POP  D ES:[BX].SRIndex          ;  SetupRequest Structure
  CALL TestTDForHolding           ;Schedule it, putting On Hold if needed
  JMP >C80                        ;We're done
C70:                              ;Error with TD already reserved
  CALL ReleaseTD                  ;Release TD - It's not needed
C75:                              ;Error, no TD Reserved yet
  MOV  CX,-1                      ;CX = -1
  XOR  DX,CX                      ;DX = -1
  POPF                            ;Restore flags
  STC                             ;Set the error flag
  JMP >C90                        ;We're done
C80:                              ;Packet Sent
  CALL TDOffset2Index             ;CX = TD Index # (Request Handle)
  MOV  DH,-1                      ;DH = -1
  MOV  DL,ES:[CloseID]            ;DL = Closure ID
  POPF                            ;Restore flags
  CLC                             ;Set the OK flag
C90:                              ;We're done
  POP  DI,BX,EAX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST A CONTROL REQUEST TO SEE IF IT'S "LEGAL"
;Inputs:  DS:[SI] = Int 14 Request Structure
;             ES  = TSR Data Area
;         [DI] = TD we're testing
;Outputs: CF = Clear if OK
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
TestIllegalControls:
  MOV  BP,I14RErrSetupReqData   ;BP = Error Code
  CMP  W [SI].I14RSetupReqData,((SRRQSetAddress SHL 8)+SRRTOut+SRRTTypeStandard+SRRTRecipDevice)
  JNE >L80                      ;If not Set Address, it's OK
  CMP  [SI].I14RDeviceAddress,0 ;If so, is it to Address 0?
  JE  >L80                      ;If so, it's OK
L70:                            ;Error
  STC                           ;Set Error Flag
  JMP >L90                      ;Done
L80:                            ;OK
  CLC                           ;Set OK Flag
L90:                            ;Done
  RET

;------------------------------------------------------------------------------
;TEST A CONTROL TD TO SEE IF IT SHOULD BE PUT ON HOLD
;Inputs:   ES  = TSR Data Area
;         [DI] = TD we're testing
;Outputs: Schedules TD in the Queue
;         If another Control TD with same Address & EndPoint is already
;           scheduled, the TD is marked as On Hold and set to Inactive
;         If no other TD is already scheduled, the TD is set to Active
;Changes:
;NOTES: This scans through the existing Control Queue, looking for
;         Active TD's with the same Address & EndPoint.
;------------------------------------------------------------------------------
TestTDForHolding:
  PUSH AX,CX,DI,DS               ;Save used registers
  PUSHF                          ;Save flags
  CLI                            ;Disable interrupts
  MOV  DS,ES                     ;Point DS at TSR Data Area
  MOV  B [DI].TDToken[0],TDPacketSetup ;Packet Type = Setup
  MOV  AL,TDTypeControlSetup     ;Mark it as
  CALL SetTDType                 ;  a Control Setup Request
  CALL GetTDDeviceAddress        ;Is it
  CMP  AL,1                      ;  Address 1 (Root Hub/Fake Address)?
  JE  >H40                       ;If so, we don't need to put it On Hold
  CALL FindTDNotOnHold           ;Is there an Active Control TD to this Device?
  JC  >H40                       ;If not, no need to put in On Hold
H20:                             ;Need to put TD On Hold
  OR   [DI].TDFlags,TDFlagOnHold ;Mark as On Hold
  MOV  CL,[DI].TDTimeoutIndex    ;Get the Timeout Table Index
  PUSH DI                        ;Save TD Pointer
  CALL TTIndex2Offset            ;Mark the Timeout Table Entry
  OR   [DI].TTFlags,TTFlagOnHold ;  as On Hold
  POP  DI                        ;Restore TD Pointer
H40:                             ;Schedule the TD
  CALL AddSetupTD2ControlQH      ;Schedule the TD
  POPF                           ;Restore flags
  POP  DS,DI,CX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;START A ONE-TIME INTERRUPT PACKET REQUEST ON THE USB BUS
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         AH = Host Index (-1 or Ours)
;Outputs: CF = Set if error
;              CX = DX = -1
;              BP =Error Code
;            = Clear if OK
;              CX = Handle (TD Index Number)
;              DL = Closure ID
;              DH = -1
;              BP =Undefined
;Changes: Starts One-time Interrupt Packet Request on USB Bus if data is valid
;------------------------------------------------------------------------------
StartInt1TPacket:
  PUSH AX,DI                        ;Save used registers
  CALL TestHostAndHalted            ;Test for valid Host Index, not Halted
  JC  >O70                          ;If error, quit (returns Error Code in BP)
  MOV  BP,I14RErrPeriodicity        ;Assume bad Periodicity
  MOV  CX,[SI].I14RPeriodicity      ;Get the number of milliseconds to Delay
  JCXZ >O70                         ;If 0, Error
  CALL GetAvailTD                   ;Get a Transfer Descriptor (ES:DI)
  JC  >O70                          ;If error, we're done (sets BP)
  MOV  W ES:[DI].TDLastFrameUsed,-1 ;Mark as not scheduled yet
  CALL CopyI14RCallBack2TD          ;Copy Call Back Addr & User Pkt ID to TD
  XOR  AX,AX                        ;Assume less than one time through the FL
  CMP  CX,FLEntries                 ;Is it more than one time through the FL?
  JB  >O20                          ;If not, handle it
  MOV  AX,FLEntries                 ;If so,
  SUB  CX,AX                        ;  calculate next
  XCHG AX,CX                        ;  delay factor to use
O20:                                ;BX contains
  MOV  W ES:[DI].TDPeriodicity,AX   ;Number of Milliseconds to Delay next time
  CALL Add1TimeIntTD2FL             ;Schedule it
  JMP >O80                          ;We're done
O70:                                ;Error with TD already reserved
  MOV  CX,-1                        ;CX = -1
  STC                               ;Set the error flag
  JMP >O90                          ;We're done
O80:                                ;Packet Sent
  CALL TDOffset2Index               ;CX = TD Index # (Request Handle)
  CALL GetCloseID                   ;DL = Closure ID
  MOV  ES:[DI].TDCloseID,DL         ;Store it in the TD
  CLC                               ;Set the OK flag
O90:                                ;We're done
  POP  DI,AX                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY APPROPRIATE INFORMATION FROM INT 14 STRUCTURE TO TD (ALL TD's EXC ISOCH)
;Inputs:  DS:[SI] = Int 14 Structure
;         ES:[DI] = TD to store it in
;Outputs: CF = Set if error (invalid Data somewhere)
;              BP = Error Code
;            = Clear if OK
;              BP = Undefined
;Changes: Copies Low Speed, End Point, Device Address
;                Max Packet Size, Bytes To Transfer (for Transaction),
;                User Packet ID, Call Back Address, Data Buffer Address
;                Bytes to Transfer (Actual Packet TD), Direction (IN/OUT)
;------------------------------------------------------------------------------
CopyI14PktInfo2TD:
  PUSH EAX,BX,CX                 ;Save used registers
  PUSHF                          ;Save Flags
  CLI                            ;Disable Interrupts
  MOV  BL,[SI].I14RFlags         ;Get the Request Flags
  MOV  AL,TDPacketOut            ;Assume it's OUT
  TEST BL,I14RFlagIn             ;Is it IN?
  JZ  >D05                       ;If not, leave things as OUT
  OR   ES:[DI].TDFlags,TDFlagIn  ;If so, mark it as IN
  MOV  AL,TDPacketIn             ;Packet Token needs to be IN
D05:                             ;Direction is handled
  MOV  B ES:[DI].TDToken[0],AL   ;Store the IN/OUT Packet Token
  MOV  BP,I14RErrEndPoint        ;Assume Bad EndPoint
  CALL GetEPMaxPktSizeI14        ;Get Max Packet Size for EndPoint (CX, ZF)
  JZ  >D70                       ;If Bad End Point, Error
  MOV  AL,[SI].I14RDeviceAddress ;Calculate and Set
  CALL CopyAddressLowSpeed2TD    ;  Low Speed as necessary
  CALL SetTDDeviceAddress        ;Store the Device Address
  MOV  AL,[SI].I14REndPoint      ;Store the
  CALL SetTDEndPoint             ;  End Point
  MOV  EAX,[SI].I14RDataAddress  ;Get Buffer Address
  TEST BL,I14RFlagAddrIsPhys     ;Is it a Physical Address (not Seg:Off)?
  JNZ >D20                       ;If so, no need to change it
  MOV  BP,I14RErrDataAddress     ;Assume we can't convert the address
  CALL SegOff2PhysAddrEAX        ;If not, convert it to a physical address
  JC  >D70                       ;If error, quit
D20:                             ;Physical Address is in EAX
  MOV  ES:[DI].TDBuffPointer,EAX ;Store the buffer address
  MOV  AX,[SI].I14RDataSize      ;Copy the number of bytes
  MOV  ES:[DI].TDBytesToXfer,AX  ;  to Transfer
  CMP  AX,CX                     ;Is actual data bigger than Max Packet Size?
  JBE >D30                       ;If not, it's OK
  MOV  AX,CX                     ;Just make it the Max Packet Size
D30:                             ;Data Size is OK
  CALL SetTDMaxLength            ;Store it
  CALL CopyI14RCallBack2TD       ;Copy Call Back Addr & User Pkt ID to TD
  JMP >D80                       ;We're done
D70:                             ;Error
  POPF                           ;Restore Flags
  STC                            ;Set the error flag
  JMP >D90                       ;We're done
D80:                             ;OK
  POPF                           ;Restore Flags
  CLC                            ;Set the OK flag
D90:                             ;We're done
  POP  CX,BX,EAX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SET APPROPRIATE TIMEOUT COUNTER FOR CONTROL OR BULK TD, GIVEN A SETUP REQUEST
;Inputs:  DS:[SI] = Int 14 Request (Contains Setup Request)
;         ES:[DI] = TD to Modify (if Control)
;                 = QH to Modify (if Bulk)
;Outputs: CF = Clear if OK
;              Sets up a Timeout Table Entry for the Transaction, and Stores it
;              If Control, copies and stores Retries & ShortPacketOK Flag
;              Also gets and stores TTCloseID
;         CF = Set if error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
CopyBulkTimeout2QH:
  PUSH AX,BX,DX                     ;Save used registers
  MOV  BX,OFFSET QHBulkTimeOutIndex ;Need Offset of QHBulkTimeOutIndex
  MOV  AL,DefBulkTimeout            ;Default Timeout Value
  XOR  DH,DH                        ;Mark as Bulk
  JMP >T00                          ;Do it
CopyCtlTimeout2TD:
  PUSH AX,BX,DX                     ;Save used registers
  MOV  BX,OFFSET TDTimeOutIndex     ;Need Offset of TDTimeOutIndex
  MOV  AL,DefControlTimeout         ;Default Timeout Value
  MOV  DH,-1                        ;Mark as Control
;  JMP >T00                          ;Do it
T00:
  PUSH CX,DI                        ;Save used registers
  ADD  BX,DI                        ;Put TimeoutIndex Pointer in BX
  CALL GetTimeoutTicksSI            ;Get Timout Ticks (uses AL&SI, sets AX&BP)
  JZ  >T70                          ;If Error, quit
  MOV  BP,I14RErrResources          ;Error = Lack of Resources
  CALL GetAvailTT                   ;If OK, get a Timeout Table entry (ES:[DI])
  JC  >T70                          ;If error, we're done
  MOV  ES:[DI].TTDelayCounter,AX    ;Store
  MOV  ES:[DI].TTOrigDelay,AX       ;  Timer Ticks
  CALL GetCloseID                   ;Get Closure ID (DL)
  MOV  ES:[DI].TTCloseID,DL         ;Store it in the Timeout Table
  OR   DH,DH                        ;Is it Control?
  JZ  >T50                          ;If not, no Retries & Short Packets
T10:                                ;Is a Control Packet
  TEST [SI].I14RFlags,I14RFlagShortPktOK ;Need to set the Short Packet OK Flag?
  JZ  >T15                          ;If not, continue
  OR   ES:[DI].TTFlags,TTFlagSPktOK ;If so, set it
T15:                                ;Short Packet OK flag handled
  TEST [SI].I14RFlags,I14RFlagNoRetries ;Retry multiple times?
  JZ  >T50                          ;If so, retries are already set at 8
  OR   ES:[DI].TTFlags,20h          ;If not, set retry counter to 1
T50:                                ;Done setting up TT entry
  CALL TTOffset2Index               ;Get the TT Index Number (CX)
  MOV  ES:[BX],CL                   ;Store it in the appropriate place
  JMP >T80                          ;Done
T70:                                ;Error
  STC                               ;Set error flag
  JMP >T90                          ;Done
T80:                                ;OK
  CLC                               ;Set OK flag
T90:                                ;Done
  POP  DI,CX                        ;Restore used registers
  POP  DX,BX,AX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THE HOST INDEX IS FOR US, AND WHETHER THE HOST IS RUNNING
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         AH = Host Index (-1 or Ours)
;Outputs: CF = Clear if OK (Our Host, Host is Running)
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
TestHostAndHalted:
  PUSH AX                   ;Save used registers
  MOV  BP,I14RErrHostIndex  ;Assume Bad Host Index
  CMP  AH,AllHostsIndex     ;Is it for All Hosts?
  JE  >H70                  ;If so, Error
  MOV  BP,I14RErrHostHalted ;Assume Host is halted
  CALL TestHostHalted       ;Is the Host even running?
  JZ  >H80                  ;If so, it's OK
  CALL ReadUSBCommandWord   ;Read the USB Command Register
  TEST AL,UCSoftDebug       ;Is is Halted because it's in Debug Mode?
  JNZ >H80                  ;If so, it's OK
H70:                        ;Error
  STC                       ;Set Error Flag
  JMP >H90                  ;Done
H80:                        ;OK
  CLC                       ;Set OK Flag
H90:                        ;Done
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT CLOSURE ID TO USE
;Inputs:  ES = TSR Data Area
;         ES:[CloseID] = Stored Closure ID
;Outputs: DL = Closure ID to use
;              Updates Closure ID for next time
;Changes:
;------------------------------------------------------------------------------
GetCloseID:
  MOV  DL,ES:[CloseID] ;Get the store ID
  INC  DL              ;Increment it
  CMP  DL,8            ;Is it at least 8?
  JAE >C90             ;If so, it's OK
  MOV  DL,8            ;If not, make it 8
C90:                   ;Done
  MOV  ES:[CloseID],DL ;Store it for next time
  RET

;------------------------------------------------------------------------------
;SET APPROPRIATE DIRECTION (IN/OUT) AND DATA SIZE TO A TD, GIVEN A SETUP REQUEST
;Inputs:  DS:[SI] = Int 14 Request (Contains Setup Request)
;         ES:[DI] = TD to Modify
;Outputs: Sets Direction (In/Out) in TD
;Changes:
;------------------------------------------------------------------------------
CopyCtlDirSize2TD:
  AND  ES:[DI].TDFlags,(NOT TDFlagIn)   ;Assume OUT
  TEST B [SI].I14RSetupReqData.SRRequestType,SRRTIn ;Is it OUT?
  JZ  >D20                              ;If so, continue
  OR   ES:[DI].TDFlags,TDFlagIn         ;If not, it's IN
D20:                                    ;Is IN
  PUSH W [SI].I14RSetupReqData.SRLength ;Copy the Data Size
  POP  W ES:[DI].TDBytesToXfer          ;  to the TD
  RET

;------------------------------------------------------------------------------
;SET APPROPRIATE SPEED (LOW/FULL) IN A TD, GIVEN AN ADDRESS
;Inputs:  AL    = Device Address to use
;         ES:DI = TD to Modify
;Outputs: ZF = Set if Full Speed
;            = Clear if Low Speed
;Changes: Sets/Unsets Low Speed flag in TD
;------------------------------------------------------------------------------
CopyAddressLowSpeed2TD:
  PUSH AX                                ;Save used registers
  CALL TestDvcLowSpeed                   ;Is it Low-Speed?
  MOV  AL,B ES:[DI].TDControlStatus[3]   ;Get Current Low Speed Byte
  JZ  >L20                               ;If Full Speed, handle it
  OR   AL,(TDLowSpeedDevice SHR 24)      ;Set Low Speed
  JMP >L30                               ;Do it
L20:                                     ;Device is Full Speed
  AND  AL, NOT (TDLowSpeedDevice SHR 24) ;Set Full Speed
L30:                                     ;Speed is set in CL
  MOV  B ES:[DI].TDControlStatus[3],AL   ;Store it
  TEST AL,(TDLowSpeedDevice SHR 24)      ;Set return flag
  POP  AX                                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A DEVICE IS LOW-SPEED OR NOT
;Inputs:  AL = Device Address to Test
;         ES = TSR Data Area
;Outputs: ZF = Clear if Device is Low-Speed
;            = Set if Device is Full-Speed
;Changes:
;------------------------------------------------------------------------------
TestDvcLowSpeed:
  PUSH CX,DI          ;Save used registers
  MOV  CL,AL          ;Point at the
  CALL ADIndex2Offset ;  Address Table Entry
  TEST ES:[DI].ADFlags,ADFlagLowSpeed ;Set Return Flag
  POP  DI,CX          ;Restore used registers
  RET


#IF !LITE

;------------------------------------------------------------------------------
;ADD AN ISOCHRONOUS TRANSFER DESCRIPTOR TO A FRAME LIST ENTRY
;Inputs:  ES:DI = Pointer of TD to Add (Frame Number is embedded in it)
;Outputs:
;Changes: Schedules the TD
;------------------------------------------------------------------------------

;Seems that higher priority interrupts can screw up the schedule:
;  need to Disable Interrupts all the way from figuring out which FL Index
;  to use until it's actually scheduled!!

;Set error if insufficient space?

AddIsochTD2FL:
  PUSH EAX,BX,CX,DI,SI,DS     ;Save used registers
  PUSHF                       ;Save Flags
  MOV  DS,ES                  ;Point DS at the correct data area
  MOV  SI,DI                  ;Save the Pointer we're adding
  CLI                         ;Disable interrupts
  MOV  AL,TDTypeIsoch         ;Mark it as
  CALL SetTDType              ;  Isochronous
  CALL UpdateSpecificFrame    ;Get the FL Index to Add it to (CX)
  CALL FLIndex2Offset         ;Convert Index to a Pointer (DI)
  MOV  EAX,[DI].FLLinkPointer ;Get address currently stored in FL
  CALL CalcPhysAddrType       ;Is it already another
  CMP  BL,PhysAddrTypeIsochTD ;  Isochronous TD?
  JNE >I20                    ;If not, jump to handle first TD!
I10:                          ;Loop to here to find last Isoch TD
  CALL PhysAddr2SegOffNoFlags ;Convert the Address to an Offset
  MOV  EAX,[DI].TDLinkPointer ;Get what it's pointed at
  CALL CalcPhysAddrType       ;Is it
  CMP  BL,PhysAddrTypeIsochTD ;  another Isochronous TD?
  JE   I10                    ;If so, keep looking
  XCHG DI,SI                  ;Swap TD addresses
  MOV  [DI].TDLinkPointer,EAX ;Put the correct address into the
                              ;  LinkPointer of the TD we're adding
  CALL SegOff2PhysAddrESDI    ;Convert the LinkPointer we're adding
  MOV  [SI].TDLinkPointer,EAX ;  to a physical address, and store it
  JMP >I50                    ;Jump to finish things up
I20:                          ;No Isochronous TD's in FL yet
  MOV  [SI].TDLinkPointer,EAX ;Put old FL Pointer into LinkPointer
  XCHG DI,SI                  ;Convert the TD we're entering
  CALL SegOff2PhysAddrESDI    ;  to a physical address
  MOV  [SI].FLLinkPointer,EAX ;Put it into the FL Link Pointer
                              ;  FLTerminate = 0, FLQHSelect = 0
I50:                          ;DI = New TD we're adding
  OR   W [DI].TDControlStatus[2],((TDShortPacketDetect+TDIsochSelect+TDIntOnComplete+TDActive) SHR 16)
                              ;ErCt=0, Isoch, SPD, IOC, Active, Data0
  POPF                        ;Restore Flags
  POP  DS,SI,DI,CX,BX,EAX     ;Restore used registers
  RET

#ENDIF

;------------------------------------------------------------------------------
;ADD A 1-TIME OR PERIODIC INTERRUPT TRANSFER DESCRIPTOR TO A FRAME LIST ENTRY
;Inputs:  CX = Number of Frames to add to current FL Index
;              Only valid if One-Time Int or if Periodic Int with
;                UseSpecificFrame = False
;              If UseSpecificFrame = True, Frame Number to use
;                is embedded in TD
;         ES:DI = Pointer of TD to Add
;Outputs:
;Changes: Schedules the TD
;NOTES:   If Periodic Interrupt, TD must already contain addresses, flags, etc.
;         For One-Time Interrupt, this sets the Device Address to 1 (Root Hub)
;           and EndPoint to 15, which is a non-existent Device and EndPoint
;         This will always return an Error from the Bus, but we don't care
;------------------------------------------------------------------------------
Add1TimeIntTD2FL:
  PUSH EAX                     ;Save used registers
  MOV  AL,TDTypeInterrupt1Time ;Mark it as
  CALL SetTDType               ;  a 1-time Interrupt
  MOV  AL,1                    ;Set
  CALL SetTDDeviceAddress      ;  Device Address
  MOV  AL,0                    ;Set
  CALL SetTDEndPoint           ;  End Point
  MOV  B ES:[DI].TDToken[0],TDPacketIn ;Direction = IN
  MOV  AX,1                    ;Mark as One-Time Interrupt (Add if FL Full)
  JMP >T00                     ;Do it
AddPerIntTD2FL:
  PUSH EAX                     ;Save used registers
  MOV  AL,TDTypeInterruptPer   ;Mark it as
  CALL SetTDType               ;  a periodic Interrupt
  MOV  AX,-1                   ;Mark as Periodic Interrupt (Subtract if FL Full)
;  JMP >T00                     ;Do it
T00:
  PUSH BX,CX,DX,DI,SI,DS         ;Save used registers
  PUSHF                          ;Save Flags
  MOV  DS,ES                     ;Point DS at the correct data area
  MOV  SI,DI                     ;Save the Pointer we're adding
  CLI                            ;Disable interrupts
  TEST [DI].TDFlags,TDFlagSpecificFrame ;Using a specific Frame?
  JZ  >T10                       ;If not, find a Frame with enough space
  CALL UpdateSpecificFrame       ;If so, calculate and store the Specific Frame
                                 ;  Returns CX = Frame Index to use
  JMP >T15                       ;Schedule it
T10:                             ;Not using a Specific Frame
  CALL FindFLWithEnoughSpace     ;Make sure FL has enough space
                                 ;  Returns CX = Frame Number to use
  MOV  [DI].TDLastFrameUsed,CX   ;Store Frame Index in TD (to handle TD Skips)
  AND  CX,FrNumIndexMask         ;Convert Frame Number to Frame Index
T15:                             ;Have Frame Number to use (CX)
  CALL CopyIntLastFrameUsed      ;Copy Last Frame Used to all TD's in Queue
  CALL FLIndex2Offset            ;Convert the Index to a Pointer (DI)
  JMP >T25                       ;Jump to test it
T20:                             ;Loop to here to find last TD
  CALL PhysAddr2SegOffNoFlags    ;Convert the Address to an Offset
T25:                             ;EAX contains LinkPointer
  MOV  EAX,[DI].TDLinkPointer    ;Get what it's pointed at
                                 ;  (FLLinkPointer=TDLinkPointer=QHLinkPointer,
                                 ;   so this works for all possible scenarios)
  CALL CalcPhysAddrType          ;Is it
  CMP  BL,PhysAddrTypeControlQH  ;  the Control Queue?
  JNE  T20                       ;If not, keep looking
T30:                             ;[DI] = previous TD/FL, [SI] = TD/QH to add
  XCHG  DI,SI                    ;Point [DI] at TD, [SI] at FL
  CALL GetIntQHPtrDI             ;Is the TD in a Queue (returns [DI] = QH)?
  JC  >T35                       ;If not, handle a single TD
  MOV  [DI].QHLinkPointer,EAX    ;Put old FL Pointer into QHLinkPointer
  CALL SegOff2PhysAddrESDI       ;Get Physical Address of QH
  OR   AL,TDQHSelect             ;Mark it as a Queue
  MOV  [SI].QHLinkPointer,EAX    ;Store the new TD in the LinkPointer
  JMP >T90                       ;Done
T35:                             ;It's a single TD ([DI] = TD, [SI] = FL)
  MOV  [DI].TDLinkPointer,EAX    ;Put old FL Pointer into TDLinkPointer
  CALL SegOff2PhysAddrESDI       ;Get Physical Address of TD
T37:                             ;EAX contains Address of new TD/QH
  MOV  [SI].TDLinkPointer,EAX    ;Store the new TD in the LinkPointer
T50:                             ;DI = New TD we're adding
  OR   W [DI].TDControlStatus[2],((TDErrorCount1+TDIntOnComplete+TDActive) SHR 16)
                                 ;Reset appropriate Flags
T90:                             ;Done
  POPF                           ;Restore Flags
  POP  DS,SI,DI,DX,CX,BX         ;Restore used registers
  POP  EAX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY THE NEW SCHEDULED FRAME NUMBER INTO ALL TD's IN AN INTERRUPT QUEUE
;Inputs:  DS = ES = TSR Data Area
;         ES:[DI] = TD with the new (legitimate) Frame Number to use
;                     May not be part of a Queue, and may not be Periodic!
;Outputs: CF = Clear if it worked
;              Frame Number Copied to all TD's in the Queue
;            = Set if Error (Not a Periodic Interrupt in a Queue)
;Changes:
;------------------------------------------------------------------------------
CopyIntLastFrameUsed:
  PUSH AX,DI                   ;Save used registers
  MOV  AX,[DI].TDLastFrameUsed ;Get the Last Frame used
  CALL GetFirstIntTD           ;Point at the First TD
  JC  >U90                     ;If no Queue, we're done
U10:                           ;Loop to here for each TD in the Queue
  OR   W [DI].TDControlStatus[2],((TDErrorCount1+TDIntOnComplete+TDActive) SHR 16)
                               ;Reset appropriate Flags
  MOV  [DI].TDLastFrameUsed,AX ;Store the Last Frame Used
  CALL GetNextIntTD            ;Point at the Next TD
  JNC  U10                     ;If there is a next TD, keep going
  CLC                          ;Set the TD-in-Queue flag
U90:                           ;Done
  POP  DI,AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE QH POINTER, FIRST TD POINTER, OR NEXT TD POINTER FOR A PERIODIC INT TD
;Inputs:  ES = TSR Data Area
;         ES:[DI] = TD to work with
;                     May not be a Periodic Interrupt
;                     May not be in a Queue
;Outputs: CF = Clear if OK
;              [BX] = Pointer to QH (If GetIntQHPtrBX)
;              [DI] = Pointer to QH (If GetIntQHPtrDI)
;              [DI] = First TD in the Queue (If GetFirstIntTD)
;                   = Next TD in the Queue (If GetNextIntTD)
;            = Set if Error (not Periodic Int in Queue, or last TD for GetNext)
;              BX/DI = unchanged
;Changes:
;------------------------------------------------------------------------------
TestIntTDInQH:
  PUSH BX            ;Save used registers
  CALL GetIntQHPtrBX ;Try to get the QH Pointer (Sets CF)
  POP  BX            ;Restore used registers
  RET

GetIntQHPtrDI:
  PUSH BX            ;Save used registers
  CALL GetIntQHPtrBX ;Get the QH Pointer
  JC  >S90           ;If none, quit
  MOV  DI,BX         ;If OK, put the poiner in SI
S90:                 ;Done
  POP  BX            ;Restore used registers
  RET

GetIntQHPtrBX:
  PUSH AX                       ;Save used registers
  CALL GetTDType                ;Is it a
  CMP  AL,TDTypeInterruptPer    ;  Periodic Interrupt?
  JNE >Q70                      ;If not, error
  MOV  AX,ES:[DI].TDIntQHOffset ;Get the QH Offset
  OR   AX,AX                    ;Is there a Queue?
  JZ  >Q70                      ;If not, error
  MOV  BX,AX                    ;If so, put the Pointer in BX for the return
  JMP >Q80                      ;Done
Q70:                            ;Error
  STC                           ;Set error flag
  JMP >Q90                      ;Done
Q80:                            ;OK
  CLC                           ;Set OK flag
Q90:                            ;Done
  POP  AX                       ;Restore used registers
  RET

GetFirstIntTD:
  PUSH BX                       ;Save used registers
  CALL GetIntQHPtrBX            ;Is it a Periodic Interrupt in a Queue?
  JC  >F90                      ;If not, error
  MOV  DI,ES:[BX].QHIntTDOffset ;If so, get the First TD Pointer
  CLC                           ;Set OK flag
F90:                            ;Done
  POP  BX                       ;Restore used registers
  RET

GetNextIntTD:
  PUSH EAX,BX                    ;Save used registers
  CALL GetIntQHPtrBX             ;Is it a Periodic Interrupt in a Queue?
  JC  >N70                       ;If not, error
  MOV  EAX,ES:[DI].TDLinkPointer ;Get the Link Pointer
  TEST AL,TDTerminate            ;Was this the last TD in the Queue?
  JNZ >N70                       ;If so, error
  CALL PhysAddr2SegOffNoFlags    ;If not, convert it to an Offset
  JMP >N80                       ;Done
N70:                             ;Error
  STC                            ;Set error flag
  JMP >N90                       ;Done
N80:                             ;OK
  CLC                            ;Set OK flag
N90:                             ;Done
  POP  BX,EAX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE NEXT FRAME NUMBER FOR A SPECIFIC-FRAME ISOCH OR PERIODIC INT TD
;Inputs:  ES:[DI] = TD to update (Isoch or Periodic Int)
;Outputs: CX = FL Index to Schedule this in
;              Stores Frame Number in TDLastFrameUsed
;Changes:
;------------------------------------------------------------------------------
UpdateSpecificFrame:
  PUSH AX                         ;Save used registers
  MOV  AX,ES:[DI].TDLastFrameUsed ;Get Frame Number from Last Time
  ADD  AX,ES:[DI].TDPeriodicity   ;Add the Periodicity
  CALL CvtFrNum2FrNum             ;Roll it over, if necessary
  MOV  ES:[DI].TDLastFrameUsed,AX ;Store it for next time
  AND  AX,FrNumIndexMask          ;Convert it to an Index for the Return
  MOV  CX,AX                      ;Put it in CX where we can use it
  POP  AX                         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND AN AVAILABLE FL NEAR THE ONE WE WANT THAT HAS ENOUGH SPACE FOR AN INT
;Inputs:  DS = ES = TSR Data Area
;         [DI] = TD we're trying to Add
;         CX = Number of Desired Frames to Add to Current FL Index
;         AX   = 1 if One-Time Interrupt (we should search forward)
;              = -1 if Periodic Int (we should search backward)
;Outputs: CX = FL Number to add TD to
;Changes:
;NOTES:   If the original (truly desired) FL is already full, this will search
;           a few FL's surrounding the original for one that does have enough
;           space.  If it can't find one nearby, it just uses the original
;           (desired) FL Index anyway and we hope for the Best!
;         The amount of bandwidth used by ay particular Packet is never
;           EXACTLY known ahead of time, anyway.  Things such as bit-stuffing
;           and unknown/variable response times from individual devices
;           will affect how long things actually take.  So, even if our
;           calculations say it won't work, it still might.
;         We also have the 10% "slop" at the end of the Frame that is
;           supposed to be reserved for Control and Bulk Transfers.
;           If our Packet is excessively long, it should simply overflow
;           and complete in the 10% Control/Bulk Time at the end of the Frame.
;           We will be able to complete fewer Control and Bulk transactions
;           as a result, but that's probably OK.  Interrupt transactions
;           do not retry if they fail, but Control and Bulk do retry (up to
;           three times).  So, the Controls and Bulks will still probably
;           end up being completed in spite of this.
;         If we really do ever get to the point where an Interrupt cannot be
;           scheduled within a few Frames of where it's supposed to go,
;           the Bus is probably so heavily overloaded that there is a
;           systemic problem anyway.  That is, either there are simply
;           way too many Devices on the Bus, or the software/device drivers
;           are badly written and are trying to schedule transactions
;           more often than they really need to.
;------------------------------------------------------------------------------
FindFLWithEnoughSpace:
  PUSH AX,BX,DX         ;Save used registers
  PUSH DI,SI,BP         ;Save used registers
  CMP  CX,3             ;Is the Adder Big enough to even use?
  JAE >F10              ;If so, keep going
  MOV  CX,3             ;If not, make it big enough
F10:                    ;FL Adder is OK
  DEC  CX               ;Subtract 1 from it
  MOV  SI,CX            ;Save original FL Adder
  CALL CalcTotalTDBits  ;Calculate number of bits in TD we're adding (CX)
  MOV  BP,CX            ;Save it in BP
  MOV  DI,AX            ;Save forward/backward search Status
  MOV  AX,SI            ;Use original FL Adder to start
  XOR  BX,BX            ;BX = Current Adder Offset
  MOV  DL,6             ;Check a maximum of 6 Frames from original requested
F20:                    ;Loop to here to find valid FL Entry
  CMP  AX,2             ;Is the FL Adder getting too small?
  JB  >F50              ;If so, just use the original Adder
  CMP  AX,FLEntries     ;Is it getting too big?
  JE  >F50              ;If so, just use the original
  CALL AddToFrameNumber ;Calculate the new Frame Number to use (CX)
  CALL CalcFLBits       ;  already scheduled in the FL (returns AX)
  ADD  AX,BP            ;Add in the new bits
  CMP  AX,IsochIntBits  ;Will this put us over the 90% limit?
  JBE >F90              ;If not, we're done!
F40:                    ;Try the next one
  MOV  AX,SI            ;Get original adder
  ADD  BX,DI            ;Add in one more
  ADD  AX,BX            ;  Shift Register
  DEC  DL               ;Done yet?
  JNZ  F20              ;If not, keep looking
F50:                    ;Just use the Original Adder
  MOV  AX,SI            ;Restore Original
  CALL AddToFrameNumber ;  Frame Number (CX)
F90:                    ;Done
  POP  BP,SI,DI         ;Restore used registers
  POP  DX,BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE TOTAL NUMBER OF BITS IN A TD
;Inputs:  DS = ES = TSR Data Area
;         [DI] = TD to work with
;Outputs: CX = Number of Bits in TD
;              If Periodic Interrupt in a Queue, returns Queue Total Bits
;Changes:
;------------------------------------------------------------------------------
CalcTotalTDBits:
  PUSH BX            ;Save used registers
  CALL GetIntQHPtrBX ;Get the QH Pointer (if there is one)
  JC  >B50           ;If none, handle a regular TD
  MOV  CX,[BX].QHIntTotalBits ;Get number of bits in Queue
  JMP >B90           ;Done
B50:                 ;Not an Interrupt Queue
  CALL CalcTDBits    ;Calculate the bits for the individual TD (CX)
B90:                 ;Done
  POP  BX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADD A TRANSFER DESCRIPTOR TO THE END OF A QUEUE
;Inputs:  ES:[DI] = Pointer to TD to Add
;         If Bulk QH, TD contains QH Pointer
;Outputs: CF = Set if it couldn't be added
;            = Clear if it was added OK
;Changes: Schedules the TD into the Queue
;NOTES:   Always sets the Queue type to Vertical
;         Only Sets SPD, TDType, ErrorCount, & IOC
;           All other values in TD & TDLocal must be set before calling this!
;           (Speed, Data1, Address, EndPoint, FarCall, Direction, etc.)
;------------------------------------------------------------------------------
AddSetupTD2ControlQH:
  PUSH EAX                            ;Save used registers
  MOV  AL,TDTypeControlSetup          ;Mark it
  JMP >C00                            ;Do it
AddDataTD2ControlQH:
  PUSH EAX                            ;Save used registers
  MOV  AL,TDTypeControlData           ;Mark it
  JMP >C00                            ;Do it
AddStatusTD2ControlQH:
  PUSH EAX                            ;Save used registers
  MOV  AL,TDTypeControlStatus         ;Mark it
C00:
  PUSH SI                             ;Save used registers
  MOV  SI,ES:[QHTable]                ;[SI] = Control QH
  JMP >A00                            ;Do it
AddTD2BulkQH:
  PUSH EAX,SI                         ;Save used registers
  MOV  AL,TDTypeBulk                  ;Mark it as Bulk
  MOV  SI,ES:[DI].TDBulkQHOffset      ;Get QH Pointer
  ;JMP >A00                            ;Do it
A00:                                  ;Add Transfer Descriptor to Queue
  PUSH EBX,DI,DS                      ;Save used registers
  PUSHF                               ;Save Flags
  MOV  DS,ES                          ;Point DS at correct data area
  CALL SetTDType                      ;Set the Transfer Descriptor Type (in AL)
  OR   B [DI].TDControlStatus[3],((TDShortPacketDetect+TDErrorCount3+TDIntOnComplete) SHR 24)
                                      ;ErCt=3, No Isoch, IOC
  CMP  AL,TDTypeBulk                  ;Is it Bulk?
  JE  >A20                            ;If so, put it at the end of the Queue
  TEST [DI].TDFlags,TDFlagOnHold      ;Is the TD on Hold?
  JNZ >A30                            ;If so, handle it
A10:                                  ;Active Control -- Put at Start of Queue
  OR   B [DI].TDControlStatus[2],(TDActive SHR 16) ;Make it Active
  CALL SegOff2PhysAddrESDI            ;Convert TD Pointer to a Physical Address
  OR   AL,TDDepthFirst                ;Mark it as Depth first
  CLI                                 ;Disable interrupts
  XCHG EAX,[SI].QHElementPointer      ;Get Vertical Pointer, Store Our Pointer
  MOV  [DI].TDLinkPointer,EAX         ;Store Vertical Pointer in our TD
  JMP >A90                            ;Done
A20:                                  ;Is Bulk -- Make Active at End of Queue
  OR   B [DI].TDControlStatus[2],(TDActive SHR 16) ;Make it Active
A30:                                  ;Put at End of Queue
  MOV  [DI].TDLinkPointer,TDTerminate ;Mark TD as last in Queue
  CALL SegOff2PhysAddrESDI            ;Convert TD Pointer to a Physical Address
  OR   AL,TDDepthFirst                ;Mark it as Depth first
  MOV  EBX,EAX                        ;Store it in EBX
  CLI                                 ;Disable interrupts
  MOV  EAX,[SI].QHElementPointer      ;Get the Vertical Pointer
  TEST AL,QHTerminate                 ;Is the Queue Empty?
  JZ  >A40                            ;If not, jump to handle it
  MOV  [SI].QHElementPointer,EBX      ;Store TD in the QH
  JMP >A90                            ;Done
A40:                                  ;Queue isn't empty - look for last TD
  CALL PhysAddr2SegOffNoFlags         ;Get the Offset of the TD
  MOV  EAX,[DI].TDLinkPointer         ;Get its Link Pointer
  TEST AL,TDTerminate                 ;Is it the last TD in the Queue?
  JZ   A40                            ;If not, keep looking for the Last One
A50:                                  ;Pointed at least TD in the Queue
  MOV  [DI].TDLinkPointer,EBX         ;Storeour TD in the TDLinkPointer
A90:                                  ;Done
  POPF                                ;Restore Flags
  POP  DS,DI,EBX                      ;Restore used registers
  POP  SI,EAX                         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE BANDWIDTH (# BITS) USED BY A FRAME LIST ENTRY (ISOCH & INT TDs)
;Inputs:  CX = Number (NOT Index) of FL to measure
;Outputs: AX = Number of bits used by Isoch & Int entries of FL
;         ZF = Set if AX = 0 bytes
;            = Clear if AX > 0 bytes
;Changes:
;------------------------------------------------------------------------------
CalcFLBits:
  PUSH DX                       ;Save used registers
  PUSH EAX,BX,CX,DI,DS          ;Save used registers
  MOV  DS,ES                    ;Point DS at the correct data area
  CALL FLIndex2Offset           ;Convert the Index to an Offset
  XOR  DX,DX                    ;Start Byte Counter at 0
  MOV  EAX,[DI].FLLinkPointer   ;Get the Link Pointer
C10:                            ;Loop to here for each Link Pointer
  CALL CalcPhysAddrType         ;What kind of Link Pointer is this pointed at?
  CMP  BL,PhysAddrTypeControlQH ;Is it the Control Queue?
  JE  >C90                      ;If so, we're done
  CALL PhysAddr2SegOffNoFlags   ;If so, convert it to an Offset
  CALL CalcTotalTDBits          ;Calculate the bandwidth it uses
  ADD  DX,CX                    ;Add it to our Counter
  MOV  EAX,[DI].TDLinkPointer   ;Get the Link Pointer of this TD
  JMP  C10                      ;Jump to see how big it is
C90:                            ;We're done
  POP  DS,DI,CX,BX,EAX          ;Restore used registers
  MOV  AX,DX                    ;Put counter in AX for the return
  OR   AX,AX                    ;Set the return flag
  POP  DX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE BANDWIDTH (# FULL-SPEED BIT TIMES) USED BY A TRANSFER DESCRIPTOR
;Inputs:  ES:DI = Offset of TD to measure
;Outputs: CX = Number of BITS (NOT Bytes) used, 0 if Invalid/Unused
;         ZF = Set if error (0 bits/invalid packet)
;            = Clear if OK (CX <> 0)
;Changes:
;NOTES:   Takes into account Overhead, & Low-/Full-Speed characteristics
;------------------------------------------------------------------------------
CalcTDBits:
  PUSH AX,BX,DS                      ;Save used registers
  MOV  DS,ES                         ;Point DS at the correct data area
  XOR  CX,CX                         ;Start byte counter at 0
  CALL GetTDType                     ;Get the Type of TD
  CMP  AL,TDTypeReserved             ;Is it Available or Reserved?
  JBE >B90                           ;If so, we're done
  MOV  BL,AL                         ;Put TD Type in DL
  CALL GetTDMaxLength                ;Get Data Size
  SHL  AX,3                          ;Convert Bytes to Bits
  MOV  CX,TokenOHBits+StatusOHBits   ;All Packets have Token, most have Status
  CMP  BL,TDTypeIsoch                ;Is it Isochronous?
  JNE >B20                           ;If not, continue
  SUB  CX,StatusOHBits               ;Isoch deosn't have a Status Pkt
B20:                                 ;Token and Status Pkts Accounted For
  OR   AX,AX                         ;Is there a Data stage?
  JZ  >B40                           ;If not, we're done
  ADD  CX,AX                         ;If so, add in the Data bits
  ADD  CX,DataOHBits                 ;Add in the Data Overhead bits
B40:                                 ;Adjust for Low Speed, if necessary
  TEST B [DI].TDControlStatus[3],(TDLowSpeedDevice SHR 24) ;Low Speed?
  JZ  >B90                           ;If not, we're done
  SHL  CX,3                          ;If so, multiply by 12/1.5 (FS/LS) factor
  ADD  CX,(LowSpeedOHBits*2)         ;Add Token and Status LS Transition OH
  OR   AX,AX                         ;Is there a Data stage?
  JZ  >B90                           ;If not, we're done
  CMP  B [DI].TDToken[0],TDPacketOut ;If so, is it Out?
  JNE >B90                           ;If not, we're done
  ADD  CX,LowSpeedOHBits             ;If so, there's another LS Preamble
B90:                                 ;Done
  OR   CX,CX                         ;Set return flag
  POP  DS,BX,AX                      ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE CALLED WHEN A HUB HAS DETECTED A NEW DEVICE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE A NEWLY CONNECTED DEVICE
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES      = Our TSR Data Area
;         AH      = Hub Index (-1 or Ours)
;Outputs: CF = Clear if OK
;              Stores Hub/Port Info in Reset Table
;              BP = Undefined
;            = Set if error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
NewDvcConn:
  PUSH EAX,DI                          ;Save used registers
  CALL TestHostAndAddress1             ;Valid Address (rtns DI)?
  JC  >C70                             ;If Error, Quit
  MOV  BP,I14RErrHostCallInUse         ;Assume already resetting
  CALL TestResetEntryNewDvc            ;Are we already Resetting?
  JNC >C70                             ;If so, Error
  MOV  BP,I14RErrResources             ;Assume Error = No Resources
  CALL GetAvailReset                   ;Get a Reset Table Entry (DI)
  JC  >C70                             ;If Error, Quit
  MOV  ES:[DI].RsRetries,ResetRetries  ;Initialize Retry counter
  TEST [SI].I14RFlags,I14RFlagLowSpeed ;Is it a Low Speed Device?
  JZ  >C20                             ;If not, continue
  OR   ES:[DI].RsFlags,RsFlagLowSpeed  ;If so, mark it as Low Speed
C20:                                   ;Speed is stored
  MOV  AX,W [SI].I14RHubAddress        ;Store the Hub Address
  MOV  W ES:[DI].RsHubAddress,AX       ;  and Port
  MOV  EAX,[SI].I14RCallBackAddr       ;Store the
  MOV  ES:[DI].RsCallBackAddr,EAX      ;  Call Back Address
  MOV  AX,[SI].I14RUserPktID           ;Store the
  MOV  ES:[DI].RsUserPktID,AX          ;  User packet ID
  JMP >C80                             ;Done
C70:                                   ;Error
  STC                                  ;Set return flag
  JMP >C90                             ;Done
C80:                                   ;OK
  CLC                                  ;Set return flag
C90:                                   ;Done
  POP  DI,EAX                          ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE CALLED WHEN A HUB HAS DETECTED A NEW DEVICE,
;  OR A RESET HAS BEEN REQUESTED
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;ENUMERATE A NEWLY CONNECTED DEVICE (OR DEVICE THAT NEEDS TO BE RESET)
;Inputs:  BX (UserPktID) = TSR Segment that data is in
;         [RsTable] contains Hub/Port info of newly connected Devices
;Outputs:
;Changes: Gets Device and Configuration Descriptors
;         Enumerates the Device
;         Copies Appropriate data to the Address Table
;------------------------------------------------------------------------------
EnumerateNewDvc:
  CALL CopyBX2DSES                   ;Point DS & ES at TSR Data
  DEC  [EnumerateDelay]              ;Decrement the Delay Counter
  JNZ >E901                          ;If not 0 yet, don't do anything
  MOV  [EnumerateDelay],5            ;If 0, reset it for next time
  TEST [TSRFlags],EnumeratingDvc     ;Are we already enumerating something?
  JNZ >E901                          ;If so, quit
  MOV  BX,[ResetTblOffset]           ;Assume we're retrying
  CMP  [BX].RsRetries,0              ;Already done retrying?
  JE  >E05                           ;If so, look for another Reset Entry
  CMP  [BX].RsDelayCounter,0         ;If not, are we in the middle of a Delay?
  JE  >E20                           ;If not, use this one
E05:                                 ;Look for a new Reset Table entry
  MOV  BX,DS:[RsTable]               ;If not, [BX] = Reset Table
  MOV  CX,RsEntries                  ;Number of Entries
E10:                                 ;Loop to here to find entry
  TEST [BX].RsFlags,RsFlagInUse      ;Valid entry?
  JZ  >E15                           ;If not, go to the next one
  CMP  [BX].RsDelayCounter,0         ;If so, are we in the middle of a Delay?
  JE  >E20                           ;If not, use it
E15:
  ADD  BX,RsSize                     ;Point at next entry
  LOOP E10                           ;Keep looking
E901:                                ;To avoid JMP > 128
  JMP >E90                           ;If Table is Empty, we're done

E20:                                 ;[BX] = Reset Table Entry to use
  OR   [TSRFlags],EnumeratingDvc     ;Mark us as Enumerating
  MOV  [ResetTblOffset],BX           ;Save Reset Table Offset
  PUSH BX                            ;Save used registers
  MOV  BL,[BX].RsHubAddress          ;Is the Hub we're attached to
  CALL TestAddressIsHubBL            ;  still valid?
  POP  BX                            ;Restore used registers
  JNZ >E70                           ;If not, Error
  MOV  AL,[LastAddressUsed]          ;Assume that
  MOV  DI,[LastAddressOffset]        ;  we're retrying
  CMP  [BX].RsDeviceAddress,0        ;Is there already an address assigned?
  JNE >E30                           ;If so, continue
  CALL GetAvailAddress               ;Any addresses available (rtns AL, DI)?
  JZ  >E70                           ;If not, Quit right away - no use waiting
  MOV  [BX].RsDeviceAddress,AL       ;If so, store the Address
E30:                                 ;Address is assigned
  AND  [BX].RsFlags,(NOT RsFlagCfgRetry) ;Reset Config Retry flag
  OR   [DI].ADFlags,ADFlagInUse      ;Mark Address 0 as in use
  OR   [DI].ADFlags2,ADFlagConfiging ;Mark as being Configured
  MOV  [DI].ADMaxPktSizeEP0,8        ;Start Max Pkt Size at 8 bytes
  TEST [BX].RsFlags,RsFlagLowSpeed   ;Is it a Low-Speed Device?
  JZ  >E50                           ;If not, it's OK
  OR   [DI].ADFlags,ADFlagLowSpeed   ;If so,
E50:                                 ;Speed Flag is set
  MOV  [DI].ADNewDeviceStage,0       ;Stage
  MOV  [DI].ADNewDeviceError,0       ;  Zero
  MOV  SI,Int14Request2              ;Point at new Int14 Structure
  MOV  [SI].I14RFlags,0              ;Set Int14Request flags to 0
  MOV  [SI].I14RTimeout,3            ;Use Timeout = 3 dS for all Requests
  MOV  AX,W [BX].RsHubAddress        ;Transfer the
  MOV  W [DI].ADHubAddress,AX        ;  Hub Address
  MOV  W [SI].I14RHubAddress,AX      ;  and Port Number
  MOV  [SI].I14RRequestType,I14RRTResetHubPort ;Request = Reset Hub/Port
  MOV  W [SI].I14RCallBackAddr[0],NewDvcReset  ;Where to go when Done
  CALL CopyToAddress0                ;Copy data to Address 0 data area
  CALL DoInt14CallAXSI               ;Do the call
  JNC >E90                           ;If it worked, we're done
  MOV  [DI].ADNewDeviceStage,1       ;If error, Update Stage
E70:                                 ;Done Enumerating (no Addresses Available)
  CALL FinishUpBadDevice             ;Finish Up Bad Device Entry and Inform Hub
E90:                                 ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BX (UserPktID) = TSR Segment that data is in
;NOTES: According to the USB specs, a Device is supposed to be ready to
;         accept any request 10 mS after the Reset is complete.  We wait
;         longer than that in case the Device is not fully compliant.
;------------------------------------------------------------------------------
NewDvcReset:
  CALL CopyBX2DSESLastAddrSIDI  ;Set DS, ES, SI, & DI
  MOV  [SI].ADNewDeviceStage,10 ;Update Stage
  JNZ >R70                      ;If error, quit
;  MOV  AX,23                    ;Wait 23 ms
  MOV  AX,77                    ;Wait 77 ms (maybe fixes problems with some
  MOV  DI,NewDvcResetWait       ;Go here when done
  CALL StartOneTimeIntDI        ;Do it
  JNC >R90                      ;If OK, continue
  MOV  [SI].ADNewDeviceStage,11 ;Update Stage
R70:                            ;Error
  CALL FinishUpBadDevice        ;Finish Up Bad Device Entry and Inform Hub
R90:                            ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BX (UserPktID) = TSR Segment that data is in
;------------------------------------------------------------------------------
NewDvcResetWait:
  CALL CopyBX2DSESLastAddrSIDI       ;Set DS, ES, SI, & DI
  MOV  [SI].ADNewDeviceStage,20      ;Update Stage
  MOV  BX,[ResetTblOffset]           ;Point BX at Reset Table Entry
  MOV  CX,SetAddressReq              ;Copy
  CALL CopySetupReqToInt14CXDI       ;  Setup Pkt
  MOV  AL,[LastAddressUsed]          ;Put Device Address
  MOV  B [DI].I14RSetAddressValue,AL ;  in the Request
  MOV  W [DI].I14RDeviceAddress,0    ;Address 0, EndPoint 0
  MOV  [DI].I14RRequestType,I14RRTDoControl       ;Type = Control
  MOV  W [DI].I14RCallBackAddr[0],NewDvcAddressed ;Go here when done
  CALL DoInt14CallAXDI               ;Do it
  JNC >W90                           ;If OK, we're done
  MOV  [SI].ADNewDeviceStage,21      ;Update Stage
W70:                                 ;Error
  CALL FinishUpBadDevice             ;Finish Up Bad Device Entry and Inform Hub
W90:                                 ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BX (UserPktID) = TSR Segment that data is in
;NOTE: The Set Address Request that was issued in the previous time slot
;        is unique.  The USB spec says that the Device can return from
;        the Set Address Request before it has actually accepted the Address.
;        This is in direct contrast to all other Requests (at least those
;        that I know about), which must actually be DONE before they
;        return from the call.  A Device actually has 2 milliseconds after
;        it returns from the Set Address Request before it is required
;        to respond to Requests to the new Address.  We'll go ahead and
;        give it 10 seconds to make sure it has enough time.
;------------------------------------------------------------------------------
NewDvcAddressed:
  CALL CopyBX2DSESLastAddrSIDI  ;Set DS, ES, SI, & DI
  MOV  [SI].ADNewDeviceStage,30 ;Update Stage
  JNZ >R70                      ;If the Request failed, quit
  CALL ResetAddress0            ;Make sure Address 0 is empty
  MOV  AX,25                    ;Wait 25 ms
  MOV  DI,NewDvcAddressedWait   ;Go here when done
  CALL StartOneTimeIntDI        ;Do it
  JNC >R90                      ;If OK, continue
  MOV  [SI].ADNewDeviceStage,31 ;Update Stage
R70:                            ;Error
  CALL FinishUpBadDevice        ;Finish Up Bad Device Entry and Inform Hub
R90:                            ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BX (UserPktID) = TSR Segment that data is in
;------------------------------------------------------------------------------
NewDvcAddressedWait:
  CALL CopyBX2DSESLastAddrSIDI      ;Set DS, ES, SI, & DI
  MOV  [SI].ADNewDeviceStage,40     ;Update Stage
  CALL ClearDCDescriptorData        ;Clear Device & Config Descrs
  MOV  AL,[LastAddressUsed]         ;Set the Address
  MOV  [DI].I14RDeviceAddress,AL    ;  in the Request
  MOV  CX,GetDvcDescrReq            ;Copy
  CALL CopySetupReqToInt14CXDI      ;  Setup Request
  MOV  [DI].I14RGetDvcDescrSize,8   ;Just get first 8 bytes to start with
  MOV  AX,[DvcDescrPtr]             ;Where to
  MOV  W [DI].I14RDataAddress[0],AX ;Where to put data
  MOV  W [DI].I14RCallBackAddr[0],NewDvcGotDvcDescr ;Go here when done
  CALL DoInt14CallAXDI              ;Do it
  JNC >W90                          ;If it worked, we're done
  MOV  [SI].ADNewDeviceStage,41     ;Update Stage
W70:                                ;Error
  CALL FinishUpBadDevice            ;Finish Up Bad Device Entry and Inform Hub
W90:                                ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BX (UserPktID) = TSR Segment that data is in
;------------------------------------------------------------------------------
NewDvcGotDvcDescr:
  CALL CopyBX2DSESLastAddrSIDI        ;Set DS, ES, SI, & DI
  MOV  [SI].ADNewDeviceStage,50       ;Update Stage
  JNZ >D70                            ;If Error, Handle it
  MOV  BX,[DvcDescrPtr]               ;AL =
  MOV  AL,[BX].DDMaxPktSize           ;  End Point 0 Max Pkt Size
  MOV  [SI].ADMaxPktSizeEP0,AL        ;Store it
  OR   AL,AL                          ;Is it 0?
  JZ  >D70                            ;If so, error
  TEST AL,07h                         ;Is it evenly divisible by 8?
  JNZ >D70                            ;If not, error
  CMP  AL,64                          ;Is it > 64?
  JA  >D70                            ;If so, error
  MOV  B [DI].I14RGetDvcDescrSize,DvcDescrSize  ;Get Full Descriptor
  MOV  W [DI].I14RCallBackAddr[0],NewDvcGotFullDvcDescr ;Go here when done
  CALL DoInt14CallAXDI                ;Do it
  JNC >D90                            ;If OK, quit
  MOV  [SI].ADNewDeviceStage,51       ;Update Stage
D70:                                  ;Error
  CALL FinishUpBadDevice              ;Finish Up Bad Device Entry and Inform Hub
D90:                                  ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BX (UserPktID) = TSR Segment that data is in
;------------------------------------------------------------------------------
NewDvcGotFullDvcDescr:
  CALL CopyBX2DSESLastAddrSIDI      ;Set DS, ES, SI, & DI
  MOV  [SI].ADNewDeviceStage,60     ;Update Stage
  JNZ >F70                          ;If Error, handle it
  MOV  CX,GetCfgDescrReq            ;Copy
  CALL CopySetupReqToInt14CXDI      ;  Setup Request
  MOV  CX,[CfgDescrPtr]             ;Where to
  MOV  W [DI].I14RDataAddress[0],CX ;  put data
  MOV  W [DI].I14RCallBackAddr[0],NewDvcSetConfig ;Go here when done
  CALL DoInt14CallAXDI              ;Do it
  JNC >F90                          ;If OK, quit
  MOV  [SI].ADNewDeviceStage,61     ;Update Stage
F70:                                ;Error
  CALL FinishUpBadDevice            ;Finish Up Bad Device Entry and Inform Hub
F90:                                ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BX (UserPktID) = TSR Segment that data is in
;------------------------------------------------------------------------------
NewDvcSetConfig:
  CALL CopyBX2DSESLastAddrSIDI          ;Set DS, ES, SI, & DI
  MOV  [SI].ADNewDeviceStage,70         ;Update Stage
  MOV  BX,[ResetTblOffset]              ;Point BX at Reset Table Pointer
  JNZ >S70                              ;If Error, Handle it
  MOV  BP,[CfgDescrPtr]                 ;Is Configuration 0 valid
  CMP  B DS:[BP].CDConfigValue,0        ;  (Device is not USB Compliant)?
  JNE >S05                              ;If not, continue
  OR   [SI].ADFlags,ADFlagConfig0OK     ;If so, mark Config 0 as legitimate
S05:
NewDvcSetConfigAgain:
  MOV  SI,[LastAddressOffset]           ;[SI] = Address Table Entry
  MOV  BP,[CfgDescrPtr]                 ;Assume
  MOV  AL,DS:[BP].CDConfigValue         ;  non-Specific Config
  TEST [BX].RsFlags,RsFlagSetConfig     ;Use Specific Config?
  JZ  >S30                              ;If not, continue
  TEST [BX].RsFlags,RsFlagCfgRetry      ;Already tried Specific Config?
  JNZ >S30                              ;If so, use Default Config
  MOV  AL,[BX].RsConfigValue            ;If not, use Specific Config
S30:                                    ;AL contains Config Value to use
  MOV  CX,SetConfigReq                  ;Copy
  CALL CopySetupReqToInt14CXDI          ;  Setup Request
  MOV  B [DI].I14RSetConfigValue,AL     ;Store the Config Value
  MOV  W [DI].I14RCallBackAddr[0],NewDvcSetConfigDone ;Go here when done
  CALL DoInt14CallAXDI                  ;Do it
  JNC >S90                              ;If OK, quit
  MOV  [SI].ADNewDeviceStage,71         ;Update Stage
S70:                                    ;Error
  CALL FinishUpBadDevice                ;Finish Up Bad Dvc Entry, Inform Hub
S90:                                    ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BX (UserPktID) = TSR Segment that data is in
;NOTE: In spite of the fact that it is in blatant violation of the USB specs,
;        some devices have a "legitimate" Configuration Value of 0 (they
;        don't need to be configured, and it is impossible to unconfigure
;        them).  Some of these same devices may reject a Set Configuration
;        request, so an error here doesn't necessarily indicate a
;        Bad Device.
;------------------------------------------------------------------------------
NewDvcSetConfigDone:
  CALL CopyBX2DSESLastAddrSIDI      ;Set DS, ES, SI, & DI
  MOV  [SI].ADNewDeviceStage,80     ;Update Stage
  MOV  BX,[ResetTblOffset]          ;[BX] = Reset Table Pointer
  JZ  >F10                          ;If no error, continue
  CMP  B [DI].I14RSetConfigValue,0  ;Are we setting Config 0?
  JNE >F05                          ;If not, continue
  TEST [SI].ADFlags,ADFlagConfig0OK ;Does the Device even accept Configurations?
  JNZ >F10                          ;If not, assume it's OK
F05:                                ;Not a Device where Config 0 is legitimate
  TEST [BX].RsFlags,RsFlagSetConfig ;Using a Specific Config?
  JZ  >F70                          ;If so, Config didn't work
  TEST [BX].RsFlags,RsFlagCfgRetry  ;Did we already try with the Default Config?
  JNZ >F70                          ;If so, the Config Didn't work
  OR   [BX].RsFlags,RsFlagCfgRetry  ;If not, mark it as the Retry
  JMP  NewDvcSetConfigAgain         ;And try it again

F10:
  MOV  BP,[CfgDescrPtr]                  ;AX =
  MOV  AX,W DS:[BP].CDTotalLength        ;  Total Descriptor Length
  CMP  AX,(CfgDescrSize+CfgDescrXBytes)  ;Will it fit in our Buffer?
  JBE >F30                               ;If so, it's OK
  MOV  AX,(CfgDescrSize+CfgDescrXBytes)  ;If not, just fill Buffer
F30:                                     ;Have full data size
  MOV  CX,GetCfgDescrReq                 ;Copy
  CALL CopySetupReqToInt14CXDI           ;  Setup Request
  MOV  W [DI].I14RGetCfgDescrSize,AX     ;Store the Size
  MOV  W [DI].I14RCallBackAddr[0],NewDvcGotConfig ;Where to go when done
  CALL DoInt14CallAXDI                   ;Do it
  JNC >F90                               ;If OK, quit
  MOV  [SI].ADNewDeviceStage,81          ;Update Stage
F70:                                     ;Error
  CALL FinishUpBadDevice                 ;Finish Up Bad Dvc Entry & Inform Hub
F90:                                     ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BX (UserPktID) = TSR Segment that Data is in
;------------------------------------------------------------------------------
NewDvcGotConfig:
  CALL CopyBX2DSESLastAddrSIDI       ;Set DS, ES, SI, & DI
  MOV  [SI].ADNewDeviceStage,90      ;Update Stage
  JNZ >F70                           ;If Error, handle it
  MOV  DI,SI                         ;Point DI at Address Table Entry
  CALL GetInfoFromDescrs             ;Get info from Descriptors (uses DI)
  TEST [DI].ADFlags2,ADFlagRWkUpSupt ;Remote Wakeup Supported?
  JZ  >F30                           ;If not, continue
  PUSH DI                            ;Save Address Table Pointer
  MOV  DI,Int14Request2              ;Point at Request Structure
  MOV  CX,SetDvcFeatureReq           ;Copy the
  CALL CopySetupReqToInt14CXDI       ;  Request
  MOV  B [DI].I14RSetDvcFeatureFtrSel,DvcFeatureRemoteWakeup ;Store Feature
  MOV  W [DI].I14RCallBackAddr[0],-1 ;Do nothing when done
  CALL DoInt14CallDI                 ;Do it
  POP  DI                            ;Restore Address Table Pointer
F30:                                 ;Remote Wakeup Handled, if appropriate
  CALL NotifyNewDvcOK                ;Notify Far Call Owner & Hub
  MOV  AX,20                         ;Delay 20ms
  PUSH SI                            ;Save SI momentarily
  MOV  SI,NewDvcNotify0s             ;Go here when done
  CALL StartOneTimeIntSI             ;Do it
  POP  SI                            ;Restore SI
  JNC >F90                           ;Done
  MOV  [SI].ADNewDeviceStage,91      ;Update Stage
F70:                                 ;Error
  CALL FinishUpBadDevice             ;Finish Up Bad Device Entry and Inform Hub
F90:                                 ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BX (UserPktID) = TSR Segment that data is in
;This is the final step in the Device Enumeration Process.
;Here we notify all appropriate Device 0 Owners that the new Device has been
;  connected.  If a Driver registered to be notified when this particular
;  type of Device is connected, this is where we do the notification.
;------------------------------------------------------------------------------
NewDvcNotify0s:
  CALL CopyBX2DSESLastAddrSIDI         ;Set DS, ES, SI, & DI
  MOV  [SI].ADNewDeviceStage,100       ;Update Stage
  CMP  [SI].ADConfigValue,0            ;Configuration = 0?
  JNE >Z20                             ;If not, continue
  TEST [SI].ADFlags,ADFlagConfig0OK    ;If so, is Configuration 0 valid?
  JZ  >Z90                             ;If not, don't issue notifications
Z20:                                   ;OK to issue Notifications
  MOV  CL,[USBHostIndex]               ;CL = Host Index
  MOV  CH,[LastAddressUsed]            ;CH = Address
  MOV  AX,OwnerCallNewDvc              ;Inform Owner of New Device
  CALL NotifyDvc0OwnersOfIntf          ;Notify Device 0 Owners of new Interfaces
  MOV  [SI].ADNewDeviceStage,101       ;Update Stage
Z90:                                   ;Done
  AND  [SI].ADFlags2,(NOT ADFlagConfiging) ;Mark as done Configuring
  AND  [TSRFlags],(NOT EnumeratingDvc) ;Mark us as Done
  RETF

;------------------------------------------------------------------------------
;FINISH UP A BAD DEVICE ADDRESS ENTRY AND INFORM THE HUB THAT WE'RE DONE
;Inputs:  DS = ES = TSR Data Area
;         AX = Error Code from Transaction
;         [LastAddressUsed]
;         [ADTable] contains Address Data gathered so far about Device
;         [ResetTblOffset]
;Outputs: Disables Device
;         Informs Caller that the Device is Done Enumerating, but is Bad
;         Informs the Hub that the Device is bad
;         Marks us as done Enumerating (EnumeratingDvc = False)
;         Beeps the speaker
;Changes: AX,BX,CX,DX,DI
;------------------------------------------------------------------------------
FinishUpBadDevice:
  CALL ResetAddress0              ;Make sure Address 0 is empty
  MOV  CL,[LastAddressUsed]       ;CL = [LastAddressUsed]
  MOV  SI,[LastAddressOffset]     ;DI = [LastAddressOffset]
  MOV  [SI].ADNewDeviceError,AX   ;Store Error Code
  CALL DisableLastDevice          ;Disable the Enumerated Device
  MOV  BX,[ResetTblOffset]        ;Point at the Reset Table Entry
  DEC  [BX].RsRetries             ;Decrement the Retry Counter
  JZ  >F20                        ;If 0, it's really a Bad Device
  MOV  [BX].RsDelayCounter,55     ;If not 0, Set Retry Timer for ~3 seconds
  JMP >F90                        ;Done for now
F20:                              ;Bad Device after multiple retries
  CALL GetAvailInterface          ;Get a (fake) Interface (DI)
  MOV  BX,DI                      ;Save the Address
  MOV  [DI].InDeviceAddress,CL    ;Associate it with the Bad Device
  CALL GetAvailAltInterface       ;Get a (Fake) Alternate Interface
  MOV  [DI].AIInterfaceOffset,BX  ;Set the Interface Address
  OR   [SI].ADFlags2,ADFlagBadDvc ;Mark Device as Bad
  AND  [SI].ADFlags2,(NOT ADFlagConfiging) ;Mark as done Configuring
  CALL NotifyNewDvcErr            ;Notify
F90:                              ;Done
  AND  [TSRFlags],(NOT EnumeratingDvc) ;Mark us as done
  RET

;------------------------------------------------------------------------------
;NOTIFY NEW DEVICE CALLER AND HUB OWNER OF ERROR/OK AT END OF ENUMERATION
;Inputs:  DS = ES = TSR Data Area
;         [ResetTblOffset]
;Outputs: Issues Request to Beep the Speaker (if Error)
;         Releases the Reset Table Entry
;Changes: Notifies appropriate Owners of New Device Completion Status
;------------------------------------------------------------------------------
NotifyNewDvcOK:
  PUSH AX                       ;Save used registers
  XOR  AX,AX                    ;Call Code = 0 (No Error)
  JMP >N00                      ;Do it
NotifyNewDvcErr:
  PUSH AX                       ;Save used registers
  MOV  AX,TDStsLargeCallErr     ;Call Code = Large Call Error
;  JMP >N00                      ;Do it
N00:
  PUSH BX,CX,DX,DI,SI           ;Save used registers
  MOV  SI,[ResetTblOffset]      ;Point at the Reset Table Entry
N10:                            ;Notify Caller of LargeCall Status
  MOV  BX,[SI].RsUserPktID      ;BX = User Packet ID
  XOR  CX,CX                    ;CX = 0
  XOR  DX,DX                    ;DX = 0
  LEA  DI,[SI].RsCallBackAddr   ;Point DI at the Call Back Address
  CALL DoFarCall                ;Inform the Caller
N20:                            ;Notify Hub of Device Address
  MOV  CX,W [SI].RsHubAddress   ;CL = Hub Address, CH = Hub Port
  PUSH AX                       ;Save Error Code
  MOV  AL,CL                    ;Point at the Hub's
  CALL Address2Intf             ;  Interface Entry
  POP  AX                       ;Restore Error Code
  MOV  BX,[DI].InUserPktID      ;BX = Hub Owner User Packet ID
  MOV  DL,[USBHostIndex]        ;DL = Host Index
  MOV  DH,[LastAddressUsed]     ;DH = Device Address -- Assume OK (not Error)
  OR   AX,AX                    ;Is it OK?
  JZ  >N30                      ;If so, continue
  MOV  DH,-1                    ;DH = Device Address = Bad Device
  CALL DoErrorBeep              ;Beep the Speaker
N30:                            ;DH contains correct Address
  MOV  AX,HubCallEnumerated     ;Call Code = Device enumerated on Hub Port
  ADD  DI,OFFSET InCallBackAddr ;Inform the
  CALL DoFarCall                ;  Hub
N90:                            ;Done
  CALL ReleaseRsTblOffset       ;Release the Reset Table Entry
  POP  SI,DI,DX,CX,BX           ;Restore used registers
  POP  AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE A REQUEST TO BEEP THE SPEAKER (ERROR BEEP)
;Inputs:  ES = TSR Data Area
;         ES:[TSRFlags].NoBeep
;Outputs: Issues Request to Beep the Speaker at 200Hz for 3 DeciSeconds
;Changes: Int14Request4
;------------------------------------------------------------------------------
DoErrorBeep:
  PUSH DI,DS              ;Save used registers
  MOV  DS,ES              ;Point DS at TSR Data Area
  TEST [TSRFlags],NoBeep  ;Are we allowed to Beep?
  JNZ >P90                ;If not, just quit
  MOV  DI,Int14Request4   ;Point at Request Structure
  MOV  [DI].I14RRequestType,I14RRTBeepSpeaker ;Request = Beep Speaker
  MOV  W [DI].I14RBeepFrequency,200 ;Frequency of Beep = 200Hz
  MOV  [DI].I14RTimeout,3 ;Duration = 3 DeciSeconds
  CALL DoInt14CallDI      ;Do it
P90:                      ;Done
  POP  DS,DI              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;NOTIFY DEVICE 0 OWNERS OF DEVICE (INTERFACE) ATTACHMENT/REMOVAL
;Inputs:  CL = Host Index
;         CH = Device Address
;         AX = Owner Call Code to use (Unregistered Device Added or Removed)
;         ES = TSR Data Area
;         CS = [FirstInstanceSeg]
;Outputs: Notifies registered Device 0 Owners
;Changes:
;------------------------------------------------------------------------------
NotifyDvc0OwnersOfIntf:
  PUSH AX,BX,CX,DX,DI,SI,BP,DS,FS ;Save used registers
  MOV  DS,CS                      ;Point DS at Correct Data Area
  MOV  FS,AX                      ;Save Owner Call Code
  MOV  AL,CH                      ;Save Address in AL
  XCHG CL,CH                      ;Point at correct entry
  CALL ADIndex2Offset             ;  in Address Table (DI)
  XCHG CL,CH                      ;Save New Host (CL) and
  MOV  BP,CX                      ;  and Address (CH) Info
  MOV  SI,NDTable                 ;Point at Device 0 Owner Table
  MOV  CX,NDEntries               ;Number of Entries to check
N10:                              ;Loop to here for each table entry
  CMP  W [SI].NDCallBackAddr[2],0 ;Valid Entry?
  JE  >N80                        ;If not, skip it
;Test VendorID & ProductID
  PUSH CX,DI,SI                   ;Save Loop Counter
  ADD  DI,(OFFSET ADVendorID)     ;Go to VendorID
  ADD  SI,(OFFSET NDVendorID)     ;Go to VendorID
  MOV  CL,2                       ;Test two words (VendorID, ProductID)
  CALL CompareWordTables          ;Compare the tables
  POP  SI,DI,CX                   ;Restore Loop Counter
  JC  >N80                        ;If no match, try the next one
;Test Device Class, SubClass, & Protocol
  PUSH CX,DI,SI                   ;Save Loop Counter
  ADD  DI,(OFFSET ADDvcClass)     ;Go to Device Class
  ADD  SI,(OFFSET NDDvcClass)     ;Go to Device Class
  MOV  CL,3                       ;Test three bytes (Dvc Cls, SCls, Prot)
  CALL CompareByteTables          ;Compare the tables
  POP  SI,DI,CX                   ;Restore Loop Counter
  JC  >N80                        ;If no match, try the next one

;Test Interfaces
  PUSH CX,DI                      ;Save Loop Counter and Pointer
  XOR  AH,AH                      ;Start with Interface 0
N20:                              ;Loop to here for each Interface
  CALL AddressIntf2Intf           ;Look for matching Interface Data
  JC  >N70                        ;If no more Interfaces, we're done

  PUSH AX                         ;Save Address & Interface
  MOV  DL,[DI].InInterfaceNum     ;Get the Interface Number
  PUSH SI                         ;Save Pointers
  ADD  SI,(OFFSET NDIntfClass)    ;Point at the Interface Class
  CALL TestIntfCSP                ;See if it matches (CF & AL)
  POP  SI                         ;Restore Pointer
  JC  >N50                        ;If no match, try the next one
  MOV  DH,AL                      ;If OK, store Alt Interface
;It's a match -- do the Far Call
  MOV  AX,FS                      ;AX = Call Code
  MOV  BX,[SI].NDUserPktID        ;BX = User Packet ID
  MOV  CX,BP                      ;CL = Host Index, CH = Address
                                  ;DL = Interface Number
                                  ;DH = Alternate Interface
  PUSH DI                         ;Save Pointers
  LEA  DI,[SI].NDCallBackAddr     ;Do the
  CALL DoFarCall                  ;  Far Call
  POP  DI                         ;Restore Pointers
N50:                              ;Done testing this Interface
  POP  AX                         ;Restore Address 7 Interface
  INC  AH                         ;Point at next Interface Number
  JMP  N20                        ;Look for the next Interface
N70:                              ;Done testing Interfaces
  POP  DI,CX                      ;Restore Loop Counter and Pointer

N80:                              ;Done with this Entry
  ADD  SI,NDSize                  ;Go to next Owner
  LOOP N10                        ;Keep going until we're done
  POP  FS,DS,BP,SI,DI,DX,CX,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COMPARE INTERFACE CLASS, SUBCLASS, & PROTOCOL DATA GIVEN AN INTERFACE
;Inputs:  ES:[DI] = Interface Table Entry to Test
;         DS:[SI] = Intf Class, SubClass, Protocol to Compare with
;Outputs: CF = Clear if a Match was found (any Alternate Interface)
;              AL = Alternate Interface Value
;            = Set if No Match Found
;              AL = 0
;Changes:
;------------------------------------------------------------------------------
TestIntfCSP:
  PUSH BX,CX,DI                ;Save used registers
  MOV  BX,DI                   ;Save Interface Pointer
  XOR  AL,AL                   ;Start with Alt Interface 0
I10:                           ;Loop to here for each Alternate Interface
  MOV  DI,BX                   ;Get Interface pointer back again
  CALL FindAltInterfaceALDI    ;Look for an Alternate Interface
  JC  >I70                     ;If not found, we're done
  ADD  DI,(OFFSET AIIntfClass) ;Point at the Interface Class
  MOV  CL,3                    ;Test 3 Bytes
  CALL CompareByteTables       ;Compare the Tables
  JNC >I80                     ;If tables match, we're done
I30:                           ;No match here
  INC  AL                      ;Increment Alt Interface Value
  JMP  I10                     ;Keep Looking
I70:                           ;No match
  XOR  AL,AL                   ;Set Return Value
  STC                          ;Set Return Flag
  JMP >I90                     ;Done
I80:                           ;Found a match
  CLC                          ;Set Return Flag
I90:                           ;Done
  POP  DI,CX,BX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GATHER INFORMATION FROM DEVICE AND CONFIG DESCRIPTORS AND STORE IT
;Inputs:  DS = ES = TSR Data Area
;         [DI] = Address Table Entry
;         Dvc Descr Buffer, Cf gDescr Buffer filled in
;         [LastAddressUsed] = Device Address
;Outputs: Device, Interface, Alt Interface & EndPoint Tables Filled as needed
;Changes:
;NOTES:   Already have various things stored (MaxPktSize0, Config Value, etc.).
;         This just stores the things not already stored.
;         If we get this far, the Device has already accepted an Address,
;           so we will simply assume that everything here works!!
;         If something is very obviously wrong (like if we run out of memory),
;           we simply stop prematurely and don't continue, whihc could lead
;           to some erroneous information.  FOr now, we will simply
;           ignore that possibility!
;------------------------------------------------------------------------------
GetInfoFromDescrs:
  PUSH AX,BX,DX,DI,SI                ;Save used registers
  MOV  BX,DI                         ;Point BX at Address Table
  CALL GetInfoFromDvcDescr           ;Copy Info from Device Descriptor
  CALL FindConfigDescr               ;Find the Correct Config Descriptor (SI)
  JC  >G90                           ;If error, quit
  TEST [SI].CDAttributes,CDAttrRemoteWakeup ;Remote Wakeup supported?
  JZ  >G02                           ;If not, continue
  OR   [BX].ADFlags2,ADFlagRWkUpSupt ;If so, mark it as being supported
G02:                                 ;Remote Wakeup Support handled
  MOV  AL,[SI].CDMaxBusPower         ;Copy the
  MOV  [BX].ADBusPower,AL            ;  Bus Power
  TEST [SI].CDAttributes,CDAttrSelfPowered ;Copy the
  JZ  >G05                           ;  Self Powered
  OR   [BX].ADFlags,ADFlagSelfPwr    ;  Status
G05:                                 ;Done with Self-Power
  ADD  SI,CfgDescrSize               ;Point at the first Interface Decriptor
  MOV  DX,-1                         ;DL = Interface, DH = Alt (Sub) Interface
G10:                                 ;Loop to here for each New Interface
  MOV  AX,[SI]                       ;Get the Descriptor Size (AL) & Type (AH)
  OR   AL,AL                         ;Size 0 (End of Descriptor Data)?
  JZ  >G90                           ;If so, we're done
  CMP  AH,DescrTypeInterface         ;Another Interface Descriptor?
  JNE >G90                           ;If not, we're done
G20:                                 ;Keep looking through Interfaces & Alts
  CMP  DL,[SI].IDInterfaceNumber     ;Same Interface Number as last time?
  MOV  DL,[SI].IDInterfaceNumber     ;Store Interface Number
  JE  >G40                           ;If so, it's an Alternate Interface Descr
  CALL GetAvailInterface             ;If not, get a new Interface entry (DI)
  JC  >G90                           ;If error, quit
  MOV  BX,DI                         ;Put it in BX
  MOV  AL,[LastAddressUsed]          ;Store the Address
  MOV  [DI].InDeviceAddress,AL       ;Store the Device Address
  MOV  [DI].InInterfaceNum,DL        ;Store the Interface Number
G40:                                 ;Alternate Interface Descr
  MOV  DH,[SI].IDAlternateSetting    ;Save Alternate Interface Setting
  CALL GetAvailAltInterface          ;Get a new Alt Interface Entry (DI)
  JC  >G90                           ;If error, quit
  OR   DH,DH                         ;Alt Interface 0?
  JNZ >G50                           ;If not, Continue
  OR   [DI].AIFlags,AIFlagSelected   ;If so, mark it as Selected
G50:                                 ;Done with Selected
  MOV  [DI].AIInterfaceOffset,BX     ;Store the Interface Offset
  MOV  AX,W [SI].IDInterfaceClass    ;Copy the
  MOV  W [DI].AIIntfClass,AX         ;  Interface Class,
  MOV  AL,[SI].IDInterfaceProtocol   ;  SubClass,
  MOV  [DI].AIIntfProtocol,AL        ;  and Protocol
  MOV  [DI].AIAltIntfNum,DH          ;Store the Alternate Interface Setting
  CALL GetEndPoints                  ;Get the End Point(s) Data (updates SI)
  JNC  G20                           ;If more data, keep getting it
G90:                                 ;Done
  POP  SI,DI,DX,BX,AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GATHER INFO FROM DEVICE DESCRIPTOR AND PUT IT IN THE ADDRESS TABLE
;Inputs:  DS = ES = TSR Data Area
;         [BX] = Address Table Pointer
;         [DvcDescrPtr]
;Outputs: Copies Appropriate Info From Device Descriptor to Address Table
;Changes:
;------------------------------------------------------------------------------
GetInfoFromDvcDescr:
  PUSH AX,SI                 ;Save used registers
  MOV  SI,[DvcDescrPtr]      ;[SI] = Device Descriptor Data
  MOV  AX,W [SI].DDDvcClass  ;Copy the
  MOV  W [BX].ADDvcClass,AX  ;  Device Class,
  MOV  AL,[SI].DDDvcProtocol ;  SubClass,
  MOV  [BX].ADDvcProtocol,AL ;  and Protocol
  MOV  AX,[SI].DDVendorID    ;Copy
  MOV  [BX].ADVendorID,AX    ;  Vendor ID
  MOV  AX,[SI].DDProductID   ;Copy
  MOV  [BX].ADProductID,AX   ;  Product ID
  MOV  AL,[SI].DDNumConfigs  ;Copy
  MOV  [BX].ADNumConfigs,AL  ;  Number of Configs
  MOV  AX,[SI].DDUSBRelease  ;Get the USB Compliance Release
  SHR  AX,4                  ;Convert word to byte (e.g, 0110h -> 11h)
  MOV  [BX].ADUSBVersion,AL  ;Store it
  POP  SI,AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND AND POINT AT THE CORRECT CONFIGURATION DESCRIPTOR
;Inputs:  DS = ES = TSR Data Area
;         [CfgDescrPtr]
;         SetConfigValue
;Outputs: CF = Set if OK
;              [SI] = Beginning of Appropriate Configuration Descriptor
;            = Clear if Error
;              SI = Unchanged
;Changes:
;------------------------------------------------------------------------------
FindConfigDescr:
  PUSH AX,BX,CX,DI           ;Save used registers
  MOV  CL,[LastAddressUsed]  ;Get the
  CALL ADIndex2Offset        ;  Config Value
  MOV  BL,[DI].ADConfigValue ;  we used
  OR   BL,BL                 ;Is it 0?
  JNZ >F10                   ;If not, it's OK
  TEST [DI].ADFlags,ADFlagConfig0OK ;If so, is Configuration 0 valid?
  JNZ >F10                   ;If so, continue
  MOV  BL,1                  ;If not, look for Config 1
F10:                         ;BL contains Config value to look for
  MOV  CX,SI                 ;Save original SI
  MOV  SI,[CfgDescrPtr]      ;Point at Config Data
F20:                         ;Loop to here to find Correct Config Descr
  MOV  AX,[SI]               ;Get the Descriptor Size (AL) & Type (AH)
  OR   AL,AL                 ;Size 0 (End of Descriptor Data Area)?
  JZ  >F70                   ;If so, Error
  CMP  AH,DescrTypeConfig    ;A Config Descriptor?
  JNE >F30                   ;If not, skip it
  CMP  BL,[SI].CDConfigValue ;Is it the correct Config Descr?
  JE  >F80                   ;If so, we're done
F30:                         ;Skip to the next Descriptor
  XOR  AH,AH                 ;Point at
  MOV  AL,[SI]               ;  the Next
  ADD  SI,AX                 ;  Descriptor
  JMP  F20                   ;Keep Looking
F70:                         ;Error
  MOV  SI,CX                 ;Restore original SI
  STC                        ;Set error flag
  JMP >F90                   ;Done
F80:                         ;OK
  CLC                        ;Set OK flag
F90:                         ;Done
  POP  DI,CX,BX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE ENDPOINT DATA FOR AN ALTERNATE INTERFACE
;Inputs:  DS = ES = TSR Data Area
;         [SI] = Interface Descriptor that the Endpoint(s) are for
;         [LastAddressUsed] = Device Address associated with the EndPoints
;Outputs: CF = Clear if there are more EndPoints to get
;              (this data is followed by another Interface Descriptor)
;              [SI] points to spot after the last EndPoint
;            = Set if this is the Final EndPoint
;              (this is final Data returned by Device, or next Data is
;                Config Descr)
;Changes: Assigns/Fills In EndPoint table as appropriate
;NOTES: We only store Data for Bulk & Control EndPoints, since they are
;         the only ones we will need to subdivide into smaller pieces.
;       Also, we associate EndPoints with Devices rather than Interfaces or
;         Alternate (Sub) Interfaces.  For any particular Device/EndPoint
;         combination, we only store the biggest EndPoint we find.
;       This could potentially cause problems with a Device that does
;         any really funny stuff with EndPoint Data Sizes, which I don't
;         believe any Real Device would ever do.  If this approach causes
;         problems, we may need to move the EndPoint Association down
;         to where it actually belongs (with an Alternate Interface).
;------------------------------------------------------------------------------
GetEndPoints:
  PUSH AX,BX,CX,DI                ;Save used registers
  MOV  BL,[LastAddressUsed]       ;Get Address to Use
  ADD  SI,InterfaceDescriptorSize ;Point at Descriptor after the Intf
E10:                              ;Loop to here for each Descriptor
  MOV  AX,[SI]                    ;Get the Descriptor Size (AL) & Type (AH)
  OR   AL,AL                      ;Size 0 (End of Descriptor Data)?
  JZ  >E70                        ;If so, end of Data
  CMP  AH,DescrTypeConfig         ;A new Configuration?
  JE  >E70                        ;If so, end of Data
  CMP  AH,DescrTypeInterface      ;A new Interface?
  JE  >E80                        ;If so, done with this Interface
  CMP  AH,DescrTypeEndPoint       ;An EndPoint Descr (not HID or something else?))
  JNE >E50                        ;If so, just skip over it
  MOV  AL,[SI].EDAttributes       ;Get End Point Attributes
  AND  AL,EDAttrTransTypeMask     ;Mask out everything but the Transaction Type
  CMP  AL,EDAttrIsoch             ;Is it Isochronous?
  JE  >E50                        ;If so, we don't need to store it
  MOV  BH,[SI].EDEndPointNumber   ;Get the End Point Number
  MOV  AX,[SI].EDMaxPktSize       ;Get the Max Packet Size
  OR   AX,AX                      ;Valid Size?
  JZ  >E50                        ;If not, skip it
  MOV  DI,DS:[EnTable]            ;Point at EndPoint Table
  MOV  CX,EnEntries               ;Number of Table Entries
E20:                              ;Loop to here to find matching EndPoint Entry
  CMP  BX,W [DI].EnDeviceAddress  ;Are this Address & EndPoint already there?
  JNE >E40                        ;If not, keep looking
  CMP  AL,[DI].EnMaxPktSize       ;Is this EndPoint bigger than the last one?
  JBE >E50                        ;If not, just leave it alone
  MOV  [DI].EnMaxPktSize,AL       ;If so, store the new bigger value
  JMP >E50                        ;Done with this EndPoint
E40:                              ;No matching EndPoint yet in Table
  ADD  DI,EnSize                  ;Point at Next Entry
  LOOP E20                        ;Keep going until we're done
  CALL GetAvailEndPoint           ;If not found, Get an Available EndPoint (DI)
  JC  >E70                        ;If error, quit
  MOV  W [DI].EnDeviceAddress,BX  ;Store Device Address & EndPoint
  MOV  [DI].EnMaxPktSize,AL       ;Store the Max Packet Size
;  JMP >E50                        ;Done with this EndPoint
E50:                              ;Done with this Descriptor
  XOR  AH,AH                      ;Point at
  MOV  AL,[SI]                    ;  the Next
  ADD  SI,AX                      ;  Descriptor
  JMP  E10                        ;Keep Looking
E70:                              ;No Data Left to get
  STC                             ;Set Return Flag
  JMP >E90                        ;Done
E80:                              ;More Interfaces after this one
  CLC                             ;Set return flag
E90:                              ;Done
  POP  DI,CX,BX,AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RELEASE ALL INTERFACES AND ALTERNATE INTERFACE ASSOCIATED WITH A DEVICE ADDRESS
;Inputs:  ES = TSR Data Area
;         AL = Address to remove Interfaces for
;Outputs:
;Changes: Releases all Interfaces with the Device Address
;------------------------------------------------------------------------------
ReleaseIntfs4Address:
  PUSH CX,DI,SI        ;Save used registers
I10:                   ;Loop to here for each entry
  CALL Address2Intf    ;Any Interfaces to Release (DI)?
  JC  >I90             ;If not, we're done
 #IF !LITE
  MOV  SI,AIOffset     ;ES:[SI] = Alternate Interface Table
 #ELSE
  MOV  SI,ES:[AITable] ;ES:[SI] = Alternate Interface Table
 #ENDIF
  MOV  CX,AIEntries    ;Number of Entries in Table
I20:                   ;Loop to here for each AI Entry
  TEST ES:[SI].AIFlags,AIFlagInUse  ;Valid Entry?
  JZ  >I40                          ;If not, skip it
  CMP  ES:[SI].AIInterfaceOffset,DI ;Is it the correct Interface?
  JNE >I40             ;If not, skip it
  CALL ReleaseAISI     ;Release the AI Entry
I40:                   ;Done with this AI Entry
  ADD  SI,AISize       ;Point at next Entry
  LOOP I20             ;Keep going until we're done
  CALL ReleaseInDI     ;Release the In Entry
  JMP  I10             ;Keep looking
I90:                   ;Done
  POP  SI,DI,CX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;LOOK FOR AN INTERFACE ASSOCIATED WITH A PARTICULAR DEVICE ADDRESS AND INTF NUM
;Inputs:  ES = TSR Data Area
;         AL = Address to Look For
;         If Address and Interface Number to Look for, AH = Interface Number
;Outputs: CF = Clear if there is an Entry with the Address in it
;           DI = Pointer to Entry that contains the Address
;         CF = Set if no Entry with that Address is found
;           DI = Undefined
;Changes:
;------------------------------------------------------------------------------
AddressIntf2Intf:
  PUSH BX              ;Save used registers
  MOV  BL,-1           ;Mark as needing to match Interface Number
  JMP >A00             ;Do it
Address2Intf:
  PUSH BX              ;Save used registers
  XOR  BL,BL           ;Mark as not caring about Interface Number
;  JMP >A00             ;Do it
A00:
  PUSH CX,DX,SI        ;Save used registers
 #IF !LITE
  MOV  DI,InOffset     ;[DI] = Interface Table
 #ELSE
  MOV  DI,ES:[InTable] ;[DI] = Interface Table
 #ENDIF
  MOV  CX,InEntries    ;Number of Entries to test
  MOV  SI,InSize       ;Size of Each Entry
A10:                   ;Loop to here for each Entry
  TEST ES:[DI].InFlags,InFlagInUse  ;Valid Entry?
  JZ  >A40                          ;If not, skip it
  MOV  DX,W ES:[DI].InDeviceAddress ;Get Address (DL) & Interface (DH)
  CMP  AL,DL           ;Does the Address match?
  JNE >A40             ;If not, try the next one
  OR   BL,BL           ;Do we care about the Interface Number?
  JZ  >A80             ;If not, it's a match
  CMP  AH,DH           ;Does the Interface Number match?
  JE  >A80             ;If so, it's a match
A40:                   ;No Match
  ADD  DI,SI           ;Point at next entry
  LOOP A10             ;Keep looking
A70:                   ;No Entry found
  STC                  ;Set not found flag
  JMP >A90             ;Done
A80:                   ;Found a matching Entry
  CLC                  ;Set found flag
A90:                   ;Done
  POP  SI,DX,CX        ;Restore used registers
  POP  BX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RELEASE ALL ENDPOINTS ASSOCIATED WITH A DEVICE ADDRESS
;Inputs:  ES = TSR Data Area
;         AL = Address to remove EndPoints for
;Outputs:
;Changes: Releases all EndPoints with the Device Address
;------------------------------------------------------------------------------
ReleaseEPs4Address:
  PUSH DI          ;Save used registers
E10:               ;Loop to here for each entry
  CALL Address2EP  ;Any EndPoints to Release?
  JC  >E90         ;If not, we're done
  CALL ReleaseEnDI ;Release the EndPoint Entry
  JMP  E10         ;Keep looking
E90:               ;Done
  POP  DI          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;LOOK FOR AN ENDPOINT ASSOCIATED WITH A PARTICULAR DEVICE ADDRESS
;Inputs:  ES = TSR Data Area
;         AL = Address to Look For
;         If Address and EndPoint Number to Look for,
;           AH = EndPoint Number (masked with Direction Flag)
;Outputs: CF = Clear if there is an Entry with the Address in it
;           DI = Pointer to Entry that contains the Address
;         CF = Set if no Entry with that address is found
;           DI = Undefined
;Changes:
;------------------------------------------------------------------------------
AddressEP2EP:
  PUSH BX                          ;Save used registers
  MOV  BL,-1                       ;Mark as needing to match EndPoint Number
  JMP >A00                         ;Do it
Address2EP:
  PUSH BX                          ;Save used registers
  XOR  BL,BL                       ;Mark as not caring about EndPoint Number
;  JMP >A00                         ;Do it
A00:
  PUSH CX                          ;Save used registers
  MOV  DI,ES:[EnTable]             ;Point at Table
  MOV  CX,EnEntries                ;Number of Entries to test
A10:                               ;Loop to here for each Entry
  TEST ES:[DI].EnFlags,EnFlagInUse ;Valid Entry?
  JZ  >A40                         ;If not, try next one
  CMP  ES:[DI].EnDeviceAddress,AL  ;Does the Address match?
  JNE >A40                         ;If not, try next one
  OR   BL,BL                       ;Do we care about the EndPoint Number?
  JZ  >A80                         ;If not, it's a match
  CMP  ES:[DI].EnEndPointNum,AH    ;Does the EndPoint Number match?
  JE  >A80                         ;If so, it's a match
A40:                               ;No Match
  ADD  DI,EnSize                   ;Point at next entry
  LOOP A10                         ;Keep looking
A70:                               ;No Entry found
  STC                              ;Set not found flag
  JMP >A90                         ;Done
A80:                               ;Found a matching Entry
  CLC                              ;Set found flag
A90:                               ;Done
  POP  CX                          ;Restore used registers
  POP  BX                          ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE CALLED WHEN A HUB HAS DETECTED A DISCONNECTED DEVICE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE A RECENTLY DISCONNECTED DEVICE
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         AH = Hub Index (-1 or Ours)
;Outputs: CF = Clear if OK
;            = Set if Error
;              BP = Error Code
;Changes:
;NOTES:   The call to this has the Hub Address and Port Number,
;           not the Device Address and EndPoint Number!
;------------------------------------------------------------------------------
OldDvcDisc:
  PUSH AX,BX,CX,DI,DS           ;Save used registers
  MOV  BP,I14RErrHostIndex      ;Assume bad Host Index
  CMP  AH,AllHostsIndex         ;Is it for All Hosts?
  JE  >D70                      ;If so, Error
  MOV  AX,W [SI].I14RHubAddress ;Get Hub Address & Port Number
  MOV  DS,ES                    ;Point DS at TSR Data Area
  CALL HubAndPort2Addr          ;Convert to a Device Address
  JZ  >D80                      ;If not in table, quit (must be n Addresses)
  CALL RemoveAddress            ;Remove the Device from the Address Table
  JMP >D80                      ;Done
D70:                            ;Error
  STC                           ;Set error flag
  JMP >D90                      ;Done
D80:                            ;OK
  CLC                           ;Set OK flag
D90:                            ;Done
  POP  DS,DI,CX,BX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CLEAR OUT THE DEVICE AND CONFIG DESCRIPTOR DATA AREAS
;Inputs:  ES = Our TSR Data Area
;         CLD Already issued
;Outputs:
;Changes: Sets Device & Configuration Descriptor Buffer to All Aeroes
;------------------------------------------------------------------------------
ClearDCDescriptorData:
  PUSH AX,CX,DI            ;Save used registers
  XOR  AX,AX               ;Fill with zeroes
  MOV  DI,ES:[DvcDescrPtr] ;[DI] = Data Area
  MOV  CX,((DvcDescrSize+CfgDescrSize+CfgDescrXBytes)/2) ;CX = Number of words
  REP  STOSW               ;Do it
  POP  DI,CX,AX            ;Restorer used registers
  RET

;------------------------------------------------------------------------------
;REMOVE A SINGLE ADDRESS, OR ALL ADDRESSES, FROM THE ADDRESS TABLE
;Inputs:  ES = TSR Data Area
;         AL = Address to Remove
;Outputs: Removes Address(s) from Address Table
;         Also Removes all Downstream Addresses (if Device is a Hub)
;Changes:
;------------------------------------------------------------------------------
RemoveAllAddresses:
  PUSH AX              ;Save used registers
  MOV  AX,0101h        ;Address 1 (Root Hub), Port 1
  CALL HubAndPort2Addr ;Any Device here?
  JZ  >A20             ;If not, skip down
  CALL RemoveAddress   ;If so, Remove it
A20:                   ;Port 1 is handled
  MOV  AX,0201h        ;Address 1 (Root Hub), Port 2
  CALL HubAndPort2Addr ;Any Device here?
  JZ  >A90             ;If not, skip down
  CALL RemoveAddress   ;If so, Remove it
A90:                   ;Done
  POP  AX              ;Restore used registers
  RET

RemoveAddress:
  PUSH AX,CX                ;Save used registers
  CALL HandleAddressDisc    ;Notify everyone of Device Disconnect
V20:                        ;Loop to here for each affected Device
  CALL FindAddressWithNoHub ;Did this affect some other Devices also?
  JZ  >V90                  ;If not, we're done
  MOV  AL,CL                ;If so,
  CALL HandleAddressDisc    ;  Handle it
  JMP  V20                  ;And keep looking
V90:                        ;Done
  POP  CX,AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;NOTIFY ALL APPROPRIATE ENTITIES THAT A DEVICE HAS BEEN DISCONNECTED
;Inputs:  AL = Address number that has been disconnected
;         ES = TSR Data Area
;Outputs: ZF = Set if device was NOT a hub
;            = Clear if Device was a hub
;Changes: Closes all TD's associated with the Device, with TDStsDvcRemoved
;         Releases all TD's associated with Device
;         Notifies Device Owner that Device was Disconnected
;         Releases Address
;------------------------------------------------------------------------------
HandleAddressDisc:
  PUSH AX,BX,CX,DX,DS         ;Save used registers
  MOV  DS,ES                  ;Point DS at TSR Data Area
  CALL ReleaseTDs4Address     ;Release all the TD's for this address (uses AL)
  MOV  BL,AL                  ;Put Address in BL
  MOV  CL,[USBHostIndex]      ;CL = Host Index
  MOV  CH,AL                  ;CH = Device Address
  XOR  DX,DX                  ;DX = 0
  MOV  AX,OwnerCallDvcDisc    ;Owner Call Code = Device Disconnect
  CALL NotifyDownstreamDvcs   ;Notify Intf Owner & Downstream Owners (uses BL)
  MOV  AX,OwnerCallDvc0Disc   ;Inform Device Owners of Device Disconnect
  CALL NotifyDvc0OwnersOfIntf ;Do it
  MOV  CL,CH                  ;Release
  CALL ResetAddress           ;  the Address (uses CL)
  POP  DS,DX,CX,BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RELEASE ALL TD'S ASSOCIATED WITH A RECENTLY DISCONNECTED DEVICE ADDRESS
;Inputs:  AL = Address to remove TD's for
;         ES = TSR Data Area
;Outputs:
;Changes: Issues TD complete notification with TDStsDvcRemoved
;         Release all TD's with a specific Device Address
;------------------------------------------------------------------------------
ReleaseTDs4Address:
  PUSH AX,CX,DX,DI,DS       ;Save used registers
  MOV  DS,ES                ;DS = TSR Data Area
  MOV  AH,AL                ;Save address in AH
R10:                        ;Loop to here for each TD that matches
  MOV  AL,AH                ;Get Address back again
  CALL Address2TD           ;Any TD's to release (rtns CF, DI)?
  JC  >R90                  ;If not, we're done
  XOR  CX,CX                ;Returns CX (Bytes Transferred) = 0
  MOV  DX,TDStsDvcRemoved   ;TD Status = Device Removed
  CALL DoUserFarCall        ;Inform the TD Owner
  CALL GetTDType            ;Get the Type of TD
R20:                        ;Test for Bulk
  CMP  AL,TDTypeBulk        ;Is it a Bulk TD?
  JNE >R30                  ;If not, try the next possibility
  CALL ReleaseBulkQHGivenTD ;If so, Release the Entire QH
  JMP >R60                  ;Done
R30:                        ;Test for Periodic Int in Queue
  CALL TestIntTDInQH        ;Is it a Periodic Int in a Queue?
  JC  >R50                  ;If not, just Release it
  CALL ReleaseIntQHGivenTD  ;If so, Release the Entire QH
  JMP >R60                  ;Done
R50:                        ;Only need to release 1 TD
  CALL ReleaseTD            ;Release the TD
R60:                        ;Done releasing the TD
  JMP  R10                  ;Keep looking for more
R90:                        ;Done
  POP  DS,DI,DX,CX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;LOOK FOR ADDRESSES WHERE THE HUB HAS BEEN REMOVED/RESET/DISCONNECTED
;Inputs:  ES = TSR Data area
;Outputs: ZF = Clear
;           CL = Address without a Hub any more
;         ZF = Set
;           CL = 0
;Changes:
;------------------------------------------------------------------------------
FindAddressWithNoHub:
  PUSH AX,DI                       ;Save used registers
  XOR  CL,CL                       ;Start with Address 0
F20:                               ;Loop to here for each entry to test
  MOV  AH,CL                       ;Save the current address
  CALL ADIndex2Offset              ;Get the Address Table Pointer (DI)
  TEST ES:[DI].ADFlags,ADFlagInUse ;Is this address in use?
  JZ  >F60                         ;If not, continue
  MOV  CL,ES:[DI].ADHubAddress     ;If so, get the hub address for this device
  CMP  CL,-1                       ;Is this the Root Hub?
  JE  >F60                         ;If so, don't delete it
  CALL ADIndex2Offset              ;Point at the Hub Address entry
  TEST ES:[DI].ADFlags,ADFlagInUse ;Is the hub still there?
  JZ  >F70                         ;If not, we've found one!
  PUSH AX                          ;Save used registers
  MOV  AL,CL                       ;Does the
  CALL Address2Intf                ;  Hub still
  CMP  ES:[DI].InCallBackAddr,0    ;  have an Owner?
  POP  AX                          ;Restore used registers
  JE  >F70                         ;If not, it's actually not there any more!
F60:                               ;Don't want to delete this address
  MOV  CL,AH                       ;Restore the Address we're working on
  INC  CL                          ;Point at the next entry
  CMP  CL,ADEntries                ;Are we at the end of the address table?
  JB   F20                         ;If not, keep looking
  JMP >F80                         ;If so, we're done
F70:                               ;Address with no hub found
  MOV  CL,AH                       ;Put address in CL
  JMP >F90                         ;Done
F80:                               ;All addresses have a hub
  XOR  CL,CL                       ;Address = 0
F90:                               ;Done
  OR   CL,CL                       ;set return flag
  POP  DI,AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;REMOVE AN ADDRESS FROM THE DEVICE ADDRESS TABLE
;Inputs:  CL = Address Number to Reset (resets to all zeros)
;         ES = TSR Data Area
;Outputs: Removes all entries from Address, Interface, and EndPoint Table
;Changes:
;------------------------------------------------------------------------------
ResetAddress0:
  PUSH CX           ;Save used registers
  XOR  CL,CL        ;Set Address to 0
  CALL ResetAddress ;Reset it
  POP  CX           ;Restore used registers
  RET

ResetAddress:
  PUSH AX                   ;Save used registers
  PUSHF                     ;Save Flags
  CLI                       ;Disable interrupts
  MOV  AL,CL                ;Put Address in AL
  CALL ReleaseIntfs4Address ;Release Interfaces & Alternate Interfaces
  CALL ReleaseEPs4Address   ;Release EndPoints
  CALL ReleaseADCL          ;Release the Address Entry
  POPF                      ;Restore Flags
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;LOOK FOR A TD ASSOCIATED WITH A PARTICULAR DEVICE ADDRESS
;Inputs:  AL = Address to Look For
;         ES = TSR Data Area
;Outputs: CF = Clear if there is a TD with the Address in it
;           [DI] = TD (first one) that contains the Address
;         CF = Set if no TD with that address is found
;           DI = Undefined
;Changes:
;------------------------------------------------------------------------------
Address2TD:
  PUSH AX                 ;Save used registers
  MOV  DI,TDOffset        ;Point at TD Table
  MOV  AH,AL              ;Put address to test in AH
A10:                      ;Loop to here for each entry
  CALL GetTDType          ;Is this TD
  CMP  AL,TDTypeAvailable ;  even in use?
  JE  >A40                ;If not, skip it
  CALL GetTDDeviceAddress ;If so, get the address
  CMP  AL,AH              ;Is it a match?
  JE  >A80                ;If so, we're done
A40:                      ;No Match
  ADD  DI,TDSize          ;Point at next entry
  CMP  DI,(TDOffset+(TDEntries*TDSize)) ;Done with the table yet?
  JB   A10                ;If not, keep looking
A70:                      ;No TD found
  STC                     ;Set not found flag
  JMP >A90                ;Done
A80:                      ;Found a TD
  CLC                     ;Set found flag
A90:                      ;Done
  POP  AX                 ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;MISCELLANEOUS INT 14h "GET INFO" TYPE REQUESTS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO BEEP THE SPEAKER
;Inputs:  DS:[SI] = Int 14h Request Structure
;         ES      = TSR Data area
;         AH      = HostIndex (-1 or ours)
;         AL      = Int14RBeepSpeaker
;Outputs: CF = Clear if OK
;              BP = Undefined
;              Notifies first Instance of Program to Beep the Speaker
;            = Set if Error
;              BP = Error Code
;Changes:
;NOTES: This can either be issued to All Hosts, or to a Single Host.
;       If to all Hosts, the first Host Driver to receive it will process it.
;------------------------------------------------------------------------------
BeepSpeaker:
  PUSH AX,BX,DX                  ;Save used registers
  MOV  BP,I14RErrAlreadyBeeping  ;Error = Already Beeping
  TEST CS:[TSRFlags0],DoTheBeep  ;Already have a beep Queued Up?
  JNZ >B70                       ;If so, quit
  CMP  CS:[BeepCount],0          ;Are we already processing a Beep?
  JNE >B70                       ;If so, quit
  CMP  CS:[BeepFrequency],0      ;Are we already processing a Beep?
  JNE >B70                       ;If so, quit
B10:                             ;Handle Frequency
  MOV  BP,I14RErrBeepFrequency   ;Assume Error
  MOV  BX,[SI].I14RBeepFrequency ;Get the Frequency
  OR   BX,BX                     ;Is it 0?
  JNZ >B20                       ;If not, continue
  MOV  BX,DefBeepFrequency       ;If so, use the Default
  JMP >B25                       ;No need to test it
B20:                             ;0 Frequency Handled
  CMP  BX,MinBeepFrequency       ;Is it too small?
  JB  >B70                       ;If so, error
  CMP  BX,MaxBeepFrequency       ;Is it too big?
  JA  >B70                       ;If so, error
B25:                             ;Beep Frequency is OK
  MOV  DX,0012h                  ;Put 1193280 (123540h)
  MOV  AX,3540h                  ;  in DX:AX
  DIV  BX                        ;Divide it by the beep frequency
  MOV  CS:[BeepFrequency],AX     ;Store it in [BeepFrequency]
B40:                             ;Handle Timeout
  MOV  AL,DefBeepTimeout         ;Set AL to Default Timeout
  CALL GetTimeoutTicksSI         ;Get Timeout Ticks (uses AL&SI, sets AX&BP)
  JZ  >B70                       ;If error, quit
  MOV  CS:[BeepCount],AX         ;Store it
  OR   CS:[TSRFlags0],DoTheBeep  ;Mark us for beeping
  JMP >B80                       ;Done
B70:                             ;Error
  STC                            ;Set Error Flag
  JMP >B90                       ;Done
B80:                             ;OK
  CLC                            ;Set return Flag
B90:                             ;Done
  POP  DX,BX,AX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO RECEIVE HUB CHARACTERISTICS FROM A HUB DRIVER
;Inputs:  DS:[SI] = Int 14h Request Structure
;         ES      = TSR Data area
;         AH      = HostIndex (-1 or ours)
;         AL      = Int14RRequestType (Send Hub Characteristics)
;Outputs: CF = Clear If OK
;              Stores Hub Characteristics
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
SendHubCharacteristics:
  PUSH DI                                 ;Save used registers
  CALL TestHostAndAddress0                ;Valid Address & Host (returns DI)?
  JC  >H70                                ;If not, Error
  CMP  ES:[DI].ADDvcClass,DvcClassHub     ;Is this Device really a Hub?
  JNE >H70                                ;If not, Error (Device Address)
  MOV  BP,I14RErrHubPort                  ;If Address OK, assume Hub Port Error
  MOV  AL,[SI].I14RHubPort                ;Get the Number of Hub Ports
  OR   AL,AL                              ;Is it valid?
  JZ  >H70                                ;If not, error
  MOV  ES:[DI].ADNumPorts,AL              ;If OK, store the number of ports
  TEST [SI].I14RConfigValue,01h           ;Hub Supports PPP?
  JNZ >H30                                ;If so, jump to Handle it
  AND  ES:[DI].ADFlags,(NOT ADFlagHubPPP) ;Mark it as not being supported
  JMP >H80                                ;Done
H30:                                      ;Hub Supports PPP
  OR   ES:[DI].ADFlags,ADFlagHubPPP       ;Mark it as being supported
  JMP >H80                                ;Done
H70:                                      ;Error
  STC                                     ;Set Error Flag
  JMP >H90                                ;Done
H80:                                      ;OK
  CLC                                     ;Set OK Flag
H90:                                      ;Done
  POP  DI                                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO GET HOST SOFTWARE INFORMATION
;Inputs:  DS:[SI] = Int 14h Request Structure
;         ES      = TSR Data area
;         AH      = HostIndex (-1 or ours)
;         AL      = Int14RRequestType (Get Software Info)
;         BX = CX = DX = -1
;Outputs: CF = Clear
;              If Host Index = -1 (Any/All Hosts):
;                 BX = API Version
;                 CX, DX = Unchanged (-1)
;              If our Host Index:
;                 BL = Host USB Version (1.0 or 1.1)
;                 BH = 0 (We do not use Int 2Fh)
;                 CX = DX = -1
;Changes:
;------------------------------------------------------------------------------
GetHostSWInfo:
  PUSH DS               ;Save used registers
  MOV  DS,ES            ;Point DS at TSR Data Area
  CMP  AH,AllHostsIndex ;Is it for All Hosts?
  JNE >S30              ;If not, it's really for us
S10:                    ;All Hosts
  MOV  BX,APIVersion    ;If so, set appropriate return values
  JMP >S90              ;Done
S30:                    ;Our individual Host
  MOV  BL,[USBVersion]  ;Set
  XOR  BH,BH            ;  return
S90:                    ;Done
  CLC                   ;Set OK Flag
  POP  DS               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO GET HOST HARDWARE INFO
;Inputs:  DS:[SI] = Int 14h Request Structure
;         ES      = TSR Data area
;         CS      = [FirstInstanceSeg]
;         AH      = HostIndex (-1 or ours)
;         AL      = Int14RRequestType (Get Hardware Info)
;         BX = CX = DX = -1
;Outputs: CF = Clear
;              If Host Index = -1 (Any/All Hosts):
;                 BX = [HostIndexes] Bit Mask
;                 CX, DX = Unchanged (-1)
;              If our Host Index:
;                 BL = USB Type (UHCI) & Bus Type (PCI)
;                 BH = -1 (future home of corresponding EHCI Host?)
;                 CL = USB Host Index
;                 CH = Number of Root Hub Ports (2)
;                 DX = PCI Bus-Device-Function Word
;Changes:
;------------------------------------------------------------------------------
GetHostHWInfo:
  PUSH DS                   ;Save used registers
  MOV  DS,ES                ;Point DS at TSR Data Area
  CMP  AH,AllHostsIndex     ;Is it for All Hosts?
  JNE >H30                  ;If not, it's really for us
H10:                        ;All Hosts
  MOV  BX,CS:[HostIndexes]  ;If so, set appropriate return values
  JMP >H90                  ;Done
H30:                        ;Our individual Host
  MOV  BL,(USBHostTypeUHCI+USBBusTypePCI) ;Set
  MOV  CL,[USBIRQNum]       ;  appropriate
  MOV  CH,[NumRootHubPorts] ;  return
  MOV  DX,[PCIDevFunc]      ;  values
H90:                        ;Done
  CLC                       ;Return = OK
  POP  DS                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO GET HOST VENDOR INFORMATION
;Inputs:  DS:[SI] = Int 14h Request Structure
;         ES      = TSR Data area
;         AH      = HostIndex (-1 or ours)
;         AL      = Int14RRequestType (Get Vendor Info)
;         BX = CX = DX = -1
;Outputs: CF = Clear If OK
;              BX = Vendor ID
;              CX = Product ID
;              DX = Unchanged (-1)
;              BP = Undefined
;            = Set if Error
;              BP = Error Code
;              BX, CX, DX = Unchanged (-1)
;Changes:
;NOTES: This Call cannot be passed on to other Host Indexes!
;------------------------------------------------------------------------------
GetHostVendorInfo:
  MOV  BP,I14RErrHostIndex   ;Assume Bad Host Index
  CMP  AH,AllHostsIndex      ;Is it for All Hosts?
  JE  >V70                   ;If so, Error
  MOV  BX,ES:[HostVendorID]  ;BX = Vendor ID
  MOV  CX,ES:[HostProductID] ;CX = Product ID
  JMP >V80                   ;Done
V70:                         ;Error
  STC                        ;Set Error Flag
  JMP >V90                   ;Done
V80:                         ;OK
  CLC                        ;Set OK Flag
V90:                         ;Done
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO GET THE CURRENT USB HOST STATUS
;Inputs:  DS:[SI] = Int 14h Request Structure
;         ES      = TSR Data area
;         AH      = HostIndex (-1 or ours)
;         AL      = Int14RRequestType (Get Host Status)
;         BX = CX = DX = -1
;Outputs: CF = Clear If OK
;              BL = Host Status Code (Running, Halted, etc.)
;              BH = Percentage of bus used by Isoch & Periodic Ints
;              CX = Current Frame Index
;                   Note that For non-UCHI Hosts, this may not be a
;                     Frame Index, but will be something to indicate where
;                     it is in the Schedule
;              DX = Frame Timing (Full-Speed Bits/Frame)
;            = Set if Error
;              BP = Error Code
;Changes:
;NOTES: This Call cannot be passed on to other Host Indexes!
;       In a UHCI Host, it is Halted while Debugging or Suspended, so we
;         need to check Debug/Suspend BEFORE we check Halted.
;       This may not necessarily be true for non-UHCI Hosts.
;------------------------------------------------------------------------------
GetHostStatus:
  PUSH AX                     ;Save used registers
  MOV  BP,I14RErrHostIndex    ;Assume Bad Host Index
  CMP  AH,AllHostsIndex       ;Is it for All Hosts?
  JE  >S70                    ;If so, Error
  CALL ReadUSBCommandWord     ;Read the USB Command Register
  MOV  DX,AX                  ;Save it in DX
  MOV  BL,USBStatus           ;Get the
  CALL ReadHostWord           ;  Host Status Register (AX)
  MOV  BL,HostStatusSuspended ;Assume Suspended
  TEST DL,UCGlobalSuspend     ;Is it Suspended?
  JNZ >S50                    ;If so, we're done
  MOV  BL,HostStatusDebugMode ;Assume Debug Mode
  TEST DL,UCSoftDebug         ;Is it in Debug Mode?
  JNZ >S50                    ;If so, we're done
  MOV  BL,HostStatusStopped   ;Assume Stopped/Halted
  TEST AL,USHostHalted        ;Is it Halted?
  JNZ >S50                    ;If so, we're done
  MOV  BL,HostStatusRunning   ;Assume Running
  TEST DL,UCRunStop           ;Is it Running?
  JNZ >S50                    ;If so, we're done
  MOV  BL,HostStatusUnknown   ;If none of these, Status is Unknown
S50:                          ;Have Status Calculated
  CALL CalcBusPercentUsed     ;Get the percentage of Bus Bandwidth
  MOV  BH,AL                  ;  used by Isoch & Periodic Int Transactions
  CALL GetFrameIndex          ;Get Current Frame Index
  MOV  CX,AX                  ;Put in in CX
  CALL GetFrameTiming         ;Get Current Frame Timing
  MOV  DX,AX                  ;Put it in DX
  JMP >S80                    ;Done
S70:                          ;Error
  XOR  BX,BX                  ;Set
  XOR  CX,CX                  ;  return values
  STC                         ;Set Error Flag
  JMP >S90                    ;DOne
S80:                          ;OK
  CLC                         ;Set OK Flag
S90:                          ;Done
  POP  AX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE PERCENTAGE OF BUS BANDWIDTH USED BY INT & ISOCH TRANSACTIONS
;Inputs:  ES = TSR Data Area (contains TD's)
;Outputs: AL = Percentage of Bus bandwidth used (approximate!)
;Changes:
;------------------------------------------------------------------------------
CalcBusPercentUsed:
  PUSH EBX,ECX,EDX     ;Save used registers
  MOV  EBX,EAX         ;Save original EAX
  CALL CalcBusBitsUsed ;Get bits used by Transactions (ECX)
  MOV  EAX,100         ;Multiply by 100
  MUL  ECX             ;  (convert to a percent)
  MOV  ECX,(IsochIntBits*FLEntries) ;Divide by the
  DIV  ECX             ;  number of
  SHR  ECX,1           ;  Isoch & Int
  CMP  EDX,ECX         ;  bits allowed
  JB  >P20             ;  per
  INC  AX              ;  frame period
P20:                   ;AX contains percentage
  TEST AH,-1           ;More than 255% (shouldn't be!!)
  JZ  >P30             ;If not, continue
  MOV  AL,-1           ;If so, make it 255%
P30:                   ;AL contains percentage
  MOV  BL,AL           ;Put pct in BL
  MOV  EAX,EBX         ;Put pct in AL, restore high 3 bytes of EAX
  POP  EDX,ECX,EBX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE TOTAL FULL-SPEED BIT TIMES USED BY INT & ISOCH TRANSACTIONS
;Inputs:  ES = TSR Data Area (contains TD's)
;Outputs: ECX = Total number of bits used by Control & Isoch Transactions
;Changes:
;NOTES: This compensates for Overhead bits, Low-speed/High-speed,
;         and Periodicity!
;------------------------------------------------------------------------------
CalcBusBitsUsed:
  PUSH EAX,BX,DX,DI,SI,EBP        ;Save used registers
  XOR  EBP,EBP                    ;EBP = Accumulator
  MOV  DI,TDOffset                ;[DI] = first TD
  MOV  BX,TDEntries               ;BX = Number of TD's to search
B10:                              ;Loop to here for each TD
  CALL GetTDType                  ;Get the TD Type
  CMP  AL,TDTypeIsoch             ;Is it Isochronous?
  JE  >B20                        ;If so, add it
  CMP  AL,TDTypeInterruptPer      ;Is it Periodic?
  JNE >B60                        ;If not, don't add it
B20:                              ;Is Isoch or Periodic Interrupt!
  CALL CalcTDBits                 ;Calculate the number of bits in this TD (CX)
  MOV  AX,FLEntries               ;Calculate
  XOR  DX,DX                      ;  the number
  MOV  SI,W ES:[DI].TDPeriodicity ;  of time
  DIV  SI                         ;  the TD
  SHR  SI,1                       ;  occurs
  CMP  DX,SI                      ;  during
  JB  >B25                        ;  each
  INC  AX                         ;  Frame Period
B25:                              ;AX contains number of times per Frame Period
  MUL  CX                         ;Multiply by bits per TD
  PUSH DX                         ;Add
  PUSH AX                         ;  it
  POP  EAX                        ;  to
  ADD  EBP,EAX                    ;  the total
B60:                              ;Done with this TD
  ADD  DI,TDSize                  ;Point at next TD
  DEC  BX                         ;Done with all of the TD's yet?
  JNZ  B10                        ;If not, keep looking
B90:                              ;Done
  MOV  ECX,EBP                    ;Put Total in ECX for the return
  POP  EBP,SI,DI,DX,BX,EAX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO COPY THE NEW DEVICE OWNERSHIP REGISTRATION TABLE
;Inputs:  DS:[SI] = Int 14h Request Structure
;         ES      = TSR Data area
;         CS      = [FirstInstanceSeg]
;         AH      = HostIndex (-1 or ours)
;         AL      = Int14RRequestType (Copy New Device Table)
;         CLD already issued
;Outputs: CF = Set if Error
;                 BP = Error Code
;            = Clear if OK
;                 Copies New Device Ownership table to requested location
;                 BP = Undefined
;Changes:
;------------------------------------------------------------------------------
CopyNDTable:
  PUSH CX,DI,SI,DS,ES               ;Save used registers
  MOV  BP,I14RErrDataSize           ;Assume Data Size error
  CMP  [SI].I14RDataSize,(NDEntries*NDSize) ;Is the Data Size OK?
  JNE >N70                          ;If not, error
  MOV  CX,W [SI].I14RDataAddress[2] ;Get Data Address Segment
  MOV  DI,W [SI].I14RDataAddress[0] ;  and Offset
  MOV  SI,NDTable                   ;Point DS:[SI] at our
  MOV  DS,ES:[FirstInstanceSeg]     ;  ND Table
  MOV  ES,CX                        ;Point ES:DI at where to copy it to
  MOV  CX,((NDEntries*NDSize)/2)    ;Number of Words to Copy
  REP  MOVSW                        ;Copy the Table
  JMP >N80                          ;Done
N70:                                ;Error
  STC                               ;Set Error Flag
  JMP >N90                          ;Done
N80:                                ;OK
  CLC                               ;Set OK Flag
N90:                                ;Done
  POP  ES,DS,SI,DI,CX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO GET DEVICE HUB INFORMATION
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         AH = Host Index (-1 or ours)
;Outputs: CF = Clear if OK
;              BL = Hub Address (-1 if Root Hub)
;              BH = Hub Port (-1 if Root Hub)
;              CX = DX = Unchanged (-1)
;              BP = Undefined
;            = Set if no Device Found
;              BX = CX = DX = Unchanged (-1)
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
GetDvcHubInfo:
  PUSH DI                        ;Save used registers
  CALL TestHostAndAddress0       ;Test Host and Addr validity (rtns DI)
  JC  >H90                       ;If not, error
  MOV  BX,W ES:[DI].ADHubAddress ;BL = Hub Address, BH = Hub Port
  CLC                            ;Return flag = OK
H90:                             ;Done
  POP  DI                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO GET DEVICE POWER INFORMATION
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         AH = Host Index (-1 or ours)
;Outputs: CF = Clear if OK
;              BX = Device Power Draw from Bus (mA)
;              CL = Power Flags (Self-Powered, IsHub, Per-Port-Power-Switch)
;              CH = Number of Ports (0 if Device is not a Hub)
;              DX = Unchanged (-1)
;              BP = Undefined
;            = Set if no Device Found
;              BX = CX = DX = Unchanged (-1)
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
GetDvcPowerInfo:
  PUSH AX,DI                 ;Save used registers
  CALL TestHostAndAddress0   ;Test Host and Addr validity (rtns DI)
  JC  >P90                   ;If not, error
  XOR  CX,CX                 ;Start Flags & Number of Port at 0
  MOV  AL,ES:[DI].ADFlags    ;Get Address Flags
  CMP  ES:[DI].ADDvcClass,DvcClassHub ;Is it a Hub?
  JNE >P20                   ;If not, skip Hub Stuff
  OR   CL,DvcPwrInfoDvcIsHub ;If so, mark it as a Hub
  MOV  AH,ES:[DI].ADNumPorts ;Store the number
  MOV  CH,AH                 ;  of Hub Ports
  TEST AL,ADFlagHubPPP       ;Is it a Per-Port-Powered Hub?
  JZ  >P20                   ;If not, we're done with Hub Stuff
  OR   CL,DvcPwrInfoHubPPP   ;If so, mark it as a Per-Port-Powered Hub
P20:                         ;Hub stuff handled
  TEST AL,ADFlagSelfPwr      ;Is it Self-Powered?
  JZ  >P40                   ;If not, we're done with the Flags
  OR   CL,DvcPwrInfoSelfPwr  ;If so, mark it as Self-Powered
P40:                         ;Done with Flags
  XOR  BH,BH                 ;Put the
  MOV  BL,ES:[DI].ADBusPower ;  Bus Power Draw
  SHL  BX,1                  ;  in BX (mA)
  CLC                        ;Return flag = OK
P90:                         ;Done
  POP  DI,AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO GET POWER DRAW INFORMATION FOR A HUB/PORT
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         AH = Host Index (-1 or ours)
;Outputs: CF = Clear if OK
;              BX = Total Power Draw from Hub (mA)
;              CX = DX = Unchanged (-1)
;              BP = Undefined
;            = Set if invalid Hub/Port
;              BX = CX = DX = Unchanged (-1)
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
GetHubPowerDraw:
  PUSH AX,DI                  ;Save used registers
  CALL TestHostAndAddress1    ;Test Host and Addr validity (rtns DI)
  JC  >W90                    ;If not, error
  MOV  BP,I14RErrHubAddress   ;Assume Device is not a Hub
  CMP  ES:[DI].ADDvcClass,DvcClassHub ;Is it a Hub?
  JNE >W70                    ;If not, error
  MOV  BP,I14RErrHubPort      ;Assume invalid Port Number
  MOV  AH,[SI].I14RHubPort    ;Is it a valid
  CMP  AH,ES:[DI].ADNumPorts  ;  Port Number?
  JA  >W70                    ;If not, error
  MOV  AL,[SI].I14RHubAddress ;If OK, get the
  CALL CalcHubPowerDraw       ;  Hub/Port Power Draw
  JMP >W80                    ;Done
W70:                          ;Error
  STC                         ;Return flag = Error
  JMP >W90                    ;Done
W80:                          ;OK
  CLC                         ;Return flag = OK
W90:                          ;Done
  POP  DI,AX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE TOTAL CURRENT CONSUMED BY DOWNSTREAM DEVICES ON A HUB
;Inputs:  AL = Hub Address to get power for
;         AH = Hub Port to get power for (0 = Get All Ports)
;         ES = TSR Data Area
;Outputs: BX = Total Current drawn by all bus-powered downstream devices
;Changes:
;NOTES: This does not test for validity of the Hub Address or Port Number.
;       If the Address or Port Number does not exist, this will simply return
;         with AX = 0.
;------------------------------------------------------------------------------
CalcHubPowerDraw:
  PUSH AX,CX,DX,DI,SI,BP,DS       ;Save used registers
  MOV  DS,ES                      ;Point DS at TSR Data Area
  MOV  DX,AX                      ;Store Hub Address in DL, Port in DH
  XOR  BX,BX                      ;BX = Running Power Total
 #IF !LITE
  MOV  SI,ADOffset                ;[SI] = Address Table
 #ELSE
  MOV  SI,DS:[ADTable]            ;[SI] = Address Table
 #ENDIF
  MOV  BP,SI                      ;BP = Offset of
  ADD  BP,ADSize                  ;  Address 1 (Root Hub)
  ADD  SI,((ADEntries-1)*ADSize)  ;[SI] = Last Address
P10:                              ;Loop to here for each Address
  TEST [SI].ADFlags,ADFlagInUse   ;Valid Address?
  JZ  >P60                        ;If not, skip it
  TEST [SI].ADFlags,ADFlagSelfPwr ;If valid, is it Self-powered?
  JNZ >P60                        ;If so, skip it
  MOV  DI,SI                      ;Put our pointer in [DI]
P20:                              ;Loop to here to determine ancestry
  MOV  CX,W [DI].ADHubAddress     ;CL = Device's Hub Address, CH = Hub Port
  OR   DH,DH                      ;Are we doing all ports or just one?
  JNZ >P30                        ;If just one, jump to handle it
P25:                              ;Doing all ports
  CMP  CL,DL                      ;Is it a port on the hub we're looking for?
  JE  >P50                        ;If so, add the current draw to our total
  JMP >P40                        ;If not, hyandle it
P30:                              ;Looking for a specific Port
  CMP  CX,DX                      ;Is it the Hub & Port we're looking for?
  JE  >P50                        ;If so, add the current draw to the total
P40:                              ;Not the Hub/Port we're looking for
  CALL ADIndex2Offset             ;Point [DI] at the Hub's Address Entry
  TEST [DI].ADFlags,ADFlagSelfPwr ;Is it a Self-powered Hub?
  JNZ >P60                        ;If so, don't add our current to the total
  CMP  CL,1                       ;Are we at the Root Hub Entry yet?
  JNE  P20                        ;If not, keep checking the ancestry
  JMP >P60                        ;If so, we're done with this entry
P50:                              ;Add this Devices Current to the Total
  XOR  AX,AX                      ;Add the current draw
  MOV  AL,[SI].ADBusPower         ;  of this Device
  ADD  BX,AX                      ;  to the total
P60:                              ;Done testing this address
  SUB  SI,ADSize                  ;Go to the next lower address
  CMP  SI,BP                      ;Are we pointed at the Root Hub (Address 1)?
  JA   P10                        ;If not, we need to keep testing
  SHL  BX,1                       ;Multiply by 2 (convert to mA)
  POP  DS,BP,SI,DI,DX,CX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO GET DEVICE CLASS INFORMATION
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         AH = Host Index (-1 or ours)
;Outputs: CF = Clear if OK
;              BL = Device Class
;              BH = Device SubClass
;              CL = Device Protocol
;              CH = USB Version (BCD)
;              DL = Speed
;              DH = Unchanged (-1)
;              BP = Undefined
;            = Set if no Device Found
;              BX = CX = DX = Unchanged (-1)
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
GetDvcClassInfo:
  PUSH DI                       ;Save used registers
  CALL TestHostAndAddress0      ;Test Host and Addr validity (rtns DI)
  JC  >C70                      ;If not, error
  MOV  BX,W ES:[DI].ADDvcClass  ;BL = Dvc Class, BH = Dvc SubClass
  MOV  CL,ES:[DI].ADDvcProtocol ;CL = Dvc Protocol
  MOV  CH,ES:[DI].ADUSBVersion  ;CH = USB Version
  XOR  DL,DL                    ;Assume Full Speed
  TEST ES:[DI].ADFlags,ADFlagLowSpeed ;Low Speed?
  JZ  >C80                      ;If not, we're done
  OR   DL,1                     ;Mark as Low Speed
  JMP >C80                      ;Done
C70:                            ;Error
  STC                           ;Set error flag
  JMP >C90                      ;Done
C80:                            ;Worked OK
  CLC                           ;Return flag = OK
C90:                            ;Done
  POP  DI                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO GET DEVICE VENDOR INFORMATION
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         AH = Host Index (-1 or ours)
;Outputs: CF = Clear if OK
;              BX = Vendor ID
;              CX = Product ID
;              DX = Unchanged (-1)
;              BP = Undefined
;            = Set if no Device Found
;              BX, CX, DX = Unchanged (-1)
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
GetDvcVendorInfo:
  PUSH DI                     ;Save used registers
  CALL TestHostAndAddress0    ;Test Host and Addr validity (rtns DI)
  JC  >V90                    ;If not, Error
  MOV  BX,ES:[DI].ADVendorID  ;BX = Vendor ID
  MOV  CX,ES:[DI].ADProductID ;CX = Product ID
  CLC                         ;Return flag = OK
V90:                          ;Done
  POP  DI                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO GET DEVICE STATUS INFORMATION
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         AH = Host Index (-1 or ours)
;Outputs: CF = Clear if OK
;              BL = Current Config Value
;              BH = Remote Wakeup & Test Status
;                   Bit 0 = Remote Wakeup Supported
;                   Bit 1 = Remote Wakeup Enabled
;                   Bit 2 = Test Mode Enabled
;              CL = NewDeviceStage
;              DX = NewDeviceError
;              CH = Unchanged (-1)
;              BP = Undefined
;            = Set if no Device Found
;              BX = CX = DX = Unchanged (-1)
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
GetDvcStatus:
  PUSH DI                          ;Save used registers
  CALL TestHostAndAddress0         ;Test Host and Addr validity (rtns DI)
  JC  >S70                         ;If not, error
  MOV  BL,ES:[DI].ADConfigValue    ;BL = Config Value
  MOV  BH,ES:[DI].ADFlags2         ;BH = Bad Device, RmtWkUp, & Test Statuses
  MOV  CL,ES:[DI].ADNewDeviceStage ;CL = New Device Stage
  MOV  DX,ES:[DI].ADNewDeviceError ;DX = New Device Error Code
  JMP >S80                         ;Done
S70:                               ;Error
  STC                              ;Set error flag
  JMP >S90                         ;Done
S80:                               ;Worked OK
  CLC                              ;Return flag = OK
S90:                               ;Done
  POP  DI                          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO GET ALTERNATE INTERFACE INFORMATION
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         AH = Host Index (-1 or ours)
;Outputs: CF = Clear if OK
;              BL = Interface Class
;              BH = Interface SubClass
;              CL = Interface Protocol
;              CH = Bit 0 set if AltInterface is currently Selected
;                   Bit 1 set if (Alt)Interface is currently owned
;              DX = Unchanged (-1)
;              BP = Undefined
;            = Set if no Device Found
;              BX = CX = DX = Unchanged (-1)
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
GetAltIntfInfo:
  PUSH AX,DI                          ;Save used registers
  CALL TestHostAndAddress0            ;Test Host and Addr validity (rtns DI)
  JC  >I70                            ;If not, Error
  MOV  BP,I14RErrInterfaceNum         ;Assume Bad Interface Number
  MOV  AL,[SI].I14RDeviceAddress      ;AL = Device Address
  MOV  AH,[SI].I14RInterfaceNum       ;AH = Interface Number
  CALL AddressIntf2Intf               ;Look for the Interface Num (Rtns ES:DI)
  JC  >I70                            ;If not there, Error
  MOV  BP,I14RErrAltIntf              ;Assume Bad Alternate Interface
  MOV  AL,[SI].I14RAltInterface       ;If OK, look for the
  CALL FindAltInterfaceALDI           ;  Alternate Interface
  JC  >I70                            ;If not found, errir
  MOV  BX,W ES:[DI].AIIntfClass       ;BL = Intf Class, BH = Intf SubClass
  MOV  CL,ES:[DI].AIIntfProtocol      ;CL = Intf Protocol
  XOR  CH,CH                          ;Start Flags at 0
  TEST ES:[DI].AIFlags,AIFlagSelected ;Is it selected?
  JZ  >I20                            ;If not, we're done
  OR   CH,AltIntfInfoSelected         ;If so, mark it as selected
I20:                                  ;Done with Selected Status
  MOV  DI,ES:[DI].AIInterfaceOffset   ;Point at Interface Entry
  CMP  ES:[DI].InCallBackAddr,0       ;Is it owned?
  JE  >I80                            ;If not, we're done
  OR   CH,AltIntfInfoOwned            ;If so, mark it as selected
  JMP >I80                            ;Done
I70:                                  ;Error
  STC                                 ;Set error flag
  JMP >I90                            ;Done
I80:                                  ;Worked OK
  CLC                                 ;Return flag = OK
I90:                                  ;Done
  POP  DI,AX                          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE ALTERNATE INTERFACE ENTRY THAT CORRESPONDS TO AN INTERFACE
;Inputs:  ES = TSR Data Area
;         DI = Interface Table Entry to match up with
;         AL = Alternate Interface to Find
;Outputs: CF = Clear if Found
;              DI = Alt Interface Table Entry
;            = Set if Error (not Found)
;              DI = Unchanged
;Changes:
;------------------------------------------------------------------------------
FindAltInterfaceALDI:
  PUSH CX,DX                        ;Save used registers
  MOV  DX,DI                        ;Save original Pointer
 #IF !LITE
  MOV  DI,AIOffset                  ;ES:[DI] = Alternate Interface Table
 #ELSE
  MOV  DI,ES:[AITable]              ;ES:[DI] = Alternate Interface Table
 #ENDIF
  MOV  CX,AIEntries                 ;Number of Table Entries
A10:                                ;Loop to here for each Table Entry
  TEST ES:[DI].AIFlags,AIFlagInUse  ;Valid Entry?
  JZ  >A30                          ;If not, skip it
  CMP  DX,ES:[DI].AIInterfaceOffset ;Correct Interface?
  JNE >A30                          ;If not, skip it
  CMP  AL,ES:[DI].AIAltIntfNum       ;Is it the corrent Alt Interface?
  JE  >A80                          ;If so, we found it
A30:                                ;Skip this entry
  ADD  DI,AISize                    ;Point at next entry
  LOOP A10                          ;Keep looking
A70:                                ;No found
  MOV  DI,DX                        ;Restore original Pointer
  STC                               ;Set return flag
  JMP >A90                          ;Done
A80:                                ;Found
  CLC                               ;Set Return Flag
A90:                                ;Done
  POP  DX,CX                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO SEARCH FOR AN (UN)REGISTERED INTERFACE, INCL SPANNING HOSTS
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;Outputs: CF = Clear if OK
;              CL = Host Index
;              CH = Device Address
;              DL = Interface Number
;              DH = Alternate Interface
;              BP = Undefined
;            = Set if no Device Found
;              CX = DX = -1
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
FindRegIntf:
  OR   ES:[TSRFlags],DoRegIntf          ;Mark as Doing Registered Interface
  JMP >Q00                              ;Do it
FindUnRegIntf:
  AND  ES:[TSRFlags],(NOT DoRegIntf)    ;Mark as Doing Unregistered Interface
;  JMP >Q00                              ;Do it
Q00:
  PUSH AX,BX                            ;Save used registers
  MOV  BP,I14RErrIntfNotFound           ;Error = Interface not Found
  CMP  [SI].I14RHostIndex,AllHostsIndex ;Is it Any/All Hosts?
  JE  >Q05                              ;If so, jump to handle it
  CALL FindIntfHere                     ;If not, just this Host (Rtns BX,CX,DX)
  JMP >Q95                              ;Done
Q05:                                    ;Do All Hosts
  MOV  AH,[SI].I14RSearchIndex          ;Save Original
  MOV  BX,CS:[HostIndexes]              ;Get Host Indexes
  XOR  AL,AL                            ;Start with First Host
Q10:                                    ;Loop to here to find Device
  SHR  BX,1                             ;Is AL a Valid Host Index?
  JNC >Q20                              ;If not, skip it
  MOV  [SI].I14RHostIndex,AL            ;Use Host Index AL
  CALL DoInt14CallCXDXSI                ;Do it (Modifies DS:I14RSearchIndex)
  JNC >Q80                              ;If we found it, quit
Q20:                                    ;Done with this Host
  INC  AL                               ;AL = Next Host Index
  OR   BX,BX                            ;Done all of the Hosts already?
  JNZ  Q10                              ;If not, continue scanning
Q70:                                    ;No Device Found
  MOV  CX,-1                            ;CX = -1
  MOV  DX,CX                            ;DX = -1
  STC                                   ;Error Code
  JMP >Q90                              ;Done
Q80:                                    ;Got it!
  CLC                                   ;Set OK flag
Q90:                                    ;Done with All Hosts
  MOV  [SI].I14RHostIndex,AllHostsIndex ;Restore original Search Index
  MOV  [SI].I14RSearchIndex,AH          ;  Search Index
Q95:                                    ;Done
  POP  BX,AX                            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO SEARCH FOR AN (UN)REGISTERED INTERFACE, THIS HOST ONLY
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;              [TSRFlags].DoRegIntf indicates Whether looking for Reg or UnReg
;Outputs: CF = Clear if OK
;              CL = Host Index
;              CH = Device Address
;              DL = Interface Number
;              DH = Alternate Interface Number
;            = Set if no Device Found
;              CX = DX = -1
;Changes:
;------------------------------------------------------------------------------
FindIntfHere:
  PUSH AX,DI                       ;Save used registers
 #IF !LITE
  MOV  DI,InOffset                 ;ES:[DI] = Interface Table
 #ELSE
  MOV  DI,ES:[InTable]             ;ES:[DI] = Interface Table
 #ENDIF
  MOV  DL,InEntries                ;Number of Interfaces to test
L10:                               ;Loop to here for each Interface
  TEST ES:[DI].InFlags,InFlagInUse ;Valid Interface?
  JZ  >L50                         ;If not, skip it
  CALL TestIntfAddrValidity        ;Test the Address for Validity
  JC  >L50                         ;If Invalid, skip it
  TEST ES:[TSRFlags],DoRegIntf     ;Looking for a Registered Interface?
  JZ  >L20                         ;If not, handle UnRegistered
  CMP  ES:[DI].InCallBackAddr,0    ;Already Registered?
  JE  >L50                         ;If not, skip it
  JMP >L30                         ;If so, keep testing
L20:                               ;Looking for UnRegistered Interface
  CMP  ES:[DI].InCallBackAddr,0    ;Already Registered?
  JNE >L50                         ;If so, skip it
L30:                               ;Do the Test!
;-------------------------
;Test Interface Attributes
;-------------------------
  PUSH SI                          ;Save Pointer
  ADD  SI,(OFFSET I14RIntfClass)   ;Point at Interface Class
  CALL TestIntfCSP                 ;Test Class, SubClass, Protocol (CF & AL)
  POP  SI                          ;Restore Pointer
  JC  >L50                         ;If not match, skip it
  MOV  DH,AL                       ;If OK, store the Alt Interface Number
;----------------------
;Test Device Attributes
;----------------------
  PUSH DI,SI                       ;Save Pointers
  MOV  CL,ES:[DI].InDeviceAddress  ;Point
  CALL ADIndex2Offset              ;  at
  ADD  DI,(OFFSET ADDvcClass)      ;  Device Class
  ADD  SI,(OFFSET I14RDvcClass)    ;Point at Device Class
  MOV  CL,3                        ;Test 3 bytes
  CALL CompareByteTables           ;Compare the Tables
  POP  SI,DI                       ;Restore Pointers
  JC  >L50                         ;If no match, skip it
;------------------------
;Test Vendor & Product ID
;------------------------
  PUSH EAX,DI,SI                   ;Save Pointers
  MOV  CL,ES:[DI].InDeviceAddress  ;Point
  CALL ADIndex2Offset              ;  at
  ADD  DI,(OFFSET ADVendorID)      ;  Vendor ID
  ADD  SI,(OFFSET I14RVendorID)    ;Point at Vendor ID
  MOV  EAX,[SI]                    ;Get Original Vendor ID & Product ID
  PUSH EAX                         ;Save it
  CALL ConvertVPID2Neg1            ;  to -1's, if necessary
  MOV  [SI],EAX                    ;Store it in the Request Structure
  MOV  CL,2                        ;Test 2 words
  CALL CompareWordTables           ;Compare the Tables
  POP  EAX                         ;Get Original Vendor ID & Product ID back
  MOV  [SI],EAX                    ;Restore it
  POP  SI,DI,EAX                   ;Restore Pointers
  JC  >L50                         ;If no match, skip it
L40:                               ;It's a match!
  CMP  [SI].I14RSearchIndex,0      ;Is it the correct Index?
  JE  >L80                         ;If so, we've found it!
  DEC  [SI].I14RSearchIndex        ;If not, Decrement the Index
L50:                               ;Not the correct Interface
  ADD  DI,InSize                   ;Point at the next Interface Entry
  DEC  DL                          ;Decrement the Loop Counter
  JNZ  L10                         ;If not done yet, keep looking
L70:                               ;No match
  MOV  CX,-1                       ;CX = -1
  MOV  DX,CX                       ;DX = -1
  STC                              ;Set Error Flag
  JMP >L90                         ;Done
L80:                               ;It matches
  MOV  CH,ES:[DI].InDeviceAddress  ;CH = Address
  MOV  CL,ES:[USBHostIndex]        ;CL = Host Index
  MOV  DL,ES:[DI].InInterfaceNum   ;DL = Interface Number
                                   ;DH = Alternate Interface Number
  CLC                              ;Set OK flag
L90:                               ;Done
  POP  DI,AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO CLOSE A HANDLE (RELEASE A TRANSFER DESCRIPTOR)
;Inputs:  ES = TSR Data Area
;         [DI] = Interface Table Entry to Test
;Outputs: CF = Clear if OK (Address is not Bad, and Device is Configured)
;            = Set if Error (Address is Bad and/or Device is Unconfigured)
;Changes:
;------------------------------------------------------------------------------
TestIntfAddrValidity:
  PUSH CX,DI,DS                     ;Save used registers
  MOV  DS,ES                        ;Point DS at TSR Data Area
  MOV  CL,[DI].InDeviceAddress      ;Point DI at
  CALL ADIndex2Offset               ;  the Address Table Entry
  TEST [DI].ADFlags2,ADFlagBadDvc   ;Is it a Bad Device?
  JNZ >V70                          ;If so, it's an Error
  CMP  [DI].ADConfigValue,0         ;Configured?
  JNE >V80                          ;If so, it's OK
  TEST [DI].ADFlags,ADFlagConfig0OK ;If not, is Config Value 0 valid?
  JNZ >V80                          ;If so, it's OK
V70:                                ;Error
  STC                               ;Set Error Flag
  JMP >V90                          ;Done
V80:                                ;OK
  CLC                               ;Set OK Flag
V90:                                ;Done
  POP  DS,DI,CX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO CLOSE A HANDLE (RELEASE A TRANSFER DESCRIPTOR)
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         AH = Host Index (-1 or Ours)
;Outputs: CF = Clear if OK (TD Released)
;              BX = CX = DX = Unchanged (-1)
;              BP = Undefined
;            = Set if Error
;              BX = CX = DX = Unchanged (-1)
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
CloseHandle:
  PUSH AX,CX,DI                  ;Save used registers
  CALL TestHostAndHandle         ;Test Host & Handle validity (Returns CX, BP)
  JC  >H70                       ;If invalid, error
  CMP  CX,(TDEntries-1)          ;Is it too big?
  JA  >H50                       ;If so, see if it's a Bulk Queue
H10:                             ;Is a TD
  CALL TDIndex2Offset            ;Convert it to an offset (ES:DI)
  CALL GetTDType                 ;Is it a
  CMP  AL,TDTypeAvailable        ;  Legitimate Handle?
  JE  >H70                       ;If not, Error
  MOV  BP,I14RErrCloseID         ;Assume Close ID Error
  CMP  AL,TDTypeInterrupt1Time   ;Is it a 1-time Interrupt?
  JNE >H20                       ;If not, continue
  MOV  AL,ES:[DI].TDCloseID      ;If so, get the Closure ID
  CMP  AL,[SI].I14RCloseID       ;Does it match?
  JE  >H40                       ;If so, OK to Release it
  JMP >H70                       ;If not, Error
H20:                             ;Not one-time interrupt
  CMP  AL,TDTypeControlSetup     ;Control?
  JB  >H30                       ;If not, Ok to Release it
  CMP  AL,TDTypeControlStatus    ;Control?
  JA  >H30                       ;If not, Ok to Release it
  MOV  CL,ES:[DI].TDTimeoutIndex ;Get the Timeout Table Index
  CALL TestTTCloseID             ;Does the Closure ID match?
  JZ  >H40                       ;If so, Close it
  JMP >H70                       ;If not, error
H30:                             ;Test for Periodic Int
  CALL TestIntTDInQH             ;Is it a Periodic Interrupt in a Queue?
  JC  >H40                       ;If not, just release the TD
  CALL ReleaseIntQHGivenTD       ;If so, release all TD's and the Queue
  JMP >H80                       ;Done
H40:                             ;OK to release
  CALL ReleaseTD                 ;Release it
  JMP >H80                       ;Done

H50:                             ;Test for a Queue (Bulk Transaction)
  SUB  CX,(TDEntries-1)          ;Subtract out Bulk Queue Offset
  CMP  CX,BulkQHEntries          ;Is it too big?
  JA  >H70                       ;If so, error
  CALL QHIndex2Offset            ;Convert it to an Offset (ES:DI)
  TEST B ES:[DI].QHElementPointer,QHTerminate ;Empty Queue?
  JNZ >H70                       ;If so, Error
  MOV  CL,ES:[DI].QHBulkTimeoutIndex ;Get the Timeout Table Index
  CALL TestTTCloseID             ;Does the Closure ID match?
  JNZ >H70                       ;If not, error (rtns BP)
  CALL ReleaseBulkQH             ;Release it
  JMP >H80                       ;Done
H70:                             ;Error
  STC                            ;Set error flag
  JMP >H90                       ;Done
H80:                             ;Worked OK
  CLC                            ;Return flag = OK
H90:                             ;Done
  POP  DI,CX,AX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST THE CLOSURE ID FOR A CLOSE HANDLE REQUEST
;Inputs:  ES = TSR Data Area
;         CL = TTIndex
;         DS:[SI] = Interrupt 14h Request (contains I14RCloseID)
;Outputs: ZF = Set if Closure ID matches
;              BP = Undefined
;            = Clear if no match
;              BP = Error Code (I14RErrCloseID)
;Changes:
;------------------------------------------------------------------------------
TestTTCloseID:
  PUSH AX,DI                ;Save used registers
  MOV  BP,I14RErrCloseID    ;Error = CloseID
  CALL TTIndex2Offset       ;Get the Timeout Table Pointer (DI)
  MOV  AL,ES:[DI].TTCloseID ;Get the Closure ID
  CMP  AL,[SI].I14RCloseID  ;Does it match (sets return flag)?
  POP  DI,AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO CHANGE THE PERIODICITY OF A PERIODIC INTERRUPT
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         AH = Host Index (-1 or Ours)
;Outputs: CF = Clear if OK (New Periodicity Rate Set)
;              BX = CX = DX = Unchanged (-1)
;              BP = Undefined
;            = Set if Error (Invalid Handle)
;              BX = CX = DX = Unchanged (-1)
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
ChangePeriodicity:
  PUSH AX,BX,CX,DI                 ;Save used registers
  PUSHF                            ;Save flags
  CALL TestHostAndHandle           ;Test Host & Handle validity (Returns CX)
  JC  >P70                         ;If invalid, error
  CMP  CX,(TDEntries-1)            ;Is it too big?
  JA  >P70                         ;If so, it's an error
  MOV  BP,I14RErrPeriodicity       ;Assume Bad Periodicity
  MOV  BX,[SI].I14RPeriodicity     ;Get Periodicity
  OR   BX,BX                       ;Is it too small?
  JZ  >P70                         ;If so, Error
  CMP  BX,FLEntries                ;Is it too big?
  JA  >P70                         ;If so, error
  CALL TDIndex2Offset              ;Convert it to an offset (ES:DI)
  CALL GetTDType                   ;Get TD Type (Returns AL)
  MOV  BP,I14RErrRequestHandle     ;Assume Bad Handle
  CMP  AL,TDTypeInterruptPer       ;Is it really a Periodic Interrupt?
  JNE >P70                         ;If not, it's an error
  CLI                              ;Disable interrupts
P20:                               ;Loop to here for each TD in the Queue
  MOV  ES:[DI].TDPeriodicity,BX    ;Store the Periodicity
  CALL GetNextIntTD                ;Point at the Next TD
  JNC  P20                         ;If there is a next TD, keep going
  CALL GetIntQHPtrDI               ;Get the QH Pointer
  JC  >P80                         ;If none, we're done
  MOV  ES:[DI].QHIntPeriodicity,BX ;Store the new periodicity in the QH
  JMP >P80                         ;Done
P70:                               ;Error
  POPF                             ;Restore flags
  STC                              ;Set error flag
  JMP >P90                         ;Done
P80:                               ;Worked OK
  POPF                             ;Restore flags
  CLC                              ;Return flag = OK
P90:                               ;Done
  POP  DI,CX,BX,AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO GET THE STATUS OF A TRANSACTION HANDLE
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;         AH = Host Index (-1 or Ours)
;Outputs: CF = Clear if OK
;              BX, CX, DX = Data as appropriate (depends on Handle Type)
;                In general, BX = General/Flags, CX = Timing, DX = Data
;              BP = Undefined
;            = Set if Error
;              BX = CX = DX = Unchanged (-1)
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
GetTransStatus:
  PUSH EAX,DI,SI,DS,FS              ;Save used registers
  MOV  FS,CX                        ;Save original CX
  CALL TestHostAndHandle            ;Test Host & Handle validity (Returns CX)
  JC  >T70                          ;If invalid, error
  CMP  CX,(TDEntries-1)             ;Is it too big?
  JA  >T10                          ;If so, see if it's a Bulk Queue
T05:                                ;Is a possible Transfer Descriptor
  CALL TDIndex2Offset               ;Convert it to an offset (ES:[DI])
  JMP >T15                          ;Continue
T10:                                ;Is a possible Bulk TD
  SUB  CX,(TDEntries-1)             ;Subtract out Bulk Queue Offset
  CMP  CX,BulkQHEntries             ;Is it too big?
  JA  >T70                          ;If so, error
  CALL QHIndex2Offset               ;Convert it to an Offset (ES:[DI])
  TEST ES:[DI].QHFlags,QHFlagInUse  ;Valid QH?
  JZ  >T70                          ;If not, error
  MOV  EAX,ES:[DI].QHElementPointer ;Get the Element (TD) Physical Address
  CALL PhysAddr2SegOffNoFlags       ;Convert it to an Offset (ES:[DI])
T15:                                ;ES:[DI] = Transfer Descriptor
  CALL GetTDType                    ;Get the TD Type
  CMP  AL,TDTypeReserved            ;  Legitimate Handle?
  JBE >T70                          ;If not, Error
  MOV  BP,I14RErrDeviceAddress      ;Assume incorrect Device Address
  CALL GetTDDeviceAddress           ;Get the Device Address
  CMP  AL,[SI].I14RDeviceAddress    ;Correct Device Address?
  JNE >T70                          ;If not, error
  MOV  BP,I14RErrEndPoint           ;Assume incorrect End Point
  CALL GetTDEndPoint                ;Get the End Point
  CMP  AL,[SI].I14REndPoint         ;Correct End Point?
  JNE >T70                          ;If not, error
T20:                                ;TD is Valid
  MOV  DS,ES                        ;DS = TSR Data Area
  CALL GetTDType                    ;Get the TD Type again
  MOV  BX,GetTStatusTbl             ;[BX] = Lookup Table
  CALL SearchByte2WordTblCS         ;Look up the code offset (assume no error)
  MOV  SI,BX                        ;SI = Code to Call
  XOR  BX,BX                        ;Initialize BX
  XOR  DX,DX                        ;  and DX
  CALL SI                           ;Do it (Returns BX, CX, DX)
  JMP >T80                          ;Done
T70:                                ;Error
  MOV  CX,FS                        ;Restore original CX
  STC                               ;Set error flag
  JMP >T90                          ;Done
T80:                                ;Worked OK
  CLC                               ;Return flag = OK
T90:                                ;Done
  POP  FS,DS,SI,DI,EAX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Input:    DS = ES = TSR Data Area
;         [DI] = Transfer Descriptor of Transaction to return status of
;                If Bulk, is First TD currently in QH
;                If Isoch, is first TD in Schedule
;                If Periodic w/ Queue, is ?????
;          BX = 0
;Output:   BX =
;               Flags: On Hold (Control TDs Only)
;          CX = Approx Deciseconds until Timeout (Bulk, Control)
;             = Frames until next Interrupt (Periodic Int)
;             = Frames until Isoch Schedule Restarts (Isoch)
;             = Frames until completion (One-time Int)
;          DX = Bytes not transferred yet (Bulk, Isoch)
;             = Bytes to be sent next time (Periodic Int)
;             = 0 (One-time Int)
;             = Bytes left in Data Stage (If no Data, always 0)
;                 (0 does NOT necessarily mean it's done)
;Changes:
;------------------------------------------------------------------------------

;------------------------------------------------------------------------------
;Return Status of Isochronous Transaction
;  BX = 0 (Never on Hold)
;  CX = Frames Left until Start of Schedule repeats
;  DX = Bytes Left until Start of Schedule repeats
;       If > 65535, just returns 65535
;------------------------------------------------------------------------------

 #IF !LITE

  IsochHighWord DW 0 ;High word of total bytes in Isochronous Transaction Status

TStsIsoch:
  PUSHF                        ;Save flags
  CLI                          ;Disable interrupts
  PUSH AX,DI,SI,BP             ;Save used registers
  MOV  IsochHighWord,0         ;Initialize High Word of Byte Count
  CALL GetFrameNumber          ;Get the Current Frame Number (AX)
  MOV  SI,AX                   ;SI = Current Frame Number
  MOV  BX,[DI].TDLastFrameUsed ;BX = Start of Schedule
  MOV  BP,BX                   ;BP =
  SUB  BP,[DI].TDPeriodicity   ;  Previous Beginning of Schedule
  JNC >I15                     ;If not Rolled Over, continue
I10:                           ;Previous End of Schedule is Rolled Over
  ADD  BP,(FLEntries*2)        ;BP = Adjusted Previous Beginning of Schedule
  CMP  SI,BP                   ;Are we in the Previous Schedule?
  JAE >I20                     ;If so, handle it
  CMP  SI,BX                   ;Are we in the Previous Schedule?
  JB  >I20                     ;If so, handle it
I15:                           ;Previous Beginning of Schedule not Rolled Over
  CMP  SI,BX                   ;Are we in the Previous Schedule?
  JAE >I25                     ;If not, continue
I20:                           ;We are in Previous Schedule
  MOV  BX,BP                   ;BX = Correct Beginning of Schedule
I25:                           ;BX = Correct Beginning of Schedule
  MOV  BP,BX                   ;BP =
  ADD  BP,[DI].TDPeriodicity   ;  End of Schedule
  CMP  SI,BX                   ;Is the Current Frame Rolled Over?
  JAE >I30                     ;If not, continue
  ADD  SI,(FLEntries*2)        ;If so, adjust it
I30:                           ;BX = Start, SI = Current, BP = End Frame
  MOV  AX,[DI].TDIsochHandle   ;BX = Handle to look for
  MOV  DI,TDOffset             ;[DI] = First TD
I35:                           ;Loop to here for each TD
  PUSH AX                      ;Save AX momentarily
  CALL GetTDType               ;Is it an
  CMP  AL,TDTypeIsoch          ;  Isochronous TD?
  POP  AX                      ;Restore AX
  JNE >I60                     ;If not, skip it
  CMP  AX,[DI].TDIsochHandle   ;If so, is it one of ours?
  JNE >I60                     ;If not, skip it
  MOV  CX,[DI].TDLastFrameUsed ;Get the Scheduled Frame
  CMP  BP,(FLEntries*2)        ;Is the end of the Schedule Rolled Over?
  JB  >I40                     ;If not, no need to adjust anything
  CMP  CX,BX                   ;Is it rolled over?
  JAE >I40                     ;If not, continue
  ADD  CX,(FLEntries*2)        ;If so, adjust it
I40:                           ;CX = Adjusted Scheduled Frame
  CMP  CX,BP                   ;Is it in the Schedule?
  JAE >I60                     ;If not, it's already happened
  CMP  CX,SI                   ;Has it already happened?
  JB  >I60                     ;If so, skip it
I50:                           ;Has not happened yet
  ADD  DX,[DI].TDBytesToXfer   ;Add bytes to the running total
  ADC  IsochHighWord,0         ;If overflow, add 1 to the high word count
I60:                           ;Done with this TD
  ADD  DI,TDSize               ;Point at the next TD
  CMP  DI,(TDOffset+(TDEntries*TDSize)) ;Tested all of the TD's yet?
  JB   I35                     ;If not, keep going
I90:                           ;DX (number of bytes) set correctly
  MOV  CX,BP                   ;CX = Number of Frames
  SUB  CX,SI                   ;  Left in Schedule
  MOV  BX,IsochHighWord        ;Set BX for the Return
  POP  BP,SI,DI,AX             ;Restore used registers
  POPF                         ;Restore flags
  RET

 #ENDIF

;------------------------------------------------------------------------------
;Return Status of Bulk Transaction
;  BX = 0 (Never on Hold)
;  CX = Approximate deciseconds left until Timeout
;  DX = Bytes left to send
;------------------------------------------------------------------------------
TStsBulk:
  PUSH EAX                    ;Save used registers
  MOV  EAX,[DI].TDBuffPointer ;DX =
  SUB  EAX,[DI].TDDataAddress ;  Number of
  MOV  DX,[DI].TDBytesToXfer  ;  Bytes Left
  SUB  DX,AX                  ;  to Transfer
  CALL GetTimeoutDS           ;Get the Timeout Remaining (CX)
  POP  EAX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Return Status of Bulk Transaction
;  BL = Hold/Stage/Retry Data
;         Low Nibble = Stage/Hold Data
;           0 = On Hold
;           1 = Setup Stage
;           2 = Data State
;           3 = Status Stage
;         High Nibble = Retries to be attempted if current one is unsuccessful
;  BH = 0
;  CX = Approximate deciseconds left until Timeout
;  DX = Bytes left to send in Data Stage
;------------------------------------------------------------------------------
TStsCtlSetup:
  TEST [DI].TDFlags,TDFlagOnHold ;Currently on Hold?
  JNZ >C00                       ;If so, leave BL = BH = 0
  MOV  BL,1                      ;If not, Stage = Setup
  JMP >C00                       ;Continue
TStsCtlData:
  MOV  BL,2                      ;Stage = Data
  JMP >C00                       ;Continue
TStsCtlStatus:
  MOV  BL,3                      ;Stage = Status
;  JMP >C00                       ;Continue
C00:                             ;Need to put Retry value in BL
  PUSH AX,DI                     ;Save used registers
  MOV  CL,[DI].TDTimeoutIndex    ;Get the
  CALL TTIndex2Offset            ;  Timeout
  MOV  AL,[DI].TTFlags           ;  Flags
  SHR  AL,5                      ;AL = Retry Counter
  OR   AL,AL                     ;Is it 0?
  JNZ >C10                       ;If not, it's OK
  MOV  AL,8                      ;If so, it's actually 8
C10:                             ;AL = Retry Counter
  DEC  AL                        ;Convert to Retries Left Value
  SHL  AL,4                      ;Move it over to use as a mask
  OR   BL,AL                     ;Mask it into BL
  POP  DI,AX                     ;Restore used registers
C20:                             ;BX contains correct data
  MOV  DX,[DI].TDBytesToXfer     ;DX = Number of Bytes
  SUB  DX,[DI].TDBytesXfered     ;  Left to Transfer
  CALL GetTimeoutDS              ;Get the Timeout Remaining (CX)
  RET

;------------------------------------------------------------------------------
;Return Status of Periodic Interrupt Transaction
;  BX = 0 if OK
;     = 0080h if OverDue
;  CX = Frames Left until Interrupt repeats
;  DX = Bytes Sent during each Interrupt
;------------------------------------------------------------------------------
TStsIntPer:
  MOV  DX,[DI].TDBytesToXfer ;DX = Number of Bytes to Transfer
  CALL GetTimeTilRpt         ;CX = Frames until next Repeat
  OR   CX,CX                 ;Is it 0 (start of Schedule)?
  JNZ >P90                   ;If not, continue
  MOV  CX,[DI].TDPeriodicity ;If so, make it the Period
P90:                         ;Done
  RET

;------------------------------------------------------------------------------
;Return Status of 1-Time Interrupt Transaction
;  BX = 0 if OK
;     = 0080h if OverDue
;  CX = Frames Left until Completion
;  DX = 0 (Never gets any bytes)
;------------------------------------------------------------------------------
TStsInt1T:
  CALL GetTimeTilRpt           ;Get the Time until the next repeat (CX)
  ADD  CX,W [DI].TDPeriodicity ;Add time left over after next Repeat
  RET

;------------------------------------------------------------------------------
;CALCULATE THE TIMEOUT LEFT IN A CONTROL OR BULK TRANSACTION
;Inputs:   DS = ES = TSR Data Area
;         [DI] = TD to get status of (Bulk or Control)
;Outputs:  CX = Timeout left (Deciseconds)
;Changes:
;NOTES: Timer Frequency = 1,193,180 MHz / 65536
;------------------------------------------------------------------------------
GetTimeoutDS:
  PUSH AX,DX,DI               ;save used registers
  MOV  CL,[DI].TDTimeOutIndex ;Get the
  CALL TTIndex2Offset         ;  Timer Ticks
  MOV  AX,[DI].TTDelayCounter ;  Left
  MOV  CX,5493                ;Convert
  MUL  CX                     ;  it
  MOV  CX,10000               ;  to
  DIV  CX                     ;  deciseconds
  CMP  DX,5000                ;Do we need to round up?
  JB  >T30                    ;If not, continue
  INC  AX                     ;If so, do it
T30:                          ;AX = Timeout Frames/Deciseconds
  MOV  CX,AX                  ;Put it in CX for the return
  POP  DI,DX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE TIME UNTIL THE NEXT REPEAT IN A PERIODIC OR ISOCH TD
;Inputs:   DS = ES = TSR Data Area
;         [DI] = TD to get status of (Isoch or Interrupt)
;          BL = 0
;Outputs:  CX = Frames until next repeat
;          BL = Bit 7 (80h) set if Value is Negative (TD is OVerDUe)
;          ZF = Set   if BL =  0  (not OverDue)
;             = Clear if BL = 80h (OverDue)
;Changes:
;;------------------------------------------------------------------------------
GetTimeTilRpt:
  PUSH AX               ;Save used registers
  CALL GetFrameNumber   ;Get the Frame Nubmer (AX)
  MOV  CX,[DI].TDLastFrameUsed ;CX = Next Scheduled Frame Number
  SUB  CX,AX            ;CX = Frames until next repeat
  JNC >R20              ;If no rollover, continue
  ADD  CX,(FLEntries*2) ;If rollover, adjust for it
R20:                    ;Frame Numbers are OK
  CMP  CX,FLEntries     ;Should CX be negative?
  JB  >R90              ;If not, we're done
  SUB  CX,(FLEntries*2) ;If so, calculate
  NEG  CX               ;  the absolute value
  OR   BL,80h           ;Mark it as Negative
R90:                    ;Done
  TEST BL,80h           ;Set return flag
  POP  AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST HOST INDEX AND REQUEST HANDLE FOR VALIDITY
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = Our TSR Data Area
;Outputs: CF = Clear if OK (Valid Host and Handle)
;              CX = Handle Number
;              BP = Undefined
;            = Set if Error
;              CX = Undefined
;              BP = Error Code
;Changes:
;NOTES: This only tests the Handle for the lower limit, not the upper limit,
;         because some routines that call this handle an upper limit
;         problem differently (it may not actually be an error)
;------------------------------------------------------------------------------
TestHostAndHandle:
  MOV  BP,I14RErrHostIndex              ;Assume bad Host Index
  CMP  [SI].I14RHostIndex,AllHostsIndex ;Is it for All Hosts?
  JE  >H70                              ;If so, Error
  MOV  BP,I14RErrRequestHandle          ;Assume Bad Handle
  MOV  CX,[SI].I14RRequestHandle        ;Get TD Index Number
  JMP >H80                              ;Done
H70:                                    ;Error
  STC                                   ;Set error flag
  JMP >H90                              ;Done
H80:                                    ;No error
  CLC                                   ;St OK flag
H90:                                    ;Done
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FOR THE ALL HOSTS INDEX (PROXY CALL TO ALL VALID HOSTS)
;Inputs:  DS:[SI] = Int 14 Request Structure
;         ES = TSR Data Area
;         AH = HostIndex (-1 or ours)
;Outputs: CF = Clear if Not All Hosts Index (original routine needs to do it)
;              BX = CX = DX = Unchanged (-1)
;            = Set if All Hosts Index (-1 / we did it)
;              BX = CX = DX = Unchanged (-1)
;Changes:
;------------------------------------------------------------------------------
DoAllHostsFunction:
  PUSH AX,BX,CX              ;Save used registers
  CMP  AH,AllHostsIndex      ;Is it an All Hosts Call?
  JNE >Z80                   ;If not, we're done
  MOV  AX,CS:[HostIndexes]   ;Get List of Valid Host Indexes
  XOR  BL,BL                 ;BL = Actual Host Index Number
  MOV  CX,MaxHosts           ;CX = Number of Hosts to check
Z10:                         ;Loop to here for each Host
  ROR  AX,1                  ;Is this a valid Host Index?
  JNC >Z40                   ;If not, skip it
  MOV  [SI].I14RHostIndex,BL ;If so, put Index in Request Structure
  CALL DoInt14CallSI         ;Do Call with Specific Host
Z40:                         ;Done with this Host
  INC  BL                    ;  next Host
  LOOP Z10                   ;Keep Going
  MOV  [SI].I14RHostIndex,AllHostsIndex ;Restore original Host Index
  STC                        ;Set Return Flag
  JMP >Z90                   ;Done
Z80:                         ;Not All Hosts Index
  CLC                        ;Set Return Flag
Z90:                         ;Done
  POP  CX,BX,AX              ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE FOR THE USB ROOT HUB
;THE ROOT HUB ACTUALLY WORKS VERY DIFFERENTLY THAN A REGULAR (REMOTE) HUB,
;  THOUGH WE WANT IT TO SIMULATE A REGULAR HUB.  THIS CODE DOES THAT.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE DEVICE CONNECTS/DISCONNECTS FROM THE ROOT HUB, AND RESUME DETECTS
;Inputs:  [NumRootHubPorts]
;         BX (UserPktID) = TSR Data Area
;Outputs:
;Changes: Issues appopriate interrupt requests if new devices are detected
;------------------------------------------------------------------------------
TestRootHubConns:
  CALL CopyBX2DSES          ;Point DS & ES at TSR Data Area
  CMP  [PauseCounter],0     ;Finished our Pausing yet?
  JE  >H10                  ;If so, start looking for Devices
  DEC  [PauseCounter]       ;If not, decrement the Pause Counter
  JMP >H90                  ;Done for now
H10:                        ;OK to continue
  TEST [TSRFlags],GettingRootPort ;Are we in the middle of something already?
  JNZ >H90                  ;If so, we're done
  MOV  BH,1                 ;Start with
  MOV  BL,PortSC1           ;  first Port
H30:                        ;Loop to here for each Port
  MOV  W [RHPortOffset],BX  ;Store Offset (BL) and Port Number (BH)
  CALL TestRootHubConn      ;Test the Port
  JNZ >H90                  ;If something's changed, we're done for now
  ADD  BL,(PortSC2-PortSC1) ;Point at the next Port
  INC  BH                   ;Increment the Port Index
  CMP  BH,[NumRootHubPorts] ;Have we done all the ports?
  JBE  H30                  ;If not, continue
H90:                        ;Done
  RETF

;------------------------------------------------------------------------------
;SEE IF A NEW DEVICE HAS BEEN ATTACHED/DETACHED TO THE ROOT HUB
;Inputs:  BL = Root Hub Port Pointer Offset (PortSC1 or PortSC2)
;              (also in [RHPortOffset])
;         BH = Root Hub Port Number (1-based)
;              (also in [RHPortNumber])
;         [PtConnLastTime]
;         DS = ES = TSR Data Area
;Outputs: ZF = Set if nothing has changed
;            = Clear if connect status has changed
;                Starts process of Resetting and Enumerating Device
;Changes: AX,CX,DI,SI,BP
;NOTE: On the new Dell Desktop, PtConnStatus gets changed when a new Device
;        is connected, but PtConnStatChg is never set.  Either there is
;        something wrong with the Host Controller or the Dell EHCI BIOS
;        software.
;      Whatever the problem (I suspect Dell), the bottom line is that
;        we can't trust the PtConnStatChg bit.  We'll have to keep track
;        of connect changes ourselves.
;------------------------------------------------------------------------------
TestRootHubConn:
  MOV  DI,OFFSET PtConnLastTime   ;[DI] = [PtConnLastTime]
  MOV  BP,[DI]                    ;Save original [PtConnLastTime]
  XOR  CX,CX                      ;CX =
  MOV  CL,BH                      ;  Port Number
  CALL ReadHostWord               ;Get current Port Status (AX)
  TEST AL,PtConnStatChg           ;Is there a change in Connect?
  JZ  >R20                        ;If not, test the other way
R10:                              ;Change in PtConnStatChg
  TEST AL,PtConnStatus            ;Is it A Conn or a Disconn?
  JZ  >R15                        ;If a Disconnect, handle it
R12:                              ;Connect
  BTS  W [DI],CX                  ;Mark as Connected next time
  JMP >R40                        ;Continue
R15:                              ;Disconnect
  BTR  W [DI],CX                  ;Mark as disconnected next time
  JMP >R40                        ;Continue
R20:                              ;No change in PtConnStatChg
  TEST AL,PtConnStatus            ;Device currently connected?
  JNZ >R25                        ;If so, handle it
R22:                              ;Device not currently connected
  BTR  W [DI],CX                  ;Test connect status, reset it
  JNC >R90                        ;If no connect last time, quit
  JMP >R40                        ;If it changed, handle it
R25:                              ;Device currently connected
  BTS  W [DI],CX                  ;Test connect status, set it
  JC  >R90                        ;If connect last time, quit
R40:                              ;There has been a Connect change
  AND  AL,(NOT PtPortEnable)      ;Make sure it's Disabled,
  OR   AL,PtConnStatChg           ;Reset Connect Change Status
  CALL WriteHostWord              ;  and Confirm the change
  TEST AL,PtConnStatus            ;Is a new Device Connected?
  JZ  >R60                        ;If not, Handle a Disconnect
  MOV  AL,1                       ;AL = Root Hub Address
  MOV  AH,BH                      ;AH = Port Number
  CALL HubAndPort2Addr            ;Does a Device already exist (AL)?
  JZ  >R50                        ;If not, continue
  MOV  SI,Int14Request            ;Point at Int 14 data structure
  MOV  [SI].I14RDeviceAddress,AL  ;Address of Device
  MOV  [SI].I14RRequestType,I14RRTResetDevice ;Request = Reset Device
  MOV  W [SI].I14RCallBackAddr[0],-1 ;No notification when done
  CALL DoInt14CallSI              ;Do it
  JMP >R90                        ;We're done
R50:                              ;New device is connected
  OR   [TSRFlags],GettingRootPort ;Mark us as in progress
  MOV  AX,250                     ;Delay 250ms
  MOV  SI,OFFSET RHResetWait      ;Code to call when Delay is over
  CALL StartOneTimeIntSI          ;Do it
  JNC >R90                        ;If it worked, we're done
  MOV  [DI],BP                    ;If it didn't work, restore original Status
  AND  [TSRFlags],(NOT GettingRootPort) ;Mark as not in progress
  JMP >R90                        ;We're done
R60:                              ;Device has been disconnected
  MOV  SI,Int14Request            ;Point at Int 14 data structure
  MOV  [SI].I14RDeviceAddress,1   ;Root Hub = Address 1
  MOV  [SI].I14RHubPort,BH        ;Hub Port Number
  MOV  [SI].I14RRequestType,I14RRTDvcDisc ;Request = Device Disconnect
  CALL DoInt14CallSI              ;Do it
R90:                              ;Done
  TEST [TSRFlags],GettingRootPort ;Set the return flag
  RET

;------------------------------------------------------------------------------
;Inputs:  BX (UserPktID) = TSR Data Segment
;         [RHPortOffset], [RHPortNumber]
;------------------------------------------------------------------------------
RHResetWait:
  CALL SetupRootHubFarCall                   ;Set DS = ES = TSR Data Segment
                                             ;  BL = Port Ofst, BH = Port Num
                                             ;  AX = Port Data (ReadHostWord)
  CALL WriteHostWord                         ;Confirm Connect Status change
  CALL ReadHostWord                          ;Read the Status again
  TEST AL,PtConnStatus                       ;Is the Device still Connected?
  JZ  >W70                                   ;If not, we're done
  MOV  SI,Int14Request                       ;Point at Request Structure
  XOR  AL,AL                                 ;Reset Flags
  TEST AH,(PtLowSpeed SHR 8)                 ;Is the Device Low Speed?
  JZ  >W30                                   ;If not, it's OK
  OR   AL,I14RFlagLowSpeed                   ;Set Low Speed flag
W30:                                         ;Have speed accounted for
  MOV  [SI].I14RFlags,AL                     ;Store Flags
  MOV  [SI].I14RDeviceAddress,1              ;Root Hub = Address 1
  MOV  [SI].I14RHubPort,BH                   ;Hub Port Number
  MOV  [SI].I14RRequestType,I14RRTNewDvcConn ;Request = Device Connect
  MOV  W [SI].I14RCallBackAddr[0],RHDvcReady ;Code to Call when done
  CALL DoInt14CallAXSI                       ;Do it
  JNC >W90                                   ;If Host is not busy, we're done
  CMP  AX,I14RErrHostCallInUse               ;If error, is it already resetting?
  JE  >W90                                   ;If so, it's OK
W60:                                         ;Error (Host is Busy)
  MOV  AX,20                                 ;Delay 20ms
  MOV  SI,OFFSET RHResetWait                 ;What to do when Delay is over
  CALL StartOneTimeIntSI                     ;Do it
  JNC >W90                                   ;If it worked, we're done
  MOV  AX,SI                                 ;AX = Where to go when done
  MOV  CL,1                                  ;Delay for 1 timer tick (0-55 ms)
  CALL ScheduleInt08Delay                    ;Do it
  ;Theoretically, both the One Time Int and the Int 08 Delay could not work,
  ;  though that is extremely unlikely.  We'll just assume that at least
  ;  one of them will work.  If they don't, this Device will never enumerate!
  JMP >W90                                   ;Done
W70:                                         ;Completely Done
  AND  [TSRFlags],(NOT GettingRootPort)      ;Mark us as done
W90:                                         ;Done
  RETF

;------------------------------------------------------------------------------
;HANDLE A NEW DEVICE AFTER THE HOST HAS QUEUED THE RESET REQUEST
;Inputs:  BX (UserPktID) = TSR Data Segment
;         [RHPortOffset], [RHPortNumber]
;         CL = New Address
;         CH = Max Power (2mA Units)
;Outputs:
;Changes:
;NOTE: Everything we care about is already stored in the Device Address
;        Table, so we don't actually need to do anything here.
;        This call is intended more for a "real" (remote) hub,
;        which needs to keep track of addresses and power requirements
;        of the devices it is "hosting".
;------------------------------------------------------------------------------
RHDvcReady:
  CALL CopyBX2DSES                      ;Point DS & ES at TSR Data Area
  AND  [TSRFlags],(NOT GettingRootPort) ;Mark us as done
  RETF

;------------------------------------------------------------------------------
;SET UP REGISTERS (PARTICULARLY SEGMENTS) FOR VARIOUS FAR CALL CODE SEGMENTS
;Inputs:  BX (UserPktID) = TSR Data Segment
;         Possibly also a ByteWord variable to put in BX
;           (depending on exact call)
;Outputs: DS, ES
;         Possibly AL,AX, BL/BX (Depending on exact Call)
;Changes:
;NOTE:  Because any particular computer can have more than one UHCI Host,
;         we allow multiple instances of this program in memory.
;       Because we want to be as efficient with memory use as possible,
;         and because this program has quite a bit of code, each instance
;         of the program in memory will re-use the exact same Code.  That is,
;         the Program code will only get installed by the first instance
;         of the Program in memory, but the majority of the Data will be
;         unique to each instance.
;       If the Code is entered from an Interrupt Call, it's not a problem
;         to get the Code and Data Segments set correctly.  However, the Code
;         is somewhat recursive, and wome of the Code calls for us to
;         schedule something to happen on the USB bus, and then "wait"
;         in the background for the USB Bus to do it.  There can be many of
;         these background tasks going on on the bus at teh same time, on
;         many different Hosts, all using the exact same Code.  So, no matter
;         which Host is responsible for issuing the original call, the exact
;         same code will get called.  Knowing which Data Segment to use
;         (determining which USB Host was actualyl responsible for the call)
;         will be controlled by the UserPktID Word, which is returned
;         by the USB Software in BX.
;       So, in a Far Call, the first thing we need to do is to set up the
;         correct Data Segment, by simply copying BX to DS & ES.
;------------------------------------------------------------------------------
SetupRootHubFarCall: ;Do at beginning of every Root-Hub New Device Code Seg
  CALL CopyBX2DSES         ;Set up DS & ES
  MOV  BX,W [RHPortOffset] ;BL = Port Offset, BH = Port Number
  CALL ReadHostWord        ;AX = Value from Port
  RET

;NOTE: This does NOT change the Flags!
CopyBX2DSESLastAddrSIDI:
  CALL CopyBX2DSES            ;DS = ES = TSR Data Area
  MOV  SI,[LastAddressOffset] ;[SI] = Address Table Entry
  MOV  DI,Int14Request2       ;[DI] = Int14Request2 (for Enumerations)
  RET

CopyBX2DSES:
  MOV  DS,BX ;Copy BX (UsrPktID) to
  MOV  ES,BX ;  DS and ES
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE FOR CALLS TO THE ROOT HUB TO DO SOMETHING TO A DEVICE
;  (ENABLE,  DISABLE,  RESET, ETC.)
;THESE CALLS ARE THE SAME ONES THAT GO TO A REGULAR HUB, BUT WE HANDLE THEM
;  DIFFERENTLY SINCE WE CONTROL THE ROOT HUB THROUGH I/O ADDRESS SPACE
;  (A REGULAR HUB ACTUALLY NEEDS TO BE SENT A CONTROL PACKET ON THE USB BUS)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE A NOTIFICATION FROM THE HOST DRIVER FOR THE ROOT HUB
;Inputs:  AX = Device Owner Call Code (various possibilities)
;         BX = User Packet ID we told host about (Data Segment)
;         CL = Hub Address (1 in our case, but we don't care)
;         CH = Hub Port Number
;         DL = USB Host Index
;         DH = Hub Request Handle Number (if DvcEnumerated, New Address)
;Outputs:
;Changes: Various Registers
;------------------------------------------------------------------------------
RootHubOwnerCall:
  CALL CopyBX2DSES          ;Point DS & ES at TSR Data Area
  MOV  BX,RootHubCallTbl    ;Point at Code Translation Table
  CALL SearchByte2WordTblCS ;Look for our code in the Table
  JC  >O90                  ;If Error, Quit
  CALL BX                   ;If OK, do it
O90:                        ;Done
  RETF

;------------------------------------------------------------------------------
;HANDLE A REQUEST FOR AN ENUMERATED DEVICE ON THE ROOT HUB
;Inputs:  CL = Hub Address (1)
;         CH = Hub Port Number (1-based)
;         DL = Host Index
;         DH = New Device Address
;         DS = ES = TSR Data Area
;Outputs:
;Changes:
;------------------------------------------------------------------------------
RootHubDvcEnumerated:
  ;For Root Hub, everything is already stored!
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO ENABLE A DEVICE ON THE ROOT HUB
;Inputs:  CH = Hub Port Number (1-based)
;         DX = Hub Request Handle Number
;         DS = ES = TSR Data Area
;Outputs:
;Changes: Various Registers
;------------------------------------------------------------------------------
RootHubEnableDvc:
  CALL RHPort2IOPort   ;Convert Hub Port to I/O Offset (returns BL)
  CALL ReadHostWord    ;Get current status
  TEST AL,PtPortEnable ;Already Enabled?
  JNZ >E80             ;If so, we're done
  OR   AL,PtPortEnable ;Enable
  CALL WriteHostWord   ;  the Port
  CALL ReadHostWord    ;Get Status back again
  CALL WriteHostWord   ;Confirm the Enable change
E80:                   ;OK
  CALL FinishHubCallOK ;Inform the Host that we're done
E90:                   ;Done
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO DISABLE A DEVICE ON THE ROOT HUB
;Inputs:  CH = Hub Port Number (1-based)
;         DX = Hub Request Handle Number
;         DS = ES = TSR Data Area
;Outputs:
;Changes: Various Registers
;------------------------------------------------------------------------------
RootHubDisableDvc:
  CALL RHPort2IOPort         ;Convert Hub Port to I/O Offset (returns BL)
  CALL ReadHostWord          ;Get the Current Status
  TEST AL,PtPortEnable       ;Already Disabled?
  JZ  >D80                   ;If so, we're done
  AND  AL,(NOT PtPortEnable) ;Disable
  CALL WriteHostWord         ;  the Port
  CALL ReadHostWord          ;Get Status back again
  CALL WriteHostWord         ;Confirm the Enable change
D80:                         ;OK
  CALL FinishHubCallOK       ;Inform the Host that we're done
D90:                         ;Done
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO RESUME (UN-SUSPEND) A DEVICE ON THE ROOT HUB
;Inputs:  CH = Hub Port Number (1-based)
;         DX = Hub Request Handle Number
;         DS = ES = TSR Data Area
;Outputs:
;Changes: Various Registers
;NOTES: Another section of code periodically polls the Root Hub for the
;         Resume Detect signal, and automatically shuts it off after
;         a short delay.  Therefore, we do not need to worry about
;         shutting it off here.
;------------------------------------------------------------------------------
RootHubResumeDvc:
  CALL RHPort2IOPort        ;Convert Hub Port to I/O Offset (returns BL)
  CALL ReadHostWord         ;Get the current Port Data
  TEST AL,PtResumeDetect    ;Is it already Resuming?
  JNZ >R70                  ;If so, Error
  TEST AH,(PtSuspend SHR 8) ;Is the Device currently Suspended?
  JZ  >R70                  ;If not, Error
  OR   AL,PtResumeDetect    ;If so, send a
  CALL WriteHostWord        ;  Resume Signal
  CALL FinishHubCallOK      ;If so, it's OK
  JMP >R90                  ;Done
R70:                        ;Error
  CALL FinishHubCallErr     ;Inform the Host that we're done
R90:                        ;Done
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO SUSPEND A DEVICE ON THE ROOT HUB
;Inputs:  CH = Hub Port Number (1-based)
;         DX = Hub Request Handle Number
;         DS = ES = TSR Data Area
;Outputs:
;Changes: Various Registers
;------------------------------------------------------------------------------
RootHubSuspendDvc:
  CALL RHPort2IOPort        ;Convert Hub Port to I/O Offset (returns BL)
  CALL ReadHostWord         ;Get the Port Status
  TEST AL,PtPortEnable      ;Is the Port even Enabled?
  JZ  >S70                  ;If not, Error
  TEST AH,(PtSuspend SHR 8) ;Is it already Suspended?
  JNZ >S80                  ;If so, we're done
  OR   AH,(PtSuspend SHR 8) ;Suspend
  CALL WriteHostWord        ;  it
  JMP >S80                  ;Done
S70:                        ;Error
  CALL FinishHubCallErr     ;Inform the Host that we're done
  JMP >S90                  ;Done
S80:                        ;OK
  CALL FinishHubCallOK      ;Inform the Host that we're done
S90:                        ;Done
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO RESET A DEVICE ON THE ROOT HUB
;Inputs:  CH = Hub Port Number (1-based)
;         DX = Hub Request Handle Number
;         DS = ES = TSR Data Area
;Outputs:
;Changes: Various Registers
;------------------------------------------------------------------------------
RootHubResetDvc:
  CALL RHPort2IOPort             ;Convert Hub Port to I/O Offset (returns BL)
  CALL ReadHostWord              ;Get the current Port Data
  TEST AH,(PtPortReset SHR 8)    ;Is it already being Reset?
  JNZ >R70                       ;If so, Error
  AND  AL,(NOT PtPortEnable)     ;Disable the
  CALL WriteHostWord             ;  Port
  CALL Delay100US                ;Wait for 100æs
  CALL ReadHostWord              ;Get Status back again
  TEST AL,PtPortEnable           ;Is the Port Disabled?
  JNZ >R70                       ;If not, Error
  OR   AH,(PtPortReset SHR 8)    ;Send a Reset Signal
  CALL WriteHostWord             ;  to the Port
  CMP  CH,2                      ;Is it Port 2?
  JE  >R20                       ;If so, jump to handle it
R10:                             ;It's Port 1
  MOV  [HubResetPort1Handle],DX  ;It's
  MOV  AX,HubResetDvcWaitPort1   ;  Port 1
  JMP >R30                       ;Continue
R20:                             ;Have Port stuff set up
  MOV  [HubResetPort2Handle],DX  ;It's
  MOV  AX,HubResetDvcWaitPort2   ;  Port 2
R30:                             ;Port Values are Set
  CALL ScheduleInt08Dly2         ;Schedule 2 Timer Tick Delay (55-110ms)
  JMP >R90                       ;Done
R70:                             ;Error
  CALL FinishHubCallErr          ;Inform the Host that we're done
R90:                             ;Done
  RET

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;        [HubResetPort1Handle] or [HubResetPort2Handle]
;------------------------------------------------------------------------------
HubResetDvcWaitPort1:
  CALL CopyBX2DSES                  ;Point DS & ES at correct Data Area
  MOV  CH,1                         ;Port Number 1
  MOV  DX,[HubResetPort1Handle]     ;Handle Number for Port 1
  MOV  SI,HubReset1Done             ;Code to call when we're done
  JMP >W00                          ;Do it
HubResetDvcWaitPort2:
  CALL CopyBX2DSES                  ;Point DS & ES at correct Data Area
  MOV  CH,2                         ;Port Number 2
  MOV  DX,[HubResetPort2Handle]     ;Handle Number for Port 2
  MOV  SI,HubReset2Done             ;Code to call when we're done
  JMP >W00                          ;Do it
W00:                                ;Handle a Port Reset after the Wait
  CALL RHPort2IOPort                ;Convert Hub Port to I/O Offset (BL)
  CALL ReadHostWord                 ;Get the current Port Data
  AND  AH,((NOT PtPortReset) SHR 8) ;Turn off
  CALL WriteHostWord                ;  the Reset Signal
  CALL Delay100US                   ;Wait for 100æs
  CALL ReadHostWord                 ;Has it
  TEST AH,(PtPortReset SHR 8)       ;  stopped Resetting?
  JNZ >W70                          ;If not, Error
  TEST AL,PtConnStatus              ;Device still connected?
  JZ  >W70                          ;If not, Error
  OR   AL,PtPortEnable              ;Enable
  CALL WriteHostWord                ;  the Port
  CALL Delay100US                   ;Wait for 100æs
  CALL ReadHostWord                 ;Is the
  TEST AL,PtPortEnable              ;  Port Enabled?
  JZ  >W70                          ;If not, Error
  MOV  AX,10                        ;If OK, we need to wait for 10ms
                                    ;SI contains Code to Call when Done
  CALL StartOneTimeIntSI            ;Do it
  JNC >W90                          ;If it worked, we're done
W70:                                ;Error
  CALL FinishHubCallErr             ;Inform the Host that we're done
W90:                                ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: BX = TSR Data Area to use
;        [HubResetPort1Handle] or [HubResetPort2Handle]
;------------------------------------------------------------------------------
HubReset1Done:
  CALL CopyBX2DSES              ;Point DS & ES at correct Data Area
  MOV  DX,[HubResetPort1Handle] ;Handle Number for Port 1
  JMP >D00                      ;Do it
HubReset2Done:
  CALL CopyBX2DSES              ;Point DS & ES at correct Data Area
  MOV  DX,[HubResetPort2Handle] ;Handle Number for Port 1
;  JMP >D00                      ;Do it
D00:
  CALL FinishHubCallOK          ;Tell Host that we're Done
  RETF

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO POWER ON/OFF/RESET A DEVICE ON THE ROOT HUB
;Inputs:  CH = Hub Port Number (1-based)
;         DX = Hub Request Handle Number
;         DS = ES = TSR Data Area
;Outputs: Returns Error!
;Changes:
;NOTES: In UHCI, Root Hubs have no control over power (it's always on).
;       The Host Driver keeps track of whether or not a Hub is capable
;         of controlling Power on a particular port, and would NEVER even
;         try to tell the Root Hub to try and control the Power, so this
;         code should never get called.  We'll put it in anyway, and
;         just return an error if it does.
;------------------------------------------------------------------------------
RootHubPowerOnDvc:
RootHubPowerOffDvc:
RootHubPowerResetDvc:
  CALL FinishHubCallErr ;Tell the Host that we're done
  RET

;------------------------------------------------------------------------------
;FINISH UP A ROOT HUB CALL (TELL HOST DRIVER THAT IT IS COMPLETED)
;Inputs:  DX = Handle Number to return
;Outputs: Informs Host Driver that the Hub Call is Complete
;Changes:
;------------------------------------------------------------------------------
FinishHubCallOK:
  PUSH AX                             ;Save used registers
  XOR  AX,AX                          ;Error Code = 0
  JMP >F00                            ;Do it
FinishHubCallErr:
  PUSH AX                             ;Save used registers
  MOV  AX,TDStsLargeCallErr           ;Error Code = Hub Call Problem
;  JMP >F00                            ;Do it
F00:
  PUSH SI                             ;Save used registers
  MOV  SI,Int14Request5               ;Point at Request Structure
  MOV  [SI].I14RRequestType,I14RRTLargeCallDone ;Request Type = Large Call Done
  MOV  [SI].I14RRequestHandle,DX      ;Store the Handle Number
  MOV  W [SI].I14RLargeCallRtnCode,AX ;Return Code = AX
  CALL DoInt14CallSI                  ;Tell the Host we're done
  POP  SI                             ;Restore used registers
  POP  AX                             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A ROOT HUB PORT NUMBER TO AN I/O OFFSET
;Inputs:  CH = Root Hub Port Number to Convert
;Outputs: BL = PortSCx I/O Offset (needed for ReadHostWord/WriteHostWord)
;Changes:
;------------------------------------------------------------------------------
RHPort2IOPort:
  PUSH CX  ;Save used registers
  MOV  BL,(PortSC1-(PortSC2-PortSC1)) ;Start with Port 1 Offset
P10:       ;Loop to here to find correct Port
  ADD  BL,(PortSC2-PortSC1) ;Point at next port
  DEC  CH  ;Decrement the counter
  JNZ  P10 ;If not 0 yet, keep adding
P90:       ;Done
  POP  CX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SCHEDULE A DELAY USING INT 08, CALLING BACK USER WHEN DONE
;Inputs:  ES = TSR Data Area
;              will be put in User Packet ID
;         AX = Call Back Address Offset to use (CS will be the Segment)
;         CL = Delay (in timer ticks)
;         [FirstInstanceSeg] (where Int08 Table is located)
;Outputs: CF = Clear if OK
;              Delay is Scheduled using Int 08
;            = Set if error (Table Full or Invalid Value)
;Changes:
;------------------------------------------------------------------------------
ScheduleInt08Dly2:
  PUSH CX   ;Save used registers
  MOV  CL,2 ;Delay for 2 timer ticks (55-110 mS)
  CALL ScheduleInt08Delay ;Do it
  POP  CX   ;Restore used registers
  RET

ScheduleInt08Delay:
  PUSH SI,DS                       ;Save used registers
  PUSHF                            ;Save Flags
  MOV  DS,ES:[FirstInstanceSeg]    ;Point DS at correct Data Area
  OR   AX,AX                       ;Valid Call Back Address?
  JZ  >S70                         ;If not, error
  MOV  SI,I8Table                  ;Table Pointer
  CLI                              ;Disable Interrupts
S10:                               ;Loop to here to find empty Table Entry
  TEST [SI].I8Flags,I8FlagInUse    ;This one already being used?
  JNZ >S40                         ;If so, skip it
  MOV  [SI].I8Delay,CL             ;Fill the
  MOV  [SI].I8UserPktID,ES         ;  Table Entry
  MOV  W [SI].I8CallBackAddr[0],AX ;  with
  MOV  W [SI].I8CallBackAddr[2],CS ;  Data
  MOV  [SI].I8Flags,I8FlagInUse    ;Mark it as In Use
  JMP >S80                         ;Done
S40:                               ;Go to next one
  ADD  SI,I8Size                   ;If not, point at the next table entry
  CMP  SI,(I8Table+(I8Entries*I8Size)) ;At the end of the table?
  JB   S10                         ;If not, keep looking
S70:                               ;Error
  POPF                             ;Restore Flags
  STC                              ;Set error flag
  JMP >S90                         ;Done
S80:                               ;OK
  POPF                             ;Restore Flags
  CLC                              ;Set OK flag
S90:                               ;Done
  POP  DS,SI                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE AN INT 14 CALL TO THE USB HOST (DS:[DI] = REQUEST STRUCTURE)
;Inputs:  DS:[DI] = Int14 Request Structure (filled with appropriate data)
;Outputs: CF = Set if error (host stalled, etc.)
;            = Clear if OK
;Changes: Sends the appropriate info to the USB Host via Int 14 call
;------------------------------------------------------------------------------
DoInt14CallDI:
  PUSH DX          ;Save used registers
  MOV  DX,DI       ;Point DX at Request Structure
  CALL DoInt14Call ;Do it
  POP  DX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE AN INT 14 CALL TO THE USB HOST (DS:[SI] = REQUEST STRUCTURE)
;Inputs:  DS:[SI] = Int14 Request Structure (filled with appropriate data)
;Outputs: CF = Set if error (host stalled, etc.)
;            = Clear if OK
;Changes: Sends the appropriate info to the USB Host via Int 14 call
;------------------------------------------------------------------------------
DoInt14CallSI:
  PUSH DX          ;Save used registers
  MOV  DX,SI       ;Point DX at Request Structure
  CALL DoInt14Call ;Do it
  POP  DX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE AN INT 14 CALL TO THE USB HOST (DS:[DX] = REQUEST STRUCTURE)
;Inputs:  DS:[DX] = Int14 Request Structure (filled with appropriate data)
;Outputs: CF = Set if error (host stalled, etc.)
;            = Clear if OK
;Changes: Sends the appropriate info to the USB Host via Int 14 call
;------------------------------------------------------------------------------
DoInt14Call:
  PUSH AX,BX,CX,DX   ;Save used registers
  CALL DoInt14CallDX ;Do it
  POP  DX,CX,BX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE AN INT 14 CALL TO THE USB HOST (DS:[SI] = REQUEST STRUCTURE), RETURN AX
;Inputs:  DS:[SI] = Int14 Request Structure (filled with appropriate data)
;Outputs: CF = Set if error (host stalled, etc.)
;            = Clear if OK
;         AX
;Changes: Sends the appropriate info to the USB Host via Int 14 call
;------------------------------------------------------------------------------
DoInt14CallAXSI:
  PUSH BX,CX,DX      ;Save used registers
  MOV  DX,SI         ;Point DX at Data
  CALL DoInt14CallDX ;Do it
  POP  DX,CX,BX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE AN INT 14 CALL TO THE USB HOST (DS:[SI] = REQUEST STRUCTURE), RETURN BX
;Inputs:  DS:[SI] = Int14 Request Structure (filled with appropriate data)
;Outputs: CF = Set if error (host stalled, etc.)
;            = Clear if OK
;         BX
;Changes: Sends the appropriate info to the USB Host via Int 14 call
;------------------------------------------------------------------------------
DoInt14CallBXSI:
  PUSH AX,CX,DX      ;Save used registers
  MOV  DX,SI         ;Point DX at Data
  CALL DoInt14CallDX ;Do it
  POP  DX,CX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE AN INT 14 CALL TO THE USB HOST (DS:[DI] = REQUEST STRUCTURE), RETURN AX
;Inputs:  DS:[DI] = Int14 Request Structure (filled with appropriate data)
;Outputs: CF = Set if error (host stalled, etc.)
;            = Clear if OK
;         AX
;Changes: Sends the appropriate info to the USB Host via Int 14 call
;------------------------------------------------------------------------------
DoInt14CallAXDI:
  PUSH BX,CX,DX      ;Save used registers
  MOV  DX,DI         ;Point DX at Data
  CALL DoInt14CallDX ;Do it
  POP  DX,CX,BX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE AN INT 14 CALL TO THE USB HOST (DS:[DI] = REQUEST STRUCTURE), RETURN BX
;Inputs:  DS:[DI] = Int14 Request Structure (filled with appropriate data)
;Outputs: CF = Set if error (host stalled, etc.)
;            = Clear if OK
;         AX
;Changes: Sends the appropriate info to the USB Host via Int 14 call
;------------------------------------------------------------------------------
DoInt14CallBXDI:
  PUSH AX,CX,DX      ;Save used registers
  MOV  DX,DI         ;Point DX at Data
  CALL DoInt14CallDX ;Do it
  POP  DX,CX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE AN INT 14 CALL TO THE USB HOST (DS:[DI] = REQUEST STRUCTURE), RETURN CX
;Inputs:  DS:[DI] = Int14 Request Structure (filled with appropriate data)
;Outputs: CF = Set if error (host stalled, etc.)
;            = Clear if OK
;         CX
;Changes: Sends the appropriate info to the USB Host via Int 14 call
;------------------------------------------------------------------------------
DoInt14CallCXDI:
  PUSH AX,BX,DX      ;Save used registers
  MOV  DX,DI         ;Point DX at Data
  CALL DoInt14CallDX ;Do it
  POP  DX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE AN INT 14 CALL TO THE USB HOST (DS:[DI] = REQUEST STRUCTURE), RETURN DX
;Inputs:  DS:[DI] = Int14 Request Structure (filled with appropriate data)
;Outputs: CF = Set if error (host stalled, etc.)
;            = Clear if OK
;         CX
;Changes: Sends the appropriate info to the USB Host via Int 14 call
;------------------------------------------------------------------------------
DoInt14CallDXDI:
  PUSH AX,BX,CX      ;Save used registers
  MOV  DX,DI         ;Point DX at Data
  CALL DoInt14CallDX ;Do it
  POP  CX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE AN INT 14 CALL TO THE USB HOST (DS:[SI] = REQUEST STRUCTURE), RTN CX, DX
;Inputs:  DS:[SI] = Int14 Request Structure (filled with appropriate data)
;Outputs: CF = Set if error (host stalled, etc.)
;            = Clear if OK
;         CX, DX
;Changes: Sends the appropriate info to the USB Host via Int 14 call
;------------------------------------------------------------------------------
DoInt14CallCXDXSI:
  PUSH AX,BX         ;Save used registers
  MOV  DX,SI         ;Point DX at Data
  CALL DoInt14CallDX ;Do it
  POP  BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs:  DS:[DX] = Data Structure to use
;Outputs:
;Changes: AX, BX, CX, DX
;------------------------------------------------------------------------------
DoInt14CallDX:
  MOV  AX,5001h ;Set Function Number
  MOV  BX,'US'  ;Set
  MOV  CX,'B!'  ;  registers
  STC           ;Preset Error Flag
  INT  14h      ;Do it
  RET

;------------------------------------------------------------------------------
;ISSUE A ONE-TIME DELAY REQUEST, OR A "FAKE" PERIODIC REQ TO THE USB HOST
;Inputs:  AX = Number of milliseconds to Delay or Periodic Rate
;         SI = Far Call Back Address for USB Host to call when done
;              (note that this is SI, NOT [SI]!!)
;              Code Segment is already in Int 14 Request ([FirstInstanceSeg])
;Outputs: CF = Set if error of some sort (like Host not running)
;              AX = Error Code
;            = Clear if OK
;                Sends appropriate Request to the USB Host, which in turn
;                issue Far Call(s) to address DS:[SI] when the Delay(s) are over
;              AX = 0
;Changes: Int14Request
;NOTES: StartFakePeriodicInt is only called from InitRootHub, which means it
;         does not actually need to be in the TSR portion of the program.
;         We'll leave it here for convenience sake anyway.
;------------------------------------------------------------------------------
StartOneTimeIntDI:
  PUSH SI    ;Save used registers
  MOV  SI,DI ;Put DI into SI where we need it
  CALL StartOneTimeIntSI ;Do it
  POP  SI    ;Restore sued registers
  RET

StartOneTimeIntSI:
  PUSH DI              ;Save used registers
  MOV  DI,Int14Request ;Point at Request Structure
  MOV  [DI].I14RRequestType,I14RRTDoInterrupt1T ;Type = 1 Time Interrupt
  JMP >S00             ;Jump to finish it

StartFakePeriodicInt:
  PUSH DI                       ;Save used registers
  MOV  DI,Int14Request          ;Point at Request Structure
  MOV  [DI].I14RRequestType,I14RRTDoInterruptPer ;Type = Periodic Interrupt
  MOV  [DI].I14RDeviceAddress,1 ;Address
  MOV  [DI].I14REndPoint,0      ;EndPoint
  MOV  [DI].I14RDataSize,0      ;Transfer 0 bytes
;  JMP  >S00                     ;Jump to finish it

S00:
  MOV  [DI].I14RFlags,I14RFlagIn     ;Direction = In
                                     ;  Addresses are Segment:Offset
  MOV  [DI].I14RPeriodicity,AX       ;Periodicity = Delay Factor
  MOV  W [DI].I14RCallBackAddr[0],SI ;  Address
  CALL DoInt14CallAXDI               ;Send it
  POP  DI                            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE TYPE OF TRANSFER DESCRIPTOR THAT A TD IS
;Inputs:  ES:[DI] = TD to get the Type of
;Outputs: AL = TD Type (TDTypeAvailable, TDTypeReserved, ...)
;Changes:
;------------------------------------------------------------------------------
GetTDType:
  MOV  AL,ES:[DI].TDFlags ;Get the flags
  AND  AL,TDTypeMask      ;Mask out everything except the TDType
  RET

;------------------------------------------------------------------------------
;SET THE TYPE OF TRANSFER DESCRIPTOR THAT A TD IS
;Inputs:  ES:[DI] = TD to set the Type of
;         AL = TD Type to set it to (TDTypeAvailable, TDTypeReserved, ...)
;Outputs:
;Changes: TDType of this particular TD
;------------------------------------------------------------------------------
SetTDType:
  PUSH AX                               ;Save used registers
  AND  AL,TDTypeMask                    ;Mask out everything except TD Type
  AND  ES:[DI].TDFlags,(NOT TDTypeMask) ;Set the
  OR   ES:[DI].TDFlags,AL               ;  TD Type
  POP  AX                               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE MAXIMUM PACKET SIZE FOR AN ENDPOINT, GIVEN THE ADDRESS & ENDPOINT #
;Inputs:  ES = TSR Data Area
;         ES:[DI] = TD Entry (if GetEPMaxPktSizeTD)
;      or DS:[SI] = Int 14 Structure (if GetEPMaxPktSizeI14)
;Outputs: ZF = Clear if OK (Valid Address & EndPoint)
;              CX = Max Packet Size (obtained from original Descriptors)
;            = Set if Error
;              CX = 0
;Changes:
;NOTES: We simply return a size of 1023 for Isoch.  That should not
;         cause any problems.  For all other TD types, we will return the
;         Actual Max Data Size.
;------------------------------------------------------------------------------
GetEPMaxPktSizeTD:
  PUSH AX,DX              ;Save used registers
  XOR  DX,DX              ;Assume not Isochronous
  CALL GetTDType          ;Is it
  CMP  AL,TDTypeIsoch     ;  Isochronous?
  JNE >T00                ;If not, continue
  MOV  DX,1023            ;Set Isochronous size
T00:
  CALL GetTDEndPoint      ;AH =
  MOV  AH,AL              ;  End Point Number
  OR   AH,AH              ;End Point 0?
  JZ  >T01                ;If so, don't set direction
  TEST ES:[DI].TDFlags,TDFlagIn ;Is it In?
  JZ  >T01                ;If not, continue
  OR   AH,80h             ;If so, mark it as In
T01:                      ;Direction flags masked in, if appropriate
  CALL GetTDDeviceAddress ;AL = Device Address
  JMP >G00                ;Do it

GetEPMaxPktSizeI14:
  PUSH AX,DX                       ;Save used registers
  XOR  DX,DX                       ;Assume not Isochronous
  CMP  [SI].I14RRequestType,I14RRTDoIsoch ;Is it Isoch?
  JNE >F00                         ;If not, continue
  MOV  DX,1023                     ;Set Isochronous size
F00:
  MOV  AX,W [SI].I14RDeviceAddress ;AL = Device Address, AH = End Point
  AND  AH,(NOT 80h)                ;Mask out the Direction, if there
  OR   AH,AH                       ;End Point 0?
  JZ  >G00                         ;If so, don't set direction flag
  TEST [SI].I14RFlags,I14RFlagIn   ;Is it In?
  JZ  >G00                         ;If not, continue
  OR   AH,80h                      ;If so, mark it as In
;  JMP >G00                         ;Do it

G00:
  PUSH DI,DS                    ;Save used registers
  MOV  DS,ES                    ;Point DS at TSR Data Area
  CMP  AL,(ADEntries-1)         ;Valid Address?
  JA  >G70                      ;If not, Error
  MOV  CL,AL                    ;Convert Address
  CALL ADIndex2Offset           ;  to a Table Entry (ES:[DI])
  TEST [DI].ADFlags,ADFlagInUse ;Valid Device?
  JZ  >G70                      ;If not, Error
  OR   AH,AH                    ;Is it EndPoint 0?
  JNE >G20                      ;If not, handle it
  MOV  DL,[DI].ADMaxPktSizeEP0  ;If so, get EP0 Max Pkt Size
  JMP >G90                      ;Done
G20:                            ;Not EndPoint 0
  OR   DX,DX                    ;Did we already calculate the Maximum Size?
  JNZ >G90                      ;If so, use it
  CALL AddressEP2EP             ;Get EndPoint Table Entry
  JC  >G70                      ;If Invalid, Error
  XOR  DH,DH                    ;If OK, get
  MOV  DL,[DI].EnMaxPktSize     ;  Max Pkt Size
  JMP >G90                      ;Done
G70:                            ;Error
  XOR  DX,DX                    ;Set Error Flag
G90:                            ;Done
  MOV  CX,DX                    ;Set Return Value
  OR   CX,CX                    ;Set Return Flag
  POP  DS,DI                    ;Restore used registers
  POP  DX,AX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SET THE DATA1 IN A BULK OR INT TD (GET SETTING FROM ENDPOINT TABLE)
;Inputs:  ES = TSR Data Area
;         ES:[DI] = TD Entry
;Outputs: Sets TDData1 as appropriate for the TD
;Changes:
;NOTES: This simply assumes that the TD is Bulk or Interrupt, it does not
;         actually test it for validity.  It also assumes everything else
;         is kosher (valid Address, valid EndPoint other than 0, etc.) and
;         does not test it.
;------------------------------------------------------------------------------
SetData1ForBulkIntTD:
  PUSH AX,BX,DI,DS              ;Save used registers
  MOV  DS,ES                    ;Point DS at TSR data area
  CALL GetTDEndPoint            ;AH =
  MOV  AH,AL                    ;  End Point Number
  TEST [DI].TDFlags,TDFlagIn    ;Is it In?
  JZ  >D05                      ;If not, continue
  OR   AH,80h                   ;If so, mark it as In
D05:                            ;Direction flag set, if appropriate
  CALL GetTDDeviceAddress       ;AL = Device Address
  MOV  BX,DI                    ;[BX] = TD Entry
  CALL AddressEP2EP             ;Get EndPoint Table Entry
  JC  >D90                      ;If Invalid, Quit
  TEST [DI].EnFlags,EnFlagData1 ;Are we supposed to set Data1?
  JNZ >D30                      ;If so, do it
D10:                            ;Set Data0
  AND  B [BX].TDToken[2],(NOT (TDData1 SHR 16)) ;Set Data0
  JMP >D80                      ;Done
D30:                            ;Set Data1
  OR   B [BX].TDToken[2],(TDData1 SHR 16) ;Set Data1
D80:                            ;Update Data1
  XOR  [DI].EnFlags,EnFlagData1 ;Toggle Data1 for next time
D90:                            ;Done
  POP  DS,DI,BX,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE DEVICE ADDRESS FROM A TRANSFER DESCRIPTOR
;Inputs:  ES:[DI] = Transfer Descriptor
;Outputs: AL = Device Address (0-127)
;Changes:
;------------------------------------------------------------------------------
GetTDDeviceAddress:
  MOV  AL,B ES:[DI].TDToken[1]     ;Get the Address
  AND  AL,(TDDeviceAddrMask SHR 8) ;Mask out the unwanted bits
  RET

;------------------------------------------------------------------------------
;SET THE DEVICE ADDRESS IN A TRANSFER DESCRIPTOR
;Inputs:  ES:[DI] = Transfer Descriptor
;         AL = Device Address (0-127)
;Outputs:
;Changes: Transfer Descriptor
;------------------------------------------------------------------------------
SetTDDeviceAddress:
  PUSH AX                          ;Save used registers
  AND  B ES:[DI].TDToken[1],(NOT (TDDeviceAddrMask SHR 8))
                                   ;Mask out the previous address
  AND  AL,(TDDeviceAddrMask SHR 8) ;Set the
  OR   B ES:[DI].TDToken[1],AL     ;  new address
  POP  AX                          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE END POINT NUMBER FROM A TRANSFER DESCRIPTOR
;Inputs:  ES:[DI] = Transfer Descriptor
;Outputs: AL = EndPoint (0-15)
;         ZF = Set if AL = 0
;Changes:
;------------------------------------------------------------------------------
GetTDEndPoint:
  PUSH BX                      ;Save used registers
  MOV  BX,W ES:[DI].TDToken[1] ;Get the End Point from the Token
  SHR  BX,(TDEndPointSft-8)    ;Shift it over to the correct spot
  AND  BL,(TDEndPointMask SHR TDEndPointSft) ;Mask out the unwanted bits
  MOV  AL,BL                   ;Put it in AL for the return
  OR   AL,AL                   ;Set the return flag
  POP  BX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SET THE END POINT NUMBER IN A TRANSFER DESCRIPTOR
;Inputs:  ES:[DI] = Transfer Descriptor
;         AL = EndPoint (0-15)
;Outputs:
;Changes: TD
;------------------------------------------------------------------------------
SetTDEndPoint:
  PUSH AX                                    ;Save used registers
  AND  AX,(TDEndPointMask SHR TDEndPointSft) ;Convert to a word
  SHL  AX,(TDEndPointSft-8)                  ;Shift to correct spot
  AND  W ES:[DI].TDToken[1],(NOT (TDEndPointMask SHR 8)) ;Mask out the old one
  OR   W ES:[DI].TDToken[1],AX               ;Mask in the new one
  POP  AX                                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE ACTUAL LENGTH DATA SIZE FROM A TRANSFER DESCRIPTOR
;Inputs:  ES:DI = Pointer to TD to get Actual Length From
;Outputs: CX = TD Actual Length (0-1024)
;Changes:
;------------------------------------------------------------------------------
GetTDActualLength:
  MOV  CX,W ES:[DI].TDControlStatus[0] ;Get the low word of Control & Status
  AND  CX,TDActualLengthMask           ;Mask out everything but Actual Length
  CMP  CX,TDActualLengthNUL            ;Is it 0 length?
  JNE >A10                             ;If not, it's OK
  MOV  CX,-1                           ;If so, make sure it ends up at 0
A10:                                   ;AX is OK
  INC  CX                              ;Increment by 1 (TD stores length - 1)
  RET

;------------------------------------------------------------------------------
;GET THE MAX LENGTH DATA SIZE FROM A TRANSFER DESCRIPTOR
;Inputs:  ES:[DI] = Pointer to TD to get Max Length From
;Outputs: AX = TD Max Length (0-1024)
;Changes:
;------------------------------------------------------------------------------
GetTDMaxLength:
  MOV  AX,W ES:[DI].TDToken[2] ;Get the high word of Token
  SHR  AX,(TDMaxLengthSft-16)  ;Shift it over to where it belongs
  CMP  AX,(TDMaxLengthNUL SHR TDMaxLengthSft) ;Is it 0 length?
  JNE >M10                     ;If not, it's OK
  MOV  AX,-1                   ;If so, make sure it ends up at 0
M10:                           ;AX is OK
  INC  AX                      ;Increment by 1 (TD stores length - 1)
  RET

;------------------------------------------------------------------------------
;SET THE MAX LENGTH DATA SIZE IN A TRANSFER DESCRIPTOR
;Inputs:  ES:[DI] = Pointer to TD to set Actual Length in
;         AX = TD Max Length (0-1024)
;Outputs: Changes TD Max Length
;Changes:
;------------------------------------------------------------------------------
SetTDMaxLength:
  PUSH AX                         ;Save used registers
  OR   AX,AX                      ;Is it 0 length?
  JNZ >M10                        ;If not, it's a real size
  MOV  AX,(TDMaxLengthNUL SHR 16) ;If so, set it as NUL
  JMP >M20                        ;Jump to store it
M10:                              ;It's not 0 size
  DEC  AX                         ;Decrement it (TD stores length - 1)
  AND  AX,1023                    ;Maximize it at 1023
  SHL  AX,(TDMaxLengthSft-16)     ;Shift it over to the corrent position
M20:                              ;Ready to store it
  AND  W ES:[DI].TDToken[2],(NOT (TDMaxLengthMask SHR 16)) ;Mask out old value
  OR   W ES:[DI].TDToken[2],AX    ;Store the new value
  POP  AX                         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;REMOVE ALL REFERENCES TO A TD/QH FROM FL, QH, AND OTHER TD's (UNSCHEDULE IT)
;Inputs:  ES:[DI] = Pointer of TD/QH to Unschedule
;Outputs:
;Changes: Removes TD from the Schedule
;------------------------------------------------------------------------------
RemoveQHRefGivenTD:
  PUSH DI                    ;Save used registers
  MOV  DI,[DI].TDIntQHOffset ;Point DI at the QH Offset
  CALL RemoveQHReferences    ;Unschedule it
  POP  DI                    ;Restore used registers
  RET

RemoveQHReferences:
  PUSH AX                        ;Save used registers
  MOV  AH,-1                     ;Mark as a Queue
  JMP >R00                       ;Do it
RemoveTDReferences:
  PUSH AX                        ;Save used registers
  XOR  AH,AH                     ;Mark as a TD
;  JMP >R00                       ;Do it
R00:
  PUSH EBX,DI,DS                 ;Save used registers
  PUSHF                          ;Save flags
  CLI                            ;Disable interrupts
  MOV  DS,ES                     ;Point DS at the correct data area
  MOV  EBX,[DI].TDLinkPointer    ;Get the address that this TD is pointed at
  OR   AH,AH                     ;Is it a Queue?
  JNZ >R10                       ;If so, can't get TD Type!
  CALL GetTDType                 ;Get the type of TD
  CMP  AL,TDTypeAvailable        ;Is it Unused?
  JE  >R90                       ;If so, we're done
  CMP  AL,TDTypeIsoch            ;Is it Isochronous?
  JE  >R10                       ;If so, jump to handle it
  CMP  AL,TDTypeInterrupt1Time   ;Is it 1-Time Interrupt?
  JE  >R10                       ;If so, jump to handle it
  CMP  AL,TDTypeInterruptPer     ;Is it Periodic Interrupt?
  JNE >R30                       ;If not, it's Control or Bulk (in a Queue)
  CMP  W [DI].TDIntQHOffset,0    ;If so, is it in a Queue?
  JNE >R30                       ;If so, handle it
R10:                             ;Frame Lists
  CALL FindTDInFLs               ;Look for the TD in the FL Table
  JNC >R80                       ;If found, jump to unshchedule it
  CALL FindTDInQHLinks           ;Look for the TD in the QH Table
  JNC >R80                       ;If found, jump to unshchedule it
  JMP >R50                       ;Jump to look in other TDs
R30:                             ;Queue elements (Bulk and some Periodic Int)
  CALL FindTDInQHElements        ;Look for the TD in the QH Table
  JC  >R50                       ;If not found, jump to look in other TD's
  MOV  [DI].QHElementPointer,EBX ;If found, unschedule it
  JMP >R90                       ;Done
R50:                             ;Other Transfer Descriptors
  CALL FindTDInOtherTDs          ;Look for the TD in other TD's
  JC  >R90                       ;If not found, done
R80:                             ;[DI] = FL/TD/QH, EBX = TD's Link Pointer
  MOV  [DI].TDLinkPointer,EBX    ;Remove the reference to our TD
R90:                             ;We're done
  POPF                           ;Restore flags
  POP  DS,DI,EBX                 ;Restore used registers
  POP  AX                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND OUT WHERE A TD/QH IS REFERENCED IN OTHER PLACES (FL, QH, or OTHER TD's)
;Inputs:  ES = TSR Data Area
;         ES:[DI] = TD Pointer to Find
;Outputs: CF = Clear if TD was Found
;              DI = FL/QH/TD Pointer it was found in
;            = Set if not found
;              DI = Unchanged
;Changes:
;NOTES: If searching for a TD in the Frame List Table, the TD must be an
;         Isochronous or Interrupt TD, otherwise it will never be found.
;       If searching for a TD in the Queue Head Table, the TD must be
;         a Control or Bulk TD, or it will never be found.
;------------------------------------------------------------------------------
FindQHInQHLinks:
FindTDInQHLinks:
  PUSH BP                  ;Save used registers
  XOR  BP,BP               ;Offset into Table Entry of Pointer
  JMP >F0000               ;Do it
FindTDInQHElements:
  PUSH BP                  ;Save used registers
  MOV  BP,OFFSET QHElementPointer ;Offset into Table Entry of Pointer
F0000:
  PUSH CX,SI,FS            ;Save used registers
  MOV  CX,ES:[QHTable]     ;Point at
  MOV  FS,CX               ;  Table
  MOV  CX,QHEntries        ;Number of Entries in Table
  MOV  SI,QHSize           ;Size of Each Entry
  JMP >F00                 ;Do it

FindQHInFLs:
FindTDInFLs:
  PUSH BP                  ;Save used registers
  XOR  BP,BP               ;Offset into Table Entry of Pointer
  PUSH CX,SI,FS            ;Save used registers
  PUSH W ES:[FLOffsetW]    ;Point
  POP  FS                  ;  at Table
  MOV  CX,FLEntries        ;Number of Entries in Table
  MOV  SI,FLSize           ;Size of Each Entry
  JMP >F00                 ;Do it

FindQHInTDs:
FindTDInOtherTDs:
  PUSH BP                  ;Save used registers
  XOR  BP,BP               ;Offset into Table Entry of Pointer
  PUSH CX,SI,FS            ;Save used registers
  PUSH (TDOffset)          ;Point
  POP  FS                  ;  at Table
  MOV  CX,TDEntries        ;Number of Entries in Table
  MOV  SI,TDSize           ;Size of Each Entry
;  JMP >F00                 ;Do it

F00:
  PUSH EAX,EBX,DX,DS       ;Save used registers
  MOV  DX,DI               ;Save original Pointer
  MOV  DS,ES               ;Point DS at the correct data area
  CALL SegOff2PhysAddrESDI ;Get the Physical Address
  MOV  EBX,EAX             ;  of the TD/QH we're looking for
  MOV  DI,FS               ;Point at the Table (CX has # of Entries)
F10:                       ;Loop to here for each Entry
  MOV  EAX,DS:[DI+BP]      ;Get the Physical Address
  AND  EAX,FLAddrMask      ;  of the Entry
  CMP  EAX,EBX             ;Is it a match?
  JE  >F80                 ;If so, we're done
  ADD  DI,SI               ;Point at the next Entry
  LOOP F10                 ;Keep going until we're done
F70:                       ;TD not Found
  MOV  DI,DX               ;Restore original Pointer
  STC                      ;Set Error Flag
  JMP >F90                 ;Done
F80:                       ;TD Found
  CLC                      ;Set OK Flag
F90:                       ;Done
  POP  DS,DX,EBX,EAX       ;Restore used registers
  POP  FS,SI,CX            ;Restore used registers
  POP  BP                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE WHAT TYPE OF 32-BIT ADDRESS WE HAVE (TD, QH, IsochTD, IntTD, etc.)
;Inputs:  EAX = 32-bit address to check
;          ES = Data segment to use
;Outputs:  BL = AddrType
;Changes:
;NOTES:   Address will be from a LinkPointer/ElementPointer (low nibble = flags)
;         Assume that the low nibble may have already been masked out,
;           so the QHSelect or Terminate bits may not be valid
;------------------------------------------------------------------------------
CalcPhysAddrType:
  PUSH AX,CX,DI,DS               ;Save used registers
  MOV  DS,ES                     ;Point DS at the correct data area
  MOV  BL,PhysAddrTypeNone       ;Assume it's Empty (all zeroes)
  CALL PhysAddr2SegOffNoFlags    ;Convert the physical address to an offset
  JZ  >Y90                       ;If it's all zeroes, we're done
Y10:                             ;Check for FL
  MOV  BL,PhysAddrTypeFL         ;Assume it's an FL
  MOV  AX,[FLOffsetW]            ;Is it
  CMP  DI,AX                     ;  an FL?
  JB  >Y20                       ;If not, try the next possibility
  ADD  AX,(FLEntries*FLSize)     ;Is it
  CMP  DI,AX                     ;  an FL?
  JB  >Y90                       ;If so, we're done
Y20:                             ;Check for TD
  CMP  DI,TDOffset               ;Is it a TD?
  JB  >Y30                       ;If not, try the next possibility
  CMP  DI,(TDOffset+(TDEntries*TDSize)) ;Is it a TD?
  JA  >Y30                       ;If not, try the next possibility
Y25:                             ;Calculate type of TD
  CALL GetTDType                 ;Get the type of TD
  SUB  AL,TDTypeAvailable        ;  converted to an "offset"
  MOV  BL,PhysAddrTypeAvailTD    ;Calculate the correct
  ADD  BL,AL                     ;  return value
  JMP >Y90                       ;We're done
Y30:                             ;Check for Control QH
  MOV  BL,PhysAddrTypeControlQH  ;Assume it's the Control QH
  MOV  CX,DS:[QHTable]           ;CX = Control QH Offset
  CMP  DI,CX                     ;Is it the Control QH?
  JE  >Y90                       ;If so, we're done
Y40:                             ;Check for Bulk QH
  MOV  BL,PhysAddrTypeBulkQH     ;Assume it's a Bulk QH
  ADD  CX,QHSize                 ;CX = Bulk QH Offset
  CMP  DI,CX                     ;Is it a Bulk QH?
  JB  >Y70                       ;If not, Error
  ADD  CX,(BulkQHEntries*QHSize) ;CX = Interrupt QH Offset
  CMP  DI,CX                     ;Is it a Bulk QH?
  JB  >Y90                       ;If so, we're done
Y50:                             ;Check for Int QH
  ADD  CX,(IntQHEntries*QHSize)  ;CX = End of QH Table
  CMP  DI,CX                     ;Is it an Interrupt QH?
  JB  >Y90                       ;If so, we're done
Y70:                             ;Invalid/Error
  MOV  BL,PhysAddrTypeErr        ;Error Address Type
Y90:                             ;We're done
  POP  DS,DI,CX,AX               ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO READ/WRITE FROM/TO PCI DEVICES AND THE USB HOST CONTROLLER
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO READ/WRITE FROM/TO THE USB HOST CONTROLLER
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;READ OR WRITE THE USB COMMAND REGISTER (WORD)
;Inputs:  ES = TSR Data Area
;         If Write, AX = Register Value to Write
;Outputs: If Read, AX = Register Value
;Changes:
;NOTES:   We have this subroutine to save us a few bytes of memory.
;         We Read and Write the USB Command Register a lot, while most
;           other Host registers are only done a few times.  We access the
;           USB Command Register enough to make it worth its own special
;           subroutines.
;------------------------------------------------------------------------------
ReadUSBCommandWord:
  PUSH BX            ;Save used registers
  MOV  BL,USBCommand ;BL = USB Command Register Offset
  CALL ReadHostWord  ;Read it (returns AX)
  POP  BX            ;Restore used registers
  RET

WriteUSBCommandWord:
  PUSH BX            ;Save used registers
  MOV  BL,USBCommand ;BL = USB Command Register Offset
  CALL WriteHostWord ;Write it (sends AX)
  POP  BX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ A CONFIGURATION BYTE, WORD, OR DWORD FROM THE USB HOST CONTROLLER
;Inputs:  BL = Offset from Base Address to get
;         ES:[BaseIOAddress]
;Outputs: AL if Byte, AX if word, EAX if DWord
;Changes:
;NOTES: On the HP Laptop, an IN EAX,DX sometimes locks up the computer
;         (not all the time, just sometimes).  So, to get a DWord, we do
;         the two "sub-Words" separately and combine them together.
;       We shouldn't need to do this, but it seems to be the only way to
;         get it to work.
;------------------------------------------------------------------------------
ReadHostByte:
  XOR  AL,AL  ;Mark as a Byte
  JMP >H00    ;Jump to do it
ReadHostWord:
  MOV  AL,1   ;Mark as a Word
  JMP >H00    ;Jump to do it
ReadHostDWord:
  MOV  AL,2   ;Mark as a DWord
;  JMP >H00    ;Jump to do it
H00:
  PUSH BX,DX  ;Save used registers
  MOV  DX,ES:[BaseIOAddress] ;DX = Base I/O Address
  XOR  BH,BH  ;Add in the
  ADD  DX,BX  ;  appropriate offset
  CMP  AL,1   ;Are we doing a Byte, Word, or DWord?
  JE  >H20    ;If a word, jump to handle it
  JA  >H40    ;If a DWord, jump to handle it
H10:          ;Doing a Byte
  IN   AL,DX  ;Do the byte
  JMP >H90    ;We're done
H20:          ;Doing a Word
  IN   AX,DX  ;Do the word
  JMP >H90    ;We're done
H40:          ;Doing a DWord
  IN   AX,DX  ;Read the Low Word
  PUSH AX     ;Save it on the stack
  INC  DX,2   ;Read the
  IN   AX,DX  ;  High Word
  SHL  EAX,16 ;Put it in the High Word of EAX
  POP  AX     ;Put the Low Word in EAX
H90:          ;We're done
  POP  DX,BX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A CONFIGURATION BYTE, WORD, OR DWORD TO THE USB HOST CONTROLLER
;Inputs:  BL = Offset from Base Address to write to
;         AL/AX/EAX = Byte/Word/DWord to write
;         ES:[BaseIOAddr]
;Outputs:
;Changes:
;NOTES: On the HP Laptop, an IN EAX,DX sometimes locks up the computer
;         (not all the time, just sometimes).  So, we do two IN AX,DX's
;         in the ReadHostDWord routine to get around the problem.  In this
;         WriteHostDWord routine, we do the same thing even though we
;         may not actually need to.
;       On the Dell Desktop, sometimes a Write to the Host does not "take"
;         for some unknown reason.  Reading back what was just written
;         seems to fix the problem, so that's what we do here.  There seem
;         to be all kidns of wierd problems like this whenever Intel
;         integrates several functions (like seversl USB Host Controllers)
;         onto a single motherboard chipset.
;------------------------------------------------------------------------------
WriteHostByte:
  PUSH CX                    ;Save used registers
  MOV  CX,ReadHostByte       ;[CX] = Follow up Code
  JMP >H00                   ;Jump to do it
WriteHostWord:
  PUSH CX                    ;Save used registers
  MOV  CX,ReadHostWord       ;[CX] = Follow up Code
  JMP >H00                   ;Jump to do it
WriteHostDWord:
  PUSH CX                    ;Save used registers
  MOV  CX,ReadHostDWord      ;[CX] = Follow up Code
;  JMP >H00                   ;Jump to do it
H00:
  PUSH EAX,BX,DX             ;Save used registers
  MOV  DX,ES:[BaseIOAddress] ;DX = Base I/O Address
  XOR  BH,BH                 ;Add in the
  ADD  DX,BX                 ;  appropriate offset
  CMP  CX,ReadHostWord       ;Are we doing a Word?
  JE  >H20                   ;If so, handle it
  CMP  CX,ReadHostDWord      ;Are we doing a DWord?
  JE  >H40                   ;If so, handle it
H10:                         ;Doing a Byte
  OUT  DX,AL                 ;Do the byte
  JMP >H90                   ;We're done
H20:                         ;Doing a Word
  OUT  DX,AX                 ;Write the low-order Word
  JMP >H90                   ;We're done
H40:                         ;Doing a DWord
  OUT  DX,AX                 ;Send the Low Word
  INC  DX,2                  ;Send
  SHR  EAX,16                ;  the
  OUT  DX,AX                 ;  High Word
H90:                         ;We're done
  CALL CX                    ;Read the data back again (uses BL)
  POP  DX,BX,EAX             ;Restore used registers
  POP  CX                    ;Restore used Registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO READ/WRITE FROM/TO A PCI DEVICE
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;READ A CONFIGURATION BYTE, WORD, OR DWORD FROM THE PCI CONTROLLER
;Inputs:  BL = Offset of PCI Configuration Register to use
;         ES:[PCIDevFunc]
;Outputs: CF = Set if error, Clear if OK
;         AL = Byte, AX if Word, EAX if DWord
;         EAX = ??? if the call fails!
;Changes: Could change "unaffected" parts of ECX???
;NOTE:    Calls May require up to 1024 bytes of Stack!
;         Can unpredictably affect any and all flags except CF and IF
;------------------------------------------------------------------------------
ReadPCIByte:
  PUSH BP                 ;Save used registers
  XOR  BP,BP              ;Mark as a Byte
  JMP  >P00               ;Jump to do it
ReadPCIWord:
  PUSH BP                 ;Save used registers
  MOV  BP,1               ;Mark as a Word
;  JMP  >P00               ;Jump to do it
;ReadPCIDWord:
;  PUSH BP                 ;Save used registers
;  MOV  BP,2               ;Mark as a DWord
;  JMP  >P00               ;Jump to do it
P00:
  PUSH EBX,ECX,EDX,DI     ;Save used registers
  PUSH EAX                ;Save original EAX
  XOR  BH,BH              ;Put register offset
  MOV  DI,BX              ;  in DI
  MOV  AX,BP              ;Function numbers are B108h (Byte), B109h (Word),
  ADD  AX,0B108h          ;  and B10Ah (DWord)
  MOV  BX,ES:[PCIDevFunc] ;Get Device & Function numbers for the Host Controller
  STC                     ;Preset the error flag
  INT  1Ah                ;Do it (returns Carry Flag, and CL/CX/ECX)
  POP  EAX                ;Restore original EAX
  JC  >P70                ;If error, we're done
  CMP  BP,1               ;Were we doing a Byte, Word, or DWord?
  JE  >P20                ;If a Word, jump to handle it
  JA  >P30                ;If a DWord, jump to handle it
P10:                      ;Doing a Byte
  MOV  AL,CL              ;If a Byte, handle it
  JMP >P80                ;We're done
P20:                      ;Doing a Word
  MOV  AX,CX              ;Handle a Word
  JMP >P80                ;We're done
P30:                      ;Doing a DWord
  MOV  EAX,ECX            ;Handle a DWord
  JMP >P80                ;We're done
P70:                      ;There's an error
  STC                     ;Set the error flag
  JMP >P90                ;We're done
P80:                      ;It went OK
  CLC                     ;Set the OK flag
P90:                      ;We're done
  POP  DI,EDX,ECX,EBX     ;Restore used registers
  POP  BP                 ;Restorer used registers
  RET

;------------------------------------------------------------------------------
;WRITE A CONFIGURATION BYTE, WORD, OR DWORD TO THE PCI CONTROLLER
;Inputs:  BL = Offset of PCI Configuration Register to use
;         AL = Byte, AX if Word, ACX if DWord
;         ES:[PCIDevFunc]
;Outputs: CF = Set if error, Clear if OK
;Changes:
;NOTE:    Calls May require up to 1024 bytes of Stack!
;         Can unpredictably affect any and all flags except CF and IF
;------------------------------------------------------------------------------
WritePCIByte:
  PUSH EDX                ;Save used registers
  XOR  DX,DX              ;Mark as a Byte
  JMP  >P00               ;Jump to do it
WritePCIWord:
  PUSH EDX                ;Save used registers
  MOV  DX,1               ;Mark as a Word
;  JMP  >P00               ;Jump to do it
;WritePCIDWord:
;  PUSH EDX                ;Save used registers
;  MOV  DX,2               ;Mark as a DWord
;;  JMP  >P00               ;Jump to do it
P00:
  PUSH EAX,EBX,ECX,DI     ;Save used registers
  XOR  BH,BH              ;Put register offset
  MOV  DI,BX              ;  in DI
  MOV  ECX,EAX            ;Put what to write in (E)Cx
  MOV  AX,DX              ;Function numbers are B10Bh (Byte), B10Ch (Word),
  ADD  AX,0B10Bh          ;  and B10Dh (DWord)
  MOV  BX,ES:[PCIDevFunc] ;Get Device & Function numbers for the Host Controller
  STC                     ;Preset the error flag
  INT  1Ah                ;Do it (returns Carry Flag)
P90:                      ;We're done
  POP  DI,ECX,EBX,EAX     ;Restore used registers
  POP  EDX                ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO CONVERT SEGMENT:OFFSET ADDRESSES TO PHYSICAL ADRESSES & VICE-VERSA
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;Code to Convert Segment:Offset Addresses to Physical Addresses
;If the Address is "foreign" (from another program), these routines will
;  use VCPI calls to determine the physical address.  If local to our
;  program, we calculated the Programs Base Physical Address on installation
;  and just need to do a simple addition.
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;CONVERT A SEGMENT:OFFSET (DS:DI, ES:DI, OR EAX) TO A 32-BIT PHYSICAL ADDRESS
;Inputs:  ES:DI = Segment:Offset to convert
;      or EAX   = Segment:Offset to convert
;         CS = [FirstInstanceSeg]
;         if ESDI, ES = TSR Data Area
;Outputs: EAX = Segment:Offset converted to a Physical address
;Changes:
;Notes: This will make a call to the VCPI-compliant Memory Manager
;         (e.g.,EMM386) if one is loaded.  This will allow us to determine the
;         Physical Address even if we are loaded in a UMB.
;------------------------------------------------------------------------------
SegOff2PhysAddrESDI:
  MOVZX EAX,DI               ;EAX = Offset
  ADD  EAX,ES:[BasePhysAddr] ;Add in the base Physical Address
  RET

SegOff2PhysAddrEAX:
  PUSH EBX,ECX,EDX  ;Save used registers
  PUSH EBP          ;Save used registers
  MOV  EBP,EAX      ;Save original EAX
  XOR  ECX,ECX      ;Convert
  XOR  EBX,EBX      ;  Segment:Offset
  PUSH EAX          ;  to
  POP  BX           ;  a
  POP  CX           ;  Linear
  SHL  ECX,4        ;  Address
  ADD  ECX,EBX      ;  (ECX)
  MOV  EBX,ECX      ;Save it in EBX
  CALL TestRealMode ;Is the CPU in Real Mode?
  JNC >S80          ;If so, we're done
  CALL TestMTask    ;Are we running underneath a multi-tasker (Windows)?
  JZ  >S70          ;If so, we can't use VCPI to determine our address
  CALL TestVCPI     ;Are we running under VCPI?
  JC  >S70          ;If not, we can't determine our physical address
  SHR  ECX,12       ;CX = Page Number of Segment
  MOV  AX,0DE06h    ;Function DE06h (convert Page to Physical Address)
  INT  67h          ;Do it (Returns EDX = Physical Address)
  OR   AH,AH        ;Did it work?
  JNZ >S70          ;If not, quit
  SHL  ECX,12       ;Subtract out original
  SUB  EBX,ECX      ;  (Linear) Page Offset
  ADD  EBX,EDX      ;Add small offset to the Page Offset
  JMP >S80          ;Done
S70:                ;Error
  MOV  EAX,EBP      ;Restore original EAX
  STC               ;Set return flag
  JMP >S90          ;Done
S80:                ;EAX is valid
  MOV  EAX,EBX      ;Put result in EAX for the return
  CLC               ;Set return flag
S90:                ;Done
  POP  EBP          ;Restore used registers
  POP  EDX,ECX,EBX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEE IF THE COMPUTER IS IN REAL MODE
;Inputs:
;Outputs: CF = Clear if in Real Mode
;            = Set if in Protected Mode
;Changes:
;------------------------------------------------------------------------------
TestRealMode:
  PUSH AX   ;Save used registers
  SMSW AX   ;Get the Machine Status Word
  SHR  AX,1 ;Set the return flag
  POP  AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF WE ARE RUNNING UNDER A MULTI-TASKER (e.g., WINDOWS)
;Inputs:
;Outputs: ZF = Set if we are underneath a multi-tasker
;            = Clear if not
;Changes:
;NOTES: This call works with several different MultiTaskers besides
;         Windows DPMI, so it's an excellent test for what we need.
;       The main reason for this test is that the VCPI test that follows it
;         crashes the computer under some versions Windows.
;------------------------------------------------------------------------------
TestMTask:
  PUSH AX       ;Save used registers
  MOV  AX,1680h ;Function 1680h (Release current Virtual Machine Time Slice)
  INT  2Fh      ;Do it
  OR   AL,AL    ;Did it work?
  POP  AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEE IF A VCPI-COMPLIANT MEMORY MANAGER IS INSTALLED
;Inputs:
;Outputs: CF = Clear if VCPI is installed
;            = Set if not
;Changes:
;------------------------------------------------------------------------------
TestVCPI:
  PUSH AX,BX     ;Save used registers
  MOV  AL,67h    ;Does Int 67h
  CALL TestInt   ;  even exist?
  JZ  >V70       ;If not, we can't have VCPI
  MOV  AX,0DE00h ;Function DE00h (VCPI Installation check)
  INT  67h       ;Do it (Also returns BX = Version)
  OR   AH,AH     ;Did it work?
  JZ  >V80       ;If so, we're done
V70:             ;Error
  STC            ;Set the error flag
  JMP >V90       ;We're done
V80:             ;It's OK
  CLC            ;Set the OK flag
V90:             ;We're done
  POP  BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF AN INTERRUPT VECTOR HAS A VALID ADDRESS (other than 0)
;Inputs:  AL = Interrupt number to test
;Outputs: ZF = Set if invalid address (Segment = 0)
;            = Clear if valid address (Segment <> 0)
;Changes:
;------------------------------------------------------------------------------
TestInt:
  PUSH BX,DS      ;Save used registers
  XOR  BX,BX      ;Point DS at the
  MOV  DS,BX      ;  Interrupt Table
  MOV  BL,AL      ;Point BX
  SHL  BX,2       ;  at the Interrupt we're looking for
  CMP  W [BX+2],0 ;Is the Segment valid (set the return flag)?
  POP  DS,BX      ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;Code to Convert Physical Addresses to Segment:Offset Addresses
;These only work with addresses in OUR program, since they assume ES
;  is the segment!
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;CONVERT A PHYSICAL ADDRESS TO A PARAGRAPH-ALIGNED SEGMENT:OFFSET FORMAT
;Inputs:  EAX = Physical Address to Convert
;Outputs:  DI = Offset to the address, using ES as the Segment
;Changes: ZF = Set if Error (EAX = 0, not a real Address)
;            = Clear if OK
;NOTES:   This masks out the flags (low nibble) of a Physical Address
;           that was stored in a Link Pointer or Element Pointer
;           so that it returns a "real" Table Offset that we can use
;------------------------------------------------------------------------------
PhysAddr2SegOffNoFlags:
  PUSH AX                       ;Save used registers
  AND  AL,(QHAddrMask AND 0FFh) ;Mask out possible LinkPointer flags
  CALL PhysAddr2SegOff          ;Convert Physical Address to Offset (DI)
  POP  AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A PHYSICAL ADDRESS TO SEGMENT:OFFSET FORMAT
;Inputs:  EAX = Physical Address to Convert
;         ES = TSR Data Area
;Outputs: DI = Offset to the address, using ES as the Segment
;         If EAX = 0 (not a real address), DI = 0 & ZF = Set
;         Otherwise, ZF = Clear
;Changes:
;------------------------------------------------------------------------------
PhysAddr2SegOff:
  PUSH EAX     ;Save used registers
  XOR  DI,DI   ;Assume invalid Address
  OR   EAX,EAX ;Valid Address?
  JZ  >P90     ;If not, quit
  SUB  EAX,ES:[BasePhysAddr] ;If OK, calculate the Program Offset
  MOV  DI,AX   ;Put it in DI for the return
P90:           ;Done
  OR   DI,DI   ;Set return flag
  POP  EAX     ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS FRAME TIMING (TIMING VALUES, TIMING OWNERSHIP, ETC.)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO GET FRAME INDEX, NUMBER, TIMING
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;GET THE CURRENT FRAME INDEX (0-1023)
;Inputs:  ES = TSR Data Area
;Outputs: AX = Current Frame Index (0-1023)
;Changes:
;------------------------------------------------------------------------------
GetFrameIndex:
  CALL GetFrameNumber    ;Get the Frame Number
  AND  AX,FrNumIndexMask ;Convert it to the Frame Index
  RET

;------------------------------------------------------------------------------
;GET THE CURRENT FRAME NUMBER (0-2047)
;Inputs:  ES = TSR Data Area
;Outputs: AX = Current Frame Number (0-2047)
;Changes:
;------------------------------------------------------------------------------
GetFrameNumber:
  PUSH BX              ;Save used registers
  MOV  BL,FrameNum     ;Get the current
  CALL ReadHostWord    ;  Frame Number
  AND  AX,FrNumNumMask ;Get rid of any extra bits that may be there
  POP  BX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT AN "EXTENDED" FRAME # (0-65535) TO A "LEGITIMATE" FRAME # (0-2047)
;Inputs:  AX = Frame Number (0-65535)
;Outputs: AX = Frame Number (0-2047)
;Changes:
;------------------------------------------------------------------------------
CvtFrNum2FrNum:
  PUSH BX               ;Save used registers
  MOV  BX,(FLEntries*2) ;BX = 2048 (Max Value to compare with)
N10:                    ;Loop to here for each test we make
  CMP  AX,BX            ;Is the Frame Nubmer too big?
  JB  >N90              ;If not, we're done
  SUB  AX,BX            ;If so, adjust it
  JMP  N10              ;Jumpt to test it again
N90:                    ;Done
  POP  BX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADD AN AMOUNT OF TIME (MS) TO THE CURRENT TIME, AND RETURN THE FRAME NUMBER
;Inputs:  ES = TSR Data Area
;         AX = Amount of time (ms) to Add to the current Frame Number
;              Must be between 1 and 1024!
;Outputs: CX = Frame Number associated with that particular time
;Changes:
;------------------------------------------------------------------------------
AddToFrameNumber:
  PUSH AX             ;Save used registers
  MOV  CX,AX          ;Put Adder in CX
  CALL GetFrameNumber ;Get the current Frame Number (AX, 0-2047)
  ADD  AX,CX          ;Add in the correct amount of time
  CALL CvtFrNum2FrNum ;Make sure it's a valid Frame Number
  MOV  CX,AX          ;Put it in CX for the return
A90:                  ;We're done
  POP  AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE CURRENT FRAME TIMING VALUE (BITS/FRAME)
;Inputs:  ES = TSR Data Area
;Outputs: AX = Current Frame Timing (Bits/Frame)
;Changes:
;------------------------------------------------------------------------------
GetFrameTiming:
  PUSH BX               ;Save used registers
  MOV  BL,SOFModify     ;Get Start-Of-Frame
  CALL ReadHostByte     ;  Modification Register
  XOR  AH,AH            ;Convert it to a Word
  ADD  AX,SOFModifyBase ;Add in the Base Value
  POP  BX               ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE FOR INT 14 REQUESTS TO REGISTER/UNREGISTER TIMING OWNER
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO REGISTER AS THE TIMING OWNER
;Inputs:  DS:[SI] = USB Data Call Structure
;         ES      = TSR Data area
;         AH      = HostIndex (-1 or ours)
;         AL      = Int14RRequestType (Register Timing Owner)
;         BX = CX = DX = -1
;Outputs: Registers Timing Owner, if one does not already Exist
;         CF = Clear if OK (Registered as Owner)
;              CX = Handle Number (a semi-randomized number)
;              BP = Undefined
;            = Set if Error
;              CX = Unchanged (-1)
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
RegTmgOwner:
  PUSH EAX                         ;Save used registers
  MOV  BP,I14RErrHostIndex         ;Assume Bad Host Index
  CMP  AH,AllHostsIndex            ;Is it for All Hosts?
  JE  >R70                         ;If so, Error
  MOV  BP,I14RErrTimingOwned       ;Assume there's already a Timing Owner
  CMP  ES:[TimingCallBackAddr],0   ;Is there already a Timing Owner?
  JNE >R70                         ;If so, error
  CALL TestI14RCallBackAddr        ;Legitimate Call Back Address (sets BP)?
  JZ  >R70                         ;If not, Error
  MOV  EAX,[SI].I14RCallBackAddr   ;If OK,
  MOV  ES:[TimingCallBackAddr],EAX ;  store it
  MOV  AX,[SI].I14RUserPktID       ;Store the
  MOV  ES:[TimingUserPktID],AX     ;  User Packet ID
  CALL GetRandomWord               ;Generate a Random Number for the Handle
  MOV  ES:[TimingHandle],AX        ;Store it as the Timing Handle
  MOV  CX,AX                       ;Return it to the user in CX
  JMP >R80                         ;Done
R70:                               ;Error (BP = Error Code)
  STC                              ;Set Error Flag
  JMP >R90                         ;Done
R80:                               ;OK
  CLC                              ;Set OK Flag
R90:                               ;Done
  POP  EAX                         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO UNREGISTER AS THE TIMING OWNER
;Inputs:  DS:[SI] = USB Data Call Structure (contains Handle Number)
;         ES      = TSR Data area
;         AH      = HostIndex (-1 or ours)
;         AL      = Int14RRequestType (UnRegister Timing Owner)
;Outputs: UnRegisters Timing Owner
;         CF = Clear if OK (UnRegistered as Owner)
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
UnRegTmgOwner:
  PUSH EAX                         ;Save used registers
  MOV  BP,I14RErrHostIndex         ;Assume Bad Host Index
  CMP  AH,AllHostsIndex            ;Is it for All Hosts?
  JE  >U70                         ;If so, Error
  MOV  BP,I14RErrTimingOwned       ;Assume there's not a Timing Owner
  CMP  ES:[TimingCallBackAddr],0   ;Is there a Timing Owner?
  JE  >U70                         ;If not, error
  MOV  BP,I14RErrRequestHandle     ;Assume Bad Handle Number
  MOV  AX,[SI].I14RRequestHandle   ;Is the Handle Number
  CMP  AX,ES:[TimingHandle]        ;  what it needs to be?
  JNE >U70                         ;If not, Error
  XOR  EAX,EAX                     ;Set with Zeroes
  MOV  ES:[TimingCallBackAddr],EAX ;Mark it
  MOV  ES:[TimingUserPktID],AX     ;  as
  MOV  ES:[TimingHandle],AX        ;  Unregistered
  JMP >U80                         ;Done
U70:                               ;Error (BP = Error Code)
  STC                              ;Set Error Flag
  JMP >U90                         ;Done
U80:                               ;OK
  CLC                              ;Set OK Flag
U90:                               ;Done
  POP  EAX                         ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE FOR INT 14 REQUESTS TO CHANGE TIMING
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO INCREMENT OR DECREMENT THE FRAME TIMING BY ONE
;Inputs:  DS:[SI] = USB Data Call Structure
;         ES      = TSR Data area
;         AH      = HostIndex (-1 or ours)
;         AL      = Int14RRequestType (Increment/Decrement Timing)
;Outputs: Increments the Frame Timing by one bit/frame
;         CF = Clear if OK
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
DecTiming:
  PUSH BX                  ;Save used registers
  MOV  BH,-1               ;Subtract 1
  JMP >M00                 ;Do it
IncTiming:
  PUSH BX                  ;Save used registers
  MOV  BH,1                ;Add 1
;  JMP >M00                 ;Do it
M00:
  PUSH AX                  ;Save used registers
  MOV  BP,I14RErrHostIndex ;Assume Bad Host Index
  CMP  AH,AllHostsIndex    ;Is it for All Hosts?
  JE  >M70                 ;If so, Error
  MOV  BL,SOFModify        ;Get the current
  CALL ReadHostByte        ;  Register
  ADD  AL,BH               ;Change it
  CALL DoTimingChange      ;Change it
  JNC >M80                 ;If it worked, we're done
M70:                       ;Error (BP = Error Code)
  STC                      ;Set Error Flag
  JMP >M90                 ;Done
M80:                       ;OK
  CLC                      ;Set OK Flag
M90:                       ;Done
  POP  AX                  ;Restore used registers
  POP  BX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST TO CHANGE THE FRAME TIMING
;Inputs:  DS:[SI] = USB Data Call Structure
;         ES      = TSR Data area
;         AH      = HostIndex (-1 or ours)
;         AL      = Int14RRequestType (Change Timing to a new Value)
;Outputs: Changes the Frame Timing
;         CF = Clear if OK
;            = Set if Error
;              BP = Error Code
;Changes:
;------------------------------------------------------------------------------
ChangeTiming:
  PUSH AX,BX                     ;Save used registers
  MOV  BP,I14RErrHostIndex       ;Assume Bad Host Index
  CMP  AH,AllHostsIndex          ;Is it for All Hosts?
  JE  >C70                       ;If so, Error
  MOV  BP,I14RErrTimingLimit     ;Assume bad Timing Value
  MOV  AX,W [SI].I14RFrameTiming ;Get Timing Value from Request
  SUB  AX,SOFModifyBase          ;Subtract out the Base Offset
  JC  >C70                       ;If it was too big, quit
  CMP  AX,127                    ;Was it too small?
  JA  >C70                       ;If so, quit
  CALL DoTimingChange            ;If OK, Change it
  JNC >C80                       ;Done
C70:                             ;Error (BP = Error Code)
  STC                            ;Set Error Flag
  JMP >C90                       ;Done
C80:                             ;OK
  CLC                            ;Set OK Flag
C90:                             ;Done
  POP  BX,AX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs:  DS:[SI] = USB Data Call Structure
;         ES      = TSR Data Area
;         AL      = Target Value for SOF Modify Register
;Outputs: CF = Clear If OK
;                Timing Change Scheduled
;            = Set if Error
;                BP = Error Code
;Changes: Frame Timing
;NOTES: If the Host is Stopped, we make the change immediately
;       If the Host is running, we cannot change the timing faster than
;          one bit time every six frames (part of the USB spec)
;------------------------------------------------------------------------------
DoTimingChange:
  PUSH EAX,BX,CX,DX,DI,DS           ;Save used registers
  MOV  BP,I14RErrTimingOwned        ;Assume there's not a Timing Owner
  CMP  ES:[TimingCallBackAddr],0    ;Is there a Timing Owner?
  JE  >C70                          ;If not, error
  MOV  BP,I14RErrRequestHandle      ;Assume Bad Handle Number
  MOV  BX,[SI].I14RRequestHandle    ;Is the Handle Number
  CMP  BX,ES:[TimingHandle]         ;  what it needs to be?
  JNE >C70                          ;If not, Error
  MOV  BP,I14RErrTmgChgInProg       ;Assume a change is already in progress
  TEST ES:[TSRFlags],TimingChanging ;Already in the middle of a change?
  JNZ >C70                          ;If so, error
  MOV  BP,I14RErrTimingLimit        ;Assume Timing is already at a limit
  CMP  AL,127                       ;Is it an allowable value?
  JA  >C70                          ;If not, error
  MOV  BL,SOFModify                 ;Point at SOFModify Offset
  OR   ES:[TSRFlags],TimingChanging ;Mark as in the middle of changing timing
  PUSH [SI].I14RUserPktID           ;Store the
  POP  ES:[TimingChgUserPktID]      ;  User Packet ID
  PUSH [SI].I14RCallBackAddr        ;Store the
  POP  ES:[TimingChgCallBackAddr]   ;  Call Back Address
  MOV  DS,ES                        ;Point DS at TSR Data Area
  CALL TestHostHalted               ;Is the Host running right now?
  JZ  >C20                          ;If so, we need to schedule it
  CALL WriteHostWord                ;If not, change it right now
  CALL FinishUpTimingChange         ;Notify everybody that we're done
  JMP >C80                          ;Done
C20:                                ;Host is running - Schedule Change Slowly
  MOV  DI,Int14Request4             ;Point at Request Structure
  MOV  TimingChangeTarget,AL        ;Store the Timing Target Value
  MOV  [DI].I14RRequestType,I14RRTDoInterrupt1T ;Request = 1-time Interrupt
  MOV  [DI].I14RPeriodicity,6       ;6 ms
  MOV  W [DI].I14RCallBackAddr[0],FrameTimingFarCall ;Code to call when done
  CALL DoInt14CallDI                ;Schedule it
  JMP >C80                          ;Done
C70:                                ;Error (BP = Error Code)
  STC                               ;Set Error Flag
  JMP >C90                          ;Done
C80:                                ;OK
  CLC                               ;Set OK Flag
C90:                                ;Done
  POP  DS,DI,DX,CX,BX,EAX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs:  BX = TSR Data Segment we need to use
;         TimingChangeTarget
;------------------------------------------------------------------------------
FrameTimingFarCall:
  CALL CopyBX2DSES           ;Point DS & ES at TSR Data Area
  MOV  BL,SOFModify          ;Read the Current
  CALL ReadHostByte          ;  SOFModify register
  CMP  AL,TimingChangeTarget ;Is it at the Target value yet?
  JE  >F50                   ;If so, we're done!
  JA  >F20                   ;If it's too big, jump to decrement
  INC  AL                    ;Increment it
  JMP >F30                   ;Change it
F20:                         ;Need to decrement
  DEC  AL                    ;Decrement it
F30:                         ;Change Timing
  CALL WriteHostWord         ;Change it
  CMP  AL,BH                 ;Is it where it's supposed to be yet?
  JE  >F50                   ;If so, we're done
  MOV  DI,Int14Request4      ;If not,
  CALL DoInt14CallDI         ;  Reschedule the one-time Interrupt
  JMP >F90                   ;Done
F50:                         ;Timing is changed
  CALL FinishUpTimingChange  ;Notify everybody that we're done
F90:                         ;Done
  RETF

;------------------------------------------------------------------------------
;HANDLE THE END OF A TIMING CHANGE PROCESS (DO ALL NOTIFICATIONS)
;Inputs:  DS =ES = TSR Data Area
;         [TimingChgCallbackAddr], [TimingChgUserPktID]
;Outputs: Notifies Timing Caller that the Timing is Changed
;         Notifies Timing Owner, Interface Owners, and Device 0 Owners of Change
;Changes:
;------------------------------------------------------------------------------
FinishUpTimingChange:
  PUSH AX,BX,CX,DX,DI                  ;Save used registers
  CALL GetFrameTiming                  ;Put Frame Timing
  MOV  CX,AX                           ;  in CX
  XOR  AX,AX                           ;AX = 0
  MOV  DX,-1                           ;DX = -1
  MOV  BX,[TimingChgUserPktID]         ;BX = User Packet ID
  MOV  DI,OFFSET TimingChgCallBackAddr ;[DI] = Address to call
  CALL DoFarCall                       ;Inform the Caller
  MOV  AX,OwnerCallTimingChg           ;Call Code = Timing Change
  MOV  DX,CX                           ;DX = Frame Timing
  MOV  CL,[USBHostIndex]               ;CL = Host Index
  MOV  CH,-1                           ;CH = -1
  CALL NotifyTimingOwner               ;Notify Timing Owner
  CALL NotifyIntfOwnersAll             ;Notify all Interface Owners
  CALL NotifyDvc0Owners                ;Notify Device 0 Owners
  AND  [TSRFlags],(NOT TimingChanging) ;Mark Timing Change as complete
  POP  DI,DX,CX,BX,AX                  ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE FOR THE USB HARDWARE INTERRUPT (IRQ)
;THESE FUNCTIONS ARE CALLED EVERY TIME SOMETHING HAPPENS TO CAUSE AN IRQ
;ALSO NOTE THAT BECAUSE IRQ's CAN BE SHARED ON A PCI BUS, THE USB INTERRUPT
;  CAN ACTUALLY BE GENERATED BY A DIFFERENT DEVICE (A DIFFERENT USB HOST
;  CONTROLLER, OR EVEN A COMPLETELY UNRELATED TYPE OF DEVICE).
;SHARING IRQ's IS ACTUALLY NOT THAT DIFFICULT.  YOU JUST NEED TO CHECK AND
;  SEE WHAT HAS CHANGED SINCE THE LAST INTERRUPT TO MAKE SURE THAT THE
;  IRQ IS REALLY FOR YOU, AND ALSO ALLOW ALL OF THE OTHER IRQ SOFTWARE TO
;  PROCESS THE IRQ AFTER YOU GET DONE.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;DO THIS EVERY TIME THE USB INTERRUPT OCCURS
;Inputs:  ES = TSR Data Area (Original ES on Stack)
;Outputs:
;Changes:
;------------------------------------------------------------------------------
USBIntCode:
  PUSHF                           ;Save flags
  STI                             ;Enable Interrupts
  CLD                             ;Go forward with string functions
  CALL MakeStack                  ;Set up our own stack space
  PUSH DS                         ;Save used registers
  MOV  DS,ES                      ;Point DS at TSR Data Area
  CALL TestUSBIntPending          ;Anything to do on this Host?
  JZ  >U10                        ;If not, we're done
  PUSHAD                          ;Save all registers
  INC  [USBIntCount]              ;Increment our Counter
  CALL HandleUSBErrs              ;Handle Major USB Bus Errors
  CALL UpdateTDs                  ;Handle/update the completed TD's
  CALL VerifyCtrlTDsScheduled     ;Make sure all Control TD's are Scheduled
  CALL VerifyBulkTDsScheduled     ;Make sure all Bulk TD's are Scheduled
  POPAD                           ;Restore all registers
  NOP                             ;POPAD Bug Fix
U10:                              ;Done doing what we need to do
  TEST [USBIntHdr].EOIFlag,80h    ;Did we turn on the IRQ in the PIC?
  JNZ >U50                        ;If so, jump to handle last vector in chain
  POP  DS                         ;Restore used registers
  CALL ReturnStack                ;Restore the Stack Space
  POPF                            ;Restore original
  PUSHF                           ;  calling flags
  CALL D ES:[USBIntHdr].OldVector ;Call the Old Interrupt Vector
  CALL RestoreIRQ                 ;Restore the original IRQ Mask
  POP  ES                         ;Restore used registers
  IRET

U50:                  ;We ARE the last Int Handler in the chain
  CALL ResetUSBIntPIC ;Tell the PIC we're done with the Int
  POP  DS             ;Restore used registers
  CALL ReturnStack    ;Restore the Stack Space
  POPF                ;Restore flags
  POP  ES             ;Restore used registers
  IRET

;------------------------------------------------------------------------------
;DISABLE/RESTORE THE USB IRQ
;Inputs:  ES = TSR Data Area
;         ES:[USBIRQNum]
;Outputs: [OrigIRQMask]
;         Disables/Restores the USB IRQ as appropriate
;Changes:
;We may not need this in the TSR any more (we REM'd them out of USBIntCode)
;------------------------------------------------------------------------------
RestoreIRQ:
  PUSH CX                  ;Save used registers
  MOV  CH,-1               ;Mark as restoring
  JMP >Q00                 ;Do it
DisableIRQ:
  PUSH CX                  ;Save used registers
  XOR  CH,CH               ;Mark as a Disable
;  JMP >Q00                 ;Do it
Q00:
  PUSH AX,DX               ;Save used registers
  PUSHF                    ;Save Flags
  MOV  CL,ES:[USBIRQNum]   ;Get the IRQ Number
  MOV  DX,(PIC1Addr+1)     ;Assume it's on the first PIC
  CMP  CL,8                ;Is it on the first PIC?
  JB  >Q20                 ;If so, continue
  MOV  DX,(PIC2Addr+1)     ;  it's on
  SUB  CL,8                ;It's on the second PIC
Q20:                       ;PIC is known
  CLI                      ;Disable interrupts
  IN   AL,DX               ;Get the current PIC mask
  OR   CH,CH               ;Are we Restoring or Disabling?
  JNZ >Q40                 ;If Restoring, jump to handle it
Q30:                       ;Disabling
  MOV  AH,01h              ;Calculate the IRQ Enable Mask
  SHL  AH,CL               ;  for the PIC
  TEST AL,AH               ;Is the IRQ already Disabled?
  JZ  >Q35                 ;If not, jump to Disable it
  MOV  ES:[OrigIRQMask],0  ;If so, mark it as already Disabled
  JMP >Q90                 ;Done
Q35:                       ;Need to Disabel IRQ
  MOV  ES:[OrigIRQMask],AH ;Save Disable mask bit
  OR   AL,AH               ;Mask in the Disable Bit
  JMP >Q80                 ;Jump to set it
Q40:                       ;Restoring
  MOV  AH,ES:[OrigIRQMask] ;Get original Mask
  OR   AH,AH               ;Do we need to Enable it?
  JZ  >Q90                 ;If not, we're done
  NOT  AH                  ;If so, Enable
  AND  AL,AH               ;  the appropriate IRQ bit
Q80:                       ;Need to update IRQ Disable/enable status
  OUT  DX,AL               ;Send the IRQ Mask
Q90:                       ;Done
  POPF                     ;Restore Flags
  POP  DX,AX               ;Restore used registers
  POP  CX                  ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO HANDLE POSSIBLE PROBLEMS WITH SHARED IRQ'S ON THE USB INTERRUPTS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;TEST AND SEE IF THIS USB HOST HAS AN INTERRUPT PENDING
;Inputs:  ES = TSR Data Area
;         [PCIDevFunc]
;Outputs: ZF = Clear if an Interrupt is Pending on this Host
;            = Set if no Interrupt is actually Pending
;Changes:
;------------------------------------------------------------------------------
TestUSBIntPending:
  PUSH AX,BX                  ;Save used registers
  MOV  BL,PCILegacySupp       ;Get the Legacy Support Register
  CALL ReadPCIWord            ;  from the USB Controller
  TEST AH,(LSUSBIRQSts SHR 8) ;Set the Return Flag
  POP  BX,AX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TELL THE PIC(s) THAT WE'RE DONE PROCESSING THE USB INTERRUPT
;Inputs:  ES = TSR Data Area
;         [USBIRQNum]
;Outputs:
;Changes: Tells the PIC(s) that we're done
;------------------------------------------------------------------------------
ResetUSBIntPIC:
  PUSH AX                                   ;Save used registers
  PUSHF                                     ;Save flags
  CLI                                       ;Disable interrupts
  CMP  ES:[USBIRQNum],7                     ;Is the USB IRQ on PIC 1?
  JBE >P60                                  ;If so, don't mess with PIC 2
P10:                                        ;IRQ is on PIC 2
  MOV  AL,OCW2SelectOCW2+OCW2NonSpecificEOI ;Non-specific EOI
  OUT  PIC2Addr,AL                          ;Send to PIC2
  MOV  AL,OCW3SelectOCW3+OCW3ReadISR        ;Get the
  OUT  PIC2Addr,AL                          ;  Interrupt In-Service Register
  MOV  AX,AX                                ;  from
  IN   AL,PIC2Addr                          ;  PIC 2
  OR   AL,AL                                ;Other Ints still being serviced?
  JNZ >P90                                  ;If so, don't reset PIC 1 yet
P60:                                        ;Issue EOI to PIC1
  MOV  AL,OCW2SelectOCW2+OCW2NonSpecificEOI ;Non-specific EOI
  OUT  PIC1Addr,AL                          ;Send to PIC1
P90:                                        ;Done
  POPF                                      ;Restore flags
  POP  AX                                   ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO HANDLE HOST-LEVEL ERRORS ON THE USB HOST
;  In theory, these should never happen!
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;RESET HOST ERROR STATUS BITS, AND HANDLE "SYSTEM" LEVEL ERRORS
;Inputs:  DS = ES = TSR Data Area
;Outputs:
;Changes: "Resets" Error Status bits in Host
;         If Host-level error, notifies Interface/Timing Owners, and then
;           issues request to Reset Host
;------------------------------------------------------------------------------
HandleUSBErrs:
  PUSH AX,BX,DX,SI           ;Save used registers
  MOV  BL,USBStatus          ;Get the USB
  CALL ReadHostWord          ;  Status Register
  AND  AX,USErrorMask        ;Mask out everything except Errors we care about
  CALL WriteHostWord         ;Clear them out for the next Interrupt
  TEST AL,(USProcessorErr+USSystemErr) ;Host HW Error?
  JZ  >E90                   ;If not, we're done
  MOV  AX,OwnerCallHostHWErr ;If so, Owner Call = Host HW Error
  MOV  DL,[USBHostIndex]     ;Put Host Index in DL
  CALL NotifyDvcOwnersOfHost ;Notify Interface/Timing Owners (uses AX & DL)
  MOV  SI,Int14Request       ;Point at Request Structure
  MOV  [SI].I14RRequestType,I14RRTHostReset ;Request = Reset Host
  MOV  W [SI].I14RCallBackAddr[0],-1        ;No notification when done
  CALL DoInt14CallSI         ;Do it
E90:                         ;Done
  POP  SI,DX,BX,AX           ;Restore used registers
  RET

;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO UPDATE/RESCHEDULE/TEST VARIOUS TYPES OF TRANSFER DESCRIPTORS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;UPDATE ALL OF THE TRANSFER DESCRIPTORS THAT HAVE COMPLETED
;Inputs:  Transfer Descriptor Table
;         DS = ES = Segment containing TD's
;Outputs:
;Changes: Issues IOC's to the appropriate calling Program
;         Updates periodic TD's, Releases completed TD's as appopriate
;------------------------------------------------------------------------------
UpdateTDs:
  PUSH EAX,DI                    ;Save used registers
  MOV  DI,TDOffset               ;Beginning of Table
S10:                             ;Loop to here for each table entry
  CALL GetTDType                 ;Get the Type of TD
  CMP  AL,TDTypeReserved         ;Is it available or reserved?
  JBE >S70                       ;If so, we don't need to do anything
  CMP  AL,TDTypeControlSetup     ;Is it a Control TD?
  JB  >S15                       ;If not, it can't be On Hold
  CMP  AL,TDTypeControlStatus    ;Is it a Control TD?
  JA  >S15                       ;If not, it can't be On Hold
  TEST [DI].TDFlags,TDFlagOnHold ;If so, is it On Hold?
  JNZ >S70                       ;If so, no need to update it
S15:                             ;Not On Hold
  TEST B [DI].TDControlStatus[2],(TDActive SHR 16) ;Has the TD been retired?
  JZ  >S50                       ;If so, Update it
  CMP  AL,TDTypeInterruptPer     ;Periodic Interrupt?
  JE  >S20                       ;If so, check for NAKs
  CMP  AL,TDTypeIsoch            ;Isochronous?
  JNE >S30                       ;If not, no need to test for NAKs
S20:                             ;Need to check for NAK's
  TEST B [DI].TDControlStatus[2],(TDNAKReceived SHR 16) ;Was it a NAK?
  JNZ >S50                       ;If so, we need to Update it
S30:                             ;Need to test for Timeout
  CALL TestTDOverDue             ;Is it an OverDue Periodic Int or Isoch TD?
  JC  >S50                       ;If so, we need to Update it
  CALL TestTDTimeout             ;Is it a Timed-Out Bulk or Control TD?
  JNC >S70                       ;If not, no need to update it
S50:                             ;Need to update the TD
  CALL UpdateTD                  ;If not, go ahead and handle it
S70:                             ;Done with this one
  ADD  DI,TDSize                 ;Point at the next one
  CMP  DI,(TDOffset+(TDEntries*TDSize)) ;Done the whole table yet?
  JB   S10                       ;If not, keep looking
  CALL ActivateTDsOnHold         ;Activate any TD's that may be On Hold
  POP  DI,EAX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;UPDATE A PARTICULAR TRANSFER DESCRIPTOR THAT HAS BEEN COMPLETED
;Inputs:  DS = ES = Segment containing TD's
;         DI = Pointer to TD that has been completed
;Outputs:
;Changes: Issues IOC to the appropriate calling Program
;         Updates TD if periodic or long Transaction
;         Releases TD if complete
;------------------------------------------------------------------------------
UpdateTD:
  PUSH EAX,BX,CX,DX         ;Save used registers
  CALL TestTDError          ;Test for errors
                            ;  Returns DX = Error Code
                            ;  CX = Actual Data Size Xfered
  CALL GetTDType            ;Get the Type of TD (returns AL)
  MOV  BX,UpdateTDTbl       ;Point at the Table of Code Offsets
  CALL SearchByte2WordTblCS ;Is there a match?
  JC  >U85                  ;This should never happen, but if it does,
                            ;  just release the TD
  CALL BX                   ;Do the Appropriate Code!
  JNC >U90                  ;If the Transaction isn't complete, quit
U80:                        ;Do Far Call for completed Transaction
  CALL DoUserFarCall        ;Do the Far Call
U85:                        ;No need to do Call Back
  CALL ReleaseTD            ;Done with the TD
U90:                        ;We're done
  POP  DX,CX,BX,EAX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A TRANFER DESCRIPTOR RETURNED WITH AN ERROR
;Inputs:  DS = ES = Data area that TD is in
;         DI = Pointer to TD to check
;Outputs: DX = Appropriate Error Code(s) associated with the status
;              TDStsNAK, TDStsStalled, etc.
;         CX = Actual Data Size transferred
;         ZF = Set if No Error (DX = 0)
;            = Clear if Error (DX <> 0)
;Changes:
;------------------------------------------------------------------------------
TestTDError:
  PUSH AX                              ;Save used registers
  MOV  DX,TDStsOK                      ;Start Error at (ACK Received)
  MOV  AX,W [DI].TDControlStatus[2]    ;Get the TD Status Word
  TEST AL,(TDNAKReceived SHR 16)       ;Was a NAK Received
  JZ  >E10                             ;If not, try the next possibility
  OR   DL,TDStsNAKReceived             ;Set Error Flag
E10:                                   ;NAK Handled
  TEST AL,(TDStalled SHR 16)           ;Was it Stalled?
  JZ  >E20                             ;If not, try the next possibility
  OR   DL,TDStsStalled                 ;Set Error Flag
E20:                                   ;Stall Handled
  TEST AL,(TDBabbleDetected SHR 16)    ;Was Babble Detected?
  JZ  >E30                             ;If not, try the next possibility
  OR   DL,TDStsBabbleDetected          ;Set Error Flag
  AND  DL,(NOT TDStsStalled)           ;UHCI sets Stalled also
E30:                                   ;Babble Handled
  TEST AL,(TDCRCTOReceived SHR 16)     ;Was a CRC or TimeOut Received?
  JZ  >E40                             ;If not, try the next possibility
  OR   DL,TDStsCRCTOReceived           ;Set Error Flag
  AND  DL,(NOT TDStsStalled)           ;UHCI sets Stalled also
E40:                                   ;CRC/TO Handled
  TEST AL,(TDBitStuffError SHR 16)     ;Was there a Bit-Stuffing Error?
  JZ  >E50                             ;If not, try the next possibility
  OR   DL,TDStsBitStuffError           ;Set Error Flag
  AND  DL,(NOT TDStsStalled)           ;UHCI sets Stalled also
E50:                                   ;Bit Stuff Error Handled
  TEST AL,(TDDataBuffErr SHR 16)       ;Was there a Data Buffer Error?
  JZ  >E60                             ;If not, try the next possibility
  OR   DH,(TDStsDataBuffErr SHR 8)     ;Set Error Flag
  AND  DL,(NOT TDStsStalled)           ;UHCI sets Stalled also
E60:                                   ;Data Buffer Error Handled
  CALL TestTDTimeout                   ;Test for TimeOut
  JNC >E70                             ;If no timeout, continue
  OR   DL,TDStsTimeout                 ;If Timeout, Set error flag
E70:                                   ;TimeOut handled
  CALL TestTDOverDue                   ;Test for OverDue
  JNC >E80                             ;If not OverDue, continue
  OR   DL,TDStsOverDue                 ;If OverDue, Set error flag
E80:                                   ;OverDue error handled
  CALL GetTDActualLength               ;Get the Actual Length (CX)
  TEST AH,(TDShortPacketDetect SHR 24) ;Do we even need to test Packet Length?
  JZ  >E90                             ;If not, Return Code is OK
  CALL GetTDMaxLength                  ;Get the Max Length (AX)
  CMP  AX,CX                           ;Are they the same?
  JE  >E90                             ;If so, there's no error
  OR   DL,TDStsShortPacket             ;If not, it's a Short Packet Error
  AND  DL,(NOT TDStsStalled)           ;UHCI sets Stalled also?
E90:                                   ;We're done
  OR   DX,DX                           ;Set the return flag
  POP  AX                              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A TD IS "OVERDUE", BUT IS NOT YET DE-ACTIVATED
;Inputs:  DS = ES = TSR Data Area
;         [DI] = TD to test
;Outputs: CF = Set if TD is "overdue"
;            = Clear if TD is still really Pending
;Changes:
;NOTES: This type of test is needed because some TD simply "get lost",
;         and do not ever get shipped across the USB Bus.  This could
;         either be because of a scheduling problem (the Bus is too full),
;         or slow IRQ-Handling Code, or a host of other reasons.
;       We only need to do this for Interrupt and Isoch TDs,
;         which are put directly into the Frame List.  If one of these TDs
;         is "skipped" for some reason, it will be 1024 more Frames (more than
;         a second) before the TD will be attempted again.
;         Any TD that is actually sent across the Bus will be marked as
;         Inactive by the Host whether it was successful or not, but any TDs
;         that are "skipped" will not.
;       TDs that are in a fixed Queue (Control & Bulk) will be attempted again
;         the very next Frame, so that is not a problem.  Also, Control & Bulk
;         are NEVER supposed to be time-sensitive, so it really doesn't
;         matter that much if they get delayed for a little while, anyway.
;------------------------------------------------------------------------------
TestTDOverDue:
  PUSH AX,BX,CX                ;Save used registers
  PUSHF                        ;Save flags
  CLI                          ;Disable interrupts
  CALL GetTDType               ;AL = TD Type
  CMP  AL,TDTypeIsoch          ;Isochronous?
  JE  >O20                     ;If so, handle it
  CMP  AL,TDTypeInterruptPer   ;Periodic Interrupt?
  JE  >O20                     ;If so, handle it
  CMP  AL,TDTypeInterrupt1Time ;One-time Interrupt?
  JNE >O80                     ;If not, it can't be OverDue
O20:                           ;Is correct TD Type
  XOR  BL,BL                   ;Initialize BL for the call
  CALL GetTimeTilRpt           ;See if it's OverDue (returns BL, CX)
  OR   BL,BL                   ;Is it Overdue?
  JZ  >O80                     ;If not, we're done
  CMP  CX,2                    ;Is it more than two Frame overdue?
  JBE >O80                     ;If not, it's OK
O70:                           ;TD is OverDue
  POPF                         ;Restore flags
  STC                          ;Set OverDue Flag
  JMP >O90                     ;Done
O80:                           ;TD is not OverDue
  POPF                         ;Restore flags
  CLC                          ;Set OK Flag
O90:                           ;Done
  POP  CX,BX,AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A TD HAS TIMED OUT
;Inputs:  DS = ES = TSR Data Area
;         [DI] = TD to test
;Outputs: CF = Set if TD has Timed Out
;            = Clear if TD does not have timeout, or is still waiting
;Changes:
;NOTES: In addition to checking Timeouts, this code also checks to make
;         sure Control TD's are actually scheduled in the Control Queue.
;         For some unknown reason, this doesn't always happen!
;------------------------------------------------------------------------------
TestTDTimeout:
  PUSH AX,CX,DI               ;Save used registers
  CALL GetTDType              ;Get the Type of TD
  CMP  AL,TDTypeBulk          ;Bulk TD?
  JE  >T20                    ;If so, test it
  CMP  AL,TDTypeControlSetup  ;Control TD?
  JB  >T80                    ;If not, no need to test
  CMP  AL,TDTypeControlStatus ;Control TD
  JA  >T80                    ;If not, no need to test
T20:                          ;Test Timeout
  MOV  CL,[DI].TDTimeOutIndex ;Get Timeout Index
  CALL TTIndex2Offset         ;Convert Index to an offset (DI)
  CMP  [DI].TTDelayCounter,0  ;Counted down to 0 yet?
  JNE >T80                    ;If not, keep waiting
T70:                          ;Timeout has occurred
  STC                         ;Set Timeout Flag
  JMP >T90                    ;Done
T80:                          ;Not timed out yet
  CLC                         ;Set OK flag
T90:                          ;Done
  POP  DI,CX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;VERIFY THAT ALL CONTROL TD's ARE SCHEDULED
;Inputs:  ES = TSR Data Area
;Outputs:
;Changes:
;------------------------------------------------------------------------------
VerifyCtrlTDsScheduled:
  PUSH AX,CX,DI,SI,DS         ;Save used registers
  PUSHF                       ;Save flags
  CLI                         ;Disable Interrupts
  MOV  DS,ES                  ;Point DS at TSR Data Area
  MOV  DI,TDOffset            ;Point at TD's
  MOV  CX,TDEntries           ;Number of Entries to test
  MOV  SI,DS:[QHTable]        ;[SI] = Control QH
V10:                          ;Loop to here for each TD
  CALL GetTDType              ;Get the Type of TD
  CMP  AL,TDTypeControlSetup  ;Control TD?
  JB  >V50                    ;If not, no need to test
  CMP  AL,TDTypeControlStatus ;Control TD
  JA  >V50                    ;If not, no need to test
  CALL VerifyTDScheduled      ;See if it's scheduled
  JNC >V50                    ;If it is, continue
  CMP  AL,TDTypeControlData   ;What type of TD is it?
  JE  >V32                    ;If Data, jump to handle it
  JA  >V34                    ;If Setup, jump to handle it
V30:                          ;Control Setup
  CALL AddSetupTD2ControlQH   ;Reschedule it
  JMP >V50                    ;Keep checking
V32:                          ;Control Data
  CALL AddDataTD2ControlQH    ;Reschedule it
  JMP >V50                    ;Keep checking
V34:                          ;Control Status
  CALL AddStatusTD2ControlQH  ;Reschedule it
;  JMP >V50                    ;Keep checking
V50:                          ;Go to next TD
  ADD  DI,TDSize              ;Point at next TD
  LOOP V10                    ;Keep looking
V90:                          ;Done
  POPF                        ;Restore flags
  POP  DS,SI,DI,CX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;VERIFY THAT ALL BULK TD's ARE SCHEDULED
;Inputs:  ES = TSR Data Area
;Outputs:
;Changes:
;NOTE: It really pisses me off that I need to do this!
;------------------------------------------------------------------------------
VerifyBulkTDsScheduled:
  PUSH AX,BX,CX,DI,DS         ;Save used registers
  PUSHF                       ;Save flags
  CLI                         ;Disable Interrupts
  MOV  DS,ES                  ;Point DS at TSR Data Area
  MOV  DI,TDOffset            ;Point at TD's
  MOV  CX,TDEntries           ;Number of Entries to test
B10:                          ;Loop to here for each TD
  CALL GetTDType              ;Get the Type of TD
  CMP  AL,TDTypeBulk          ;Is it Bulk?
  JNE >B50                    ;If not, no need to test
  TEST B [DI].TDControlStatus[2],(TDActive SHR 16) ;If so, is it still Active?
  JZ  >B50                    ;If not, no need to test
  MOV  BX,[DI].TDBulkQHOffset ;Get the QH Pointer
  TEST B [BX].QHElementPointer[0],QHTerminate ;Is there anything in the Queue?
  JZ  >B50                    ;If so, assume everything's OK
B20:                          ;Loop to here to find the first TD
  CALL FindTDInOtherTDs       ;Is this TD pointed at by another TD?
  JNC  B20                    ;If so, keep going until we find the first TD
                              ;  (uses DI, returns DI & CF)
  CALL AddTD2BulkQH           ;Add the first TD to the Queue
B50:                          ;Go to next TD
  ADD  DI,TDSize              ;Point at next TD
  LOOP B10                    ;Keep looking
B90:                          ;Done
  POPF                        ;Restore flags
  POP  DS,DI,CX,BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHECK AND SEE IF A PARTICULAR TD IS SCHEDULED IN A QUEUE
;Inputs:  DS = ES = TSR Data Area
;         DI = TD to Test
;         SI = Queue Head that TD should be in
;         CLI already issued
;Outputs: CF = Clear if TD is scheduled in Queue
;            = Set if not scheduled
;Changes:
;------------------------------------------------------------------------------
VerifyTDScheduled:
  PUSH EAX,EBX,DI                ;Save used registers
V10:                             ;TD is Control
  CALL SegOff2PhysAddrESDI       ;Convert TD pointer to a Phys Addr (EAX)
  MOV  EBX,EAX                   ;Save it in EBX
  MOV  EAX,[SI].QHElementPointer ;Get the first TD in the Queue
V20:                             ;Loop to here for each TD
  TEST AL,QHTerminate            ;Valid Address?
  JNZ >V70                       ;If not, it's not scheduled
  AND  AL,(QHAddrMask AND 0FFh)  ;Mask out the Flags (just leave the Address)
  CMP  EAX,EBX                   ;Is it our TD?
  JE  >V80                       ;If so, it's scheduled
  CALL PhysAddr2SegOff           ;If not, point DI at the TD
  MOV  EAX,[DI].TDLinkPointer    ;Get the next TD in the Queue
  JMP  V20                       ;Keep going until we're at the end of the Queue
V70:                             ;Not scheduled
  STC                            ;Set not scheduled flag
  JMP >V90                       ;Done
V80:                             ;Scheduled
  CLC                            ;Set scheduled flag
V90:                             ;Done
  POP  DI,EBX,EAX                ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO UPDATE AN ISOCHRONOUS TD
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

#IF LITE ;UpdateIsochTD

  UpdateIsochTD:
    MOV  BP,I14RErrRequestType ;Error = Request Type
    STC                        ;Set Error Flag
    RET

#ELSE ;UpdateIsochTD

;------------------------------------------------------------------------------
;UPDATE AN ISOCHRONOUS TD TO BE USED AGAIN
;Inputs:  ES = DS = Segment containing TD's
;         DI = Pointer to TD that needs to be Updated
;         CX = Actual Data Size Xfered in Packet
;         DX = Packet Error Code
;Outputs: CF = Clear (Transaction is Incomplete)
;         Updates appropriate values in TD so it can be used again
;Changes:
;NOTES: Isoch should always be DATA0!!
;------------------------------------------------------------------------------
UpdateIsochTD:
  PUSH AX                        ;Save used Registers
  PUSHF                          ;Save Flags
  XOR  AH,AH                     ;Get the
  MOV  AL,B [DI].TDIsochSequence ;  Sequence Number
  CALL DoUserFarCallAXDX         ;Notify User (return a value AX -> DX)
  CLI                            ;Disable Interrupts
  CALL ResetIntIsochTD           ;Reset TD for next time
  CALL RemoveTDReferences        ;Remove from FL
  CALL AddIsochTD2FL             ;Reschedule it
  POPF                           ;Restore Flags
  CLC                            ;Mark as not done yet
  POP  AX                        ;Restore used registers
  RET

#ENDIF ;UpdateIsochTD


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO UPDATE A PERIODIC INTERRUPT TD
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;UPDATE A PERIODIC INTERRUPT TD TO BE USED AGAIN
;Inputs:  ES = DS = Segment containing TD's
;         DI = Pointer to TD that needs to be Updated
;         CX = Actual Data Size Xfered in Packet
;         DX = Packet Error Code
;Outputs: CF = Clear (Transaction is Incomplete)
;         Updates appropriate values in TD so it can be used again
;Changes:
;------------------------------------------------------------------------------
UpdateInterruptPerTD:
  PUSH AX,CX,DI                ;Save used registers
  PUSHF                        ;Save Flags
  CALL GetFirstIntTD           ;Is it in a Queue (rtns DI)?
  JC  >P50                     ;If not, just do a single TD
  XOR  AX,AX                   ;Start Byte counter at 0
  CLI                          ;Disable interrupts
P10:                           ;Loop to here for each TD in the Queue
  CALL GetTDActualLength       ;Get number of bytes Xfered (CX)
  ADD  AX,CX                   ;Add it to the Total
  CALL TestTDError             ;Test TD for Errors (DX & ZF)
  JNZ >P20                     ;If error, handle it
  CALL GetNextIntTD            ;Point at the next TD
  JNC  P10                     ;If not last one, keep looking
P20:                           ;Done with TD's
  MOV  CX,AX                   ;Put Total bytes in CX for the Call
  CALL DoUserFarCall           ;Notify User
  CALL GetFirstIntTD           ;Point back at the First TD
P30:                           ;Loop to here for each TD in the Queue
  CALL ResetIntIsochTD         ;Reset TD for next time
  TEST DX,(TDStsCRCTOReceived+TDStsNAKReceived+TDStsOverDue) ;Did Device even respond?
  JNZ >P40                     ;If not, don't update DataX
  CALL SetData1ForBulkIntTD    ;If so, set Data1 as appropriate
P40:                           ;Data1 handled as appropriate
  CALL GetNextIntTD            ;Point at the next TD
  JNC  P30                     ;If another TD is looming, keep going
  CALL RebuildIntQHGivenTD     ;Rebuild the QH (Host may have messed it)
  CALL RemoveQHRefGivenTD      ;Unschedule the QH
  JMP >P80                     ;Jump to reschedule it
P50:                           ;TD not in a Queue
  CALL DoUserFarCall           ;Notify User
  CLI                          ;Disable Interrupts
  TEST DX,(TDStsCRCTOReceived+TDStsNAKReceived+TDStsOverDue) ;Did Device even respond?
  JNZ >P60                     ;If not, don't toggle DataX
  CALL SetData1ForBulkIntTD    ;Set Data1 as appropriate
P60:                           ;Done toggling DataX
  CALL ResetIntIsochTD         ;Reset TD for next time
  CALL RemoveTDReferences      ;Remove from FL
P80:                           ;Reschedule the TD
  MOV  CX,W [DI].TDPeriodicity ;Get Periodicity
  CALL AddPerIntTD2FL          ;Schedule it again
P90:                           ;Done
  POPF                         ;Restore Flags
  CLC                          ;Mark as not done yet
  POP  DI,CX,AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;REBUILD AN INTERRUPT QUEUE THAT THE HOST MIGHT HAVE MESSED UP
;Inputs:  ES = DS = Segment containing TD's
;         DI = Pointer to TD in the Queue
;Outputs:
;Changes:
;NOTES: If a TD that is in a QH is successful, the Host Driver automatically
;         "unschedules" the TD from the QH.  So, if things are successful,
;         the Queue will actually be empty at the end of an Interrupt
;         that requires a Queue.  Therefore, we need to rebuild it before
;         we can  reschedule it.
;       This assumes that we already know that the Int requires a Queue,
;         which means it has more than one TD.  In addition, it assumes that
;         the only thing the Host messes up is the QHElementPointer, so that
;         all we need to do is reschedule the first TD into the QH.  The
;         TDLinkPointers in all of the TD's will then keep the QH intact
;         as it was when we originally scheduled it.
;------------------------------------------------------------------------------
RebuildIntQHGivenTD:
  PUSH EAX,BX,DI                 ;Save used registers
  CALL GetIntQHPtrBX             ;Point BX at the QH
  CALL GetFirstIntTD             ;Point DI at the first TD in the Queue
  CALL SegOff2PhysAddrESDI       ;Convert it to a Physical Address
  OR   AL,TDDepthFirst           ;Mark it as Depth First
  MOV  [BX].QHElementPointer,EAX ;Store it (QHSelect=0, Terminate=0)
  POP  DI,BX,EAX                 ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO UPDATE A BULK TD
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;UPDATE A BULK TD
;Inputs:  DS = ES = Segment containing TD's
;         DI = Pointer to TD that needs to be Updated
;         CX = Actual Data Size Xfered in Packet
;         DX = Packet Error Code
;Outputs: CF = Set when entire Transaction is complete
;            = Clear if not completed yet
;         Can possibly modify DX (Error Code)
;         Will almost certainly modify CX (Actual Data Size)
;Changes:
;------------------------------------------------------------------------------
UpdateBulkTD:
  PUSH EAX,BX                        ;Save used registers
  PUSHF                              ;Save Flags
  CLI                                ;Disable interrupts
  CALL VerifyBulkTDsScheduled        ;Make sure all Bulk TD's are scheduled
  OR   DX,DX                         ;Was there an error?
  JNZ >B40                           ;If so, handle it
  CALL ResetCtrlBulkTD               ;Reset Errors and Counters
  MOV  BX,W [DI].TDBulkQHOffset      ;[BX] = Queue Head
  TEST [BX].QHFlags,QHFlagLastTDSent ;Have we sent all of the data yet?
  JNZ >B20                           ;If so, handle it
B10:                                 ;Not all data sent yet
  CALL SetBulkTDAddr                 ;Update TD with new info
  CALL AddTD2BulkQH                  ;Reschedule the TD
  JMP >B80                           ;Done
B20:                                 ;All data has been sent
  TEST [DI].TDFlags,TDFlagLastBulkTD ;Is this the last TD in the Queue?
  JNZ >B30                           ;If so, handle it
  CALL ReleaseTD                     ;If not, just release it
  JMP >B80                           ;Done
B30:                                 ;Last TD in Queue (Trans is complete!)
  MOV  CX,[DI].TDBytesToXfer         ;Total number of bytes in Transaction
  JMP >B60                           ;Done with Transaction
B40:                                 ;Error
  MOV  EAX,[DI].TDBuffPointer        ;Calculate the
  SUB  EAX,[DI].TDDataAddress        ;  TOTAL bytes transferred
  ADD  CX,AX                         ;  (for entire Trans)
B60:                                 ;Transaction is Complete
  CALL DoUserFarCall                 ;Inform User of Completion
  CALL ReleaseBulkQHGivenTD          ;Release the Queue & TD's
B80:                                 ;Transaction not done yet
  POPF                               ;Restore Flags
  CLC                                ;Mark Transaction as Incomplete
  POP  BX,EAX                        ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO UPDATE A ONE-TIME INTERRUPT TD
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;UPDATE A ONE-TIME INTERRUPT TD NEXT PACKET IN THE TRANSACTION
;Inputs:  ES = DS = Segment containing TD's
;         DI = Pointer to TD that needs to be Updated
;         DX = Error to be returned to calling program (0 if no error)
;Outputs: CF = Set when entire Transaction is completed
;              CX = 0 (Actual Data Size)
;              DX = 0 (Error Code)
;            = Clear if not completed yet
;              CX & DX Undefined
;         Updates appropriate values in TD so it can be used again
;Changes: CX
;------------------------------------------------------------------------------
UpdateInterrupt1TimeTD:
  PUSH AX                      ;Save used registers
  PUSHF                        ;Save Flags
  CLI                          ;Disable interrupts
  MOV  CX,W [DI].TDPeriodicity ;Get amount of time left to Delay
  JCXZ >O70                    ;If we're done waiting, quit
  CMP  CX,FLEntries            ;More than one time through FL?
  JAE >O10                     ;If so, handle it
  CALL RemoveTDReferences      ;If not, remove from FL
  MOV  W [DI].TDPeriodicity,0  ;Delay 0 milliseconds next time
  CALL Add1TimeIntTD2FL        ;Schedule it
  JMP >O80                     ;Done
O10:                           ;More than one time through FL
  MOV  AX,FLEntries            ;Calculate
  SUB  CX,AX                   ;  how long to
  XCHG AX,CX                   ;  wait next time
  MOV  W [DI].TDPeriodicity,AX ;Number of milliseconds to wait next time
  XOR  W [DI].TDLastFrameUsed,FLEntries ;Adjust Last Frame Used for OverDue
  CALL ResetIntIsochTD         ;Reset TD Errors and Re-Activate it
  JMP >O80                     ;Done
O70:                           ;Done waiting
  XOR  DX,DX                   ;Error Code = 0
  POPF                         ;Restore Flags
  STC                          ;Set Done flag
  JMP >O90                     ;Done
O80:                           ;Not Done Yet
  POPF                         ;Restore Flags
  CLC                          ;Set not Done Flag
O90:                           ;Done
  POP  AX                      ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO UPDATE A CONTROL TD
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;UPDATE A CONTROL TD FOR THE NEXT PACKET IN THE TRANSACTION
;Inputs:   DS  = ES = Segment containing TD's
;         [DI] = TD to be Updated
;          AL  = TDType
;          CX  = Actual Data Size Transferred in this Packet
;          DX  = Error to be returned to calling program (0 if no error)
;Outputs: CF = Set when entire Transaction is completed
;            = Clear if not completed yet
;         Can possibly modify DX (Error Code)
;         Will almost certainly modify CX (Actual Data Size)
;         Updates appropriate values in TD so it can be used again
;Changes:
;------------------------------------------------------------------------------
UpdateControlTD:
  PUSH AX                    ;Save used registers
  PUSHF                      ;Save Flags
  CLI                        ;Disable Interrupts
  CALL RemoveTDReferences    ;Unschedule the TD
  CALL ResetCtrlBulkTD       ;Reset Errors & Counter
  MOV  AH,TDPacketIn         ;Assume we'll do IN's
  CMP  AL,TDTypeControlData  ;Is it Setup, Data, or Status?
  JE  >C30                   ;If Data, jump to handle it
  JB  >C05                   ;If Setup, jump to handle it
  MOV  CX,[DI].TDBytesXfered ;CX = Number of Bytes Transferred in Data Stage
  JMP >C85                   ;Jump to handle Status stage
;-----
;Setup
;-----
C05:
  OR   DX,DX                 ;Was there an error?
  JZ  >C10                   ;If not, continue
  OR   DH,(TDStsControlSetup SHR 8) ;If so, mark it as occurring during Setup
  JMP >C80                   ;We're done
C10:                         ;No error
  CMP  [DI].TDBytesToXfer,0  ;Is there any data to transfer?
  JE  >C40                   ;If not, just do the Status with an IN
  TEST [DI].TDFlags,TDFlagIn ;If real data, is it IN?
  JNZ >C20                   ;If so, we're OK
  MOV  AH,TDPacketOut        ;If not, make it an OUT
C20:                         ;Direction is in AH
  MOV  B [DI].TDToken[0],AH  ;Store the Direction Type
  PUSH D [DI].TDDataAddress  ;Move data area of TD
  POP  D [DI].TDBuffPointer  ;  to real Data area
  XOR  CX,CX                 ;Mark bytes transferred so far as 0
  CALL UpdateBytesXfered     ;Update TD with bytes transferred
  CALL AddDataTD2ControlQH   ;Send it
  JMP >C70                   ;We're done for now
;----
;Data
;----
C30:                         ;Data
  CALL UpdateBytesXfered     ;Update the TD with bytes transferred
  JC  >C35                   ;If all data is transferred, handle it
  OR   DX,DX                 ;Was there an error?
  JNZ >C80                   ;If so, handle it
  CALL AddDataTD2ControlQH   ;If not, send it again
  JMP >C70                   ;We're done for now
C35:                         ;All data has been sent
  OR   DX,DX                 ;Was there an error?
  JNZ >C80                   ;If so, handle it
  TEST [DI].TDFlags,TDFlagIn ;Was it an OUT?
  JZ  >C40                   ;If so, AH is OK
  MOV  AH,TDPacketOut        ;If not, change it to an OUT
;----------------------
;Schedule Status Packet
;----------------------
C40:                         ;Schedule Status Packet (AH = Direction)
  MOV  B [DI].TDToken[0],AH  ;Store the Packet Type (In/Out)
  OR   W [DI].TDToken[2],((TDMaxLengthNUL+TDData1) SHR 16) ;Data1, Size = 0
  CALL AddStatusTD2ControlQH ;Send it
C70:                         ;Transaction is not complete yet
  POPF                       ;Restore Flags
  CLC                        ;Set the not complete flag
  JMP >C90                   ;We're done
C80:                         ;Transaction is done
  CALL TestControlShortPkt   ;Handle a Short Packet, if necessary
C85:                         ;Transaction is complete
  CALL TestCtlRetry          ;Test to see if we need to retry or not
                             ;  (may reinitialize & reschedule TD)
  JC   C70                   ;If we need to retry, we're not done yet
  CALL HandleSpecialControls ;Handle any Special Control Requests
  POPF                       ;Restore Flags
  STC                        ;Mark Transaction as Completed
C90:                         ;We're done
  POP  AX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST A CONTROL PACKET TO SEE IF IT NEEDS TO BE RETRIED OR NOT
;Inputs:   DS  = ES = Segment containing TD's
;         [DI] = Pointer to TD that needs to be tested
;          DX  = Error that will be returned if we don't retry
;         Interrupts Disabled
;Outputs: CF = Set if we need to retry
;                TD is reinitialized & scheduled
;            = Clear if TD is complete
;                (No Errors, or Retries are exhausted)
;Changes:
;------------------------------------------------------------------------------
TestCtlRetry:
  PUSH EAX,BX,CX,DI,SI           ;Save used registers
  OR   DX,DX                     ;Any errors?
  JZ  >Y80                       ;If not, no need to retry
  MOV  SI,DI                     ;Point [SI] at the TD
  MOV  CL,[DI].TDTimeoutIndex    ;Point [DI] at the
  CALL TTIndex2Offset            ;  Timeout entry
  XCHG SI,DI                     ;[SI] = Timeout entry, [DI] = TD
  TEST [SI].TTFlags,TTFlagSPktOK ;Is a Short Packet Error OK?
  JZ  >Y10                       ;If not, we need to retry
  CMP  DX,TDStsShortPacket       ;If so, is the only error a Short Packet?
  JE  >Y80                       ;If so, we won't retry
Y10:                             ;It's an Error - need to retry if possible
  CALL UpdateTTRetriesSI         ;Decrement the Retry Counter (uses [SI])
  JZ  >Y80                       ;If retries are exhausted, we won't retry
Y20:                             ;We need to retry
                                 ;  Many parts of TD are already set
  MOV  AX,[SI].TTOrigDelay       ;Reset
  MOV  [SI].TTDelayCounter,AX    ;  Timeout Counter
  MOV  AX,SetupReqSize           ;Set number of byte to Transfer
  CALL SetTDMaxLength            ;  in TD
  CALL FindSRGivenTD             ;Point [BX] at the Status Request
  PUSH ES                        ;Convert Setup Request Address
  PUSH BX                        ;  to a Physical Address
  POP  EAX                       ;  and store it
  CALL SegOff2PhysAddrEAX        ;  in the
  MOV  [DI].TDBuffPointer,EAX    ;  TD
  AND  B [DI].TDToken[2],(NOT (TDData1 SHR 16)) ;Make Data0
  MOV  [DI].TDBytesXfered,0      ;Reset bytes Transferred count
  CALL TestTDForHolding          ;Schedule the TD
Y70:                             ;We're retrying
  STC                            ;Set return flag
  JMP >Y90                       ;Done
Y80:                             ;We're not retrying
  CLC                            ;Set return flag
Y90:                             ;Done
  POP  SI,DI,CX,BX,EAX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;UPDATE THE CONTROL PACKET RETRY COUNTER
;Inputs:   DS = TSR Data Area
;         [SI] = Timeout Table Offset
;Outputs: ZF = Set if Retry Counter is exhausted
;            = Clear if Retries are still left
;Changes: Timeout Table Entry ([BX].TTFlags)
;------------------------------------------------------------------------------
UpdateTTRetriesSI:
  PUSH AX                 ;Save used registers
  MOV  AL,[SI].TTFlags    ;Get the Flags
  AND  B [SI].TTFlags,1Fh ;Mask out the original Retry Counter
  SHR  AL,5               ;Update
  DEC  AL                 ;  the
  SHL  AL,5               ;  Retry Counter
  OR   [SI].TTFlags,AL    ;Update the Retry Counter
  OR   AL,AL              ;Set the return flag
  POP  AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A SETUP REQUEST SHORT PACKET POSSIBILITY
;Inputs:  DS = ES = TSR Data Area
;         [DI] = TD we're Updating
;         DX = Current Status Flags
;Outputs: CX = Total Bytes Transferred (already stored in TD)
;         DX = Updated with SPD Flag, if appropriate
;Changes:
;------------------------------------------------------------------------------
TestControlShortPkt:
  MOV  CX,[DI].TDBytesXfered ;Was it actually a Short Transaction?
  CMP  CX,[DI].TDBytesToXfer ;  (this actually occured in Data Stage)
  JE  >P90                   ;If not, it's OK
  OR   DL,TDStsShortPacket   ;If so, mark it as a Short Packet
P90:                         ;Done
  RET

;------------------------------------------------------------------------------
;HANDLE ANY "SPECIAL" CONTROL REQUESTS THAT WE MAY NEED TO MONITOR
;Inputs:  DS = ES = TSR Data Area
;         [DI] = TD that's Completed
;         DX = Current Status Flags
;Outputs: Updates "monitored" data as appropriate
;Changes:
;------------------------------------------------------------------------------
HandleSpecialControls:
  PUSH AX,BX,CX,DX,DI,SI         ;Save used registers
  OR   DX,DX                     ;Error processing the TD?
  JNZ >P901                      ;If not, we're done
  CALL FindSRGivenTD             ;Find Setup Request for this TD (rtns BX)
  JC  >P901                      ;If not found, quit (should Not Happen!)
  MOV  SI,DI                     ;Put TD Pointer in SI
  CALL GetTDDeviceAddress        ;Point DI
  MOV  CL,AL                     ;  at the correct
  CALL ADIndex2Offset            ;  Address Table Entry
  MOV  DX,[BX].SRValue           ;DX = SRValue
  MOV  AX,W [BX].SRRequestType   ;AL = Request Type, AH = Request
  CMP  AX,((SRRQSetConfig SHL 8)+SRRTOut+SRRTTypeStandard+SRRTRecipDevice)
  JE  >P20                       ;If Set Config, handle it
  CMP  AX,((SRRQSetAltInterface SHL 8)+SRRTOut+SRRTTypeStandard+SRRTRecipInterface)
  JE  >P30                       ;If Set Alt Interface, handle it
  CMP  AX,((SRRQSetFeature SHL 8)+SRRTOut+SRRTTypeStandard+SRRTRecipDevice)
  JE  >P40                       ;If Set Remote Wakeup/Test Mode, handle it
  CMP  AX,((SRRQClearFeature SHL 8)+SRRTOut+SRRTTypeStandard+SRRTRecipDevice)
  JE  >P50                       ;If Clr Remote Wakeup/Test Mode, handle it
  CMP  AX,((SRRQClearFeature SHL 8)+SRRTOut+SRRTTypeStandard+SRRTRecipEndPoint)
  JE  >P60                       ;If Clr EndPoint Feature, handle it
  JMP >P901                      ;If none of these, we're done

;From here down, [BX] = Setup Request,
;                 CL = Device Address, DX = SRValue
;                [DI] = Address Table Entry, [SI] = Transfer Descriptor

P20:                             ;Set Config Request
  MOV  [DI].ADConfigValue,DL     ;Store the Config Value
  JMP >P901                      ;Done
P30:                             ;Set Alt Interface
  MOV  AL,CL                     ;AL = Device Address
  MOV  AH,B [BX].SRIndex         ;AH = Interface Number
  CALL AddressIntf2Intf          ;Find the Interface Entry (Returns DI)
  JC  >P901                      ;If not found, we're done
  MOV  AH,DL                     ;Put Alt Interface value we selected in AH
  CALL FinishSetAltIntf          ;Handle it
P901:                            ;To avoid JMP > 128
  JMP >P90                       ;Done
P40:                             ;Set Remote Wakeup/Test Mode Feature
  MOV  AL,ADFlagRWkUpOn          ;Assume Remote Wakeup
  CMP  DL,DvcFeatureRemoteWakeup ;Is it Remote WakeUp?
  JE  >P45                       ;If so, handle it
  MOV  AL,ADFlagTestMode         ;Assume Test Mode
  CMP  DL,DvcFeatureTestMode     ;Is it Test Mode?
  JNE >P90                       ;If not, quit
P45:                             ;AL contains Feature Flag
  OR   [DI].ADFlags2,AL          ;Set the Feature Flag
  JMP >P90                       ;Done
P50:                             ;Clear Remote Wakeup/Test Mode Feature
  MOV  AL,(NOT ADFlagRWkUpOn)    ;Assume Remote Wakeup
  CMP  DL,DvcFeatureRemoteWakeup ;Is it Remote WakeUp?
  JE  >P55                       ;If so, handle it
  MOV  AL,(NOT ADFlagTestMode)   ;Assume Test Mode
  CMP  DL,DvcFeatureTestMode     ;Is it Test Mode?
  JNE >P90                       ;If not, quit
P55:                             ;AL contains Feature Flag
  AND  [DI].ADFlags2,AL          ;UnSet the Feature Flag
  JMP >P90                       ;Done
P60:                             ;Clear End Point Feature
  CMP  DL,EndPtFeatureHalt       ;Clearing the Halt Feature?
  JNE >P90                       ;If not, quit
  MOV  AH,B [BX].SRIndex[0]      ;If so, AH = EndPoint Number
  MOV  AL,CL                     ;AL =
  AND  AL,(NOT 80h)              ;  Device Address
  CALL FindEndPtEntry            ;Find the correct End Point Entry ([SI])
  JC  >P90                       ;If none, we're finished
  AND  [SI].EnFlags,(NOT EnFlagData1) ;If so, reset to Data0
;  JMP >P90                       ;Done
P90:                             ;Done
  POP  SI,DI,DX,CX,BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE THE END OF A SETALTINTF REQUEST
;Inputs:  DS = ES = TSR Data Area
;         [DI] = Interface Entry
;          AH  = Alt Interface Value that was set
;Outputs: Modifies AltIntf Entries as appropriate
;Changes:
;------------------------------------------------------------------------------
FinishSetAltIntf:
  PUSH AX,DI,SI                          ;Save used registers
  XOR  AL,AL                             ;Start with Alt Interface 0
  MOV  SI,DI                             ;Save Interface Pointer
I10:                                     ;Loop to here for each Alt Interface
  CALL FindAltInterfaceALDI              ;Get Alt Interface Pointer (returns DI)
  JC  >I90                               ;If not found, we're done
  CMP  AH,[DI].AIAltIntfNum              ;If so, is it the Alt Interface we set?
  JNE >I30                               ;If not, jump to Un-Select it
I20:                                     ;Is alt Intf that we set
  OR   [DI].AIFlags,AIFlagSelected       ;If so, mark it as Selected
  JMP >I50                               ;Done with this one
I30:                                     ;Not Alt Interface that we set
  AND  [DI].AIFlags,(NOT AIFlagSelected) ;Mark it as unselected
I50:                                     ;Done with this Alt Interface entry
  MOV  DI,SI                             ;Restore Interface Pointer
  INC  AL                                ;Increment Alt Interface Number
  JMP  I10                               ;Keep going until we're done
I90:                                     ;Done
  POP  SI,DI,AX                          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ACTIVATE ANY TD'S THAT ARE CURRENTLY ON HOLD BUT CAN NOW BE RELEASED
;Inputs:  DS = ES = Segment containing TD's
;Outputs: Activates any TD's that are On Hold but no longer have any Active
;           TD's that are currently "in the way"
;Changes:
;NOTE: This only applies to Control TD's.
;------------------------------------------------------------------------------
ActivateTDsOnHold:
  PUSH AX,CX,DI           ;Save used registers
  PUSHF                   ;Save flags
  CLI                     ;Disable interrupts
  XOR  AH,AH              ;Start with Index 0
A10:                      ;Loop to here for each TD On Hold
  CALL FindTDOnHold       ;Any TD's On Hold?
  JC  >A90                ;If not, we're done
  CALL GetTDDeviceAddress ;Get the Device Address (AL)
  CALL FindTDNotOnHold    ;Is there an Active TD to the same Device?
  JNC >A50                ;If so, stay On Hold
A20:                      ;Need to take Off Hold
  AND  [DI].TDFlags,(NOT TDFlagOnHold) ;Mark as not On Hold any more
  OR   B [DI].TDControlStatus[2],(TDActive SHR 16) ;Mark as Active
  MOV  CL,[DI].TDTimeoutIndex          ;Mark the
  CALL TTIndex2Offset                  ;  Timeout Table Entry
  AND  [DI].TTFlags,(NOT TTFlagOnHold) ;  as no longer On Hold
A50:                      ;Done testing this TD On Hold
  INC  AH                 ;Increment the Index
  JMP  A10                ;Keep looking
A90:                      ;Done
  POPF                    ;Restore flags
  POP  DI,CX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;LOOK FOR A TD THAT IS ON HOLD IN THE CONTROL QUEUE
;Inputs:  DS = ES = TSR Data Area
;         AH = Index of TD to find (0 = first TD On Hold, etc.)
;Outputs: CF = Clear if OK (TD found)
;              [DI] = TD that was found
;            = Set if Error (no TD found)
;              DI = Unchanged
;Changes:
;NOTES: This also checks that the End Point is zero, since we are using this
;         as part of the "On Hold" functions in the Driver.  We do not
;         handle "On Hold" processes for anything except Control Request
;         to End Point 0.  If a Device has a Control End Point other than 0,
;         it will need to manage conflicts itself.
;       This does not check the Device Address.
;------------------------------------------------------------------------------
FindTDOnHold:
  PUSH EAX,CX,BP                 ;Save used registers
  PUSHF                          ;Save flags
  CLI                            ;Disable interrupts
  MOV  BP,DI                     ;Save original DI
  MOV  CL,AH                     ;CL = Index number to find
  MOV  DI,DS:[QHTable]           ;Get the physical address of the first
  MOV  EAX,[DI].QHElementPointer ;  TD in the Control Queue
H10:                             ;Loop to here for each TD in the Queue
  TEST AL,QHTerminate            ;End of Queue?
  JNZ >H70                       ;If so, no TD found
  CALL PhysAddr2SegOffNoFlags    ;Convert TD Physical Address to Offset (DI)
  TEST [DI].TDFlags,TDFlagOnHold ;Is it On Hold?
  JZ  >H50                       ;If not, skip it
  CALL GetTDEndPoint             ;Get the End Point
  JNZ >H50                       ;If not End Point 0, skip it
  SUB  CL,1                      ;Is it the Index we're looking for?
  JC  >H80                       ;If so, we're done
H50:                             ;Not the correct TD
  MOV  EAX,[DI].TDLinkPointer    ;Get Physical Address of next TD in Queue
  JMP  H10                       ;Keep looking through the Queue
H70:                             ;Error (no TD found)
  MOV  DI,BP                     ;Restore original DI
  POPF                           ;Restore flags
  STC                            ;Set return flag
  JMP >H90                       ;Done
H80:                             ;OK
  POPF                           ;Restore flags
  CLC                            ;Set return flag
H90:                             ;Done
  POP  BP,CX,EAX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;LOOK FOR A TD THAT IS NOT ON HOLD IN THE CONTROL QUEUE
;Inputs:  DS = ES = TSR Data Area
;         AL = Device Address to Find in the Control Queue
;Outputs: CF = Clear if OK (TD found)
;            = Set if Error (no TD found)
;Changes:
;NOTES: This looks for a TD in the Control Queue that is NOT On Hold (Active
;         or not), directed at End Point 0 of the Device Address in AL.
;       This not return the address of the TD -- it simply returns CF
;         indicating whether or not the TD exists.
;------------------------------------------------------------------------------
FindTDNotOnHold:
  PUSH EAX,CX,DI                 ;Save used registers
  PUSHF                          ;Save flags
  CLI                            ;Disable interrupts
  MOV  CL,AL                     ;CL = Index number to find
  MOV  DI,DS:[QHTable]           ;Get the physical address of the first
  MOV  EAX,[DI].QHElementPointer ;  TD in the Control Queue
H10:                             ;Loop to here for each TD in the Queue
  TEST AL,QHTerminate            ;End of Queue?
  JNZ >H70                       ;If so, no TD found
  CALL PhysAddr2SegOffNoFlags    ;Convert TD Physical Address to Offset (DI)
  TEST [DI].TDFlags,TDFlagOnHold ;Is it On Hold?
  JNZ >H50                       ;If not, skip it
  CALL GetTDEndPoint             ;Get the End Point
  JNZ >H50                       ;If not End Point 0, skip it
  CALL GetTDDeviceAddress        ;Get the Device Address
  CMP  AL,CL                     ;Is it the address we're looking for?
  JE  >H80                       ;If so, we're done
H50:                             ;Not the correct TD
  MOV  EAX,[DI].TDLinkPointer    ;Get Physical Address of next TD in Queue
  JMP  H10                       ;Keep looking through the Queue
H70:                             ;Error (no TD found)
  POPF                           ;Restore flags
  STC                            ;Set return flag
  JMP >H90                       ;Done
H80:                             ;OK
  POPF                           ;Restore flags
  CLC                            ;Set return flag
H90:                             ;Done
  POP  DI,CX,EAX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND A MATCHING END POINT TABLE ENTRY
;Inputs:  ES = TSR Data Area
;         AL = Device Address to Find
;         AH = End Point to Find (Masked with 80h if In)
;Outputs: CF = Clear if OK (Entry Found)
;              [SI] = End Point Entry
;            = Set if Error (Entry not found)
;              SI = Unchanged
;Changes:
;------------------------------------------------------------------------------
FindEndPtEntry:
  PUSH BX,CX           ;Save used registers
  MOV  BX,SI           ;Save original SI
  TEST AH,7Fh          ;End Point 0?
  JZ  >E70             ;If so, error
  MOV  SI,ES:[EnTable] ;[SI] = EndPoint Table
  MOV  CX,EnEntries    ;CX = Number of Table Entries
E10:                   ;Loop to here to find the Entry
  TEST ES:[SI].EnFlags,EnFlagInUse  ;Valid Table Entry?
  JZ  >E50                          ;If not, skip it
  CMP  W ES:[SI].EnDeviceAddress,AX ;Correct Device Address & End Point?
  JE  >E80             ;If so, we've found it
E50:                   ;Done with this Entry
  ADD  SI,EnSize       ;Point at the next Table Entry
  LOOP E10             ;Keep looking
E70:                   ;Error
  MOV  SI,BX           ;Restore original SI
  STC                  ;Set return flag
  JMP >E90             ;Done
E80:                   ;OK
  CLC                  ;Set return flag
E90:                   ;Done
  POP  CX,BX           ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;SUPPORT ROUTINES NEEDED TO UPDATE VARIOUS TYPES OF TD'S
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;RESET AN INTERRUPT OR ISOCHRONOUS TD, SO IT CAN BE USED AGAIN
;Inputs:  ES = DS = Segment containing TD's
;         DI = Pointer to TD that needs to be reset
;Inputs:  DS:[DI] = TD to change
;Outputs: Resets appropriate values in TD so it can be used again
;           Clears Errors
;           Initializes ErrorCount to 1, Actual Length to 0,
;             and Active
;Changes:
;------------------------------------------------------------------------------
ResetIntIsochTD:
  PUSHF ;Save flags
  CLI   ;Disable interrupts
  AND  B [DI].TDControlStatus[2],(NOT (TDAllErrorsMask SHR 16))
        ;Mask out previous Errors
  OR   [DI].TDControlStatus,(TDErrorCount1+TDActive+TDActualLengthNUL)
        ;No Change to SPD, Low-Speed, Isoch, IOC
        ;ErrorCount is ignored for Isoch TD's anyway?
  POPF  ;Restore Flags
  RET

;------------------------------------------------------------------------------
;RESET A CONTROL OR BULK TD, SO IT CAN BE USED AGAIN
;Inputs:  ES = DS = Segment containing TD's
;         DI = Pointer to TD that needs to be reset
;Inputs:  DS:[DI] = TD to change
;Outputs: Resets appropriate values in TD so it can be used again
;           Clears Errors
;           Initializes ErrorCount to 3, Actual Length to 0,
;             and Active?
;Changes:
;------------------------------------------------------------------------------
ResetCtrlBulkTD:
  PUSHF ;Save flags
  CLI   ;Disable interrupts
  AND  B [DI].TDControlStatus[2],(NOT (TDAllErrorsMask SHR 16))
        ;Mask out previous Errors
  OR   [DI].TDControlStatus,(TDErrorCount3+TDActualLengthNUL)
        ;No Change to SPD, Low-Speed, Isoch, IOC
        ;Set Active later (after rest of TD is updated)
        ;Or do this after rest of TD is updated!!
  POPF  ;Restore Flags
  RET

;------------------------------------------------------------------------------
;UPDATE THE NUMBER OF BYTES TRANSFERRED FOR A CONTROL TRANSACTION
;Inputs:   ES  = DS = Segment containing TD
;         [DI] = TD to be Updated
;          CX  = Actual Data Size Transferred in this Packet
;          DX  = Error to be returned to calling program (0 if no error)
;Outputs: CF = Set if all bytes have been transferred
;                (this is final "real" data Packet in the Transaction)
;            = Clear if more bytes are left to be transferred
;         Sets MaxLength in TDToken
;         Toggles Data0/Data1
;         Updates Data Address
;         Re-specifies IN/OUT
;Changes: Calculates/Updates bytes transferred values
;NOTE: This never actually gets called if there is not actual Data to Xfer
;        for the Setup Request is 0 Bytes (which is true for MANY types
;        of Control TD's!).
;------------------------------------------------------------------------------
UpdateBytesXfered:
  PUSH AX,BX,ECX              ;Save used registers
  MOVZX ECX,CX                ;Convert Bytes Transferred to a DW
  ADD  [DI].TDBuffPointer,ECX ;Update the Data Buffer Pointer
  MOV  AX,[DI].TDBytesXfered  ;Get sizes
  MOV  BX,[DI].TDBytesToXfer  ;  of Data sent
  ADD  AX,CX                  ;Add this packet to total bytes in Transaction
  MOV  [DI].TDBytesXfered,AX  ;Store bytes transferred so far
  SUB  BX,AX                  ;Calculate bytes left to transfer
  JZ  >X80                    ;If all bytes have already been sent, we're done
  TEST DX,TDStsShortPacket    ;Was it a Short Packet?
  JNZ >X80                    ;If so, we're done
  CALL GetEPMaxPktSizeTD      ;Get the Maximum packet Size (CX)
  CMP  BX,CX                  ;Do we have more data to send than one packet?
  JBE >X20                    ;If not, things are OK
  MOV  BX,CX                  ;If so, use MaxPktSize instead of Data Size
X20:                          ;Ready to set size (BX = Size of Data to send)
  MOV  AX,BX                  ;Set the
  CALL SetTDMaxLength         ;  Data Length
  XOR  B [DI].TDToken[2],(TDData1 SHR 16) ;Toggle Data0/Data1
X70:                          ;Not Done yet
  CLC                         ;Set the not Done flag
  JMP >X90                    ;Quit
X80:                          ;Done
  STC                         ;Mark done flag
X90:                          ;Done
  POP  ECX,BX,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALL THE USER FUNCTION WITH THE FAR CALL ADDRESS OF THE TD
;Inputs:  DS = ES = Data area that TD is in
;         DI = Pointer to TD
;         CX = Number of Bytes Transferred to return to User
;         DX = Error Code to return to user (put in AX during Call)
;         If DoUserFarCallAXDX, AX contains value to put in DX during Call
;Outputs: Calls User located in FarCall section of TD,
;           with DS = ES = Segment located in FarCall
;Changes:
;------------------------------------------------------------------------------
DoUserFarCallAXDX:
  PUSH AX                       ;Save used registers
  JMP >F00                      ;Doit
DoUserFarCall:
  PUSH AX                       ;Save used registers
  XOR  AX,AX                    ;Need DX to be 0
;  JMP >F00                      ;Do it
F00:
  PUSH BX,DX,DI                 ;Save used registers
  MOV  BX,[DI].TDUserPktID      ;If so, put the User Packet ID in BX
  XCHG AX,DX                    ;Swap AX and DX
  ADD  DI,OFFSET TDCallBackAddr ;Point DI at the Call Back Address
  CALL DoFarCall                ;Do the user thing
  POP  DI,DX,BX                 ;Restore used registers
  POP  AX                       ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE FOR INT 08h (CLOCK TIMER TICK)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HAVE INTERRUPT 08 (TIMER) RUN THIS PROGRAM EVERY TIME IT OCCURS
;Inputs:  ES = TSR Data Area (Original ES on Stack)
;Outputs:
;Changes:
;NOTES: The main thing we use the Timer Tick for is to update Timeout
;         counters.  The USB Bus itself can be used as a Timer (at least
;         when it is running) with a resolution of approximately 1 mS.
;       We use the Clock Interrupt for Timers that either need to be
;         running even when the USB Bus isn't, or that have long durations,
;         or that don't require super-critical accuracy, or for some other
;         reason are not "appropriate" to consume resources on the USB Bus.
;------------------------------------------------------------------------------
Int08Code:
  PUSHF                          ;Save flags
  STI                            ;Enable Interrupts
  CLD                            ;Go forward with string functions
  CALL MakeStack                 ;Create our own Stack Space
  PUSH DS                        ;Save used registers
  MOV  DS,ES                     ;Point DS at correct data area
  CALL HandleBeep                ;Handle/Update Speaker Beeping
  CALL CheckGlobalResume         ;Handle Global Resume if appropriate
  CALL CheckRHResumeDetect       ;Handle Root Hub Resume Detect if appropriate
  CALL UpdateTTEntries           ;Update TimeOut Counters
  CALL UpdateI8Entries           ;Update Int 08 Delay Table
  CALL UpdateRsEntries           ;Update Reset Retry Timeout Counters
  CALL UpdateConfigIntf          ;Update Configing Interface Timeouts
  POP  DS                        ;Restore used registers
  CALL ReturnStack               ;Restore original Stack Space
  POPF                           ;Restore original
  PUSHF                          ;  calling flags
  CALL D ES:[Int08Hdr].OldVector ;Call the Old Interrupt Vector
  POP  ES                        ;Restore used registers
  IRET

;------------------------------------------------------------------------------
;CHECK FOR AND HANDLE A GLOBAL RESUME (UN-SUSPEND)
;Inputs:  DS = ES = TSR Data Area
;Outputs:
;Changes:
;NOTES: If in Global Suspend Mode, this routine checks to see if the User
;         did something to request a Global Resume (Connected/Disconnected
;         a Device, or moved a Remote Wakeup Device (Mouse/Keyboard).  If this
;         happens, the Host will automatically issue the Global Resume
;         request.  Unfortunately, the Host simply turns it on and leaves
;         it there.
;       The correct sequence of events is to Hold the Global Resume signal
;         for at least 20ms, and then follow it with at least 10ms of
;         "idle time" before we actually resume normal Bus Operation.
;         Of course, when the Bus is Suspended we can't use it to control
;         the timing delays.  We will be using Int 08 to control the timing
;         instead.  The resolution of Int 08 is approximately 55ms, so we
;         will be holding things and delaying much longer than we actually
;         need to (55ms, rather than 10 or 20ms).  Things should sill work
;         OK, though.
;------------------------------------------------------------------------------
CheckGlobalResume:
  PUSH AX,SI              ;Save used registers
  CALL TestGlobalSuspend  ;In Global Suspend Mode?
  JZ  >G90                ;If not, Quit
  CALL ReadUSBCommandWord ;Read the USB Command Register
  TEST AL,UCGlobalResume  ;Global Resume Detected by Host?
  JZ  >G90                ;If not, quit
  MOV  SI,Int14Request    ;Point at Request Structure
  MOV  [SI].I14RRequestType,I14RRTHostRun ;Request = Start Host
  CALL DoInt14CallSI      ;Do it
G90:                      ;Done
  POP  SI,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A ROOT HUB PORT IF IT IS IN RESUME DETECT MODE
;Inputs:  DS = ES = TSR Data Area
;Outputs: If Resume Detect Mode, delays for a little while and then
;           "unsets" the Resume Detect.
;Changes:
;NOTES: A Resume Detect can either come from the Host Driver (via an
;         Int 14h Request), or from a Remote Wakeup issued from a downstream
;         Device.  In either case, we need to hold the Resume Signal for
;         several milliseconds before releasing it again.  This code simply
;         waits for several milliseconds after detecting the Resume Detect
;         signal, and then turns it off.
;       At least on some USB Hosts, Bus Timing stops while the Resume signal
;         is going on.  That is why need need to handle this with Int08
;         instead of the USB IRQ.
;------------------------------------------------------------------------------
CheckRHResumeDetect:
  PUSH AX,BX                 ;Save used registers
  MOV  BL,[ResDetPortOffset] ;Get the Resume Detect Port Offset
  OR   BL,BL                 ;Is it in use from last time?
  JZ  >D20                   ;If not, continue
  CALL ReadHostWord          ;If so, read the Port Status
  AND  AX,(NOT (PtSuspend+PtResumeDetect)) ;Un-Suspend the Port
  CALL WriteHostWord         ;Send it
  JMP >D70                   ;Done for now
D20:                         ;Resume Detect handled from last time
  MOV  BH,1                  ;Start with
  MOV  BL,PortSC1            ;  first Port
D30:                         ;Loop to here for each Port
  MOV  [ResDetPortOffset],BL ;Store Offset (BL) and Port Number (BH)
  CALL ReadHostWord          ;Get the Port Status
  TEST AL,PtResumeDetect     ;Is it in Resume Detect Mode?
  JNZ >D90                   ;If so, we're done for now
  ADD  BL,(PortSC2-PortSC1)  ;Point at the next Port
  INC  BH                    ;Increment the Port Index
  CMP  BH,[NumRootHubPorts]  ;Have we done all the ports?
  JBE  D30                   ;If not, continue
D70:                         ;No Resume Detect
  MOV  [ResDetPortOffset],0  ;Mark as not doing anything
D90:                         ;Done
  POP  BX,AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;UPDATE THE TIMEOUT COUNTERS AS APPROPRIATE
;Inputs:  DS = ES = TSR Data Area
;Outputs: Updates all entries in TimeOut Table
;Changes:
;NOTES: This code simply decrements the TimeOut counters down to 0, and
;         then leaves them at 0.
;       It is the responsibilty of the TD Update Code to mark an entry as
;         unused when appropriate.
;------------------------------------------------------------------------------
UpdateTTEntries:
  PUSH BX,CX                     ;Save used registers
  PUSHF                          ;Save Flags
  CALL TestHostHalted            ;Is the Host currently Halted?
  JNZ >T90                       ;If so, don't update any Timout Counters
  MOV  BX,DS:[TTTable]           ;Point at Table
  MOV  CX,TTEntries              ;Number of Entries in Table
  CLI                            ;Disable Interrupts
T10:                             ;Loop to here for each Table Entry
  TEST [BX].TTFlags,TTFlagInUse  ;Valid table Entry?
  JZ  >T50                       ;If not, skip it
  TEST [BX].TTFlags,TTFlagOnHold ;Is it On Hold?
  JNZ >T50                       ;If so, skip it
  CMP  [BX].TTDelayCounter,0     ;Is the Delay already counted down to 0?
  JE  >T50                       ;If so, leave it alone
  DEC  [BX].TTDelayCounter       ;If not, Decrement it
T50:                             ;Done with this entry
  ADD  BX,TTSize                 ;Point at the next Table entry
  LOOP T10                       ;Keep going until we're done
T90:                             ;DOne
  POPF                           ;Restore Flags
  POP  CX,BX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;UPDATE THE INT08 DELAY TIMEOUT ENTRIES AS APPROPRIATE
;Inputs:  DS = ES = TSR Data Area
;         [TSRFlags].FirstInstance (if True, CS = DS = ES)
;Outputs: Updates all entries in Table, as needed
;Changes:
;------------------------------------------------------------------------------
UpdateI8Entries:
  PUSH AX,BX,CX,DX,DI           ;Save used registers
  TEST [TSRFlags],FirstInstance ;Is this the First Instance (has I8 Table)?
  JZ  >E90                      ;If not, we're done
  XOR  AX,AX                    ;Set default
  XOR  CX,CX                    ;  Values for
  XOR  DX,DX                    ;  Far Call Registers
  MOV  DI,I8Table               ;[DI] = Table Pointer
E10:                            ;Loop to here for each Table Entry
  TEST [DI].I8Flags,I8FlagInUse ;This entry in use?
  JZ  >E50                      ;If not, skip it
  DEC  [DI].I8Delay             ;If so, decrement the Counter
  JNZ >E50                      ;If not 0 yet, keep waiting
  MOV  BX,[DI].I8UserPktID      ;If so, BX = User Packet ID
  PUSH DI                       ;Save Pointer
  ADD  DI,OFFSET I8CallBackAddr ;Point at the Call Back Address
  CALL DoFarCall                ;Call the User Code
  POP  DI                       ;Restore Pointer
  CALL ReleaseI8DI              ;Release the Table Entry
E50:                            ;Done with this Table Entry
  ADD  DI,I8Size                ;Point at next Table Entry
  CMP  DI,(I8Table+(I8Entries*I8Size)) ;Done with the table yet?
  JB   E10                      ;If not, keep going
E90:                            ;Done
  POP  DI,DX,CX,BX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;UPDATE THE RESET TIMEOUT COUNTERS AS APPROPRIATE
;Inputs:  DS = ES = TSR Data Area
;Outputs: Updates all entries in Reset Table
;Changes:
;NOTES: This code simply decrements the TimeOut counters down to 0, and
;         then leaves them at 0.
;       It is the responsibilty of the Reset Update Code to mark an entry as
;         unused when appropriate.
;------------------------------------------------------------------------------
UpdateRsEntries:
  PUSH BX,CX                    ;Save used registers
  PUSHF                         ;Save Flags
  CALL TestHostHalted           ;Is the Host currently Halted?
  JNZ >R90                      ;If so, don't update any Timout Counters
  MOV  BX,DS:[RsTable]          ;[BX] = Reset Table
  MOV  CX,RsEntries             ;Number of Entries in Table
  CLI                           ;Disable Interrupts
R10:                            ;Loop to here for each Table Entry
  TEST [BX].RsFlags,RsFlagInUse ;Valid table Entry?
  JZ  >R50                      ;If not, skip it
  CMP  [BX].RsDelayCounter,0    ;Is the Delay already counted down to 0?
  JE  >R50                      ;If so, leave it alone
  DEC  [BX].RsDelayCounter      ;If not, Decrement it
R50:                            ;Done with this entry
  ADD  BX,RsSize                ;Point at the next Table entry
  LOOP R10                      ;Keep going until we're done
R90:                            ;DOne
  POPF                          ;Restore Flags
  POP  CX,BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;UPDATE THE CONFIGING INTERFACE TIMEOUT ENTRIES AS APPROPRIATE
;Inputs:  DS = ES = TSR Data Area
;Outputs: Updates all entries in Address Data Table, as appropriate
;Changes:
;------------------------------------------------------------------------------
UpdateConfigIntf:
  PUSH BX,CX          ;Save used registers
  CALL TestHostHalted ;Is the Host even running?
  JNZ >G90            ;If not, we're done
 #IF !LITE
  MOV  BX,ADOffset+(OFFSET ADConfigingIntf)
 #ELSE
  MOV  BX,DS:[ADTable]             ;[BX] =
  ADD  BX,(OFFSET ADConfigingIntf) ;  first Table Entry
 #ENDIF
  MOV  CX,ADEntries   ;CX = Number of Table Entries
G10:                  ;Loop to here for each Table Entry
  CMP  B [BX],0       ;Is there a Timeout in Progress?
  JE  >G50            ;If not, try the next Table Entry
  DEC  B [BX]         ;If so, decrement the Timeout
G50:                  ;Done with this Table Entry
  ADD  BX,ADSize      ;Point at next
  LOOP G10            ;Keep going until we've done the whole table
G90:                  ;Done
  POP  CX,BX          ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO BEEP THE SPEAKER
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;START/STOP/CHANGE THE SPEAKER BEEPING AS APPROPRIATE
;Inputs:  DS = ES = TSR Data Area
;         [TSRFlags].FirstInstance (if True, CS = DS = ES)
;         [TSRFlags0].DoTheBeep
;         [OldPort42], [OldPort61], [BeepFrequency], [BeepCount]
;Outputs: Starts/Changes/Stops Beeping the Speaker as appropriate
;Changes:
;------------------------------------------------------------------------------
HandleBeep:
  PUSH BX                          ;Save used registers
  MOV  BX,OFFSET BeepCount         ;[BX] = [BeepCount]
  TEST [TSRFlags],FirstInstance    ;Is this the First Instance (has the Data)?
  JZ  >H90                         ;If not, we're done
  TEST [TSRFlags0],DoTheBeep       ;Are we supposed to start beeping?
  JZ  >H30                         ;If not, see if we're already beeping
  AND  [TSRFlags0],(NOT DoTheBeep) ;If so, mark it as started
  CMP  [BeepFrequency],0           ;Valid Frequency Divider?
  JE  >H90                         ;If not, just quit
  CALL BeepStart                   ;Try to start Beeping the Speaker
  JNC >H90                         ;If it worked, we're done
  MOV  W [BX],0                    ;If not, mark us as done Beeping
  JMP >H90                         ;Done
H30:                               ;Handled the Beep Start
  CMP  W [BX],0                    ;In the middle of Beeping?
  JE  >H90                         ;If not, we're done
  DEC  W [BX]                      ;If so, decrement the Counter
  JNZ >H90                         ;If not zero yet, keep waiting
  CALL BeepStop                    ;Stop Beeping
  MOV  [BeepFrequency],0           ;Mark us as done
H90:                               ;Done
  POP  BX                          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;START BEEPING THE SPEAKER
;Inputs:  CS = DS = Data Area to use ([FirstInstanceSeg])
;Outputs: Starts beeping the speaker, if appropriate
;         CF = Set if speaker is already beeping (from some other program)
;            = Clear if we started beeping the speaker
;         [BeepFrequency]
;Changes: [OldPort42], [OldPort61]
;------------------------------------------------------------------------------
BeepStart:
  PUSH AX             ;Save used register
  IN   AL,61h         ;Get status of PPI
  AND  AL,03h         ;Get rid of everything but the first two bits
  CMP  AL,03h         ;Are the first two bits both set?
  JNE >B10            ;If not, the speaker isn't beeping yet - continue
  STC                 ;If so, mark the "already beeping" flag
  JMP >B90            ;And we're done
B10:                  ;Start beeping
  MOV  AL,10110110xb  ;Channel 2, LSB/MSB, Square wave, Binary
  OUT  43h,AL         ;Tell timer about it
  IN   AL,42h         ;Get existing LSB
  MOV  AH,AL          ;Save it in AH
  IN   AL,42h         ;Get existing MSB
  XCHG AL,AH          ;Put things in right order
  MOV  [OldPort42],AX ;Store entire word in [OldPort42]
  MOV  AL,10110110xb  ;Channel 2, LSB/MSB, Square wave, binary
  OUT  43h,AL         ;Tell timer about it
  CALL ChangeBeepFreq ;Set the Frequency Divider
  IN   AL,61h         ;Get status byte of PPI
  MOV  [OldPort61],AL ;Save it in [OldPort61]
  OR   AL,03h         ;Allow timer to
  OUT  61h,AL         ;  control speaker
  CLC                 ;Set the "we started beeping" flag
B90:                  ;We're done
  POP  AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SET (CHANGE) THE FREQUENCY OF THE SPEKAER BEEPING
;Inputs:  CS = DS = Data Area to use ([FirstInstanceSeg])
;         BeepFreq = Frequency to set things to
;Outputs: Changes the Frequency of the Beep
;------------------------------------------------------------------------------
ChangeBeepFreq:
  PUSH AX     ;Save used registers
  MOV  AX,[BeepFrequency] ;AX = Frequency Divider to use
  OUT  42h,AL ;Send LSB to timer
  XCHG AH,AL  ;Put MSB in AL
  OUT  42h,AL ;Send MSB to timer
  POP  AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;STOP BEEPING THE SPEAKER
;Inputs:  CS = DS = Data Area to use ([FirstInstanceSeg])
;         [OldPort42], [OldPort61]
;Outputs: Stops beeping the speaker
;Changes:
;------------------------------------------------------------------------------
BeepStop:
  PUSH AX             ;Save used registers
  MOV  AL,10110110xb  ;Channel 2, LSB/MSB, Square wave, Binary
  OUT  43h,AL         ;Tell timer about it
  MOV  AX,[OldPort42] ;Get original timer word
  OUT  42h,AL         ;Put LSB in timer
  MOV  AL,AH          ;Get MSB
  OUT  42h,AL         ;Put MSB in timer
  MOV  AL,[OldPort61] ;Get back original status byte
  OUT  61h,AL         ;Tell PPI about it
  POP  AX             ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS (FIND/ALLOCATE/RESET) VARIOUS STRUCTURE-BASED TABLES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO CONVERT INDEXES TO OFFSETS & OFFSETS TO INDEXES
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;CONVERT A TRANSFER DESCRIPTOR OFFSET TO AN INDEX (BP)
;Inputs:  ES:DI = TD Offset to calculate
;Outputs: BP = Index
;Changes:
;------------------------------------------------------------------------------
TDOffset2IndexBP:
  PUSH CX    ;Save used registers
  CALL TDOffset2Index ;Convert Offset to Index (CX)
  MOV  BP,CX ;Put index in BP for the Return
  POP  CX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A TABLE OFFSET TO AN INDEX
;Inputs:  ES:[DI] = Offset to calculate
;Outputs: CX = Index
;Changes:
;------------------------------------------------------------------------------
;ADOffset2Index:
;  PUSH BX                ;Save used registers
;  MOV  BX,ES:[ADTable]   ;[BX] = Beginning of the table
;  MOV  CX,ADSize         ;Size of each Table Entry
;  JMP >I00               ;Jump to do it
;AIOffset2Index:
;  PUSH BX                ;Save used registers
;  MOV  BX,ES:[AITable]   ;[BX] = Beginning of the table
;  MOV  CX,AISize         ;Size of each Table Entry
;  JMP >I00               ;Jump to do it
FLOffset2Index:
  PUSH BX                ;Save used registers
  MOV  BX,ES:[FLOffsetW] ;[BX] = Beginning of the table
  MOV  CX,FLSize         ;Size of each Table Entry
  JMP >I00               ;Jump to do it
LCOffset2Index:
  PUSH BX                ;Save used registers
  MOV  BX,ES:[LCTable]   ;[BX] = Beginning of the table
  MOV  CX,LCSize         ;Size of each Table Entry
  JMP >I00               ;Jump to do it
InOffset2Index:
  PUSH BX                ;Save used registers
 #IF !LITE
  MOV  BX,InOffset       ;[BX] = Beginning of the table
 #ELSE
  MOV  BX,ES:[InTable]   ;[BX] = Beginning of the table
 #ENDIF
  MOV  CX,InSize         ;Size of each Table Entry
  JMP >I00               ;Jump to do it
;NDOffset2Index:
;  PUSH BX                ;Save used registers
;  MOV  BX,NDTable        ;[BX] = Beginning of the table
;  MOV  CX,NDSize         ;Size of each Table Entry
;  JMP >I00               ;Jump to do it
QHOffset2Index:
  PUSH BX                ;Save used registers
  MOV  BX,ES:[QHTable]   ;[BX] = Beginning of the table
  MOV  CX,QHSize         ;Size of each Table Entry
  JMP >I00               ;Jump to do it
TTOffset2Index:
  PUSH BX                ;Save used registers
  MOV  BX,ES:[TTTable]   ;[BX] = Beginning of the table
  MOV  CX,TTSize         ;Size of each Table Entry
  JMP >I00               ;Jump to do it
TDOffset2Index:
  PUSH BX                ;Save used registers
  MOV  BX,TDOffset       ;[BX] = Beginning of the table
  MOV  CX,TDSize         ;Size of each Table Entry
;  JMP >I00               ;Jump to do it
I00:                     ;Do the Offset2Index
  PUSH AX,DX             ;Save used registers
  MOV  AX,DI             ;Subtract out the offset
  SUB  AX,BX             ; of the beginning of the table
  XOR  DX,DX             ;Divide by the
  DIV  CX                ;  size of each table entry
  MOV  CX,AX             ;Put it in CX for the return
  POP  DX,AX             ;Restore used registers
  POP  BX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A FRAME LIST/QUEUE HEAD/TRANSFER DESCRIPTOR/ADDRESS INDEX TO AN OFFSET
;Inputs:  ES    = Data Segment where data is located
;         CX/CL = Table Index
;Outputs: DI    = Offset to Table Entry (Assuming ES is the segment)
;Changes:
;------------------------------------------------------------------------------
;AIIndex2Offset:
;  PUSH AX,CX             ;Save used registers
;  MOV  DI,ES:[AITable]   ;[DI] = Beginning of Table
;  MOV  AX,AISize         ;Size of each entry
;  JMP >O00               ;Jump to do it
ADIndex2Offset:
  PUSH AX,CX             ;Save used registers
 #IF !LITE
  MOV  DI,ADOffset       ;[DI] = Beginning of Table
 #ELSE
  MOV  DI,ES:[ADTable]   ;[DI] = Beginning of Table
 #ENDIF
  MOV  AX,ADSize         ;Size of each entry
  JMP >O00               ;Jump to do it
;EnIndex2Offset:
;  PUSH AX,CX             ;Save used registers
;  MOV  DI,ES:[EnTable]   ;[DI] = Beginning of Table
;  MOV  DI,[EnTable]      ;[DI] = Beginning of Table
;  MOV  AX,EnSize         ;Size of each entry
;  JMP >O00               ;Jump to do it
FLIndex2Offset:
  PUSH AX,CX             ;Save used registers
  AND  CX,FrNumIndexMask ;Convert Frame Number to Frame Index, if necessary
  MOV  DI,ES:[FLOffsetW] ;[DI] = Beginning of Table
  MOV  AX,FLSize         ;Size of each entry
  JMP >O01               ;Jump to do it
LCIndex2Offset:
  PUSH AX,CX             ;Save used registers
  MOV  DI,ES:[LCTable]   ;[DI] = Beginning of Table
  MOV  AX,LCSize         ;Size of each entry
  JMP >O00               ;Jump to do it
InIndex2Offset:
  PUSH AX,CX             ;Save used registers
 #IF !LITE
  MOV  DI,InOffset       ;[DI] = Beginning of Table
 #ELSE
  MOV  DI,ES:[InTable]   ;[DI] = Beginning of Table
 #ENDIF
  MOV  AX,InSize         ;Size of each entry
  JMP >O00               ;Jump to do it
NDIndex2Offset:
  PUSH AX,CX             ;Save used registers
  MOV  DI,NDTable        ;[DI] = Beginning of Table
  MOV  AX,NDSize         ;Size of each entry
  JMP >O00               ;Jump to do it
QHIndex2Offset:
  PUSH AX,CX             ;Save used registers
  MOV  DI,ES:[QHTable]   ;[DI] = Beginning of Table
  MOV  AX,QHSize         ;Size of each entry
  JMP >O00               ;Jump to do it
;SRIndex2Offset:
;  PUSH AX,CX             ;Save used registers
;  MOV  DI,ES:[SRTable]   ;[DI] = Beginning of Table
;  MOV  DI,[SRTable]      ;[DI] = Beginning of Table
;  MOV  AX,SRSize         ;Size of each entry
;  JMP >O00               ;Jump to do it
TTIndex2Offset:
  PUSH AX,CX             ;Save used registers
  MOV  DI,ES:[TTTable]   ;[DI] = Beginning of Table
  MOV  AX,TTSize         ;Size of each entry
  JMP >O00               ;Jump to do it
TDIndex2Offset:
  PUSH AX,CX             ;Save used registers
  MOV  DI,TDOffset       ;[DI] = Beginning of Table
  MOV  AX,TDSize         ;Size of each entry
  JMP >O01               ;Jump to do it
O00:                     ;Input is a byte
  XOR  CH,CH             ;Set high byte to 0
O01:                     ;Do the Index2Offset
  PUSH DX                ;Save used registers
  MUL  CX                ;Multiply Index by the size of each entry
  ADD  DI,AX             ;Add the offset of the beginning of the table
  POP  DX                ;Restore used registers
  POP  CX,AX             ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO RELEASE (RESET) VARIOUS TYPES OF TABLE ENTRIES
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;RELEASE A TABLE ENTRY (VARIOUS TYPES)
;Inputs:  ES = Appropriate Data Area (Segment where Table is located)
;              WIll either be TSR Data Area or [FirstInstanceSeg]
;         BX/CX/DI/SI = Table Entry Pointer or Index
;Outputs: Resets (Clears/Marks as available) the Table Entry, if appropriate
;Changes:
;------------------------------------------------------------------------------
ReleaseADCL:
  PUSH CX,DI                  ;Save used registers
  CALL ADIndex2Offset         ;Point DI at the Table Entry
  MOV  CX,(ADSize/2)          ;Number of words to write
  JMP >R00                    ;Do it
ReleaseAISI:
  PUSH CX,DI                  ;Save used registers
  MOV  DI,SI                  ;Point DI at Table Entry
  MOV  CX,(AISize/2)          ;Number of words to write
  JMP >R00                    ;Do it
ReleaseEnDI:
  PUSH CX,DI                  ;Save used registers
                              ;DI already points at Table Entry
  MOV  CX,(EnSize/2)          ;Number of words to write
  JMP >R00                    ;Do it
ReleaseI8DI:
  PUSH CX,DI                  ;Save used registers
                              ;DI already points at Table Entry
  MOV  CX,(I8Size/2)          ;Number of words to write
  JMP >R00                    ;Do it
ReleaseInDI:
  PUSH CX,DI                  ;Save used registers
                              ;DI already points at Table Entry
  MOV  CX,(InSize/2)          ;Number of words to write
  JMP >R00                    ;Do it
ReleaseLCDI:
  PUSH CX,DI                  ;Save used registers
                              ;DI already points at Table Entry
  MOV  CX,(LCSize/2)          ;Number of words to write
  JMP >R00                    ;Do it
ReleaseNDCX:
  PUSH CX,DI                  ;Save used registers
  CALL NDIndex2Offset         ;Point DI at the Table Entry
  MOV  CX,(NDSize/2)          ;Number of words to write
  JMP >R00                    ;Do it
ReleaseRsTblOffset:
  PUSH CX,DI                  ;Save used registers
  MOV  DI,ES:[ResetTblOffset] ;Point DI at Table Entry
  MOV  CX,(RsSize/2)          ;Number of words to write
  JMP >R00                    ;Do it
ReleaseTTCL:
  PUSH CX,DI                  ;Save used registers
  CMP  CL,-1                  ;Valid Index?
  JE  >R90                    ;If not, we're done
  CALL TTIndex2Offset         ;Point DI at the Table Entry
  MOV  CX,(TTSize/2)          ;Number of words to write
;  JMP >R00                    ;Do it
R00:
  PUSHF                       ;Save flags
  PUSH AX                     ;Save used registers
  CLI                         ;Disable interrupts
  XOR  AX,AX                  ;Fill table with zeroes
  REP  STOSW                  ;Reset the Table Entry
  POP  AX                     ;Restore used registers
  POPF                        ;Restore flags
R90:                          ;Done
  POP  DI,CX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PUT A TRANSFER DESCIPTOR BACK INTO THE AVAILABLE POOL (WE'RE DONE WITH IT)
;Inputs:  ES = TSR Data Area
;         DI = Offset of TD to Release
;Outputs: TD is flagged as Available
;Changes:
;------------------------------------------------------------------------------
ReleaseTD:
  PUSH AX,BX,CX,DI,DS          ;Save used registers
  PUSHF                        ;Save Flags
  CLI                          ;Disable interrupts
  MOV  DS,ES                   ;Point DS at the correct data area
  CALL GetTDType               ;Get the Type of TD
  CMP  AL,TDTypeIsoch          ;Is it Isoch?
  JNE >R40                     ;If not, just release a single TD
  MOV  BX,W [DI].TDIsochHandle ;If so, get the Isoch Handle
  MOV  DI,TDOffset             ;Point at TD Table
  MOV  CX,TDEntries            ;Number of table Entries
R10:                           ;Loop to here for each Isoch TD w/ same handle
  CALL GetTDType               ;Is it
  CMP  AL,TDTypeIsoch          ;  another Isochronous TD?
  JNE >R30                     ;If not, don't change it
  CMP  BX,W [DI].TDIsochHandle ;Is it part of our Isoch Series?
  JNE >R30                     ;If not, don't change it
  CALL ReleaseTDGo             ;If so, Release it
R30:                           ;Done with this TD
  ADD  DI,TDSize               ;Point at the next Entry
  LOOP R10                     ;Keep going until we're done
  JMP >R90                     ;Quit
R40:                           ;Release a Single TD
  CMP  AL,TDTypeControlSetup   ;Control TD?
  JB  >R80                     ;If not, no need to worry about Timeout
  CMP  AL,TDTypeControlStatus  ;Control TD?
  JA  >R80                     ;If not, no need to worry about Timeout
  MOV  CL,[DI].TDTimeoutIndex  ;Get the Timeout Table Index
  CALL ReleaseTTCL             ;Release the Timeout Entry
  CALL ReleaseSRGivenTD        ;Release the Setup Request Entry
R80:                           ;Release TD
  CALL ReleaseTDGo             ;Release the TD
R90:                           ;Done
  POPF                         ;Restore Flags
  POP  DS,DI,CX,BX,AX         ;Restore used registers
  RET

ReleaseTDGo:
  PUSH EAX                                    ;Save used registers
  CALL RemoveTDReferences                     ;Remove all References to the TD
  XOR  EAX,EAX                                ;Need to reset things to 0
  MOV  [DI].TDLinkPointer,TDTerminate         ;Mark the TD Link Pointer as NUL
  MOV  [DI].TDControlStatus,TDActualLengthNUL ;Reset Control & Status DWord
  MOV  [DI].TDToken,TDMaxLengthNUL            ;Mark Token as a Null Packet
  MOV  [DI].TDBuffPointer,EAX                 ;Reset Buffer Pointer
  MOV  [DI].TDFlags,AL                        ;Set Type to Available, OUT
  MOV  [DI].TDTimeoutIndex,-1                 ;Set Timeout Entry to nothing
  MOV  [DI].TDDataAddress,EAX                 ;Reset Data Address
  MOV  [DI].TDBytesToXfer,AX                  ;Reset Bytes To Transfer
  MOV  [DI].TDBytesXfered,AX                  ;Reset Bytes Transferred
  MOV  [DI].TDCallBackAddr,EAX                ;Reset Call Back Address
  MOV  [DI].TDUserPktID,AX                    ;Reset User Packet ID
  POP  EAX                                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RELEASE A SETUP REQUEST TABLE ENTRY, GIVEN THE TD IT IS FOR
;Inputs:  ES = TSR Data Area
;         [DI] = TD Pointer to Release Request for
;Outputs: Resets (Clears/Marks as available) the SREntry
;Changes:
;------------------------------------------------------------------------------
ReleaseSRGivenTD:
  PUSH BX                         ;Save used registers
  CALL FindSRGivenTD              ;Look for the Setup Request
  JC  >S90                        ;If not found, quit
  MOV  W ES:[BX].SRRequestType,-1 ;If found, mark it as available
S90:                              ;Done
  POP  BX                         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE SETUP REQUEST TABLE ENTRY ASSOCIATED WITH A PARTICULAR TD
;Inputs:   ES  = TSR Data Area
;         [DI] = TD Pointer to match up with
;Outputs: CF = Clear if Setup Request was found
;              [BX] = Setup Request Pointer
;            = Set if no Request Found
;              BX = Undefined
;Changes:
;------------------------------------------------------------------------------
FindSRGivenTD:
  PUSH CX                         ;Save used registers
  MOV  BX,ES:[SRTable]            ;Point at the Table
  MOV  CX,SREntries               ;Number of Table Entries to search
F10:                              ;Loop to here for each Table Entry
  CMP  W ES:[BX].SRRequestType,-1 ;Valid Table Entry?
  JE  >F40                        ;If not, skip it
  CMP  ES:[BX].SRTDOffset,DI      ;Is it for our TD?
  JE  >F80                        ;If so, we're done
F40:                              ;Go to next Table Entry
  ADD  BX,SRSize                  ;Point at next Table Entyr
  LOOP F10                        ;Keep looking
F70:                              ;Error
  STC                             ;Set Error flag
  JMP >F90                        ;Done
F80:                              ;OK
  CLC                             ;Set OK flag
F90:                              ;Done
  POP  CX                         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PUT A BULK QUEUE HEAD BACK INTO THE AVAILABLE POOL (WE'RE DONE WITH IT)
;Inputs:  ES = Segment where QH's & TD's are
;         DI = Offset of QH to Release
;              or
;         DI = Offset of Bulk TD in QH (TD contains QH Address)
;Outputs: QH is emptied out, and flagged as Available
;Changes:
;------------------------------------------------------------------------------
ReleaseBulkQHGivenTD:
  PUSH DI                        ;Save used registers
  MOV  DI,ES:[DI].TDBulkQHOffset ;Get QH Pointer from TD
  CALL ReleaseBulkQH             ;Release the QH
  POP  DI                        ;Restore used registers
  RET

ReleaseBulkQH:
  PUSH CX,DS                      ;Save used registers
  PUSHF                           ;Save flags
  CLI                             ;Disable interrupts
  MOV  DS,ES                      ;Point DS at the correct data area
  MOV  CL,[DI].QHBulkTimeoutIndex ;Release the
  CALL ReleaseTTCL                ;  Timeout Entry
  CALL ReleaseAllTDsInQH          ;Release all of the TD's
  MOV  [DI].QHBulkTimeoutIndex,-1 ;Reset Timeout Index
  POPF                            ;Restore flags
  POP  DS,CX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PUT AN INTERRUPT QUEUE HEAD BACK INTO THE AVAILABLE POOL (WE'RE DONE WITH IT)
;Inputs:  ES = TSR Data Area
;         DI = Offset of QH to Release or
;            = Offset of TD in the QH (If ReleaseIntQHGivenTD)
;Outputs: QH is flagged as Available
;         All TD's inside the Queue are Released
;Changes:
;------------------------------------------------------------------------------
ReleaseIntQHGivenTD:
  PUSH DI                       ;Save used registers
  MOV  DI,ES:[DI].TDIntQHOffset ;Point DI at the QH
  CALL ReleaseIntQH             ;Release the QH
  POP  DI                       ;Restore used Registers
  RET

ReleaseIntQH:
  PUSH DS                             ;Save used registers
  PUSHF                               ;Save flags
  MOV  DS,ES                          ;Point DS at TSR Data Area
  CLI                                 ;Disable interrupts
  CALL RemoveQHReferences             ;Unschedule the Queue
  CALL ReleaseAllTDsInQH              ;Release all of the TD's
  MOV  [DI].QHLinkPointer,QHTerminate ;Reset the Link Pointer
  POPF                                ;Restore flags
  POP  DS                             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;EMPTY ALL OF THE TD's OUT OF A BULK OR INTERRUPT QUEUE HEAD
;Inputs:  DS = ES = TSR Data Area
;         [DI] = QH to Release all TD's from
;Outputs: Releases all TD's that are in the QH
;         Resets QHElementPointer to QHTerminate
;         Resets all other registers in QH (QHFlags, etc.) to 0
;Changes:
;------------------------------------------------------------------------------
ReleaseAllTDsInQH:
  PUSH EAX,BX,CX,DI          ;Save used registers
  PUSHF                      ;Save flags
  CLI                        ;Disable interrupts
  MOV  BX,DI                 ;Point BX at the QH
  MOV  DI,TDOffset           ;Point at TD Table
  MOV  CX,TDEntries          ;Number of entries in the Table
L10:                         ;Loop to here for each TD in QH
  CALL GetTDType             ;Get the Type of TD
  CMP  AL,TDTypeBulk         ;Is it Bulk?
  JE  >L20                   ;If so, handle it
  CMP  AL,TDTypeInterruptPer ;Is it a Periodic Interrupt?
  JNE >L40                   ;If not, skip it
L20:                         ;Is correct type of TD
  CMP  [DI].TDIntQHOffset,BX ;Is it in the Queue we're releasing?
  JNE >L40                   ;If not, skip it
  CALL ReleaseTD             ;If so, Release it
L40:                         ;All TD's are released
  ADD  DI,TDSize             ;Point at next TD
  LOOP L10                   ;Keep going until we're done
L50:                         ;All TD's are released
  MOV  [BX].QHElementPointer,QHTerminate ;Mark QH as Empty
  XOR  EAX,EAX               ;Reset everything else to 0
  MOV  [BX+8],EAX            ;Reset all registers
  MOV  [BX+12],EAX           ;  in the QH
  POPF                       ;Restore flags
  POP  DI,CX,BX,EAX          ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO FIND AVAILABLE AND RESERVE VARIOUS TYPES OF TABLE ENTRIES
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;GET THE NEXT AVAILABLE DEVICE ADDRESS FROM THE ADDRESS TABLE
;Inputs:  DS = ES = TSR Data Area
;         [LastAddressUsed]
;Outputs: ZF = Clear if Address is available
;              AL = Address
;              DI = Address Table Offset
;              Marks address as In Use ("reserved") in Address Table
;              Stores [LastAddressUsed], [LastAddressOffset]
;            = Set if no available Addresses
;              AL = 0
;              DI = Undefined
;              [LastAddressUsed], [LastAddressOffset] = Unchanged
;Changes:
;NOTES: This only returns the CF flag indicating success or failure.  The
;         data is stored in [LastAddressUsed] & [LastAddressOffset].
;------------------------------------------------------------------------------
GetAvailAddress:
  PUSH CX                       ;Save used registers
  PUSHF                         ;Save flags
  MOV  CL,2                     ;Start at Address 2
  CLI                           ;Disable interrupts
A10:                            ;Loop to here for each Address
  CALL ADIndex2Offset           ;Get the Address Pointer
  TEST [DI].ADFlags,ADFlagInUse ;This Address already used?
  JZ  >A80                      ;If not, it's ours
  INC  CL                       ;Get next Address
  CMP  CL,ADEntries             ;Are we out of Addresses to use?
  JB   A10                      ;If not, keep looking
A70:                            ;Error (no addresses available)
  XOR  AL,AL                    ;Set error flag
  JMP >A90                      ;Done
A80:                            ;OK
  MOV  [DI].ADFlags,ADFlagInUse ;Mark it as in use
  MOV  AL,CL                    ;Put address in AL
  MOV  [LastAddressUsed],AL     ;Store Last Address Used
  MOV  [LastAddressOffset],DI   ;Store Last Address Offset
A90:                            ;Done
  POPF                          ;Restore flags
  OR   AL,AL                    ;Set return flag
  POP  CX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT AVAILABLE LARGE CALL ENTRY
;Inputs:  ES = TSR Data Area
;Outputs: CF = Clear if entry is available (now marked as reserved)
;              [DI] = Entry Pointer
;               CL  = LC Index
;               CH  = Host Index
;            = Set if no entry available
;               DI  = Undefined
;Changes:
;------------------------------------------------------------------------------
GetAvailLC:
  CALL GetAvailLC0    ;Get LC Pointer (DI)
  PUSHF               ;Save return flag
  CALL LCOffset2Index ;Get the Index (CX)
  MOV  CH,ES:[USBHostIndex] ;CH = Host Index
  POPF                ;Restore return flag
  RET

;------------------------------------------------------------------------------
;GET THE NEXT AVAILABLE ENTRY FROM ONE OF THE VARIOUS STRUCTURE-BASED TABLES
;Inputs:  ES = TSR Data Area
;Outputs: CF = Clear if entry is available (now marked as reserved)
;              [DI] = Entry Pointer
;            = Set if no entry available
;               DI  = Undefined
;Changes:
;NOTES: This assumes that the Flags Byte Offset is 0, and that the InUse
;         Flag bit is 1.  This is true for nearly all Structures that were
;         set up by us (non-Industry-defined structures).
;------------------------------------------------------------------------------
GetAvailAltInterface:
  PUSH AX,CX           ;Restore used registers
  MOV  AX,AISize       ;AX = Size of each entry
  MOV  CX,AIEntries    ;CX = Number of Table Entries
 #IF !LITE
  MOV  DI,AIOffset     ;[DI] = Table Pointer
 #ELSE
  MOV  DI,ES:[AITable] ;[DI] = Table Pointer
 #ENDIF
  JMP >V00             ;Do it
GetAvailEndPoint:
  PUSH AX,CX           ;Restore used registers
  MOV  AX,EnSize       ;AX = Size of each entry
  MOV  CX,EnEntries    ;CX = Number of Table Entries
  MOV  DI,ES:[EnTable] ;[DI] = Table Pointer
  JMP >V00             ;Do it
GetAvailInterface:
  PUSH AX,CX           ;Restore used registers
  MOV  AX,InSize       ;AX = Size of each entry
  MOV  CX,InEntries    ;CX = Number of Table Entries
 #IF !LITE
  MOV  DI,InOffset     ;[DI] = Table Pointer
 #ELSE
  MOV  DI,ES:[InTable] ;[DI] = Table Pointer
 #ENDIF
  JMP >V00             ;Do it
GetAvailLC0:
  PUSH AX,CX           ;Restore used registers
  MOV  AX,LCSize       ;AX = Size of each entry
  MOV  CX,LCEntries    ;CX = Number of Table Entries
  MOV  DI,ES:[LCTable] ;[DI] = Table Pointer
  JMP >V00             ;Do it
GetAvailReset:
  PUSH AX,CX           ;Restore used registers
  MOV  AX,RsSize       ;AX = Size of each entry
  MOV  CX,RsEntries    ;CX = Number of Table Entries
  MOV  DI,ES:[RsTable] ;[DI] = Table Pointer
  JMP >V00             ;Do it
GetAvailTT:
  PUSH AX,CX           ;Restore used registers
  MOV  AX,TTSize       ;AX = Size of each entry
  MOV  CX,TTEntries    ;CX = Number of Table Entries
  MOV  DI,ES:[TTTable] ;[DI] = Table Pointer
;  JMP >V00             ;Do it
V00:
  PUSHF                ;Save Flags
  CLI                  ;Disable Interrupts
V10:                   ;Loop to here for each Table Entry
  TEST B ES:[DI],01h   ;Is this table entry available?
  JZ  >V80             ;If so, use it
  ADD  DI,AX           ;If not, point at the next Table Entry
  LOOP V10             ;Keep looking
V70:                   ;Entry not available
  POPF                 ;Restore Flags
  STC                  ;Set Error Flag
  JMP >V90             ;Done
V80:                   ;Entry is set
  OR   B ES:[DI],01h   ;Mark the entry as In Use
  POPF                 ;Restore Flags
  CLC                  ;Set OK Flag
V90:                   ;Done
  POP  CX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT AVAILABLE SETUP REQUEST ENTRY FROM THE TABLE
;Inputs:  ES = TSR Data Area
;Outputs: CF = Clear if OK
;              [BX] = Address of Setup Request
;            = Set if no Request Available
;              BX   = 0 (Invalid)
;              BP = Error Code (insufficient resources)
;         Marks Request as In Use (RequestType = 0) in Table
;         RequestType of -1 = Available
;Changes:
;------------------------------------------------------------------------------
GetAvailSetupReq:
  PUSH CX              ;Save used registers
  PUSHF                ;Save Flags
  MOV  BX,ES:[SRTable] ;Point at Table
  MOV  CX,SREntries    ;Number of table entries to check
  CLI                  ;Disable interrupts
S10:                   ;Loop to here for each possible entry
  CMP  W ES:[BX].SRRequestType,-1 ;Available entry?
  JE  >S80             ;If so, we're done
  ADD  BX,SRSize       ;If not, point at the next one
  LOOP S10             ;Keep going until we're done
S70:                   ;None available
  MOV  BP,I14RErrResources ;BP = Error Code
  POPF                 ;Restore Flags
  STC                  ;Set error Flag
  JMP >S90             ;We're done
S80:                   ;Have a good address
  MOV  W ES:[BX].SRRequestType,0 ;Mark it as in use
  POPF                 ;Restore Flags
  CLC                  ;Set OK Flag
S90:                   ;We're done
  POP  CX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE NUMBER OF AVAILABLE TRANSFER DESCRIPTORS
;Inputs:  ES = Data segment where TD's are stored
;Outputs: CX = Number of available TD's
;           ZF = Set if CX = 0
;           ZF = Clear if ZF > 0
;Changes:
;------------------------------------------------------------------------------
CalcAvailTDs:
  PUSH AX,BX,DI           ;Save used registers
  PUSHF                   ;Save Flags
  XOR  BX,BX              ;Start the counter at 0
  MOV  DI,TDOffset        ;Point at the TD Table
  MOV  CX,TDEntries       ;Number of entries to process
  CLI                     ;Disable interrupts
C10:                      ;Loop to here for each TD Entry
  CALL GetTDType          ;Get the Type of TD
  CMP  AL,TDTypeAvailable ;Is it available?
  JNE >C20                ;If not, don't increment the counter
  INC  BX                 ;If so, increment the counter
C20:                      ;Have this Entry calculated
  ADD  DI,TDSize          ;Point at the next one
  LOOP C10                ;Keep going until we're done
  MOV  CX,BX              ;Put the count in CX for the return
  POPF                    ;Restore Flags
  OR   CX,CX              ;Set the return flag
  POP  DI,BX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET NEXT AVAILABLE TRANSFER DESCRIPTOR
;Inputs:  ES = Segment containing TD's
;Outputs: CF = Clear if one was found
;           DI = Offset of TD (using ES Segment)
;           TD is marked as Reserved
;           BP = Undefined
;         CF = Set if none available
;           DI = Undefined
;           BP = Error Code (Insufficient Resources)
;Changes:
;------------------------------------------------------------------------------
GetAvailTD:
  PUSH AX,CX               ;Save used regsiters
  PUSHF                    ;Save Flags
  MOV  DI,TDOffset         ;Beginning of Table
  MOV  CX,TDEntries        ;Number of table entries to check
  CLI                      ;Disable interrupts
G10:                       ;Loop to here for each table entry
  CALL GetTDType           ;Get the Type of TD
  CMP  AL,TDTypeAvailable  ;Is it available?
  JE  >G80                 ;If so, jump to handle it
  ADD  DI,TDSize           ;If not, point at the next one
  LOOP G10                 ;Keep going until we're done
G70:                       ;No available TD's
  MOV  BP,I14RErrResources ;Error = Insufficient Memory
  POPF                     ;Resetore Flags
  STC                      ;Set Error Flag
  JMP >G90                 ;We're done
G80:                       ;Found an available TD
  MOV  AL,TDTypeReserved   ;Mark the TD
  CALL SetTDType           ;  as reserved
  POPF                     ;Restore Flags
  CLC                      ;Set OK Flag
G90:                       ;We're done
  POP  CX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET NEXT AVAILABLE QUEUE HEAD FOR A BULK OR INT TRANSACTION (NOT CONTROL)
;Inputs:  ES = Segment containing QH's
;Outputs: CF = Clear if one was found
;           DI = Offset of QH (using ES Segment)
;         CF = Set if none available
;           DI = 0
;Changes:
;------------------------------------------------------------------------------
GetAvailQHBulk:
  PUSH CX                            ;Save used registers
  MOV  DI,(CtlQHEntries*QHSize)      ;DI = Offset to first Bulk QH
  MOV  CX,BulkQHEntries              ;Number of table entries to check
  JMP >Q00                           ;Do it
GetAvailQHInt:
  PUSH CX                            ;Save used registers
  MOV  DI,((CtlQHEntries+BulkQHEntries)*QHSize) ;DI = Offset to first Int QH
  MOV  CX,IntQHEntries               ;Number of table entries to check
;  JMP >Q00                          ;Do it
Q00:
  ADD  DI,ES:[QHTable]               ;Add in the QH Table Base Offset
  PUSHF                              ;Save Flags
  CLI                                ;Disable interrupts
Q10:                                 ;Loop to here for each table entry
  TEST ES:[DI].QHFlags,QHFlagInUse   ;TD empty?
  JZ  >Q80                           ;If so, use it
  ADD  DI,QHSize                     ;If not, point at the next one
  LOOP Q10                           ;Keep going until we're done
Q70:                                 ;No available QH's
  XOR  DI,DI                         ;DI = 0
  JMP >Q90                           ;We're done
Q80:                                 ;Found an available QH
  OR   ES:[DI].QHFlags,QHFlagInUse   ;Mark as in use
Q90:                                 ;We're done
  POPF                               ;Restore flags
  OR   DI,DI                         ;Set the return flag
  POP  CX                            ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;"SPECIFIC" MISCELLANEOUS SUPPORT FUNCTIONS NEEDED BY OTHER SUBROUTINES
;PRETTY SPECIFIC TO THIS PROGRAM, UNLIKELY TO BE USEFUL ANYWHERE ELSE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;COPY SETUP REQUEST INTO AN INT 14h STRUCTURE
;Inputs:  CS:[CX] = Request Structure to Copy From (8 bytes)
;         ES = TSR Data Area (Int14 Request to copy to)
;         [DI] = Int14 Request Structure to copy Setup Request Data into
;         CLD already issued
;Outputs: To ES:[DI]
;Changes:
;NOTES: This assumes that a CLI was issued (if appropriate)
;------------------------------------------------------------------------------
CopySetupReqToInt14CXDI:
  PUSH CX,DI,SI,DS                ;Save used registers
  MOV  DS,CS                      ;Point DS at First Instance Seg
  ADD  DI,OFFSET I14RSetupReqData ;Point at correct part of structure
  MOV  SI,CX                      ;Point at structure to copy
  MOV  CX,(SetupReqSize/2)        ;Number of words to copy
  REP  MOVSW                      ;Copy it
  POP  DS,SI,DI,CX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST A CALL BACK ADDRESS FOR VALIDITY (SEE IF IT'S "LEGITIMATE")
;Inputs:  DS:[SI] = Int 14 Request Structure (I14RCallBackAddr)
;     or  DS:[DI] = Call Back Address to test
;Outputs: ZF = Clear if address is legitimate
;            = Set if Invalid Address (Segment = 0 or Offset = -1)
;         If TestI14RCallBackAddr, BP = I14RErrCallBackAddr
;Changes:
;------------------------------------------------------------------------------
TestI14RCallBackAddr:
  PUSH DI                       ;Save used registers
  MOV  BP,I14RErrCallBackAddr   ;Assume Error = Invalid Call Back Address
  LEA  DI,[SI].I14RCallBackAddr ;Point DI at the Call Back Address
  CALL TestCallBackAddrDI       ;Test it
  POP  DI                       ;Restore used registers
  RET

TestCallBackAddrDI:
  CMP  W [DI],-1  ;Valid Offset?
  JE  >K90        ;If not, Quit
  CMP  W [DI+2],0 ;Valid Segment?
K90:              ;Done
  RET

;------------------------------------------------------------------------------
;COPY CALL BACK ADDRESS & USER PACKET ID FROM INT 14 REQUEST TO TD
;Inputs:  DS:[SI] = Int 14 Request
;         ES:[DI] = TD Pointer
;Outputs: Copies Call Back Address & User Packet ID from Int 14 Req to TD
;Changes:
;------------------------------------------------------------------------------
CopyI14RCallBack2TD:
  PUSH [SI].I14RCallBackAddr  ;Copy the
  POP  ES:[DI].TDCallBackAddr ;  Call Back Address
  PUSH [SI].I14RUserPktID     ;Copy the
  POP  ES:[DI].TDUserPktID    ;  User Packet ID
  RET

;------------------------------------------------------------------------------
;CALL A FAR CALL PROCEDURE, PRESERVING ALL SEGMENTS AND REGISTERS
;Inputs:  DS:[DI] = Far Call Procedure to perform
;Outputs:
;Changes:
;NOTES: This changes some registers before it does the Far Call, under
;         the assumption that ONLY AX, BX, CX, and DX contain data relevant
;         to the Call!!
;       This also sets DS, ES, FS, and GS to whatever the Code Segment is
;         (the high Word) in [DI].  This makes for easier programming
;         the Far Call Code (it can change any register, and does not need
;         to worry about setting the segment registers itself).
;------------------------------------------------------------------------------
DoFarCall:
  PUSHF                   ;Save flags
  CALL TestCallBackAddrDI ;Legitimate Call Back Address?
  JZ  >F90                ;If not, don't do anything
  PUSHAD                  ;Save all registers
  PUSH DS,ES,FS,GS,SS     ;Save segment registers
  CLD                     ;Go forward with strings
  STI                     ;Enable Interrupts
  MOV  ES,[DI+2]          ;Match up ES,
  MOV  FS,ES              ;  FS,
  MOV  GS,ES              ;  and GS
  PUSH CS                 ;Put our return address
  PUSH DoFarCallRtn       ;  on the stack
  PUSH D [DI]             ;Put the Far Call Address on the Stack
  MOV  DS,ES              ;Match up DS
  OR   AX,AX              ;Set ZF for the Call Entry
  RETF                    ;Call the User Code
DoFarCallRtn:             ;After Farr Call is done, this is where we are
  POP  SS,GS,FS,ES,DS     ;Restore segment registers
  POPAD                   ;Restore all registers
  NOP                     ;To handle possible bug in POPAD
F90:                      ;Done
  POPF                    ;Restore flags
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;"GENERAL PURPOSE" MISCELLANEOUS SUPPORT FUNCTIONS NEEDED BY TSR
;COULD EASILY BE NEEDED BY OTHER PROGRAMS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO CREATE/RESTORE OUR OWN STACK SPACE
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;CREATE/DELETE OUR OWN STACK
;Inputs:  ES = TSR Data Area
;         [StackInUse]
;Outputs: Interrupts Enabled
;Changes: SS,SP to/from our stack
;NOTE: CS is NOT the TSR Data Area!
;------------------------------------------------------------------------------
MakeStack:
  CLI                    ;Disable interrupts
  PUSHF                  ;Save
  POP  ES:[TempFlags]    ;  Flags
  INC  ES:[StackInUse]   ;Increment number-of-calls counter
  CMP  ES:[StackInUse],1 ;Is this the first call?
  JNE >M90               ;If not, the stack is already in use
  MOV  ES:[TempBX],BX    ;  BX in memory
  POP  BX                ;Save MakeStack's return address in BX
  MOV  ES:[OldSS],SS     ;Save original SS
  MOV  ES:[OldSP],SP     ;Save original SP
  MOV  SP,ES             ;Put our CS
  MOV  SS,SP             ;  into SS
  MOV  SP,TSRStackSize   ;SP = Top of Stack
  PUSH BX                ;Restore MakeStack's return address to stack
  MOV  BX,ES:[TempBX]    ;Restore BX from memory
M90:                     ;Done
  PUSH ES:[TempFlags]    ;Restore
  POPF                   ;  Flags
  STI                    ;Enable interrupts
  RET

ReturnStack:
  CLI                  ;Disable interrupts
  PUSHF                ;Save
  POP  ES:[TempFlags]  ;  Flags
  DEC  ES:[StackInUse] ;Decrement number-of-calls counter
  JNZ >R90             ;If sack is still in use, quit
  MOV  ES:[TempBX],BX  ;Save BX in memory
  POP  BX              ;Save ReturnStack's return address in BX
  MOV  SS,ES:[OldSS]   ;Restore original SS
  MOV  SP,ES:[OldSP]   ;Restore original SP
  PUSH BX              ;Restore ReturnStack's return address to stack
  MOV  BX,ES:[TempBX]  ;Restore BX from memory
R90:                   ;Done
  PUSH ES:[TempFlags]  ;Restore
  POPF                 ;  Flags
  STI                  ;Enable interrupts
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO SEARCH THROUGH/COMPARE LOOKUP TABLES
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;SEARCH A BYTE-TO-WORD LOOKUP TABLE FOR A MATCH
;Inputs:  ES:[BX] = Table to search
;           OR
;         CS:[BX] = Table to Search
;         AL      = Byte to search for
;Outputs: CF = Clear if a byte match as found in table
;              BX = Word from Table
;            = Set if no match found in table
;              BX = unchanged
;Changes:
;NOTES:   Last Entry in Table (end-of-table marker) = DB -1, DW -1
;------------------------------------------------------------------------------
SearchByte2WordTblCS:
  PUSH ES                 ;Save used registers
  MOV  ES,CS              ;Point ES at Data Segment we need
  CALL SearchByte2WordTbl ;Look for a match
  POP  ES                 ;Restore used registers
  RET

SearchByte2WordTbl:
  PUSH AX,SI,DS  ;Save used registers
  CLD            ;Go forward with string functions
  MOV  DS,ES     ;Point DS at correct data area
  MOV  SI,BX     ;Put pointer in SI
  MOV  AH,AL     ;Put byte to check in AH
B10:             ;Loop to here for each table entry
  LODSB          ;Get the next table entry
  CMP  AL,-1     ;Is it possibly the end of the table?
  JNE >B20       ;If not, continue
  CMP  W [SI],-1 ;Is it actually the end of the table?
  JE  >B70       ;If so, there's no match
B20:             ;Not end of table
  CMP  AL,AH     ;Is it a match?
  JE  >B80       ;If so, handle it!
  INC  SI,2      ;If not, skip over this table entry
  JMP  B10       ;And keep looking
B70:             ;No entry found
  STC            ;Set the not found flag
  JMP >B90       ;Quit
B80:             ;Entry found [SI]
  MOV  BX,[SI]   ;Point BX at the table entry
  CLC            ;Set the found flag
B90:             ;Done
  POP  DS,SI,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COMPARE TWO BYTE-ORIENTED OR WORD-ORIENTED TABLES TO SEE IF THEY MATCH
;Inputs:  DS:[SI] = Table we want to test
;           Tests 1 byte/word at a time
;           A byte/word of -1 (FFh/FFFFh) = Don't care
;         ES:[DI] = Table we want to compare with
;         CL = Number of bytes to test
;Outputs: CF = Clear if the tables match
;            = Set if no match
;Changes:
;------------------------------------------------------------------------------
CompareByteTables:
  PUSH BX          ;Save used registers
  MOV  BX,1        ;Number of bytes in each Entry = 1
  JMP >C00         ;Do it
CompareWordTables:
  PUSH BX          ;Save used registers
  MOV  BX,2        ;Number of bytes in each Entry = 2
;  JMP >C00         ;Do it
C00:
  PUSH AX,CX,DI,SI ;Save used registers
  XOR  CH,CH       ;Convert counter to a word
C10:               ;Loop to here for each table entry
  CMP  BL,1        ;Doing a Byte?
  JNE >C20         ;If not, it's a Word
  LODSB            ;Get the Byte to test
  CMP  AL,-1       ;Do we care what it is?
  JE  >C40         ;If not, skip it
  CMP  AL,ES:[DI]  ;If we care, does it match?
  JNE >C70         ;If not, we're done
  JMP >C40         ;If so, continue testing
C20:               ;Doing a Word
  LODSW            ;Get the Word to test
  CMP  AX,-1       ;Do we care what it is?
  JE  >C40         ;If not, skip it
  CMP  AX,ES:[DI]  ;If we care, does it match?
  JNE >C70         ;If not, we're done
C40:               ;Done testing this byte
  ADD  DI,BX       ;Point at next Table Entry
  LOOP C10         ;Keep going until we're done
  JMP >C80         ;If they all match, we're done
C70:               ;No match
  STC              ;Set no match flag
  JMP >C90         ;Done
C80:               ;It matches
  CLC              ;Set matches flag
C90:               ;Done
  POP  SI,DI,CX,AX ;Restore used registers
  POP  BX          ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO CONVERT SECONDS TO TIMER TICKS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;GET TIMEOUT DECISECONDS FROM INT 14h REQUEST, AND CONVERT TO TIMER TICKS
;Inputs:  DS:[SI] = INT 14h Request to get Deciseconds from
;         AL = Default value to use (if INT 14h Request has 0)
;Outputs: ZF = Clear if OK
;              AX = Number of Timer Ticks to use
;              BP = Unchanged
;            = Set if Error (Invalid Deciseconds)
;              AX = 0
;              BP = I14RErrTimeout
;Changes:
;
;------------------------------------------------------------------------------
GetTimeoutTicksSI:
  PUSH BX,DX               ;Save used registers
  XOR  BH,BH               ;Put Default value
  MOV  BL,AL               ;  in BX
  MOV  AX,[SI].I14RTimeout ;Get the number of Deciseconds
  CMP  AX,MaxTimeout       ;Is it too big?
  JA  >K70                 ;If so, Error
  OR   AX,AX               ;Should we use the Default value?
  JNZ >K10                 ;If not, continue
  MOV  AX,BX               ;If so, put the default value in AX
K10:                       ;AX contains Deciseconds to use
  MOV  BX,18206            ;Multiply by 1.8206
  MUL  BX                  ;  (approx number of
  MOV  BX,10000            ;  timer ticks
  DIV  BX                  ;  per decisecond)
  CMP  DX,5000             ;Do we need to round up?
  JB  >K20                 ;If not, continue
  INC  AX                  ;If so, round it up
K20:                       ;Done counting
  INC  AX                  ;Add an extra Timer Tick for good measure
  JMP >K90                 ;Done
K70:                       ;Error
  MOV  BP,I14RErrTimeout   ;Set BP to Error Code
  XOR  AX,AX               ;Set return value to 0
K90:                       ;Done
  OR   AX,AX               ;Set return flag
  POP  DX,BX               ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO DELAY FOR A CERTAIN NUMBER OF MICROSECONDS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;DELAY FOR 100 MICROSECONDS
;Inputs:
;Outputs: Delays for 100 microseconds
;Changes:
;------------------------------------------------------------------------------
Delay100US:
  PUSH AX        ;Save used registers
  MOV  AX,100    ;Delay for
  CALL DelayUSAX ;  100 Microseconds
  POP  AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DELAY FOR A GIVEN NUMBER OF MICROSECONDS
;Inputs:  AX = number of microseconds to wait (0-65,535)
;Outputs:
;Changes:
;   NOTE: Delays will be slightly longer than what's asked for, never shorter.
;         Accuracy decreases with small delays or slow computers!
;------------------------------------------------------------------------------
DelayUSAX:
  PUSH AX,BX           ;Save used registers
  OR   AX,AX           ;Is there anything to do?
  JZ  >D90             ;If not, just quit
  MOV  BX,AX           ;Put it in BX
  MOV  AX,(0FFFFh/3)+1 ;Maximum time for each sub-delay
D10:                   ;Loop to here for each sub-delay
  CMP  BX,AX           ;Is it more than the maximum?
  JA  >D40             ;If so, just do the sub-delay
  MOV  AX,BX           ;If not, just do the remainder that's left
D40:                   ;Do the delay
  CALL DoDelayUS       ;Do the US Delay
  SUB  BX,AX           ;SUbtract out how long we just waited
  JNZ  D10             ;If not 0 yet, do the sub-delay again
D90:                   ;We're done
  POP  BX,AX           ;Restore used registers
  RET

DoDelayUS:
  PUSH AX,BX,CX,DX ;Save used registers
  PUSHF            ;Save Flags
  SHL  AX,1        ;Multiply by 2
  MOV  BX,11932    ;Compensate for the fact
  MUL  BX          ;  that the clock frequency
  MOV  BX,10000    ;  is actually
  DIV  BX          ;  1.19318 MHz
  MOV  DX,AX       ;Save it
  CLI              ;Disable interrupts
  CALL GetTimer    ;Get the starting timer tick counter
  MOV  CX,AX       ;Save it
D20:               ;Keep looping to here until we've waited long enough
  MOV  BX,CX       ;Get the starting timer tick counter
  CALL GetTimer    ;Get the current timer tick counter
  SUB  BX,AX       ;Calculate the elapsed time
  CMP  BX,DX       ;Has it been long enough?
  JB   D20         ;If not, keep waiting
D90:               ;We're done
  POPF             ;Restore Flags
  POP  DX,CX,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET CURRENT TIMER COUNTER FROM PORT 40h (THE CLOCK INTERRUPT)
;Inputs:
;Outputs: AX = Current timer counter word
;Changes:
;------------------------------------------------------------------------------
GetTimer:
  MOV  AL,06h ;Bits 7:6 =  00 = Timer 0
              ;Bits 5:4 =  00 = Latch Counter
              ;Bits 3:1 = 011 = Mode 3 (Square Wave)
              ;Bit    0 =   0 = Binary Counter (16 bits)
  OUT  43h,AL ;Tell the PIT what wer'e going to do
  IN   AL,40h ;Get LSB of timer counter
  MOV  AH,AL  ;Save it
  IN   AL,40h ;Get MSB of timer counter
  XCHG AH,AL  ;Put things in the right order
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;CODE TO GENERATE A "RANDOM" NUMBER
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;GENERATE A RANDOM NUMBER (0-65535)
;Inputs:
;Outputs: AX = "Random" Word
;Changes:
;NOTES: This uses functions that require at least an 80286 CPU.
;       It is not actualy possible for a computer to generate truly random
;         numbers.  Most randomizers simply perform a calculation on a
;         "seed" number, and use the generated number as the next seed value.
;         Usually, with these routines, you end up with the same values
;         every time you reboot the computer, since you actually need to
;         "randomize" the seed to come up with different values each time.
;       This code simply does some math on the counters that the computer
;         uses to keep track of the date and time.  These numbers are not
;         really random, but they are EXTREMELY unpredictable (which is
;         all we really care about).
;------------------------------------------------------------------------------
GetRandomWord:
  PUSH BX,CX,DX,DS ;Save used registers
  CALL GetTimer    ;Get current Timer Counter Word
  MOV  BX,AX       ;Put it in BX
  AND  AX,0007h    ;Delay between
  INC  AX          ;  1 and 8
  CALL DelayUSAX   ;  microseconds (make sure next Timer is different)
  MOV  AX,0040h    ;Point DS at the
  MOV  DS,AX       ;  BIOS Data Area
  SUB  BX,[006Ch]  ;Subtract the low Time-of-Day Word
  MOV  AH,4        ;Function 4 (Get CMOS Date)
  INT  1Ah         ;Do it (CH=Century, CL=Year, DH=Month, DL=Day)
  ADD  BX,CX       ;Add the Century/Year
  SUB  BX,DX       ;Subtract the Month/Day
  MOV  CL,[006Eh]  ;Get the low byte of the high Time-of-Day Word
  AND  CL,0Fh      ;Make sure it's less than 16
  CALL GetTimer    ;Get the Timer Again
  XCHG AL,AH       ;Swap the high and low bytes
  XOR  BX,AX       ;Add it to the Total
  TEST AL,4        ;Should we Rotate Right or Left?
  JNZ >R20         ;If Right, jump to handle it
R10:               ;Rotate Left
  ROL  BX,CL       ;Rotate Left
  JMP >R90         ;Done
R20:               ;Rotate Right
  ROR  BX,CL       ;Rotate Right
R90:               ;Done
  MOV  AX,BX       ;Put return value in AX
  XCHG AL,AH       ;Swap AL & AH
  POP  DS,DX,CX,BX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;A "DUMMY" FAR CALL THAT DOES NOTHING
;Inputs:
;Outputs:
;Changes:
;------------------------------------------------------------------------------
NullFarCall:
  RETF


LastTSRByte:


;ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
;ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;DATA NEEDED TO INSTALL/UPDATE/SHOW STATUS (NOT NEEDED DIRECTLY IN TSR)
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;EQUATES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

  ;----------------------------------------------------------------------------
  ;ErrorLevels
  ;----------------------------------------------------------------------------
  ;--------------------------
  ;Command-line/User problems
  ;--------------------------
  ErLvlOption       EQU  1 ;Bad Option on the command line
  ErLvlStdIn        EQU  2 ;StdIn file is too big
  ErLvlLegacy       EQU  3 ;Legacy Support enabled, and user won't continue
  ErLvlAlreadyRun   EQU  4 ;Another driver has control of the USB Bus
  ;--------------------
  ;Memory/File problems
  ;--------------------
  ErLvlMemory       EQU  5 ;Memory problem with the computer
  ErLvlNotRealMode  EQU  6 ;Not in Real Mode or VCPI not installed
  ErLvlNoOvl        EQU  7 ;Could not find Overlay File
  ;-------------------------------
  ;Hardware/Compatibility problems
  ;-------------------------------
  ErLvlDOSVer       EQU  8 ;DOS Version too old
  ErLvlNo386        EQU  9 ;Not a 386+ CPU
  ErLvlNoPCI        EQU 10 ;No PCI Bus Installed
  ErLvlNoUHCI       EQU 11 ;No UHCI-compatible Controller found
  ErLvlNoStart      EQU 12 ;Host failed to Initialize Properly
  ;------------------------
  ;Program Install problems
  ;------------------------
  ErLvlTooManyHosts EQU 13 ;Too Many Hosts Already Installed
  ErLvlVersion      EQU 14 ;Another version of the program already installed
  ;--------------------------
  ;Program Uninstall problems
  ;--------------------------
  ErLvlNotInMem     EQU 15 ;Not in memory yet, can't perform Request
  ErLvlCantStopHost EQU 16 ;Could not stop the Host
  ErLvlNotFirstInst EQU 17 ;Not first Instance while Uninstalling
  ErLvlSharedIRQ    EQU 18 ;Another program is sharing the IRQ that we Enabled
  ErLvlDvc0Owner    EQU 19 ;Last Host, with Registered Device 0 Owners
  ;-----------------
  ;Internal problems
  ;-----------------
  ErLvlInternal     EQU 20 ;Internal processing error - shouldn't happen!

  ;----------------------------------------------------------------------------
  ;Command Line Options with no single-character equivalents
  ;----------------------------------------------------------------------------
  OptionHostStatus    EQU  1 ;Host Status
  OptionFLStatus      EQU  2 ;Frame List Status
  OptionTDStatus      EQU  3 ;Transfer Descriptor Status
  OptionQHStatus      EQU  4 ;Queue Head Status
  OptionADStatus      EQU  5 ;Address Data Status
  OptionNDStatus      EQU  6 ;New Device Data Status
  OptionDescriptor    EQU  7 ;Show Descriptors from last Device
  OptionErrLvl        EQU  8 ;Write ErrorLevel Table

  OptionReset         EQU 10 ;Reset
  OptionSuspend       EQU 11 ;Suspend
  OptionResume        EQU 12 ;Resume
  OptionPwrOn         EQU 13 ;Power On
  OptionPwrOff        EQU 14 ;Power Off
  OptionPwrReset      EQU 15 ;Power Reset

  OptionResetBad      EQU 16 ;Reset all Bad Devices on All Hosts

  OptionDebug         EQU 17 ;Host Debug Mode
  OptionSingleStep    EQU 18 ;Host Single Step

  OptionTiming        EQU 20 ;Change Frame Timing

  OptionSetConfig     EQU 21 ;Set Device Configuration Value
  OPtionRmtWakeup     EQU 22 ;Change Remote Wakeup Setting
  OptionTestMode      EQU 23 ;Change Test Mode Setting

  OptionUserIO        EQU 25 ;User-assigned I/O Base Address
  OptionUserIRQ       EQU 26 ;User-assigned IRQ
  OptionDisableLegacy EQU 27 ;User OK'd us to Disable Legacy Support
  OptionDisableOther  EQU 28 ;User OK'd us to Disable Other Control Program
  OptionBeep          EQU 29 ;Beep Speaker when Bad Device is found
  OptionProgDebug     EQU 30 ;Display Program Debugging Strings


;==============================================================================
;String Identifier Codes (for USBUHCI.OVL)
;==============================================================================
  MinSID            EQU 0FF00h ;Minimum SID value Allowed
 ;---------------------
 ;Miscellaneous Strings
 ;---------------------
  SIDCrLf           EQU 0FF00h
  SIDYes2Msg        EQU 0FF01h
  SIDNo2Msg         EQU 0FF02h
  SIDSpace4         EQU 0FF03h
  SIDSpace3         EQU 0FF04h
  SIDSpace2         EQU 0FF05h
  SIDSpace          EQU 0FF06h
  SIDYesMsgY        EQU 0FF07h
  SIDNoMsgN         EQU 0FF08h
  SIDDblLine        EQU 0FF09h
  SIDNAMsg          EQU 0FF0Ah

  SIDPause          EQU 0FF10h
  SIDPauseN         EQU 0FF11h
  SIDPauseD         EQU 0FF12h
  SIDNoSuptFile     EQU 0FF13h
  SIDSyntax         EQU 0FF14h
  SIDFLHeader       EQU 0FF15h
  SIDEllipses       EQU 0FF16h
  SIDQHHeader       EQU 0FF17h
  SIDQHTypeCtl      EQU 0FF18h
  SIDQHTypeBulk     EQU 0FF19h
  SIDQHTypeInt      EQU 0FF1Ah

  SIDTDHeader0      EQU 0FF20h
  SIDTDHeader1      EQU 0FF21h
  SIDTDHeader2      EQU 0FF22h
  SIDTDTypeTbl      EQU 0FF23h
  SIDTDPktTypeTbl   EQU 0FF24h
  SIDTDPktTypeNA    EQU 0FF25h
  SIDOneTimeInt     EQU 0FF26h
  SIDPeriodicInt    EQU 0FF27h
  SIDBulk           EQU 0FF28h
  SIDIsoch          EQU 0FF29h
  SIDControl        EQU 0FF2Ah

  SIDSetupStage     EQU 0FF30h
  SIDDataStage      EQU 0FF31h
  SIDStatusStage    EQU 0FF32h
  SIDDvcNotYet      EQU 0FF33h
  SIDDvcAddr        EQU 0FF34h
  SIDDvcConfig      EQU 0FF35h
  SIDDvcNoMore      EQU 0FF36h
  SIDAliasHdr       EQU 0FF37h
  SIDParseCmd       EQU 0FF38h
  SIDParseEnv       EQU 0FF39h
  SIDParseStdIn     EQU 0FF3Ah

  SIDParseErr       EQU 0FF40h
  SIDParseErrEnv    EQU 0FF41h
  SIDParseErr2      EQU 0FF42h
  SIDInitializing1  EQU 0FF43h
  SIDInitializing2  EQU 0FF44h
  SIDEnvironment    EQU 0FF45h
  SIDInstall1       EQU 0FF46h
  SIDInstallAuto    EQU 0FF47h
  SIDInstallHigh    EQU 0FF48h
  SIDInstallHole    EQU 0FF49h
  SIDInstallNorm    EQU 0FF4Ah
  SIDInstallLast    EQU 0FF4Bh

  SIDDOSVer         EQU 0FF50h
  SIDNo386          EQU 0FF51h
  SIDNoPCI          EQU 0FF52h
  SIDNoUHCI         EQU 0FF53h
  SIDNotReal        EQU 0FF54h
  SIDLegacyCont     EQU 0FF55h
  SIDAlreadyRun     EQU 0FF56h
  SIDTooManyHosts   EQU 0FF57h
  SIDNoEnviron      EQU 0FF58h
  SIDStdInMemory    EQU 0FF59h
  SIDStdInTooBig    EQU 0FF5Ah

  SIDAssignIRQ      EQU 0FF60h
  SIDAssignIO       EQU 0FF61h
  SIDWrongVer       EQU 0FF62h
  SIDUninstall      EQU 0FF63h
  SIDNoUninstall    EQU 0FF64h
  SIDNotFirstInst   EQU 0FF65h
  SIDSharedIRQ      EQU 0FF66h
  SIDDvc0Owner      EQU 0FF67h
  SIDNotInMem       EQU 0FF68h
  SIDCantStopHost   EQU 0FF69h
  SIDUpdate         EQU 0FF6Ah
  SIDNoStart        EQU 0FF6Bh
  SIDInternalErr    EQU 0FF6Ch

  SIDMoreLeft       EQU 0FF70h
  SIDMoreRight      EQU 0FF71h
  SIDSwitchList     EQU 0FF72h
  SIDSwitchList2    EQU 0FF73h
  SIDSwitchListYN   EQU 0FF74h
  SIDErrLvlHdr      EQU 0FF75h
  SIDErrLvlTbl      EQU 0FF76h
 ;---------------
 ;Debugging Codes
 ;---------------
  SIDProgDebug      EQU 0FF80h
  SIDBusDevFunc     EQU 0FF81h
  SIDPCISearchIdx   EQU 0FF82h
  SIDIRQNumber      EQU 0FF83h
  SIDBaseIO         EQU 0FF84h
  SIDFrameListAddr  EQU 0FF85h
  SIDStopHost       EQU 0FF86h
  SIDEnBusMaster    EQU 0FF87h
  SIDDisSMIFlags    EQU 0FF88h
  SIDEnResumeDet    EQU 0FF89h
  SIDRedirGenInts   EQU 0FF8Ah
  SIDRedirUSBInt    EQU 0FF8Bh

  SIDResetHost      EQU 0FF90h
  SIDSetFLAddress   EQU 0FF91h
  SIDFrameTiming    EQU 0FF92h
  SIDStartFrame     EQU 0FF93h
  SIDEnIRQFlags     EQU 0FF94h
  SIDDisSMIGen      EQU 0FF95h
  SIDEnIRQGen       EQU 0FF96h
  SIDStartHost      EQU 0FF97h
  SIDVerifyHost     EQU 0FF98h
  SIDInitRootHub    EQU 0FF99h
  SIDVerifyIRQ      EQU 0FF9Ah
 ;-------------------------
 ;Uninstall Debugging Codes
 ;-------------------------
  SIDRestoreUSBInt  EQU 0FFA0h
  SIDRestorePort1   EQU 0FFA1h
  SIDRestorePort2   EQU 0FFA2h
  SIDEnSMIFlags     EQU 0FFA3h
  SIDEnSMIGen       EQU 0FFA4h
  SIDRestoreIRQ     EQU 0FFA5h
  SIDRestorePCI     EQU 0FFA6h
  SIDRestoreGenInts EQU 0FFA7h
 ;-----------------
 ;Reset Bad Devices
 ;-----------------
  SIDResetBad       EQU 0FFB0h
  SIDNoBads         EQU 0FFB1h
  SIDErrorBads      EQU 0FFB2h
 ;-------------------------
 ;Report Descriptor Strings
 ;-------------------------
  SIDRptNoDvc0      EQU 0FFC0h
  SIDRptNoDvc1      EQU 0FFC1h
  SIDRptNoDvc2      EQU 0FFC2h
  SIDRptNoData      EQU 0FFC3h
 ;----------------------
 ;Downloaded Descriptors
 ;----------------------
  SIDDescrNoDvc     EQU 0FFD0h
  SIDDescrNoData    EQU 0FFD1h

  ;----------------------------------------------------------------------------
  ;Flags for WriteByteMin/WriteWordMin/etc.
  ;----------------------------------------------------------------------------
  WriteBWNoMin EQU 0 ;No minimum (write all characters)
  WriteBWMin   EQU 1 ;Use minimum number of characters
  WriteBWByte  EQU 0 ;Is a Byte, or a Word with max 3 characters
  WriteBWWord  EQU 2 ;Is a Word (max 5 characters)

  ;----------------------------------------------------------------------------
  ;Size of our program stack (in bytes)
  ;----------------------------------------------------------------------------
  ProgStackSize EQU 1024


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;DATA NEEDED TO INSTALL/UPDATE/ SHOW STATUS (NOT NEEDED DIRECTLY IN TSR)
;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

  ;------------------------------------------------------------------------------
  ;INT2F Data
  ;This data was used in pre-AMIS versions of USBUHCI{L}.  We still need it
  ;  to know if an older (pre-AMIS) version of the program is installed in
  ;  memory.  This does NOT need to be in the TSR Segment.
  ;------------------------------------------------------------------------------
  Author:    DB '  Bret Johnson' ;Authors name
  AuthorLen EQU         $-Author  ;Length of Author

  ;----------------------------------------------------------------------------
  ;Data needed to test for Pre-AMIS versions
  ;----------------------------------------------------------------------------
  HandleNum DB 0


;==============================================================================
;Memory Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Segment of first UMCB (Memory Control Block for a UMB)
  ;This value is used to compare to to determine whether or not we are
  ;  installed/installing to a UMB.  On most systems, UMB's start at
  ;  Segment A000h (MCB Segment = 9FFFh), but this is not always true.
  ;The FindFirstUMCB subroutine calculates the correct value and fills it
  ;  in here.
  ;This is only needed when we are installing ourselves into memory, so does
  ;  not need to be stored in the TSR.
  ;----------------------------------------------------------------------------
  FirstUMCB DW 9FFFh

  ;----------------------------------------------------------------------------
  ;Original Code Segment (before we relocated ourselves)
  ;This is only needed to test whether we were installed in a "memory hole".
  ;----------------------------------------------------------------------------
  OriginalCS DW ?

;  ;----------------------------------------------------------------------------
;  ;Memory Segment we reserve to allow us space to install the TSR
;  ;----------------------------------------------------------------------------
;  WastedSegment DW 0

  ;----------------------------------------------------------------------------
  ;Original UMB Link State & Memory Allocation Strategy
  ;----------------------------------------------------------------------------
  OldUMBLink  DW ? ;Original UMB Link State
  OldStrategy DW ? ;Original Memory Allocation Strategy

  ;----------------------------------------------------------------------------
  ;Program name to store in MCB
  ;Max 8 Characters, all CAPS, ASCIIZ
  ;----------------------------------------------------------------------------
  MCBName:
  #IF !LITE
    DB 'USBUHCI'          ;Name of our program
  #ELSE
    DB 'USBUHCIL'         ;Name of our program
  #ENDIF
  MCBNameSz EQU $-MCBName ;Length of the Name
    DB 0                  ;Must be ASCIIZ


;==============================================================================
;Miscellaneous
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Miscellaneous Yes/No flags (individual bits)
  ;----------------------------------------------------------------------------
  ProgFlags        DB  0  ;Yes/No Test bits #1
    Help          EQU 80h ;User wants help?
    Uninstall     EQU 40h ;Uninstall resident program?
    InMemory      EQU 20h ;Already installed in memory?
    Alias         EQU 10h ;Write the Alias List?
    MemoryMoved   EQU 08h ;TSR Memory has been moved by our Auto-Code
    UseLowMemory  EQU 04h ;User does not want us in High Memory
    DisableLegacy EQU 02h ;User OK'd Disabling of Legacy Driver
    ResetBads     EQU 01h ;Reset All Bad Devices

  ProgFlags2       DB  0  ;Yes/No Test bits #2
    AssignedIO    EQU 80h ;We assigned an IO Space
    AssignedIRQ   EQU 40h ;We assigned an IRQ
    DoSerialTest  EQU 20h ;Test for Serial-Bus-compatible PCI IRQ's
    LegacyEnabled EQU 10h ;Legacy Support Installed
    DisableOther  EQU 08h ;Disable other program controlling the Bus
    DoEnvir       EQU 04h ;Parsing the Environment variable
    DoStdIn       EQU 02h ;Parsing the StdIn contents
    DoTest        EQU 01h ;Do the Test Function

  StatusFlags   DB  0  ;Yes/No Test bits for Status Tables
    HostStatus EQU 80h ;Do the Host/PCI/UHCI Status?
    FLStatus   EQU 40h ;Do the Frame List Status?
    QHStatus   EQU 20h ;Do the Queue Head Status?
    TDStatus   EQU 10h ;Do the Transfer Descriptor Status
    ADStatus   EQU 08h ;Do the Address Data Status
    NDStatus   EQU 04h ;Do the New Device Notification Status
    ErrLvl     EQU 02h ;Show ErrorLevel Table

  ;----------------------------------------------------------------------------
  ;Miscellaneous strings needed to print numbers and such to the screen
  ;These should not be moved to the OVL file, since they are not Fixed.
  ;----------------------------------------------------------------------------
  HexString: DB '0000_0000',0
  SingleMsg: DB ' '
  NoMsg:     DB 0
  DotMsg:    DB '.',0

  ;----------------------------------------------------------------------------
  ;Copyright Message
  ;This gets printed before we load the overlya file.
  ;----------------------------------------------------------------------------
  Copyright:
   #IF !LITE
    DB 'USBUHCI'
   #ELSE
    DB 'USBUHCIL'
   #ENDIF
    DB ' 0.14, (C) 2007-2010, Bret E. Johnson.',CR,LF
    DB "DOS Driver for a Universal HCI compatible USB Host Controller.",CR,LF
   #IF LITE
    DB '  LITE version (maximum 16 Devices, no Isochronous Transactions).',CR,LF
   #ENDIF
    DB LF,0


;==============================================================================
;Program Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Milliseconds to Delay between each Program Debug Step
  ;  -1 = No Program Debugging
  ;----------------------------------------------------------------------------
  DebugDelay DW -1

  ;----------------------------------------------------------------------------
  ;Device Address & Interface associated with Showing Report Descriptor
  ;  [ReportAddr] = 0 = Don't do anything
  ;----------------------------------------------------------------------------
  ReportAddr DB 0 ;Device Address
  ReportIntf DB 0 ;Interface Number

  ;----------------------------------------------------------------------------
  ;Device Address Downloading Descriptors
  ;  [DescrAddr] =  0 = Don't do anything
  ;              = -1 = Write Last Device Enumerated
  ;----------------------------------------------------------------------------
  DescrAddr DB 0 ;Device Address

  ;----------------------------------------------------------------------------
  ;Last (Highest) PCI Bus Number.
  ;This is used if the UHCI Controller is not already assigned a valid
  ;  IRQ Number.  When this is the case, we search ALL PCI Devices for
  ;  IRQ Numbers.  Knowing the Last Bus Number saves us some time
  ;  so that we don't search all 256 PCI Busses when there are only
  ;  one or two of them.
  ;----------------------------------------------------------------------------
  LastPCIBusNumber DB -1 ;Highest PCI Bus Number

  ;----------------------------------------------------------------------------
  ;Data needed to store User-provided IRQ and/or I/O Address Space values
  ;These will be used if the USB Controller has not already been assigned
  ;  a valid value (presumably by the BIOS when the computer boots up).
  ;----------------------------------------------------------------------------
  UserIOSpace DW 0 ;User-provided I/O Base Address
  UserIRQ     DB 0 ;User-provided IRQ

  ;----------------------------------------------------------------------------
  ;Timing value entered by user on command line during initialization
  ;----------------------------------------------------------------------------
  SOFModifyStart DW 12000

  ;----------------------------------------------------------------------------
  ;Temporary variable needed to issue Host Requests (Run/Stop/Reset/etc.)
  ;----------------------------------------------------------------------------
  DoHostReturnAX DW -1


;==============================================================================
;Pause Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings and Data needed to Pause the screen
  ;----------------------------------------------------------------------------
  PauseMsg:
    DB CR,LF
    DB ' MORE   (Esc stops Pausing, Ctrl-C stops Completely, any other Continues)',CR,0
  PauseNMsg:
    DB ' MORE                                                                    ',CR,LF,0
  PauseDMsg:
    DB '                                                                               ',CR,0
  PauseRows       DW      ?  ;Number of rows per screen
  PauseHeaderPtr  DD 1_0000h ;Pointer to Header Message
                             ;  High Word =  0 if Pausing has been cancelled
                             ;            = -1 if Output has been cancelled
                             ;  (start with a fake one <> 0)
  PauseHeaderSize DW      2  ;Number of lines in the Header Message
  PauseRowCount   DW      2  ;Current Row Counter


;==============================================================================
;DOS Environment Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Variables to search for our Environment Variable
  ;----------------------------------------------------------------------------
 #IF !LITE
  EnvVarString:  DB 'USBUHCI='     ;Environment Variable String
 #ELSE
  EnvVarString:  DB 'USBUHCIL='
 #ENDIF

  EnvVarSize    EQU $-EnvVarString ;Length of String
  EnvVarPointer  DW -1             ;Pointer to Program Environment Variable

  ;----------------------------------------------------------------------------
  ;Variables to search for an extended Command Line String
  ;This should only be valid/needed if the Command Line Size (PSP:[80h]) is 7Eh
  ;----------------------------------------------------------------------------
  CmdLineVarString:  DB 'CMDLINE='         ;Environment Variable String
  CmdLineVarSize    EQU $-CmdLineVarString ;Length of String
  CmdLineVarPointer  DW -1                 ;Pointer to Program Environment Variable


;==============================================================================
;Overlay File Related
;==============================================================================

  OvlFileName:
  OvlSignature:
   #IF !LITE
    DB 'USBUHCI.OVL',0
   #ELSE
    DB 'USBUHCIL.OVL',0
   #ENDIF

  OvlSignatureLen EQU $-OvlSignature-1 ;Size of Signature (not incl Zero)
  OvlNotFoundMsg:  DB 'Required Data File ',0
  OvlNotFoundMsg2: DB ' is missing, invalid, or incorrect version.',0
  OvlFileSize      DW ? ;Size of Overlay File Data
  OvlSegment       DW ? ;Overlay Segment


;==============================================================================
;EXEC Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Variables to Locate and Run another Program (EXEC Child Program)
  ;----------------------------------------------------------------------------
  PathToUse:       DB MaxPathSize DUP (0) ;Path to Use
  OurPathPointer   DW -1                  ;Pointer to our Path String
  CurrentPath:     DB  0                  ;Current Path (Zero-Length ASCIIZ)
  SupportFileGen:  DB 'USBSUPT1.COM',0    ;Support File for General Support
  SupportFileADND: DB 'USBDEVIC.COM',0    ;Support File for Address Info
  SupportFileHost: DB 'USBHOSTS.COM',0    ;Support File for Host Details

  PathVarString1:  DB 'PATH='             ;PATH Environment String Header (DOS)
  PathVarString2:  DB 'Path='             ;PATH Environment String Header (NT?)
  PathVarSize     EQU $-PathVarString2    ;Length of String
  PathVarPointer   DW -1                  ;Pointer to PATH Environment Variable

  ;----------------------------------------------------------------------------
  ;Variables needed to do EXEC Call
  ;----------------------------------------------------------------------------
  CmdTailSize DB CmdTailMax-2           ;Length of command tail (Maximize it)
  CmdTail:    DB CmdTailMax DUP (CR)    ;Command Tail for EXEC Call
  ParamBlock: DB ParamBlockSize DUP (?) ;Parameter Block for EXEC Call
  FCB1:       DB FCBSize DUP (?)        ;File Control Block #1
  FCB2:       DB FCBSize DUP (?)        ;File Control Block #2
  OldSPExec   DW ?                      ;SP may be destroyed by EXEC Call

  ;----------------------------------------------------------------------------
  ;Strings needed to set up Command Tail for Exec Call(s)
  ;----------------------------------------------------------------------------
  DescriptorMsg: DB 'Descriptor',0
  ControlPktMsg: DB 'ControlPacket',0
  RptDescrMsg:   DB 'ReportDescriptor',0
  UHCIMsg:       DB 'UHCI',0
  NMsg:          DB 'N',0
  HostIndexMsg:  DB 'xx',0


;==============================================================================
;Program Status Related
;Some of the Status related code is in other programs that we call, but
;  some is here.  This takes a lot of room to store the strings and code
;  we need to do thisl, so is a place we could "offload" to a different
;  program to decrease our size.
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings and Tables to Print a Transfer Descriptor Status to the screen
  ;----------------------------------------------------------------------------

TDTypeSpecificTbl:
 #IF !LITE
  DB TDTypeIsoch
     DW WriteTDIsoch
 #ENDIF
  DB TDTypeInterrupt1Time
     DW WriteTDInterrupt1Time
  DB TDTypeInterruptPer
     DW WriteTDInterruptPer
  DB TDTypeControlSetup
     DW WriteTDControlSetup
  DB TDTypeControlData
     DW WriteTDControlData
  DB TDTypeControlStatus
     DW WriteTDControlStatus
  DB TDTypeBulk
     DW WriteTDBulk
  DB -1    ;End of
     DW -1 ;  Table


;==============================================================================
;Alias Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Table needed to temporarily store Aliases.
  ;They are originally sorted in reverse alphabetical order.
  ;To write them in forward alphabetical order, we temporarily store
  ;  the String Pointers, in the original reverse order, in this table.
  ;  We then write the strings, starting with the last entry in this table
  ;  and moving backwards.
  ;The number of entries in this table must be AT LEAST as big as the largest
  ;  number of Aliases for a single command Option.  Most Options don't have
  ;  more than a dozen or so Aliases.
  ;----------------------------------------------------------------------------
  AliasSortTbl:
    DW 40 DUP (?) ;Table to store Alias Strings (to reverse order)


;==============================================================================
;Command-line (Parsing) Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Memory Segment to store compressed STDIN contents
  ;----------------------------------------------------------------------------
  StdInSegment DW ?

  ;----------------------------------------------------------------------------
  ;Data needed to Parse the command line for Options
  ;----------------------------------------------------------------------------
  ParseTest    DB  ? ;Testing the command for errors or for real?
  ParseError   DB No ;Error while Parsing Command Line?
  IndexToWrite DW -1 ;Storage area for Numbers on Command Line

  ;----------------------------------------------------------------------------
  ;Strings needed to write the Command-line error message
  ;----------------------------------------------------------------------------
;  MoreLeftMsg:   DB '<<-More}  ',0
;  MoreRightMsg:  DB '  {More->>',0
  MoreMsgSize EQU 11

  ;----------------------------------------------------------------------------
  ;TABLE OF SUBROUTINE OFFSETS TO PROCESS THE VARIOUS COMMAND LINE OPTIONS
  ;----------------------------------------------------------------------------
  SwitchTbl:
    DB  '?'                     ;Help
       DW DoSwitchH
    DB  'A'                     ;Alias List
       DW DoSwitchA
    DB  'D'                     ;Disable
       DW DoSwitchD
    DB  'E'                     ;Enable
       DW DoSwitchE
    DB  'I'                     ;PCI Search Index
       DW DoSwitchI
    DB  'L'                     ;Install in Low Memory
       DW DoSwitchL
    DB  'P'                     ;Pause at beginning of Program before searching
       DW DoSwitchP
    DB  'R'                     ;Show Report Descriptor
       DW DoSwitchR
    DB  'U'                     ;Uninstall
       DW DoSwitchU
    DB  OptionADStatus          ;Address Data Status
       DW DoSwitchADStatus
    DB  OptionBeep              ;Beep the Speaker
       DW DoSwitchBeep
    DB  OptionDisableLegacy     ;Disable Legacy Support
       DW DoSwitchDisableLegacy
    DB  OptionDisableOther      ;Disable other Control Program
       DW DoSwitchDisableOther
    DB  OptionSetConfig         ;Set Configuration Value for Device
       DW DoSwitchSetConfig
    DB  OptionDescriptor        ;Descriptor Switch
       DW DoSwitchDescriptor
    DB  OptionHostStatus        ;PCI/UHCI Status
       DW DoSwitchHostStatus
    DB  OptionDebug             ;Debug Mode
       DW DoSwitchDebug
    DB  OptionProgDebug         ;Program Debug
       DW DoSwitchProgDebug
    DB  OptionErrLvl            ;ErrorLevel Table
       DW DoSwitchErrLvl
    DB  OptionFLStatus          ;Frame List Status
       DW DoSwitchFLStatus
    DB  OptionTiming            ;Frame Timing Switch
       DW DoSwitchTiming
    DB  OptionUserIO            ;User-provided I/O Base Address
       DW DoSwitchIOSpace
    DB  OptionUserIRQ           ;User-provided IRQ
       DW DoSwitchIRQ
    DB  OptionNDStatus          ;New Device Notification Data Status
       DW DoSwitchNDStatus
    DB  OptionPwrReset          ;Power Reset
       DW DoSwitchPowerReset
    DB  OptionPwrOff            ;Power Off
       DW DoSwitchPowerOff
    DB  OptionPwrOn             ;Power On
       DW DoSwitchPowerOn
    DB  OptionQHStatus          ;Queue Head Status
       DW DoSwitchQHStatus
    DB  OptionResetBad          ;Reset all Bad Devices
       DW DoSwitchResetBad
    DB  OptionReset             ;Reset
       DW DoSwitchReset
    DB  OptionRmtWakeup         ;Enable/Disable Remote Wakeup for Device
       DW DoSwitchRmtWakeup
    DB  OptionResume            ;Resume
       DW DoSwitchResume
    DB  OptionSingleStep        ;Single Step
       DW DoSwitchSingleStep
    DB  OptionSuspend           ;Global Suspend
       DW DoSwitchSuspend
    DB  OptionTDStatus          ;Transfer Descriptor Status
       DW DoSwitchTDStatus
    DB  OptionTestMode          ;Enable/Disable Test Mode for Device
       DW DoSwitchTestMode

    DB  0                       ;End of Table


  ;----------------------------------------------------------------------------
  ;TABLE TO BE ABLE TO PRINT ALIASES FOR SwitchList2
  ;----------------------------------------------------------------------------
  SwitchTbl2:
    DB 1    ;Host/Root Hub
      DW -1
    DB -1   ;All Hosts
      DW -1

    DB 0

  ;----------------------------------------------------------------------------
  ;TABLE TO BE ABLE TO PRINT ALIASES FOR SwitchListYesNo
  ;----------------------------------------------------------------------------
  SwitchTblYesNo:
    DB 'N'  ;No
      DW -1
    DB 'Y'  ;Yes
      DW -1

    DB 0


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;PROGRAM CODE (NOT NEEDED IN TSR)
;Needed to initialize/update/show status of TSR, but not actually needed
;  in memory while TSR is running
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;------------------------------------------------------------------------------
;INITIALIZE/UPDATE THE PROGRAM
;Inputs:
;Outputs: Lots of Stuff
;Changes: Everything
;------------------------------------------------------------------------------
Main:
  CLD                           ;Go forward with string functions
  MOV  SP,LastProgByte          ;Reset Stack Pointer
  CALL ResizeMemory             ;Resize our Memory Allocation
  CALL CopyNameToMCB            ;Copy our Program name to the MCB
  CALL MoveDTA                  ;Relocate the DOS Disk Transfer Area
  CALL SetupPauseNoHdr          ;Set up the Pause Stuff
  MOV  DX,Copyright             ;Write the
  CALL WriteZPause              ;  Copyright Message
  CALL GetOurPath               ;Get the Pointer to Our Path
  CALL LoadOvlFile              ;Load the Overlay File (Quits if Err)
  CALL GetStdInSegment          ;Set up the StdIn Memory Segment (Quits if Err)
  CALL SetupExec                ;Setup Exec Parameters
  CALL GetEnvVars               ;Get the Environment variable Pointers
  CALL ParseIt                  ;Parse the Command Line
  CALL RlsStdInSegment          ;Release the StdIn Segment (used for parsing)
  CALL DoUninstall              ;Uninstall and quit, if necessary
  CALL DoHelp                   ;Print Help and Quit, if necessary
  CALL DoAliases                ;Print Aliases and Quit, if necessary
  CALL DoErrLvls                ;Print ErrorLevel Table and Quit, if necessary
  CALL DoResetBads              ;Reset Bad Devices and Quit, if necessary
  CALL TestCompatibility        ;Test for compatibility (quit if not)
  CALL DoHostStatus             ;Write the UHCI/PCI Status & quit, if necessary
  CALL DoDescriptors            ;Downlaod/Write Descriptrs & 1uit
  CALL DoReportDescr            ;Download/Write tReport Descriptor & quit
  TEST [ProgFlags],InMemory     ;Are we already installed in memory?
  JZ  >M50                      ;If not, install as a TSR
  CALL DoStatuses               ;If necessary, write the Statuses & Quit
  MOV  DX,SIDUpdate             ;If so, point at Update message
  CALL WriteZPause              ;Write it
  MOV  DX,NoMsg                 ;Point to no message
  XOR  AL,AL                    ;Errorlevel = 0
  JMP  Exit                     ;QUIT

M50:                            ;First-time installation (install as TSR)
  CALL DelEnvironment           ;Delete extra environment space we don't need
  CALL FindFirstUMCB            ;Find the start of Upper Memory ([FirstUMCB])
  CALL MoveProgramToUMB         ;Move Program to Upper Memory, if possible
                                ;Returns ES = TSR Segment
   ;All Subroutines after this MUST assume ES is TSR Segment, NOT CS!!
  MOV  DS,ES                    ;Point DS at TSR Data Segment
  CALL CalcBasePhysAddr         ;Calculate the Physical Address of our program
                                ;  Quits program if error
  TEST [TSRFlags],FirstInstance ;Are we the first Instance in Memory?
  JZ  >M60                      ;If not, continue
  MOV  [FirstInstanceSeg],ES    ;If so, set [FirstInstanceSeg] correctly
M60:                            ;[FirstInstanceSeg] is set
  CALL WriteInitializing        ;Tell user what we're doing
  CALL InitTSRStack             ;Initialize the TSR Stack Space
  CALL CalcHostIndex            ;Calculate Host Index - Quit if Already Full
  CALL IncNumInstances          ;Inform First Instance of TSR that we're here
  CALL CalcOffsets              ;Calculate our Table and Stack Offsets
  CALL StoreMiscOffsets         ;Calculate and Store Miscellaneous Offsets
  CALL FillQueueHeadTbl         ;Fill up the
  CALL FillTransferDescTbl      ;  tables with
  CALL FillFrameListTbl         ;  do-nothing entries
  CALL InitInt14Reqs            ;Initialize our Int 14 internal Requests
  CALL InitSetupRequestTbl      ;Initialize the Setup Request Table
  CALL DbgGenStats              ;Display Debug Statistics, if appropriate
  CALL SetUSBStatus             ;Save the current USB status (completely!)
  MOV  SI,(IntNumTable+3)       ;Change the Interrupts
  CALL ChangeInts               ;  to point at us
  CALL StartUSBInt              ;Enable the USB IRQ and point it at us
  CALL DoHostAdd                ;Inform other programs of the new Host Index
  CALL StartUSB                 ;Start up the Host Controller (quits if error)
  MOV  DS,CS                    ;Point DS at local data (where Strings are)

  XOR  AL,AL                     ;ErrorLevel = 0
  MOV  BX,ES                     ;BX = TSR Segment
  MOV  CX,DS                     ;CX = Current Segment
  MOV  DX,SIDInstall1            ;Write the first part of the
  CALL WriteZPause               ;  Install Message
  TEST ProgFlags,MemoryMoved     ;Did we move the TSR Memory?
  JZ  >M90                       ;If not, use TSR Exit
  MOV  DX,SIDInstallAuto         ;Write
  CALL WriteZPause               ;  "automatically"
  MOV  DX,SIDInstallHole         ;Assume we installed in a Low Memory Hole
  CMP  BX,[FirstUMCB]            ;Did we install in a UMB or a Low Memory Hole?
  JB  >M80                       ;If a Low Memory Hole, leave the message as is
  MOV  DX,SIDInstallHigh         ;If a UMB, point at Installed High message
M80:                             ;[DX] = appropriate Memory Message
  CALL WriteZPause               ;Write the Memory Message
  MOV  DX,SIDInstallLast         ;Point at the last part of the Installed Message
  JMP  Exit                      ;Done

M90:                             ;Exit Program as a TSR
  MOV  DX,SIDInstallNorm         ;Assume we're in Low Memory
  CMP  CX,[FirstUMCB]            ;Are we in Low Memory?
  JB  >M95                       ;If so, continue
  MOV  DX,SIDInstallHigh         ;If not, point at the High Memory message
M95:                             ;[DX] = appropriate Memory Message to write
  CALL WriteZPause               ;Write the Memory Message
  MOV  DX,SIDInstallLast         ;Write the last part of the
  CALL WriteZPause               ;  Install Message
  MOV  DX,(LastTSRByte+15)SHR 4  ;DX = # of TSR paragraphs if First Instance
  TEST ES:TSRFlags,FirstInstance ;Is this the First Instance?
  JNZ >M97                       ;If so, we're done
  MOV  DX,(LastTSRByte0+15)SHR 4 ;If not, Number of TSR paragraphs is this
M97:                             ;DX contains correct Size
  CALL RlsExtraMem               ;Release the Extra Memory Segment(s)
  CALL CloseHandles              ;Close all Open File Handles
  MOV  AH,31h                    ;Function 31h (TSR), ErrorLevel in AL (0)
  INT  21h                       ;Do it

;------------------------------------------------------------------------------
;CLOSE ALL OPEN FILE HANDLES
;Inputs:
;Outputs:
;Changes: Closes File Handles 0-19
;NOTES:   We need to do this when terminating with INT 21.31 (TSR), since that
;           function does not close open handles.  The standard Terminate
;           function (INT 21.4C) does, so we we don't need to worry
;           about it there.
;------------------------------------------------------------------------------
CloseHandles:
  PUSH AX,BX  ;Save used registers
  MOV  BX,19  ;Start with handle 19 (Close 20 Handles)
C10:          ;Loop to here for each Handle
  MOV  AH,3Eh ;Function 3Eh (Close Handle)
  INT  21h    ;Do it (don't care about errors)
  DEC  BX     ;Decrement the Handle Number
  JNZ  C10    ;If not done yet, keep going
  POP  BX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;MAKE SURE AN MCB (MEMORY CONTROL BLOCK) CONTAINS OUR PROGRAM NAME
;Inputs:  ES = Segment to Store Name in
;         CS:[MCBName] = ASCIIZ Program Name
;         CLD Already Issued
;Outputs: MCB Associated with ES Segment contains our Name
;         Segment is set as its own Owner in the MCB
;Changes:
;NOTES:   This makes sure that the MCB (Memory Control Block) for our
;           program contains our program name.  DOS 4+ does this
;           automatically, but DOS versions 1-3 do not.  This code
;           does not verify which DOS version is in use, but simply
;           fills in the MCB no matter what.
;         Our program name is needed in the MCB to make sure other programs
;           can identify that we are installed in memory.  This code should
;           be added to all TSR's, so that memory-mapping programs
;           (like MAPMEM or ISLOADED) can tell which TSR's are installed
;           in memory.  It should also be added to all programs that
;           EXEC other programs, so that the EXEC'd program can figure out
;           who called it.
;         Programs that are not TSR's and do not EXEC other programs
;           do not necessarily need this code.
;------------------------------------------------------------------------------
CopyNameToMCB:
  PUSH CX,DI,SI                 ;Save used registers
  PUSH DS,ES                    ;Save used registers
  MOV  CX,ES                    ;ES:[DI] =
  DEC  CX                       ;  where
  MOV  ES,CX                    ;  to store
  MOV  DI,(OFFSET MCBOwnerName) ;  the Name
  MOV  DS,CS                    ;DS:[SI] =
  MOV  SI,MCBName               ;  name to store
  MOV  CX,4                     ;Copy 4 words (8 bytes)
  REP  MOVSW                    ;Copy our program name to the MCB
  MOV  DI,(OFFSET MCBOwnerID)   ;ES:[DI] = Where to Store Owner
  MOV  ES:[DI],ES               ;Make it
  INC  W ES:[DI]                ;  Own Itself
  POP  ES,DS                    ;Restore used registers
  POP  SI,DI,CX                 ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED BECAUSE WE ARE A TSR.  NEEDED TO FIND EXISTING PROGRAM
;  IN MEMORY, UNINSTALL FROM MEMORY, ETC.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;CHECK MEMORY TO SEE IF PROGRAM IS ALREADY INSTALLED
;Inputs:  CS = DS = ES = Local Data Area
;         [ProgFlags].InMemory = No
;         CLD already issued
;Outputs: ES = TSR program segment, whether a TSR yet or not
;         InMemory     = Yes if program is already installed as TSR
;                      = No if not
;         [AMISHandle] = Multiplex interrupt handle number for Interrupt 2Dh
;         [FirstInstanceSeg] set as appropriate
;Changes:
;------------------------------------------------------------------------------
TestMemory:
  PUSH AX,BX,CX,DX,DI,SI        ;Save used registers
  CALL TestMemory2F             ;Is there a Pre-AMIS version installed?
  JC  >M70                      ;If so, Error
  OR   [TSRFlags],FirstInstance ;Assume this will be the First Instance
  XOR  AH,AH                    ;Start with Handle 0
M10:                            ;Loop to here for each handle number
  MOV  AL,AMISInstallChk        ;Install Check Function
  INT  2Dh                      ;Do it (Rtns AL, CX, DX:[DI])
  CMP  AL,-1                    ;Is this function installed?
  JNE >M40                      ;If not, our code can't be installed yet
M20:                            ;AH = Valid Handle Number
  MOV  BX,CX                    ;Save version number in BX
  MOV  ES,DX                    ;ES:[DI] = TSR Manufacturer & Program Name
  MOV  SI,AMISMfgName           ;ES:[SI] = Our Manufacturer & Program Name
  MOV  CX,16                    ;CX = Number of bytes to compare
  REPE CMPSB                    ;Does it match?
  JNZ >M50                      ;If not, try the rest of the Handles
  CMP  BX,AMISVersion           ;If so, is it the correct version?
  JNE >M70                      ;If not, error
M30:                            ;We've found an Instance of the program (ES)
  MOV  BX,ES:[FirstInstanceSeg] ;Copy the First Instance Segment
  MOV  [FirstInstanceSeg],BX    ;  to our Local Data Area
  AND  [TSRFlags],(NOT FirstInstance) ;Mark as not First Instance in Local Seg
  MOV  AL,AMISGetPCIIndex       ;Get the PCI Search Index
  INT  2Dh                      ;Do it
  CMP  BX,[PCISearchIndex]      ;Is it for our Host?
  JE  >M80                      ;If so, we've found it
  JMP >M50                      ;If not, keep looking
M40:                            ;Invalid AMIS Handle
  CMP  [AMISHandle],-1          ;Do we already have an AMIS Handle?
  JNE >M50                      ;If so, continue
  MOV  [AMISHandle],AH          ;If not, we'll try to use this one
M50:                            ;Done checking this Handle
  INC  AH                       ;Increment Handle Number
  JNZ  M10                      ;If no overflow, keep looking
M60:                            ;Not installed yet
  MOV  ES,CS                    ;ES = Local Data Area
  JMP >M90                      ;Done
M70:                            ;Different Version Found
  MOV  AL,ErLvlVersion          ;AL = ErrorLevel = Wrong version
  MOV  DX,SIDWrongVer           ;[DX] = Error message
  JMP  Exit                     ;Quit
M80:                            ;We've already been installed (ES = segment)
  OR   [ProgFlags],InMemory     ;Mark as already installed
M90:                            ;We're done
  POP  SI,DI,DX,CX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF AN OLD (PRE-AMIS) VERSION OF THE PROGRAM IS INSTALLED
;Inputs:  CS = DS = ES = Local Segment
;Outputs: CF = Clear if OK (Pre-AMIS Version of TSR not Installed)
;            = Set if Error (Pre-AMIS version installed)
;Changes: [HandleNum]
;NOTES: Our Pre-AMIS TSR's used a somewhat non-standard method of scanning
;         to discover if we were already installed in memory or not, and
;         if not, to discover an available Handle Number to use.
;       Because it was non-Standard, we had to worry about what other
;         TSR's would return in some of the registers, and therefore
;         have to save ALL registers each time trhough the Loop.
;------------------------------------------------------------------------------
TestMemory2F:
  PUSH AX,BX,CX,DX,DI    ;Save all registers that might change
  PUSH SI,BP,DS,ES       ;  (includes everything except SS & SP)
  MOV  AH,0C0h           ;Function C0, (first available user handle)
F10:                     ;Loop to here for each handle number
  CLD                    ;Go forward with string functions
  XOR  BX,BX             ;Make sure
  XOR  CX,CX             ;  all registers
  XOR  DX,DX             ;  are zero
  MOV  [HandleNum],AH    ;Store the handle number
  MOV  AL,MuxInstallChk  ;Install Check Function
  INT  2Fh               ;Do it
  CMP  AL,0FFh           ;Is this function installed?
  JNE >F50               ;If not, try the Next Handle
F20:                     ;Test Program Name
  MOV  AH,[HandleNum]    ;Get the handle number back again
  MOV  AL,MuxGetProgName ;Get Program Name
  XOR  DI,DI             ;  Function
  INT  2Fh               ;Do it (returns ES:[DI])
  MOV  SI,AMISPrgName    ;[SI] = Our Name
  MOV  CX,8              ;Get the string length
  REPE CMPSB             ;Compare the two strings
  JNE >F50               ;If not the same, it's not us
F30:                     ;Test Author
  MOV  AH,[HandleNum]    ;Get the handle number back again
  MOV  AL,MuxGetAuthor   ;Get Author Function
  INT  2Fh               ;Do it (returns ES:[DI])
  MOV  SI,Author         ;[SI] = Our Name
  MOV  CX,AuthorLen      ;Get the string length
  REPE CMPSB             ;Compare the two strings
  JE  >F70               ;If a match, it's a Pre-AMIS version
F50:                     ;Increment the Handle number and try again
  MOV  DS,CS             ;Make sure another
  MOV  ES,CS             ;  Int 2F installation check routine
  MOV  AH,[HandleNum]    ;  hasn't changed things
  ADD  AH,1              ;Look at the next handle number
  JNC  F10               ;If no overflow, keep looking
  JMP >F80               ;If overflow, we couldn't find it
F70:                     ;Error (Pre-AMIS version found)
  STC                    ;Set return flag
  JMP >F90               ;Done
F80:                     ;Did not find a Pre-AMIS version
  CLC                    ;Set return flag
F90:                     ;We're done
  POP  ES,DS,BP,SI       ;Restore
  POP  DI,DX,CX,BX,AX    ;  all registers
  RET

;------------------------------------------------------------------------------
;PRINT MESSAGE IN DX AND QUIT WITH ERRORLEVEL IN AL
;Inputs:  AL = Errorlevel to exit program with
;         DS:[DX] = Message to Print (to ERR)
;Outputs:
;Changes: Quits program
;------------------------------------------------------------------------------
Exit:
  OR   AL,AL          ;Was there an Error?
  JZ  >X80            ;If not, jump to handle a normal termination
  CALL BeepErr        ;If error, Beep Once
  CALL WriteZErr      ;Write message to ERR
  CALL WriteCrLfErr   ;Write a new line
  JMP >X90            ;Jump to quit
X80:                  ;No Error - Write to CON
  CALL WriteZPause    ;Write the message to CON
  CALL WriteCrLfPause ;Write a new line
X90:                  ;We're done!!
  CALL RlsExtraMem    ;Release the Extra Memory Segment(s)
  MOV  AH,4Ch         ;Service 4Ch (terminate program)
  INT  21h            ;Do it

;------------------------------------------------------------------------------
;RELEASE THE EXTRA MEMORY SEGMENT(S)
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         [OvlSegment]    = Overlay Segment (0 if unused)
;         [StdInSegment]  = StdIn Segment (0 if unused)
;         [WastedSegment] = Wasted Segment (should never be 0)
;Outputs: Releases Overlay & StdIn segments, if they exist
;Changes:
;NOTES: The Overlay segment contains almost all of the strings we need to write,
;         so this must be called AFTER ALL strings have been written.
;------------------------------------------------------------------------------
RlsExtraMem:
  CALL RlsStdInSegment  ;Release the StdIn Segment
  CALL RlsOvlSegment    ;Release the Overlay Segment
  RET

RlsStdInSegment:
  PUSH BX                      ;Save used registers
  MOV  BX,OFFSET StdInSegment  ;[BX] = Segment to Release
  JMP >G00                     ;Do it
RlsOvlSegment:
  PUSH BX                      ;Save used registers
  MOV  BX,OFFSET OvlSegment    ;[BX] = Segment to Release
;  JMP >G00                     ;Do it
G00:
  PUSH AX,ES                   ;Save used registers
  CMP  W [BX],0                ;Valid Segment?
  JE  >G90                     ;If not, we're done
  MOV  ES,[BX]                 ;If so, ES = Segment to Release
  MOV  AH,49h                  ;Service 49h (Free Memory Segment in ES)
  INT  21h                     ;Do it
  MOV  W [BX],0                ;Mark it as invalid
G90:                           ;Done
  POP  ES,AX                   ;Restore used registers
  POP  BX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE "INITIALIZING" MESSAGE TO THE SCREEN
;Inputs:  DS = ES = TSR Data Area
;         CS = Local (non-TSR) Data Area
;Outputs: [PCISearchIndex]
;Changes:
;------------------------------------------------------------------------------
WriteInitializing:
  PUSH AX,DX,DS               ;Save used registers
  MOV  DS,CS                  ;Point DS at local data area
  MOV  DX,SIDInitializing1    ;Write first part
  CALL WriteZPause            ;  of the message
  MOV  AX,ES:[PCISearchIndex] ;Write the
  CALL WriteWordMin           ;  Search Index
  MOV  DX,SIDInitializing2    ;Write last part
  CALL WriteZPause            ;  of the message
  POP  DS,DX,AX               ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO INITIALIZE AND START THE USB HOST
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;CALCULATE THE OFFSETS TO OUR USB TABLES AND OUR STACKS
;Inputs:  DS = ES = TSR Data Area
;Outputs: [FLOffsetW], [FLOffsetDW]
;Changes:
;------------------------------------------------------------------------------
CalcOffsets:
  PUSH EAX,EBX,DI,SI,BP      ;Save used registers
  XOR  DI,DI                 ;DS:[DI] = Beginning of our Program
  CALL SegOff2PhysAddrESDI   ;Convert it to a Physical Address (EAX)
  MOV  EBX,EAX               ;Calculate 4K Offset
  AND  EAX,0FFFF_F000h       ;  to beginning of
  SUB  EBX,EAX               ;  our Program
  MOV  AX,BX                 ;Start with that value as an Offset
  ADD  AX,(FrameAndStackBuff+(FLSize*FLEntries)-1) ;Add the offset to the end of our buffer
  AND  AX,0F000h             ;Convert to a 4K Page Offset
  SUB  AX,BX                 ;Subtract out our Code Segment Offset
  MOV  [FLOffsetW],AX        ;This is the start of our Frame List Table
  MOV  DI,AX                 ;Save it in DI
  CALL SegOff2PhysAddrESDI   ;Calculate and Store the Physical Address
  MOV  [FLOffsetDW],EAX      ;  of the Frame List Table
  MOV  SI,DI                 ;[SI] = Upper
  ADD  SI,(FLSize*FLEntries) ;  Buffer Pointer
  MOV  DI,FrameAndStackBuff  ;[DI] = Lower Buffer Pointer
 ;--------------------------------
 ;Device and Configuration Buffers
 ;--------------------------------
  MOV  BX,OFFSET DvcDescrPtr ;[BX] = Table Pointer
  MOV  BP,(((DvcDescrSize+CfgDescrSize+CfgDescrXBytes)+1) AND 0FFFEh)
                             ;BP = Number of Bytes in Buffers
  CALL CalcTblOffsetW        ;Calculate the Buffer Pointer
  MOV  BX,[BX]               ;Calculate the
  ADD  BX,DvcDescrSize       ;  Configuration
  MOV  [CfgDescrPtr],BX      ;  Buffer Pointer
 ;----------------
 ;Queue Head Table
 ;----------------
  MOV  BX,OFFSET QHTable     ;[BX] = Table Pointer
  MOV  BP,(QHSize*QHEntries) ; BP  = Number of Bytes in Table
  CALL CalcTblOffsetP        ;Calculate the Table Pointer
 #IF LITE
 ;------------------
 ;Address Data Table
 ;------------------
  MOV  BX,OFFSET ADTable     ;[BX] = Table Pointer
  MOV  BP,(ADSize*ADEntries) ; BP  = Number of Bytes in Table
  CALL CalcTblOffsetW        ;Calculate the Table Pointer
 ;---------------
 ;Interface Table
 ;---------------
  MOV  BX,OFFSET InTable     ;[BX] = Table Pointer
  MOV  BP,(InSize*InEntries) ; BP  = Number of Bytes in Table
  CALL CalcTblOffsetW        ;Calculate the Table Pointer
 ;-------------------------
 ;Alternate Interface Table
 ;-------------------------
  MOV  BX,OFFSET AITable     ;[BX] = Table Pointer
  MOV  BP,(AISize*AIEntries) ; BP  = Number of Bytes in Table
  CALL CalcTblOffsetW        ;Calculate the Table Pointer
 #ENDIF
 ;--------------
 ;EndPoint Table
 ;--------------
  MOV  BX,OFFSET EnTable     ;[BX] = Table Pointer
  MOV  BP,(EnSize*EnEntries) ; BP  = Number of Bytes in Table
  CALL CalcTblOffsetW        ;Calculate the Table Pointer
 ;-------------------
 ;Setup Request Table
 ;-------------------
  MOV  BX,OFFSET SRTable     ;[BX] = Table Pointer
  MOV  BP,(SRSize*SREntries) ; BP  = Number of Bytes in Table
  CALL CalcTblOffsetW        ;Calculate the Table Pointer
 ;-------------
 ;Timeout Table
 ;-------------
  MOV  BX,OFFSET TTTable     ;[BX] = Table Pointer
  MOV  BP,(TTSize*TTEntries) ; BP  = Number of Bytes in Table
  CALL CalcTblOffsetW        ;Calculate the Table Pointer
 ;----------------
 ;Large Call Table
 ;----------------
  MOV  BX,OFFSET LCTable     ;[BX] = Table Pointer
  MOV  BP,(LCSize*LCEntries) ; BP  = Number of Bytes in Table
  CALL CalcTblOffsetW        ;Calculate the Table Pointer
 ;-----------
 ;Reset Table
 ;-----------
  MOV  BX,OFFSET RsTable     ;[BX] = Table Pointer
  MOV  BP,(RsSize*RsEntries) ; BP  = Number of Bytes in Table
  CALL CalcTblOffsetW        ;Calculate the Table Pointer
  POP  BP,SI,DI,EBX,EAX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE AND STORE THE OFFSET FOR A DATA TABLE IN THE FRAME & STACK AREA
;Inputs:  DS = ES = TSR Data Area
;         [BX] = Where to store the Table Pointer
;          BP  = Number of Bytes Required for the Table
;          DI  = Start of lower buffer
;          SI  = Start of upper buffer
;Outputs: [BX] = Filled in
;                DI,SI updated as appropriate
;         Quits Program if Error (Table will not fit into either buffer)
;           (should never happen)
;Changes:
;------------------------------------------------------------------------------
CalcTblOffsetW:
  PUSH AX             ;Save used registers
  XOR  AX,AX          ;Mark as word alignment
  JMP >C00            ;Do it
CalcTblOffsetP:
  PUSH AX             ;Save used registers
  MOV  AL,-1          ;Mark as paragraph alignment
;  JMP >C00            ;Do it
C00:
  PUSH CX,DX          ;Save used registers
  MOV  CX,DI          ;CX = Lower Buffer Offset
  MOV  DX,SI          ;DX = Lower Buffer Offset
  OR   AL,AL          ;Need word alignment?
  JNZ >C20            ;If not, handle paragraph alignment
C10:                  ;Need Word Alignment
  INC  CX             ;Convert Lower Buffer Offset
  AND  CL,(NOT 1)     ;  to Word Alignment
  INC  DX             ;Convert Upper Buffer Offset
  AND  DL,(NOT 1)     ;  to Word Alignment
  JMP >C30            ;Continue
C20:                  ;Need paragraph alignment
  ADD  CX,15          ;Convert Lower Buffer Offset
  AND  CL,(NOT 15)    ;  to Paragraph Alignment
  ADD  DX,15          ;Convert Upper Buffer Offset
  AND  DL,(NOT 15)    ;  to paragraph Alignment
C30:                  ;Try to put in Lower Buffer
  PUSH CX             ;Save Lower Buffer Pointer momentarily
  SUB  CX,[FLOffsetW] ;Calculate Lower
  NEG  CX             ;  Buffer Size
  CMP  BP,CX          ;Will the Table fit into the Lower Buffer?
  POP  CX             ;Restore Lower Buffer Pointer
  JA  >C40            ;If not, try the Upper Buffer
  MOV  [BX],CX        ;If OK, store the Table Pointer
  MOV  DI,CX          ;Update the Buffer Pointer
  ADD  DI,BP          ;  for next time
  JMP >C90            ;Done
C40:                  ;Try to put in upper buffer
  PUSH DX             ;Save Upper Buffer Pointer momentarily
  SUB  DX,(FrameAndStackBuff+8192) ;Calculate Upper
  NEG  DX             ;  Buffer Size
  CMP  BP,DX          ;Will the Table fit into the Upper Buffer?
  POP  DX             ;Restore Upper Buffer Pointer
  JA  >C70            ;If not, error
  MOV  [BX],DX        ;If OK, store the Table Pointer
  MOV  SI,DX          ;Update the Buffer Pointer
  ADD  SI,BP          ;  for next time
  JMP >C90            ;Done
C70:                  ;Error (no room in either buffer)
  MOV  AL,ErLvlInternal  ;ErrorLevel = Internal Error
  MOV  DX,SIDInternalErr ;[DX] = Error Message
  JMP  Exit              ;Quit Program
C90:                  ;Done
  POP  DX,CX          ;Restore used registers
  POP  AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;STORE THE MISCELLANEOUS OFFSETS WE NEED TO KEEP TRACK OF
;Inputs:  DS = ES = TSR Data Area
;Outputs: [ResetTblOffset]
;Changes:
;------------------------------------------------------------------------------
StoreMiscOffsets:
  PUSH AX                  ;Save used registers
  MOV  AX,DS:[RsTable]     ;Default Reset Table Entry =
  MOV  [ResetTblOffset],AX ;  First One
  POP  AX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE WHAT OUR HOST INDEX SHOULD BE, AND STORE IT, AND COPY NEW DEVICE TBL
;Inputs:  DS = ES = TSR Data Area
;         [TSRFlags].FirstInstance, [FirstInstanceSeg]
;Outputs: [HostIndexes], [USBHostIndex], [USBHostMask], NewDvcTable
;Changes:
;------------------------------------------------------------------------------
CalcHostIndex:
  PUSH AX,BX,CX,SI,GS           ;Save used registers
  MOV  GS,[FirstInstanceSeg]    ;GS = First Instance Segment
  MOV  CL,B [PCISearchIndex][0] ;Try to match
  MOV  AX,0001h                 ;  Host Index
  SHL  AX,CL                    ;  with PCI Serch Index
  XOR  BX,BX                    ;Assume no other Hosts yet
  CALL TestUSBHost              ;Is another Host Driver already installed?
  JC  >I80                      ;If not, store the values we have
I10:                            ;Another Host is already installed
  MOV  SI,Int14Request4         ;If so, point at Int 14h Request Structure
  MOV  [SI].I14RHostIndex,AllHostsIndex ;Requests go to All Hosts
  TEST [TSRFlags],FirstInstance ;Is this the first instance of our program?
  JZ  >I20                      ;If not, no need to copy New Device Table
  MOV  [SI].I14RRequestType,I14RRTCopyNDTable ;Request = Copy New Device Table
  MOV  W [SI].I14RDataAddress[2],ES           ;Copy it to our
  MOV  W [SI].I14RDataAddress[0],NDTable      ;  New Device Table
  MOV  [SI].I14RDataSize,(NDSize*NDEntries)   ;Size of the Table
  CALL DoInt14CallSI            ;Do it
I20:                            ;New Device Table Handled
  MOV  [SI].I14RRequestType,I14RRTGetHostHWInfo ;Get Hardware Info
  CALL DoInt14CallBXSI          ;Do it (returns BitMap in BX)
  MOV  CH,MaxHosts              ;Initialize Loop Counter
I30:                            ;Loop to here to find an Empty Index
  TEST AX,BX                    ;Is this Index Available?
  JZ  >I80                      ;If so, use it
  CMP  CL,(MaxHosts-1)          ;Maximized the Index yet?
  JB  >I40                      ;If not, handle it
  XOR  CL,CL                    ;If so, start it at
  MOV  AX,0001h                 ;  0 again
  JMP >I50                      ;Continue
I40:                            ;Increment Host Index to test
  SHL  AX,1                     ;Go to next
  INC  CL                       ;  Host Index
I50:                            ;Have Host Index incremented
  DEC  CH                       ;Decrement loop counter
  JNZ  I30                      ;If not done yet, keep looking
I70:                            ;Error - Quit
  MOV  AL,ErLvlTooManyHosts     ;ErrorLevel = Too Many Hosts Already Installed
  MOV  DX,SIDTooManyHosts       ;Error Message
  JMP  Exit                     ;Quit
I80:                            ;Have values we need (AX, BX, CL)
  MOV  [USBHostMask],AX         ;Store our individual Bit Mask
  MOV  [USBHostIndex],CL        ;Store our individual Host Index
  OR   AX,BX                    ;Mask our Index into the Total Bit Mask
  MOV  GS:[HostIndexes],AX      ;Store the Total Bit Mask in [FirstInstanceSeg]
I90:                            ;Done
  POP  GS,SI,CX,BX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A COMPATIBLE USB HOST DRIVER IS ALREADY INSTALLED
;Inputs:
;Outputs: CF = Set if error (No Driver Installed)
;            = Clear if OK
;Changes:
;------------------------------------------------------------------------------
TestUSBHost:
  PUSH AX,BX,CX ;Save used registers
  MOV  AX,5000h ;Function 5000h (Install Check)
  MOV  BX,'US'  ;Set
  MOV  CX,'B!'  ;  registers
  STC           ;Preset Error Flag
  INT  14h      ;Do it
  JC  >U70      ;If Error, USB Host can't be installed
  OR   AX,AX    ;Is AX Correct?
  JNZ >U70      ;If not, Error
  CMP  BX,'B!'  ;Is BX correct?
  JNE >U70      ;If not, Error
  CMP  CX,'US'  ;Is CX correct?
  JE  >U80      ;If so, it's installed
U70:            ;Not installed
  STC           ;Set Error Flag
  JMP >U90      ;Done
U80:            ;Installed
  CLC           ;Set OK flag
U90:            ;Done
  POP  CX,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SAVE THE COMPLETE CURRENT STATE OF THE USB HOST CONTROLLER
;Inputs:  DS = ES = TSR Data Area
;Outputs: [OldUSBCommand], [OldUSBIntEnable], [OldFrameNum], [OldFrameListAddr]
;         [OldSOFModify], [OldPortSC1], [OldPortSC2],
;         [OldPCICfgCmd], OldPCIResumeEnable
;Changes: Enables us to be able to write to USB I/O Ports
;NOTES:   Some statuses should already be saved by other subroutines
;           This routine only needs to save what is not saved already!
;         In addition to saving the current state, this STOPs the Host
;           Controller and enables it for Bus Mastering and I/O Access.
;           After this routine runs, the Host is STOPPED and does not work
;           any more!  (Should we change this??)
;------------------------------------------------------------------------------

;Change this to a REP INSB/INSW?

SetUSBStatus:
  PUSH EAX,BX                 ;Save used registers
S10:                          ;Work with USB Command Register
  CALL DbgStopHost            ;Write Debug String, if appropriate
  CALL ReadUSBCommandWord     ;Store the original USB
  MOV  [OldUSBCommand],AX     ;  Command Register
  AND  AL,(NOT UCRunStop)     ;Stop the Host Controller
  CALL WriteUSBCommandWord    ;Tell the Host Controller about it
  CALL Delay10MS              ;Wait a few milliseconds for it to take effect
S15:                          ;Work with Configuration Command Register
  CALL DbgEnBusMaster         ;Write Debug String, if appropriate
  MOV  BL,PCICfgCmd           ;Store the
  CALL ReadPCIWord            ;  original PCI
  MOV  [OldPCICfgCmd],AX      ;  Configuration Command Register
  MOV  AX,PCICfgIOAccess+PCICfgBusMaster ;Enable Access
  CALL WritePCIWord           ;Tell the PCI Bus about it
S20:                          ;Work with Legacy Support Register
  CALL DbgDisSMIFlags         ;Write Debug String, if appropriate
  MOV  BL,PCILegacySupp       ;Store the
  CALL ReadPCIWord            ;  original PCI
  MOV  [OldLegacySupp],AX     ;  Legacy Register
  OR   AX,LSUSBPIRQEn         ;Enable IRQ
  AND  AX,(NOT(LSSMIEndPassThruEn+LSA20PassThruEn+LSSMI64WEn+LSSMI64REn+LSSMI60WEn+LSSMI60REn))
                              ;Disable SMI#
  CALL WritePCIWord           ;Tell the PCI Bus about it
S25:                          ;Work with Resume Enable Register (not all Hosts??)
  CALL DbgEnResumeDet         ;Write Debug String, if appropriate
  MOV  BL,PCIResumeEnable     ;Store the
  CALL ReadPCIByte            ;  original PCI
  MOV  [OldResumeEnable],AL   ;  Resume Enable Register
  OR   AL,PCIResPort0Enable+PCIResPort1Enable ;Enable Resume/Connect Detection
  CALL WritePCIByte           ;Tell the PCI Bus about it
S30:                          ;Work with USB Command Register
  CALL ReadUSBCommandWord     ;Store the original USB
  MOV  [OldUSBCommand],AX     ;  Command Register
S35:                          ;Work with USB Interrupt Enable Register
  MOV  BL,USBIntEnable        ;Store the
  CALL ReadHostWord           ;  Original USB
  MOV  [OldUSBIntEnable],AX   ;  Interrupt Enable Register
S40:                          ;Work with Frame Number Register
  MOV  BL,FrameNum            ;Store the
  CALL ReadHostWord           ;  Original USB
  MOV  [OldFrameNum],AX       ;  Frame Number
S45:                          ;Work with Frame List Address Register
  MOV  BL,FrameListAddr       ;Store the
  CALL ReadHostDWord          ;  Original USB
  MOV  [OldFrameListAddr],EAX ;  Frame List Address
S50:                          ;Work with SOF Modify Register
  MOV  BL,SOFModify           ;Store the
  CALL ReadHostByte           ;  Original USB
  MOV  [OldSOFModify],AL      ;  Start-Of-Frame Modify Register
S60:                          ;Work with Port 1 Status & Control Register
  MOV  BL,PortSC1             ;Store the
  CALL ReadHostWord           ;  Original USB
  MOV  [OldPortSC1],AX        ;  Port 1 Status & Control Register
S65:                          ;Work with Port 2 Status & Control Register
  MOV  BL,PortSC2             ;Store the
  CALL ReadHostWord           ;  Original USB
  MOV  [OldPortSC2],AX        ;  Port 2 Status & Control Register
  POP  BX,EAX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FILL THE QUEUE HEAD TABLE WITH EMPTY ENTRIES
;Inputs:  DS = ES = TSR Data Area
;Outputs: Fills Queue Head Tables with empty (do-nothing) entries
;Changes:
;------------------------------------------------------------------------------
FillQueueHeadTbl:
  PUSH EAX,EBX,CX,DI              ;Save used registers
  MOV  CX,BulkQHEntries           ;Number of Entries to process
  MOV  DI,DS:[QHTable]            ;[DI] =
  ADD  DI,QHSize                  ;  Second QH
  CALL SegOff2PhysAddrESDI        ;Convert it to a Physical Address (EAX)
  OR   AL,QHQHSelect              ;Mark as a Valid, Horizontal QH
  MOV  EBX,QHTerminate            ;EDX = Empty Entry
  MOV  DI,DS:[QHTable]            ;Point at first QH
Q10:                              ;Loop to here for each QH
  MOV  [DI].QHLinkPointer,EAX     ;Store it
  MOV  [DI].QHElementPointer,EBX  ;Mark Vertical as invalid
  MOV  [DI].QHBulkTimeoutIndex,-1 ;Mark Timeout Index as Invalid
  ADD  DI,QHSize                  ;Point at
  ADD  EAX,QHSize                 ;  next QH
  LOOP Q10                        ;Keep going until we're done
Q20:                              ;Last Bulk QH
  MOV  [DI].QHLinkPointer,EBX     ;Mark Horizontal as Invalid
  MOV  [DI].QHElementPointer,EBX  ;Mark Vertical as Invalid
  MOV  [DI].QHBulkTimeoutIndex,-1 ;Mark Timeout Index as Invalid
Q40:                              ;Now handle Interrupt QH's
  MOV  CX,IntQHEntries            ;Number of entries to process
Q50:                              ;Loop to here for each Int QH
  ADD  DI,QHSize                  ;Point at next QH
  MOV  [DI].QHLinkPointer,EBX     ;Mark Horizontal as Invalid
  MOV  [DI].QHElementPointer,EBX  ;Mark Vertical as Invalid
  MOV  [DI].QHBulkTimeoutIndex,-1 ;Mark Timeout Index as Invalid
                                  ;  Need this in Int QH's?
  LOOP Q50                        ;Keep going until we're done
  POP  DI,CX,EBX,EAX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FILL THE TRANSFER DESCRIPTOR TABLE WITH EMPTY ENTRIES
;Inputs:  DS = ES = TSR Data Area
;Outputs: Fills Transfer Descriptor Table with empty (do-nothing) entries
;Changes:
;------------------------------------------------------------------------------
FillTransferDescTbl:
  PUSH CX,DI        ;Save used registers
  MOV  DI,TDOffset  ;Point at the beginning of the Table
  MOV  CX,TDEntries ;Number of Table Entries to fill
T20:                ;Loop to here for each TD Entry
  CALL ReleaseTD    ;Reset the Transfer Descriptor to a NUL
  ADD  DI,TDSize    ;Point at the next Transfer Descriptor
  LOOP T20          ;Keep going until the table is filled
  POP  DI,CX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FILL THE FRAME LIST TABLE WITH EMPTY ENTRIES
;Inputs:  DS = ES = TSR Data Area
;Outputs: Fills Frame List Table with empty (do-nothing) entries
;Changes:
;------------------------------------------------------------------------------
FillFrameListTbl:
  PUSH EAX,CX,DI           ;Save used registers
  MOV  DI,DS:[QHTable]     ;Get the physical address
  CALL SegOff2PhysAddrESDI ;  of the first QH
  OR   AL,FLQHSelect       ;Mark it as a Valid Queue Head
  MOV  DI,[FLOffsetW]      ;Point at the beginning of the Frame List Table
  MOV  CX,FLEntries        ;Number of Table Entries to fill
  REP  STOSD               ;Do it
  POP  DI,CX,EAX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE OUR INTERNAL (TSR) INT 14 REQUEST STRUCTURES
;Inputs:  DS = ES = TSR Data Area
;         [FirstInstanceSeg]
;Outputs:
;Changes: Int14Request, Int14Request2, Int14Request3, Int14Request4
;------------------------------------------------------------------------------
InitInt14Reqs:
  PUSH AX,SI                        ;Save used registers
  MOV  SI,Int14Request              ;Point at Request Structure
  MOV  AL,[USBHostIndex]            ;Store
  MOV  [SI].I14RHostIndex,AL        ;  Host Index
  MOV  W [SI].I14RDataAddress[2],ES ;Store the Data Segment in the Address
  MOV  [SI].I14RUserPktID,ES        ;Store the Data Segment in the User Pkt ID
  PUSH [FirstInstanceSeg]           ;Store the
  POP  W [SI].I14RCallBackAddr[2]   ;  Code Segment
  MOV  SI,Int14Request2             ;Copy to
  CALL CopyInt14ReqStruc            ;  Request #2
  MOV  SI,Int14Request3             ;Copy to
  CALL CopyInt14ReqStruc            ;  Request #3
  MOV  SI,Int14Request4             ;Copy to
  CALL CopyInt14ReqStruc            ;  Request #4
  MOV  SI,Int14Request5             ;Copy to
  CALL CopyInt14ReqStruc            ;  Request #5
  POP  SI,AX                        ;Restore used registers
  RET

CopyInt14ReqStruc:
  PUSH CX,DI,SI                ;Save used registers
  MOV  CX,(Int14RequestSize/2) ;Number of words to copy
  MOV  DI,SI                   ;Where to copy from
  MOV  SI,Int14Request         ;Where to copy from
  REP  MOVSW                   ;Copy the structure
  POP  SI,DI,CX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE ROOT HUB SO THAT IT BEGINS WORKING
;Inputs:  ES = TSR Data Area
;Outputs:
;Changes: Address Table
;         Sets Periodic Interrupt for Root Hub
;NOTES: This sets up two different Interrupts.
;       The first will peridically scan for Devices that need to be
;          Reset and enumerated.  This will include all newly connected
;          devices, as well as any Devices that are being Reset for any
;          other reason.
;       When a Hub detects a new Device, it informs the Host,
;         and the Hub & Port information is temporarily stored in a Table.
;         Whenever this periodic interrupt occurs, we scan through the list
;         and enumerate any devices we have been informed about.
;         This interrupt will also force us to periodically scan the Bus
;         for anything else we might need to do, which should help us keep
;         on top of things like Isochronous Transfers which don't generate
;          Interrupts by themselves.
;       The second one is to periodically poll the Root Hub to see if
;         any Devices have been attached/removed since the last time we looked.
;       While the StartFakePeriodicInt calls could theoretically fail (return
;         with the Carry Flag set), in actual practice there's not way that it
;         can.  The only reason it could possibly fail is because of a lack of
;         resources (unavailable Transfer Descriptors).  Because we are
;         still initializing the Root Hub, we have not used any Transfer
;         Descriptors yet for "real" transactions, so there's no way
;         to not have some available TD's.  Therefore, we don't need to
;         worry about or even check for errors.
;------------------------------------------------------------------------------
InitRootHub:
  PUSH AX,BX,SI,DS          ;Save used registers
  MOV  DS,ES                ;Point DS at TSR Data Area
  CALL InitRootAddress      ;Initialize the Address Table (Address 1)
  MOV  AX,5                 ;5 ms between Interrupts
  MOV  SI,EnumerateNewDvc   ;Code to Call when Interrupt happens
  CALL StartFakePeriodicInt ;Do it
  MOV  AX,100               ;100 ms between Interrupts
  MOV  SI,TestRootHubConns  ;Code to call when interrupt happens (DS:SI)
  CALL StartFakePeriodicInt ;Do it
  POP  DS,SI,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE ADDRESS TABLE WITH ADDRESS FOR THE ROOT HUB (ADDRESS 1)
;Inputs:  DS = ES = TSR Data Area
;Outputs: Address Entry #1 in the Address Table
;Chnages:
;------------------------------------------------------------------------------
InitRootAddress:
  PUSH AX,DI                                     ;Save used registers
 #IF !LITE
  MOV  DI,ADOffset+ADSize                        ;[DI] = Address 1
 #ELSE
  MOV  DI,DS:[ADTable]                           ;[DI] =
  ADD  DI,ADSize                                 ;  Address 1
 #ENDIF
  MOV  [DI].ADFlags,(ADFlagInUse+ADFlagSelfPwr)  ;In use & Self-Powered
  MOV  AL,[NumRootHubPorts]                      ;Store number of
  MOV  [DI].ADNumPorts,AL                        ;  Root Hub Ports
  MOV  [DI].ADDvcClass,DvcClassHub               ;Set Device
  MOV  [DI].ADConfigValue,1                      ;Configured, BusPower = 0
  MOV  W [DI].ADDvcSubClass,0                    ;  Class, SubClass, & Protocol
  MOV  W [DI].ADHubAddress,-1                    ;Set Hub & Port to -1 (invalid)
  MOV  AX,[HostVendorID]                         ;Store the Host
  MOV  [DI].ADVendorID,AX                        ;  Vendor ID
  MOV  AX,[HostProductID]                        ;Store the Host
  MOV  [DI].ADProductID,AX                       ;  Product ID
  MOV  AL,[USBVersion]                           ;Store the USB
  MOV  [DI].ADUSBVersion,AL                      ;  Version
  MOV  [DI].ADMaxPktSizeEP0,64                   ;Set Max Packet Size
R10:                                             ;Set up Interface Table
  XOR  AX,AX                                     ;Set some things to 0!
 #IF !LITE
  MOV  DI,InOffset                               ;[DI] = Interface Table
 #ELSE
  MOV  DI,DS:[InTable]                           ;[DI] = Interface Table
 #ENDIF
  MOV  [DI].InFlags,InFlagInUse                  ;Mark as in use
  MOV  [DI].InDeviceAddress,1                    ;Address 1 (Interface 0)
  MOV  [DI].InInterfaceNum,AL                    ;Interface Number 0
  MOV  AX,[FirstInstanceSeg]                     ;Get Code Segment to Use
  MOV  W [DI].InCallBackAddr[0],RootHubOwnerCall ;Set Far Call
  MOV  W [DI].InCallBackAddr[2],AX               ;  Address
  MOV  [DI].InUserPktID,ES                       ;Set User Packet ID (Data Seg)
R20:                                             ;Set up Alternate Interface Tbl
  XOR  AX,AX                                     ;Set some things to 0!
 #IF !LITE
  MOV  DI,AIOffset                               ;[DI] = Alt Interface Table
 #ELSE
  MOV  DI,DS:[AITable]                           ;[DI] = Alt Interface Table
 #ENDIF
  MOV  [DI].AIFlags,(AIFlagInUse+AIFlagSelected) ;In Use & Selected
  MOV  [DI].AIIntfClass,IntfClassHub             ;Set Interface
  MOV  W [DI].AIIntfSubClass,AX                  ;  Class, SubClass, & Protocol
 #IF !LITE
  MOV  [DI].AIInterfaceOffset,InOffset           ;Set Interface Number
 #ELSE
  MOV  AX,DS:[InTable]                           ;Set
  MOV  [DI].AIInterfaceOffset,AX                 ;  Interface Number
 #ENDIF
  POP  DI,AX                                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE SETUP REQUEST TABLE, MARKING ENTRIES AS AVAILABLE
;Inputs:  DS = ES = TSR Data Area
;Outputs:
;Chnages: SetupRequest Table
;------------------------------------------------------------------------------
InitSetupRequestTbl:
  PUSH CX,DI           ;Save used registers
  MOV  DI,DS:[SRTable] ;Table to change
  MOV  CX,SREntries    ;Number of entries in table
I10:                   ;Loop to here for each table entry
  MOV  W [DI].SRRequestType,-1 ;Mark it as available
  ADD  DI,SRSize       ;Point at the next one
  LOOP I10             ;Keep going untilwe're done
  POP  DI,CX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;START THE USB HOST RUNNING FOR THE FIRST TIME
;Inputs:  DS = ES = TSR Data Area
;Outputs: Attempts to Start Host Running
;         If Unable, prints Error Message and Quits
;Changes:
;NOTES: This is called after we have already changed the Interrupts to
;         point at us.  So, if the Host fails to start properly, we
;         actually need to do a partial Uninstall!
;------------------------------------------------------------------------------
StartUSB:
  PUSH EAX,BX,DI,SI,DS        ;Save used registers
  MOV  DS,CS                  ;Point DS at Local Data Area
S10:                          ;Reset the Host Controller
  CALL DbgResetHost           ;Write Debug String, if appropriate
  CALL ResetHostCtrl          ;Reset the Host Controller
  JC  >S701                   ;If error, quit
S15:                          ;Set Frame List Address
  CALL DbgSetFLAddress        ;Write Debug String, if appropriate
  MOV  BL,FrameListAddr       ;Store our
  MOV  EAX,[FLOffsetDW]       ;  Frame List
  CALL WriteHostDWord         ;  Address
S20:                          ;Set Start-of-Frame Address
  CALL DbgFrameTiming         ;Write Debug String, if appropriate
  MOV  BL,SOFModify           ;Set the
  MOV  AX,[SOFModifyStart]    ;  starting
  SUB  AX,SOFModifyBase       ;  Timing
  CALL WriteHostByte          ;  value
S25:                          ;Set Starting Frame Number
  CALL DbgStartFrame          ;Write Debug String, if appropriate
  MOV  BL,FrameNum            ;Set the
  XOR  AX,AX                  ;  starting
  CALL WriteHostWord          ;  Frame Index
S30:                          ;Set Interrupt Enable Types
  CALL DbgEnIRQFlags          ;Write Debug String, if appropriate
  MOV  BL,USBIntEnable        ;Enable
  MOV  AX,-1                  ;  all
  CALL WriteHostWord          ;  interrupt types
  JMP >S35                    ;Continue
S701:                         ;To avoid JMP > 128
  JMP >S70                    ;Error
S35:                          ;Acknowledge any leftover Legacy Statuses
  CALL DbgDisSMIFlags         ;Write Debug String, if appropriate
  MOV  BL,PCILegacySupp       ;Reset Legacy Support Register Status
  CALL ReadPCIWord            ;Get current Legacy Support REgister
  AND  AX,NOT (LSSMI60REn+LSSMI60WEn+LSSMI64REn+LSSMI64WEn+LSA20PassThruEn)
                              ;Disable SMI-related Interrupts &
                              ;  confirm SMI-related Interrupt Statuses
  CALL WritePCIWord           ;Send it
  CALL DbgDisSMIGen           ;Write Debug String, if appropriate
  AND  AX,(NOT LSSMIUSBIRQEn) ;Disable SMI Interrupt
  CALL WritePCIWord           ;Send it
  CALL Delay10MS              ;Wait a few milliseconds to take effect
  CALL DbgEnIRQGen            ;Write Debug String, if appropriate
  MOV  AX,LSUSBPIRQEn         ;Enable IRQ
  CALL WritePCIWord           ;Send it
S40:                          ;Start Host
  CALL DbgStartHost           ;Write Debug String, if appropriate
  MOV  AX,(UCRunStop+UCConfigured+UCMaxPkt64) ;Start the
  CALL WriteUSBCommandWord    ;  Host Running
S45:                          ;Wait for it to take effect
  MOV  AX,250                 ;Wait for 250 MS
  CALL DelayMSAX              ;  (some Intel Hosts take this long!)
  CALL DbgVerifyHost          ;Write Debug String, if appropriate
  CALL TestHostHalted         ;Is it running?
  JNZ >S70                    ;If not, error
  CALL DbgInitRootHub         ;Write Debug String, if appropriate
  CALL InitRootHub            ;Initialize Root Hub (sets up Periodic Ints)
  MOV  AX,50                  ;Wait a
  CALL DelayMSAX              ;Wait a little while
  CALL DbgVerifyIRQ           ;Write Debug String, if appropriate
  CMP  ES:[USBIntCount],0     ;Have any Interrupts Occurred?
  JNE >S90                    ;If so, we're done
S70:                          ;Error

;DbgError Here!

  MOV  AL,ES:[USBHostIndex]   ;Stop
  CALL DoHostStop             ;  the Host
  CALL DecNumInstances        ;Inform First Instance that we're gone
  CALL StopUSBInt             ;Restore the USB Interrupt (also resets PIC)
  CALL DoHostDelete           ;Inform other Hosts that we're gone
                              ;This will also inform us, and consequently
                              ;  all Devices/Interfaces attached to us
  CALL RestoreUHCI            ;Restore the Host Controller to original state
  MOV  SI,(IntNumTable+3)     ;Restore Interrupts
  CALL RestoreInts            ;  back to normal
  MOV  AH,49h                 ;If so, service 49h (return memory to system)
  INT  21h                    ;Do it (uses ES)
S75:                          ;UMB removed from memory
  MOV  DX,SIDNoStart          ;Point at Error Message
  MOV  AL,ErLvlNoStart        ;ErrorLevel = Couldn't Start
  JMP  Exit                   ;Quit
S90:                          ;Done
  POP  DS,SI,DI,BX,EAX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;STOP AND RESET THE HOST CONTROLLER
;Inputs:  ES = TSR Data Area
;Outputs: CF = Clear if OK (Host has been Stopped and Reset)
;            = Set if Error
;Changes:
;NOTES: This is only called during startup and shutdown
;------------------------------------------------------------------------------
ResetHostCtrl:
  PUSH AX,CX               ;Save used registers
  MOV  CX,200              ;Wait a maximum of 200 milliseconds
  XOR  AX,AX               ;Set Command register to all zeroes
  CALL WriteUSBCommandWord ;Do it
R10:                       ;Loop to here to wait for it to stop
  CALL Delay1MS            ;Wait 1 millisecond
  CALL TestHostHalted      ;Is the Host Halted?
  LOOPZ R10                ;If not, keep waiting
  JCXZ >R70                ;If timed out, Error
  OR   AL,UCHostReset      ;Reset Host Controller
  CALL WriteUSBCommandWord ;Do it
R30:                       ;Loop to here to wait for the Reset
  CALL Delay1MS            ;Wait 1 millisecond
  CALL ReadUSBCommandWord  ;Read the USB Command Register
  TEST AL,UCHostReset      ;Is the Reset complete yet?
  LOOPNZ R30               ;If not, keep waiting
  JCXZ >R70                ;If timed out, error
  JMP >R80                 ;If no time out, we're good
R70:                       ;Error
  STC                      ;Set error flag
  JMP >R90                 ;Done
R80:                       ;It worked
  CLC                      ;Set OK flag
R90:                       ;Done
  POP  CX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INFORM OTHER HOSTS AND NEW DEVICE OWNERS OF A NEW HOST OR A HOST DELETION
;Inputs:  ES = TSR Data Area
;         ES:[FirstInstanceSeg]
;Outputs:
;Changes:
;------------------------------------------------------------------------------
DoHostAdd:
  PUSH AX                      ;Save used registers
  MOV  AL,I14RRTHostAdded      ;Request Type = Host Added
  JMP >H00                     ;Do it
DoHostDelete:
  PUSH AX                      ;Save used registers
  MOV  AL,I14RRTHostDeleted    ;Request Type = Host Deleted
;  JMP >H00                     ;Do it
H00:
  PUSH SI                      ;Save used registers
  MOV  SI,Int14Request4        ;Point at Int 14h Request Structure
  MOV  [SI].I14RRequestType,AL ;Store Request Type
  MOV  AL,ES:[USBHostIndex]    ;Store the
  MOV  [SI].I14RConfigValue,AL ;  Host Index
  MOV  [SI].I14RHostIndex,AllHostsIndex ;Do All Hosts
  CALL DoInt14CallSI           ;Do it
  MOV  [SI].I14RHostIndex,AL   ;Restore Our Host Index
  POP  SI                      ;Restore used registers
  POP  AX                      ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO UNINSTALL OUR DRIVER
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;UNINSTALL RESIDENT PROGRAM
;Inputs:  ES = TSR Data Area
;Outputs:
;Changes: Attempts to Uninstall Program from memory
;         If it can't be Uninstalled, it is Disabled
;------------------------------------------------------------------------------
DoUninstall:
  TEST [ProgFlags],Uninstall ;Are we supposed to Uninstall?
  JNZ >U00                   ;If so, continue
  RET

U00:                        ;User wants to Uninstall
  TEST [ProgFlags],InMemory ;Are we even installed yet?
  JZ  >U40                  ;If not, there's an error
  CALL DbgStopHost          ;Write Debug String, if appropriate
  MOV  AL,ES:[USBHostIndex] ;Stop
  CALL DoHostStop           ;  the Host
  JC  >U45                  ;If it didn't work, quit
U05:                        ;Host is Stopped
  CALL TestSharedIRQ        ;Is there a Shared IRQ Problem?
  JC  >U50                  ;If so, Error
  TEST ES:[TSRFlags],FirstInstance ;First Instance?
  JZ  >U10                  ;If not, it's OK to Uninstall
  CALL GetNumInstances      ;Get the Number of Instances
  CMP  AL,1                 ;If First Instance, are we the only Instance?
  JA  >U55                  ;If not, Error
U10:                        ;OK to Uninstall based on Instances
  CALL GetNumHosts          ;Get # of Hosts (Rtns AL, ZF set if AL = 1)
  JNZ >U20                  ;If we're not the only Host, continue
  CALL GetNumDvc0Owners     ;If so, are there any Dvc 0 Owners?
  JNZ >U60                  ;If so, Error
U20:                        ;No other Programs depending on us
  MOV  SI,IntNumTable       ;Point at the Interrupt Address Table
  CALL CompareInts          ;Can we Uninstall the Interrupt Vectors?
  JC  >U70                  ;If not, we can't Uninstall
  MOV  AL,ES:[USBIntNum]    ;Work with the IRQ Interrupt
  MOV  DX,[USBIntHdr].CodeJmp ;ES:[DX] at our code address
  CALL CompareInt           ;See if it's changed
  JC  >U70                  ;If so, we can't uninstall
  MOV  AH,49h               ;If not, service 49h (return memory to system)
  INT  21h                  ;Do it
  JC  >U70                  ;If unable to do it, quit with error
U30:                        ;Restore Interrupts & Controller to Original
  CALL DecNumInstances      ;Inform First Instance that we're gone
  CALL DbgRestoreUSBInt     ;Write Debug String, if appropriate
  CALL StopUSBInt           ;Restore the USB Interrupt (also resets PIC)
  CALL DoHostDelete         ;Inform other Hosts that we're gone
                            ;This will also inform us, and consequently
                            ;  all Devices/Interfaces attached to us
  CALL RestoreUHCI          ;Restore the Host Controller to original state
  CALL DbgRestoreGenInts    ;Write Debug String, if appropriate
  MOV  SI,(IntNumTable+3)   ;Restore Interrupts
  CALL RestoreInts          ;  back to normal
  MOV  DX,SIDUninstall      ;Point at successful Uninstall message
  XOR  AL,AL                ;Errorlevel = 0
  JMP  Exit                 ;QUIT
U40:                        ;Not in memory yet
  MOV  DX,SIDNotInMem       ;Point at error message
  MOV  AL,ErLvlNotInMem     ;Errorlevel = Not Installed Yet
  JMP  Exit                 ;QUIT
U45:                        ;First Instance with others installed
  MOV  DX,SIDCantStopHost   ;Point at error message
  MOV  AL,ErLvlCantStopHost ;Errorlevel = First Instance Problem
  JMP  Exit                 ;QUIT
U50:                        ;Shared IRQ
  MOV  DX,SIDSharedIRQ      ;Point at error message
  MOV  AL,ErLvlSharedIRQ    ;Errorlevel = Shared IRQ Problem
  JMP  Exit                 ;QUIT
U55:                        ;First Instance with others installed
  MOV  DX,SIDNotFirstInst   ;Point at error message
  MOV  AL,ErLvlNotFirstInst ;Errorlevel = First Instance Problem
  JMP  Exit                 ;QUIT
U60:                        ;Last Host with Registered Device 0 Owners
  MOV  DX,SIDDvc0Owner      ;Point at error message
  MOV  AL,ErLvlDvc0Owner    ;Errorlevel = Device 0 Owners
  JMP  Exit                 ;QUIT
U70:                        ;Another TSR is in the way - can't Uninstall
  MOV  DX,SIDNoUninstall    ;Point at error message
  MOV  AL,ErLvlMemory       ;Errorlevel = Memory Problem
  JMP  Exit                 ;QUIT

;------------------------------------------------------------------------------
;RESTORE THE USB HOST CONTROLLER TO THE WAY IT WAS BEFORE WE STARTED
;Inputs:  Host Controller already stopped!!
;Outputs:
;Changes:
;NOTES:   Needs to restore Legacy Support properly if it was
;           turned on before we took over the Controller
;------------------------------------------------------------------------------
RestoreUHCI:
  PUSH EAX,BX,CX,DX              ;Save used registers
  CALL DbgEnIRQGen               ;Write Debug String, if appropriate
  MOV  BL,USBIntEnable           ;Enable all interrupt types
  MOV  AX,-1                     ;  to make sure
  CALL WriteHostWord             ;  all pending interrupts are cleared
  CALL DbgResetHost              ;Write Debug String, if appropriate
  CALL ResetHostCtrl             ;Stop and Reset the Host Controller
  CALL DbgEnIRQGen               ;Write Debug String, if appropriate
  MOV  BL,USBIntEnable           ;Restore the
  MOV  AX,ES:[OldUSBIntEnable]   ;  original
  CALL WriteHostWord             ;  Interrupt Enable Register
  CALL DbgSetFLAddress           ;Write Debug String, if appropriate
  MOV  BL,FrameListAddr          ;Restore the
  MOV  EAX,ES:[OldFrameListAddr] ;  original
  AND  EAX,0FFFF_F000h           ;  upper 20 bits of the
  CALL WriteHostDWord            ;  Frame List Base Address
  CALL DbgFrameTIming            ;Write Debug String, if appropriate
  MOV  BL,SOFModify              ;Restore the
  MOV  AL,ES:[OldSOFModify]      ;  original
  CALL WriteHostByte             ;  Start-of-Frame Modify Register
  CALL DbgRestorePort1           ;Write Debug String, if appropriate
  MOV  BL,PortSC1                ;Restore the
  MOV  AX,ES:[OldPortSC1]        ;  original
  AND  AX,(NOT (PtLowSpeed+PtLineStatM+PtLineStatP+PtPortEnChg+PtConnStatChg))
  CALL WriteHostWord             ;  Port 1 Status & Control Register
  CALL DbgRestorePort2           ;Write Debug String, if appropriate
  MOV  BL,PortSC2                ;Restore the
  MOV  AX,ES:[OldPortSC2]        ;  original
  AND  AX,(NOT (PtLowSpeed+PtLineStatM+PtLineStatP+PtPortEnChg+PtConnStatChg))
  CALL WriteHostWord             ;  Port 2 Status & Control Register
  CALL DbgStartFrame             ;Write Debug String, if appropriate
  MOV  BL,FrameNum               ;Restore the
  MOV  AX,ES:[OldFrameNum]       ;  original
  CALL WriteHostWord             ;  Frame Number Register

  ;Windows doesn't restore PortSCx, SFMod, or FrameNum

  CALL DbgEnSMIFlags             ;Write Debug String, if appropriate
  MOV  BL,PCILegacySupp          ;Restore the
  MOV  AX,ES:[OldLegacySupp]     ;  Original
  AND  AX,(NOT (LSA20EndPassThruSts+LSUSBIRQSts+LSTrap64W+LSTrap64R+LSTrap60W+LSTrap60R+LSA20PassThruSts))
  CALL WritePCIWord              ;  Legacy Support Register
  CALL DbgRestoreIRQ             ;Write Debug String, if appropriate
  MOV  BL,PCIIRQNum              ;Restore the
  MOV  AL,ES:[OldIRQNum]         ;  original
  CALL WritePCIByte              ;  IRQ Number

  ;Windows reads LegacySupp, Enables SMI, and writes back again here

  CALL DbgEnIRQFlags             ;Write Debug String, if appropriate
  MOV  BL,USBCommand             ;Restore the
  MOV  AX,ES:[OldUSBCommand]     ;  Original
  CALL WriteHostWord             ;  USB Command Register

  ;Windows sets UCRunStop bit here
  ;Do a Global Reset?

  CALL DbgRestorePCI             ;Write Debug String, if appropriate
  MOV  BL,PCICfgCmd              ;Restore the
  MOV  AX,ES:[OldPCICfgCmd]      ;  Original
  CALL WritePCIWord              ;  PCI Configuration Command Register
S70:                             ;Couldn't stop it!!
  STC                            ;Set the error flag
  JMP >S90                       ;We're done
S80:                             ;It's stopped!
  CLC                            ;Set the OK flag
S90:                             ;We're done
  POP  DX,CX,BX,EAX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THERE'S ANOTHER PROGRAM SHARING OUR IRQ, PREVENTING UNINSTALL
;Inputs:  ES = TSR Data Area
;         ES:[USBIntHdr].EOIFlag
;         ES:[USBIntNum]
;Outputs: CF = Clear if IRQ does NOT have a sharing problem
;            = Set another program is sharing the IRQ that we Enabled in the PIC
;Changes:
;------------------------------------------------------------------------------
TestSharedIRQ:
  PUSH AX,BX,ECX,ES      ;Save used registers
  TEST ES:[USBIntHdr].EOIFlag,80h ;Did we Enable the IRQ?
  JZ  >Q80               ;If not, we're done
  MOV  CX,ES             ;Save our Segment
  MOV  AL,ES:[USBIntNum] ;Get the Interrupt Number
  MOV  AH,35h            ;Function 35h (Get Int Vector)
  INT  21h               ;Do it (returns ES:[BX])
  MOV  AX,ES             ;Is it still
  CMP  AX,CX             ;  our Segment?
  JE  >Q80               ;If so, it's OK to Uninstall
Q70:                     ;Sharing Problem
  STC                    ;Set Return Flag
  JMP >Q90               ;Done
Q80:                     ;No problem
  CLC                    ;Set Return Flag
Q90:                     ;Done
  POP  ES,ECX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INCREMENT OR DECREMENT THE NUMBER OF INSTANCES COUNTER
;Inputs:  ES = TSR Data Area
;         [FirstInstanceSeg] (Segment of Original Instance of Program)
;Outputs: Modifies NumInstances in First TSR
;         ZF = Set if Decrementing and this is Last Instance
;Changes:
;------------------------------------------------------------------------------
IncNumInstances:
  PUSH AX                ;Save used registers
  MOV  AL,1              ;Add 1
  JMP >I00               ;Do it
DecNumInstances:
  PUSH AX                ;Save used registers
  MOV  AL,-1             ;Subtract 1
;  JMP >I00               ;Do it
I00:
  PUSH DS                ;Save used registers
  MOV  DS,ES:[FirstInstanceSeg] ;Adjust the
  ADD  [NumInstances],AL        ;  number of Instances
  POP  DS                ;Restore used registers
  POP  AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NUMBER OF INSTANCES OF THIS PROGRAM IN MEMORY
;Inputs:  ES = TSR Data Area
;         [FirstInstanceSeg] (Segment of Original Instance of Program)
;Outputs: AL = Number of Instances
;Changes:
;------------------------------------------------------------------------------
GetNumInstances:
  PUSH DS                       ;Save used registers
  MOV  DS,ES:[FirstInstanceSeg] ;Get the
  MOV  AL,[NumInstances]        ;  Number of Instances
  POP  DS                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NUMBER OF HOST DRIVERS INSTALLED IN MEMORY
;Inputs:  ES = TSR Data Area
;         [HostIndexes]
;         [FirstInstanceSeg]
;Outputs: AL = Number of Host Drivers in Memory
;         ZF = Set if We are the Only Host (Num Hosts = 1)
;            = Clear if We are NOT the Only Host (Num Hosts > 1)
;Changes:
;------------------------------------------------------------------------------
GetNumHosts:
  PUSH BX,CX,DS         ;Save used registers
  MOV  DS,ES:[FirstInstanceSeg] ;Get the Host Indexes
  MOV  BX,[HostIndexes] ;  Bit Mask
  XOR  AL,AL            ;Start Host Counter at 0
  MOV  CX,MaxHosts      ;Number of possible Hosts
H10:                    ;Loop to here for each Host
  ROR  BX,1             ;Is this Host Installed?
  JNC >H30              ;If not, skip it
  INC  AL               ;If so, increment the Host Counter
H30:                    ;Done testing this Host
  LOOP H10              ;Keep Going until we're done
H90:                    ;Done
  CMP  AL,1             ;Set Return Flag
  POP  DS,CX,BX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NUMBER OF REGISTERED DEVICE 0 OWNERS
;Inputs:  ES = TSR Data Area
;         ES:[FirstInstanceSeg]
;         NDTable
;Outputs: AL = Number of Registered Device 0 Owners
;         ZF = Set if No Owners
;            = Clear if Number of Owners >= 1
;Changes:
;------------------------------------------------------------------------------
GetNumDvc0Owners:
  PUSH BX,DS                      ;Save used registers
  MOV  DS,ES:[FirstInstanceSeg]   ;Point DS at Correct Data Area
  XOR  AL,AL                      ;Start Host Counter at 0
  MOV  BX,NDTable                 ;Point at Table
Z10:                              ;Loop to here for each Table Entry
  CMP  W [BX].NDCallBackAddr[2],0 ;Valid entry?
  JE  >Z30                        ;If not, skip it
  INC  AL                         ;If so, increment the Counter
Z30:                              ;Done testing this Host
  ADD  BX,NDSize                  ;Point at next Table Entry
  CMP  BX,(NDTable+(NDEntries*NDSize)) ;Done with the Table Yet?
  JB   Z10                        ;If not, keep looking
Z90:                              ;Done
  OR   AL,AL                      ;Set Return Flag
  POP  DS,BX                      ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO SAVE/INITIALIZE/RESTORE INTERRUPT VECTORS
;This code is needed in every program that intercepts Interrupt Vectors.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;INITIALIZE, COMPARE, OR RESTORE INTERRUPT VECTORS TO OUR TSR CODE
;Inputs:  ES = TSR Data Area
;         CS = Local Data Area
;         CLD Already Issued
;         ES:[SI] = Interrupt Table to Use
;Outputs: CF = Clear if OK (needed for CompareInts)
;            = Set if Error (CompareInts had at least one invalid INT)
;Changes: Various Int vectors
;------------------------------------------------------------------------------
ChangeInts:
  PUSH BP            ;Save used registers
  MOV  BP,ChangeInt  ;[BP] = Code to Call
  JMP >I00           ;Do it
CompareInts:
  PUSH BP            ;Save used registers
  MOV  BP,CompareInt ;[BP] = Code to Call
  JMP >I00           ;Do it
RestoreInts:
  PUSH BP            ;Save used registers
  MOV  BP,RestoreInt ;[BP] = Code to Call
;  JMP >I00           ;Do it
I00:
  PUSH AX,DI   ;Save used registers
  PUSH SI,DS   ;Save used registers
  MOV  DS,ES   ;DS = TSR Data Area
I10:           ;Loop to here for each table entry
  LODSB        ;Get the Interrupt Number
  MOV  DI,[SI] ;If valid, get our Code Header Offset
  CALL BP      ;Call the subroutine
  JC  >I70     ;If error, quit
  CMP  AL,2Dh  ;End of the Table?
  JE  >I80     ;If so, we're done
  INC  SI,2    ;Point at the next table entry
  JMP  I10     ;Keep going until we're done
I70:           ;Error
  STC          ;Set return flag
  JMP >I90     ;Done
I80:           ;OK
  CLC          ;Set return flag
I90:           ;Done with the Interrupt Table
  POP  DS,SI   ;Restore used registers
  POP  DI,AX   ;Restore used registers
  POP  BP      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHANGE INTERRUPT VECTOR TO THIS PROGRAMS INTERRUPT ROUTINE, AND SAVE THE OLD
;Inputs:  DS:[DI] = Pointer to our new interrupt header (CodeJmp)
;         AL = Interrupt number to change
;Outputs: CF = Clear
;Changes: Interrupt vector
;NOTES: Except for INT 2D, we can't simply install ourselves "behind"
;         another AMIS-compatible interrupt, because not all Interrupt
;         Handlers chain to the previous handler.  INT 2Dh is different,
;         the only known use for INT 2Dh is AMIS, which will always chain.
;       For all other INTs, we just install at the beginning of the INT
;         chain (in the IVT).  There is no reason to go down the IISP chain
;         any lower.
;       An exception to this would be if we needed ourselves to be the LAST
;         vector in the chain (we need to issue EOI or not chain past
;         ourselves).  In that case, we would want to go down the IISP
;         chain as far as we could so that we "included" programs that were
;         installed before we were.  An example of this is RxANSI (from
;         Christian Masloch), which REPLACES INT 29h (DOS Fast Console Output),
;         rather than augmenting or monitoring it.  By installing down the IISP
;         chain as far as it can (for INT 29h), it can be installed after
;         programs like CLOCK and SERIAL and LOCKEYS (which use IISP but
;         simply monitor INT 29h) and still work properly.  However, if we
;         installed another non-IISP program that monitored INT 29h after
;         CLOCK etc., and then tried to install RxANSI after that, we would
;         be screwed.
;------------------------------------------------------------------------------
ChangeInt:
  PUSH AX,BX,DX,ES                       ;Save used registers
  CALL InitIntHdr                        ;Initialize our Interrupt Header
  CMP  AL,2Dh                            ;AMIS Interrupt Vector?
  JNE >C30                               ;If not, don't try to install w/ AMIS
  XOR  AH,AH                             ;Start with AMIS Index 0
C10:                                     ;Loop to here for each AMIS Index
  CALL FindAMISInt                       ;Look for an AMIS Interrupt (ES:[BX])
  JC  >C30                               ;If none, do a normal install
;  CMP  ES:[BX-IntOfst].EOIFlag,80h       ;Does the AMIS Int issue the EOI?
;  JE  >C15                               ;If so, skip it
;  CMP  ES:[BX-IntOfst].OldVector[2],0    ;Valid Old Vector?
;  JNE >C20                               ;If so, continue
;C15:                                     ;Not an AMIS Int we can use
;  INC  AH                                ;If so, increment the AMIS Index
;  JMP  C10                               ;Keep looking
C20:                                     ;ES:[BX] = AMIS, DS:[DI] = Us
  MOV  AX,W ES:[BX-IntOfst].OldVector[0] ;Copy the Code Pointer
  MOV  W [DI-IntOfst].OldVector[0],AX    ;  stored in the AMIS IISP Header
  MOV  AX,W ES:[BX-IntOfst].OldVector[2] ;  into our
  MOV  W [DI-IntOfst].OldVector[2],AX    ;  IISP Header
  CLI                                    ;Disable Interrupts
  MOV  W ES:[BX-IntOfst].OldVector[0],DI ;Store our Code Pointer
  MOV  W ES:[BX-IntOfst].OldVector[2],DS ;  in the AMIS IISP Header
  STI                                    ;Enable Interrupts
  JMP >C90                               ;Done
C30:                                     ;Install at beginning of Chain
  MOV  AH,35h                            ;Service 35h (Get interrupt vector)
  INT  21h                               ;Do it (returns ES:[BX])
  MOV  W [DI-IntOfst].OldVector,BX       ;Save it
  MOV  W [DI-IntOfst].OldVector[2],ES    ;  in [DI]
  MOV  DX,DI                             ;DS:[DX] = Our Code Address
  MOV  AH,25h                            ;Service 25h (Set interrupt vector)
  INT  21h                               ;Do it
C90:                                     ;Done
  CLC                                    ;Set return flag
  POP  ES,DX,BX,AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COMPARE OUR INTERRUPT ADDRESS TO MEMORY SEE IF IT'S BEEN REHOOKED
;Inputs:  ES:[DI] = Vector address to test (our TSR's address)
;         AL = Interrupt number to test
;Outputs: CF = Clear if OK to remove
;         CF = Set if rehooked and can't be removed
;Changes:
;------------------------------------------------------------------------------
CompareInt:
  PUSH AX,BX,CX,ES  ;Save used registers
  MOV  CX,ES        ;CX:[DX] =
  XOR  AH,AH        ;Start with AMIS Index 0
P10:                ;Loop to here for each AMIS Index
  CALL FindAMISInt  ;Look for AMIS Entry (rtns CF, ES:[BX])
  JC  >P50          ;If none, look for non-AMIS
  CALL ScanIISPHdrs ;If so, does it have what we need?
  JNC >P80          ;If so, we're done
P30:                ;Incorrect AMIS Entry
  INC  AH           ;Increment the Index
  JMP  P10          ;Keep looking
P50:                ;No AMIS entry found
  CALL FindInt      ;Look for it (returns CF, ES:BX)
  JNC >P80          ;If f
P70:                ;Error (can't be removed)
  STC               ;Set return flag
  JMP >P90          ;Done
P80:                ;OK (safe to remove)
  CLC               ;Set return flag
P90:                ;Done
  POP  ES,CX,BX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESTORE INTERRUPT VECTOR TO ITS ORIGINAL PLACE
;Inputs:  ES:[DI] = Pointer to our Interrupt Header CodeJmp
;         AL = Interrupt number to restore
;Outputs: CF = Clear
;Changes: Interrupt vector back to where it belongs
;Notes:   If we got to here, nothing should have intercepted
;           an interrupt that we haven't checked for.
;         We shouldn't have to worry about running into a road-block!
;------------------------------------------------------------------------------
RestoreInt:
  PUSH AX,BX,CX,SI,BP,ES                 ;Save used registers
  PUSHF                                  ;Save flags
  MOV  SI,W ES:[DI-IntOfst].OldVector    ;Put the address we'll need to store
  MOV  BP,W ES:[DI-IntOfst].OldVector[2] ;  in BP:SI
  MOV  CX,ES                             ;Point CX:DX
  XOR  AH,AH                             ;Start with AMIS Index 0
R10:                                     ;Loop to here for each AMIS Index
  CALL FindAMISInt                       ;Look for AMIS Entry (rtns CF, ES:[BX])
  JC  >R50                               ;If none, look for non-AMIS
  CALL ScanIISPHdrs                      ;If so, does it have what we need?
  JC  >R30                               ;If not, try the next AMIS Index
  ADD  BX,((OFFSET OldVector)-IntOfst)   ;If so, ES:[BX] = Vector pointer
  JMP >R80                               ;Jump to store it
R30:                                     ;Incorrect AMIS Entry
  INC  AH                                ;If not, increment the AMIS Index
  JMP  R10                               ;Keep looking
R50:                                     ;No AMIS entry found
  CALL FindInt                           ;Do normal/IISP Search (rtns ES:[BX])
                                         ;We already test this with CompareInt,
                                         ;  so we should never get an error
R80:                                     ;ES:[BX] = Where to Store the Vector
  CLI                                    ;Disable interrupts
  MOV  ES:[BX],SI                        ;Store the
  MOV  ES:[BX+2],BP                      ;  address
  POPF                                   ;Restore flags
  CLC                                    ;Set return flag
  POP  ES,BP,SI,CX,BX,AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEARCH FOR AN INTERRUPT VECTOR ADDRESS STORED IN AN AMIS-COMPATIBLE TSR
;Inputs:  AL = Interrupt number to find
;         AH = Index of AMIS INterrupt to Find (0 = first, etc.)
;Outputs: CF = Clear if AMIS-compatible TSR found storing INT Vector
;           ES:[BX] = AMIS/IISP-compatible Header Pointer
;         CF = Set if no AMIS-compatible TSR found with the Interrupt Number
;           ES:BX = Undefined
;Changes:
;NOTES: The index is necessary because there may be multiple, "unlinked"
;         instances of AMIS Interrupt handlers.  This is especially true
;         of IRQ handlers, where only one handler can be responsible for
;         issuing the EOI signal to the PIC (signified by the EOI flag
;         in the AMIS IISP header).
;       If the AMIS handler installed issues the EOI, another handler
;         must not install itself "before" the original handler (to be
;         processed after the EOI has been issued).
;       In theory, it should be possible to do though, by the new
;         interrupt turning the EOI flag off in the "first" handler,
;         turning its own EOI flag on, and assuming the EOI responsibilities
;         itself.
;       Unfortunately, this would mean that the EOI flag in the header MUST
;         be used by all IRQ handlers to determine if they should issue the
;         EOI or not, and the IISP spec does not explicitly say that it must
;         work that way.
;       I suspect many AMSI (and IISP) programs do, but because it is not
;         explicitly stated in the spec I would imagine many programs don't.
;       Therefore, when we are installing, we cannot install ourselves "before"
;         an AMIS (or IISP) interrupt that has the EOI flag set in its header,
;         nor can we uninstall if we issue the EOI and ANY other TSRs,
;         AMIS//IISP or not, are installed after us are using the IRQ.
;------------------------------------------------------------------------------
FindAMISInt:
  PUSH AX,CX,DX,SI       ;Save used registers
  MOV  CX,AX             ;Save Interrupt Number & Index in CX
  MOV  AX,AMISInstallChk ;AH = Handle = 0, AL = Function = Install Check
  MOV  SI,AX             ;Save it for later
A10:                     ;Loop to here for each Handle
  PUSH AX,CX,DX,DI       ;Save changed registers
  INT  2Dh               ;Do it (Rtns AL, CX, DX, DI)
  CMP  AL,-1             ;Function Installed?
  POP  DI,DX,CX,AX       ;Restore changed registers
  JNE >A60               ;If not, try the next possibility
  MOV  AL,AMISGetInts    ;If so, Function = Get Ints
  MOV  BL,CL             ;BL = Interrupt Number
  INT  2Dh               ;Do it (Rtns AL, BX, DX)
  CMP  AL,AMISIntAddress ;Did it return an Address we can use?
  JB  >A60               ;If not, quit
  CMP  AL,AMISIntList    ;Is it an Interrupt List?
  JA  >A70               ;If not, skip it
  JE  >A30               ;If so, handle it
A20:                     ;DX:[BX] = Interrupt Header
  MOV  ES,DX             ;ES:[BX] = Interrupt Header
  OR   CH,CH             ;Correct Index?
  JZ  >A80               ;If so, we've found it
  DEC  CH                ;If not, decrement the Index
  JMP >A60               ;Keep looking
A30:                     ;DX:[BX] = Interrupt List
  MOV  ES,DX             ;ES:[BX] = Interrupt List
A35:                     ;Loop to here for each Interrupt Table entry
  CMP  ES:[BX],CL        ;Correct Interrupt Number?
  JNE >A50               ;If not, skip it
  OR   CH,CH             ;Correct Index?
  JZ  >A40               ;If so, wer've found it
  DEC  CH                ;If not, decrement the Index
  JMP >A60               ;Keep looking
A40:                     ;We found it in the Interrupt Table
  MOV  BX,ES:[BX+1]      ;ES:[BX] = Interrupt Header
  JMP >A80               ;Done
A50:                     ;Not the correct Interrupt Number
  CMP  B ES:[BX],2Dh     ;Last Interrupt Table entry?
  JE  >A60               ;If so, done with this Handle
  ADD  BX,3              ;If not, point at the next Interrupt Table Entry
  JMP  A35               ;Keep looking
A60:                     ;Not an AMIS we can use
  MOV  AX,SI             ;Try the next
  ADD  AH,1              ;  handle number
  MOV  SI,AX             ;Save it for next time
  JNC  A10               ;If no overflow, keep looking
A70:                     ;Not found
  STC                    ;Set return flag
  JMP >A90               ;Done
A80:                     ;Found
  CLC                    ;Set return flag
A90:                     ;Done
  POP  SI,DX,CX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEARCH AN IISP INTERRUPT VECTOR FOR A SEGMENT MATCH, SPANNING IISP's
;Inputs:  ES:[BX] = Interrupt Vector to Start with
;             CX  = Sector number to look for in OldVector
;Outputs: CF = Clear if OK (CX found in IISP Chain)
;              ES:[BX] = Int Header where it is stored
;            = Set if Error (Int not IISP-compatible, or
;              ES:[BX] = Unchanged
;Changes:
;NOTES: The Input Vector is assumed to be IISP-compatible, and is not
;         verified.
;------------------------------------------------------------------------------
ScanIISPHdrs:
  PUSH SI,BP                             ;Save used registers
  MOV  BP,ES                             ;Save original ES:BX in
  MOV  SI,BX                             ;  BP:SI
I10:                                     ;Loop to here for each IISP INT
  CMP  W ES:[BX-IntOfst].OldVector[2],CX ;Is it the one we're looking for?
  JE  >I80                               ;If so, we're done
  LES  BX,ES:[BX-IntOfst].OldVector      ;If not, get next INT pointer
  CALL TestIntHdr                        ;Is it an IISP INT?
  JNC  I10                               ;If so, keep testing
I70:                                     ;Error (not found)
  MOV  ES,BP                             ;Restore original
  MOV  BX,SI                             ;  ES:BX
  STC                                    ;Set return flag
  JMP >I90                               ;Done
I80:                                     ;OK (ES:BX set)
  CLC                                    ;Set return flag
I90:                                     ;Done
  POP  BP,SI                             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEARCH FOR AN INTERRUPT VECTOR ADDRESS (TO SEE IF OUR CODE CAN BE REMOVED)
;Inputs:  CX:DX = Interrupt Vector address to find (address of our TSR code)
;         AL = Interrupt number to find
;Outputs: CF = Clear if OK to remove
;           ES:[BX] = address where it is stored
;         CF = Set if rehooked and can't be removed
;           ES:BX = undefined
;Changes:
;NOTES: This does NOT return the Address to an IISP Header.  It returns
;          the Address where we should store the Address stored in
;          our IISP Header to remove ourselves from the Interrupt Chain.
;       This could either be directly in the IVT, or in the IISP Header
;          of another TSR.
;------------------------------------------------------------------------------
FindInt:
  PUSH AX                                ;Save used registers
  XOR  AH,AH                             ;Point ES:BX
  ADD  AX,AX                             ;  at the
  ADD  AX,AX                             ;  main
  MOV  BX,AX                             ;  interupt
  XOR  AX,AX                             ;  vector
  MOV  ES,AX                             ;  table
  CMP  ES:[BX+2],CX                      ;Is the segment the same as ours?
  JE  >F80                               ;If so, it's ours - we're done
F20:                                     ;The main interrupt vector has changed
  LES  BX,ES:[BX]                        ;Get the current vector address
F30:                                     ;Loop for each removable interrupt
  CALL TestIntHdr                        ;Is this a removable interrupt?
  JC  >F70                               ;If not, we can't be removed
  CMP  W ES:[BX-IntOfst].OldVector[2],CX ;If so, is old segment ours?
  JNE >F50                               ;If not, keep looking
  ADD  BX,((OFFSET OldVector)-IntOfst)   ;If so, ES:BX = old vector pointer
  JMP >F80                               ;And we're done
F50:                                     ;Removable, but doesn't point at us
  LES  BX,ES:[BX-IntOfst].OldVector      ;Get its old vector address
  JMP  F30                               ;And keep looking for our vector
F70:                                     ;Been rehooked and can't be removed
  STC                                    ;Set the "rehooked" flag
  JMP >F90                               ;We're done
F80:                                     ;It's not rehooked, or it's removable
  CLC                                    ;Set the "OK to remove" flag
F90:                                     ;We're done
  POP  AX                                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE THE DATA IN A REMOVABLE INTERRUPT VECTOR HEADER
;Inputs:  DS:[DI] = Pointer to Our Interrupt Header Structure CodeJmp
;Outputs:
;Changes: The Interrupt Header Data
;------------------------------------------------------------------------------
InitIntHdr:
  MOV  [DI-IntOfst].HdwreRst,0CBh   ;Hardware Reset Code = CBh = RETF
  MOV  [DI-IntOfst].CodeJmp,10EBh   ;EBh 10h = JMP ENDS
  MOV  [DI-IntOfst].Signature,424Bh ;Heaer Signature = 424Bh
  MOV  [DI-IntOfst].EOIFlag,0       ;We will not be issuing EOI's
  MOV  [DI-IntOfst].HdwreJmp,0F4EBh ;EBh F4h = JMP HdwreRst
  RET

;------------------------------------------------------------------------------
;TEST AN INTERRUPT POINTER TO SEE IF IT'S REMOVABLE
;Inputs:  ES:[BX] = Interrupt Vector to test
;Outputs: CF = Set if it's not a removable vector
;            = Clear if it is removable
;Changes:
;Notes:   The references to [BX-IntOfst] instead of [BX] are because of
;           our "unusual" Interrupt Header Structure design.
;         We have included the (unneeded) Hardware Reset Routine code
;           (a simple RETF) in our Header Structure for efficiency.
;         Many programs that use the IISP test for 10EBh in the first two
;           bytes of the Header, but this is incorrect.  All that matters
;           is the EBh (a short Jump) -- it doesn't actually matter how
;           many bytes the JMP is.  However, it is such a common mistake
;           that it is even listed in the RBIL as being that way.  We still
;           follow the real specification, and only check for EBh.  However,
;           our actual code must comply the faulty 10EBh precedent, or it
;           won't work correctly with other (faulty) programs.
;------------------------------------------------------------------------------
TestIntHdr:
  PUSH AX,BX,DS                      ;Save used registers
  MOV  DS,ES                         ;Point DS at the interrupt segment
  CMP  [BX-IntOfst].Signature,0424Bh ;Is there a Removeable Interrupt Signature?
  JNE >H70                           ;If not, it's not removable
  CMP  B [BX-IntOfst].HdwreJmp,0EBh  ;Is the HdwreJmp instruction a Short JMP?
  JNE >H70                           ;If not, it's not removable!
  CMP  B [BX-IntOfst].CodeJmp,0EBh   ;Is the first instruction a Short JMP?
  JE  >H10                           ;If so, keep testing
  CMP  W [BX-IntOfst].CodeJmp,0EA90h ;Is it an Unused iHPFS Entry
  JNE >H70                           ;If not, it's not removable
H10:                                 ;Signature & First Jump Are Valid
  MOV  AL,[BX-IntOfst].EOIFlag       ;Get the EOI flag
  OR   AL,AL                         ;Is it zero?
  JZ  >H80                           ;If so, it's OK
  CMP  AL,80h                        ;Is it 80h?
  JE  >H80                           ;If so, it's OK
H70:                                 ;Vector is not removable
  STC                                ;Set the "not removable" flag
  JMP >H90                           ;We're done
H80:                                 ;Vector is removable
  CLC                                ;Set the "removable" flag
H90:                                 ;We're done
  POP  DS,BX,AX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SET UP THE USB INTERRUPT VECTOR TO POINT AT OUR CODE, AND ENABLE IT
;Inputs:  DS = ES = TSR Data Area
;         [USBIRQNum]
;Outputs: [USBIntHdr].EOIFlag
;Changes: Int Vector to puir code, Enables IRQ if needed
;------------------------------------------------------------------------------
StartUSBInt:
  PUSH AX,CX,DX,DI             ;Save used registers
  CALL DbgRedirUSBInt          ;Write Debug String, if appropriate
  MOV  CL,[USBIRQNum]          ;Get the IRQ Number
  MOV  AH,8                    ;Assume it's on
  MOV  DX,(PIC1Addr+1)         ;  the first PIC
  CMP  CL,8                    ;Is it on the first PIC?
  JB  >S20                     ;If so, continue
  MOV  AH,70h                  ;If not,
  MOV  DX,(PIC2Addr+1)         ;  it's on
  SUB  CL,8                    ;  the second PIC
S20:                           ;PIC & INT are known
  ADD  AH,CL                   ;Calculate the INT Number
  MOV  AL,AH                   ;Change the
  MOV  DI,(USBIntHdr+IntOfst)  ;  software INT
  CALL ChangeInt               ;  to our code
  MOV  [USBIntNum],AL          ;Save the Interrupt number for later
  MOV  AH,01h                  ;Calculate the IRQ Enable Mask
  ROL  AH,CL                   ;  for the PIC
  CLI                          ;Disable interrupts
  IN   AL,DX                   ;Get the current PIC mask
  TEST AL,AH                   ;Is the IRQ already masked in?
  JZ  >S90                     ;If so, we're done
  OR   [USBIntHdr].EOIFlag,80h ;If not, mark us as having programmed the PIC
  NOT  AH                      ;Mask our IRQ
  AND  AL,AH                   ;  into the PIC
  OUT  DX,AL                   ;Send it
S90:                           ;Done
  STI                          ;Enable interrupts
  POP  DI,DX,CX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESTORE THE USB INTERRUPT VECTOR TO ITS ORIGINAL CODE, AND DISABLE IT
;Inputs:  ES:[USBIRQNum]
;         ES:[USBIntNum]
;         ES:[USBIntHdr].EOIFlag
;Outputs:
;Changes: Restores Int Vector, Disables IRQ if appropriate
;------------------------------------------------------------------------------
StopUSBInt:
  PUSH AX,CX,DX,DI                ;Save used registers
  TEST ES:[USBIntHdr].EOIFlag,80h ;Did we enable the IRQ when we started?
  JZ  >S50                        ;If not, we don't want to disable it
  CALL DisableIRQ                 ;If so, Disable it
S50:                              ;Done resetting PIC
  MOV  AL,ES:[USBIntNum]          ;Work with the USB IRQ vector
  MOV  DI,(USBIntHdr+IntOfst)     ;Point at the old address (ES:[DI])
  CALL RestoreInt                 ;Restore it back to where it was
  POP  DI,DX,CX,AX                ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED TO SET UP AND DO SCREEN PAUSES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SETUP PARAMETERS FOR DOING A SCREEN PAUSE (FOR PRINTING A LARGE TABLE)
;Inputs:  CS = Local Data Area
;         DS:[DX] = ASCIIZ Header to Print at top of each screen
;                   Last character of the Header MUST be an LF
;                   If SetupPauseNoHdr, we "inject" NoMsg as the Header
;Outputs: Pauses the screen with a MORE message every time it gets full
;NOTES:   If a Screen Header is really large (almost taking up the whole
;           screen itself, with little room for data), this procedure
;           may not work correctly.  This procedure does not validate
;           the size of the Header -- it simply assumes that it is a
;           "reasonable" size compared to the size of the screen.  Most
;           anything that needs a Screen Header (a long data table) will
;           only have a few lines of Header, so this should be OK as a
;           general purpose procedure.
;         After this Setup is complete (which should be near the beginning
;           of MAIN, before anything is sent to the screen), WriteZPause
;           must be called for ALL screen writing to CON:, not WriteZCon!
;         The Pausing occurs in "real time", meaning we can send things
;           to the Pause routine a byte, line, or several screens at a
;           time for processing.  Because we do it in "real time",
;           we can end up with extra MORE's and screen Headers appearing
;           on screen than are actually needed.  During a screen
;           transition (or a transition to a new Header) whether we
;           actually need to write anything or not depends on if there
;           is actually any real data coming afterward (in time), which
;           of course we don't know (since it hasn't happened yet).
;           So, we must assume there is more data to come and process the
;           MORE's and Screen Headers accordingly.  This only causes problems
;           (in the form of extraneous MORE's and Screen Headers)
;           when things happen near the bottom of the screen.
;           DOS's MORE utiltiy (and other programs of similar ilk) do not
;           process in "real time", but rather store things in a Temporary
;           File and then process the file.
;------------------------------------------------------------------------------
SetupPauseNoHdr:
  PUSH DX         ;Save used registers
  MOV  DX,NoMsg   ;Point at 0-length Message
  CALL SetupPause ;Setup the Pause
  POP  DX         ;Restore used registers
  RET

SetupPauseFar:
  CALL SetupPause ;Setup the Pause routine
  RETF

SetupPause:
  PUSH AX,BX,CX,DI,SI       ;Save used registers
  PUSH BP,DS                ;Save used registers
  MOV  BP,DS                ;Save header segment in BP
  MOV  SI,OFFSET PauseHeaderPtr ;[SI] = PauseHeaderPtr
  CMP  W CS:[SI+2],-1       ;Has the user already cancelled us?
  JE  >S90                  ;If so, just quit
  CMP  W CS:[SI+2],0        ;Has the user stopped pausing already?
  JE  >S85                  ;If so, just write the header
  CALL TestRedir            ;Is our output redirected?
  JNC >S10                  ;If not, setup our Headers
  MOV  W CS:[SI+2],0        ;Mark as Redirected or Pausing Stopped/Disabled
  JMP >S85                  ;Jump to write the Header and Quit
S10:                        ;Output not redirected
  CALL GetScreenRows        ;Store the number of rows
  MOV  CS:[PauseRows],AX    ;  on the screen
  CALL CountZLinesCX        ;Calculate the number of lines
  INC  CX,2                 ;  in the new Header
  MOV  DS,CS                ;Point DS at local data area
  MOV  DI,[PauseRowCount]   ;Get the Current Row count
  ADD  DI,CX                ;Add the size of the new header
  SUB  DI,3                 ;Adjust for Headers
  DEC  AX                   ;Will writing the new Header
  CMP  DI,AX                ;  cause a Pause event?
  JB  >S50                  ;If not, handle it
S20:                        ;New Header is too big to fit on screen
  MOV  W [SI],NoMsg         ;Point Header for second page
  MOV  W [SI+2],CS          ;  at nothing
  MOV  [PauseHeaderSize],2  ;Set Pause Header Size
  PUSH CX                   ;Save New Header Size
  SUB  AX,[PauseRowCount]   ;Calculate how many rows to fill up the screen
  MOV  CX,AX                ;Put number of rows in CX
  INC  CX                   ;Adjust it
S30:                        ;Loop to here to fill up the screen
  CALL WriteCrLfPause       ;Write a new line
  LOOP S30                  ;Keep going until we're done
  POP  CX                   ;Restore New Header Size
  CMP  W [SI+2],-1          ;Did the user cancel during the header transition?
  JE  >S90                  ;If so, we're done
  CMP  W [SI+2],0           ;Did the user stop Pausing during the transition?
  JE  >S85                  ;If so, just write the Header
S50:                        ;Need to adjust current Row Count
  SUB  [PauseRowCount],2    ;Adjust things for the previous Header
S80:                        ;Store new Header Info
  MOV  [SI+0],DX            ;Store the new
  MOV  [SI+2],BP            ;  Header Address
  MOV  [PauseHeaderSize],CX ;Store the Header Size
  ADD  [PauseRowCount],CX   ;Add the Header Size to the Row Count
  MOV  AX,[PauseRows]       ;Compensate if
  CMP  AX,[PauseRowCount]   ;  the new header
  JAE >S85                  ;  put us past
  DEC  AX                   ;  the end
  MOV  [PauseRowCount],AX   ;  of hte screen
S85:                        ;Write Header
  MOV  DS,BP                ;Make sure DS:[DX] points at Header
  CALL WriteZCon            ;Write the Header
S90:                        ;We're done
  POP  DS,BP                ;Restore used registers
  POP  SI,DI,CX,BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHECK TO SEE IF STDOUT HAS BEEN REDIRECTED
;Inputs:
;Outputs: CF = Clear if STDOUT is normal (usually the screen)
;            = Set if STDOUT been redirected
;Changes:
;------------------------------------------------------------------------------
TestRedir:
  PUSH AX,BX,DX        ;Save used registers
  MOV  AX,4400h        ;Function 4400h (Get Device Info)
  MOV  BX,StdOutHandle ;Device = STDOUT
  INT  21h             ;Do it (returns DX, changes AX)
  JC  >R80             ;If error, assume not Redirected
  AND  DL,(DvcInfoIsDevice+DvcInfoIsStdOut) ;Mask out unwanted bits
  CMP  DL,(DvcInfoIsDevice+DvcInfoIsStdOut) ;Is it still the STDOUT Device?
  JE  >R80             ;If so, it's not Redirected
R70:                   ;STDOUT has been Redirected
  STC                  ;Set the Redirected flag
  JMP >R90             ;Done
R80:                   ;STDOUT is not Redirected
  CLC                  ;Set the Not-Redirected flag
R90:                   ;Done
  POP  DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NUMBER OF VIDEO ROWS ON THE SCREEN
;Inputs:
;Outputs: AX = Number of text rows on the screen
;                (usually 25, 43, or 50)
;Changes:
;------------------------------------------------------------------------------
GetScreenRows:
  PUSH BX,CX,DS  ;Save used registers
  MOV  AX,40h    ;Point ES to
  MOV  DS,AX     ;  BIOS data area
  MOV  AH,12h    ;Function 12h (EGA Alternate Select)
  MOV  BX,0FF10h ;Subfunction (BL) 10h (Return EGA information)
                 ;  Preset unrealistic return value (BH)
  INT  10h       ;Do it (returns AX, BX, CX)
  CMP  BL,10h    ;Is the function supported (EGA or better)?
  JE  >R50       ;If not, jump to handle MDA/CGA
  CMP  BH,0FFh   ;Is the return value valid?
  JE  >R50       ;If not, jump to handle MDA/CGA
  TEST B [87h],8 ;If so, is bit 3 of the EGA information byte set?
  JNZ >R50       ;If so, EGA is not the active display
  XOR  AX,AX     ;Get # of
  MOV  AL,[84h]  ;  rows - 1
  JMP >R90       ;We're done
R50:             ;Video card is less than EGA (MDA or CGA)
  MOV  AX,24     ;Number of rows must be 25
R90:             ;We're done
  INC  AX        ;Bump the number of rows by 1
  POP  DS,CX,BX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ASCIIZ STRING(s) TO THE SCREEN, PAUSING WHEN IF NECESSARY
;Inputs:  DS:[DX] = String to write
;         [PauseRows], [PauseHeaderPtr], [PauseHeaderSize], [PauseRowCount]
;         CS = Local Data Area
;Outputs: [PauseRowCount]
;Changes: Pauses the screen and waits for user input, if necessary
;NOTES: This should be called instead of WriteZCon every time something
;         is written during the Pausing.
;       A string can be written by WriteZCon during the pausing, as long
;         as the string does not contain a Line Feed.  Any line containing
;         a Line Feed must come through here or the Line Count will get
;         screwed up!
;------------------------------------------------------------------------------
  CallBackSig:     DB 'DS:[DX]',0     ;Call Back Signature String
                                      ;Must IMMEDIATELY precede WriteZPauseFar
  CallBackSigSize EQU ($-CallBackSig) ;Size of the String

WriteZPauseFar:
  CALL WriteZPause ;Write the String
  RETF

WriteZPause:
  PUSH AX,BX,CX,DX,DS        ;Save used registers
  CALL TestFSSegment         ;Test for and modify DS:[DX], if needed
  MOV  AX,W CS:[PauseHeaderPtr][2] ;Put Header Segment in AX
  CMP  AX,-1                 ;Has the Output been cancelled by the user?
  JE  >P90                   ;If so, don't write anything at all
  OR   AX,AX                 ;Is STDOUT Redirected?
  JZ  >P80                   ;If so, just write it with no Pausing
  CALL CountZLinesCX         ;Count how many Lines are in the string
  MOV  AX,CS:[PauseRowCount] ;Add the new lines
  ADD  AX,CX                 ;  to the current lines
  CMP  AX,CS:[PauseRows]     ;Will we be at or past the end of the screen?
  JB  >P70                   ;If not, just write it
  JE  >P50                   ;If at the end of the screen, handle it
  SUB  AX,CS:[PauseRows]     ;If not, find
  SUB  CX,AX                 ;  the end of the String
  CALL FindEndOfLines        ;  we need to write ([BX])
  MOV  AL,[BX]               ;Save the character that's there now
  MOV  B [BX],0              ;Replace it with a 0
  CALL WriteZPause           ;Write it (will Pause correctly)
  MOV  [BX],AL               ;Restore original character
  MOV  DX,BX                 ;Use the new string pointer
  CALL WriteZPause           ;Write it (Pausing if necessary)
  JMP >P90                   ;Done
P50:                         ;At end of screen
  CALL WriteZCon             ;Write the String
  CALL HandlePause           ;Handle the Pause (may change Pointers/Counters)
  JMP >P90                   ;We're done for now
P70:                         ;Store new Row Count
  MOV  CS:[PauseRowCount],AX ;Save the new Row Count
P80:                         ;Write the String
  CALL WriteZCon             ;Write the string
P90:                         ;Done
  POP  DS,DX,CX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST FOR AND CHANGE THE DATA SEGMENT, IF APPROPRIATE TO WRITE STRINGS
;Inputs:  DS:[DX] = String to write
;      OR [OvlSegment] = Segment where string is located and DX = String ID
;         CS = Local Data Area
;Outputs: If appropriate, DS:[DX] = "real" pointer
;Changes:
;------------------------------------------------------------------------------
TestFSSegment:
  PUSH AX,BX,ES               ;Save used registers
  MOV  AX,CS                  ;Is DS
  MOV  BX,DS                  ;  in our
  CMP  AX,BX                  ;  data area?
  JNE >F90                    ;If not, we're done
  CMP  DX,MinSID              ;Is it too small to be a String ID?
  JB  >F90                    ;If so, we're done
  MOV  ES,CS:[OvlSegment]     ;ES:[BX] =
  MOV  BX,(OvlSignatureLen+9) ;  Lookup Table in Overlay Segment
  MOV  AL,DL                  ;AL = Index to Find in the Table
  CALL SearchByte2WordTbl     ;Do it  (just assume it works)
  MOV  DX,BX                  ;DS:[DX] =
  MOV  DS,ES                  ;  New Pointer
F90:                          ;Done
  POP  ES,BX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE PAUSE LINE, AND WAIT FOR A KEYSTROKE
;Inputs:  CS = Local Data Area
;         [PauseRows], [PauseHeaderPtr], [PauseHeaderSize], [PauseRowCount]
;Outputs: [PauseRowCount], [PauseHeaderPtr]
;Changes: Pauses the screen and waits for user input, if necessary
;------------------------------------------------------------------------------
HandlePause:
  PUSH AX,BX,DX,DS          ;Save String Segment
  MOV  DS,CS                ;Point DS at our Data Segment
  MOV  BX,OFFSET PauseHeaderPtr ;[BX] = Pause Header
  MOV  DX,SIDPause          ;Write the
  CALL WriteZCon            ;  Enter a Keystroke message
  CALL FlushKbdBuff         ;Clear the keyboard buffer
L10:                        ;Loop to here to wait for a keystroke
  CALL GetKey               ;Is there a key in the keystroke buffer?
  JZ   L10                  ;If not, keep waiting until there is
  MOV  DX,SIDPauseD         ;Delete the
  CALL WriteZCon            ;  MORE Message
  CMP  AL,CtrlC             ;Was the keystroke a Control-C?
  JNE >L30                  ;If not, try the next possibility
  MOV  W [BX+2],-1          ;If so, mark as stopped
  JMP >L90                  ;Done
L30:                        ;Test for Escape
  CMP  AL,Escape            ;Was the keystroke an Escape?
  JNE >L40                  ;If not, just keep going
  MOV  W [BX+2],0           ;If so, mark us as redirected (stop Pausing)
  JMP >L90                  ;Done
L40:                        ;Continue with the Pause
  MOV  DX,SIDPauseN         ;Write the
  CALL WriteZCon            ;  MORE Replacement Line
  LDS  DX,[BX]              ;Point DS:[DX] at the Header
  CALL WriteZCon            ;Write it
  MOV  DS,CS                ;Point DS at the local data area
  MOV  AX,[PauseHeaderSize] ;Reset the Row Count
  MOV  [PauseRowCount],AX   ;Store the new Row Count
L90:                        ;Done
  POP  DS,DX,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE NUMBER OF LINES IN AN ASCIIZ STRING (COUNT CR/LF COMBINATIONS)
;Inputs:  DS:[DX] = Pointer to String to measure (may be String in [OvlSegment])
;         CLD already issued
;Outputs: CX = Number of LF's in the String (may be 0)
;         ZF = Set if CX = 0
;            = Clear if CX > 0
;Changes:
;------------------------------------------------------------------------------
CountZLinesCX:
  PUSH AX,DX,SI,DS   ;Save used registers
  CALL TestFSSegment ;Convert to DS:[DX] in Overlay segment, if appropriate
  MOV  SI,DX         ;Put the pointer in DI
  XOR  CX,CX         ;Initialize Lines Counter
Z10:                 ;Loop to here for each character
  LODSB              ;Get the next character
  OR   AL,AL         ;Is it the end of the string?
  JZ  >Z90           ;If so, we're done
  CMP  AL,LF         ;Is it a Line Feed?
  JNE  Z10           ;If not, it's not a new line
  INC  CX            ;If so, Increment the Line Counter
  JMP  Z10           ;Keep looking
Z90:                 ;We're done
  OR   CX,CX         ;Set return flag
  POP  DS,SI,DX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE POINTER AFTER THE FIRST SEVERAL LINES OF A STRING
;Inputs:  DS:[DX] = String to use
;         CX = Number of lines to "skip"
;         CLD already issued
;Outputs: DS:[BX] = "New" String Pointer (after the last line written)
;Changes:
;NOTES: This assumes that the string actually has MORE than the number of
;         lines in AX (it does not look for the end of an ASCIIZ string).
;------------------------------------------------------------------------------
FindEndOfLines:
  PUSH AX,CX  ;Save used registers
  PUSH DI,ES  ;Save used registers
  MOV  BX,CX  ;BX = Line Counter
  MOV  ES,DS  ;Point ES:[DI] at
  MOV  DI,DX  ;  the string
  MOV  AL,LF  ;Look for Line Feeds
  MOV  CX,-1  ;Maximize counter
L10:          ;Loop to here for each new line
  REPNE SCASB ;Look for the end-of-line character
  DEC  BX     ;Decrement the Line Counter
  JNZ  L10    ;If not 0 yet, keep looking
  MOV  BX,DI  ;Store the new string beginning
L90:          ;Done
  POP  ES,DI  ;Restore used registers
  POP  CX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FLUSH KEYBOARD BUFFER
;Inputs:
;Outputs:
;Changes: Flushes the Keyboard Buffer
;------------------------------------------------------------------------------
FlushKbdBuff:
  PUSH AX     ;Save used registers
F10:          ;Loop to here for each key
  CALL GetKey ;Get a key from the keyboard buffer
  JNZ  F10    ;If there was one, get another
  POP  AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ CHARACTER FROM THE KEYBOARD BUFFER
;Inputs:
;Outputs: AH = Keyboard scan code
;         AL = ASCII value of keypress (0 if extended ASCII)
;         AX = 0 if no key is waiting
;Changes: ZF = Set if no key in buffer (AX = 0)
;            = Clear if a key was found (AX = key)
;------------------------------------------------------------------------------
GetKey:
  MOV  AH,1  ;Service 1 (Keystroke waiting?)
  INT  16h   ;Do It
  JZ  >K10   ;If no key waiting, we're done
  XOR  AH,AH ;If a key is waiting, service 0 (Get keystroke)
  INT  16h   ;Do It
  JMP >K90   ;We're done
K10:         ;No keystroke waiting
  XOR  AX,AX ;Make sure AX=0
K90:         ;We're done
  OR   AX,AX ;Set the found/not found flag
  RET

;------------------------------------------------------------------------------
;WRITE A CR/LF TO THE CONSOLE WITH A PAUSE
;Inputs:
;Outputs: To SCreen, Updates Pause Counters
;Changes:
;------------------------------------------------------------------------------
WriteCrLfPause2:
  CALL WriteCrLfPause ;Write two
  CALL WriteCrLfPause ;  new Lines
  RET

WriteCrLfErr:
  PUSH DX         ;Save used registers
  MOV  DX,SIDCrLf ;Write a Cr/Lf to
  CALL WriteZErr  ;  the Err Device
  POP  DX         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SOME GENERIC CODE TO WRITE STRINGS, ETC.
;This code is needed in almost every program we write.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GETS RID OF ENVIRONMENT INFORMATION - NOT NEEDED IN TSR
;Inputs:
;Outputs:
;Changes: Quits if problem releasing memory
;------------------------------------------------------------------------------
DelEnvironment:
  PUSH AX,ES            ;Save used registers
  MOV  ES,[PSPEnvirSeg] ;Point ES at the Environment Segment
  MOV  AH,49h           ;Service 49h (free up memory)
  INT  21h              ;Do it
  JNC >E90              ;If no error occurred, Quit
  MOV  DX,SIDNoEnviron  ;If error, point to message
  MOV  AL,ErLvlMemory   ;Errorlevel = Memory Problem
  JMP  Exit             ;QUIT
E90:                    ;We're done
  POP  ES,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;BEEP THE SPEAKER
;Inputs:
;Outputs: Beeps the speaker
;Changes:
;------------------------------------------------------------------------------
BeepErr:
  PUSH AX,BX    ;Save used registers
  XOR  BX,BX    ;BH = Video page = 0
  MOV  AX,0E07h ;AH = 0Eh = Function = Write TTY
                ;AL = 07h = Character to write = BEL
  INT  10h      ;Do it
  POP  BX,AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CAPITALIZE A CHARACTER (Byte)
;Inputs:  AL = character to be capitalized
;Outputs: AL = capitalized character
;Changes:
;------------------------------------------------------------------------------
Capitalize:
  CMP  AL,'a'     ;Is it less than 'a'?
  JB  >Z90        ;If so, quit
  CMP  AL,'z'     ;Is it more than 'z'?
  JA  >Z90        ;If so, quit
  SUB  AL,'a'-'A' ;If between 'a' and 'z', capitalize it
Z90:
  RET

;------------------------------------------------------------------------------
;WRITE SOME SPACES OR HEADER LINES (DOUBLE OR SINGLE) TO THE SCREEN
;Inputs:  CL = Number of characters to write
;Outputs: To the screen
;Changes:
;------------------------------------------------------------------------------
WriteSpacesErr:
  PUSH AX,DX         ;Save used registers
  MOV  AL,-1         ;Mark as ERR
  MOV  DX,SIDSpace   ;Point at Space Message
  JMP >S00           ;Do it
WriteSpaces:
  PUSH AX,DX         ;Save used registers
  XOR  AL,AL         ;Mark as CON
  MOV  DX,SIDSpace   ;Point at Space Message
  JMP >S00           ;Do it
WriteDoubleLine:
  PUSH AX,DX         ;Save used registers
  XOR  AL,AL         ;Mark as CON
  MOV  DX,SIDDblLine ;Point at Double Line Message
;  JMP >S00           ;Do it
S00:
  PUSH CX            ;Save used registers
  OR   CL,CL         ;Should we write 0 characters?
  JZ  >S90           ;If so, we're done
  XOR  CH,CH         ;If OK, change it to a word
  OR   AL,AL         ;Write to CON (Pause)?
  JNZ >S30           ;If not, Handle ERR
S10:                 ;Loop to here for each character
  CALL WriteZPause   ;Write the character
  LOOP S10           ;Keep going until we're done
  JMP >S90           ;Done
S30:                 ;Write to Err
  CALL WriteZErr     ;Write the character
  LOOP S10           ;Keep going until we're done
S90:                 ;We're done
  POP  CX            ;Restore used registers
  POP  DX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A SPECIFIC CHARACTER OR SET OF CHARACTERS TO THE SCREEN
;Inputs:
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
WriteAL:
  PUSH DX              ;Save used registers
  MOV  DL,AL           ;Write what's in AL
  JMP >C00             ;Do it
WriteBlock:
  PUSH DX              ;Save used registers
  MOV  DL,'±'          ;Write a Block Character
  JMP >C00             ;Do it
WriteCR:
  PUSH DX              ;Save used registers
  MOV  DL,CR           ;Write a Carriage Return
  JMP >C00             ;Do it
WriteCrLfPause:
  PUSH DX              ;Save used registers
  MOV  DX,SIDCrLf      ;Point at Message
  JMP >C10             ;Do it
WriteDash:
  PUSH DX              ;Save used registers
  MOV  DL,'-'          ;Write an h
  JMP >C00             ;Do it
WriteDot:
  PUSH DX              ;Save used registers
  MOV  DX,DotMsg       ;Point at Message
  JMP >C10             ;Do it
WriteHexEnd:
  PUSH DX              ;Save used registers
  MOV  DL,'h'          ;Write an h
  JMP >C00             ;Do it
WritePeriod:
  PUSH DX              ;Save used registers
  MOV  DL,'.'          ;Write a Period
  JMP >C00             ;Do it
WriteSpace:
  PUSH DX              ;Save used registers
  MOV  DX,SIDSpace     ;Point at Message
  JMP >C10             ;Do it
Write2Spaces:
  PUSH DX              ;Save used registers
  MOV  DX,SIDSpace2    ;Point at Message
  JMP >C10             ;Do it
Write3Spaces:
  PUSH DX              ;Save used registers
  MOV  DX,SIDSpace3    ;Point at Message
  JMP >C10             ;Do it
Write4Spaces:
  PUSH DX              ;Save used registers
  MOV  DX,SIDSpace4    ;Point at Message
  JMP >C10             ;Do it
C00:
  MOV  SingleMsg[0],DL ;Put the character in the Single Character String
  MOV  DX,SingleMsg    ;Point at Single Character String
C10:                   ;DX is pointed at String
  CALL WriteZPause     ;Write the String
  POP  DX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A YES OR NO AND THEN SOME SPACES TO THE SCREEN
;Inputs: AL/AH = Status Word to test (If WriteYesNoAL or WriteYesNoAH)
;        DL/DH = Status Word to test (If WriteYesNoDL or WriteYesNoDH)
;        BH    = Mask to test for
;Outputs: To the screen
;Changes:
;------------------------------------------------------------------------------
WriteYesNoALBH:
  PUSH AX            ;Save used registers
  JMP >Y00           ;Jump to do it
WriteYesNoAHBH:
  PUSH AX            ;Save used registers
  MOV  AL,AH         ;Put test byte into AL
  JMP >Y00           ;Jump to do it
WriteYesNoDLBH:
  PUSH AX            ;Save used registers
  MOV  AL,DL         ;Put test byte into AL
;  JMP >Y00           ;Jump to do it
;WriteYesNoDHBH:
;  PUSH AX            ;Save used registers
;  MOV  AL,DH         ;Put test byte into AL
;;  JMP >Y00           ;Jump to do it
Y00:
  PUSH DX            ;Save used registers
  MOV  DX,SIDYes2Msg ;Assume Yes
  TEST AL,BH         ;Is it Yes?
  JNZ >Y20           ;If so, write Yes
  MOV  DX,SIDNo2Msg  ;If not, write No
Y20:                 ;[DX] = String to write
  CALL WriteZPause   ;Write it
  POP  DX            ;Restore used registers
  POP  AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT BYTE, WORD, OR DWORD TO HEX CHARACTER STRING, AND WRITE IT
;Inputs:  AL/AX = Nibble/Byte/Word to be written
;         CLD must be set already!
;Outputs: Writes to the Screen
;Changes: HexString
;------------------------------------------------------------------------------
WriteNibbleHex:
  PUSH BX             ;Save used registers
  MOV  BX,8           ;Need to start of offset 8 in string
  JMP >H00            ;Jump to do it
WriteByteHex:
  PUSH BX             ;Save used registers
  MOV  BX,7           ;Need to start of offset 7 in string
  JMP >H00            ;Jump to do it
WriteWordHex:
  PUSH BX             ;Save used registers
  MOV  BX,5           ;Need to start of offset 5 in string
  JMP >H00            ;Jump to do it
WriteDWordHex:
  PUSH BX             ;Save used registers
  XOR  BX,BX          ;Need to start of offset 0 in string
;  JMP >H00            ;Jump to do it
H00:                  ;Start converting the strings
  PUSH DX,DI          ;Save used registers
  MOV  DI,HexString   ;Point DS:[DI] at HexString
  MOV  DX,DI          ;Point DS:[DX] at HexString
  ROR  EAX,16         ;Convert the High Word
  CALL Word2HexString ;  to a String
  INC  DI             ;Skip over the Underscore
  ROR  EAX,16         ;Convert the Low Word
  CALL Word2HexString ;  to a String
  ADD  DX,BX          ;Point DX at the beginning of where we write
  CALL WriteZPause    ;Write it
  POP  DI,DX          ;Restore used registers
  POP  BX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A BYTE OR WORD TO A HEXADECIMAL STRING (2 OR 4 CHARACTERS)
;Inputs:  AX = Word to Convert to a Hex String
;         DS = Local Data Area
;         CLD already issued
;Outputs: DS:[DI]
;Changes: DI
;------------------------------------------------------------------------------
Word2HexString:
  PUSH AX,BX,ES         ;Save used registers
  MOV  BX,AX            ;Save original Word
  MOV  ES,DS            ;Point ES:[DI] at
  CALL Word2HexString00 ;Convert it
  POP  ES,BX,AX         ;Restore used registers
  RET

Word2HexString00:
  MOV  AL,BH            ;Convert High Byte
  CALL Word2HexString10 ;  to ASCII
  MOV  AL,BL            ;Work with Low Byte
Word2HexString10:       ;Convert Byte to ASCII
  AAM  10h              ;Separate Low & High Nibbles
  XCHG AH,AL            ;Put High Nibble in AL
  CALL Word2HexString20 ;Convert High Nibble to ASCII
  XCHG AH,AL            ;Work with Low Nibble
Word2HexString20:       ;Convert Nibble to ASCII
  ADD  AL,90h           ;Convert BCD
  DAA                   ;  to Decimal
  ADC  AL,40h           ;Convert Decimal
  DAA                   ;  to ASCII
  STOSB                 ;Store the Nibble
  RET

Byte2HexString:
  PUSH AX,ES            ;Save used registers
  MOV  ES,DS            ;Point ES:[DI] at the String
  CALL Word2HexString10 ;Convert it
  POP  ES,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE OR WORD TO THE SCREEN AS A DECIMAL (EXTRA SPACES INCLUDED)
;Inputs:  AL/AX = Byte/Word to Write
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteByteMin:
  PUSH AX,BX          ;Save used registers
  XOR  AH,AH          ;Make sure high byte is 0
  MOV  BH,(WriteBWMin+WriteBWByte) ;Set Flags
  JMP >W00            ;Do it
WriteWordMin:
  PUSH AX,BX          ;Save used registers
  MOV  BH,(WriteBWMin+WriteBWWord) ;Set Flags
  JMP >W00            ;Do it
ByteToString:
  PUSH AX,BX          ;Save the original word & BP
  XOR  AH,AH          ;Make sure high byte is 0
  MOV  BH,(WriteBWNoMin+WriteBWByte) ;Set Flags
  JMP >W00            ;Jump to start the loop
WordToString:
  PUSH AX,BX          ;Save the original word
  MOV  BH,(WriteBWNoMin+WriteBWWord) ;Set Flags
;  JMP >W00            ;Jump to start the loop
;WordToString3:
;  PUSH AX,BX          ;Save the original word
;  MOV  BH,(WriteBWNoMin+WriteBWByte) ;Set Flags
;  JMP >W00            ;Jump to start the loop
W00:                  ;Do a word or a byte
  PUSH CX,DX,SI       ;Save used registers
  MOV  SI,SingleMsg   ;Point at the single character message
  XOR  BL,BL          ;Test for first non-zero character is false
  MOV  CX,10000       ;First divisor is 10,000
W20:                  ;Loop to here for each character
  XOR  DX,DX          ;High word of Dividend = 0
  DIV  CX             ;Divide DX:AX by current divisor
  OR   AX,AX          ;Is this a non-zero character?
  JNZ >W30            ;If so, we need to write it
  OR   BL,BL          ;Has there already been a non-zero character?
  JNZ >W30            ;If so, we need to write it
  CMP  CX,1           ;Is this the last character?
  JE  >W30            ;If so, we need to write it
  TEST BH,WriteBWMin  ;Are we doing a minimum?
  JNZ >W40            ;If not, don't write anything
  MOV  AL,' '         ;Assume a space
  TEST BH,WriteBWWord ;Doing a word?
  JNZ >W35            ;If so, write the space
  CMP  CX,100         ;If not, doing the hundreds character?
  JBE >W35            ;If so, write the space
  JMP >W40            ;If not, don't write anything
W30:                  ;We need to write this character
  INC  BL             ;Test for first non-zero character is true
  ADD  AL,'0'         ;Convert the Number to ASCII
W35:                  ;Write the character
  MOV  [SI],AL        ;Write the
  CALL WriteZPauseSI  ;  character
W40:                  ;Skip this character - just make it a space
  CMP  CX,1           ;Was this the last division to do?
  JE  >W90            ;If so, we're done
  MOV  AX,DX          ;If not, start next loop with remainder of division
  PUSH AX             ;Save register for a second
  XOR  DX,DX          ;So dividend won't be messed up
  MOV  AX,CX          ;Want to divide divisor in CX
  MOV  CX,10          ;Want to divide by 10
  DIV  CX             ;Divide it
  MOV  CX,AX          ;Store it back in CX
  POP  AX             ;Restore register
  JMP  W20            ;And do it again
W90:                  ;We're done
  POP  SI,DX,CX       ;Restore used registers
  POP  BX,AX          ;Restore original word & BP
  RET

;------------------------------------------------------------------------------
;WRITE THE ADDRESS AND TYPE OF A LINK OR ELEMENT POINTER
;Inputs:  EAX = Link/Element Pointer to write
;         ES = TSR Segment
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WritePtrType:
  PUSH EAX,BX,CX,DI,SI        ;Save used registers
  MOV  BH,AL                  ;Save the Flags
  MOV  SI,SingleMsg           ;Point at SingleMsg
  AND  EAX,FLAddrMask         ;Get rid of the flags (just need the address)
  CALL WriteDWordHex          ;Write it
  CALL WriteHexEnd            ;Write the "h"
  CALL WriteSpace             ;Move over
  CALL CalcPhysAddrType       ;See what type of pointer it is
  TEST BL,PhysAddrClassNul    ;Is it anything at all?
  JNZ >P10                    ;If not, jump to handle it
  TEST BL,PhysAddrClassTD     ;Is it a Transfer Descriptor
  JNZ >P20                    ;If so, jump to handle it
  TEST BL,PhysAddrClassQH     ;Is it a Queue?
  JNZ >P30                    ;If so, jump to handle it
P10:                          ;Pointer is Invalid/Empty
  MOV  B [SI],'.'             ;Store the Invalid/Empty Message
  XOR  CX,CX                  ;Index = 0
  JMP >P50                    ;Jump to write things
P20:                          ;Pointer is a Transfer Descriptor
  MOV  B [SI],'T'             ;Store the Transfer Descriptor Message
  CALL PhysAddr2SegOffNoFlags ;Calculate the
  CALL TDOffset2Index         ;  TD Index
  JMP >P50                    ;We're done
P30:                          ;Pointer is a Queue
  MOV  B [SI],'Q'             ;Store the Queue Head Message
  CALL PhysAddr2SegOffNoFlags ;Calculate the
  CALL QHOffset2Index         ;  QH Index
P50:                          ;Have everything calculated
  CALL WriteZPauseSI          ;Write the Type of Link Pointer
  MOV  AX,CX                  ;Write the
  CALL WordToString           ;  Index
  CALL WriteSpace             ;Move Over
  MOV  AL,BH                  ;Get back the flags
  MOV  BH,TDQHSelect          ;Write the
  CALL WriteYesNoALBH         ;  QH Select Flag
  MOV  BH,TDTerminate         ;Write the
  CALL WriteYesNoALBH         ;  Terminate Flag
  POP  SI,DI,CX,BX,EAX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEARCH THROUGH A BYTE-TO-STRING LOOKUP TABLE, AND WRITE THE STRING
;Inputs:  DS:[BX] = Byte-to-String lookup table (may be an SID)
;         AL = Byte to look for
;         CLD already issued
;Outputs: CF = Clear if the byte was found
;              String written to CON
;            = Set if byte was not found
;              Nothing written to screen
;Changes:
;NOTES: The end-of-table marker is a DW -1
;------------------------------------------------------------------------------
WriteByteToStringTbl:
  PUSH AX,DX,SI,DS      ;Save used registers
  MOV  DX,BX            ;DS:[DX] = SID value
  CALL TestFSSegment    ;Test for and modify DS:[DX], if needed
  MOV  SI,DX            ;DS:[SI] = Lookup Table
  MOV  AH,AL            ;Put byte to search for in AH
B10:                    ;Loop to here for each table entry
  CMP  W [SI],-1        ;End of the Table?
  JE  >B70              ;If so, there's no match
  LODSB                 ;If not, get the byte
  CMP  AL,AH            ;Is it the corect table entry?
  JE  >B30              ;If so, jump to handle it
  CALL SkipOverStringSI ;If not, skip over the string
  JMP  B10              ;Keep looking
B30:                    ;[SI] points at the string
  CALL WriteZPauseSI    ;Write the String
  JMP >B80              ;Done
B70:                    ;Byte not found in the table
  STC                   ;Set not-found flag
  JMP >B90              ;Done
B80:                    ;Byte was found in the table
  CLC                   ;Set found flag
B90:                    ;Done
  POP  DS,SI,DX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEARCH A BYTE-TO-STRING LOOKUP TABLE FOR A MATCHING ENTRY
;Inputs:  DS:[BX] = Table to search (may be table in Overlay segment)
;         AL      = Byte to search for
;         CLD already issued
;Outputs: CF = Clear if a byte match as found in table
;              BX = Pointer to the String
;            = Set if no match found in table
;              BX = unchanged
;Changes:
;NOTES: Last Entry in Table (end-of-table marker) = DW -1
;------------------------------------------------------------------------------
SearchByte2StringTbl:
  PUSH AX,DX,SI,DS      ;Save used registers
  CLD                   ;Go forward with string functions
  MOV  DX,BX            ;DS:[DX] =
  CALL TestFSSegment    ;  Table Pointer
  MOV  SI,DX            ;Put pointer in SI
  MOV  AH,AL            ;Put byte to check in AH
S10:                    ;Loop to here for each table entry
  LODSB                 ;Get the next table entry
  CMP  AL,-1            ;Is it possibly the end of the table?
  JNE >S20              ;If not, continue
  CMP  B [SI],-1        ;Is it actually the end of the table?
  JE  >S70              ;If so, there's no match
S20:                    ;Not end of table
  CMP  AL,AH            ;Is it a match?
  JE  >S80              ;If so, handle it!
  CALL SkipOverStringSI ;If not, skip over the string
  JMP  S10              ;And keep looking
S70:                    ;No entry found
  STC                   ;Set the not found flag
  JMP >S90              ;Quit
S80:                    ;Entry found [SI]
  MOV  BX,SI            ;Point BX at the String
  CLC                   ;Set the found flag
S90:                    ;Done
  POP  DS,SI,DX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER AN ASCIIZ STRING
;Inputs:  DS:[SI] = ASCIIZ String to Skip Over
;      OR ES:[SI] =   "      "    "   "    "
;Outputs:
;Changes: [SI] points at character after the 0
;------------------------------------------------------------------------------
SkipOverStrESSI:
  PUSH DS               ;Save used registers
  MOV  DS,ES            ;DS = String Segment
  CALL SkipOverStringSI ;Skip over the string
  POP  DS               ;Restore used registers
  RET

SkipOverStringSI:
  PUSH CX            ;Save used registers
  CALL CalcStrSizeSI ;Calculate the size of the string
  ADD  SI,CX         ;Add it to the pointer
  INC  SI            ;Skip over the 0
  POP  CX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LENGTH OF AN ASCIIZ STRING
;Inputs:  DS:[SI] = ASCIIZ String to work with
;      OR ES:[SI] =   "      "    "   "    "
;Outputs: CX = Length of String
;         ZF = Set if string is 0 length
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
CalcStrSizeESSI:
  PUSH DS            ;Save used registers
  MOV  DS,ES         ;DS = Correct data sement
  CALL CalcStrSizeSI ;Calculate the Size
  POP  DS            ;Restore used registers
  RET

CalcStrSizeSI:
  PUSH DX            ;Save used registers
  MOV  DX,SI         ;Calculate the
  CALL CalcStrSizeDX ;  length of the string
  POP  DX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE AN ASCIIZ STRING, POINTED AT BY SI, TO PAUSE
;Inputs:  DS:[SI] = ASCIIZ String to Write
;      OR ES:[SI] =   "      "    "    "
;Outputs: To Screen (CON)
;Changes:
;------------------------------------------------------------------------------
WriteZPauseESSI:
  PUSH DS            ;Save used registers
  MOV  DS,ES         ;DS = Correct data sement
  CALL WriteZPauseSI ;Calculate the Size
  POP  DS            ;Restore used registers
  RET

WriteZPauseSI:
  PUSH DX          ;Save used registers
  MOV  DX,SI       ;Write the
  CALL WriteZPause ;  string
  POP  DX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ASCIIZ STRING TO CON OR TO ERR
;Inputs:  DS:[DX] = Pointer to string
;         CS = Local Data Area
;Outputs: Writes the string to CON or ERR
;Changes:
;------------------------------------------------------------------------------
WriteZCon:             ;Write to CON
  CMP  CS:[PauseHeaderPtr][2],-1 ;Should we write anything?
  JE  >Z90             ;If not, just quit
  PUSH BX,DX,DS        ;Save used register
  MOV  BX,StdOutHandle ;Write to STDOUT
  JMP >Z00             ;Jump to do it
WriteZErr:             ;Write to ERR
  PUSH BX,DX,DS        ;Save used register
  MOV  BX,StdErrHandle ;Write to STDERR
Z00:
  PUSH AX,CX           ;Save used registers
  CALL TestFSSegment   ;Change DS:[DX], if appropriate
  CALL CalcStrSizeDX   ;Calculate the size of the string (returns CX)
  JZ  >Z80             ;If nothing to write, just quit
  MOV  AH,40h          ;Function 40h (Write to Device)
  INT  21h             ;Do it
Z80:                   ;We're done
  POP  CX,AX           ;Restore used registers
  POP  DS,DX,BX        ;Restore used register
Z90:                   ;We're done
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LENGTH OF AN ASCIIZ STRING
;Inputs:  DS:[DX] = Pointer to the string
;Outputs: CX = Length of the string
;         ZF = Set if string is 0 length
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
CalcStrSizeDX:
  PUSH AX,DI  ;Save used registers
  PUSH ES     ;Save used registers
  MOV  ES,DS  ;Point ES:[DI]
  MOV  DI,DX  ; at the string
  XOR  AL,AL  ;Look for a 0
  MOV  CX,-1  ;Start with max count for REPNE
  REPNE SCASB ;Find the end of the string
  NOT  CX     ;Calculate the size
  DEC  CX     ;  of the string (sets ZF)
  POP  ES     ;Restore used registers
  POP  DI,AX  ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PARSE THE COMMAND LINE FOR SWITCHES, AND PRINT ERRORS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PARSE THE COMMAND LINE FOR SWITCHES
;Inputs:
;Outputs: All kinds of stuff!
;Changes:
;------------------------------------------------------------------------------
ParseIt:
  CALL FixCmdLineCR    ;Replace CR at end of Command Line with a 0
  CALL FillStdInBuffer ;Copy redirected input to our buffer, if needed
                       ;  Quits if error
  MOV  [ParseTest],2   ;Need to test a total of three times
  CALL ParseThings     ;Do all input strings
  CALL TestMemory      ;See if we're already installed in memory
  DEC  [ParseTest]     ;Test the second time
  CALL ParseThings     ;Do all input strings
  DEC  [ParseTest]     ;Parse string for real
  CALL ParseThings     ;Do all input strings
P90:
  RET

ParseThings:
  PUSH SI                         ;Save used registers
  MOV  SI,[EnvVarPointer]         ;[SI] = Our Environment Variable
  CMP  SI,-1                      ;Is there an Environment Variable to parse?
  JE  >P30                        ;If no, skip it
  OR   [ProgFlags2],DoEnvir       ;Mark as doing the Environment
  CMP  [ParseTest],0              ;Just doing a Test Run?
  JNE >P20                        ;If so, don't write the variable contents yet
  MOV  DX,SIDEnvironment          ;Write the first part of the
  CALL WriteZPause                ;  environment message to the screen
  CALL WriteEnvCon                ;Write the environment variable contents
  CALL WriteCrLfPause2            ;Move down
P20:                              ;Do the Environment Variable
  CALL ParseCmdLine               ;Parse the Environment (quits if Error)
P30:                              ;Do StdIn
  AND  [ProgFlags2],(NOT DoEnvir) ;Mark as doing Command Line
  OR   [ProgFlags2],DoStdIn       ;Parse the
  XOR  SI,SI                      ;  StdIn buffer
  CALL ParseCmdLine               ;  Quit if error
  AND  [ProgFlags2],(NOT DoStdIn) ;  is found
  MOV  SI,81h                     ;Assume "real" Command Line
  CMP  [CmdLineVarPointer],-1     ;Have a CMDLINE Environment variable?
  JE  >P50                        ;If not, just do regular command line
  MOV  SI,[CmdLineVarPointer]     ;If so, point at the variable
P50:                              ;Pointed at Command Line Tail
  CALL ParseCmdLine               ;Parse Command Line
  POP  SI                         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PARSE THE COMMAND LINE FOR SWITCHES
;Inputs:  [ParseTest]
;         [SI] = Option String to Parse
;Outputs:
;Changes: SI
;------------------------------------------------------------------------------
ParseCmdLine:
  PUSH AX             ;Save used registers
P10:                  ;Look for the next switch
  CALL IsSpaceOrEOX   ;Look for a valid character
  JZ  >P90            ;If EOL, we're done
  CMP  AL,'/'         ;Is it a slash?
  JE  >P20            ;If so, jump to handle it
  CMP  AL,'-'         ;Is it a dash?
  JE  >P20            ;If so, jump to handle it
  DEC  SI             ;If not, point back at the first character
  JMP >P30            ;Continue
P20:                  ;It's a slash
  CALL IsSpaceOrEOL   ;Look for a valid switch character
  JZ  >P70            ;If no character, there's an error
P30:                  ;Look for the switch
  CALL GetSwitch      ;See if it matches one of our switches
  JNZ  P10            ;If a match, look for the next switch
P70:                  ;Error - tell the user where it was
  CALL WriteCmdErr    ;Display the error for the user
  MOV  AL,ErLvlOption ;ErrorLevel = Bad Option on command line
  MOV  DX,NoMsg       ;Point at an empty message
  JMP  Exit           ;Print error message and quit
P90:                  ;We're done
  POP  AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE SWITCH CHARACTERS, AND DO WHATEVER IT IS THEY'RE ASKING
;Inputs:  [SI] = Command line pointer
;          ES  = TSR Data Area
;          DS  = Local Data Area (same as CS)
;Outputs: Lots of stuff!!!
;         [ParseError]
;         ZF = Set if Error
;            = Clear if OK
;Changes:
;------------------------------------------------------------------------------
GetSwitch:
  PUSH AX,BX,DI,BP         ;Save used registers
  MOV  BX,SIDSwitchList    ;Point at the list of switch code words
  CALL GetCode             ;See if its a match
  JNC >S10                 ;If so, jump to test it
  CALL GetNextChar         ;If not, it's a single character
  CALL Capitalize          ;Capitalize it
S10:                       ;We have a Switch to test!
  MOV  BX,SwitchTbl        ;Point at the Table of Offsets
S20:                       ;Loop to here for each table entry
  MOV  AH,[BX]             ;Get the switch from our table?
  OR   AH,AH               ;Is it the end of the table?
  JZ  >S70                 ;If so, there's an error
  CMP  AL,AH               ;If a valid entry, is it a match?
  JE  >S30                 ;If so, jump to handle it
  ADD  BX,3                ;If not, point at the next table entry
  JMP  S20                 ;And keep looking
S30:                       ;It's a match from the table
  MOV  DI,OFFSET ProgFlags ;[DI] = [ProgFlags]
  MOV  BP,OFFSET TSRFlags  ;[BP] = [TSRFlags]
  MOV  AH,[ParseTest]      ;Pass the "Testing" flag
  CMP  AH,1                ;Set the Flags for Testing
  CALL W [BX+1]            ;Do the Switch stuff
  JMP >S90                 ;And quit
S70:                       ;There's an error
  MOV  [ParseError],Yes    ;Mark the error flag
S90:                       ;We're done
  CMP  [ParseError],Yes    ;Set/Clear the error flag
  POP  BP,DI,BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Display Help (Syntax) Message
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchH:
  OR   B [DI],Help ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Display ErrorLevel Table
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchErrLvl:
  OR   B [DI+2],ErrLvl ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Display list of Command-line Aliases
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchA:
  OR   B [DI],Alias ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Display Host/PCI Status
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchHostStatus:
  OR   B [DI+2],HostStatus ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display Address Data Status
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchADStatus:
  OR   B [DI+2],ADStatus ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display Frame List Status
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchFLStatus:
  OR   B [DI+2],FLStatus ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display Queue Heads Status
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchQHStatus:
  OR   B [DI+2],QHStatus ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display New Device Notification Table
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchNDStatus:
  OR   B [DI+2],NDStatus ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Reset All Bad Devices
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchResetBad:
  OR   B [DI],ResetBads ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Download & Display the Report Descriptor for an HID
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchR:
  PUSH AX               ;Save used registers
  CALL GetColonNum      ;Get the Device Address
  JC  >R70              ;If none, error
  CMP  AX,(ADEntries-1) ;Is it too big?
  JA  >R70              ;If so, error
  CMP  AL,1             ;Is it Address 0 or 1 (New Device / Root Hub)?
  JBE >R70              ;If so, error
  MOV  [ReportAddr],AL  ;If OK, store it
  CALL GetColonNum      ;Get the Interface Number
  JC  >R70              ;If none, error
  OR   AH,AH            ;Too big?
  JNZ >R70              ;If so, error
  MOV  [ReportIntf],AL  ;If OK, store it
  JMP >R90              ;Done
R70:                    ;Error
  MOV  [ParseError],Yes ;Mark it as an error
R90:                    ;We're done
  POP  AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Enable Program Debug Strings
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchProgDebug:
  PUSH AX,BX            ;Save used registers
  XOR  BX,BX            ;Default = 0
  CALL TestColonNum     ;Is there a number following (Debug Delay Value)?
  JC  >G80              ;If not, we're done
  CALL GetColonNum      ;If so, get the Debug Delay Value
  CMP  AX,MaxDebugDelay ;Is it too big?
  JA  >G70              ;If so, error
  MOV  BX,AX            ;If OK, store it
  JMP >G80              ;Done
G70:                    ;Error
  MOV  [ParseError],Yes ;Mark it as an error
  JMP >G90              ;We're done
G80:                    ;It's OK
  CMP  [ParseTest],2    ;Is this the first test run?
  JB  >G90              ;If not, don't store it
  MOV  [DebugDelay],BX  ;Store the Delay Value
G90:                    ;We're done
  POP  BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Display Transfer Descriptor Status
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchTDStatus:
  PUSH AX                ;Save used registers
  CALL TestColonNum      ;Is there a number following (TD Index)?
  JC  >T80               ;If not, we're done
  CALL GetColonNum       ;If so, Get the TD Index to write
  CMP  AX,(TDEntries-1)  ;Is it too big?
  JA  >T70               ;If so, it's an error
  CMP  [ParseTest],2     ;Is this the first test run?
  JB  >T80               ;If not, don't store it
  MOV  [IndexToWrite],AX ;If it's OK, store it
  JMP >T80               ;We're done
T70:                     ;Error
  MOV  [ParseError],Yes  ;Mark it as an error
  JMP >T90               ;We're done
T80:                     ;It's OK
  OR   B [DI+2],TDStatus ;Set the OK flag
T90:                     ;We're done
  POP  AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Display Descriptors of Last Enumerated Device
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchDescriptor:
  PUSH AX               ;Save used registers
  MOV  [DescrAddr],-1   ;Assume No Address (Do Last Enumerated Device)
  CALL TestColonNum     ;Is there a number following (Device Address)?
  JC  >D90              ;If not, we're done
  CALL GetColonNum      ;Get the Device Address to write (Optional)
  CMP  AX,(ADEntries-1) ;Is it too big?
  JA  >D70              ;If so, error
  CMP  AL,1             ;Is it too small?
  JBE >D70              ;If so, error
  MOV  [DescrAddr],AL   ;If not, store the Address
  JMP >D90              ;Done
D70:                    ;Error
  MOV  [ParseError],Yes ;Mark error flag
D90:                    ;Done
  POP  AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Put Host into Debug Mode
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchDebug:
  JAE >G90                  ;If still doing test runs, quit
  MOV  AL,ES:[USBHostIndex] ;Do
  CALL DoHostDebug          ;  it
G90:                        ;Done
  RET

;------------------------------------------------------------------------------
;Single-Step the Host
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchSingleStep:
  JAE >S90                  ;If still doing test runs, quit
  MOV  AL,ES:[USBHostIndex] ;Do
  CALL DoHostSingleStep     ;  it
S90:                        ;Done
  RET

;------------------------------------------------------------------------------
;Disable/Stop Host/Device
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchD:                 ;Disable/Stop
  PUSH BX,DI               ;Save used registers
  MOV  BX,DoDeviceStop     ;Code if Single Device
  MOV  DI,DoHostStop       ;Code if Host
  CALL DoSwitchWithAddress ;Do it
  POP  DI,BX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Enable/Run Host/Device
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchE:                 ;Enable/Run
  PUSH BX,DI               ;Save used registers
  MOV  BX,DoDeviceRun      ;Code if Single Device
  MOV  DI,DoHostRun        ;Code if Host
  CALL DoSwitchWithAddress ;Do it
  POP  DI,BX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Suspend Host/Device
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchSuspend:
  PUSH BX,DI               ;Save used registers
  MOV  BX,DoDeviceSuspend  ;Code if Single Device
  MOV  DI,DoHostSuspend    ;Code if Host
  CALL DoSwitchWithAddress ;Do it
  POP  DI,BX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Resume Host/Device
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchResume:
  PUSH BX,DI               ;Save used registers
  MOV  BX,DoDeviceResume   ;Code if Single Device
  MOV  DI,DoHostResume     ;Code if Host
  CALL DoSwitchWithAddress ;Do it
  POP  DI,BX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Reset Host/Device
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchReset:
  PUSH BX,DI               ;Save used registers
  MOV  BX,DoDeviceReset    ;Code if Single Device
  MOV  DI,DoHostReset      ;Code if Host
  CALL DoSwitchWithAddress ;Do it
  POP  DI,BX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Power Off Device
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchPowerOff:
  PUSH BX,DI               ;Save used registers
  MOV  BX,DoDevicePwrOff   ;Code if Single Device
  MOV  DI,CmdLineErr       ;Code if Host
  CALL DoSwitchWithAddress ;Do it
  POP  DI,BX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Power On Device
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchPowerOn:
  PUSH BX,DI               ;Save used registers
  MOV  BX,DoDevicePwrOn    ;Code if Single Device
  MOV  DI,CmdLineErr       ;Code if Host
  CALL DoSwitchWithAddress ;Do it
  POP  DI,BX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Power Reset (Cycle) Device
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchPowerReset:
  PUSH BX,DI               ;Save used registers
  MOV  BX,DoDevicePwrReset ;Code if Single Device
  MOV  DI,CmdLineErr       ;Code if Host
  CALL DoSwitchWithAddress ;Do it
  POP  DI,BX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Uninstall Program from Memory
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchU:
  OR   B [DI],Uninstall ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Overwrite (Disable) Legacy Support of Keyboards/Mice
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchDisableLegacy:
  OR   B [DI],DisableLegacy ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Overwrite (Disable) Other Program controlling the Bus
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchDisableOther:
  OR   B [DI+1],DisableOther ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Install Program in Lower Memory, even if Upper Memory is available
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchL:
  PUSH AX                   ;Save used registers
  MOV  AL,UseLowMemory      ;Bit mask to use
  CALL DoSwitchWithYNPrgFwd ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Beep Speaker when "Bad" Devices are discovered
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchBeep:
  PUSH AX                   ;Save used registers
  MOV  AL,NoBeep            ;Bit mask to use
  CALL DoSwitchWithYNTsrRvs ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Get Pause Factor
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchP:
  PUSH AX                   ;Save used registers
  CALL GetColonNum          ;Get the Pause Factor (deciSeconds)
  JC  >P70                  ;If Error, Quit
  OR   AH,AH                ;Valid Number?
  JZ  >P80                  ;If so, jump to handle it
P70:                        ;Error
  MOV  [ParseError],Yes     ;Mark it as an error
  JMP >P90                  ;We're done
P80:                        ;It's OK
  CMP  [ParseTest],2        ;Just a Test Run?
  JB  >P90                  ;If so, don't save it yet
  MOV  ES:[PauseCounter],AL ;If for real, save the number
P90:                        ;Done
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Get PCI Search Index to Use
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchI:
  PUSH AX               ;Save used registers
  CALL GetColonNum      ;Get the PCI Search Index to use
  JC  >I70              ;If none there, it's an error
  CMP  [ParseTest],2    ;Is this the first test run?
  JB  >I90              ;If not, don't store anything
  MOV  [PCISearchIndex],AX ;If OK, store it
  JMP >I90              ;Done
I70:                    ;Error
  MOV  [ParseError],Yes ;Mark it as an error
I90:                    ;Done
  POP  AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Get I/O Address Space to Use
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchIOSpace:
  PUSH AX               ;Save used registers
  CALL GetColonNum      ;Get the I/O Base Address
  JC  >O70              ;If Error, Quit
  CMP  AX,MinIOBase     ;Valid Number?
  JB  >O70              ;If not, Error
  CMP  AX,MaxIOBase     ;Valid Number?
  JA  >O70              ;If not, Error
  TEST AX,001Fh         ;Divisible by 32?
  JZ  >O80              ;If so, it's OK
O70:                    ;Error
  MOV  [ParseError],Yes ;Mark it as an error
  JMP >O90              ;We're done
O80:                    ;It's OK
  CMP  [ParseTest],2    ;Just a Test Run?
  JB  >O90              ;If so, don't save it yet
  MOV  [UserIOSpace],AX ;If for real, save the number
O90:                    ;Done
  POP  AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Get IRQ Number to Use
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchIRQ:
  PUSH AX               ;Save used registers
  CALL GetColonNum      ;Get the I/O Base Address
  JC  >Q70              ;If Error, Quit
  CMP  AX,MinIRQ        ;Valid Number?
  JB  >Q70              ;If not, Error
  CMP  AX,MaxIRQ        ;Valid Number?
  JBE >Q80              ;If so, we're done
Q70:                    ;Error
  MOV  [ParseError],Yes ;Mark it as an error
  JMP >Q90              ;We're done
Q80:                    ;It's OK
  CMP  [ParseTest],2    ;Just a Test Run?
  JB  >Q90              ;If so, don't save it yet
  MOV  [UserIRQ],AL     ;If for real, save the number
Q90:                    ;Done
  POP  AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Change Host Frame Timing
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchTiming:
  PUSH AX,BX,CX,DI                   ;Save used registers
  CALL GetColonNum                   ;Get the Timing Value to use
  JC  >T70                           ;If none there, it's an error
  CMP  AX,SOFModifyBase              ;Is it too small?
  JB  >T70                           ;If so, error
  CMP  AX,(SOFModifyBase+127)        ;Is it too big?
  JA  >T70                           ;If so, error
  CMP  [ParseTest],1                 ;Just a test run?
  JAE >T90                           ;If so, we're done
  MOV  [SOFModifyStart],AX           ;Save the value in case we are initializing
  TEST [ProgFlags],InMemory          ;Already installed?
  JZ  >T90                           ;If not, we're done
  MOV  DI,Int14Request4              ;If so, point at Request Structure
  MOV  BL,ES:[USBHostIndex]          ;Set
  MOV  [DI].I14RHostIndex,BL         ;  Host Index
  MOV  W [DI].I14RCallBackAddr[2],CS          ;Store Registration
  MOV  W [DI].I14RCallBackAddr[0],NullFarCall ;  Call Back Address
  MOV  [DI].I14RRequestType,I14RRTRegTmgOwner ;Register as Timing Owner
  CALL DoInt14CallCXDI               ;Do it
  PUSH ES:[FirstInstanceSeg]         ;Restore correct
  POP  W [DI].I14RCallBackAddr[2]    ;  Call Back segment
  JC  >T70                           ;If Error, Quit
  MOV  [DI].I14RRequestHandle,CX     ;Store Handle Number
  MOV  W [DI].I14RCallBackAddr[0],-1 ;Do nothing when done
  MOV  [DI].I14RRequestType,I14RRTChangeTiming ;Request = Change Timing
  MOV  W [DI].I14RFrameTiming,AX     ;Timing value to set it to
  CALL DoInt14CallDI                 ;Set it
  MOV  [DI].I14RRequestType,I14RRTUnRegTmgOwner ;UnRegister as Timing Owner
  CALL DoInt14CallDI                 ;Do it
  JNC >T90                           ;If No Error, We're done
T70:                                 ;Error
  MOV  [ParseError],Yes              ;Mark it as an error
T90:                                 ;Done
  POP  DI,CX,BX,AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Set Configuration Value for Device
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;NOTE: This does not wait around to see if the Device configures correctly
;        or not.  It simply issues the Request and terminates.  This should
;        always work, since the TSR keeps track of the number of possible
;        configurations and returns an error if we try to set an illegal
;        value.
;------------------------------------------------------------------------------
DoSwitchSetConfig:
  PUSH AX,DI                     ;Save used registers
  JBE >G20                       ;If not the first test run, jump to handle it
G10:                             ;Just the test run
  CALL GetColonNum               ;Get the Device Address
  JC  >G70                       ;If none there, it's an error
  CMP  AX,(ADEntries-1)          ;Valid address?
  JA  >G70                       ;If not, error
  CMP  AL,1                      ;Valid address?
  JBE >G70                       ;If not, error
  CALL GetColonNum               ;Get the Configuration Value
  JC  >G70                       ;If none there, it's an error
  OR   AH,AH                     ;Is it too big?
  JNZ >G70                       ;If so, error
  JMP >G90                       ;If OK, we're done
G20:                             ;Not the first test run
  TEST [ProgFlags],InMemory      ;Already installed as a TSR?
  JZ  >G70                       ;If not, error
  CALL GetColonNum               ;Get the Device Address
  MOV  DI,Int14Request2          ;[DI] = Int 14 Request to use
  MOV  [DI].I14RDeviceAddress,AL ;Store Device Address
  MOV  AL,ES:[USBHostIndex]      ;Store
  MOV  [DI].I14RHostIndex,AL     ;  Host Index
  MOV  AX,ES:[FirstInstanceSeg]                ;Store
  MOV  W [DI].I14RCallBackAddr[2],AX           ;  Call-Back
  MOV  W [DI].I14RCallBackAddr[0],NullFarCall  ;  Address
  MOV  [DI].I14RRequestType,I14RRTGetDvcStatus ;Request = Get Device Status
  CALL DoInt14CallDI             ;Do it
  JC  >G70                       ;If error, quit
  CALL GetColonNum               ;Get the Configuration Value
  CMP  [ParseTest],0             ;Is this the real run?
  JA  >G90                       ;If not, we're done
  MOV  [DI].I14RConfigValue,AL   ;Store the Configuration Value
  MOV  [DI].I14RRequestType,I14RRTSetNewConfig ;Request = Set Configuration
  CALL DoInt14CallDI             ;Do it
  JNC >G90                       ;If OK, quuit
G70:                             ;Error
  MOV  [ParseError],Yes          ;Mark it as an error
G90:                             ;Done
  POP  DI,AX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Enable/Disable Remote Wakeup Mode for Device
;Enable/Disable Test Mode for Device
;Inputs:   DS    = Local Data Area
;          ES    = TSR Data Area
;         [DI]   = [ProgFlags]
;         [DI+1] = [ProgFlags2]
;         [DI+2] = [StatusFlags]
;         [SI]   = Command Line Pointer
;         [BP]   = [TSRFlags]
;          AH    = [ParseTest], Flags set to match
;------------------------------------------------------------------------------
DoSwitchRmtWakeup:
  PUSH CX                        ;Save used registers
  MOV  CH,0                      ;Mark as Remote Wakeup
  JMP >W00                       ;Do it
DoSwitchTestMode:
  PUSH CX                        ;Save used registers
  MOV  CH,1                      ;Mark as Test Mode
;  JMP >W00                       ;Do it
W00:
  PUSH AX,BX,DI                  ;Save used registers
  JBE >W20                       ;If not the first test run, jump to handle it
W10:                             ;Just the test run
  CALL GetColonNum               ;Get the Device Address
  JC  >W70                       ;If none there, it's an error
  CMP  AX,(ADEntries-1)          ;Valid address?
  JA  >W70                       ;If not, error
  CMP  AL,1                      ;Valid address?
  JBE >W70                       ;If not, error
  CALL SkipColonEquals           ;Skip over the colon or equals, if there
  MOV  BX,SIDSwitchListYN        ;Point at the list of code words
  CALL GetCode                   ;See if its a match
  JC  >W70                       ;If not, error
  JMP >W90                       ;If OK, we're done
W20:                             ;Not the first test run
  TEST [ProgFlags],InMemory      ;Already installed as a TSR?
  JZ  >W70                       ;If not, error
  CALL GetColonNum               ;Get the Device Address
  CALL TestAddrIsValid           ;Is it a valid Device Address?
  JC  >W70                       ;If not, error
  MOV  DI,Int14Request2          ;[DI] = Int 14 Request to use
  MOV  [DI].I14RDeviceAddress,AL ;Store Device Address
  CALL SkipColonEquals           ;Skip over the colon or equals, if there
  MOV  BX,SIDSwitchListYN        ;Point at the list of code words
  CALL GetCode                   ;See if its a match
  CMP  [ParseTest],0             ;Is this the real run?
  JA  >W90                       ;If not, we're done
  MOV  CL,AL                     ;CL = 'Y' or 'N' (Set or Unset)
  MOV  AL,ES:[USBHostIndex]      ;Store
  MOV  [DI].I14RHostIndex,AL     ;  Host Index
  MOV  AX,ES:[FirstInstanceSeg]               ;Store
  MOV  W [DI].I14RCallBackAddr[2],AX          ;  Call-Back
  MOV  W [DI].I14RCallBackAddr[0],NullFarCall ;  Address
W30:                             ;Issue Request to change Feature
  MOV  BX,(SRRQSetFeature SHL 8)+SRRTOut+SRRTTypeStandard+SRRTRecipDevice
  CMP  CL,'Y'                    ;Assume it is Set Feature: is it?
  JE  >W40                       ;If so, continue
  MOV  BH,SRRQClearFeature       ;If not, it's Clear Feature
W40:                             ;BX = Request Type & Request
  MOV  W [DI].I14RSetupReqData.SRRequestType,BX ;Store the Req Type & Req
  MOV  BX,DvcFeatureRemoteWakeup ;Assume Remote Wakeup
  OR   CH,CH                     ;Is it Remote Wakeup?
  JZ  >W50                       ;If so, continue
  MOV  BL,DvcFeatureTestMode     ;If not, it's Test Mode
W50:                             ;BX = Feature Select Value
  MOV  W [DI].I14RSetupReqData.SRValue,BX   ;Store the Select Value
  MOV  D [DI].I14RSetupReqData.SRIndex,0    ;Value & Index = 0
  MOV  [DI].I14RRequestType,I14RRTDoControl ;Request Type = Control
  MOV  [DI].I14REndPoint,0       ;End Point = 0
  CALL DoInt14CallDI             ;Do it
  JNC >W90                       ;If OK, quuit
W70:                             ;Error
  MOV  [ParseError],Yes          ;Mark it as an error
W90:                             ;Done
  POP  DI,BX,AX                  ;Restore used registers
  POP  CX                        ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT ROUTINES FOR PROCESSING SWITCHES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET A YES/NO OPTION FOR A COMMAND-LINE SWITCH
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK
;              ZF = Set if No
;                   AL = 0 (No)
;                 = Clear if Yes
;                   AL = -1 (Yes)
;            = Set if Error
;              AL = 0
;Changes:
;------------------------------------------------------------------------------
GetYesNo4Switch:
  PUSH BX,CX              ;Save used registers
  MOV  CH,AH              ;Save original AH
  CALL SkipColonEquals    ;Skip Colon/Equals (if there)
  MOV  BX,SIDSwitchListYN ;Point at the list of code words
  CALL GetCode            ;See if its a match
  JC  >Y70                ;If not, error
Y20:                      ;Got a character
  CMP  AL,'Y'             ;Is it Yes?
  JE  >Y40                ;If so, handle it
  CMP  AL,'N'             ;Is it No?
  JNE >Y70                ;If not, error
Y30:                      ;No
  XOR  AL,AL              ;If so, make it No
  JMP >Y80                ;Done
Y40:                      ;Yes
  MOV  AL,Yes             ;Mark it as a Yes
  JMP >Y80                ;Done
Y70:                      ;Error
  XOR  AL,AL              ;Set AL to 0
  STC                     ;Set Error Flag
  JMP >Y90                ;Done
Y80:                      ;OK
  OR   AL,AL              ;Set Zero Flag for Return
  CLC                     ;Set OK Flag
Y90:                      ;Done
  MOV  AH,CH              ;Restore original AH
  POP  CX,BX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A SWITCH WITH A YES/NO OPTION
;Inputs:  [SI] = Command Line Pointer
;          ES  = TSR Data Area
;          DS  = Local Data Area
;          AL  = Bit mask to Set/Unset
;          AH  = [ParseTest]
;Outputs: Sets/Unsets bit in ES:[TSRFlags] or DS:[ProgFlags] as appropriate
;Changes:
;NOTES: If we are changing the resident (TSR) part of the program
;         (ES:[TSRFlags]), we do not actually change anything unless
;         [ParseTest] is 0.  If we are changing the transient
;         part of the program (DS:[ProgFlags]), we change it no matter
;         what [ParseTest] is set to.
;       Forward and Reverse refer to Forward and Reverse Logic.  With
;         Forward Logic, if the user says Yes, we set the particular bit
;         to 1.  With Reverse Logic, when the user says Yes, we set
;         to bit to 0.
;------------------------------------------------------------------------------
DoSwitchWithYNTsrRvs:
  PUSH CX                  ;Save used registers
  MOV  CL,-1               ;Mark as Reverse Logic
  JMP >Y000                ;Jump to do ES:[TSRFlags]
;DoSwitchWithYNTsrFwd:
;  PUSH CX                  ;Save used registers
;  XOR  CL,CL               ;Mark as Forward Logic
;  JMP >Y000                ;Jump to do ES:[TSRFlags]
;DoSwitchWithYNPrgRvs:
;  PUSH CX                  ;Save used registers
;  MOV  CL,-1               ;Mark as Reverse Logic
;  JMP >Y001                ;Jump to do DS:[ProgFlags]
DoSwitchWithYNPrgFwd:
  PUSH CX                  ;Save used registers
  XOR  CL,CL               ;Mark as Forward Logic
  JMP >Y001                ;Jump to do DS:[ProgFlags]
Y000:                      ;ES:[TSRFlags]
  PUSH BX                  ;Save used registers
  MOV  BX,OFFSET TSRFlags  ;[BX] = [TSRFlags]
  JMP >Y00                 ;Do it
Y001:                      ;DS:[ProgFlags]
  PUSH BX                  ;Save used registers
  MOV  BX,OFFSET ProgFlags ;[BX] = [ProgFlags]
;  JMP >Y00                 ;Do it
Y00:
  PUSH AX                  ;Save used registers
  MOV  CH,AL               ;Save Bit Mask to set
  CALL GetYesNo4Switch     ;Get the Yes/No parameter (AL)
  JC  >Y70                 ;If error, handle it
  OR   AL,AL               ;Is it Yes?
  JNZ >Y20                 ;If so, jump to handle it
Y10:                       ;No
  OR   CL,CL               ;Is it Forward Logic?
  JZ  >Y40                 ;If so, jump to handle it
  JMP >Y50                 ;If not, jump to handle Reverse Logic
Y20:                       ;Yes
  OR   CL,CL               ;Is it Forward Logic?
  JZ  >Y50                 ;If so, jump to handle it
Y40:                       ;Unset the Bit
  NOT  CH                  ;Need to Unset
  CMP  BX,LastTSRByte      ;Is it for [ProgFlags]?
  JAE >Y45                 ;If so, jump to handle it
Y42:                       ;Unset ES:[TSRFlags]
  OR   AH,AH               ;Just a Test Run?
  JNZ >Y90                 ;If so, quit
  AND  ES:[BX],CH          ;Unset the appropriate flag
  JMP >Y90                 ;Done
Y45:                       ;Unset DS:[ProgFlags]
  AND  [BX],CH             ;Unset the appropriate flag
  JMP >Y90                 ;Done
Y50:                       ;Set the Bit
  CMP  BX,LastTSRByte      ;Is it for [ProgFlags]?
  JAE >Y55                 ;If so, jump to handle it
Y52:                       ;Set ES:[TSRFlags]
  OR   AH,AH               ;Just a Test Run?
  JNZ >Y90                 ;If so, quit
  OR   ES:[BX],CH          ;Set the appropriate flag
  JMP >Y90                 ;Done
Y55:                       ;Set DS:[ProgFlags]
  OR   [BX],CH             ;Set the appropriate flag
  JMP >Y90                 ;Done
Y70:                       ;Error
  MOV  [ParseError],Yes    ;Mark as an Error
Y90:                       ;Done
  POP  AX                  ;Restore used registers
  POP  BX                  ;Restore used registers
  POP  CX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;VALIDATE THAT AN ADDRESS ON THE HOST IS FOR A REAL OR BAD DEVICE
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         AL = Address to Test
;Outputs: CF = Clear if Address is Valid (or Bad)
;            = Set if Address is Invalid (or Good)
;Changes:
;------------------------------------------------------------------------------
TestAddrIsValid:
  PUSH AX               ;Save used registers
  XOR  AH,AH            ;Mark as testing for Valid Address
  JMP >V00              ;Do it
TestAddrIsBad:
  PUSH AX               ;Save used registers
  MOV  AH,1             ;Mark as testing for Bad Address
  JMP >V00              ;Do it
V00:
  PUSH CX,DI            ;Save used registers
  CMP  AL,1             ;Legitimate address?
  JBE >V70              ;If not, error
  CMP  AL,(ADEntries-1) ;Legitimate Address?
  JA  >V70              ;If not, error
  MOV  CL,AL            ;Get the
  CALL ADIndex2Offset   ;  Address Table Pointer (DI)
  TEST ES:[DI].ADFlags,ADFlagInUse ;Valid Address?
  JZ  >V70              ;If not, error
  OR   AH,AH            ;Are we testing for a Bad Device?
  JZ  >V80              ;If not, we're done
  TEST ES:[DI].ADFlags2,ADFlagBadDvc ;If so, is it a Bad Device?
  JNZ >V80              ;If so, we're done
V70:                    ;Error
  STC                   ;Set return flag
  JMP >V90              ;Done
V80:                    ;OK
  CLC                   ;Set return flag
V90:                    ;Done
  POP  DI,CX            ;Restore used registers
  POP  AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS A COMMAND LINE SWITCH THAT HAS A DEVICE ADDRESS AFTER IT
;Inputs:  [SI] = Command Line Pointer
;         [BX] = Code to Call if it's for a Single Device
;         [DI] = Code to Call if it's for a Host (Address 0-1, >=127)
;         [ParseTest]
;         [ParseError] = No
;         ES = TSR Data Area
;Outputs: ZF = Clear if OK ([ParseError] = No)
;              AX = Address that we got
;            = Set if Error ([ParseError] = Yes)
;              AX = Undefined
;Changes: SI
;------------------------------------------------------------------------------
DoSwitchWithAddress:
  CMP  [ParseTest],2        ;Is this the first Test Run?
  JE  >W05                  ;If so, we haven't checked for InMemory yet
  TEST [ProgFlags],InMemory ;If not, are we installed in memory yet?
  JZ  >W70                  ;If not, error
W05:                        ;Get the Address
  CALL SkipColonEquals      ;Skip over the Colon or Equals, if there
  PUSH BX                   ;Save Pointer
  MOV  BX,SIDSwitchList2    ;Point at the list of code words
  CALL GetCode              ;See if its a match
  POP  BX                   ;Restore Pointer
  JNC >W10                  ;If a match, jump to handle it
  CALL GetColonNum          ;Get the Address from the Command Line
  JC  >W70                  ;If no Address, Error
W10:                        ;Have an Address
  OR   AH,AH                ;Valid Number?
  JNZ >W70                  ;If not, error
  CMP  [ParseTest],2        ;Is this the first test run?
  JE  >W90                  ;If so, we're done
  CMP  AX,(ADEntries-1)     ;Is it for all Hosts?
  JA  >W35                  ;If so, handle it
  CMP  AX,1                 ;Address 0 or 1 (just this Host)?
  JBE >W30                  ;If so, handle it
W20:                        ;For a single Device
  CALL TestAddrIsValid      ;Is it a Valid Device Address?
  JC  >W70                  ;If not, error
  CMP  [ParseTest],0        ;Just a test Run?
  JA  >W90                  ;If so, don't do it for real yet
  CALL BX                   ;If not, run the appropriate Code (Address in AL)
  JMP >W90                  ;Done
W30:                        ;It's a Call for this Host
  MOV  AL,ES:[USBHostIndex] ;Store our Host Index
  JMP >W40                  ;Do it
W35:                        ;It's a Call for All hosts
  MOV  AL,AllHostsIndex     ;Mark it as being for all Hosts
W40:                        ;Call for one or more Hosts
  XOR  AH,AH                ;Make sure high byte is 0
  CMP  [ParseTest],0        ;Just a test Run?
  JA  >W90                  ;If so, don't do it for real yet
  CALL DI                   ;If not, run the appropriate Code (Address in AL)
  JMP >W90                  ;Done
W70:                        ;Error
  MOV  [ParseError],Yes     ;Set Error Code
W90:                        ;Done
  CMP  [ParseError],Yes     ;Set Return Flag
  RET

;------------------------------------------------------------------------------
;REPLACE THE CARRIAGE RETURN AT THE END OF THE CMD LINE TAIL WITH A 0
;Inputs:  CS = DS = PSP Segment
;Outputs:
;Changes: Last Byte of Command Tail
;------------------------------------------------------------------------------
FixCmdLineCR:
  PUSH AX,CX,DI,ES   ;Save used registers
  MOV  AL,CR         ;Look for a CR
  MOV  CX,7Fh        ;Maximize Byte Counter
  MOV  ES,DS         ;Point ES:[DI]
  MOV  DI,81h        ;  at the Command Line Tail
  REPNE SCASB        ;Look for the CR
  MOV  B ES:[DI-1],0 ;Replace the CR with a 0
  POP  ES,DI,CX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT CHARACTER FROM THE ENVIRONMENT OR COMMAND LINE
;Inputs:  [SI] = Pointer (Command Line or Environment)
;Outputs: AL = The next character
;         ZF = Set if End-Of-Line (Character = ASCII 0)
;            = Clear if "real" character
;Changes: SI
;------------------------------------------------------------------------------
GetNextChar:
  PUSH DS                     ;Save used registers
  TEST [ProgFlags2],DoStdIn   ;Are we doing StdIn?
  JNZ >N20                    ;If so, jumpto handleit
  TEST [ProgFlags2],DoEnvir   ;Are we doing the Program Environment Variable?
  JNZ >N10                    ;If so, handle it
  CMP  [CmdLineVarPointer],-1 ;Need to use the CMDLINE Environment variable?
  JE  >N90                    ;If not, just do the "real" command line
N10:                          ;Get next character from the Environment
  MOV  DS,[PSPEnvirSeg]       ;Point at the Environment Segment
  JMP >N90                    ;Continue
N20:                          ;StdIn
  MOV  DS,[StdInSegment]      ;Point DS at the correct Segment
N90:                          ;DS:[SI] points at the next character
  LODSB                       ;Get the character from the "real" command line
  OR   AL,AL                  ;Set ZF if EOL
  POP  DS                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER SPACES TO FIND THE NEXT LEGITIMATE CHARACTER, TESTING FOR EOL
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: ZF = Set if EOL
;               AL  = Unchanged
;              [SI] = End-of-Line Character
;            = Clear if not EOL
;               AL  = First non-space character
;              [SI] = Character AFTER the next non-space character
;Changes:
;------------------------------------------------------------------------------
IsSpaceOrEOX:
  CALL IsSpaceOrEOL ;Skip over the spaces
  JZ  >X90          ;If end-of-line, we're done
  CALL GetNextChar  ;If not, get the next character
  OR   AL,AL        ;Set return flag
X90:                ;Done
  RET

;------------------------------------------------------------------------------
;SKIP OVER SPACES TO FIND LEGITIMATE CHARACTERS, AND TEST FOR EOL
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: ZF = Set if EOL
;            = Clear if legitimate character
;              [SI] = The Next non-Space Character
;Changes:
;------------------------------------------------------------------------------
IsSpaceOrEOL:
  PUSH AX          ;Save used registers
L10:               ;Loop to here to skip over spaces
  CALL GetNextChar ;Get the next character
  CMP  AL,' '      ;Is it a space?
  JE   L10         ;If so, get the next character
  CMP  AL,Tab      ;Is it a Tab?
  JE   L10         ;If so, get the next character
  DEC  SI          ;If not, point back at the character
  OR   AL,AL       ;Set EOL flag
  POP  AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER A COLON OR EQUALS, IF THERE, AND GET THE NUMBER AFTER IT
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK (Number Found)
;                AX  = Number
;               [SI] = First Character after the Number
;            = Set if No Number Found
;                AX  = Undefined
;               [SI] = First Character where the Number should have been
;Changes:
;NOTES: TestColonNum is used when the number is optional, and we just need
;         to test and see if a number is there or not (it preserves both
;         AX and SI, even if there is a number).  A successful TestColonNum
;         will usually be followed immediately by a GetColonNum.
;       Get ColonNum is used when a number is required (not Optional), so
;         returns [SI] = where we expected the number to be.
;------------------------------------------------------------------------------
TestColonNum:
  PUSH AX,SI       ;Save used registers
  CALL GetColonNum ;Skip the Colon/Equals, Get the Number (returns CF,AX)
  POP  SI,AX       ;Restore used registers
  RET

GetColonNum:
  CALL SkipColonEquals ;Skip over the Colon or Equals, if there
  CALL GetNumber       ;Get the Number (returns CF)
  RET

;------------------------------------------------------------------------------
;SKIP OVER A COLON OR EQUALS, IF THERE
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if Colon or Equals was found (and skipped)
;              [SI] = First non-Space Character after the Colon/Equals
;            = Set if No Colon or Equals was found
;              [SI] = First non-Space Character after where we were looking
;Changes:
;------------------------------------------------------------------------------
SkipColonEquals:
  PUSH AX           ;Save used registers
  CALL IsSpaceOrEOX ;Skip over the Spaces
  JZ  >Q75          ;If End-of-Line, nothing to get
  CMP  AL,':'       ;Is it a Colon?
  JE  >Q80          ;If so, we're done
  CMP  AL,'='       ;Is it an equals?
  JE  >Q80          ;If so, we're done
Q70:                ;No Colon/Equals Found
  DEC  SI           ;Point back at the character
Q75:                ;[SI] correct
  STC               ;Set return flag
  JMP >Q90          ;Done
Q80:                ;Colon/Equals Found
  CALL IsSpaceOrEOL ;Go to the next character
  CLC               ;Set return flag
Q90:                ;Done
  POP  AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A CODE WORD FROM THE COMMAND LINE TO A BYTE FROM THE LOOKUP TABLE
;Inputs:  [SI] = Command Line Pointer
;         DS:[BX] = List to Test (may be SID in Overlay segment)
;Outputs: CF = Clear if a match was found
;              AL = Entry from Table
;              [SI] = Next character after the Code Match
;         CF = Set if no match found (error)
;              AL = Unchanged
;              SI = Unchanged
;Changes: SI if valid match found
;------------------------------------------------------------------------------
GetCode:
  PUSH BX,DX,ES      ;Save used registers
  PUSH DS            ;Save DS for a second
  MOV  DX,BX         ;DS:[DX] = Table Pointer
  CALL TestFSSegment ;Convert to Overlay pointer, if appropriate
  MOV  ES,DS         ;ES:[BX] =
  MOV  BX,DX         ;  Table Pointer
  POP  DS            ;DS = Original (local) DS
  MOV  DX,AX         ;Save AX in case there's no match
C10:                 ;Loop to there for each list of words
  CMP  B ES:[BX],0   ;Are we at the end of our table?
  JE  >C80           ;If so, we couldn't find a match
  XOR  AH,AH         ;Assume it's a match
  PUSH SI            ;Save our command line pointer for a second
C20:                 ;Loop to here for each character in a word
  CALL GetNextChar   ;Get the next character
  CALL Capitalize    ;Capitalize it
  CALL CmpALBXNoCase ;Is it a match?
  JZ  >C30           ;If so, handle it
  INC  AH            ;If not, mark us as no match
C30:                 ;The character is tested
  INC  BX            ;Point at the next character in our test word
  CMP  B ES:[BX],0   ;Are we at the end of the word?
  JNE  C20           ;If not, keep going until we're done
  INC  BX            ;Point at the next word or code list
  OR   AH,AH         ;Was it a match?
  JZ  >C50           ;If so, jump to handle it
  POP  SI            ;If not, restore our command line pointer
  CMP  B ES:[BX],0   ;Is this the end of our word list?
  JNE  C10           ;If not, just test the next word
  INC  BX,2          ;If so, skip over the codes
  JMP  C10           ;Keep going until we're done with our list
C50:                 ;We've found a match!
  POP  AX            ;Lose our original command line pointer
  DEC  BX            ;Point back at the end-of-word marker
C60:                 ;Loop to here to find the end-of-list
  MOV  AX,ES:[BX]    ;Get the next two characters in our list
  INC  BX            ;Point at the next character for next time
  OR   AX,AX         ;Is this the start of our code list?
  JNE  C60           ;If not, keep looking
  INC  BX            ;If so, point at the word we're loking for
  MOV  DL,ES:[BX]    ;Get the word from the table
  CLC                ;Mark our OK flag
  JMP >C90           ;And we're done
C80:                 ;No match found
  STC                ;Mark us as no match
C90:                 ;We're done
  MOV  AX,DX         ;Set AX to the correct value
  POP  ES,DX,BX      ;Restore used registers
  RET

CmpALBXNoCase:
  PUSH AX         ;Save used registers
  CALL Capitalize ;Capitalize AL
  MOV  AH,AL      ;Store it in AH
  MOV  AL,ES:[BX] ;Get ES:[BX]
  CALL Capitalize ;Capitalize it
  CMP  AL,AH      ;Compare AL & [BX]
  POP  AX         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO GET A NUMBER FROM A STRING (HEX OR DECIMAL)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET A NUMBER FROM A STRING (CAN BE DECIMAL OR HEX)
;Inputs:  [SI] = String Pointer
;Outputs: CF = Clear if we got a valid number
;               AX  = Number
;              [SI] = Character after the Number
;            = Set if Error (no number found)
;              AX = Unchanged
;              [SI] = First non-Space, non-Number Character
;Changes:
;NOTES: A Hex String must start with '0x' or '$', and/or end in 'H'!
;------------------------------------------------------------------------------
GetNumber:
  PUSH BX,DX         ;Save used registers
  MOV  BX,AX         ;Save original AX
  CALL IsSpaceOrEOL  ;Skip past spaces
  MOV  DX,SI         ;Save pointer
  JZ  >N70           ;If End-of-Line, Error
  CALL TestForHex    ;Is it a Hex Number?
  JC  >N20           ;If not, try a decimal
  CALL TestHexPrefix ;Skip over the Hex Prefix, if there
  CALL GetHex        ;If so, get it
  JNC >N80           ;If OK, we're done
  JMP >N70           ;If not, Error
N20:                 ;Not Hex
  CALL GetDecimal    ;Try a Decimal
  JNC >N80           ;If OK, we're done
N70:                 ;Error
  MOV  AX,BX         ;Restore original AX
  MOV  SI,DX         ;Restore Pointer
  STC                ;Set Error Flag
  JMP >N90           ;Done
N80:                 ;OK
  CLC                ;Set OK Flag
N90:                 ;Done
  POP  DX,BX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII STRING TO SEE IF IT IS A HEX STRING (ENDS IN H)
;Inputs:  [SI] = String to test
;Outputs: CF = Clear if it is a Hex String
;            = Set if Error (not a Hex String)
;Changes:
;NOTES: A valid Hex String will contain numerals 0-9, A-F, and Underscores,
;         and will end in an H.  It cannot contain spaces.
;------------------------------------------------------------------------------
TestForHex:
  PUSH AX,SI         ;Save used registers
  CALL TestHexPrefix ;Test for a Hex Prefix (changes SI)
  JNC >H80           ;If so, it's Hex
  CALL GetNextChar   ;Get the
  DEC  SI            ;  first character
  CALL IsHexNumber   ;A valid Hex Number?
  JC  >H70           ;If not, Error
H40:                 ;Loop to here for each character
  CALL GetNextChar   ;Get the next character
  CALL IsHexNumber   ;A valid Hex Number?
  JNC  H40           ;If so, keep looking
  CMP  AL,'_'        ;An Underscore?
  JE   H40           ;If so, keep looking
  CALL IsHexEnd      ;End of the Hex Number?
  JZ  >H80           ;If so, we're done
H70:                 ;Not Hex
  STC                ;Set error Flag
  JMP >H90           ;Done
H80:                 ;Is Hex
  CLC                ;Set OK Flag
H90:                 ;Done
  POP  SI,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST FOR A 0x (C-STYLE) OR $ (FASM-STYLE) HEX PREFIX
;Inputs:  [SI] = String to test
;Outputs: CF = Set if not a Hex Prefix
;              SI unchanged
;            = Clear if not a Hex Prefix
;              [SI] = Character after the Prefix
;Changes:
;------------------------------------------------------------------------------
TestHexPrefix:
  PUSH AX,BX       ;Save used registers
  MOV  BX,SI       ;Save original Pointer
  CALL GetNextChar ;Get the next character
  CMP  AL,'$'      ;Is it a $?
  JE  >X30         ;If so, it might be a Prefix
  CMP  AL,'0'      ;Is it a 0?
  JNE >X70         ;If not, it can't be a Prefix
X20:               ;Loop to here to skip over all zeroes
  CALL GetNextChar ;Get the next character
  CMP  AL,'0'      ;Is it another 0?
  JE   X20         ;If so, keep skipping the zeroes
  CALL Capitalize  ;If not, capitalize it
  CMP  AL,'X'      ;Is it an X?
  JNE >X70         ;If not, it's not a 0x Prefix
X30:               ;Appears to be a Valid Prefix
  CALL GetNextChar ;Get the next character
  CALL IsHexNumber ;Is it a Hex Number?
  JNC >X80         ;If so, it's a HEx Prefix
X70:               ;Not a Hex Prefix
  MOV  SI,BX       ;Restore original pointer
  STC              ;Set return flag
  JMP >X90         ;Done
X80:               ;Is a Hex Prefix
  DEC  SI          ;Point back at the first hex number
  CLC              ;Set return flag
X90:               ;Done
  POP  BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT SERIES OF HEX CHARACTERS, AND CONVERT THEM TO A NUMBER
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK
;              AX = Character string converted to a number, ?? if not
;            = Set if Error
;              AX = Unchanged
;Changes:
;NOTES: The string can either have an H at the end or not, and this code
;         will work.
;------------------------------------------------------------------------------
GetHex:
  PUSH BX,CX,DX    ;Save used registers
  MOV  DX,AX       ;Save original AX
  XOR  BX,BX       ;Start with zero
  MOV  CX,4        ;CL = bits to shift by, CH = Character Counter
  XOR  AH,AH       ;Set High byte to 0
D10:               ;Loop to here for each character
  CALL GetNextChar ;Get the next character
  CALL IsHexNumber ;A valid Hex Number?
  JNC >D20         ;If so, continue
  CMP  AL,'_'      ;If not, is it an Underscore?
  JE  >D45         ;If so, keep looking
  JMP >D50         ;If not, we're done
D20:               ;Valid Hex Number
  INC  CH          ;Increment the character counter
  SHL  BX,CL       ;Make room for the New Nibble
  JNC >D40         ;If we're not too big yet, keep going
  DEC  SI          ;If too big, Point back at bad character
  JMP >D70         ;Error
D40:               ;OK to add in new Nibble
  ADD  BX,AX       ;Add in the new Nibble
D45:               ;Done with this character
  JMP  D10         ;Jump to get next character
D50:               ;Done getting string
  DEC  SI          ;Point back at the bad character
  OR   CH,CH       ;Any valid characters at all?
  JZ  >D70         ;If not, error
  CALL GetNextChar ;Is the next character
  CALL IsHexEnd    ;  an H?
  JZ  >D80         ;If so, we're done
  DEC  SI          ;If not, point back at the non-H
  JMP >D80         ;Done
D70:               ;There was an error
  MOV  AX,DX       ;Restore original AX
  STC              ;Mark the error flag
  JMP >D90         ;And quit
D80:               ;We have a good number
  MOV  AX,BX       ;Put the value where it belongs
  CLC              ;Mark the OK flag
D90:               ;We're done
  POP  DX,CX,BX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT SERIES OF NUMERIC CHARACTERS, AND CONVERT THEM TO A NUMBER
;Inputs:  [SI] = Command Line Pointer
;Outputs: AX = decimal character string converted to a number, ?? if not
;         CF = Clear if AX is OK
;            = Set if no decimal found
;Changes: SI points at character after the number
;------------------------------------------------------------------------------
GetDecimal:
  PUSH BX,CX,DX     ;Save used registers
  XOR  AX,AX        ;Start with zero
  XOR  BX,BX        ;  "    "    "   - accumulator
  MOV  CX,10        ;CX = multiplier & digit limit comparer
  CALL IsSpaceOrEOX ;Skip over the spaces
  JZ  >D70          ;If EOL, Error
  SUB  AL,'0'       ;If not, convert it to a number
  CMP  AL,9         ;Is it really a number?
  JA  >D70          ;If not, there's an error
  DEC  SI           ;If so, step back to the number
D10:                ;Loop to here for each character
  CALL GetNextChar  ;Get the next character
  SUB  AL,'0'       ;Change it to 0-9 range
  XOR  AH,AH        ;Extend byte to word
  CMP  AX,CX        ;Is it a digit?
  JAE >D80          ;If not, we're done
  CMP  BX,6553      ;Is our number getting too big?
  JB  >D20          ;If not, jump to store it
  CMP  AL,5         ;If so, will this number make it too big?
  JA  >D70          ;If so, there's an error
D20:                ;Add the digit to our number
  XCHG AX,BX        ;Swap accumulation into AX, new digit into BX
  MUL  CX           ;Multiply the previous accumulation by 10
  ADD  BX,AX        ;Add in the new digit
  JMP  D10          ;Jump to get next character
D70:                ;There was an error
  STC               ;Mark the error flag
  JMP >D90          ;And quit
D80:                ;We have a good number
  DEC  SI           ;Point back at the non-number
  MOV  AX,BX        ;Put the value where it belongs
  CLC               ;Mark the OK flag
D90:                ;We're done
  POP  DX,CX,BX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A HEX NUMERAL (BETWEEN 0 AND F)
;Inputs:  AL = ASCII Character to Test
;Outputs: CF = Clear if it is a Number
;              AL = ASCII Code converted to a real Number
;            = Set if Error (not a Number)
;              AL = Unchanged
;Changes:
;------------------------------------------------------------------------------
IsHexNumber:
  PUSH BX          ;Save used registers
  MOV  BL,AL       ;Save the character in case we need to restore it
  CALL IsNumber    ;A Decimal Number?
  JNC >H85         ;If so, we're done
  CALL Capitalize  ;If not, Capitalize it
  CMP  AL,'A'      ;A Hex Number?
  JB  >H70         ;If not, Error
  CMP  AL,'F'      ;A Hex Number?
  JBE >H80         ;If so, handle it
H70:               ;Not a Number
  MOV  AL,BL       ;Restore original character
  STC              ;Set Error Flag
  JMP >H90         ;Done
H80:               ;A Number > 9
  SUB  AL,('A'-10) ;Convert it to a real number
  JMP >H90         ;Done
H85:               ;OK (is a Number)
  CLC              ;Set OK Flag
H90:               ;Done
  POP  BX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A NUMERAL (BETWEEN 0 AND 9)
;Inputs:  AL = ASCII Character to Test
;Outputs: CF = Clear if it is a Number
;              AL = ASCII Code converted to a real Number
;            = Set if Error (not a Number)
;              AL = Unchanged
;Changes:
;------------------------------------------------------------------------------
IsNumber:
  CMP  AL,'0' ;A Number?
  JB  >N70    ;If not, Error
  CMP  AL,'9' ;A Number?
  JBE >N80    ;If so, handle it
N70:          ;Not a Number
  STC         ;Set Error Flag
  JMP >N90    ;Done
N80:          ;A number
  SUB  AL,'0' ;Convert it to a real number
  CLC         ;Set OK Flag
N90:          ;Done
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A PARTICULAR CHARACTER
;Inputs:  AL = ASCII Character to Test
;Outputs: ZF = Set if it is the appropriate character
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
IsHexEnd:
  PUSH AX         ;Save used registers
  CALL Capitalize ;Capitalize the Character
  CMP  AL,'H'     ;See if it matches
  POP  AX         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE THE TELL THE USER WHERE THE COMMAND LINE ERROR OCCURRED
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE THE COMMAND LINE OR ENVIRONMENT ERROR INFORMATION TO THE SCREEN
;Inputs:  [SI] = Command line Pointer (if Command Line)
;              = StdIn Buffer Pointer (if StdIn String)
;              = Environment Pointer (if Environment Variable)
;         [ProgFlags2].DoEnvir, DoStdIn
;Outputs:
;Changes: Writes information to screen
;------------------------------------------------------------------------------
WriteCmdErr:
  PUSH AX,BX,CX,DX        ;Save used registers
  PUSH DI,SI,BP           ;Save used registers
  CALL FindBadChar        ;Find the actual bad character in the string (SI)
  CALL SetupCmdErrStrings ;Set up the String Pointers and Sizes
                          ;DI:[AX] = Command Line String
                          ;DS:[BX] = Program name at beginning of String
                          ;    CX  = Size of BX String
                          ;DS:[DX] = Header String
                          ;DS:[BP] = Footer String
  CALL WriteZErr          ;Write the Header
  CALL WriteCrLfErr       ;Move
  CALL WriteCrLfErr       ;  down
  SUB  SI,AX              ;Calculate the number
  ADD  CX,SI              ;  of spaces
  DEC  CX                 ;  to write
  CALL WriteCmdString     ;Write the Command-line String (may modify CX)
  CALL WriteCrLfErr       ;Move down
  MOV  B SingleMsg[0],' ' ;Want to write spaces
  MOV  DX,SingleMsg       ;Point at the string
E60:                      ;Loop to here to write each space (number in CX)
  CALL WriteZErr          ;Write the space
  LOOP E60                ;Keep writing them until we're done
  MOV  DX,SIDParseErr     ;Write the Pointer Part
  CALL WriteZErr          ;  of the Error Message
  MOV  DX,BP              ;Write the last part
  CALL WriteZErr          ;  of the message
  POP  BP,SI,DI           ;Restore used registers
  POP  DX,CX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GO BACKWARDS IN AN ERRORED OPTION STRING TO INDICATE TO USER WHERE ERROR WAS
;Inputs:  SI = Option String Pointer (Environment, StdIn, or Command Line)
;                where error was found
;Outputs: SI = Options String Pointer, adjusted to point at a "Real" character
;Changes:
;------------------------------------------------------------------------------
FindBadChar:
  PUSH AX          ;Save used registers
  DEC  SI          ;Go back 1 character to start
B10:               ;Loop to here to find a legitimate character
  CALL GetNextChar ;Get the character
  JZ  >B40         ;If end-of-line, keep going back
  CMP  AL,' '      ;Is it a space?
  JNE >B90         ;If not, we're done
B40:               ;Need to keep going back
  DEC  SI,2        ;Go back to the previous character
  JMP  B10         ;Keep looking
B90:               ;Done
  POP  AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SET UP THE STRING POINTERS AND SIZES TO BE ABLE TO WRITE THE COMMAND ERROR
;Inputs:  DS = Local Data Area
;Outputs: DI:[AX] = Command-line String to write
;         DS:[DX] = First Error Message (Header) to write
;         DS:[BX] = Second message to write (first part of Command string)
;             CX  = Number of Bytes to add to String Size
;         DS:[BP] = Third message to write (Footer)
;Changes:
;------------------------------------------------------------------------------
SetupCmdErrStrings:
  TEST [ProgFlags2],DoEnvir   ;Working with the Environment?
  JNZ >S40                    ;If so, handle it
  TEST [ProgFlags2],DoStdIn   ;Working with StdIn?
  JNZ >S50                    ;If so, handle it
S10:                          ;Command Line
  MOV  AX,81h                 ;DI:[AX] =
  MOV  DI,DS                  ;  Command-line Tail
  MOV  BX,MCBName             ;DS:[BX] = Program Name
  MOV  CX,MCBNameSz           ;CX = Size of [BX] String
  CMP  [CmdLineVarPointer],-1 ;Real Command Line?
  JE  >S30                    ;If so, continue
S20:                          ;CMDLINE Environment Variable
  MOV  DI,[PSPEnvirSeg]       ;DI:[AX] =
  MOV  AX,[CmdLineVarPointer] ;  CMDLINE
  SUB  AX,CmdLineVarSize      ;  Environment Variable
S30:                          ;Have Command-line parameters set up
  MOV  DX,SIDParseCmd         ;DS:[DX] = Header String
  MOV  BP,SIDParseErr2        ;DS:[BP] = Footer String
  JMP >S90                    ;Done
S40:                          ;Environment
  MOV  DI,[PSPEnvirSeg]       ;DI:[AX] =
  MOV  AX,[EnvVarPointer]     ;  Environment
  SUB  AX,EnvVarSize          ;  Variable
  MOV  BX,NoMsg               ;DS:[BX] = Second message to write
  XOR  CX,CX                  ;CX = Size of [BX] String
  MOV  DX,SIDParseEnv         ;DS:[DX] = Header String
  MOV  BP,SIDParseErrEnv      ;DS:[BP] = Footer String
  JMP >S90                    ;Done
S50:                          ;StdIn
  MOV  DI,[StdInSegment]      ;DI:[AX] =
  XOR  AX,AX                  ;  StdIn Buffer
  MOV  BX,NoMsg               ;DS:[BX] = Second message to write
  XOR  CX,CX                  ;CX = Size of [BX] String
  MOV  DX,SIDParseStdIn       ;DS:[DX] = Header String
  MOV  BP,SIDParseErr2        ;DS:[BP] = Footer String
S90:                          ;Done
  RET

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF THE COMMAND STRING, WITH MORE MESSAGES AS NEEDED
;Inputs:  CS = DS = Local Data Area
;         DS:[BX] = First String to write (may not be needed!)
;         DI:[AX] = Second String (main part) to write
;             CX  = Number of Spaces to write at beginning (if normal)
;Outputs: CX = Adjusted number of spaces to write
;Changes:
;------------------------------------------------------------------------------
WriteCmdString:
  PUSH AX,BX,DX,DI,SI      ;Save used registers
  PUSH BP,DS,ES            ;Save used registers
  MOV  BP,CX               ;Save the original Space Counter in BP
  MOV  ES,DI               ;Save the second string Pointer
  MOV  SI,AX               ;  in ES:[SI]
  MOV  DX,BX               ;Save the length
  CALL CalcStrSizeDX       ;  of the first string
  MOV  DI,CX               ;  in DI
  MOV  DS,ES               ;Save the length
  CALL CalcStrSizeSI       ;  of the second string
  MOV  AX,CX               ;  in AX
  CMP  BP,70               ;Are there too many spaces to fit on one line?
  JBE >G20                 ;If not, continue
G10:                       ;Need to lop off the beginning
  SUB  BP,DI               ;We will not be
  XOR  DI,DI               ;  writing the
  MOV  BX,NoMsg            ;  first string
  CMP  BP,70               ;Are there still too many spaces to fit?
  JBE >G20                 ;If not, continue
  MOV  BX,SIDMoreLeft      ;Point at the More Message
  ADD  BP,MoreMsgSize      ;Compensate number of spaces for More Message
  MOV  DI,60               ;We want the number of spaces to be 60
  SUB  DI,BP               ;Calculate how far into the Second string
  NEG  DI                  ;  we need to start to accomplish that
  MOV  BP,59               ;BP = New Number of Spaces
  ADD  SI,DI               ;  where we need to start writing
  SUB  AX,DI               ;  of second string
  MOV  DI,MoreMsgSize      ;DI = Size of new first string (More Message)
G20:                       ;Beginning of line is accounted for
  MOV  DS,CS               ;Write the
  MOV  DX,BX               ;  first
  CALL WriteZErr           ;  string
  MOV  DS,ES               ;Point DS:[DX] at the
  MOV  DX,SI               ;  second string
  ADD  DI,AX               ;Calculate total length of both strings
  CMP  DI,79               ;Will it fit on one line?
  JBE >G40                 ;If so, continue
  MOV  BX,(80-MoreMsgSize) ;Calculate how many characters
  SUB  BX,DI               ;  of the second string
  ADD  BX,AX               ;  we need to write
  MOV  AL,[SI+BX]          ;Save the old character in the string
  MOV  B [SI+BX],0         ;Convert it to an end-of-string character
  CALL WriteZErr           ;Write the truncated string
  MOV  [SI+BX],AL          ;Restore the original character of the string
  MOV  DS,CS               ;Write the
  MOV  DX,SIDMoreRight     ;  More Message
G40:                       ;Write last message
  CALL WriteZErr           ;Write it
G90:                       ;Done
  MOV  CX,BP               ;Return CX = number of spaces to write
  POP  ES,DS,BP            ;Restore used registers
  POP  SI,DI,DX,BX,AX      ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;MISCELLANEOUS COMMAND-LINE RELATED STUFF
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;MARK A COMMAND AS A COMMAND LINE ERROR
;Inputs:
;Outputs: Sets [ParseError] to True
;Changes:
;NOTES: This simply allows us to handle errors AFTER the main processing
;         for a command-line switch has been processed.  The Error Pointer
;         may not be exactly in the right place, but that's OK!
;------------------------------------------------------------------------------
CmdLineErr:
  MOV  [ParseError],Yes ;Mark as an Error
  RET

;------------------------------------------------------------------------------
;GET THE POINTERS TO THE ENVIRONMENT VARIABLES WE NEED
;Inputs:  CS = DS = Local Data Area (also PSP Data Area)
;Outputs: Various Environment Pointers
;Changes:
;------------------------------------------------------------------------------
GetEnvVars:
  PUSH BX,CX,SI                    ;Save used registers
  MOV  SI,PathVarString1           ;Get
  MOV  BX,OFFSET PathVarPointer    ;  the
  MOV  CX,PathVarSize              ;  PATH
  CALL GetEnvVarPointer            ;  Pointer
  JNZ >V20                         ;If OK, continue
  MOV  SI,PathVarString2           ;If no, try
  CALL GetEnvVarPointer            ;  "Path" instead of "PATH"
V20:                               ;Get Program Variable
  MOV  SI,EnvVarString             ;Get
  MOV  BX,OFFSET EnvVarPointer     ;  our
  MOV  CX,EnvVarSize               ;  Program Variable
  CALL GetEnvVarPointer            ;  Pointer
V50:                               ;Get CMDLINE string
  CMP  B [80h],7Eh                 ;Is command line size maxed out?
  JB  >V90                         ;If not, don't worry about CMDLINE Env Var
  MOV  SI,CmdLineVarString         ;Get
  MOV  BX,OFFSET CmdLineVarPointer ;  the
  MOV  CX,CmdLineVarSize           ;  CMDLINE
  CALL GetEnvVarPointer            ;  Pointer
  CALL AdjustCmdLine               ;Compensate CMDLINE Pointer for Program Name
V90:                               ;Done
  POP  SI,CX,BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE POINTER TO AN ENVIRONMENT VARIABLE
;Inputs:   CS = DS = Local Data Area (also contains PSP)
;         [BX] = Where to store the Pointer at
;          CX  = Length of String
;         [SI] = Environment Variable String to Look for (ends in =)
;Outputs: ZF = Set if Error (Variable not found)
;               [BX] = -1
;             = Clear if OK (variable was found)
;               [BX] = Pointer to String (in Environment Segment, NOT PSP!!)
;Changes:
;------------------------------------------------------------------------------
GetEnvVarPointer:
  PUSH AX,CX,SI,BP      ;Save used registers
  PUSH DS,ES            ;Save used registers
  MOV  W [BX],-1        ;Default = -1 (does not exist)
  MOV  ES,[PSPEnvirSeg] ;ES:[DI] =
  XOR  DI,DI            ;  Environment Variable List
  MOV  DX,CX            ;Save the Size
  MOV  BP,SI            ;Save the original Pointer
  XOR  AL,AL            ;Need to look for 0's
V10:                    ;Loop to here for each Environment variable
  MOV  CX,DX            ;CX = Number of bytes to test
  MOV  SI,BP            ;DS:[SI] = String to Test for
  REPE CMPSB            ;Is it a match?
  JZ   >V30             ;If so, continue
  MOV  CX,-1            ;Max out the count limiter
  REPNE SCASB           ;Look for the end of this environment variable
  CMP  B ES:[DI],AL     ;End of Environment?
  JNE  V10              ;If not, keep looking
  JMP >V90              ;If so, no variable
V30:                    ;Found it!
  MOV  [BX],DI          ;Store the Pointer
V90:                    ;Done
  CMP  W [BX],-1        ;Set return flag
  POP  ES,DS            ;Restore used registers
  POP  BP,SI,CX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADJUST THE CMDLINE ENVIRONMENT VARIABLE POINT TO POINT AT THE COMMAND TAIL
;Inputs:  DS = Local Data Area (and PSP Segment)
;         [CmdLineVarPtr] (-1 if does not exist)
;           Unadjusted for Program Path/Name
;Outputs: [CmdLineVarPtr]
;           Adjusted (Program Path/Name skipped over to leave Command Tail)
;Changes:
;NOTES: The CMDLINE environment variable, which is only set by SOME
;         versions of DOS, contains the entire contents of the command
;         line.  The "entire contents" includes our executable file name
;         (including the path, if it was provided), but does not include
;         the redirection and/or piping parameters.
;       This routine skips over the executable file name part and simply
;         points at the command tail (the "Options" part of the command line).
;       The CMDLINE variable is used by some versions of DOS (such as 4DOS/NDOS
;         and DOS 95) to allow the command-line to be longer than the 126
;         characters normally allowed by DOS.
;------------------------------------------------------------------------------
AdjustCmdLine:
  PUSH AX,DX,SI,DS      ;Save used registers
  MOV  SI,[CmdLineVarPointer]  ;[SI] = CMDLINE environment variable contents
  CMP  SI,-1            ;Anything there?
  JE  >J90              ;If not, no need for changes
  MOV  DL,"/"           ;Assume Get SwitchChar function is unsupported
  MOV  AX,3700h         ;Function 3700h (Get DOS SwitchChar)
  INT  21h              ;Do it (returns DL)
  MOV  DS,[PSPEnvirSeg] ;DS:[SI] = CMDLINE contents
J10:                    ;Loop to here to skip initial spaces & tabs
  LODSB                 ;Get the next character
  CMP  AL,' '           ;Space?
  JE   J10              ;If so, keep skipping
  CMP  AL,Tab           ;Tab?
  JE   J10              ;If so, keep skipping
J20:                    ;Skipped initial Tabs & Spaces
  DEC  SI               ;Point back at the first character
  XOR  AH,AH            ;Assume no quotes
  CMP  AL,Quote2        ;Double Quote (part of LFN Path & File Name)?
  JNE >J30              ;If not, continue
  MOV  AH,AL            ;If so, mark as a quote
  INC  SI               ;Update the Pointer
J30:                    ;Loop to here for each character
  LODSB                 ;Get next character
  OR   AH,AH            ;Are we looking for a Quoted Path/File Name?
  JZ  >J40              ;If not, continue
J35:                    ;Looking for the Closing Quote
  CMP  AL,AH            ;Is it the Closing Quote?
  JNE >J50              ;If not, keep looking
  JMP >J85              ;If so, we're done
J40:                    ;Not a Quoted Path/File Name
  OR   AL,AL            ;End of variable?
  JE  >J80              ;If so, handle it
  CMP  AL,' '           ;Space?
  JE  >J80              ;If so, we're done
  CMP  AL,Tab           ;Tab?
  JE  >J80              ;If so, we're done
  CMP  AL,'/'           ;Slash?
  JE  >J80              ;If so, we're done
  CMP  AL,DL            ;SwitchChar?
  JE  >J80              ;If so, we're done
J50:                    ;Not end-of-name
  JMP  J30              ;Keep looking
J80:                    ;[SI-1] = CMDLINE Pointer
  DEC  SI               ;Point at beginning of string
J85:                    ;[SI] = New CMDLINE Pointer
  MOV  CS:[CmdLineVarPointer],SI ;Store it
J90:                    ;Done
  POP  DS,SI,DX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE ENVIRONMENT VARIABLE CONTENTS TO THE SCREEN
;Inputs:  [EnvVarPointer] (-1 if no Environment variable exists)
;Outputs:
;Changes: Writes to CON or ERR
;------------------------------------------------------------------------------
WriteEnvCon:
  PUSH AX                 ;Save used registers
  XOR  AL,AL              ;Flag to write to CON
  JMP >W00                ;Do it
WriteEnvErr:
  PUSH AX                 ;Save used registers
  MOV  AL,1               ;Flag to write to ERR
W00:                      ;Write the Environment string to CON or ERR
  PUSH DX,DS              ;Save used registers
  MOV  DX,[EnvVarPointer] ;[DX] = Environment Variable
  CMP  DX,-1              ;Valid Pointer?
  JE  >W90                ;If not, quit
  SUB  DX,EnvVarSize      ;Point DX at beginning of the Variable
  MOV  DS,[PSPEnvirSeg]   ;Point DS at the Environment Segment
  OR   AL,AL              ;Should we write to CON?
  JZ  >W70                ;If so, jump to do it
  CALL WriteZErr          ;If not, write to ERR
  JMP >W90                ;And quit
W70:                      ;Write to CON
  CALL WriteZPause        ;Write it
W90:                      ;We're done
  POP  DS,DX              ;Restore used registers
  POP  AX                 ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS THE RESET ALL BAD DEVICES REQUEST
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PROCESS THE RESET ALL BAD DEVICES REQUEST AND QUIT, IF APPROPRIATE
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         [ProgFlags].ResetBads
;Outputs:
;Changes: Quits program
;------------------------------------------------------------------------------
DoResetBads:
  TEST [ProgFlags],ResetBads ;Do we need to do anything?
  JNZ >B00                   ;If so, handle it
  RET

B00:
  CALL TestUSBHost      ;Are any compatible Drivers installed?
  JNC >B01              ;If so, continue
  MOV  AL,ErLvlNotInMem ;If not, ErrorLevel = Not in Memory Yet
  MOV  DX,SIDNotInMem   ;[DX] = Error Message to write
  JMP  Exit             ;Quit program

B01:                              ;At least one Host is installed
  CALL WriteCrLfPause             ;Move down
  MOV  SI,Int14Request2           ;[SI] = Int 14 Request to use
  MOV  AX,CS                                    ;Store
  MOV  W [SI].I14RCallBackAddr[2],AX            ;  Call-Back
  MOV  W [SI].I14RCallBackAddr[0],DoHostFarCall ;  Address
  XOR  CX,CX                      ;Bad Device Counter = 0
  MOV  [SI].I14RHostIndex,CL      ;Start at Host Index 0
B10:                              ;Loop tt here for each Host
  MOV  [SI].I14RRequestType,I14RRTGetHostStatus ;Request = Get Host Status
  CALL DoInt14CallBXSI            ;Do it (returns Status flags in BL)
  JC  >B60                        ;If error, skip it
  CMP  BL,HostStatusRunning       ;Is this Host Running normally?
  JNE >B60                        ;If not, skip it
  MOV  [SI].I14RDeviceAddress,127 ;Start at Address 127 (last possible address)
B20:                              ;Loop to here for each Device
  MOV  [SI].I14RRequestType,I14RRTGetDvcStatus ;Request = Get Device Status
  CALL DoInt14CallBXSI            ;Do it (returns Status flags in BH)
  JC  >B50                        ;If error, skip it
  TEST BH,ADFlagBadDvc            ;Is it a Bad Device?
  JZ  >B50                        ;If not, skip it
  INC  CX                         ;Increment Bad Device Counter
  MOV  DX,SIDResetBad             ;Write the
  CALL WriteZPause                ;  Header
  MOV  AX,W [SI].I14RHostIndex    ;AL = Host Index, AH = Device Address
  CALL WriteByteMin               ;Write the Host Index
  CALL WriteDash                  ;Write a Dash
  XCHG AL,AH                      ;Write the
  CALL WriteByteMin               ;  Device Address
  MOV  [SI].I14RRequestType,I14RRTResetDevice ;Request = Reset Device
  MOV  [DoHostReturnAX],-1        ;Initialize Return Value
B30:                              ;Loop to here to wait for Resources
  CALL DoInt14CallAXSI            ;Do the Reset
  JNC >B40                        ;If it was accepted, continue
  CMP  AL,I14RErrResources        ;If not, was it a lack of Resources?
  JE  >B35                        ;If so, wait and try again
  MOV  DX,SIDErrorBads            ;If not, write
  CALL WriteZPause                ;  an ERROR! message
  JMP >B45                        ;Continue
B35:                              ;Lack of Resources - Wait & try again
  MOV  AX,50                      ;If so, wait
  CALL DelayMSAX                  ;  50 milliseconds
  JMP  B30                        ;Try again
B40:                              ;Wait for the Reset to happen
  CMP  [DoHostReturnAX],-1        ;Is it done yet?
  JE   B40                        ;If not, keep waiting
  MOV  AX,100                     ;Wait for
  CALL DelayMSAX                  ;  100 milliseconds
B45:                              ;Done Resetting Device
  CALL WriteCrLfPause             ;Move down
B50:                              ;Done with this Device
  CMP  [SI].I14RDeviceAddress,2   ;Done all of the Devices?
  JE  >B60                        ;If so, we're done with this Host
  DEC  [SI].I14RDeviceAddress     ;If not, go to next Device
  JMP  B20                        ;Do it
B60:                              ;Done with this Host
  CMP  [SI].I14RHostIndex,(MaxHosts-1) ;Have we done all of the Hosts?
  JE  >B90                        ;If so, we're done
  INC  [SI].I14RHostIndex         ;Go to the next Host
  JMP  B10                        ;Keep looking
B90:                              ;Done with All Hosts
  MOV  DX,NoMsg                   ;Assume at least one Bad Device
  OR   CX,CX                      ;Were there any Bad Devices at all?
  JNZ >B95                        ;If so, we're done
  MOV  DX,SIDNoBads               ;[DX] = Correct message
B95:                              ;Done
  XOR  AL,AL                      ;ErrorLevel = 0
  JMP  Exit                       ;QUIT


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO WRITE SPECIAL MESSAGES TO THE SCREEN (HELP, STATUS, ETC.)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE PROGRAM HELP MESSAGE
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;PRINT THE SYNTAX HELP MESSAGE AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;Outputs:
;Changes: Quits program
;------------------------------------------------------------------------------
DoHelp:
  TEST [ProgFlags],Help ;Does the user want help?
  JZ  >H90              ;If not, we're done
  MOV  DX,SIDSyntax     ;Point at the last part of the Help Message
  CALL WriteZPause      ;Write it with Pauses
  MOV  DX,NoMsg         ;Write nothing
  XOR  AL,AL            ;ErrorLevel=0
  JMP  Exit             ;And QUIT
H90:                    ;No need to do help
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE COMMAND-LINE ALIASES
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;PRINT THE COMMAND LINE ALIASES AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;Outputs: Writes Aliases to the screen
;Changes: Quits program
;------------------------------------------------------------------------------
DoAliases:
  TEST [ProgFlags],Alias  ;Does user want to see the Aliases?
  JZ  >A95                ;If not, we're done
  PUSH AX,BX,CX,DX,SI     ;Save used registers
  MOV  CL,21              ;Write
  CALL WriteSpaces        ;  the
  MOV  DX,SIDAliasHdr     ;  Header
  CALL WriteZPause
  MOV  CL,79
  CALL WriteDoubleLine
  CALL WriteCrLfPause
  MOV  BX,SwitchTbl       ;Point at Tbl of Switches (sorted) & Code Offsets
  MOV  SI,SIDSwitchList   ;Point at Tbl of Aliases
  CALL DoAliasesGoNoNum   ;Write the Aliases
  MOV  CL,35              ;Write the
  CALL WriteDoubleLine    ;  Dividing Line
  MOV  BX,SwitchTblYesNo  ;Point at Table of Switches
  MOV  SI,SIDSwitchListYN ;Point at Table of Aliases
  CALL DoAliasesGoNoNum   ;Write the Aliases
  MOV  CL,35              ;Write the
  CALL WriteDoubleLine    ;  Dividing Line
  MOV  BX,SwitchTbl2      ;Point at Table of Switches
  MOV  SI,SIDSwitchList2  ;Point at Table of Aliases
  CALL DoAliasesGoNum     ;Write the Aliases
A90:                      ;Done
  POP  SI,DX,CX,BX,AX     ;Restore used registers
  MOV  DX,NoMsg           ;Don't write anything
  XOR  AL,AL              ;ErrorLevel = 0
  JMP  Exit               ;QUIT
A95:                      ;No need to write Aliases
  RET

;------------------------------------------------------------------------------
;WRITE THE LIST OF SWITCH CHARACTERS TO THE SCREEN
;Inputs:  [BX] = Switch Offset Table
;         [SI] = Switch List ("Code Word") Table (may be SID in Overlay segment)
;         CH = 0 if we write Blocks for Switches < "0"
;            = -1 if we write numbers for the Switches (0-255)
;Outputs: Writes List fo Switch Characters to the Screen
;Changes:
;------------------------------------------------------------------------------
DoAliasesGoNum:
  PUSH CX               ;Save used registers
  MOV  CH,-1            ;Mark as writing Numbers
  JMP >G00              ;Continue
DoAliasesGoNoNum:
  PUSH CX               ;Save used registers
  XOR  CH,CH            ;Mark as not writing Numbers
;  JMP >G00              ;Continue
G00:
  PUSH AX,BX            ;Save used registers
G10:                    ;Loop to here for each Alias
  MOV  AL,[BX]          ;Get the Switch Character
  OR   AL,AL            ;End of the table?
  JZ  >G90              ;If so, we're done
  CALL WriteCrLfPause   ;Move down
  OR   CH,CH            ;Writing Single characters?
  JNZ >G40              ;If not, handle full numbers
  MOV  CL,78            ;This many characters left to write
  CMP  AL,'0'           ;Is there a valid single-character equivalent?
  JB  >G20              ;If not, don't write it
  CALL WriteAL          ;If so, write it
  JMP >G60              ;Continue
G20:                    ;Not a writable character
  CALL WriteBlock       ;Write a Block Character
  JMP >G60              ;Continue
G40:                    ;Need to write Numbers
  MOV  CL,76            ;Can only write 76 characters
  CALL ByteToString     ;Write the Switch as a Number
G60:                    ;Done writing single character
  CALL WriteSingleAlias ;Write the Alias List
  ADD  BX,3             ;Point at next table entry
  JMP  G10              ;Keep going until we're done
G90:                    ;Done
  CALL WriteCrLfPause   ;Move down
  POP  BX,AX            ;Restore used registers
  POP  CX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ALL ALIASES FOR A SINGLE CHARACTER COMMAND-LINE OPTION TO THE SCREEN
;Inputs:   AL  = Command-Line Switch to write (Single character)
;         [SI] = SwitchList table to look through for matches
;                (may be SID code in Overlay segment)
;          CL  = Number of characters left available to write on first line
;Outputs: Writes all Aliases for the single character in AL to the screen
;Changes:
;------------------------------------------------------------------------------
WriteSingleAlias:
  PUSH AX,BX,CX,DX     ;Save used registers
  PUSH DI,SI,ES        ;Save used registers
  PUSH DS              ;Save DS for a second
  MOV  DX,SI           ;DS:[DX] = Table to Search
  CALL TestFSSegment   ;Convert to pointer in Overlay segment, if appropriate
  MOV  ES,DS           ;ES:[SI] =
  MOV  SI,DX           ;  String Table
  POP  DS              ;Restore DS
  MOV  BX,AliasSortTbl ;Point at Sorting Table
S10:                   ;Loop to here for each Alias List Entry
  MOV  DX,SI           ;Save beginning Alias Pointer
S15:                   ;Loop to here to find the end of an Alias List Entry
  CMP  B ES:[SI],0     ;End of Alias List?
  JE  >S20             ;If so, handle it
  CALL SkipOverStrESSI ;If not, skip over the string
  JMP  S15             ;Keep looking
S20:                   ;End of Alias List Entry
  MOV  DI,SI           ;Save End-of-Entry Pointer
  CMP  B ES:[SI+1],AL  ;Is this entry a match?
  JNE >S40             ;If not, go to the next one
  MOV  SI,DX           ;Point at Alias String
S30:                   ;Loop to here for each Alias String
  CMP  B ES:[SI],0     ;End of the entry?
  JE  >S40             ;If so, we're done
  MOV  [BX],SI         ;If not, store it in the sort table
  INC  BX,2            ;Update the Table Pointer
  CALL SkipOverStrESSI ;Skip over the string
  JMP  S30             ;Keep going until we have all of the strings
S40:                   ;Done with this entry
  MOV  SI,DI           ;Get End-of-Entry Pointer
  INC  SI,2            ;Skip over End-of-Entry stuff
  CMP  B ES:[SI],0     ;End of Table?
  JNE  S10             ;If not, keep looking
S50:                   ;AliasSortTbl contains String Pointers!
  DEC  BX,2            ;Point back at the last entry we made
  MOV  DI,BX           ;Use DI as our Pointer
  MOV  BL,CL           ;Get the current character counter
S60:                   ;Loop to here for each Alias String
  CMP  DI,AliasSortTbl ;Are we done writing?
  JB  >S90             ;If so, quit
  MOV  SI,[DI]         ;Get the next string
  DEC  DI,2            ;Update the table pointer
  CALL CalcStrSizeESSI ;See how long the string is
  OR   BL,BL           ;Is the character counter down to 0?
  JZ  >S70             ;If so, we need to reset it
  CMP  CL,BL           ;Is this string too long to fit on this line?
  JB  >S80             ;If not, go ahead and write it
S70:                   ;Need to start a new line
  CALL WriteCrLfPause  ;If so, start a new line
  CALL WriteSpace      ;Move over a little bit
  MOV  BL,78           ;Reset the character counter
S80:                   ;Write the Alias String
  SUB  BL,CL           ;Update the
  DEC  BL              ;  character counter
  CALL WriteSpace      ;Write a Space
  CALL WriteZPauseESSI ;Write the string
  JMP  S60             ;Keep writing
S90:                   ;Done
  CALL WriteCrLfPause  ;Move down
  POP  ES,SI,DI        ;Restore used registers
  POP  DX,CX,BX,AX     ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE THE ERRORLEVEL TABLE
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE ERRORLEVEL TABLE TO THE SCREEN AND QUIT
;Inputs:  CS = DS = Local Data Area
;Outputs: Writes ErrorLevel Table to the Screen
;Changes: Quits Program
;         Several registers
;------------------------------------------------------------------------------
DoErrLvls:
  TEST [StatusFlags],ErrLvl ;Does the user want to see the ErrorLevels?
  JZ  >V95                  ;If not quit
  MOV  DX,SIDErrLvlHdr      ;Write the
  CALL SetupPause           ;  Table Header
  XOR  AL,AL                ;Start with ErrorLevel 0
V10:                        ;Loop to here for each table entry
  MOV  BX,SIDErrLvlTbl      ;Table to search
  CALL SearchByte2StringTbl ;Valid ErrorLevel?
  JC  >V50                  ;If not, keep looking
  CALL WriteSpace           ;Move Over
  CALL ByteToString         ;If valid, write the Number
  CALL WriteSpace           ;Write a space
  MOV  DX,BX                ;Write
  MOV  DS,CS:[OvlSegment]   ;  the
  CALL WriteZPause          ;  Description
  MOV  DS,CS                ;  String
  CALL WriteCrLfPause       ;Write a New Line
V50:                        ;Done with this entry
  INC  AL                   ;Increment ErrorLevel
  JNZ  V10                  ;If not rolled over yet, keep looking
V90:                        ;Done
  MOV  DX,NoMsg             ;Don't write anything
  XOR  AL,AL                ;ErrorLevel = 0
  JMP  Exit                 ;Quit
V95:                        ;No need to write Aliases
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE HOST STATUS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE CURRENT UHCI/PCI HOST STATUS TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteHostStatus:
  PUSH AX,CX,DI           ;Save used registers
  CALL InitCmdTail        ;Initialize the Command Tail
  MOV  DX,UHCIMsg         ;Write the Host Type
  CALL AppendString2Cmd   ;  to the command tail
  MOV  AL,B ES:[PCISearchIndex][0] ;Write the PCI Search Index
  CALL AppendHexByte2Cmd           ;  to the command tail
  CALL AppendCallBack2Cmd ;Append the Call-Back Address to the Command Tail
  MOV  AX,CS              ;Append our
  MOV  CX,SetupPauseFar   ;  Header Setup Routine Address
  CALL AppendSegOff2Cmd   ;  to the command tail
  CALL FindCmdTailEnd     ;Calculate how many
  DEC  DI                 ;  characters
  MOV  B [DI],CR          ;  are in
  SUB  DI,CmdTail         ;  the command tail
  MOV  AX,DI              ;Store it
  MOV  [CmdTailSize],AL   ;  in [CmdTailSize]
  MOV  DI,SupportFileHost ;[DI] = Exec File to Call
  CALL HandleExecCall     ;Execute the Support File
  POP  DI,CX,AX           ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE SPECIFIC TABLE STATUS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE STATUS OF SOME PARTICULAR TABLE TO THE SCREEN
;Inputs:  Various Register values
;Outputs:
;Changes:
;------------------------------------------------------------------------------
DoHostStatus:
  PUSH BX                    ;Save used registers
  MOV  BX,OFFSET StatusFlags ;[BX] = [StatusFlags]
  TEST B [BX],HostStatus     ;Write the Host Status?
  JZ  >S90                   ;If not, we're done
  CALL WriteHostStatus       ;Write the Status
  JMP >S80                   ;We're done

DoStatuses:
  PUSH BX                    ;Save used registers
  MOV  BX,OFFSET StatusFlags ;[BX] = [StatusFlags]
  CMP  B [BX],0              ;Any Status at all to write?
  JE  >S90                   ;If not, just quit
  CALL CopyTSRData2Local     ;Copy TSR Data to local segment
  TEST B [BX],FLStatus       ;Write the Frame List Status?
  JZ  >S30                   ;If not, try the next possibility
  CALL WriteFLStatus         ;Write the Status
  JMP >S80                   ;We're done
S30:                         ;Look for QH
  TEST B [BX],QHStatus       ;Write the Queue Head Status?
  JZ  >S40                   ;If not, try the next possibility
  CALL WriteQHStatus         ;Write the Status
  JMP >S80                   ;We're done
S40:                         ;Look for TD
  TEST B [BX],TDStatus       ;Write the Transfer Descriptor Status?
  JZ  >S50                   ;If not, try the next possibility
  CALL WriteTDStatuses       ;Write the Status
  JMP >S80                   ;We're done
S50:                         ;Look for TD
  TEST B [BX],ADStatus       ;Write the Address Data Status?
  JZ  >S60                   ;If not, try the next possibility
  CALL WriteADStatus         ;Write the Status
  JMP >S80                   ;We're done
S60:                         ;Look for TD
  TEST B [BX],NDStatus       ;Write the Transfer Descriptor Status?
  JZ  >S90                   ;If not, try the next possibility
  CALL WriteNDStatus         ;Write the Status
S80:                         ;Wrote a status
  XOR  AL,AL                 ;ErrorLevel = 0
  MOV  DX,NoMsg              ;No message to write
  JMP  Exit                  ;Quit
S90:                         ;We're done
  POP  BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY THE TSR DATA AREA TO THE LOCAL DATA AREA
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         CLD already issued
;Outputs: Copies Data section of TSR Data (ES) to local Segment (DS)
;           This allows us to avoid using the ES override prefix, hopefully
;           saving memory
;Changes:
;------------------------------------------------------------------------------
CopyTSRData2Local:
  PUSH CX,DI,SI ;Save used registers
  PUSH DS,ES    ;Save used registers
  PUSHF         ;Save flags
  MOV  SI,100h  ;Point SI at TSR Data
  MOV  DI,SI    ;Point DI at the Local Data
  MOV  CX,((LastTSRByte0-100h+3)SHR 2) ;Number of DWords to Copy
  CLI           ;Disable interrupts
  SwapDSES      ;Point DS at TSR, ES at Local
  REP  MOVSD    ;Copy the data
  POPF          ;Restore flags
  POP  ES,DS    ;Restore used registers
  POP  SI,DI,CX ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE FRAME LIST STATUS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE CURRENT FRAME LIST STATUS TO THE SCREEN
;Inputs:  Various Register values
;         DS = Local Data Area
;         ES = TSR Data Area
;         TSR Data already copied to Local data area
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteFLStatus:
  PUSH EAX,BX,CX,DX,DI          ;Save used registers
  MOV  DX,SIDFLHeader           ;Tell the Pause Routine
  CALL SetupPause               ;  about the Header
  XOR  CX,CX                    ;Start at Index 0
F30:                            ;Loop to here for each FL Entry
  CALL FLIndex2Offset           ;See what type of
  MOV  EAX,[DI].FLLinkPointer   ;  pointer
  CALL CalcPhysAddrType         ;  it is
  CMP  BL,PhysAddrTypeControlQH ;Is it an Empty Frame List Entry?
  JE  >F60                      ;If so, don't write anything!
  CALL Write2Spaces             ;Move over
  MOV  AX,CX                    ;Write the
  CALL WordToString             ;  Index
  CALL Write2Spaces             ;Move over
  CALL FLIndex2Offset           ;Convert the Index
  CALL WriteFLEntry             ;Write the FL Entry
  CALL WriteCrLfPause           ;Write a new line
F60:                            ;Done writing
  INC  CX                       ;Increment the Index
  CMP  CX,FLEntries             ;Done yet?
  JB   F30                      ;If not, keep looking
F90:                            ;We're done
  POP  DI,DX,CX,BX,EAX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF AN INDIVIDUAL FRAME LIST ENTRY TO THE SCREEN
;Inputs:  ES:[DI] = Frame List Entry
;         DS = Local Data Area
;         ES = TSR Data Area
;         TSR Data already copied to Local data area
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteFLEntry:
  PUSH EAX,BX,CX,DX,DI          ;Save used registers
  MOV  CX,3                     ;Write a maximum of three Full Links
  MOV  EAX,[DI].FLLinkPointer   ;Get the Pointer
  CALL WritePtrType             ;Write it
Y10:                            ;Loop to here for each entry
  CALL PhysAddr2SegOffNoFlags   ;Convert TD Address to a Pointer (DI)
  MOV  EAX,[DI].TDLinkPointer   ;Get it's Link Pointer
  CALL CalcPhysAddrType         ;See what type it is
  CMP  BL,PhysAddrTypeControlQH ;Is it the end of the TD's?
  JE  >Y90                      ;If so, we're done
  DEC  CX                       ;Decrement our total counter
  JZ  >Y40                      ;If we've done enough, handle it
  CALL WritePtrType             ;Write the details
  JMP  Y10                      ;Keep going until we're done
Y40:                            ;Already done enough to fill line
  MOV  DX,SIDEllipses           ;Write an
  CALL WriteZPause              ;  ellipses
Y90:                            ;Done
  POP  DI,DX,CX,BX,EAX          ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE QUEUE HEAD STATUS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE CURRENT QUEUE HEAD STATUS TO THE SCREEN
;Inputs:  Various Register values
;         DS = Local Data Area
;         ES = TSR Data Area
;         TSR Data already copied to Local data area
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteQHStatus:
  PUSH EAX,CX,DX,DI,SI           ;Save used registers
  MOV  DX,SIDQHHeader            ;Write the
  CALL SetupPause                ;  Header
  XOR  CX,CX                     ;Start with Index 0
  MOV  SI,SIDQHTypeCtl           ;Point at the first QHType message
  MOV  DI,ES:[QHTable]           ;Point at first QH
Q10:                             ;Loop to here for each QH Entry
  MOV  AX,CX                     ;Put Index in AX
  CALL Write2Spaces              ;Move over
  CALL WordToString              ;Write the Index
  CALL Write2Spaces              ;Move over
  CALL SegOff2PhysAddrESDI       ;  Physical
  CALL WriteDWordHex             ;  Address
  CALL WriteHexEnd               ;Write the "h"
  CALL Write2Spaces              ;Move over
  CALL WriteZPauseSI             ;Write the QH Type
  OR   CL,CL                     ;Control QH?
  JZ  >Q20                       ;If so, don't write Number
  MOV  AL,CL                     ;Get the Index number
  CMP  AL,BulkQHEntries          ;Is it a Bulk QH?
  JBE >Q15                       ;If so, the number is OK
  SUB  AL,BulkQHEntries          ;If not, adjust the number for Int QH's
Q15:                             ;AL contains Index number to write
  CALL ByteToString              ;Write the number
Q20:                             ;Done writing Type
  CALL Write2Spaces              ;Move over
  MOV  EAX,[DI].QHLinkPointer    ;  Link Pointer
  CALL WritePtrType              ;Write the Pointer information
  CALL WriteSpace                ;Move over
  MOV  EAX,[DI].QHElementPointer ;Get the Element Pointer
  CALL WritePtrType              ;Write the Pointer information
  CALL WriteCrLfPause            ;Write a new line
  MOV  SI,SIDQHTypeBulk          ;Assume Bulk
  CMP  CL,IntQHEntries           ;Is it Bulk?
  JB  >Q50                       ;If so, continue
  MOV  SI,SIDQHTypeInt           ;If not, it's Interrupt
Q50:                             ;That line is complete
  ADD  DI,QHSize                 ;Point at next QH
  INC  CX                        ;Increment Index
  CMP  CL,QHEntries              ;Done with the Table yet?
  JB   Q10                       ;If not, keep doing it
Q90:                             ;We're done
  POP  SI,DI,DX,CX,EAX           ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE TRANSFER DESCRIPTOR STATUS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE TRANSFER DESCRIPTOR(S) STATUS
;Inputs:  [IndexToWrite] = Index of Specific Transfer Descriptor to write
;                        = -1 if we need to write all TD's
;         DS = Local Data Area
;         ES = TSR Data Area
;         TSR Data already copied to Local data area
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteTDStatuses:
  PUSH AX,BX,CX,DI        ;Save used registers
  CALL WriteCrLfPause     ;Move down
  MOV  AX,[IndexToWrite]  ;Get the Specific Index to Write
  CMP  AX,-1              ;Is there a Specific Index?
  JNE >S50                ;If so, handle it
S10:                      ;Write all TD's
  XOR  CX,CX              ;Start with Index 0
  XOR  BX,BX              ;Initialize TD's written counter
S20:                      ;Loop to here for each TD Index
  CALL TDIndex2Offset     ;Get the TD Offset (DI)
  MOV  AL,[DI].TDFlags    ;Get the
  AND  AL,TDTypeMask      ;  TD Type
  CMP  AL,TDTypeAvailable ;Is this TD used?
  JE  >S40                ;If not, don't write it
  OR   BX,BX              ;Have we written any TD's yet?
  JZ  >S30                ;If not, continue
  CALL WriteCrLfPause2    ;If so,
  CALL WriteCrLfPause     ;  move down
S30:                      ;Handled spacing, if needed
  INC  BX                 ;Increment TD's written counter
  MOV  AX,CX              ;Write the
  CALL WriteTDStatus      ;  TD Status
S40:                      ;Done with this entry
  CMP  CL,(TDEntries-1)   ;Have we done all of them yet?
  JE  >S90                ;If so, we're done
  INC  CX                 ;If not, increment the TD Index
  JMP  S20                ;Keep writing
S50:                      ;Write a single specific Index
  CALL WriteTDStatus      ;Write the TD Status
S90:                      ;Done
  POP  DI,CX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A SPECIFIC TRANSFER DESCRIPTOR STATUS TO THE SCREEN
;Inputs:  AX = Index of Transfer Descriptor to write
;         DS = Local Data Area
;         ES = TSR Data Area
;         TSR Data already copied to Local data area
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteTDStatus:
  PUSH EAX,BX,CX,EDX,DI,SI             ;Save used registers
  MOV  CL,28                           ;Write
  CALL WriteSpaces                     ;  the
  MOV  DX,SIDTDHeader0                 ;  Header
  CALL WriteZPause
  CALL WriteWordMin
  CALL WriteCrLfPause
  MOV  CL,79
  CALL WriteDoubleLine
  CALL WriteCrLfPause2
  MOV  DX,SIDTDHeader1
  CALL WriteZPause
  CALL WordToString                    ;Write the Index
  CALL WriteSpace                      ;Move over
  MOV  CX,AX                           ;Write
  CALL TDIndex2Offset                  ;  the
  CALL SegOff2PhysAddrESDI             ;  Physical
  CALL WriteDWordHex                   ;  Address
  CALL WriteHexEnd                     ;Write the "h"
  CALL WriteSpace                      ;Move over
  CALL GetTDType                       ;Get the TD Type
  MOV  BX,SIDTDTypeTbl                 ;Write the
  CALL WriteByteToStringTbl            ;  TD Type
  CALL WriteSpace                      ;Move over
  MOV  AL,B [DI].TDToken[0]            ;Get the Packet Type
  MOV  BX,SIDTDPktTypeTbl              ;Write the
  CALL WriteByteToStringTbl            ;  Packet Type
  JNC >T10                             ;If OK, continue
  CALL WriteByteHex                    ;If not in Table, write the number
  CALL WriteHexEnd                     ;Write the 'h'
  MOV  DX,SIDTDPktTypeNA               ;Write the ?
  CALL WriteZPause                     ;Write the Packet Type
T10:                                   ;DOne with Packet Type
  CALL Write2Spaces                    ;Move over
  MOV  DX,SIDNoMsgN                    ;Assume Not On Hold
  TEST [DI].TDFlags,TDFlagOnHold       ;Is it On Hold?
  JZ  >T30                             ;If not, write it
  MOV  DX,SIDYesMsgY                   ;It is On Hold
T30:                                   ;Write On Hold Status
  CALL WriteZPause                     ;Write On Hold Status
  CALL WriteSpace                      ;Move over
  CALL GetTDDeviceAddress              ;Write the
  CALL ByteToString                    ;  Device Address
  CALL WriteSpace                      ;Move over
  CALL GetTDEndPoint                   ;Write the
  CALL ByteToString                    ;  End Point
  CALL WriteSpace                      ;Move over
  CALL GetTDMaxLength                  ;Write the
  CALL WordToString                    ;  Max Length
  CALL WriteSpace                      ;Move over
  CALL GetTDActualLength               ;Write
  MOV  AX,CX                           ;  the
  CALL WordToString                    ;  Actual Length
  CALL WriteSpace                      ;Move over
  MOV  AX,[DI].TDUserPktID             ;Write
  CALL WriteWordHex                    ;  the
  CALL WriteHexEnd                     ;User Packet ID
  CALL WriteSpace                      ;Move over
  MOV  EAX,[DI].TDBuffPointer          ;Write
  CALL WriteDWordHex                   ;  the
  CALL WriteHexEnd                     ;  Buffer Address
  CALL WriteCrLfPause2                 ;Move down
  CALL WriteTDSpecificData             ;Write the TD Type-Specific data
  MOV  DX,SIDTDHeader2                 ;Write the
  CALL WriteZPause                     ;  second header
  MOV  EAX,[DI].TDControlStatus        ;Get the
  SHR  EAX,16                          ;  Control and Status register
  MOV  BH,(TDActive SHR 16)            ;Write the
  CALL WriteYesNoALBH                  ;  Active Status
  MOV  BH,(TDIsochSelect SHR 24)       ;Write the
  CALL WriteYesNoAHBH                  ;  Isochronous Select Status
  MOV  BH,(TDLowSpeedDevice SHR 24)    ;Write the
  CALL WriteYesNoAHBH                  ;  Speed
  MOV  BH,(TDIntOnComplete SHR 24)     ;Write the
  CALL WriteYesNoAHBH                  ;  Interrupt On Complete Status
  MOV  DL,B [DI].TDLinkPointer         ;Write
  MOV  BH,TDDepthFirst                 ;  the
  CALL WriteYesNoDLBH                  ;  Depth/Breadth First Status
  MOV  DL,B [DI].TDToken[2]            ;Write the
  MOV  BH,(TDData1 SHR 16)             ;  Data0/Data1
  CALL WriteYesNoDLBH                  ;  Status
  CALL Write2Spaces                    ;Move over
  PUSH AX                              ;Save the Status Word
  SHR  AX,(TDErrorCountSft-16)         ;Write
  AND  AL,3                            ;  the
  ADD  AL,'0'                          ;  current
  CALL WriteAL                         ;  Error Count
  POP  AX                              ;Get the Status Word back again
  CALL WriteSpace                      ;Move over
  MOV  BH,(TDShortPacketDetect SHR 24) ;Write the
  CALL WriteYesNoAHBH                  ;  SPD Status
  CALL WriteSpace                      ;Move over
  MOV  BH,(TDNAKReceived SHR 16)       ;Write the
  CALL WriteYesNoALBH                  ;  NAK Status
  MOV  BH,(TDStalled SHR 16)           ;Write the
  CALL WriteYesNoALBH                  ;  Stalled Status
  MOV  BH,(TDBabbleDetected SHR 16)    ;Write the
  CALL WriteYesNoALBH                  ;  Babble Status
  MOV  BH,(TDDataBuffErr SHR 16)       ;Write the
  CALL WriteYesNoALBH                  ;  Data Buffer Error Status
  MOV  BH,(TDCRCTOReceived SHR 16)     ;Write the
  CALL WriteYesNoALBH                  ;  CRC/Timeout Status
  MOV  BH,(TDBitStuffError SHR 16)     ;Write the
  CALL WriteYesNoALBH                  ;  Bit Sufffing Error Status
  CALL Write2Spaces                    ;Move over
  MOV  EAX,[DI].TDLinkPointer          ;Get the Link Pointer
  CALL WritePtrType                    ;Write the Pointer information
T90:                                   ;We're done
  POP  SI,DI,EDX,CX,BX,EAX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE TYPE-SPECIFIC DETAILS OF A TRANSFER DESCRIPTOR
;Inputs:  ES:[DI] = TD to write
;         DS = Local Data Area
;         ES = TSR Data Area
;         TSR Data already copied to Local data area
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
WriteTDSpecificData:
  PUSH AX,BX,DX             ;Save used registers
  CALL GetTDType            ;Get the Type of TD
  MOV  BX,TDTypeSpecificTbl ;See if this type
  CALL SearchByte2WordTblCS ;  is in our table (returns BX)
  JC  >S90                  ;If not, just quit
  CALL BX                   ;If so, handle it
  CALL WriteCrLfPause2      ;Move down
S90:                        ;Done
  POP  DX,BX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE SPECIFIC DETAILS OF A CONTROL TRANSFER DESCRIPTOR
;Inputs:  ES:[DI] = TD to write
;         DS = Local Data Area
;         ES = TSR Data Area
;         TSR Data already copied to Local data area
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteTDControlSetup:
  PUSH DX                 ;Save used registers
  MOV  DX,SIDSetupStage   ;Point at Stage Message
  JMP >C00                ;Do it
WriteTDControlData:
  PUSH DX                 ;Save used registers
  MOV  DX,SIDDataStage    ;Point at Stage Message
  JMP >C00                ;Do it
WriteTDControlStatus:
  PUSH DX                 ;Save used registers
  MOV  DX,SIDStatusStage  ;Point at Stage Message
;  JMP >C00                ;Do it
C00:
  PUSH AX,BX,CX,DI        ;Save used Registers
  PUSH DX                 ;Save Stage String
  MOV  DX,SIDControl      ;Write the
  CALL WriteZPause        ;  Header
  POP  DX                 ;Get Stage String Back
  CALL WriteZPause        ;Write the Current Stage
  CALL WriteSpace         ;Move over
  CALL WriteTimeOut       ;Write the Timeout
  CALL Write3Spaces       ;Move over
  CALL WriteCtlRetries    ;Write the Number of Retires Left
  CALL Write2Spaces       ;Move over
  CALL TDOffset2Index     ;Write
  MOV  AX,CX              ;  the
  CALL WordToString       ;  Handle Number
  CALL WriteCrLfPause2    ;Move down
  CALL FindSRGivenTD      ;Get the SetupRequest Pointer (BX)
  CALL InitCmdTail        ;Initialize the command tail
  MOV  DX,ControlPktMsg   ;Append the Base Option
  CALL AppendString2Cmd   ;  to the command tail
  MOV  AX,ES              ;Append the
  MOV  CX,BX              ;  data address
  CALL AppendSegOff2Cmd   ;  to the command tail
  CALL AppendCallBack2Cmd ;Append the Call-Back address to the command tail
  MOV  DI,SupportFileGen  ;[DI] = Exec File Name
  CALL HandleExecCall     ;Do it
  POP  DI,CX,BX,AX        ;Restore used registers
  POP  DX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE SPECIFIC DETAILS OF A BULK TRANSFER DESCRIPTOR
;Inputs:  ES:[DI] = TD to write
;         DS = Local Data Area
;         ES = TSR Data Area
;         TSR Data already copied to Local data area
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteTDBulk:
  PUSH AX,CX,DX                      ;Save used registers
  MOV  DX,SIDBulk                    ;Write the
  CALL WriteZPause                   ;  Header
  MOV  AX,[DI].TDBytesToXfer         ;Write the number
  CALL WordToString                  ;  of Bytes in the entire Transfer
  CALL WriteSpace                    ;Move over
  CALL WriteTimeOut                  ;Write the Timeout Left
  CALL WriteSpace                    ;Move over
  PUSH DI                            ;Save Pointer
  MOV  DI,W [DI].TDBulkQHOffset      ;Get the
  CALL QHOffset2Index                ;  QH Index Number
  POP  DI                            ;Restore Pointer
  MOV  AX,CX                         ;Write the
  CALL WordToString                  ;  Queue Head Index
  ADD  AX,(TDEntries-1)              ;Convert Index to a Handle Number
  CALL Write3Spaces                  ;Move over
  MOV  DX,SIDYesMsgY                 ;Assume TD is last in Queue
  TEST [DI].TDFlags,TDFlagLastBulkTD ;Is it last in Queue?
  JNZ >B30                           ;If so, continue
  MOV  DX,SIDNoMsgN                  ;If not, write no
B30:                                 ;Write Last TD status
  CALL WriteZPause                   ;Write it
  CALL Write2Spaces                  ;Move over
  CALL WordToString                  ;Write the Index
  POP  DX,CX,AX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE SPECIFIC DETAILS OF A ONE-TIME INTERRUPT TRANSFER DESCRIPTOR
;Inputs:  ES:[DI] = TD to write
;         DS = Local Data Area
;         ES = TSR Data Area
;         TSR Data already copied to Local data area
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteTDInterrupt1Time:
  PUSH AX,CX,DX                ;Save used registers
  MOV  DX,SIDOneTimeInt        ;Write the
  CALL WriteZPause             ;  Header
  MOV  AX,W [DI].TDPeriodicity ;Get the Time Left
  MOV  DX,AX                   ;Save it
  PUSH DI                      ;Save Pointer
O10:                           ;Loop to here to Find FL this is under
  CALL FindTDInOtherTDs        ;In another TD?
  JNC  O10                     ;If so, keep looking for FL
  CALL FindTDinFLs             ;If not, find the FL
  JC  >O40                     ;If none, quit (this shouldn't happen!)
  CALL FLOffset2Index          ;Convert it to an Index (CX)
  CALL GetFrameIndex           ;Get Current Frame Index (AX)
  ADD  DX,CX                   ;Calculate
  CMP  AX,CX                   ;  the total
  JBE >O20                     ;  time
  ADD  DX,1023                 ;  left
O20:                           ;DX Set correctly base on whether AX > CX
  SUB  DX,AX                   ;Calculate real time left
  MOV  AX,DX                   ;Put it in AX
O40:                           ;Done calculating Time Left
  POP  DI                      ;Restore Pointer
O50:                           ;AX = Time Left (Frames)
  CALL WriteFramesAsSeconds    ;Write it
  CALL Write2Spaces            ;Move over
  CALL TDOffset2Index          ;Write
  MOV  AX,CX                   ;  the
  CALL WordToString            ;  Handle Number
  POP  DX,CX,AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE SPECIFIC DETAILS OF A PERIODIC INTERRUPT TRANSFER DESCRIPTOR
;Inputs:  ES:[DI] = TD to write
;         DS = Local Data Area
;         ES = TSR Data Area
;         TSR Data already copied to Local data area
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteTDInterruptPer:
  PUSH AX,CX,DX,DI             ;Save used registers
  MOV  DX,SIDPeriodicInt       ;Write the
  CALL WriteZPause             ;  Header
  MOV  AX,W [DI].TDPeriodicity ;Write the
  CALL WordToString            ;  Periodicity
  CALL Write2Spaces            ;Move over
  MOV  AX,[DI].TDLastFrameUsed ;Write the
  CALL WordToString            ;  Frame Number
  MOV  CL,6                    ;Move
  CALL WriteSpaces             ;  over
  MOV  DX,SIDYesMsgY           ;Assume Specific Frame
  TEST [DI].TDFlags,TDFlagSpecificFrame ;Specific Frame?
  JNZ >I30                     ;If so, continue
  MOV  DX,SIDNoMsgN            ;Not Specific Frame
I30:                           ;Write Specifc Frame Message
  CALL WriteZPause             ;Write the message
  CALL WriteSpace              ;Move over
  MOV  AX,[DI].TDBytesToXfer   ;Write the Total
  CALL WordToString            ; Transaction Bytes
  CALL Write3Spaces            ;Move over
  MOV  DX,[DI].TDIntQHOffset   ;Get the possible QH Offset
  OR   DX,DX                   ;Is there a Queue?
  JZ  >I40                     ;If not, jump to handle it
  MOV  DI,DX                   ;If so, put the pointer in DI
  CALL QHOffset2Index          ;Convert it to an Index
  MOV  AL,CL                   ;Write
  CALL ByteToString            ;  it
  MOV  DI,[DI].QHIntTDOffset   ;Point at the First TD Pointer
  JMP >I50                     ;Jump to write it
I40:                           ;No QH
  MOV  DX,SIDNAMsg             ;Write the
  CALL WriteZPause             ;  NA Message
I50:                           ;Write the Index
  CALL Write2Spaces            ;Move over
  CALL TDOffset2Index          ;Write
  MOV  AX,CX                   ;  the
  CALL WordToString            ;  Handle Number
  POP  DI,DX,CX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE SPECIFIC DETAILS OF AN ISOCHRONOUS TRANSFER DESCRIPTOR
;Inputs:  ES:[DI] = TD to write
;         DS = Local Data Area
;         ES = TSR Data Area
;         TSR Data already copied to Local data area
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
#IF !LITE ;WriteTDIsoch

WriteTDIsoch:
  PUSH AX,BX,CX,DX,SI            ;Save used registers
  MOV  DX,SIDIsoch               ;Write the
  CALL WriteZPause               ;  Header
  CALL Write4Spaces              ;Move over
  MOV  AL,B [DI].TDIsochSequence ;Write the
  CALL ByteToString              ;  Sequence Number
  CALL Write2Spaces              ;Move over
  MOV  AX,W [DI].TDPeriodicity   ;Write the
  CALL WordToString              ;  Periodicity
  CALL Write2Spaces              ;Move over
  MOV  AX,[DI].TDLastFrameUsed   ;Write the
  CALL WordToString              ;  Frame Number
  CALL Write2Spaces              ;Move over
  MOV  BX,W [DI].TDIsochHandle   ;Get the Handle Number
  XOR  DX,DX                     ;Start Byte Counter
  XOR  SI,SI                     ;  at 0
  XOR  AX,AX                     ;Start Packet Counter at 0
  MOV  DI,TDOffset               ;Point at the Table
  MOV  CX,TDEntries              ;Number of Table Entries
I10:                             ;Loop to here for each TD to test
  PUSH AX                        ;Save Counter
  CALL GetTDType                 ;Is it an
  CMP  AL,TDTypeIsoch            ;  Isochronous TD?
  POP  AX                        ;Restore Counter
  JNE >I20                       ;If not, skip it
  CMP  BX,W [DI].TDIsochHandle   ;Is it the same Handle number as us?
  JNE >I20                       ;If not, it's a different transaction
  INC  AX                        ;Increment the Packet Counter
  ADD  SI,[DI].TDBytesToXfer     ;Add the Bytes to the Running Total
  ADC  DX,0                      ;If overflow, increment DX
I20:                             ;Done with this TD
  ADD  DI,TDSize                 ;Point at next TD
  LOOP I10                       ;Keep going until we're done
  CALL WordToString              ;Write the Packet Counter
  CALL WriteSpace                ;Move over
  MOV  AL,' '                    ;Assume no overflow
  OR   DX,DX                     ;Overflow?
  JZ  >I40                       ;If not, continue
  MOV  AL,'>'                    ;If so, write >
  MOV  SI,-1                     ;Write 65535
I40:                             ;Have space or > calculated
  CALL WriteAL                   ;Write the Space or >
  MOV  AX,SI                     ;Write the
  CALL WordToString              ;  number of bytes
  CALL Write2Spaces              ;Move over
  MOV  AX,BX                     ;Write the
  CALL WordToString              ;  Handle Number
  POP  SI,DX,CX,BX,AX            ;Restore used registers
  RET

#ENDIF ;WriteTDIsoch

;------------------------------------------------------------------------------
;WRITE NUMBER OF RETRIES LEFT IN CONTROL TRANSACTION
;Inputs:  ES:[DI] = TD to write
;         DS = Local Data Area
;         ES = TSR Data Area
;         TSR Data already copied to Local data area
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteCtlRetries:
  PUSH AX,CX,DI               ;Save used registers
  MOV  CL,[DI].TDTimeoutIndex ;Get the
  CALL TTIndex2Offset         ;  Timeout
  XOR  AX,AX                  ;AX =
  MOV  AL,[DI].TTFlags        ;  Retry
  SHR  AX,5                   ;  Counter
  OR   AX,AX                  ;Is it 0?
  JNZ >C10                    ;If not, it's OK
  MOV  AX,8                   ;If so, it's actually 8
C10:                          ;AL = Retry Counter
  DEC  AX                     ;Convert to Retries Left Value
  CALL WordToString           ;Write it
  POP  DI,CX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE TIMEOUT ASSOCIATED WITH A BULK OR CONTROL TD
;Inputs:  ES:[DI] = TD to get data from (Bulk or Control)
;         DS = Local Data Area
;         ES = TSR Data Area
;         TSR Data already copied to Local data area
;Outputs: To Screen
;Chnages:
;------------------------------------------------------------------------------
WriteTimeOut:
  PUSH AX,CX,DI               ;Save used registers
  MOV  CL,[DI].TDTimeOutIndex ;Get the Timeout Table Index
  CALL TTIndex2Offset         ;Get the number of Timer Ticks
  MOV  AX,[DI].TTDelayCounter ;  Left in the TimeOut
  CALL WriteTicksAsSeconds    ;Write Timer Ticks as Seconds
T90:                          ;Done
  POP  DI,CX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A FRAME COUNT AS SECONDS
;Inputs:  AX = Number of Frames (milliseconds)
;Outputs: To Screen, in xxx.xxx format
;Changes:
;------------------------------------------------------------------------------
WriteFramesAsSeconds:
  PUSH AX,CX,DX       ;Save used registers
  XOR  DX,DX          ;Calculate the
  MOV  CX,1000        ;  number of
  DIV  CX             ;  whole seconds
  CALL ByteToString   ;Write it
  CALL WritePeriod    ;Write the Decimal Point
  MOV  AX,DX          ;Work with
  XOR  DX,DX          ;  the Remainder
  MOV  CX,100         ;Calculate
  DIV  CX             ;  Tenths
  CALL WriteNibbleHex ;Write it
  MOV  AX,DX          ;Work with
  XOR  DX,DX          ;  the Remainder
  MOV  CX,10          ;Calculate
  DIV  CX             ;  Hundredths
  CALL WriteNibbleHex ;Write it
  MOV  AX,DX          ;Write
  CALL WriteNibbleHex ;  Thousandths
S90:                  ;Done
  POP  DX,CX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A TIMER TICK COUNT AS SECONDS
;Inputs:  AX = Number of Timer Ticks
;Outputs: To Screen, in xxxxx.xx format
;Changes:
;------------------------------------------------------------------------------
WriteTicksAsSeconds:
  PUSH AX,BX,CX,DX    ;Save used registers
  MOV  BX,18206       ;Ticks to Seconds factor
  MOV  CX,1000        ;Divide
  MUL  CX             ;  by 18.206
  DIV  BX             ;  (ticks per second)
  CALL WordToString   ;Write whole seconds
  CALL WritePeriod    ;Write the Decimal Point
  MOV  AX,DX          ;Work with the Remainder
  MOV  CX,10          ;Calculate
  MUL  CX             ;  Tenths
  DIV  BX             ;  Part
  CALL WriteNibbleHex ;Write it
  MOV  AX,DX          ;Work with the Remainder
  MOV  CX,10          ;Calculate
  MUL  CX             ;  Hundredths
  DIV  BX             ;  Part
  CALL WriteNibbleHex ;Write it
S90:                  ;Done
  POP  DX,CX,BX,AX    ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE CONTENTS OF NEW DEVICE NOTIFICATION TABLE
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE NEW DEVICE NOTIFICATION TABLE TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;Changes:
;------------------------------------------------------------------------------
WriteNDStatus:
  PUSH DI                 ;Save used registers
  CALL InitCmdTail        ;Initialize the command tail
  MOV  DX,NMsg            ;Write an "N" (New Device)
  CALL AppendString2Cmd   ;  to the command tail
  CALL AppendCallBack2Cmd ;Append the Call-Back address to teh command tail
  MOV  DI,SupportFileADND ;[DI] = Exec File to Call
  CALL HandleExecCall     ;Execute the Support File
  POP  DI                 ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE DEVICE ADDRESS TABLE STATUS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE CURRENT DEVICE ADDRESS STATUS TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteADStatus:
  PUSH AX,DX,DI             ;Save used registers
  CALL InitCmdTail          ;Initialize the command tail
  MOV  DI,HostIndexMsg      ;Point at the Host Index String
  MOV  AL,ES:[USBHostIndex] ;Get our Host Index
  MOV  AH,' '               ;Assume Host Index < 10
  CMP  AL,10                ;Is the Host Index < 10?
  JB  >A20                  ;If so, continue
  MOV  AH,'1'               ;If not, we need to write a 1
  SUB  AL,10                ;  and Subtract 10
A20:                        ;AH contains first numeral
  MOV  [DI],AH              ;Store the first numeral
  ADD  AL,'0'               ;Convert the remainder to a numeral
  MOV  [DI+1],AL            ;Store it
  MOV  DX,DI                ;Append the Host Index
  CALL AppendString2Cmd     ;  to the command tail
  CALL AppendCallBack2Cmd   ;Append the Call-Back Address to the command tail
  MOV  DI,SupportFileADND   ;[DI] = Exec File to Call
  CALL HandleExecCall       ;Execute the Support File
  POP  DI,DX,AX             ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE DESCRIPTORS STATUS
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;WRITE THE DESCRIPTORS FOR A DEVICE AND QUIT, IF APPROPRITE
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         [DescrAddr] (0 = Do nothing, -1 = Last Enumerated, else Specific Addr)
;Outputs: To Screen
;Changes: Quits Program
;------------------------------------------------------------------------------
DoDescriptors:
  PUSH AX,DI               ;Save used registers
  MOV  AL,[DescrAddr]      ;Get the Descriptor Address to use
  OR   AL,AL               ;Do we need to do anything at all?
  JZ  >D90                 ;If not, quit
  CMP  AL,-1               ;Do we need to do the Last Enumerated Device?
  JNE >D20                 ;If not, handle a specific Device
D10:                       ;Do Last Enumerated Device
  MOV  DI,ES:[DvcDescrPtr] ;ES:[DI] = Data to write
  CALL WriteDescriptors    ;Write the Descriptors of the Last Enumerated Device
  JMP >D50                 ;Done
D20:                       ;Write Descriptors of Specific Device
  CALL GetDescriptors      ;Download & write the Descriptors (uses AL)
D50:                       ;Done writing Descriptors
  XOR  AL,AL               ;ErrorLevel = 0
  MOV  DX,NoMsg            ;Write Nothing
  JMP  Exit                ;Exit program

D90:                       ;Done
  POP  DI,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE DESCRIPTORS OF THE LAST ENUMERATED DEVICE TO THE SCREEN
;Inputs:  [DI] = Descriptor Data to write
;         DS = Local Data Area
;         ES = TSR Data Area
;Outputs: To Screen
;Changes: DI
;------------------------------------------------------------------------------
WriteDescriptors:
  PUSH AX,CX,DX,DI              ;Save used registers
  MOV  AL,ES:[LastAddressUsed]  ;Get the Address we're writing
  OR   AL,AL                    ;Any devices yet?
  JNZ >W10                      ;If so, continue
  MOV  DX,SIDDvcNotYet          ;If not, write the
  CALL WriteZPause              ;  Error Message
  CALL WriteCrLfPause2          ;Move down
  JMP >W90                      ;Done
W10:                            ;At least one device has been attached
  MOV  DX,SIDDvcAddr            ;Write the
  CALL WriteZPause              ;  Device
  CALL ByteToString             ;  Address
  PUSH DI                       ;Save used Registers
  MOV  CL,AL                    ;Is the Address
  CALL TestDvcAddress           ;  still there (Returns DI)?
  JNC >W20                      ;If Device still there, continue
  POP  DI                       ;Restore used registers
  CALL WriteCrLfPause           ;Write the message
  MOV  DX,SIDDvcNoMore          ;  Saying that the Device
  CALL WriteZPause              ;  is gone
  JMP >W30                      ;Continue
W20:                            ;Device Address is written
  CALL WriteCrLfPause           ;Write a new line
  MOV  DX,SIDDvcConfig          ;Write
  CALL WriteZPause              ;  the
  MOV  AL,ES:[DI].ADConfigValue ;  Configuration
  CALL ByteToString             ;  value
  POP  DI                       ;Restore used registers
W30:                            ;Done with Address Stuff
  CALL WriteCrLfPause2          ;Skip a couple of lines
W40:                            ;Valid Device Address
  CALL InitCmdTail              ;Initialize the Command tail
  MOV  DX,DescriptorMsg         ;Append the Base Option
  CALL AppendString2Cmd         ;  to the command tail
  MOV  AX,ES                    ;Append the
  MOV  CX,DI                    ;  Descriptor Address
  CALL AppendSegOff2Cmd         ;  to the command tail
  MOV  AL,ES:[USBHostIndex]     ;Append the Host Index
  CALL AppendHexByte2Cmd        ;  to teh command tail
  MOV  AL,ES:[LastAddressUsed]  ;Append the Device Address
  CALL AppendHexByte2Cmd        ;  to the command tail
  CALL AppendCallBack2Cmd       ;Append Call Back Address to Command Tail
  MOV  DI,SupportFileGen        ;[DI] = Exec File Name
  CALL HandleExecCall           ;Call the Exec Function
  JNC >W90                      ;If it worked, quit
  CALL WriteCrLfPause2          ;If it didn't work, move down
W90:                            ;Done
  POP  DI,DX,CX,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DOWNLOAD & WRITE THE DESCRIPTORS FOR A SPECIFIC DEVICE
;Inputs:  AL = Device Address to write data for
;         DS = Local Data Area
;         ES = TSR Data Area
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
GetDescriptors:
  PUSH AX,CX,DI,SI,DS            ;Save used registers
  MOV  SI,Int14Request           ;[SI] = Request Structure
  MOV  [SI].I14RDeviceAddress,AL ;Store Device Address
  MOV  AL,ES:[USBHostIndex]      ;Store
  MOV  [SI].I14RHostIndex,AL     ;  Host Index
  MOV  ES,DS                     ;ES = Local Data Area
  MOV  [DvcDescrPtr],FrameAndStackBuff                ;Initialize
  MOV  [CfgDescrPtr],(FrameAndStackBuff+DvcDescrSize) ;  Data Pointers
  CALL ClearDCDescriptorData     ;Clear out the Data Area
  MOV  [SI].I14RRequestType,I14RRTDoControl ;Request = Control
  MOV  DI,SI                     ;[DI] = Request Structure
  MOV  CX,GetDvcDescrReq         ;Copy the
  CALL CopySetupReqToInt14CXDI   ;  Request
  MOV  W [SI].I14RDataAddress[2],DS                ;Store the
  MOV  W [SI].I14RDataAddress[0],FrameAndStackBuff ;  Data Address
  MOV  W [SI].I14RCallBackAddr[2],CS               ;Store the
  MOV  W [SI].I14RCallBackAddr[0],DoHostFarCall    ;  Call Back Address
  MOV  [DoHostReturnAX],-1       ;Initialize Return
  CALL DoInt14CallSI             ;Send the Request
  JC  >G70                       ;If error, quit (No Device)
  CALL WriteCR                   ;Delay
G10:                             ;Loop to here to wait for data
  MOV  AX,[DoHostReturnAX]       ;Is there
  CALL WriteCR                   ;Delay
  CMP  AX,-1                     ;  data yet?
  JE   G10                       ;If not, keep waiting
  OR   AX,AX                     ;Is the data valid?
  JNZ >G70                       ;If not, error
G20:                             ;Got Device Descriptor
  MOV  DI,[CfgDescrPtr]          ;[DI] = Configuration Decriptor Buffer
  MOV  CX,(CfgDescrSize+CfgDescrXBytes) ;CX = Size of Buffer
  MOV  W [SI].I14RDataAddress[0],DI     ;Store Buffer Pointer
  CALL GetConfigDescrs           ;Download the complete configuration
  JC  >G72                       ;If error, quit
  CALL InitCmdTail               ;Initialize the Command Tail
  MOV  DX,DescriptorMsg          ;Append the Base Option
  CALL AppendString2Cmd          ;  to the command tail
  MOV  AX,DS                     ;Append the
  MOV  CX,[DvcDescrPtr]          ;  data address
  CALL AppendSegOff2Cmd          ;  to the command tail
  MOV  AL,[SI].I14RHostIndex     ;Append the Host Index
  CALL AppendHexByte2Cmd         ;  to the command tail
  MOV  AL,[SI].I14RDeviceAddress ;Append the Device Address
  CALL AppendHexByte2Cmd         ;  to the command tail
  CALL AppendCallBack2Cmd        ;Append Call Back Address to Command Tail
  MOV  DI,SupportFileGen         ;[DI] = Exec File Name
  CALL HandleExecCall            ;Call the Exec Function
  JMP >G90                       ;Done
G70:                             ;Error - No Device
  MOV  DX,SIDRptNoDvc0           ;Write
  CALL WriteZPause               ;  the
  MOV  AL,[SI].I14RDeviceAddress ;  Device
  CALL WriteByteMin              ;  Address
  MOV  DX,SIDDescrNoDvc          ;Write the
  CALL WriteZPause               ;  end message
  JMP >G78                       ;Done
G72:                             ;Error downloading Descriptors
  MOV  DX,SIDDescrNoData         ;Write
  CALL WriteZPause               ;  the
  MOV  AL,[SI].I14RDeviceAddress ;  Device
  CALL WriteByteMin              ;  Address
  CALL WriteDot                  ;Write a Dot
G78:                             ;Move down after writing message
  CALL WriteCrLfPause            ;Move down
G90:                             ;Done
  POP  DS,SI,DI,CX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DOWNLOAD THE COMPLETE CONFIGURATION DESCRIPTOR FOR A DEVICE
;Inputs:   DS = ES = Local Data Area
;         [SI] = Int 14 Request Structure to use
;                Host Index, Device Address, & Data Address filled in
;          CX  = Maximum Data Size to download
;Outputs:  CF  = Clear if OK (Data Downloaded)
;                [DI] = Filled with Data
;              = Set if Error (Unable to Download Data)
;                [DI] = Undefined
;Changes: values in [SI]
;------------------------------------------------------------------------------
GetConfigDescrs:
  PUSH AX,BX,CX,DI,SI                ;Save used registers
  MOV  BX,CX                         ;Save buffer size
  MOV  DI,SI                         ;[DI] = Request Structure
  MOV  [SI].I14RRequestType,I14RRTDoControl ;Request = Control
  MOV  CX,GetCfgDescrReq             ;Copy the Get Configuration Request
  CALL CopySetupReqToInt14CXDI       ;  into the Int 14h Request
  MOV  W [SI].I14RCallBackAddr[2],CS            ;Store the
  MOV  W [SI].I14RCallBackAddr[0],DoHostFarCall ;  Call Back Address
  MOV  [DoHostReturnAX],-1           ;Initialize Return
  CALL DoInt14CallSI                 ;Issue the Request
  JC  >C70                           ;If error, quit
  CALL WriteCR                       ;Delay
C10:                                 ;Loop to here to wait for data
  MOV  AX,[DoHostReturnAX]           ;Is there
  CALL WriteCR                       ;Delay
  CMP  AX,-1                         ;  data yet?
  JE   C10                           ;If not, keep waiting
  OR   AX,AX                         ;Is the data valid?
  JNZ >C70                           ;If not, error
C20:                                 ;Have the Configuration Descriptor
  PUSH ES                            ;Save used registers
  MOV  ES,W [SI].I14RDataAddress[2]  ;ES:[DI] =
  MOV  DI,W [SI].I14RDataAddress[0]  ;  Buffer Address
  MOV  AX,ES:[DI].CDTotalLength      ;AX = Complete Descriptor Length
  POP  ES                            ;Restore used registers
  CMP  AX,BX                         ;Will it fit into the buffer?
  JBE >C30                           ;If so, continue
  MOV  AX,BX                         ;If not, adjust size
C30:                                 ;AX = Complete Config Size
  MOV  W [SI].I14RGetCfgDescrSize,AX ;Store the size
  MOV  [DoHostReturnAX],-1           ;Initialize Return
  CALL DoInt14CallSI                 ;Issue teh Request
  JC  >C70                           ;If error, quit
  CALL WriteCR                       ;Delay
C40:                                 ;Loop to here to wait for data
  MOV  AX,[DoHostReturnAX]           ;Is there
  CALL WriteCR                       ;Delay
  CMP  AX,-1                         ;  data yet?
  JE   C40                           ;If not, keep waiting
  OR   AX,AX                         ;Is the data valid?
  JZ  >C80                           ;If so, we're done
C70:                                 ;Error
  STC                                ;Set return flag
  JMP >C90                           ;Done
C80:                                 ;OK
  CLC                                ;Set return flag
C90:                                 ;Done
  POP  SI,DI,CX,BX,AX                ;Restore used registers
  RET


;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
;WRITE REPORT DESCRIPTOR OF HID DEVICE
;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

;------------------------------------------------------------------------------
;DOWNLOAD AND WRITE THE REPORT DESCRIPTOR FOR AN HID DEVICE
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;Outputs: To Screen
;Changes: Quits Program
;------------------------------------------------------------------------------
DoReportDescr:
  CMP  [ReportAddr],0 ;Anything to do?
  JNE >R00            ;If so, continue
  RET

R00:                         ;Need to get Report Descriptor
  MOV  SI,Int14Request       ;[SI] = Request Structure
  MOV  AL,ES:[USBHostIndex]  ;Store
  MOV  [SI].I14RHostIndex,AL ;  Host Index
  MOV  ES,DS                 ;DS = Local Data Area
  MOV  [DvcDescrPtr],FrameAndStackBuff ;Initialize the Buffer Pointer
  CALL TestRptParams         ;Is it a valid HID Device (quits if not)?
  CALL GetRptData            ;Download the Report data (quits if error)
R20:                         ;The Report Data is in the FrameAndStackBuff
  CALL InitCmdTail           ;Initialize the Command Tail
  MOV  DX,RptDescrMsg        ;Append the Base Option
  CALL AppendString2Cmd      ;  to the command tail
  MOV  AX,DS                 ;Append the
  MOV  CX,[DvcDescrPtr]      ;  data address
  CALL AppendSegOff2Cmd      ;  to the command tail
  CALL AppendCallBack2Cmd    ;Append the Call-Back address to the command tail
  MOV  DI,SupportFileGen     ;[DI] = Exec File Name
  CALL HandleExecCall        ;Do it
  MOV  DX,NoMsg              ;Write nothing
  XOR  AL,AL                 ;ErrorLevel = 0
  JMP  Exit

;------------------------------------------------------------------------------
;TEST THE USER-PROVIDED DEVICE/INTERFACE PARAMETERS FOR A REPORT DESCRIPTOR
;Inputs:  DS = ES = Local Data Area
;         [SI] = Int 14 Request to use, with Host Index filled in
;         [ReportAddr], [ReportIntf]
;Outputs: If valid Device exists, returns with I14RDeviceAddress filled in
;         If invalid, quits program with correct screen messages
;Changes:
;------------------------------------------------------------------------------
TestRptParams:
  PUSH AX,BX,CX,DX               ;Save used registers
  MOV  AL,[ReportAddr]           ;Store the
  MOV  [SI].I14RDeviceAddress,AL ;  Device Address
  MOV  AL,[ReportIntf]           ;Store the
  MOV  [SI].I14RInterfaceNum,AL  ;  Interface Number
  MOV  B [SI].I14RAltInterface,0 ;Start with Alt Interface 0
P10:                             ;Test Device Info
  MOV  [SI].I14RRequestType,I14RRTGetDvcClassInfo ;Request = Get Dvc Class Info
  MOV  DX,SI                     ;Get the
  CALL DoInt14CallDX             ;  Data
  JC  >P70                       ;If error, quit
  OR   BX,BX                     ;Device Class & SubClass = None?
  JNZ >P70                       ;If not, error
  OR   CL,CL                     ;Device Protocol = None?
  JNZ >P70                       ;If not, error
P20:                             ;Test Interface Info
  MOV  [SI].I14RRequestType,I14RRTGetAltIntfInfo ;Request = Get Intf Class Info
P30:                             ;Loop to here to find Selected Interface
  MOV  DX,SI                     ;Get the
  CALL DoInt14CallDX             ;  Data
  JNC >P40                       ;If no error, continue
  CMP  AX,I14RErrAltIntf         ;Illegal Alternate Interface?
  JE  >P70                       ;If so, error
P40:                             ;Valid Data
  TEST CH,AltIntfInfoSelected    ;Is this Alternate Interface Selected?
  JNZ >P50                       ;If so, continue
  INC  B [SI].I14RAltInterface   ;If not, try the next Alternate Interface
  JMP  P30                       ;Do it again
P50:                             ;Is selected Alternate Interface
  CMP  BL,IntfClassHID           ;Class = Human Interface Device?
  JE  >P90                       ;If so, we're done
P70:                             ;No Device/Not HID
  MOV  DX,SIDRptNoDvc0           ;Write
  CALL WriteZPause               ;  the
  MOV  AL,[ReportAddr]           ;  Device
  CALL WriteByteMin              ;  Address
  MOV  DX,SIDRptNoDvc1           ;Write
  CALL WriteZPause               ;  the
  MOV  AL,[ReportIntf]           ;  Interface
  CALL WriteByteMin              ;  Number
  MOV  DX,SIDRptNoDvc2           ;Point at end message
  XOR  AL,AL                     ;ErrorLevel = 0
  JMP  Exit

P90:                             ;Done
  POP  DX,CX,BX,AX               ;Restore used registers
  RET

;---------------------------------------------------------------------------------------------------------------------------------------
;DOWNLOAD THE HID REPORT DESCRIPTOR DATA
;Inputs:  DS = ES = Local Data Area
;         [SI] = Int 14 Request to use, with Host & Address filled in
;         ReportAddr, ReportIntf
;Outputs: If Data was downloaded, Dvc Descr Buffer = filled with Report Data
;         If error, quits program
;Changes:
;NOTES: On one of my computers (a Dell Studio 540 Desktop), this routine
;         hangs if I don't periodically send something to the screen.
;         That's what the WriteCR's are for.  It's VERY strange, and I
;         have no idea why it's happening.  Maybe someday I'll figure it
;         out, but actually suspect a hardware problem with the Intel
;         Host Controller.
;------------------------------------------------------------------------------
GetRptData:
  PUSH AX,BX,CX,DX,DI                   ;Save used registers
  MOV  DI,SI                            ;Save Int 14 Request in DI
  CALL ClearDCDescriptorData            ;Clear out the Data Area
  MOV  W [SI].I14RDataAddress[2],DS                ;Store the
  MOV  W [SI].I14RDataAddress[0],FrameAndStackBuff ;  Data Address
  MOV  CX,(DvcDescrSize+CfgDescrSize+CfgDescrXBytes) ;CX = Buffer Size
  CALL GetConfigDescrs                  ;Download the complete configuration
  JC  >D70                              ;If error, quit
D10:                                    ;Have the Configuration Data
  MOV  DI,[DvcDescrPtr]                 ;[DI] = Data
  MOV  BL,[ReportIntf]                  ;BL = Interface Number to look for
D20:                                    ;Loop to find Interface Descriptor
  MOV  AL,DescrTypeInterface            ;Look for an Interface
  CALL FindDescrType                    ;  Descriptor (rtns AX, DI)
  JC  >D70                              ;If none found, Error
  CMP  BL,[DI].IDInterfaceNumber        ;Is it the Correct Interface?
  JE  >D30                              ;If so, continue
  ADD  DI,AX                            ;If not, point at the next Descr
  JMP  D20                              ;Keep looking
D30:                                    ;Found the Interface Descriptor
  MOV  AL,DescrTypeHID                  ;Look for an HID
  CALL FindDescrType                    ;  Descriptor (rtns AX, DI)
  JC  >D70                              ;If none found, Error
D40:                                    ;[DI] = HID Report Descriptor
  MOV  AX,[DI].HIDDDescriptorLength     ;AX =  Report Size
  CMP  AX,CX                            ;Will it fit in the Buffer?
  JBE >D50                              ;If so, continue
  MOV  AX,CX                            ;If not, adjust size
D50:                                    ;AX = Report Size
  CALL ClearDCDescriptorData            ;Clear out the Data Area
  MOV  [SI].I14RRequestType,I14RRTDoControl ;Request = Control
  MOV  W [SI].I14RCallBackAddr[2],CS               ;Store the
  MOV  W [SI].I14RCallBackAddr[0],DoHostFarCall    ;  Call Back Address
  MOV  W [SI].I14RDataAddress[2],DS                ;Store the
  MOV  W [SI].I14RDataAddress[0],FrameAndStackBuff ;  Data Addreaa
  MOV  DI,SI                            ;[DI] = Int 14 Request
  MOV  CX,GetReportDescrReq             ;Copy
  CALL CopySetupReqToInt14CXDI          ;  Request Pkt
  MOV  W [SI].I14RGetReportDescrSize,AX ;Store number of bytes
  MOV  B [SI].I14RGetReportDescrIntf,BL ;Store Interface Number
  ;MOV  B [SI].I14RGetReportDescrRptID,0 ;Report ID 0 (all reports)
  MOV  [DoHostReturnAX],-1              ;Initialize Return
  CALL DoInt14CallSI                    ;Issue teh Request
  JC  >D70                              ;If error, quit
  CALL WriteCR                          ;Delay
D60:                                    ;Loop to here to wait for data
  MOV  AX,[DoHostReturnAX]              ;Is there
  CALL WriteCR                          ;Delay
  CMP  AX,-1                            ;  data yet?
  JE   D60                              ;If not, keep waiting
  OR   AX,AX                            ;Is the data valid?
  JZ  >D90                              ;If so, we're done
D70:                                    ;No Device/Not HID
  MOV  DX,SIDRptNoData                  ;Write
  CALL WriteZPause                      ;  the
  MOV  AL,[ReportAddr]                  ;  Device
  CALL WriteByteMin                     ;  Address
  CALL WriteDot                         ;Arite a period
  MOV  Dx,NoMsg                         ;Write nothing
  XOR  AL,AL                            ;ErrorLevel = 0
  JMP  Exit

D90:                                    ;Done
  POP  DI,DX,CX,BX,AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND A PARTICULAR TYPE OF DESCRIPTOR IN THE COMPLETE CONFIGURATION DESCRIPTOR
;Inputs:  DS = ES = Data Area where Descriptor is Stored
;         [DI] = Pointer to start/middle of Configuration Descriptor
;          AL  = Descriptor Type to find
;Outputs: CF = Set if OK (Descriptor Found)
;              [DI] points at beginning of Descriptor
;               AX = Descriptor Length
;            = Clear if Error (Descriptor not found)
;              AX, DI unchanged
;Changes:
;NOTES: This is only called from GetRptData, so we know where the end of
;         the buffer is!
;------------------------------------------------------------------------------
FindDescrType:
  PUSH BX,SI               ;Save used registers
  MOV  SI,DI               ;Point SI at the starting Pointer
  XOR  BH,BH               ;Initialize high byte of Size to 0
Y10:                       ;Loop here to find Descriptor
  MOV  BL,[SI].DDLength    ;Put the Length in BL
  OR   BL,BL               ;Valid Descriptor?
  JZ  >Y70                 ;If not, Error
  CMP  AL,[SI].DDDescrType ;The Descriptor we're looking for?
  JE  >Y80                 ;If so, we're done
  ADD  SI,BX               ;If not, point at next Descriptor
  CMP  SI,(FrameAndStackBuff+DvcDescrSize+CfgDescrSize+CfgDescrXBytes)
                           ;Gone past the end of the buffer?
  JBE  Y10                 ;If not, keep looking
Y70:                       ;Error
  STC                      ;Set Error Flag
  JMP >Y90                 ;Done
Y80:                       ;OK
  MOV  DI,SI               ;Update Pointer
  MOV  AX,BX               ;Put length in AX
  CLC                      ;Set OK Flag
Y90:                       ;Done
  POP  SI,BX               ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;PERFORM OPERATIONS TO CONTROL THE HOST (DEBUG, RESET, ETC.)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;DO SOMETHING TO CONTROL THE USB HOST (DEBUG, RESET, RUN, ETC>)
;Inputs:  ES = TSR Data Area
;         DS = Local Data Area
;         AL = Host Index to do it to (Our Host Number or AllHostsIndex)
;         AH = 0
;Outputs: CF = Clear if it worked OK
;            = Set if Error
;Changes:
;NOTES: Some hardware/Legacy Support BIOS Software (like that in my
;         Dell Desktop) does not process interrupts correctly, and
;         effectively disables/redirects INT 08 for periods of time.
;         This wreaks havoc with our program, and is why we need to
;         set up a method here of "monitoring" the Host to make sure
;         it doesn't get stalled out.
;       This effectively provides a Timing and Verification "wrapper"
;         around all Host Calls that Stop the Host.

;------------------------------------------------------------------------------
DoHostStop:
  PUSH CX,DX                  ;Save used registers
  MOV  CH,HostStatusStopped   ;AH = Status to achieve
  MOV  DX,DoHostStop0         ;DX = Code to call
  JMP >X00                    ;Do it
DoHostSuspend:
  PUSH CX,DX                  ;Save used registers
  MOV  CH,HostStatusSuspended ;AH = Status to achieve
  MOV  DX,DoHostSuspend0      ;DX = Code to call
  JMP >X00                    ;Do it
DoHostDebug:
  PUSH CX,DX                  ;Save used registers
  MOV  CH,HostStatusDebugMode ;AH = Status to achieve
  MOV  DX,DoHostDebug0         ;DX = Code to call
  JMP >X00                    ;Do it
DoHostReset:
  PUSH CX,DX                  ;Save used registers
  MOV  CH,HostStatusRunning   ;AH = Status to achieve
  MOV  DX,DoHostReset0        ;DX = Code to call
;  JMP >X00                    ;Do it
X00:
  PUSH AX,BX,SI               ;Save used registers
  MOV  SI,Int14Request4       ;[SI] = INT 14h Request to use
  MOV  [SI].I14RHostIndex,AL  ;Store Host Index
  MOV  [SI].I14RRequestType,I14RRTGetHostStatus ;Request = Get Host Status
  CALL DX                     ;Try to perform the function
  JNC >X80                    ;If it worked, we're done
  CMP  AL,AllHostsIndex       ;Is this for all Hosts?
  JE  >X80                    ;If so, we're done
  CALL DoInt14CallBXSI        ;Get the Host Status (BL)
  CMP  BL,CH                  ;Is the Host in the correct state?
  JE  >X80                    ;If so, we're done
  CMP  BL,HostStatusUnknown   ;If not, is it in an unknown state?
  JE  >X80                    ;If so, it's still transitioning and should be OK
  CALL DX                     ;If not, try to perform the function again
  JNC >X80                    ;If it worked, we're done
X70:                          ;Error
  STC                         ;Set return flag
  JMP >X90                    ;Done
X80:                          ;OK
  CLC                         ;Set return flag
X90:                          ;Done
  POP  SI,BX,AX               ;Restore used registers
  POP  DX,CX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DO SOMETHING TO CONTROL THE USB HOST (DEBUG, RESET, RUN, ETC>)
;Inputs:  ES = TSR Data Area
;         DS = Local Data Area
;         AL = Host Index to do it to (Our Host Number or AllHostsIndex)
;         AH = 0
;Outputs: CF = Clear if it worked OK
;            = Set if Error
;Changes:
;NOTES: Some hardware/Legacy Support BIOS Software (like that in my
;         Dell Desktop) does not process interrupts correctly, and
;         effectively disables/redirects INT 08 for periods of time.
;         This wreaks havoc with our program, and is why we need to
;         set up a method here of "monitoring" the Host to make sure
;         it doesn't get stalled out.
;------------------------------------------------------------------------------
DoHostDebug0:
  PUSH AX                            ;Save used registers
  MOV  AH,I14RRTHostDebug            ;AH = Request Type to Issue
  JMP >H00                           ;Do it
DoHostReset0:
  PUSH AX                            ;Save used registers
  MOV  AH,I14RRTHostReset            ;AH = Request Type to Issue
  JMP >H00                           ;Do it
DoHostResume:
  PUSH AX                            ;Save used registers
  MOV  AH,I14RRTHostResume           ;AH = Request Type to Issue
  JMP >H00                           ;Do it
DoHostRun:
  PUSH AX                            ;Save used registers
  MOV  AH,I14RRTHostRun              ;AH = Request Type to Issue
  JMP >H00                           ;Do it
DoHostSingleStep:
  PUSH AX                            ;Save used registers
  MOV  AH,I14RRTHostSingleStep       ;AH = Request Type to Issue
  JMP >H00                           ;Do it
DoHostStop0:
  PUSH AX                            ;Save used registers
  MOV  AH,I14RRTHostStop             ;AH = Request Type to Issue
  JMP >H00                           ;Do it
DoHostSuspend0:
  PUSH AX                            ;Save used registers
  MOV  AH,I14RRTHostSuspend          ;AH = Request Type to Issue
;  JMP >H00                           ;Do it
H00:                                 ;Do the Host Request Thing
  PUSH CX,DX,SI,DS                   ;Save used registers
  MOV  DS,CS                         ;Point DS at Local Data Area (not TSR)
  MOV  SI,Int14Request4              ;Point at Int 14h Request Structure
  MOV  DX,W [SI].I14RCallBackAddr[2] ;Save the original Call Back Segment
  MOV  W [SI].I14RCallBackAddr[2],CS            ;Code to Call
  MOV  W [SI].I14RCallBackAddr[0],DoHostFarCall ;  when Done
  MOV  [SI].I14RRequestType,AH       ;Store Request Type
  MOV  [SI].I14RHostIndex,AL         ;Store Host Index
  MOV  [DoHostReturnAX],-1           ;Initialize Return value
  CALL DoInt14CallSI                 ;Do it
  JC  >H70                           ;If Error, Quit
  MOV  CX,20                         ;Wait for a maximum of 1 second
H10:                                 ;Wait for Call to Get Done Here
  MOV  AX,50                         ;Wait for
  CALL DelayMSAX                     ;  50 milliseconds
  CALL ReadUSBCommandWord            ;Read the USB COmmand Register
  CMP  [DoHostReturnAX],-1           ;Call completed yet?
  LOOPE H10                          ;If not, keep waiting
  JCXZ >H70                          ;If timed out, error
H20:                                 ;Not timed out
  CMP  [DoHostReturnAX],0            ;Error?
  JE  >H80                           ;If not, we're done
H70:                                 ;Error
  STC                                ;Set Error Flag
  JMP >H90                           ;Done
H80:                                 ;OK
  CLC                                ;Set OK Flag
H90:                                 ;Done
  MOV  W [SI].I14RCallBackAddr[2],DX ;Restore the original Call Back Segment
  POP  DS,SI,DX,CX                   ;Restore used registers
  POP  AX                            ;Restore used registers
  RET

DoHostFarCall:
  MOV  [DoHostReturnAX],AX
  RETF

;------------------------------------------------------------------------------
;DO SOMETHING TO CONTROL A SPECIFIC DEVICE (RESET, RUN, SUSPEND, ETC>)
;Inputs:   ES = TSR Data Area
;          AX (AL) = Device Address to do it to
;Outputs:
;Changes:
;------------------------------------------------------------------------------
DoDeviceReset:
  PUSH BX                            ;Save used registers
  MOV  BL,I14RRTResetDevice          ;Request Type = Reset Device
  JMP >D00                           ;Do it
DoDeviceRun:
  PUSH BX                            ;Save used registers
  CALL DoDeviceResume                ;Resume, if necessary
  PUSH AX                            ;Save used Registers
  MOV  AX,200                        ;Wait for
  CALL DelayMSAX                     ;  200ms
  POP  AX                            ;Restore used Registers
  MOV  BL,I14RRTEnableDevice         ;Request Type = Device Enable
  JMP >D00                           ;Do it
DoDeviceStop:
  PUSH BX                            ;Save used registers
  MOV  BL,I14RRTDisableDevice        ;Request Type = Disable Device
  JMP >D00                           ;Do it
DoDeviceSuspend:
  PUSH BX                            ;Save used registers
  MOV  BL,I14RRTSuspendDevice        ;Request Type = Suspend Device
  JMP >D00                           ;Do it
DoDeviceResume:
  PUSH BX                            ;Save used registers
  MOV  BL,I14RRTResumeDevice         ;Request Type = Resume Device
  JMP >D00                           ;Do it
DoDevicePwrOn:
  PUSH BX                            ;Save used registers
  MOV  BL,I14RRTPwrOnDevice          ;Request Type = Power On Device
  JMP >D00                           ;Do it
DoDevicePwrOff:
  PUSH BX                            ;Save used registers
  MOV  BL,I14RRTPwrOffDevice         ;Request Type = Power Off Device
  JMP >D00                           ;Do it
DoDevicePwrReset:
  PUSH BX                            ;Save used registers
  MOV  BL,I14RRTPwrResetDevice       ;Request Type = Power Reset Device
;  JMP >D00                           ;Do it
D00:
DoDeviceThing:                       ;Do the Host Request Thing
  PUSH SI                            ;Save used registers
  MOV  SI,Int14Request4              ;Point at Int 14h Request Structure
  MOV  [SI].I14RRequestType,BL       ;Store Request Type
  MOV  W [SI].I14RCallBackAddr[0],-1 ;Code to Call when Done
  MOV  BL,ES:[USBHostIndex]          ;Store the
  MOV  [SI].I14RHostIndex,BL         ;  Host Index
  MOV  [SI].I14RDeviceAddress,AL     ;Store the Device Address
  CALL DoInt14CallSI                 ;Do it
  POP  SI                            ;Restore used registers
  POP  BX                            ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO DELAY FOR A CERTAIN NUMBER OF MILLISECONDS
;DelayUS is in the TSR Section, since we need it in certain Interrupt routines.
;DelayMS is not needed in the TSR, so it can go here even though it
;   uses DelayUS.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;DELAY FOR ONE OR TEN MILLISECONDS
;Inputs:
;Outputs: Delays for one millisecond
;Changes:
;------------------------------------------------------------------------------
Delay1MS:
  PUSH AX        ;Save used registers
  MOV  AX,1      ;Delay for
  CALL DelayMSAX ;  1 millisecond
  POP  AX        ;Restore used registers
  RET

Delay10MS:
  PUSH AX        ;Save used registers
  MOV  AX,10     ;Delay for
  CALL DelayMSAX ;  10 milliseconds
  POP  AX        ;Restore used registers
  RET

Delay500MS:
  PUSH AX        ;Save used registers
  MOV  AX,500    ;Delay for
  CALL DelayMSAX ;  500 milliseconds
  POP  AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DELAY FOR A GIVEN NUMBER OF MILLISECONDS
;Inputs:  AX = number of milliseconds to wait (0-65,535)
;Outputs:
;Changes:
;------------------------------------------------------------------------------
DelayMSAX:
  PUSH AX,BX,DX  ;Save used registers
  OR   AX,AX     ;Is there anything to do?
  JZ  >D90       ;If not, just quit
  MOV  DX,1000   ;Convert
  MUL  DX        ;  to
  MOV  BX,AX     ;  microseconds (DX:BX)
D10:             ;Loop to here for each 65535 uS
  OR   DX,DX     ;Counted down high word yet?
  JZ  >D30       ;If so, handle it
  DEC  DX        ;Decrement high word
  MOV  AX,-1     ;Maximum microseconds
  JMP >D50       ;Do it
D30:             ;Counted down high word
  OR   BX,BX     ;Anything to do?
  JZ  >D90       ;If not, we're done
  MOV  AX,BX     ;Get Low Word
  XOR  BX,BX     ;Make sure it's zero next time
D50:             ;AX = Microseconds to wait
  CALL DelayUSAX ;Delay the number of microseconds specified
  JMP  D10       ;See if we need to wait some more
D90:             ;We're done
  POP  DX,BX,AX  ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO TEST AND SEE IF THE COMPUTER IS COMPATIBLE OR NOT.
;Tests DOS Version, Hardware installed, etc. as appropriate to make sure
;  we don't do something that could crash the computer.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST THE COMPUTER TO SEE IF IT'S COMPATIBLE (CPU, DOS VERSION, WHATEVER)
;Inputs:  InMemory
;         ES = TSR Data Area
;Outputs: Quits the program if Computer is Incompatible
;         Returns if Computer is OK
;         Stores all kinds of values in memory variables
;Changes:
;------------------------------------------------------------------------------
TestCompatibility:
  PUSH AX,DX                    ;Save used registers
  TEST [ProgFlags],InMemory     ;Are we already installed?
  JNZ >C90                      ;If so, no need to test again
  MOV  AL,ErLvlDOSVer           ;Assume incorrect
  MOV  DX,SIDDOSVer             ;  DOS Version
  CALL TestDOSVer               ;Is the version of DOS new enough?
  JC  >C70                      ;If not, quit
  MOV  AL,ErLvlNo386            ;Assume CPU is
  MOV  DX,SIDNo386              ;  not 386+
  CALL Test80386                ;Is the CPU at least an 80386?
  JC  >C70                      ;If not, quit
  MOV  AL,ErLvlNoPCI            ;Assume no PCI bus
  MOV  DX,SIDNoPCI              ;  is Installed
  CALL TestPCI                  ;Is a PCI bus installed?
  JC  >C70                      ;If not, quit
  MOV  AL,ErLvlNoUHCI           ;Assume no UHCI Controller
  MOV  DX,SIDNoUHCI             ;  is Installed
  CALL TestUHCI                 ;Is a UHCI Controller installed?
  JC  >C70                      ;If not, quit (also tests Legacy Support)
  MOV  AL,ErLvlVersion          ;Assume incompatible API Version
  MOV  DX,SIDWrongVer           ;  is Installed
  CALL TestAPIVersion           ;Is an incompatible Driver installed?
  JC  >C70                      ;If not, quit
  TEST [StatusFlags],HostStatus ;If we're just doing the Host Status,
  JNZ >C90                      ;  no need for Real Mode/Already Running Test
  TEST [ProgFlags],(Help+Alias) ;If we're just doing Help or Aliases,
  JNZ >C90                      ;  no need for Real Mode/Already Running Test
  MOV  AL,ErLvlNotRealMode      ;Assume not Real Mode or VCPI
  MOV  DX,SIDNotReal            ;Point at possible error message
  CALL TestRealMode             ;Is the CPU in Real Mode?
  JNC >C30                      ;If so, continue
  CALL TestMTask                ;Are we running under a multi-tasker (Windows)?
  JZ  >C70                      ;If so, we can't use VCPI to determine address
  CALL TestVCPI                 ;If not, is Memory Manager VCPI-compliant?
  JC  >C70                      ;If not, Error
C30:                            ;Done testing Memory Manager
  CALL TestAlreadyRun           ;Handle it if another program has Bus control
                                ;  Quits if user doesn't want to continue
  JMP >C90                      ;Done
C70:                            ;The computer is incompatible for some reason
  JMP  Exit                     ;Quit!
C90:                            ;The computer is compatible!
  POP  DX,AX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST THE CURRENT DOS VERSION
;Inputs:  MinDOSVer (EQUate)
;Outputs: CF = Clear if DOS version >= MinDOSVer
;         CF = Set if DOS version < MinDOSVer
;Changes:
;------------------------------------------------------------------------------
TestDOSVer:
  PUSH AX,BX,CX     ;Save used registers
  MOV  AX,3000h     ;Service 30h (get DOS version number)
                    ;  DOS 5.0 requires AL = 00h, may change BX and CX
  INT  21h          ;Do it (Returns AL= Major, AH = Minor)
  XCHG AL,AH        ;Swap Major and Minor versions for testing
  CMP  AX,MinDOSVer ;Is the version new enough?
  JAE >D80          ;If so, it's OK
D70:                ;DOS is older than the minimum
  STC               ;Set the "too old" flag
  JMP >D90          ;We're done
D80:                ;DOS is >= the minimum
  CLC               ;Set the OK flag
D90:                ;We're done
  POP  CX,BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THE CPU IS AN 80386+ (CAN HANDLE 32-BIT INSTRUCTIONS)
;Inputs:
;Outputs: CF = Clear if the CPU is an 80386+
;            = Set if CPU is an 80286-
;Changes:
;------------------------------------------------------------------------------
Test80386:
  PUSH AX,BX ;Save used registers
  PUSHF      ;Save flags
  MOV  AX,(NestedFlag+IOPLMask+IntFlag+2)
             ;AX = Flags mask for testing (Bits 12-14 + STI + Bit 1)
             ;  8086 always sets bits 12-15
             ;  80286 always clears bits 12-15
             ;  80386+ never sets bit 15
  PUSH AX    ;Store it
  POPF       ;  as the FLAGS
  PUSHF      ;Retrieve
  POP  BX    ;  the Flags
  CMP  AX,BX ;Is it an 80386+?
  JE  >E80   ;If so, handle it
E70:         ;It's not an 80386
  POPF       ;Restore flags
  STC        ;Set the not 80386 flag
  JMP >E90   ;We're done
E80:         ;It is an 80386
  POPF       ;Restore flags
  CLC        ;Set the 80386 flag
E90:         ;We're done
  POP  BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A PCI BIOS IS INSTALLED
;Inputs:
;Outputs: CF = Clear if a PCI BIOS is installed
;            = Set if a PCI BIOS is not installed
;Changes:
;------------------------------------------------------------------------------
TestPCI:
  PUSH EAX,EBX,ECX,EDX,EDI   ;Save used registers
  PUSHFD                     ;Save flags
  MOV  AX,0B101h             ;Function B101h (PCI BIOS installation check)
  XOR  EDX,EDX               ;EDX = 0 in case of bad call
  XOR  EDI,EDI               ;EDI = 0 in case of bad call
  STC                        ;Set carry flag in case of bad call
  INT  1Ah                   ;Do it
  JC  >P70                   ;If error, no PCI installed
  CMP  EDX,2049_4350h        ;Did it return EDX = ' ICP'?
  JE  >P80                   ;If so, PCI is installed
P70:                         ;PCI not installed
  POPFD                      ;Restore flags
  STC                        ;Set the not installed flag
  JMP >P90                   ;We're done
P80:                         ;PCI is installed
  MOV  [LastPCIBusNumber],CL ;Store the Maximum Bus Number
  POPFD                      ;Restore flags
  CLC                        ;Set the installed flag
P90:                         ;We're done
  POP  EDI,EDX,ECX,EBX,EAX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THERE IS A UHCI HOST CONTROLLER INSTALLED
;Inputs:  CD = DS = ES = Local Data Area (Still checking Compatibility)
;Outputs: CF = Clear if a UHCI Controller is installed
;            = Set if not
;         [BaseIOAddress], [USBIRQNum], [OldLegacySupp], [USBVersion],
;         VendorID, ProductID
;Changes:
;NOTES: If the Controller is not already assigned an I/O Address Space and/or
;         an IRQ Number, we will set one for it here!!
;------------------------------------------------------------------------------
TestUHCI:
  PUSH EAX,EBX,ECX,EDX,SI       ;Save used registers
  PUSHFD                        ;Save flags
  MOV  AX,0B103h                ;Function B103h (Find PCI Class Code)
  MOV  ECX,((PCIClsSerialBus SHL 16)+(PCISClsUSB SHL 8)+(PCIPIntfUHCI))
                                ;ECX = Class/SubClass/ProgrammingInterface
  MOV  SI,[PCISearchIndex]      ;Index to Search For
  STC                           ;Preset Error Flag
  INT  1Ah                      ;Do it
  JC  >U70                      ;If error, we're done
  MOV  [PCIDevFunc],BX          ;If OK, save BX = PCI Bus Device Function Number
U10:                            ;Assign I/O Address
  MOV  BL,PCIBaseIOAddr         ;Get the USB
  CALL ReadPCIWord              ;  Base I/O Address
  JC  >U70                      ;If error, quit
  CMP  AX,1                     ;Is the Base IO Address valid?
  JBE >U15                      ;If not, assign one
  CMP  AX,0FFE1h                ;Is the Base IO Address valid?
  JBE >U20                      ;If so, continue
U15:                            ;Need to assign an I/O Space
  CALL AssignIOSpace            ;Assign an I/O Space (returns AX)
  CALL ReadPCIWord              ;Read the Assigned I/O Base Address
U20:                            ;I/O Address is OK or assigned
  AND  AX,0FFE0h                ;Only bits 15:5 are valid, mask out the rest
  MOV  [BaseIOAddress],AX       ;Store the Base I/O Address
  TEST [StatusFlags],HostStatus ;If we're just doing the Host Status,
  JNZ >U85                      ;  no need to test/assign anything else
U30:                            ;Assign IRQ Number
  MOV  BL,PCIIRQNum             ;Point BL at the IRQ Offset
  CALL ReadPCIByte              ;Save the current
  MOV  [OldIRQNum],AL           ;  IRQ Number
U35:                            ;No previous IRQ to get
  CMP  [UserIRQ],0              ;Did the User Assign an IRQ?
  JNE >U40                      ;If so, use it
  CALL ReadPCIByte              ;Get the current IRQ Number
  JC  >U70                      ;If error, quit
  CMP  AL,MinIRQ                ;Is it too small?
  JB  >U40                      ;If so, assign a new one
  CMP  AL,MaxIRQ                ;Is it too big?
  JBE >U45                      ;If not, continue
U40:                            ;Need to assign an IRQ
  CALL AssignIRQ                ;Assign an IRQ
  CALL ReadPCIByte              ;Read the Assigned IRQ Number
U45:                            ;IRQ is OK or assigned
  MOV  [USBIRQNum],AL           ;Store the IRQ Number
  MOV  BL,PCIVendorID           ;Get the
  CALL ReadPCIWord              ;  Vendor ID
  JC  >U70                      ;If error, quit
  MOV  [HostVendorID],AX        ;If OK, store it
  MOV  BL,PCIProductID          ;Get the
  CALL ReadPCIWord              ;  Product ID
  JC  >U70                      ;If error, quit
  MOV  [HostProductID],AX       ;If OK, store it
  MOV  BL,PCILegacySupp         ;Get the USB
  CALL ReadPCIWord              ;  Legacy Support status
  JC  >U70                      ;If error, quit
  MOV  [OldLegacySupp],AX       ;Store the Legacy Support Register
  CALL TestLegacySupp           ;Test for Legacy Support (quit if so, and user
                                ;  doesn't want us to Disable it)
  MOV  BL,PCIUSBVersion         ;Get the USB
  CALL ReadPCIByte              ;  Version Number
  JC  >U70                      ;If error, quit
  MOV  [USBVersion],AL          ;Store the USB Version
  OR   AL,AL                    ;Is it a pre-release version?
  JNZ >U80                      ;If not, we're done!
U70:                            ;USB not installed
  POPFD                         ;Restore flags
  STC                           ;Set the not installed flag
  JMP >U90                      ;We're done
U80:                            ;USB is installed
  TEST [ProgFlags2],(AssignedIO+AssignedIRQ) ;Did we assign any Resources here?
  JZ  >U85                      ;If not, continue
  CALL WriteCrLfPause           ;If so, write a new line
U85:                            ;USB Installed - Set return flags
  POPFD                         ;Restore flags
  CLC                           ;Set the installed flag
U90:                            ;We're done
  POP  SI,EDX,ECX,EBX,EAX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF AN INCOMPATIBLE VERSION OF THE USB API IS ALREADY INSTALLED
;Inputs:  CD = DS = ES = Local Data Area (Still checking Compatibility)
;Outputs: CF = Clear if no API installed, or is same version as us
;            = Set if different API version is installed
;Changes:
;------------------------------------------------------------------------------
TestAPIVersion:
  PUSH BX,SI            ;Save used registers
  MOV  SI,Int14Request4 ;[SI] = Request Structure
  MOV  [SI].I14RRequestType,I14RRTGetHostSWInfo ;Request = Get Software Info
  MOV  [SI].I14RHostIndex,AllHostsIndex         ;All Hosts
  CALL DoInt14CallBXSI  ;Issue the Request
  JC  >A80              ;If error, no API installed
  CMP  BX,APIVersion    ;Same version as us?
  JE  >A80              ;If so, it's OK
A70:                    ;Error
  STC                   ;Set return flag
  JMP >A90              ;Done
A80:                    ;OK
  CLC                   ;Set return flag
A90:                    ;Done
  POP  SI,BX            ;Save used registers
  RET

;------------------------------------------------------------------------------
;SEE IF LEGACY SUPPORT IS TURNED ON: IF SO, QUERY THE USER ABOUT CONTINUING
;Inputs:  [OldLegacySupp]
;         [ProgFlags].DisableLegacy
;Outputs: Quits if Legacy Support is enabled,
;           and user doesn't want to continue
;         Returns if Legacy support is disabled, or it is enabled
;           and the user says it's OK to disable it
;         [ProgFlags].DisableLegacy
;         [ProgFlags2].LegacyEnabled
;Changes:
;------------------------------------------------------------------------------
TestLegacySupp:
  PUSH AX,DX                      ;Save used registers
  MOV  AX,[OldLegacySupp]         ;Get the Legacy Support Register
  TEST AX,(LSSMI60REn+LSSMI60WEn+LSSMI64REn+LSSMI64WEn+LSSMIUSBIRQEn+LSA20PassThruEn+LSSMIEndPassThruEn)
                                  ;Are any of the Legacy Support Bits Enabled?
  JZ  >L90                        ;If not, Legacy Support is not enabled
  OR   [ProgFlags2],LegacyEnabled ;Mark Legacy Support as Enabled
  TEST [ProgFlags],DisableLegacy  ;Did user OK continuation from Command Line?
  JNZ >L90                        ;If so, continue
  MOV  AL,ErLvlLegacy             ;ErrorLevel to use if user says No
  MOV  DX,SIDLegacyCont           ;Query message to use
  CALL GetYNFromUser              ;Ask user for continuance (quits if No)
  OR   [ProgFlags],DisableLegacy  ;Mark user as OK'ing us to continue
L90:                              ;We're done
  POP  DX,AX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEE IF NON-LEGACY DRIVER IS TURNED ON: IF SO, QUERY THE USER ABOUT CONTINUING
;Inputs:  ES = TSR Data Area
;         [ProgFlags2].LegacyEnabled
;         [ProgFlags].DisableLegacy
;         [ProgFlags2].DisableOther
;Outputs: Quits if other program has control of Bus,
;           and user doesn't want to continue.
;         Returns if Host is not running, or it is enabled
;           and the user says it's OK to disable it
;Changes:
;------------------------------------------------------------------------------
TestAlreadyRun:
  PUSH AX,BX,DX                    ;Save used registers
  TEST [ProgFlags2],LegacyEnabled  ;Is a Legacy Driver installed?
  JNZ >A90                         ;If so, we've already queried the user
  CALL ReadUSBCommandWord          ;Read the USB Command Register
  CMP  AX,-1                       ;Are all of the bits set (Unconfigured)?
  JE  >A90                         ;If so, it's OK
  TEST AL,(UCConfigured+UCRunStop) ;Is the Controller Configured or Running?
  JNZ >A20                         ;If so, another program has control
  MOV  BL,USBStatus                ;Get the
  CALL ReadHostWord                ;  USB Status Register
  TEST AL,USHostHalted             ;Is the Controller Halted?
  JNZ >A90                         ;If so, it's OK for us to grab control
A20:                               ;Another program has control of the Bus
  TEST [ProgFlags2],DisableOther   ;Did user OK continuation from Command Line?
  JNZ >A90                         ;If so, continue
  MOV  AL,ErLvlAlreadyRun          ;ErrorLevel to use if user says No
  MOV  DX,SIDAlreadyRun            ;Query message to use
  CALL GetYNFromUser               ;Ask user for continuance (quits if No)
A90:                               ;We're done
  POP  DX,BX,AX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PRINT A Y/N QUERY STRING, AND PROCESS THE USERS ANSWER
;Inputs:  DS:[DX] = Query String (ASCIIZ) to write (writes to ERR)
;         AL = ErrorLevel to quit with if user does not answer Y
;Outputs: Returns if User answers Y
;         Quits program with ErrorLevel and Cr/Lf Message if
;           user answers anything except Y
;Changes:
;------------------------------------------------------------------------------
GetYNFromUser:
  PUSH AX,BX,DX        ;Save used registers
  MOV  BL,AL           ;Save ErrorLevel
  CALL WriteZErr       ;Write the Query String
  MOV  AH,07h          ;Function 7 (Read Character from STDIN)
  INT  21h             ;Do it
  CALL Capitalize      ;Capitalize it
  MOV  SingleMsg[0],AL ;Write the
  MOV  DX,SingleMsg    ;  inputted character
  CALL WriteZErr       ;  back to the user
  CALL WriteCrLfErr    ;Move down
  CALL WriteCrLfErr    ;  two lines
  CMP  AL,'Y'          ;Is it Yes?
  JE  >Y90             ;If so, return from call
  MOV  AL,BL           ;Put ErrorLevel in AL
  MOV  DX,SIDCrLf      ;Write a CrLf
  JMP  Exit            ;Quit program
Y90:                   ;User answered Y
  POP  DX,BX,AX        ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO FIND/ASSIGN AVAILABLE IRQ'S & IO ADDRESSES
;Needed if we need to assign our own IRQ's & I/O Spaces.
;Most of the time, these things are assigned at boot time by the BIOS,
;  but once in a while they aren't.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;ASSIGN AN I/O SPACE TO THE USB HOST CONTROLLER
;Inputs:
;Outputs:
;Changes: I/O Value in USB Controller Configuration Area
;------------------------------------------------------------------------------
AssignIOSpace:
  PUSH AX,BX,CX,DX,DI    ;Save used registers
  MOV  AX,[UserIOSpace]  ;Did the User give us
  OR   AX,AX             ;  an I/O Base Address to use?
  JNZ >I30               ;If so, use it
  MOV  AX,20h            ;Size of Address Space needed (in Bytes)
  CALL FindAvailIOSpace  ;Find an available I/O Space Base Address
I30:                     ;AX contains I/O Base Address to use
  INC  AX                ;Mark it as an I/O Address (not a Memory Address)
  MOV  BL,PCIBaseIOAddr  ;Offset to Store it at
  CALL WritePCIWord      ;Store it
  DEC  AX                ;Get rid of the 1 in Bit 0
  MOV  DI,AX             ;Put Base Address in DI
  MOV  CX,10h            ;Size of Address Space (in Words)
  CALL FillIOSpaceWith0s ;Write it with Zeroes (mark it as used)
  OR   [ProgFlags2],AssignedIO ;Mark us as having done the assignment
  MOV  DX,SIDAssignIO    ;Tell the user
  CALL WriteZPause       ;  that we
  CALL WriteWordHex      ;  changed
  CALL WriteHexEnd       ;  it
  CALL WriteCrLfPause    ;Write a new line
  POP  DI,DX,CX,BX,AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ASSIGN AN IRQ SPACE TO THE USB HOST CONTROLLER
;Inputs:
;Outputs:
;Changes: IRQ Value in USB Controller Configuration Area
;------------------------------------------------------------------------------
AssignIRQ:
  PUSH AX,BX,DX        ;Save used registers
  MOV  AL,[UserIRQ]    ;Did the User give us
  OR   AL,AL           ;  an IRQ to use?
  JNZ >Q30             ;If so, use it
  CALL FindSharablePCIIRQ ;Look for a sharable IRQ
  JNZ >Q30             ;If valid, we're done
  CALL FindAvailIRQ    ;If not, find an unused IRQ
  JNZ >Q30             ;If valid, we're done
  MOV  AL,DefaultIRQ   ;If not, use the Default Value
Q30:                   ;AL contains IRQ to use
  MOV  BL,PCIIRQNum    ;Offset to Store it at
  CALL WritePCIByte    ;Store it
  OR   [ProgFlags2],AssignedIRQ ;Mark as having done the assignment
  MOV  DX,SIDAssignIRQ ;Tell the user
  CALL WriteZPause     ;  that we
  CALL WriteByteMin    ;  changed it
  CALL WriteCrLfPause  ;Write a new line
  POP  DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND AN AVAILABLE I/O SPACE
;Inputs:  AX = Number of Bytes of I/O Space needed
;Outputs: AX = I/O Space that appears free (all 1's)
;Changes:
;NOTES: This code looks for an I/O Space of all 1's, and then attempts to
;         change the Code to all 0's.  If it is a truly free (available)
;         I/O Space, the change to all 0's will not work since there is
;         no Device "attached" to the I/O Space to store the changes.
;         If the change DOES work, the space is not really available, and
;         we change it back to all 1's again and keep looking.
;         Hopefully, us messing with a "live" I/O Space like this won't
;         screw up the Device the I/O Space is controlling.
;       When done, the routine that calls this one should immediately
;         "reserve" the I/O Space (with an appropriate call to the PCI
;         bus) and then immediately initialize the I/O Space (to all zeroes,
;         if nothing else).  That will prevent a future call to this routine
;         from finding the same I/O Address Space again.
;       This does not return an error flag, since we should always
;         be able to find an I/O Range to use.  We also do not check the
;         validity of AX on entry.  A "bad" value in AX could cause us
;         all kinds of grief!
;       This code will "round up" the number of bytes to a multiple
;         of 32,  and will always align the I/O Base Address with a
;         32-byte paragraph boundary.
;------------------------------------------------------------------------------
FindAvailIOSpace:
  PUSH CX,DX,DI            ;Save used registers
  OR   AX,AX               ;AX = 0?
  JNZ >O10                 ;If not, assume it's OK
  INC  AX                  ;If so, make it a 1
O10:                       ;AX > 0
  ADD  AX,31               ;Round up Number of Bytes Needed
  SHR  AX,5                ;  to a multiple of 32
  SHL  AX,4                ;  and convert number of Bytes to number of Words
  MOV  CX,AX               ;Save the Counter
  MOV  DI,400h             ;Will start with I/O Address 400h
O20:                       ;Loop to here for each I/O Space
  CALL TestIOSpaceForAll1s ;Is the I/O Space filled with ones?
  JC  >O60                 ;If not, keep looking
  CLI                      ;Disable interrupts
  CALL FillIOSpaceWith0s   ;If so, try to fill it with 0s'
  CALL TestIOSpaceForAll1s ;Is the I/O Space still filled with ones?
  JNC >O90                 ;If so, we have our I/O Space!
  CALL FillIOSpaceWith1s   ;If not, fill it back up with ones again!
O60:                       ;Not a valid I/O Space
  STI                      ;Enable Interrupts
  ADD  DI,32               ;Point at the next I/O Space
  JMP  O20                 ;Keep looking
O90:                       ;Have our Address Space (DI)
  STI                      ;Enable Interrupts
  MOV  AX,DI               ;Put the I/O Address in AX for the Return
  POP  DI,DX,CX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ATTEMPT TO FILL I/O SPACE WITH ALL ZEROES OR ALL ONES
;Inputs:  DI = Base I/O Address
;         CX = Number of Words in I/O Space
;Outputs: Attempts to Write All 0's or All 1's to an I/O Space
;Changes:
;------------------------------------------------------------------------------
FillIOSpaceWith0s:
  PUSH AX    ;Save used registers
  XOR  AX,AX ;Fill with Zeroes
  JMP >F00   ;Do it
FillIOSpaceWith1s:
  PUSH AX    ;Save used registers
  MOV  AX,-1 ;Fill with All Ones
;  JMP >F00   ;Do it
F00:
  PUSH CX,DX ;Save used registers
  MOV  DX,DI ;Put Base (Starting) I/O Address in DX
F10:         ;Loop to here for each I/O Address
  OUT  DX,AX ;Write the Next Word
  INC  DX,2  ;Point at the next I/O Address
  LOOP F10   ;Keep going until we're done
  POP  DX,CX ;Restore used registers
  POP  AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHECK AND SEE IF AN I/O SPACE IS FILLED WITH ONES
;Inputs:  DI = Base I/O Address
;         CX = Number of Words in I/O Space
;Outputs: CF = Clear if I/O Space is filled with ones
;            = Set if not all ones
;Changes:
;------------------------------------------------------------------------------
TestIOSpaceForAll1s:
  PUSH AX,CX,DX ;Save used registers
  MOV  DX,DI    ;Put Base (Starting) I/O Address in DX
A10:            ;Loop to here for each I/O Address
  IN   AX,DX    ;Get the Next Word
  CMP  AX,-1    ;Is it all ones?
  JNE >A70      ;If not, we're done
  INC  DX,2     ;Point at the next I/O Address
  LOOP A10      ;Keep going until we're done
  JMP >A80      ;It's all ones!
A70:            ;Not all Ones
  STC           ;Set return flag
  JMP >A90      ;Done
A80:            ;All Ones
  CLC           ;Set Return Flag
A90:            ;Done
  POP  DX,CX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND AN IRQ FROM THE PCI BUS (ASSUME IT'S SHARABLE)
;Inputs:
;Outputs: AL = IRQ Number that appears Sharable (0-15, never <7!)
;         ZF = Set if Error (AL = 0)
;            = Clear if OK (AL > 0)
;Changes:
;NOTES: Simply searches PCI Bus for all "registered" IRQ's on all Devices.
;       If < 7, we assume it's a Sound Card, Modem, etc., that, although
;         possibly Sharable, would more than likely cause problems since
;         other DOS programs that might try to control those devices
;         would not understand IRQ sharing.
;------------------------------------------------------------------------------
FindSharablePCIIRQ:
  PUSH CX,BP ;Save used registers
  XOR  BP,BP ;Mask in no IRQ's
  CALL FindPCIIRQsSerialOK ;Mask in Serial-Bus-compatible PCI IRQ's (returns BP)
  XOR  AL,AL ;Assume no valid IRQ's (IRQ 0)
  OR   BP,BP ;Any valid IRQ's used?
  JZ  >A90   ;If not, we're done
  MOV  CX,13 ;Need to test 13 Bits (IRQ's 3-15)
  MOV  AL,15 ;Start with IRQ 15
A10:         ;Loop to here for each IRQ Bit
  OR   BP,BP ;This IRQ used by another PCI Device?
  JS  >A90   ;If so, we're done
  DEC  AL    ;Decrement IRQ Number
  SHL  BP,1  ;Shift the IRQ Bit Mask Over
  LOOP A10   ;Keep going until we're done
A90:         ;Done
  OR   AL,AL ;Set return mask
  POP  BP,CX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND AN AVAILABLE (FREE) IRQ FROM ALL KNOWN SOURCES
;Inputs:
;Outputs: AL = IRQ Number that appears free (0-15, never 0, 1, or 2!)
;         ZF = Set if Error (AL = 0)
;            = Clear if OK (AL > 0)
;Changes:
;NOTES: Searches PCI Bus for IRQ's on all Devices, as well as Enabled IRQ's
;         on the ISA Bus, as well as the BIOS Data Area (0040:xxxxh) for
;         "standard" Serial & Parallel Ports.
;------------------------------------------------------------------------------
FindAvailIRQ:
  PUSH CX,BP          ;Save used registers
  MOV  BP,0107h       ;Mask in IRQ's 0 (Clock), 1 (Keyboard), 2 (Cascade),
                      ;  & 8 (CMOS Clock)
  CALL FindCOMLPTIRQs ;Find COM/LPT IRQ's in the BIOS Data Area
  CALL FindPCIIRQs    ;Mask in PCI IRQ's
  CALL FindPICIRQs    ;Mask in IRQ's enabled by the PIC's
  MOV  CX,16          ;Need to test 16 Bits
  XOR  AL,AL          ;Start with IRQ 0
  CMP  BP,-1          ;Any IRQ's available at all?
  JE  >A90            ;If not, we're done
  MOV  AL,15          ;If so, start with IRQ 15
A10:                  ;Loop to here for each IRQ Bit
  OR   BP,BP          ;This IRQ Available?
  JNS >A90            ;If so, we're done
  DEC  AL             ;Decrement IRQ Number
  SHL  BP,1           ;Shift the IRQ Bit Mask Over
  LOOP A10            ;Keep going until we're done
A90:                  ;Done
  OR   AL,AL          ;Set return mask
  POP  BP,CX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND OUT WHICH IRQ's ARE USED/RESERVED BY COM/LPT PORTS IN THE BIOS DATA AREA
;Inputs:  BP = IRQ's (bit mask) used by other sources
;Outputs: BP modified to include COM/LPT IRQ's
;Changes:
;NOTE: This assumes "standard" COM/LPT Port Addresses/IRQ's.
;        That is, COM1 = 03F8h/IRQ4, COM3 = 03E8h/IRQ4,
;                 COM2 = 02F8h/IRQ3, COM4 = 02E8h/IRQ3,
;                 LPT1 =       IRQ7, LPT2 =       IRQ5
;      If there is anything "weird" about the COM/Parallel Ports, we will
;        not be able to figure it out correctly!
;------------------------------------------------------------------------------
FindCOMLPTIRQs:
  PUSH AX,CX,SI,DS ;Save used registers
  MOV  AX,0040h    ;Point DS at the
  MOV  DS,AX       ;  BIOS Data Area
  XOR  SI,SI       ;Point SI at the First COM Port Address
  MOV  CX,4        ;Do 4 COM Ports
L10:               ;Loop to here for each COM Port
  LODSW            ;Get next COM Port I/O Adress
  CMP  AX,02F8h    ;COM2?
  JE  >L40         ;If so, handle it
  CMP  AX,02E8h    ;COM4?
  JE  >L40         ;If so, handle it
  CMP  AX,03F8h    ;COM1?
  JE  >L30         ;If so, handle it
  CMP  AX,03E8h    ;COM3?
  JNE >L50         ;If not, we're done
L30:               ;COM1/COM3
  OR   BP,0010h    ;Mask in IRQ4
  JMP >L50         ;Done
L40:               ;COM2/COM4
  OR   BP,0008h    ;Mask in IRQ3
L50:               ;Done
  LOOP L10         ;Keep going until are COM Ports are done
  LODSW            ;Get the first LPT Port I/O Address
  CMP  AX,10       ;Valid Address?
  JBE >L90         ;If not, we're done
  OR   BP,0080h    ;If so, mask in IRQ7
  LODSW            ;Get the second LPT Port I/O Address
  CMP  AX,10       ;Valid Address?
  JBE >L90         ;If not, we're done
  OR   BP,0020h    ;If so, mask in IRQ5
L90:               ;Done
  POP  DS,SI,CX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND OUT WHICH IRQ's ARE MASKED IN BY THE PIC's
;Inputs:  BP = IRQ's (bit mask) used by other sources
;Outputs: BP modified to include PIC-Enabled IRQ's
;Changes:
;------------------------------------------------------------------------------
FindPICIRQs:
  PUSH AX              ;Save used registers
  IN   AL,(PIC2Addr+1) ;Get the PIC2 (IRQ 8-15) Disabled Mask
  MOV  AH,AL           ;Put it in the High Byte of our mask
  IN   AL,(PIC1Addr+1) ;Get the PIC1 (IRQ 0-7) Disabled Mask
  NOT  AX              ;Convert Disabled Mask to Enabled Mask
  OR   BP,AX           ;Mask it in to the IRQ Mask
  POP  AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND OUT WHICH IRQ's ARE USED/RESERVED BY PCI DEVICES
;Inputs:  CS = DS = Local (non-TSR) Data Area
;         BP = IRQ's (bit mask) used by other sources
;Outputs: BP modified to include PCI IRQ's
;         [LastPCIBusNumber]
;Changes:
;NOTES: If FindPICIRQs, we mask in ALL PCI IRQ's from all types of Devices.
;       If FindPCIIRQsSerialOK, we only mask in PCI IRQ's that we believe
;         will be Ok to "share" with.  This includes other Serial Bus
;         controllers (USB, FireWire, Access.Bus, etc.).  It does NOT
;         include certain other types of devices (like Hard Drives, NIC's,
;         Sound Cards, Serial/Parallel Ports).
;       In actuality, all PIC IRQ's are "sharable" at the hardware level.
;         What determines whether an IRQ is truly sharable or not is the
;         software, not the hardware.
;       Most DOS programs (and BIOS's) do not even begin to understand
;         the concept of sharable IRQ's, and as a consequence, will not work
;         properly if we try to share IRQ's with them.  Specifically,
;         we will almost be guaranteed to have problems with devices such
;         as those specifically mentioned above as being excluded
;         (Hard Drives, NIC's, Sound Cards, and Serial/Parallel Ports).
;       Therefore, even though all IRQ's are theoretically "sharable",
;         many of them are not, in real, practical, terms, "sharable".
;       So, with this process, we only include IRQ's that we believe
;         won't cause problems.
;------------------------------------------------------------------------------
FindPCIIRQsSerialOK:
  OR   [ProgFlags2],DoSerialTest ;Mark as needing Serial-Bus-compatible IRQ's
  JMP >I00                       ;Do it
FindPCIIRQs:
  AND  [ProgFlags2],(NOT DoSerialTest) ;Mark as needing all IRQ's
;  JMP >I00                       ;Do it
I00:
  PUSH EAX,EBX,ECX,EDX,DI,SI     ;Save used registers
  XOR  SI,SI                     ;Start with Bus-Device-Function 0
I10:                             ;Loop to here for each Bus-Device-Function
  MOV  BX,SI                     ;BX = Bus-Device-Function
  CMP  BH,[LastPCIBusNumber]     ;Have we already checked all of the Busses?
  JA  >I90                       ;If so, we're done
  TEST [ProgFlags2],DoSerialTest ;Only want Serial-Bus-compatible IRQ's?
  JZ  >I20                       ;If so, look for all IRQ's
I15:                             ;Get Class Code
  MOV  AX,0B108h                 ;Function B108h (Read PCI Byte)
  MOV  BX,SI                     ;BX = Bus-Device-Function
  MOV  DI,PCIClassCode           ;DI = Register Offset to get (PCI Class Code)
  STC                            ;Preset the error flag
  INT  1Ah                       ;Do it (returns Carry Flag & CL)
  JC  >I30                       ;If error, continue
  CALL TestSerialBusClassCode    ;Test the Class Code
  JC  >I30                       ;If not compatible, we're done
I20:                             ;Get IRQ Number
  MOV  AX,0B108h                 ;Function B108h (Read PCI Byte)
  MOV  BX,SI                     ;BX = Bus-Device-Function
  MOV  DI,PCIIRQNum              ;DI = Register Offset to get (IRQ Number)
  STC                            ;Preset the error flag
  INT  1Ah                       ;Do it (returns Carry Flag & CL)
  JC  >I30                       ;If error, continue
  OR   CL,CL                     ;Valid IRQ Number?
  JZ  >I30                       ;If not, quit
  CMP  CL,15                     ;Valid IRQ Number?
  JA  >I30                       ;If not, quit
  MOV  AX,1                      ;Convert the IRQ Number
  SHL  AX,CL                     ;  to a bit mask
  OR   BP,AX                     ;  and store it
I30:                             ;Done with this Bus-Device-Function
  ADD  SI,1                      ;Increment Bus-Device-Function Number
  JNC  I10                       ;If not done yet, keep looking
I90:                             ;Done
  POP  SI,DI,EDX,ECX,EBX,EAX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A PCI CLASS CODE APPEARS TO BE SERIAL-BUS-COMPATIBLE
;Inputs:  CL = PCI Class Code to Test
;Outputs: CF = Clear if compatible
;              Set if incompatible
;Changes:
;------------------------------------------------------------------------------
TestSerialBusClassCode:
  CMP  CL,PCIClsDisplay     ;Display Class?
  JE  >C80                  ;If so, it's compatible
  CMP  CL,PCIClsBridgeCtrlr ;Bridge Controller Class?
  JE  >C80                  ;If so, it's compatible
  CMP  CL,PCIClsInputDvc    ;Input Device Class?
  JE  >C80                  ;If so, it's compatible
  CMP  CL,PCIClsDockingStn  ;Docking Station Class?
  JE  >C80                  ;If so, it's compatible
  CMP  CL,PCIClsSerialBus   ;Serial Bus Class?
  JE  >C80                  ;If so, it's compatible
C70:                        ;Incompatible
  STC                       ;Set return flag
  JMP >C90                  ;Done
C80:                        ;Compatible
  CLC                       ;Set return flag
C90:                        ;Done
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO EXEC ANOTHER PROGRAM
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SETUP PARAMETERS TO BE ABLE TO PERFORM THE EXEC FUNCTION
;Inputs:
;Outputs:
;Changes: Lots of stuff
;------------------------------------------------------------------------------
SetupExec:
  PUSH AX,SI                       ;Save used registers
  MOV  SI,ParamBlock               ;Point at Parameter Block
  MOV  AX,CS                       ;Use our data segment
  MOV  [SI].PBEnvirSegment,0       ;Use Copy of our Environment
  MOV  W [SI].PBCmdTailPtr[0],OFFSET CmdTailSize
  MOV  W [SI].PBCmdTailPtr[2],AX   ;Command Tail Pointer
  MOV  W [SI].PBFCB1Offset[0],FCB1
  MOV  W [SI].PBFCB1Offset[2],AX   ;FCB #1 Pointer
  MOV  W [SI].PBFCB2Offset[0],FCB2
  MOV  W [SI].PBFCB2Offset[2],AX   ;FCB #2 Pointer
  POP  SI,AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PERFORM THE EXEC FUNCTION
;Inputs:  ParamBlock set up with appropriate data
;         CmdTail/[CmdTailSize] set up with appropriate Info
;         PathToUse contains Child Program to Call
;         DS = Our data Area
;Outputs: CF = Clear if Program Returned ErrorLevel 0
;Changes: Performs EXEC Function
;------------------------------------------------------------------------------
DoExec:
  PUSH ES             ;Save used register
  MOV  ES,DS          ;Point ES at our dta Area
  PUSHA               ;Save all registers
  MOV  [OldSPExec],SP ;Save the Stack Pointer (may be destroyed by Call)
  MOV  DX,PathToUse   ;DS:[DX] = Child Program to Run
  MOV  BX,ParamBlock  ;ES:[BX] = Parameter Block
  MOV  AX,4B00h       ;Function 4B00h (Load and Execute child program)
  INT  21h            ;Do it (May Destroy BX & DX)
  JC  >X70            ;If Error, quit
X00:                  ;When the Child Program Exits, here we are!
  CLD                 ;Go forward with string functions
  CLI                 ;Disable interrupts
  MOV  DS,CS          ;Restore
  MOV  ES,DS          ;  all
  MOV  SS,CS          ;  Segments
  MOV  SP,[OldSPExec] ;Restore Stack Pointer
  STI                 ;Enable interrupts
  MOV  AH,4Dh         ;Function 4Dh (Get ErrorLevel)
  INT  21h            ;Do it (Returns AH = Term Type, AL = ErrorLevel)
  OR   AL,AL          ;ErrorLevel 0?
  JZ  >X80            ;If so, it was OK
X70:                  ;Error
  STC                 ;Set Error Flag
  JMP >X90            ;Done
X80:                  ;OK
  CLC                 ;Set OK Flag
X90:                  ;Done
  POPA                ;Restore all registers
  NOP                 ;POPA Bug Fix
  POP  ES             ;Restore used registers
  RET

;-----------------------------------------------------------------------------
;EXECUTE AN EXEC CALL, PRINTING A "FILE NOT FOUND" MESSAGE IF ERROR
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = Support File (Executable File) to Call
;         CmdTail already filled in with Parameters,
;           including CallBack Address
;Outputs: CF = Clear if Success
;            = Set if Error
;                Writes Error Message to the Screen (including Exec Filename)
;Changes:
;-----------------------------------------------------------------------------
HandleExecCall:
  PUSH DX               ;Save used registers
  CALL FindSupportFile  ;Look for the Support File (DI)
  JNC >X50              ;If OK, continue
  MOV  DX,SIDNoSuptFile ;If not, write the first part
  CALL WriteZPause      ;  of the Error Message
  MOV  DX,DI            ;Write the
  CALL WriteZPause      ;  File Name
  STC                   ;Set Error Flag
  JMP >X90              ;Done
X50:                    ;Support File exists
  CALL DoExec           ;Call the Support Program
  CLC                   ;Set OK flag
X90:                    ;Done
  POP  DX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE LOCATION OF THE SUPPORT FILE
;Inputs:  [DI] = FIleName to Look for
;Outputs: CF = Clear if OK (File Found)
;              PathToUse = Path & FileName Concatenated Together
;            = Set if Error (File not Found)
;              PathToUse = Undefined
;Changes: Various Path pointer Registers ([OurPathPointer], [PathVarPointer], etc.)
;------------------------------------------------------------------------------
FindSupportFile:
  PUSH AX,SI,ES            ;Save used registers
F10:                       ;Do Our Path
  MOV  SI,[OurPathPointer] ;[SI] = Our Program's Path
  CMP  SI,-1               ;Valid?
  JE  >F20                 ;If not, skip it
  MOV  ES,[PSPEnvirSeg]    ;Point ES at the Environment Segment
  CALL CopyPathName        ;Copy it
  CALL FindFile            ;File exists?
  JNC >F80                 ;If so, we're done
F20:                       ;Do Current Path
  MOV  ES,CS               ;Point ES at us
  MOV  SI,CurrentPath      ;If not, try the Current Path
  CALL CopyPathName        ;Copy it
  CALL FindFile            ;File exists?
  JNC >F80                 ;If so, we're done
F30:                       ;Do Environment PATH
  MOV  SI,[PathVarPointer] ;[SI] = Environment PATH Pointer
  CMP  SI,-1               ;Is it valid?
  JE  >F70                 ;If not, we're done
  MOV  ES,[PSPEnvirSeg]    ;Point ES at the PATH (Environment) Segment
F35:                       ;Loop to here for each element in PATH
  CALL CopyPathName        ;Copy the PATH element
  JC  >F70                 ;If End of Path, we're done
  CALL FindFile            ;File exists?
  JNC >F80                 ;If so, we're done
F40:                       ;Loop to here to skip over PATH Element
  MOV  AL,ES:[SI]          ;Get next character
  INC  SI                  ;Increment Pointer
  OR   AL,AL               ;End of PATH?
  JZ  >F70                 ;If so, we're done
  CMP  AL,';'              ;End of PATH Element?
  JNE  F40                 ;If not, Keep looking
  JMP  F35                 ;Try the next Element
F70:                       ;Error
  STC                      ;Set Error Flag
  JMP >F90                 ;Done
F80:                       ;Found our File
  CLC                      ;Set OK flag
F90:                       ;Done
  POP  ES,SI,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEE IF THE SUPPORT FILE EXISTS
;Inputs:  PathToUse
;Outputs: CF = Clear if OK (File Found)
;            = Set if Error (File not Found)
;Changes:
;------------------------------------------------------------------------------
FindFile:
  PUSH AX,CX,DX      ;Save used registers
  MOV  AX,4E00h      ;Function 4Eh (Find First Matching File)
  MOV  CX,FAttrToUse ;Search for any file, including Hidden
  MOV  DX,PathToUse  ;DS:DX = ASCIIZ FileName to search for
  INT  21h           ;Do it (returns CF)
  POP  DX,CX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CREATE A COMPLETE PATH NAME GIVEN A PATH AND A FILE NAME
;Inputs:  ES:[SI] = Path name to Copy
;         DS:[DI] = FileName to Append to the Path
;Outputs: PathToUse = Path & File Concatenated Together
;NOTES: The Path String can either end with a 0 (ASCIIZ String) or a SemiColon
;         (the way strings are stored in the PATH Environment variable).
;       This code will properly handle an empty Path String, which will
;         simply set PathToUse to the FileName.
;       The FileName must be an ASCIIZ String.
;------------------------------------------------------------------------------
CopyPathName:
  PUSH AX,BX,CX,DI,SI,DS,ES  ;Save used registers
  SwapDSES                   ;Point ES at our Data, DS at Data Path
  MOV  BX,DI                 ;Save File Name Pointer
  XOR  AX,AX                 ;Fill with Zeroes
  MOV  CX,(MaxPathSize/2)    ;Number of Words to Write
  MOV  DI,PathToUse          ;Where to write them
  PUSH DI                    ;Save Pointer
  REP  STOSW                 ;Reset the Buffer
  POP  DI                    ;Restore Pointer
  XOR  CL,CL                 ;Start String Length Counter at 0
N10:                         ;Loop to here for each character in Path
  LODSB                      ;Get next character
  OR   AL,AL                 ;End of Path?
  JZ  >N20                   ;If so, do Filename
  CMP  AL,';'                ;End of Path (Environment PATH)?
  JE  >N20                   ;If so, do FileName
  INC  CL                    ;Increment String Length Counter
  STOSB                      ;If not, store the character
  JMP  N10                   ;Keep going
N20:                         ;Done with Path
  OR   CL,CL                 ;Any characters at all in the Path?
  JZ  >N30                   ;If so, is Current Path, and don't want backslash!
  CMP  B ES:[DI-1],Backslash ;Path ends in a Backslash?
  JE  >N30                   ;If so, it's OK
  MOV  AL,Backslash          ;If not, store
  STOSB                      ;  a Backslash
N30:                         ;Path is OK
  MOV  DS,ES                 ;Point DS:[SI]
  MOV  SI,BX                 ;  at the File Name
N40:                         ;Loop to here for each character in File name
  LODSB                      ;Get next character
  OR   AL,AL                 ;End of File Name?
  JZ  >N90                   ;If so, we're done
  STOSB                      ;If not, store it
  JMP  N40                   ;Keepgoing
N90:                         ;Done
  POP  ES,DS,SI,DI,CX,BX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE PATH THAT OUR PROGRAM IS IN
;Inputs:
;Outputs: [OurPathPointer] = Pointer to Our Path String (in Environment Segment)
;                          = -1 if we couldn't find our own Path
;Changes:
;------------------------------------------------------------------------------
GetOurPath:
  PUSH AX,BX,CX,DI,SI   ;Save used registers
  PUSH DS,ES            ;Save used registers
  MOV  BX,OFFSET OurPathPointer ;[BX] = Where we're storing
  MOV  DS,[PSPEnvirSeg] ;Point DS and ES
  MOV  ES,DS            ;  at the Environment segment
  XOR  DI,DI            ;Point at the beginning of Environment list
  MOV  CX,-1            ;Max out the count limiter
  XOR  AX,AX            ;Need to look for a double 0
N10:                    ;Loop to here to skip over Environment vars
  REPNE SCASB           ;Look for the end of this environment variable
  CMP  [DI],AL          ;Is it the end of the variable list (double 0)?
  JNE  N10              ;If not, keep skipping over Environment vars
  CMP  [DI+1],AX        ;If so, is there a string after the Envir?
  JE  >N70              ;If not, we're done
  ADD  DI,3             ;Point DI and SI at the
  MOV  SI,DI            ;  True Name
  MOV  CS:[BX],DI       ;Store the Pointer
N20:                    ;Loop to here to find the end of the PATH
  LODSB                 ;Get the next character of the name
  CMP  AL,':'           ;Is it a Colon?
  JE  >N30              ;If so, possible end-of-path
  CMP  AL,Backslash     ;Is it a backslash?
  JE  >N30              ;If so, possible end-of-path
  OR   AL,AL            ;End of File Name?
  JZ  >N50              ;If so, we're done
  JMP >N40              ;If not, keep looking
N30:                    ;Update end-of-path Pointer
  MOV  DI,SI            ;Save possible end-of-path pointer
N40:                    ;Not end-of-path yet
  JMP  N20              ;Keep looking
N50:                    ;At end of Path
  CMP  DI,CS:[BX]       ;Was there a real path?
  JE  >N70              ;If not, error
  MOV  B [DI],0         ;If OK, put 0 at end of Path
  JMP >N90              ;Done
N70:                    ;No Path
  MOV  W CS:[BX],-1     ;Set Pointer as Invalid
N90:                    ;Done
  POP  ES,DS            ;Restore used registers
  POP  SI,DI,CX,BX,AX   ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO SET UP COMMAND TAIL WITH PROPER PARAMETERS FOR EXEC CALL
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;APPEND A STRING (ASCIIZ) TO THE EXEC COMMAND-TAIL STRING
;Inputs:  CS = DS = Local Data Area
;         CmdTail, already appended with CR's
;         DS:[DX] = String to Append
;         CLD already issued
;Outputs: String is Appended to CmdTail
;Changes:
;------------------------------------------------------------------------------
AppendString2Cmd:
  PUSH DI,SI,ES       ;Save used registers
  MOV  SI,DX          ;Point DS:[SI] at the String to Copy
  MOV  ES,DS          ;Point ES:[DI] at the end
  CALL FindCmdTailEnd ;  of the Command Tail
A10:                  ;Loop to here for each character in the String
  CMP  B [SI],0       ;End of the string?
  JE  >A90            ;If so, we're done
  MOVSB               ;If not, copy the character to the Command-Tail String
  JMP  A10            ;Keep going until we're done
A90:                  ;Done
  POP  ES,SI,DI       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;APPEND A HEX BYTE TO THE EXEC COMMAND-TAIL STRING
;Inputs:  CS = DS = Local Data Area
;         CmdTail, already appended with CR's
;         AL = Byte to Append
;         CLD already issued
;Outputs: Byte is Appended to CmdTail (Hex Value, followed by an "h")
;Changes:
;------------------------------------------------------------------------------
AppendHexByte2Cmd:
  PUSH DI             ;Save used registers
  CALL FindCmdTailEnd ;Point DS:[DI] at the end of the Command Tail
  CALL Byte2HexString ;Append the Hex Byte (modifies DI)
  MOV  B [DI],'h'     ;Append an 'h'
  POP  DI             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;APPEND A HEX WORD TO THE EXEC COMMAND-TAIL STRING
;Inputs:  CS = DS = Local Data Area
;         CmdTail, already appended with CR's
;         AX = Word to Append
;         CLD already issued
;Outputs: Word is Appended to CmdTail (Hex Value, followed by an "h")
;Changes:
;------------------------------------------------------------------------------
AppendHexWord2Cmd:
  PUSH DI             ;Save used registers
  CALL FindCmdTailEnd ;Point DS:[DI] at the end of the Command Tail
  CALL Word2HexString ;Append the Hex Word (modifies DI)
  MOV  B [DI],'h'     ;Append an 'h'
  POP  DI             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;APPEND A SEGMENT:OFFSET VALUE TO THE EXEC COMMAND-TAIL STRING
;Inputs:   AX  = Segment to Write
;          CX  = Offset to Write
;Outputs: CX:AX is Appended to CmdTail (Hex Values)
;Changes:
;------------------------------------------------------------------------------
AppendSegOff2Cmd:
  PUSH AX,DI          ;Save used registers
  CALL FindCmdTailEnd ;Point DS:[DI] at the end of the Command Tail
  CALL Word2HexString ;Append the Hex Segment Word (modifies DI)
  MOV  B [DI],':'     ;Append a
  INC  DI             ;  colon
  MOV  AX,CX          ;Append the
  CALL Word2HexString ;  Hex Offset Word (modifies DI)
  POP  DI,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;APPEND THE APPROPRIATE CALL-BACK ADDRESS TO THE EXEC COMMAND-TAIL STRING
;Inputs:  CS = DS = Local Data Area
;Outputs: Call-Back Address is Appended to CmdTail (Hex Values)
;         [CmdTailSize] is calculated and stored
;Changes:
;------------------------------------------------------------------------------
AppendCallBack2Cmd:
  PUSH AX,CX,DI          ;Save used registers
  MOV  AX,CS             ;Assume we'll use our own
  MOV  CX,WriteZPauseFar ;  Call-Back Address
  CALL AppendSegOff2Cmd  ;Store the Segment:Offset
  CALL FindCmdTailEnd    ;Calculate how many
  DEC  DI                ;  characters
  MOV  B [DI],CR         ;  are in
  SUB  DI,CmdTail        ;  the command tail
  MOV  AX,DI             ;Store it
  MOV  [CmdTailSize],AL  ;  in [CmdTailSize]
  POP  DI,CX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE THE EXEC COMMAND-TAIL STRING (FILL IT UP WITH CR's)
;Inputs:  CS = DS = Local Data Area
;         CmdTail
;         CLD already issued
;Outputs: CmdTail is filled with Carriage Returns
;Changes:
;------------------------------------------------------------------------------
InitCmdTail:
  PUSH AX,CX,DI,ES   ;Save used registers
  MOV  AL,CR         ;Write Carriage Returns
  MOV  CX,CmdTailMax ;CX = Number of Bytes to Write
  MOV  ES,DS         ;Point ES:[DI] at
  MOV  DI,CmdTail    ;  the Command tail
  REP  STOSB         ;Do it
  POP  ES,DI,CX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE END OF THE COMMAND-TAIL STRING, ADD A SPACE, AND RETURN POINTER
;Inputs:  CS = DS = Local Data Area
;         CmdTail, already filled with CR's
;         CLD already issued
;Outputs: [DI] = Command Tail Pointer (end of Command String), after a
;           space has been added
;Changes:
;------------------------------------------------------------------------------
FindCmdTailEnd:
  PUSH AX,CX,ES       ;Save used registers
  MOV  AL,CR          ;Look for a CR (end-of-tail marker)
  MOV  CX,-1          ;Maximize the Counter
  MOV  ES,DS          ;Point ES:[DI] at
  MOV  DI,CmdTail     ;  the Command tail
  REPNE SCASB         ;Look for the end of the Command-Tail String
  CMP  DI,(CmdTail+1) ;Is there anything yet in the Command-Tail String?
  JNE >E20            ;If so, continue
E10:                  ;Nothing yet in the Command-Tail String
  DEC  DI             ;Point at String Start (don't need a Space)
  JMP >E90            ;Done
E20:                  ;Something already in the Comand-Tail String
  MOV  B [DI-1],' '   ;Append a Space to the Command Tail
E90:                  ;Done
  POP  ES,CX,AX       ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO LOAD OVERLAY FILE (USBUHCI.OVL) INTO MEMORY
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;MOVE THE DISK TRANSFER AREA TO A NEW LOCATION
;Inputs:  DS = ES = Local Data Segment
;         FCB1 = New DTA Area
;Outputs:
;Changes: Disk Transfer Area
;NOTES: We don't bother checking for an error here - there's no reason
;         that this should fail.
;------------------------------------------------------------------------------
MoveDTA:
  PUSH AX,DX   ;Save used registers
  MOV  AH,1Ah  ;Function 1Ah (Set DTA Address)
  MOV  DX,FCB1 ;DS:DX = New DTA Address
  INT  21h     ;Do it
  POP  DX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND AND LOAD THE OVERLAY FILE INTO MEMORY
;Inputs:  DS = ES = Local Data Segment
;Outputs: If OK, [OvlSegment] = Segment where Overlay File is Loaded
;         If Error, prints error message and quits program
;Changes: PathToUse
;------------------------------------------------------------------------------
LoadOvlFile:
  CALL FindOvlFile ;Find Overlay File (quits if error, else sets [OvlSegment])
  CALL OpenOvlFile ;Open Overlay File
  CALL TestOvlFile ;Test Overlay for validity (quits if invalid)
  RET

;------------------------------------------------------------------------------
;FIND THE OVERLAY FILE
;Inputs:  DS = ES = Local Data Area
;Outputs: If OK, PathToUse = File Name we've found, including Path
;         [OvlSegment] = Segment to use to store Overlay Data (correctly sized)
;         If not found, prints error message and quits program
;Changes:
;------------------------------------------------------------------------------
FindOvlFile:
  PUSH AX,BX,DI,SI,ES    ;Save used registers
  MOV  DI,OvlFileName    ;DS;[DI] = File Name to Look For
  MOV  SI,OurPathPointer ;Point [SI] at our Program's Path
  CMP  SI,-1             ;Valid?
  JE  >F70               ;If not, skip it
  MOV  ES,[PSPEnvirSeg]  ;Point ES at the Environment Segment
  CALL CopyPathName      ;Copy it
  CALL FindFile          ;File exists?
  JC  >F70               ;If not, error
  CMP  W FCB1[1Ah][2],0  ;Is the file more than 64k in size?
  JNE >F70               ;If so, error
  MOV  BX,W FCB1[1Ah][0] ;BX = File Size
  CMP  BX,12000          ;Is the file too small?
  JB  >F70               ;If so, error
  CMP  BX,20000          ;Is the file too big?
  JA  >F70               ;If so, error
  MOV  [OvlFileSize],BX  ;If OK, store the Size
  ADD  BX,15             ;Convert file size
  SHR  BX,4              ;  to number of paragraphs
  MOV  AH,48h            ;Service 48h (Allocate Memory Block)
  INT  21h               ;Do it (uses BX = # paragraphs, rtns AX = Sgmt)
  MOV  [OvlSegment],AX   ;Store the Segment Address
  JMP >F90               ;Done
F70:                     ;Error
  JMP  HandleOvlErr      ;Quit the Program
F90:                     ;OK
  POP  ES,SI,DI,BX,AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;OPEN AND COPY THE OVERLAY FILE INTO A NEW MEMORY SEGMENT
;Inputs:  DS = ES = Local Data Area
;         [OvlSegment] = Segment to Copy Overlay File to (already sized)
;         PathToUse = Overlay File Name, including Path
;                     (Already verified for file existence)
;         [OvlFileSize] = Size of Overlay File Data
;Outputs: If OK, [OvlSegment] = filled with Data
;         If error, prints error message and quits program
;Changes:
;------------------------------------------------------------------------------
OpenOvlFile:
  PUSH AX,BX,CX,DX      ;Save used registers
  MOV  AX,3D00h         ;Service 3D (Open File), read access, compatibility mode
  MOV  DX,PathToUse     ;DS:[DX] = Filename
  INT  21h              ;Open the file (returns AX = Handle)
  JC  >O70              ;If error, handle it
  MOV  BX,AX            ;BX = Handle
  MOV  AH,3Fh           ;Function 3Fh (Read from file)
  MOV  CX,[OvlFileSize] ;CX= Number of Bytes to Read
  PUSH DS               ;Save DS for a second
  MOV  DS,[OvlSegment]  ;DS:[DX] = Where to
  XOR  DX,DX            ;  copy the data
  INT  21h              ;Do it
  POP  DS               ;Restore DS
  MOV  AH,3Eh           ;Function 3Eh (Close File)
  INT  21h              ;Do it
  JMP >O90              ;Done
O70:                    ;Error
  JMP  HandleOvlErr     ;Quit the Program
O90:                    ;Done
  POP  DX,CX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST THE OVERLAY FILE SIGNATURE & VERSION
;Inputs:  DS = ES = Local Data Area
;         [OvlSegment] = Overlay File in Memory
;         CLD already issued
;Outputs: If OK, PathToUse = File Name we've found, including Path
;         If not found, prints error message and quits program
;Changes:
;------------------------------------------------------------------------------
TestOvlFile:
  PUSH AX,CX,DI,SI,ES     ;Save used registers
  MOV  SI,OvlSignature    ;DS:[SI] = Local Signature String
  MOV  ES,[OvlSegment]    ;ES:[DI] = Signature String
  XOR  DI,DI              ;  in Overlay area
  MOV  CX,OvlSignatureLen ;CX = Length of String
  REPE CMPSB              ;Does the signature match?
  JNZ >T70                ;If not, error
  CMP  W ES:[DI+7],AMISVersion ;Is it the correct overlay version?
  JE  >T90                ;If so, we're done
T70:                      ;Error
  JMP  HandleOvlErr       ;Quit the Program
T90:                      ;Done
  POP  ES,SI,DI,CX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE AN ERROR IN THE OVERLAY FILE (NOT FOUND, INCORRECT FILE, ETC>)
;Inputs:  DS = Local Data Area
;Outputs: Writes Error Message to screen, quits program with ErrorLevel
;Changes:
;------------------------------------------------------------------------------
HandleOvlErr:
  MOV  DX,OvlNotFoundMsg  ;Write first part of
  CALL WriteZErr          ;  Error Message
  MOV  DX,OvlFileName     ;Write second part of
  CALL WriteZErr          ;  Error Message
  MOV  DX,OvlNotFoundMsg2 ;Point at last part of Error Message
  MOV  AL,ErLvlNoOvl      ;AL = ErrorLevel = No OverLay File
  JMP  Exit               ;Done


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO COPY DATA FROM THE REDIRECTED INPUT FILE, "COMPRESSING" IT AND
;  STORING IT IN OUR LOCAL MEMORY BUFFER.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SETUP AN EXTRA MEMORY SEGMENT FOR STDIN PARSING
;Inputs:  DS = Local Data Area
;Outputs: [StdInSegment] = New Segment
;         Quits Program with Error Message if Memory Problem
;Changes:
;------------------------------------------------------------------------------
GetStdInSegment:
  PUSH AX,BX             ;Save used registers
  MOV  BX,4096           ;Number of Paragraphs to allocate (64 kB)
  MOV  AH,48h            ;Service 48h (Allocate Memory Block)
  INT  21h               ;Do it (uses BX = # paragraphs, rtns AX = Sgmt)
  JC  >X70               ;If Error, Quit
  MOV  [StdInSegment],AX ;If OK, store the segment
  JMP >X90               ;Done
X70:                     ;Error
  MOV  DX,SIDStdInMemory ;Point at Error Message
  MOV  AL,ErLvlMemory    ;ErrorLevel = Memory Problem
  JMP  Exit              ;Quit
X90:                     ;Done
  POP  BX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ THE DATA FROM STDIN (REDIRECTED INPUT) AND STORE IT IN OUR BUFFER
;Inputs:  [StdInSegment]
;Outputs:
;Changes: Fills up StdInBuffer
;         As data is read, multiple spaces are converted to single spaces,
;           and EOL's (CR/LF) are also changed to spaces
;         Last character of buffer is a 0
;         Quits with error message if StdIn is too big for buffer
;------------------------------------------------------------------------------
FillStdInBuffer:
  PUSH AX,DI,ES             ;Save used registers
  CALL FlushKbdBuff         ;Don't let keyboard buffer mess with File Input
  MOV  ES,[StdInSegment]    ;Point ES:DI at
  XOR  DI,DI                ;  our Buffer
  MOV  AL,' '               ;Start the buffer
  STOSB                     ;  with a space
B10:                        ;Loop to here for each character
  CALL ReadStdInChar        ;Get the next character
  JZ  >B80                  ;If end of input, we're done
B15:                        ;AL contains the next character
  CMP  AL,EOF               ;Is it End-of-File?
  JE  >B80                  ;If so, it's the end of input
B20:                        ;Test for Comment
  CMP  AL,';'               ;Is it the start of a comment?
  JNE >B30                  ;If not, try the next possibility
  CALL SkipOverStdInComment ;If so, skip over the comment
  JC  >B80                  ;If EOF, we're done
  JMP  B10                  ;If not EOF, continue
B30:                        ;Test for String
  CMP  AL,'"'               ;Double Quote?
  JE  >B35                  ;If so, handle a string
  CMP  AL,"'"               ;Single Quote?
  JE  >B35                  ;If so, handle a string
  CMP  AL,"`"               ;Left Quote?
  JNE >B40                  ;If not, try the next possibility
B35:                        ;It's a String
  CALL GetStdInString       ;Get the rest of the String
  JC  >B80                  ;If error, just quit (Error handled later)
  JMP  B10                  ;If OK, continue
B40:                        ;Test for EOL
  CMP  AL,CR                ;Carriage Return?
  JE  >B45                  ;If so, handle it
  CMP  AL,LF                ;Carriage Return?
  JNE >B50                  ;If not, it's a regular character
B45:                        ;End of Line
  CALL AddSpace2StdInBuff   ;Add a Space to the Buffer, if needed
  JMP  B10                  ;Continue
B50:                        ;Is a regular character
  CALL AddChar2StdInBuff    ;Add the character to the buffer
  JMP  B10                  ;Continue
B80:                        ;Done, no error
  XOR  AL,AL                ;Mark the end
  STOSB                     ;  of the buffer
B90:                        ;Done
  POP  ES,DI,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER A COMMENT IN THE REDIRECTED INPUT FILE
;Inputs:  DS = Local Data Area
;         ES:[DI] = StdInBuffer
;         AL = Semicolon (the start of the Comment)
;Outputs: CF = Clear if OK (not EOF)
;            = Set if we've reached EOF
;         Quits Program with error message if Buffer gets full
;Changes:
;NOTES: This looks for either an EOF or LF character to indicate the end of
;         the comment.  If we see a CR, we simply skip it and wait for the LF
;         that should immediately follow the CR.
;       If a line ends in a CR or CR/LF combination, this will not work
;         this will not work correctly.  However, no file we work with
;         should ever be in that format.
;------------------------------------------------------------------------------
SkipOverStdInComment:
  PUSH AX                 ;Save used registers
C10:                      ;Loop to here for each character on the line
  CALL ReadStdInChar      ;Get the next character (AL)
  JZ  >C70                ;If no characters available, EOF
  CMP  AL,EOF             ;End-of-File character?
  JE  >C70                ;If so, we're done
  CMP  AL,CR              ;Carriage Return?
  JE  >C20                ;If so, End of Comment
  CMP  AL,LF              ;Line Feed?
  JNE  C10                ;If not, keep looking
C20:                      ;End of Line
  CALL AddSpace2StdInBuff ;Add a Space to the Buffer if we need it
  JMP >C80                ;Done
C70:                      ;EOF
  STC                     ;Set EOF Flag
  JMP >C90                ;Done
C80:                      ;Not EOF
  CLC                     ;Set not EOF Flag
C90:                      ;Done
  POP  AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY A STRING FROM STDIN TO THE STDINBUFFER
;Inputs:  DS = Local Data Area
;         ES:[DI] = StdInBuffer
;         AL = Quote Characer (the start of the String)
;Outputs: CF = Clear if OK (not EOF)
;            = Set if we've reached EOF (Bad String)
;         Quits Program with error message if Buffer gets full
;Changes:
;NOTES: This looks for the matching Quote Character to indicate the end of
;         the String.
;       If we find an EOF, CR, or LF in the string, we return a CF to indicate
;         a bad String.
;------------------------------------------------------------------------------
GetStdInString:
  PUSH AX                 ;Save used registers
  MOV  AH,AL              ;Save quote character
  CALL AddSChar2StdInBuff ;Add the Quote Character to the Buffer
S10:                      ;Loop to here for each character of string
  CALL ReadStdInChar      ;Get the next character (AL)
  JZ  >S70                ;If no characters available, Error
  CMP  AL,EOF             ;End-of-File character?
  JE  >S70                ;If so, Error
  CMP  AL,CR              ;Carriage Return?
  JE  >S70                ;If so, Error
  CMP  AL,LF              ;Line Feed?
  JE  >S70                ;If so, Error
  CALL AddSChar2StdInBuff ;Add the Character to the Buffer
  CMP  AL,AH              ;Is it the end-of-string character?
  JNE  S10                ;If not, keep looking
  JMP >S80                ;Done
S70:                      ;EOF (Bad String)
  STC                     ;Set EOF Flag
  JMP >S90                ;Done
S80:                      ;String is OK
  CLC                     ;Set OK flag
S90:                      ;Done
  POP  AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ A CHARACTER FROM STDIN (REDIRECTED INPUT)
;Inputs:
;Outputs: AL = Next character from StdIn
;              ZF Clear
;            = 0 if no character to get
;              ZF Set
;Changes:
;------------------------------------------------------------------------------
ReadStdInChar:
  PUSH DX      ;Save used registers
  MOV  DH,AH   ;Save original AH
  MOV  AH,06h  ;Function 06h
  MOV  DL,0FFh ;  (Direct Console Input)
  INT  21h     ;Do it (returns AL and ZF)
  MOV  AH,DH   ;Restore original AH
  POP  DX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADD A CHARACTER OR STRING CHARACTER TO THE END OF THE STDIN BUFFER
;Inputs:  DS = Local Data Area
;         ES:[DI] = StdInBuffer
;         AL = Character to add to end of Buffer
;         CLD already issued
;Outputs: Returns to calling program if Character was added OK
;         Quits Program with Error if Buffer is already full
;Changes: DI (maybe)
;------------------------------------------------------------------------------
AddSpace2StdInBuff:
  PUSH AX                ;Save used registers
  MOV  AL,' '            ;Add a Space to the Buffer
  CALL AddChar2StdInBuff ;  if we need it
  POP  AX                ;Restore used registers
  RET

AddChar2StdInBuff:
  CMP  AL,' '            ;Are we adding a space?
  JNE >B00               ;If not, just add it
  CMP  B ES:[DI-1],AL    ;If so, is there already a space?
  JNE >B00               ;If not, just add it
  JMP >B90               ;If so, we're done
AddSChar2StdInBuff:
B00:                     ;Add the character to the Buffer
  CMP  DI,65534          ;Is the Buffer full?
  JAE >B70               ;If so, Error
  STOSB                  ;If not, Store the Character
  JMP >B90               ;Done
B70:                     ;Buffer already Full
  MOV  DX,SIDStdInTooBig ;Point at error message
  MOV  AL,ErLvlStdIn     ;ErrorLevel = problem with StdIn
  JMP  Exit              ;Quit
B90:                     ;Done
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;DEBUGGING CODE TO TRACK PROGRAM INITIALIZATION & UNINSTALLATION
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PROCESS A PROGRAM DEBUG GENERAL STATISTICS REQUEST
;Inputs:  CS = Local Data Segment
;         ES = TSR Data Area
;         [ProgFlags].DebugFlag (If not set, we don't do anything)
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DbgGenStats:
  PUSHF                   ;Save flags
  CMP  CS:[DebugDelay],-1 ;Do we need to do anything?
  JNE >G00                ;If so, do it
  POPF                    ;Restore flags
  RET

G00:
  PUSH EAX,DX,DS                 ;Save used registers
  MOV  DS,CS                     ;DS = Local Data Area

  MOV  DX,SIDProgDebug           ;Write the PCI Bus-Device-Function
  CALL WriteZPause
  MOV  DX,SIDBusDevFunc
  CALL WriteZPause
  MOV  AL,B ES:[PCIDevFunc][1]
  CALL WriteByteMin
  CALL WriteDash
  MOV  AL,B ES:[PCIDevFunc][0]
  SHR  AL,3
  CALL WriteByteMin
  CALL WriteDash
  MOV  AL,B ES:[PCIDevFunc][0]
  AND  AL,07h
  CALL WriteByteMin
  CALL WriteCrLfPause

  MOV  DX,SIDProgDebug           ;Write the PCI Search Index
  CALL WriteZPause
  MOV  DX,SIDPCISearchIdx
  CALL WriteZPause
  MOV  AL,B ES:[PCISearchIndex][0]
  CALL ByteToString
  CALL WriteCrLfPause

  MOV  DX,SIDProgDebug           ;Write the IRQ Number
  CALL WriteZPause
  MOV  DX,SIDIRQNumber
  CALL WriteZPause
  MOV  AL,ES:[USBIRQNum]
  CALL ByteToString
  CALL WriteCrLfPause

  MOV  DX,SIDProgDebug           ;Write the Base I/O Address
  CALL WriteZPause
  MOV  DX,SIDBaseIO
  CALL WriteZPause
  MOV  AX,ES:[BaseIOAddress]
  CALL WriteWordHex
  CALL writeHexEnd
  CALL WriteCrLfPause

  MOV  DX,SIDProgDebug           ;Write the Frame List Address
  CALL WriteZPause
  MOV  DX,SIDFrameListAddr
  CALL WriteZPause
  MOV  EAX,ES:[FLOffsetDW]
  CALL WriteDWordHex
  CALL writeHexEnd
  CALL WriteCrLfPause2

G90:                             ;Done
  POP  DS,DX,EAX                 ;Restore used registers
  POPF                           ;Restore flags
  RET

;------------------------------------------------------------------------------
;PROCESS A PROGRAM DEBUG REQUEST
;Inputs:  CS = Local Data Segment
;         [ProgFlags].DebugFlag (If not set, we don't do anything)
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DbgStopHost:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDStopHost       ;Store Debug ID
  JMP >D000                 ;Do it
DbgEnBusMaster:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDEnBusMaster    ;Store Debug ID
  JMP >D000                 ;Do it
DbgDisSMIFlags:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDDisSMIFlags    ;Store Debug ID
  JMP >D000                 ;Do it
DbgEnResumeDet:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDEnResumeDet    ;Store Debug ID
  JMP >D000                 ;Do it
DbgRedirGenInts:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDRedirGenInts   ;Store Debug ID
  JMP >D000                 ;Do it
DbgRedirUSBInt:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDRedirUSBInt    ;Store Debug ID
  JMP >D000                 ;Do it
DbgResetHost:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDResetHost      ;Store Debug ID
  JMP >D000                 ;Do it
DbgSetFLAddress:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDSetFLAddress   ;Store Debug ID
  JMP >D000                 ;Do it
DbgFrameTiming:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDFrameTiming    ;Store Debug ID
  JMP >D000                 ;Do it
DbgStartFrame:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDStartFrame     ;Store Debug ID
  JMP >D000                 ;Do it
DbgEnIRQFlags:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDEnIRQFlags     ;Store Debug ID
  JMP >D000                 ;Do it
DbgDisSMIGen:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDDisSMIGen      ;Store Debug ID
  JMP >D000                 ;Do it
DbgEnIRQGen:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDEnIRQGen       ;Store Debug ID
  JMP >D000                 ;Do it
DbgStartHost:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDStartHost      ;Store Debug ID
D000:                       ;To avoid JMP > 128
  JMP >D00                  ;Do it
DbgVerifyHost:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDVerifyHost     ;Store Debug ID
  JMP >D00                  ;Do it
DbgInitRootHub:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDInitRootHub    ;Store Debug ID
  JMP >D00                  ;Do it
DbgVerifyIRQ:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDVerifyIRQ      ;Store Debug ID
  JMP >D00                  ;Do it
DbgRestoreUSBInt:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDRestoreUSBInt  ;Store Debug ID
  JMP >D00                  ;Do it
DbgRestorePort1:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDRestorePort1   ;Store Debug ID
  JMP >D00                  ;Do it
DbgRestorePort2:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDRestorePort2   ;Store Debug ID
  JMP >D00                  ;Do it
DbgEnSMIFlags:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDEnSMIFlags     ;Store Debug ID
  JMP >D00                  ;Do it
DbgEnSMIGen:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDEnSMIGen       ;Store Debug ID
  JMP >D00                  ;Do it
DbgRestoreIRQ:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDRestoreIRQ     ;Store Debug ID
  JMP >D00                  ;Do it
DbgRestorePCI:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDRestorePCI     ;Store Debug ID
  JMP >D00                  ;Do it
DbgRestoreGenInts:
  PUSH AX                   ;Save used registers
  MOV  AL,SIDRestoreGenInts ;Store Debug ID
;  JMP >D00                 ;Do it
D00:
  PUSHF                   ;Save flags
  CMP  CS:[DebugDelay],-1 ;Are we Debugging?
  JZ  >D95                ;If not, quit
  PUSH DX,DS              ;Save used registers
  MOV  DS,CS              ;DS = Local Data Area
  PUSH AX                 ;Save AX momentarily
  MOV  AX,[DebugDelay]    ;Delay
  CALL DelayMSAX          ;  as appropriate
  POP  AX                 ;Restore AX
  MOV  DX,SIDProgDebug    ;Write the first part
  CALL WriteZPause        ;  of the message
  MOV  DL,AL              ;Write the second part
  CALL WriteZPause        ;  of the message
  CALL WriteCrLfPause     ;Move down
D90:                      ;Done
  POP  DS,DX              ;Restore used registers
D95:                      ;Done - no saved registers
  POPF                    ;Restore flags
  POP  AX                 ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO AUTOMATICALLY MOVE THE PROGRAM INTO UPPER MEMORY
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TRY TO ALLOCATE A UMB, AND COPY THE PROGRAM TO THE UMB SEGMENT
;Inputs:  DS = ES = Current Data Segment
;Outputs: ES = New Data Segment (in UMB or Low Memory Hole)
;              If no UMB or Low Memory Hole is available, ES remains unchanged
;         Entire TSR Portion of Program is copied to new Segment
;Changes:
;------------------------------------------------------------------------------
MoveProgramToUMB:
  PUSH AX,BX,CX,DX,DI,SI           ;Save used registers
  MOV  AX,DS                       ;Save original Data Segment
  CMP  AX,[FirstUMCB]              ;Already in Upper Memory?
  JAE >U90                         ;If so, just quit
  TEST [ProgFlags],UseLowMemory    ;Does user want us in Low Memory?
  JNZ >U90                         ;If so, just quit
  MOV  BX,(LastTSRByte+15)SHR 4    ;Number of TSR paragraphs if First Instance
  TEST ES:[TSRFlags],Firstinstance ;Is this the First Instance?
  JNZ >U10                         ;If so, it's OK
  MOV  BX,(LastTSRByte0+15)SHR 4   ;If not, Number of TSR paragraphs is this
U10:                               ;BX contains number of Paragraphs needed
  CALL AllocateUMBDOS              ;Try to get a UMB from DOS (Returns ES)
  JZ  >U90                         ;If it didn't work, quit
  MOV  DX,ES                       ;Save new Segment
  PUSH DS                          ;Save data Segment
  MOV  AX,DS                       ;Point DS
  DEC  AX                          ;  at current
  MOV  DS,AX                       ;  MCB
  MOV  AX,ES                       ;Point ES
  DEC  AX                          ;  at new
  MOV  ES,AX                       ;  MCB
  MOV  SI,OFFSET MCBOwnerName      ;Copy
  MOV  DI,SI                       ;  the
  MOV  CX,4                        ;  Owner
  REP  MOVSW                       ;  Name
  POP  DS                          ;Restore Data Segment
  MOV  ES:[MCBOwnerID],DX          ;Make itself the Owner
  MOV  AH,26h                      ;Function 26h (Create new PSP, DX = Segment)
  INT  21h                         ;Do it
  MOV  ES,DX                       ;Point ES at new Segment again
  ADD  DX,BX                       ;Calculate where next Segment will be
  MOV  ES:[PSPNextSegment],DX      ;Store it in the PSP
  SHL  BX,2                        ;Calculate
  MOV  CX,BX                       ;  number of DWords
  SUB  CX,(PSPStrucSize/4)         ;  to Copy
  MOV  SI,PSPStrucSize             ;SI = Old Data
  MOV  DI,SI                       ;DI = New Data
  REP  MOVSD                       ;Copy Program to new Segment
  OR   [ProgFlags],MemoryMoved     ;Mark memory as having been moved
U90:                               ;Done
  POP  SI,DI,DX,CX,BX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TRY TO ALLOCATE A UMB THROUGH DOS
;Inputs:  BX = Number of Paragraphs to Allocate
;Outputs: ZF = Clear if OK
;              ES = Segment of Allocated UMB
;            = Set if Error
;              ES = Unchanged
;Changes:
;NOTES: Allocating USB's through DOS normally requires a
;         DOS=HIGH,UMB line in CONFIG.SYS
;------------------------------------------------------------------------------
AllocateUMBDOS:
  PUSHA              ;Save all registers
  MOV  CX,ES         ;Save original ES
  MOV  DI,BX         ;Save Number of Paragraphs to Allocate
  MOV  AX,5800h      ;Function 5800h (Get Memory Allocation Strategy)
  INT  21h           ;Do it (returns AX)
  JC  >D90           ;If error, quit
  MOV  SI,AX         ;If OK, save it
  MOV  AX,5802h      ;Function 5802h (Get UMB Link State - DOS 5+ Only)
  INT  21h           ;Do it (Returns AL)
  JC  >D90           ;If error, quit
  MOV  DL,AL         ;If OK, Save it
  MOV  BX,UMBLinkYes ;Enable USB's in DOS Memory Chain
  MOV  AX,5803h      ;Function 5803h (Set UMB Link State)
  INT  21h           ;Do it
  JC  >D90           ;If error, quit
  MOV  BX,StrategyHighLowBest ;Strategy = Try High, then Low, Best Fit
  MOV  AX,5801h      ;Do
  INT  21h           ;  it
  JC  >D80           ;If error, quit
D20:                 ;Strategy is set
  MOV  BX,DI         ;BX = # of Paragraphs to Allocate
  MOV  AH,48h        ;Function 48h (Allocate Memory)
  INT  21h           ;Do it (returns AX = Segment)
  JC  >D80           ;If error, quit
  MOV  ES,AX         ;If OK, put Segment in ES
  CMP  AX,0A000h     ;Is it really a UMB?
  JAE >D80           ;If so, continue
  MOV  DI,CS         ;If not, is it a memory "hole" lower in memory
  CMP  AX,DI         ;  than we are (from a previously removed TSR)?
  JB  >D80           ;If so, continue
  MOV  AH,49h        ;Function 49h (Free Memory, Segment in ES)
  INT  21h           ;Do it
  MOV  ES,CX         ;Restore original ES
D80:                 ;Restore original UMB Link State & Strategy
  XOR  BH,BH         ;Restore
  MOV  BL,DL         ;  original
  MOV  AX,5803h      ;  USB
  INT  21h           ;  Link State
  MOV  BX,SI         ;Restore original
  MOV  AX,5801h      ;  Memory Allocation
  INT  21h           ;  Strategy
D90:                 ;Done
  MOV  AX,ES         ;Set
  CMP  CX,AX         ;  Return Flag
  POPA               ;Restore all registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE FOR MEMORY STUFF
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;LOCATE THE SEGMENT OF THE FIRST UMCB
;Inputs:  CS = DS = Local Segment
;Outputs: [FirstUMCB]
;Changes:
;NOTES: Normally, we can assume that USB's start at segment A000h, but
;         sometimes that is not true.  This finds the real address of the
;         first UMB.
;       The only thing we do with this is compare to it, since it may not
;         be a legitimate MCB segment.
;       The idea to perform this check and the code that this was based
;         on is courtesy if Christian Masloch.
;       Note that we actually store the MCB of the first UMB, which is
;         one less than the UMB address itself.  This will usually be
;         be 9FFFh (the first UMB is usually A000h), but not always.
;------------------------------------------------------------------------------
FindFirstUMCB:
  PUSH AX,BX,CX,DX                   ;Save used registers
  PUSH ES                            ;Save used registers
  MOV  AX,5802h                      ;Function 5802h
                                     ;  (Get UMB Link State - DOS 5+ Only)
  INT  21h                           ;Do it (Returns AL)
  JC  >F90                           ;If error, done
  MOV  CL,AL                         ;If OK, save it
  MOV  BX,UMBLinkNo                  ;Disable UMB's in DOS Memory Chain
  MOV  AX,5803h                      ;Function 5803h (Set UMB Link State)
  INT  21h                           ;Do it
  JC  >F90                           ;If error, done
  CALL FindLastMCB                   ;Locate the last MCB (Returns AX)
  JC  >F60                           ;If error, no UMB found
  MOV  ES,AX                         ;ES = Last LMCB Segment
  MOV  BX,UMBLinkYes                 ;Enable UMB's in DOS Memory Chain
  MOV  AX,5803h                      ;Function 5803h (Set UMB Link State)
  INT  21h                           ;Do it
  JC  >F60                           ;If error, done
  XOR  BX,BX                         ;Use Offset 0
  CMP  ES:[BX].MCBID,MCBIDLastInList ;Still the Last MCB?
  JE  >F60                           ;If so, no UMB's found
  CMP  ES:[BX].MCBID,MCBIDValid      ;If not, is it still a valid MCB?
  JNE >F60                           ;If not, no UMB's found
  MOV  AX,ES                         ;If so,
  ADD  AX,ES:[BX].MCBSize            ;  store the
  INC  AX                            ;  First
  MOV  [FirstUMCB],AX                ;  UMB Segment
F60:                                 ;Done with DOS UMB Links
  XOR  BH,BH                         ;Restore
  MOV  BL,CL                         ;  original
  MOV  AX,5803h                      ;  UMB
  INT  21h                           ;  Link State
F90:                                 ;Done
  POP  ES                            ;Restore used registers
  POP  DX,CX,BX,AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE LAST MEMORY CONTROL BLOCK
;Inputs:
;Outputs: CF = Clear if OK (Last MCB Found)
;              AX = Last MCB Segment
;            = Set if Error
;              AX = Unchanged
;Changes:
;------------------------------------------------------------------------------
FindLastMCB:
  PUSH BX,CX,DS,ES                ;Save used registers
  MOV  CX,AX                      ;Save original ES
  MOV  AH,52h                     ;Function 52h (Get List of Lists Pointer)
  INT  21h                        ;Do it (Returns ES:[BX])
  MOV  AX,ES:[BX-2]               ;AX = First MCB Segment
  XOR  BX,BX                      ;Start with Offset 0 in MCB
L10:                              ;Loop to here for each MCB
  MOV  DS,AX                      ;DS = MCB Segment to test
  CMP  [BX].MCBID,MCBIDLastInList ;Last MCB?
  JE  >L80                        ;If so, we're done
  CMP  [BX].MCBID,MCBIDValid      ;If not, is it even a valid MCB?
  JNE >L70                        ;If not, Error
  ADD  AX,[BX].MCBSize            ;If so, BX =
  INC  AX                         ;  Next MCB Segment
  JMP  L10                        ;Keep looking
L70:                              ;Error
  MOV  AX,CX                      ;Restore original AX
  STC                             ;Set return flag
  JMP >L90                        ;Done
L80:                              ;OK (AX = Appropriate Return Value)
  CLC                             ;Set return flag
L90:                              ;Done
  POP  ES,DS,CX,BX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FILL TSR STACK WITH TRACKING STRINGS
;Inputs:  CS = Local Data Area
;         DS = ES = TSR Data Area
;         [ProgFlags].MemoryMoved
;         CLD already issued
;Outputs: Fills Stack with 'TSRStack' string
;Changes:
;NOTES: If we moved to a UMB, we overwrite the entire PSP since it is not
;         needed any more.  If not (we will terminate with the TSR function),
;         we only overwrite the last half of the PSP which we know DOS
;         does not need to properly terminate the program.
;       In theory, we could overwrite the the first part of the PSP with
;         the signature after a short delay in the TSR, but that could
;         cause problems if large portions of the stack are used or if
;         we are inside a debugger where the delay will likely not be short.
;------------------------------------------------------------------------------
InitTSRStack:
  PUSH EAX,EBX,CX,DI                 ;Save used registers
  MOV  EBX,'SRST'                    ;EBX = First part of "TSRStack"
  MOV  EAX,'kcat'                    ;EAX = Second part of "TSRStack"
  XOR  DI,DI                         ;Assume we moved
  MOV  CX,(TSRStackSize/8)           ;  to a UMB
  TEST CS:[ProgFlags],MemoryMoved    ;Did we move to a UMB?
  JNZ >K30                           ;If so, continue
  ADD  DI,(OFFSET PSPCmdLineLen)     ;If not, adjust the pointer
  SUB  CX,((OFFSET PSPCmdLineLen)/8) ;  and the counter
K30:                                 ;Loop to here for each DWord
  XCHG EAX,EBX                       ;Write the
  STOSD                              ;  first four letters
  XCHG EAX,EBX                       ;Write the
  STOSD                              ;  second four letters
  LOOP K30                           ;Keep going until we're done
  TEST CS:[ProgFlags],MemoryMoved    ;Did we move to a UMB?
  JNZ >K90                           ;If so, we're done
  MOV  W CS:[0],0                    ;Get rid of INT 20h code at start of PSP
K90:                                 ;Done
  POP  DI,CX,EBX,EAX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE PHYSICAL ADDRESS OF OUR TSR IN MEMORY
;Inputs:  ES = Segment of TSR
;Outputs: ES:BasePhysAddr
;Changes:
;------------------------------------------------------------------------------
CalcBasePhysAddr:
  PUSH EAX                 ;Save used registers
  XOR  AX,AX               ;Use Offset 0 (beginning of Program)
  PUSH ES                  ;Put
  PUSH AX                  ;  ES:0000h
  POP  EAX                 ;  in EAX
  CALL SegOff2PhysAddrEAX  ;Calculate the Physical Address (returns EAX)
  MOV  ES:BasePhysAddr,EAX ;Store it
  POP  EAX                 ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SPACE AND CODE TO PROCESS OUR PROGRAM STACK
;  This code and must be physically at the END of the Program,
;    but must be one of the FIRST procedures called by the Program.
;  In addition, the Stack Pointer (SP) must be set properly
;    (to LastProgByte - 2) BEFORE this code is called.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;RESIZE OUR MEMORY ALLOCATION TO THE MINIMUM SIZE NEEDED
;Inputs:  SP = LastProgByte - 2
;         ES = Local Segment
;Outputs: Rellocates Memory to the minimum size required to run the program
;Changes:
;------------------------------------------------------------------------------
ResizeMemory:
  PUSH AX,BX  ;Save used registers
  MOV  AH,4Ah ;Function 4Ah (Resize Memory Block pointed at by ES)
  MOV  BX,(LastProgByte SHR 4) ;BX = Number of Paragraphs to Resize to
  INT  21h    ;Do it
  POP  BX,AX  ;Restore used registers
  RET

  EVEN 16
  DB (ProgStackSize/8) DUP ('PrgStack')

LastProgByte:
