  JMP Main ;Skip over TSR Code to Main Program


;==============================================================================
;NOTE: This program is written for and compiled with Eric Isaacson's A86
;      assembly language compiler, using Options +P0 -F (8086/8088 CPU
;      with no FPU).
;==============================================================================

;Handle TDStsDvcRemoved

;In DOCS:
;No way to Disable/Enable individual Hub
;There are a few USB 2 Hub references and items scattered throughout the code
;  and status messages, though USB 2 Hubs are not implemented yet (things like
;  software- vs. hardware-controlled LED's, and Transaction Translators).
;We download all Descriptors for the Hub, even though the only one we actually
;  need is the Hub Descriptor.  We do this so the user can see everything
;  there is to know about the Hub, even though it doesn't matter to this
;  Driver who the manufacturer is (or anything else).


;哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌
;EQUATE/STRUCTURE/MACRO DEFINITIONS
;苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘

;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;EQUATES
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;==============================================================================
;TSR Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Size of our TSR Stack
  ;----------------------------------------------------------------------------
  StackSize EQU 256

  ;----------------------------------------------------------------------------
  ;Special Interrupt 2Fh (TSR Multiplex) Function Numbers we monitor/use
  ;----------------------------------------------------------------------------
  MuxInstallChk  EQU 0 ;Handle # Install Check
  MuxGetProgName EQU 1 ;Get Program Name
  MuxGetProgVer  EQU 2 ;Get Program Version
  MuxGetAuthor   EQU 3 ;Get Program Author


;==============================================================================
;Miscellaneous
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special Codes
  ;----------------------------------------------------------------------------
  No  EQU  0 ;Miscellaneous Yes/No tests
  Yes EQU -1 ;      "        "  "    "


;==============================================================================
;CPU Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Bit masks in the CPU Flags Register
  ;----------------------------------------------------------------------------
  CarryFlag  EQU 0001h ;Carry Flag
  ParityFlag EQU 0004h ;Parity Flag
  AuxFlag    EQU 0010h ;Auxiliary Flag
  ZeroFlag   EQU 0040h ;Zero Flag
  SignFlag   EQU 0080h ;Sign Flag
  TrapFlag   EQU 0100h ;Trap Flag
  IntFlag    EQU 0200h ;Interrupt Flag
  DirFlag    EQU 0400h ;Direction Flag
  OFFlag     EQU 0800h ;Overflow Flag


;==============================================================================
;CONsole/Screen Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special ASCII Characters
  ;----------------------------------------------------------------------------
  Tab       EQU  9 ;Tab
  LF        EQU 10 ;Line Feed
  FormFeed  EQU 12 ;FormFeed
  CR        EQU 13 ;Carriage Return
  EOF       EQU 26 ;End-of-File
  Quote2    EQU 34 ;Double quote
  Quote1    EQU 39 ;Single quote
  BackSlash EQU 92 ;BackSlash (\)

  ;----------------------------------------------------------------------------
  ;Special Keys that can be pressed during Pause routine
  ;----------------------------------------------------------------------------
  CtrlC  EQU  3 ;Control-C Keystroke
  Escape EQU 27 ;Escape Keystroke


;==============================================================================
;DOS Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;;Minimum DOS Version required to use this program
  ;----------------------------------------------------------------------------
  MinDOSVer EQU 0300h

  ;----------------------------------------------------------------------------
  ;DOS Memory Allocation Strategies
  ;----------------------------------------------------------------------------
  StrategyLowFirst     EQU 00h ;First Fit, Low Memory Only
  StrategyLowBest      EQU 01h ;Best Fit, Low Memory Only
  StrategyLowLast      EQU 02h ;Last Fit, Low Memory Only
  ;For DOS 3&4, anything >2 is Last Fit Low Memory
  ;Below are for DOS 5+ Only
  StrategyHighFirst    EQU 40h ;First Fit, High Memory Only
  StrategyHighBest     EQU 41h ;Best Fit, High Memory Only
  StrategyHighLast     EQU 42h ;Last Fit, High Memory Only
  StrategyHighLowFirst EQU 80h ;First Fit, Try High Memory then Low Memory
  StrategyHighLowBest  EQU 81h ;Best Fit, Try High Memory then Low Memory
  StrategyHighLowLast  EQU 82h ;Last Fit, Try High Memory then Low Memory

  ;----------------------------------------------------------------------------
  ;UMB Link States
  ;----------------------------------------------------------------------------
  UMBLinkNo  EQU 00h ;UMB's are not part of DOS Memory Chain
  UMBLinkYes EQU 01h ;UMB's are in DOS Memory Chain (DOS=HIGH,UMB in CONFIG.SYS)

  ;----------------------------------------------------------------------------
  ;Sizes of various DOS data structures
  ;----------------------------------------------------------------------------
  FCBSize     EQU  44 ;Size of DOS File Control Block
  CmdTailMax  EQU 128 ;Maximum size of a DOS Command Tail
  MaxPathSize EQU  64 ;Maximum Size of a DOS Path/FileName String

  ;----------------------------------------------------------------------------
  ;Special "hard-coded" DOS Device Handles.
  ;These Handles are permanently hard-coded in DOS, and are always open.
  ;There is no need to issue Find, Open, or Close calls to these
  ;  devices - you can just use them at will.
  ;----------------------------------------------------------------------------
  StdInHandle  EQU 0 ;Standard Input Device Handle
  StdOutHandle EQU 1 ;Standard Output Device Handle
  StdErrHandle EQU 2 ;Standard Error Device Handle
  StdAuxHandle EQU 3 ;Standard Auxiliary Device Handle (COM1 by default)
  StdPrnHandle EQU 4 ;Standard Printer Device Handle (LPT1 by default)

  ;----------------------------------------------------------------------------
  ;Codes returned by INT 21h, Function 4400h (Get Device Information)
  ;----------------------------------------------------------------------------
  ;If bit 7 is Set (is a Device):
  DvcInfoIsStdIn    EQU 0001h ;STDIN
  DvcInfoIsStdOut   EQU 0002h ;STDOUT
  DvcInfoIsNUL      EQU 0004h ;NUL
  DvcInfoIsClock    EQU 0008h ;CLOCK$
  DvcInfoInt29h     EQU 0010h ;Uses Int 29h (Special Device)
  DvcInfoBinary     EQU 0020h ;Binary (Raw) Mode
  DvcInfoEOF        EQU 0040h ;EOF on Input
  DvcInfoIsDevice   EQU 0080h ;Is a Device (not a File)
  DvcInfoKEYB       EQU 0100h ;Unknown (set by DOS 6.2x KEYB program)
  DvcInfoOpenClose  EQU 0800h ;Supports Open/Close calls
  DvcInfoOutputBusy EQU 2000h ;Supports Output until Busy
  DvcInfoIOCTL      EQU 4000h ;Can process IOCTL requests (INT 21h, Func 4402h)

  ;If bit 7 is Clear (is a File):
  DvcInfoDriveMask    EQU 003Fh ;Drive number (0 = A:)
  DvcInfoNotWritten   EQU 0040h ;File has not been written (Dirty Buffer?)
  ;Bit 7 = Clear!
  DvcInfoInt24h       EQU 0100h ;Generate Int 24h on Errors (DOS 4 only)
  DvcInfoNotRemovable EQU 0800h ;Media Not Removable
  DvcInfoNoDateTime   EQU 4000h ;Don't set File Date/Time on Closing (DOS 3.0+)
  DvcInfoRemote       EQU 8000h ;File is Remote (DOS 3.0+)


;==============================================================================
;USB Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Maximum number of Devices we can control
  ;----------------------------------------------------------------------------
  MaxDevices EQU 16

  ;----------------------------------------------------------------------------
  ;Maximum number of Ports on each Device
  ;----------------------------------------------------------------------------
  MaxPorts EQU 7

  ;----------------------------------------------------------------------------
  ;Maximum number of entries in Bad (incompatible) Device Table
  ;----------------------------------------------------------------------------
  MaxBadDevices EQU 12

  ;----------------------------------------------------------------------------
  ;Number of entries in the Hub Call Table
  ;----------------------------------------------------------------------------
  HCEntries EQU 16

  ;----------------------------------------------------------------------------
  ;General
  ;----------------------------------------------------------------------------
  Int14RequestSize EQU 64 ;Size of Int 14h USB Request Data Structure

  ;----------------------------------------------------------------------------
  ;Maximum Descriptor Sizes
  ;----------------------------------------------------------------------------
  MaxDescriptorSize EQU 48 ;Max size of Config Descriptor

  ;----------------------------------------------------------------------------
  ;USB Descriptor Types
  ;----------------------------------------------------------------------------
  DescrTypeDevice    EQU 01h ;Device
  DescrTypeConfig    EQU 02h ;Configuration
  DescrTypeString    EQU 03h ;String
  DescrTypeInterface EQU 04h ;Interface
  DescrTypeEndPoint  EQU 05h ;EndPoint
  DescrTypeDvcQual   EQU 06h ;Device Qualifier
  DescrTypeOtherSpd  EQU 07h ;Other Speed Configuration
  DescrTypeIntfPower EQU 08h ;Interface Power
  DescrTypeOnTheGo   EQU 09h ;On-the-Go
  DescrTypeDebug     EQU 0Ah ;Debug
  DescrTypeIntfAssoc EQU 0Bh ;Interface Association
  ;Types 12 - 17 (0Ch - 11h) are added for Wireless USB
  DescrTypeWSecurity EQU 0Ch ;Wireless USB Security
  DescrTypeWKey      EQU 0Dh ;Wireless USB Key
  DescrTypeWEncrType EQU 0Eh ;Wireless USB Encryption Type
  DescrTypeWBOS      EQU 0Fh ;Wireless USB Binary-device Object Store
  DescrTypeWDvcCap   EQU 10h ;Wireless USB Device Capability
  DescrTypeWEndPtCmp EQU 11h ;Wireless USB Endpoint Companion

  ;Hub Class-Specific Descriptor Types
  DescrTypeHub       EQU 29h ;Hub

  ;----------------------------------------------------------------------------
  ;USB-Defined Device and Interface Classes, SubClasses, and Protocols
  ;----------------------------------------------------------------------------
  DvcClassHub            EQU 09h
  DvcSubClassNone        EQU 00h
  DvcProtocolNone        EQU 00h
    DvcProtocolSingleTT  EQU 01h ;Single Transaction Translator (USB 2.0)
    DvcProtocolMultiTT   EQU 02h ;Multiple Transaction Translators (USB 2.0)

  IntfClassHub           EQU 09h
  IntfSubClassNone       EQU 00h
  IntfProtocolNone       EQU 00h
    IntfProtocolSingleTT EQU 00h ;Single Transaction Translator (USB 2.0)
    IntfProtocolMultiTT  EQU 01h ;Multiple Transaction Translators (USB 2.0)

  ;----------------------------------------------------------------------------
  ;Possible Error Codes to return to calling program on completion of TD
  ;----------------------------------------------------------------------------
  TDStsOK             EQU 0000h ;ACK Received (TD completed OK / no errors)
  TDStsNAKReceived    EQU 0001h ;NAK Received
  TDStsStalled        EQU 0002h ;TD is Stalled
  TDStsTimeout        EQU 0004h ;TD has timed out (Bulk/Control)
  TDStsOverDue        EQU 0008h ;TD is OverDue (Int/Isoch)
  TDStsShortPacket    EQU 0010h ;TD Short Packet Detected
  TDStsBabbleDetected EQU 0020h ;Babble Detected
  TDStsCRCTOReceived  EQU 0040h ;CRC/TimeOut Error Received
  TDStsBitStuffError  EQU 0080h ;Rx Data contained > 6 ones in a row
  TDStsDataBuffErr    EQU 0100h ;Data Buffer Error
  TDStsControlSetup   EQU 1000h ;Error actually occurred during Control Setup
  TDStsDvcRemoved     EQU 2000h ;Device removed while TD was in progress
  TDStsLargeCallErr   EQU 8000h ;Error during Large Call

  ;----------------------------------------------------------------------------
  ;Statuses sent by Host to USB Device Owners
  ;----------------------------------------------------------------------------
  ;Device Connect/Disconnect
  OwnerCallNewDvc   EQU 0001h ;A new Matching Device has been attached
  OwnerCallDvcDisc  EQU 0002h ;Registered Device has been disconnected
  OwnerCallDvc0Disc EQU 0003h ;Matching Unregistered Device Disconnected
  OwnerCallDontLook EQU 0007h ;Stop Looking for New Devices for ~5 seconds
  ;Device Enable/Disable/Reset/Suspend/Resume/Power
  OwnerCallDvcEnable   EQU 0008h ;Device Enabled
  OwnerCallDvcDisable  EQU 0009h ;Device Disabled
  OwnerCallDvcReset    EQU 000Ah ;Device Resetting
  OwnerCallDvcSuspend  EQU 000Bh ;Device Suspended
  OwnerCallDvcResume   EQU 000Ch ;Device Resumed
  OwnerCallDvcPwrOn    EQU 000Dh ;Device Power On
  OwnerCallDvcPwrOff   EQU 000Eh ;Device Power Off
  OwnerCallDvcPwrReset EQU 000Fh ;Device Power Reset
  ;Host Connect/Disconnect/Error
  OwnerCallNewHost     EQU 0011h ;A new Host Driver has been Installed
  OwnerCallHostDisc    EQU 0012h ;An existing Host Driver has been Uninstalled
  OwnerCallHostHWErr   EQU 0017h ;Host System/Processor Error (Host will Reset)
  ;Host Run/Stop/Reset/Suspend/Resume
  OwnerCallHostRun     EQU 0018h ;Host Running
  OwnerCallHostStop    EQU 0019h ;Host Stopped
  OwnerCallHostReset   EQU 001Ah ;Host Reset
  OwnerCallHostSuspend EQU 001Bh ;Host Suspended
  OwnerCallHostResume  EQU 001Ch ;Host Resumed
  OwnerCallHostDebug   EQU 001Dh ;Host in Debug Mode
  OwnerCallHostSST     EQU 001Eh ;Host Single-Stepped
  ;Timing Changes
  OwnerCallTimingChg   EQU 0021h ;Timing Change on Host
  ;Upstream Device Changes
  OwnerCallDvcDiscUS     EQU (OwnerCallDvcDisc OR 0080h)     ;Dvc Disc Upstream
  OwnerCallDvcEnableUS   EQU (OwnerCallDvcEnable OR 0080h)   ;Dvc Enable Upstream
  OwnerCallDvcDisableUS  EQU (OwnerCallDvcDisable OR 0080h)  ;Dvc Disable Upstream
  OwnerCallDvcResetUS    EQU (OwnerCallDvcReset OR 0080h)    ;Dvc Reset Upstream
  OwnerCallDvcSuspendUS  EQU (OwnerCallDvcSuspend OR 0080h)  ;Dvc Suspend Upstream
  OwnerCallDvcResumeUS   EQU (OwnerCallDvcResume OR 0080h)   ;Dvc Resume Upstream
  OwnerCallDvcPwrOnUS    EQU (OwnerCallDvcPwrOn OR 0080h)    ;Dvc PwrOn Upstream
  OwnerCallDvcPwrOffUS   EQU (OwnerCallDvcPwrOff OR 0080h)   ;Dvc PwrOff Upstream
  OwnerCallDvcPwrResetUS EQU (OwnerCallDvcPwrReset OR 0080h) ;Dvc PwrReset Upstream

  ;----------------------------------------------------------------------------
  ;Stuff below this line is only sent to Hubs (not "regular" devices)
  ;  Sent w/ BX = User Pkt ID, CL = Hub Address, CH = Port Number (1-based)
  ;----------------------------------------------------------------------------
  HubCallEnumerated EQU 0077h ;Device Enumerated (DL = Host Idx, DH = New Addr)
  HubCallEnable     EQU 0078h ;Enable Device
  HubCallDisable    EQU 0079h ;Disable Device
  HubCallReset      EQU 007Ah ;Reset Device
  HubCallSuspend    EQU 007Bh ;Suspend Device (Selective Suspend)
  HubCallResume     EQU 007Ch ;Resume Device
  HubCallPwrOn      EQU 007Dh ;Power On Device
  HubCallPwrOff     EQU 007Eh ;Power Off Device
  HubCallPwrReset   EQU 007Fh ;Power Reset Device

  ;----------------------------------------------------------------------------
  ;Error Codes Returned by Int 14h Requests
  ;Error Codes are returned in AX
  ;If the Error Code is 0 (no Error), various other values will be returned
  ;  in BX, CX, and DX, depending on exactly what the call was
  ;----------------------------------------------------------------------------
  ;Problems with Our Program (like not enough space in a table)
  I14RErrResources      EQU 0001h ;Insufficient Resources/Memory
  I14RErrHostHardware   EQU 0002h ;Unknown/Hardware Problem with Host
  I14RErrReqTypeNoSupt  EQU 0003h ;Request Type recognized, but not Supported

  ;Errors we can recognize in USB Data Structure Data
  I14RErrRequestType    EQU 0011h ;Invalid Request Type
  I14RErrFlags          EQU 0012h ;Invalid Flags
  I14RErrHostIndex      EQU 0013h ;Invalid Host Index
  I14RErrDeviceAddress  EQU 0014h ;Invalid Device Address         |Same
  I14RErrHubAddress     EQU 0014h ;Invalid Hub Address            |Same
  I14RErrEndPoint       EQU 0015h ;Invalid EndPoint                |Same
  I14RErrHubPort        EQU 0015h ;Invalid Hub Port                |Same
  I14RErrAltIntf        EQU 0015h ;Invalid Alternate Interface     |Same
  I14RErrConfigValue    EQU 0016h ;Invalid Configuration Value    |Same
  I14RErrCloseID        EQU 0016h ;Invalid Closure ID             |Same
  I14RErrInterfaceNum   EQU 0017h ;Invalid Interface Number
  I14RErrSearchIndex    EQU 0018h ;Invalid Search Index
  I14RErrVendorProdID   EQU 0019h ;Invalid Vendor ID
  I14RErrDvcIntf        EQU 001Ah ;Invalid Device/Interface value
  I14RErrRequestHandle  EQU 001Bh ;Invalid Request Handle
  I14RErrPeriodicity    EQU 001Ch ;Invalid Periodicity             |Same
  I14RErrBeepFrequency  EQU 001Ch ;Invalid Beep Frequency          |Same
  I14RErrTimeOut        EQU 001Dh ;Invalid Timeout
  I14RErrDataAddress    EQU 001Eh ;Invalid Data Address
  I14RErrDataSize       EQU 001Fh ;Invalid Data Size (Low Speed <= 8)
  I14RErrCallBackAddr   EQU 0021h ;Invalid Call Back Address       |Same
  I14RErrLCRtnCode      EQU 0021h ;Invalid Large Call Return Code  |Same
  I14RErrUserPktID      EQU 0022h ;Invalid User Pkt ID (matches on unregistry)
  I14RErrSetupReqData   EQU 0023h ;Invalid Setup Request Data
  I14RErrFrameTiming    EQU 0024h ;Invalid Frame Timing            |Same
  I14RErrFrameIndex     EQU 0024h ;Invalid Frame Index             |Same
  I14RErrIsochArray     EQU 0025h ;Invalid Entry in Isoch Array Data

  ;Not User Input Errors (bad data), but failure codes
  I14RErrHostHalted     EQU 0031h ;Host is Halted/Suspended
  I14RErrIntfNotFound   EQU 0032h ;Interface not found (on FindIntf/RegIntf)
  I14RErrIntfInConfig   EQU 0033h ;Interface already being Configured on Device
  I14RErrIntfAlreadyReg EQU 0034h ;Interface already Registered
  I14RErrHostCallInUse  EQU 0035h ;Host Run/Stop/etc. already running
  I14RErrNoPortPower    EQU 0036h ;Per-Port-Power not Supported by Hub
  I14RErrAlreadyBeeping EQU 0037h ;Another Beep Request is already being handled

  ;Errors related to Debug Requests
  I14RErrDebugMode      EQU 0041h ;Tried to Single Step with No Debug Mode

  ;Errors related to Frame Timing Requests
  I14RErrTimingOwned    EQU 0051h ;Problem with Frame Timing Owner
                                  ;Can only have one Owner, and there must be
                                  ;  an owner before timing can be changed
  I14RErrTimingLimit    EQU 0052h ;Frame Timing is already at the Limit
  I14RErrTmgChgInProg   EQU 0053h ;Timing Change already in progress


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;STRUCTURES
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;==============================================================================
;TSR Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;This is a Structure to use at the beginning of Interrupt Routines in
  ;  TSR's.  Using this header, along with the appropriate code,
  ;  will allow the installation and removal of TSR's (actually,
  ;  the redirected interrupt vectors of a TSR) in any order.
  ;Note that the real Interrupt code MUST IMMEDIATELY follow this Header!!
  ;----------------------------------------------------------------------------
  IntHdr STRUC
    HdwreRst  DB      0CBh ;Hardware Reset Routine (CBh = RETF)
    CodeJmp   DW    010EBh ;Jump to real Interrupt Handler (JMP ENDS)
    OldVector DD        ?  ;Old interrupt Vector
    Signature DW    0424Bh ;Signature for this type of Interrupt routine
    EOIFlag   DB        0  ;=80h if we issue End-of-Interrupt, else 0
    HdwreJmp  DW    0F4EBh ;Jump to Hardware Reset Routine (JMP HdwreRst)
    FutureUse DB 7 DUP (0) ;Reserved for future use
   ENDS
  IntOfst EQU OFFSET CodeJmp ;Offset from beginning of our Structure


;==============================================================================
;DOS Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Program Segment Prefix
  ;----------------------------------------------------------------------------
  PSPStruc      STRUC
    PSPDOSExit     DW       20CDh ;Int 20h Call
    PSPNextSegment DW          ?  ;Segment of First Byte of Memory beyond Program
    PSPCPMCall5    DB   6 DUP (?) ;CPM Far Call 5
    PSPInt22Addr   DD          ?  ;Stored Int 22h Handler
    PSPInt23Addr   DD          ?  ;Stored Int 23h (Ctrl-Break) Handler
    PSPInt24Addr   DD          ?  ;Stored Int 23h (Critical Error) Handler
    PSPParentPSP   DW          ?  ;Segment of Parent PSP
    PSPJFT         DB  20 DUP (?) ;Job File Table (20 File Handles)
    PSPEnvirSeg    DW          ?  ;Environment Segment for PSP
    PSPSSSPOnEntry DD          ?  ;Processes SS:SP on Entry to last Int 21h Call
    PSPJFTSize     DW          ?  ;Number of entries in JFT (default = 20)
    PSPJFTPointer  DD          ?  ;Pointer to JFT (Default = PSP:0018h)
    PSPPreviousPSP DD          ?  ;Pointer to previous PSP (Default = FFFF:FFFF)
    PSPFiller1     DB  18 DUP (?) ;Misc stuff used by SHARE, Windows, etc.
                                  ;Memory Below here available to TSR!
    PSPFiller2     DB   2 DUP (?) ;Unused in DOS <= 6.00
    PSPInt21       DW       21CDh ;Int 21h Call
    PSPRETF        DB        0CBh ;RETF Call
    PSPFiller3     DB   9 DUP (?) ;Can be used to make Extended FCB from FCB1
    PSPFCB1        DB  16 DUP (?) ;First File Control Block
    PSPFCB2        DB  16 DUP (?) ;Second File Control Block
    PSPFiller4     DB   4 DUP (?) ;Unused
    PSPCmdLineLen  DB          ?  ;Command Line Length & DTA
    PSPCmdLine     DB 127 DUP (?) ;Command Line String
   ENDS
  PSPStrucSize EQU (TYPE PSPStruc) ;Should be 256 bytes

  ;----------------------------------------------------------------------------
  ;Memory Control Block
  ;----------------------------------------------------------------------------
  MCBStruc STRUC
    MCBID              DB        ?  ;Memory Control Block ID
      MCBIDValid      EQU       'M' ;Memory Block is Valid
      MCBIDLastInList EQU       'Z' ;Memory Block is Last in List
    MCBOwnerID         DW        ?  ;PSP Segment of Owner
                                    ;   0 = Owns Self
                                    ;   6 = DR-DOS XMS UMB
                                    ;   7 = DR-DOS Excluded Upper Memory
                                    ;   8 = Belongs to DOS
                                    ;FFFx = 386Max
    MCBSize            DW        ?  ;Size in Paragraphs
    MCBFiller          DB 3 DUP (?) ;Filler
    MCBOwnerName       DB 8 DUP (?) ;Owner Name
   ENDS
  MCBStrucSize EQU (TYPE MCBStruc) ;Should be 16 bytes

  ;----------------------------------------------------------------------------
  ;Structure needed to Initialize DOS EXEC Function
  ;----------------------------------------------------------------------------
  ParamBlockStruc STRUC
    PBEnvirSegment   DW ? ;Environment Segment to use (0 = Copy Callers Segment)
    PBCmdTailPtr     DD ? ;Pointer to Command Tail
    PBFCB1Offset     DD ? ;Pointer to File Control Block #1
    PBFCB2Offset     DD ? ;Pointer to File Control Block #2
    PBSSSPOnReturn   DD ? ;Holds Childs Initial SS:SP on Return (if AL = 01)
    PBCSIPOnReturn   DD ? ;Holds Entry Point (CS:IP) on Return (if AL = 01)
   ENDS
  ParamBlockSize EQU (TYPE ParamBlockStruc) ;Size of EXEC Parameter Block

  ;----------------------------------------------------------------------------
  ;DTA (Disk Transfer Area) after Find First Matching File (INT 21h, Func 4Eh)
  ;The first several bytes of the DTA are DOS version specific, and
  ;  we don't care about that data anyway.  We only care about the data
  ;  that is documented and the same across all versions of DOS.
  ;----------------------------------------------------------------------------
  FindFirstStruc   STRUC            ;Find First Matching File
    FFVerSpecific     DB 21 DUP (0) ;DOS Version-specific Data
    FFAttribs         DB         ?  ;File Attributes
      FAttrReadOnly  EQU        01h ;Read-Only
      FAttrHidden    EQU        02h ;Hidden
      FAttrSystem    EQU        04h ;System
      FAttrVolume    EQU        08h ;Volume Label
      ;Bit 3 = Execute-only (Novell Netware)
      FAttrDirectory EQU        10h ;Directory
      FAttrArchive   EQU        20h ;Archive
      FAttrUnused    EQU        40h ;Unused
                                    ;DOS 3+ returns this bit set if file
                                    ;  is actually a character device
                                    ;DOS Window underneath Windows XP doesn't
      ;Bit 7 = Delete Pending (OpenDOS, NovellDOS)
      ;      = Shareable (Novell Netware)
   FFTime            DW         ?  ;File Creation Time
    FFDate            DW         ?  ;File Creation Date
    FFSize            DD         ?  ;File Size
    FFName            DB 13 DUP (?) ;ASCIIZ File Name & Extension
   ENDS

   FAttrToUse EQU FAttrHidden+FAttrSystem
     ;Attributes to use in DOS's Find First Matching File Function
     ;DOS ignores the Read-Only and and Archive bits, so they don't matter


;==============================================================================
;USB/Hub-Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Structure to store data for each USB Hub
  ;----------------------------------------------------------------------------
  DeviceInfoStruc      STRUC       ;Structure to keep track of
    DIFlags               DB    ?  ;Misc Yes/No Flags
      DIFlagInUse        EQU   01h ;This entry currently being used?
      DIFlagHubPPP       EQU   02h ;Hub supports Per-Port-Power switching
    DIInterfaceNum        DB    ?  ;Interface number of Hub (should be 0!)
    DIIntHandle           DW    ?  ;Handle number of Main Periodic Interrupt
    DIRegHandle           DW    ?  ;Handle number of Owner Registry
    DIHostIndex           DB    ?  ;Host Index this Hub is on
    DIDvcAddress          DB    ?  ;Device Address of Hub
    DIHubCurrent          DB    ?  ;Amount of Current this Hub Draws
    DINumPorts            DB    ?  ;Number of Ports this Hub Has
    DIPort1Address        DB    ?  ;Address of Device on Port 1
                                   ;0 = No Device
    DIPort2Address        DB    ?  ;Address of Device on Port 2
    DIPort3Address        DB    ?  ;Address of Device on Port 3
    DIPort4Address        DB    ?  ;Address of Device on Port 4
    DIPort5Address        DB    ?  ;Address of Device on Port 5
    DIPort6Address        DB    ?  ;Address of Device on Port 6
    DIPort7Address        DB    ?  ;Address of Device on Port 7
    DIPort1Power          DB    ?  ;Power of Device on Port 1 (ma/2)
    DIPort2Power          DB    ?  ;Power of Device on Port 2 (ma/2)
    DIPort3Power          DB    ?  ;Power of Device on Port 3 (ma/2)
    DIPort4Power          DB    ?  ;Power of Device on Port 4 (ma/2)
    DIPort5Power          DB    ?  ;Power of Device on Port 5 (ma/2)
    DIPort6Power          DB    ?  ;Power of Device on Port 6 (ma/2)
    DIPort7Power          DB    ?  ;Power of Device on Port 7 (ma/2)
    DIFiller              DB    ?  ;To align at even addresses
    DIStatusChange        DB    ?  ;Change in Hub Status
     ;Bit 0 = Hub Change, Bits 1-7 = Port Change (Bit 1 = Port 1, etc.)
  ;4 bytes returned by GetPortStatus
    DIPortStatus          DW    ?  ;Current Port Status
      DIPStConnected     EQU 0001h ;Device is connected
      DIPStEnabled       EQU 0002h ;Port is Enabled
      DIPStSuspended     EQU 0004h ;Port is Suspended
      DIPStOverCurrent   EQU 0008h ;Device is drawing too much Current
                                   ;  Only if Hub reports on a per-Port basis!
      DIPStReset         EQU 0010h ;Device is being Reset
      ;Bits 5 - 7 Reserved (0)
      DIPStPowered       EQU 0100h ;Port has Power turned on
      DIPStLowSpeed      EQU 0200h ;Low Speed Device is attached
      DIPStHiSpeed       EQU 0400h ;High Speed Device is attached (USB 2.0)
      DIPStTestMode      EQU 0800h ;Port is in Test Mode (USB 2.0)
      DIPStIndicatSWCtl  EQU 1000h ;Indicator Colors Controlled by SW (USB 2.0)
      ;Bits 13-15 Reserved (0)
    DIPortChangeStatus    DW  ?    ;Unconfirmed Port Change-in-Status
      DIPChConnect       EQU 0001h ;Change in Connect Status
      DIPChEnable        EQU 0002h ;Change in Enabled Status
      DIPChSuspend       EQU 0004h ;Change in Suspend Status
      DIPChOverCurrent   EQU 0008h ;Change in Over Current Status
      DIPChReset         EQU 0010h ;Change in Reset Status (Reset Done?)
      ;Bits 5 - 15 Reserved (0)
  ;4 bytes returned by GetHubStatus
      DIHStNoLocalPower EQU 0001h ;Local Power is Lost (running from Bus)
      DIHStOverCurrent  EQU 0002h ;Device(s) are drawing too much current
                                  ;This is 0 if Hub reports per-Port
                                  ;Hub automatically powers off ports when
                                  ;  this is set.
      ;Bits 2-15 Reserved (0)
      DIHChLocalPower   EQU 0001h ;Change in Local Power
      DIHChOverCurrent  EQU 0002h ;Change in Over Current
      ;Bits 2-15 Reserved (0)
   ENDS
  DeviceInfoStrucSize EQU TYPE (DeviceInfoStruc)

  ;----------------------------------------------------------------------------
  ;This structure keeps track of Bad (incompatible) Devices
  ;----------------------------------------------------------------------------
  BadDeviceStruc    STRUC
    BDFlags            DB  ?  ;Misc Yes/No Flags
      BDFlagInUse     EQU 01h ;This entry currently being used?
    BDInterfaceNum     DB  ?  ;Interface Number of Bad Device
    BDHostIndex        DB  ?  ;Host Index of Bad Device
    BDDvcAddress       DB  ?  ;Device Address of Bad Device
    BDFiller           DB  ?  ;To align data at even addresses
    BDNewDeviceStage   DB  ?  ;Bad Device Stage
    BDNewDeviceError   DW  ?  ;Bad Device Error Code
   ENDS
  BadDeviceStrucSize EQU (TYPE BadDeviceStruc)

  ;----------------------------------------------------------------------------
  ;This structure keeps track of Hub-related Calls from the Host
  ;----------------------------------------------------------------------------
  HubCallStruc     STRUC     ;Structure to keep track of Hub Calls
    HCDIOffset        DW  ?  ;Offset of Device Entry this is for
                             ;  0 here is an Empty Entry
    HCHostIndex       DW  ?  ;Host Index Number to return at end of Call
    HCPortNum         DB  ?  ;Port Number we're messing with
    HCType            DB  ?  ;Type of Call
      HCTypeEnable   EQU 00h ;Enable
      HCTypeDisable  EQU 01h ;Disable
      HCTypeReset    EQU 02h ;Reset
      HCTypeSuspend  EQU 03h ;Suspend
      HCTypeResume   EQU 04h ;Resume
      HCTypePwrOn    EQU 05h ;Power On
      HCTypePwrOff   EQU 06h ;Power Off
      HCTypePwrReset EQU 07h ;Power Reset
    HCPortData        DD  ?  ;Data returned from Port Status Calls
    HCInt14Request    DB Int14RequestSize DUP (0) ;Int 14h Request
                             ;This MUST be the last item in the Structure!
                             ;When we reset the structure, set everything to 0
                             ;  except the last {Int14RequestSize} Bytes
   ENDS
  HubCallStrucSize EQU TYPE (HubCallStruc)

  ;----------------------------------------------------------------------------
  ;This is the format for a request sent to Int 14h to Send/Receive Data
  ;It contains the type of request, etc.
  ;----------------------------------------------------------------------------
  Int14RequestStruc         STRUC      ;Structure for an Int 14 Request
    I14RRequestType            DB   ?  ;Type of Request
      I14RRTHostClass         EQU  00h ;Host/System/OS Class
        I14RRTGetHostSWInfo   EQU  01h ;Get Host Software Info
        I14RRTGetHostHWInfo   EQU  02h ;Get Host Hardware Info
        I14RRTGetHostVendInfo EQU  03h ;Get Host Vendor Info
        I14RRTGetHostStatus   EQU  04h ;Get Current Host Status
        I14RRTHostRun         EQU  08h ;Start/Run/Resume Host
        I14RRTHostStop        EQU  09h ;Stop Host
        I14RRTHostReset       EQU  0Ah ;Reset Host
        I14RRTHostSuspend     EQU  0Bh ;Global Suspend Host
        I14RRTHostResume      EQU  0Ch ;Force Global Resume on Host
      I14RRTTimingClass       EQU  10h ;Frame Timing Class
        I14RRTRegTmgOwner     EQU  11h ;Register as Timing Owner
        I14RRTUnRegTmgOwner   EQU  12h ;UnRegister as Timing Owner
        I14RRTIncTiming       EQU  13h ;Increment (Slow Down) Frame Timing
        I14RRTDecTiming       EQU  14h ;Decrement (Speed Up) Frame Timing
        I14RRTChangeTiming    EQU  15h ;Change Frame Timing (by Large Amount)
      I14RRTHubClass          EQU  20h ;Hub Class
        I14RRTGetDvcHubInfo   EQU  21h ;Get Hub Info for Device
        I14RRTNewDvcConn      EQU  24h ;Hub has Detected new Device
        I14RRTDvcDisc         EQU  25h ;Device has been Disconnected
        I14RRTSendHubChar     EQU  27h ;Send Hub Characteristics to Host
        I14RRTEnableHubPort   EQU  28h ;Enable Device given Hub & Port
        I14RRTDisableHubPort  EQU  29h ;Disable Device given Hub & Port
        I14RRTResetHubPort    EQU  2Ah ;Reset Device given Hub & Port
        I14RRTSuspendHubPort  EQU  2Bh ;Suspend Device given Hub & Port
        I14RRTResumeHubPort   EQU  2Ch ;Resume Device given Hub & Port
        I14RRTPwrOnHubPort    EQU  2Dh ;Power On Device given Hub & Port
        I14RRTPwrOffHubPort   EQU  2Eh ;Power Off Device given Hub & Port
        I14RRTPwrResetHubPort EQU  2Fh ;Power Reset Device given Hub & Port
      I14RRTTPowerClass       EQU  30h ;Power Class
        I14RRTGetDvcPowerInfo EQU  31h ;Get Power Info for Device
        I14RRTGetHubPowerDraw EQU  32h ;Get Power Draw for Hub
        I14RRTPwrOnDevice     EQU  3Dh ;Power On Device given Dvc Addr
        I14RRTPwrOffDevice    EQU  3Eh ;Power Off Device given Dvc Addr
        I14RRTPwrResetDevice  EQU  3Fh ;Power Reset Device given Dvc Addr
      I14RRTDeviceClass       EQU  40h ;Device Class
        I14RRTGetDvcClassInfo EQU  41h ;Get Device Class Info
        I14RRTGetDvcVendInfo  EQU  42h ;Get Device Vendor Info
        I14RRTGetDvcStatus    EQU  43h ;Get Device Status
        I14RRTEnableDevice    EQU  48h ;Enable/Resume Device given Dvc Addr
        I14RRTDisableDevice   EQU  49h ;Disable Device given Dvc Addr
        I14RRTResetDevice     EQU  4Ah ;Reset Device given Dvc Addr
        I14RRTSuspendDevice   EQU  4Bh ;Suspend Device given Dvc Addr
        I14RRTResumeDevice    EQU  4Ch ;Resume Device given Dvc Addr
      I14RRTConfigClass       EQU  50h ;Configuration Class
        I14RRTConfigingIntf   EQU  51h ;Driver is Configuring an Interface
        I14RRTConfigIntfDone  EQU  52h ;Interface Configuration is Complete
        I14RRTSetNewConfig    EQU  58h ;Set/Change Device Config Value
      I14RRTInterfaceClass    EQU  60h ;Interface Class
        I14RRTFindRegIntf     EQU  62h ;Look for Registered Interface
        I14RRTFindUnRegIntf   EQU  63h ;Look for Unregistered Interface
        I14RRTRegIntfOwner    EQU  64h ;Register as Interface Owner
        I14RRTUnRegIntfOwner  EQU  65h ;Unregister as Interface Owner
        I14RRTIntfDontLook    EQU  68h ;Existing Interface Owner Don't Look
      I14RRTAltIntfClass      EQU  70h ;Alternate Interface Class
        I14RRTGetAltIntfInfo  EQU  71h ;Get Alternate Interface Info
      I14RRTEndPointClass     EQU  80h ;End Point Class
        I14RRTGetDataX        EQU  81h ;Get Current DataX Value
        I14RRTIncDataX        EQU  88h ;Increment/Toggle DataX Value
      I14RRTPacketClass       EQU  90h ;Packet Class
        I14RRTDoIsoch         EQU  94h ;Schedule Isochronous Transaction
        I14RRTDoInterruptPer  EQU  95h ;Schedule Periodic Interrupt
        I14RRTDoControl       EQU  96h ;Schedule Control/Setup Request
        I14RRTDoBulk          EQU  97h ;Schedule Bulk Transaction
        I14RRTDoInterrupt1T   EQU  98h ;Schedule One-Time Interrupt
        I14RRTCloseHandle     EQU  9Ch ;Close/Remove Scheduled Transaction
        I14RRTChangeIntPer    EQU  9Dh ;Change Periodicity of Interrupt
        I14RRTGetTransStatus  EQU  9Fh ;Get Status of Packet Transaction
      I14RRTMiscClass         EQU 0A0h ;Miscellaneous Class
        I14RRTLargeCallDone   EQU 0A1h ;Large (Complicated) Call Complete
        I14RRTBeepSpeaker     EQU 0AFh ;Beep the Speaker
      I14RRTInterHostClass    EQU 0E0h ;Inter-Host Communication Class
      I14RRTInternalClass     EQU 0F0h ;Host Internal/Troubleshooting Class
    I14RFlags                  DB   ?  ;Bit-level flags
      I14RFlagIn              EQU  01h ;In Direction
      I14RFlagLowSpeed        EQU  02h ;Low-Speed Device
      I14RFlagHiSpeed         EQU  04h ;High-Speed Device
      I14RFlagNoRetries       EQU  10h ;No Auto Retries for Control
      I14RFlagShortPktOK      EQU  20h ;No Retries for Short Packets
      I14RFlagSpecificFrame   EQU  40h ;Use Specific Frame Number
      I14RFlagAddrIsPhys      EQU  80h ;Data Address is Physical
    I14RHostIndex              DB   ?  ;Host Index
    I14RDeviceAddress          DB   ?  ;USB Device Address
      I14RHubAddress          EQU (OFFSET I14RDeviceAddress)
    I14REndPoint               DB   ?  ;EndPoint or Port or Alt Interface
      I14RHubPort             EQU (OFFSET I14REndPoint)
      I14RAltInterface        EQU (OFFSET I14REndPoint)
    I14RConfigValue            DB   ?  ;Configuration Value
      I14RCloseID             EQU (OFFSET I14RConfigValue)
      I14RDataX               EQU (OFFSET I14RConfigValue)
    I14RInterfaceNum           DB   ?  ;Interface Number
    I14RSearchIndex            DB   ?  ;Search Index
    I14RVendorID               DW   ?  ;Vendor ID
    I14RProductID              DW   ?  ;Product ID
    I14RDvcClass               DB   ?  ;Device Class
    I14RDvcSubClass            DB   ?  ;Device SubClass
    I14RDvcProtocol            DB   ?  ;Device Protocol
    I14RIntfClass              DB   ?  ;Interface Class
    I14RIntfSubClass           DB   ?  ;Interface SubClass
    I14RIntfProtocol           DB   ?  ;Interface Protocol
    I14RRequestHandle          DW   ?  ;Request Handle Number
    I14RPeriodicity            DW   ?  ;Interrupt Periodicity/Duration
      I14RBeepFrequency       EQU (OFFSET I14RPeriodicity)
    I14RTimeout                DW   ?  ;Transaction Time Out Value
    I14RDataAddress            DD   ?  ;Data Address
    I14RDataSize               DW   ?  ;Size of Data (Bytes)
    I14RCallBackAddr           DD   ?  ;Call Back Address (CS:IP format)
      I14RLargeCallRtnCode    EQU (OFFSET I14RCallBackAddr)
    I14RUserPktID              DW   ?  ;User Packet ID
    I14RSetupReqData           DQ   ?  ;Setup Request Data (8 bytes)
    I14RFrameTiming            DW   ?  ;Frame Timing Value (def = 12000)
      I14RFrameIndex          EQU (OFFSET I14RFrameTiming)
                                       ;Starting Frame of Isoch Schedule
    I14RIsochSchedAddr         DD   ?  ;Address of Isoch Schedule
    I14RFiller  DB (Int14RequestSize-$) DUP (0)

   ENDS

  ;----------------------------------------------------------------------------
  ;Device Request is a structure containing data required by a USB Setup Packet
  ;----------------------------------------------------------------------------
  SetupRequest           STRUC     ;Structure for a Standard Setup Pkt
    SRRequestType           DB  ?  ;Request Type
      SRRTOut              EQU 00h ;0=Out (Host to Device)
      SRRTIn               EQU 80h ;1=In (Device to Host)
      SRRTTypeMask         EQU 60h ;Mask for Type
        SRRTTypeStandard   EQU 00h ;Type 0 = Standard
        SRRTTypeClass      EQU 20h ;Type 1 = Class
        SRRTTypeVendor     EQU 40h ;Type 2 = Vendor
                                   ;Type 3 = Reserved
      SRRTRecipientMask    EQU 1Fh ;Mask for Recipient Type
        SRRTRecipDevice    EQU 00h ;Recipient Type 0 = Device
        SRRTRecipInterface EQU 01h ;Recipient Type 1 = Interface
        SRRTRecipEndPoint  EQU 02h ;Recipient Type 2 = EndPoint
        SRRTRecipOther     EQU 03h ;Recipient Type 3 = Other
                                   ;Types 4-31 = Reserved
    SRRequest               DB  ?  ;Specific Request
      SRRQGetStatus        EQU  0  ;Request  0 = Get Status
      SRRQClearFeature     EQU  1  ;Request  1 = Clear Feature
      SRRQGetState         EQU  2  ;Request  2 = Get State
      SRRQSetFeature       EQU  3  ;Request  3 = Set Feature
                                   ;Request  4 = Reserved
      SRRQSetAddress       EQU  5  ;Request  5 = Set Address
      SRRQGetDescriptor    EQU  6  ;Request  6 = Get Descriptor
      SRRQSetDescriptor    EQU  7  ;Request  7 = Set Descriptor
      SRRQGetConfig        EQU  8  ;Request  8 = Get Configuration
      SRRQSetConfig        EQU  9  ;Request  9 = Set Configuration
      SRRQGetAltInterface  EQU 10  ;Request 10 = Get Alternate Interface
      SRRQSetAltInterface  EQU 11  ;Request 11 = Set Alternate Interface
      SRRQSynchFrame       EQU 12  ;Request 12 = Synch Frame
    ;These are Hub-Specific Requests (Overlap with some of the others!)
      SRRQHubClearTTBuffer EQU  8  ;Clear Transaction Translator Buffer (USB 2.0)
                                   ;  SRValue = DeviceAddr, EndPoint
                                   ;    Bits  3: 0 = EndPoint Number
                                   ;          4:10 = Device Address
                                   ;         11:12 = EndPoint Type
                                   ;         13:14 = 0
                                   ;            15 = Direction (1 = In)
                                   ;  SRIndex = TTPort
                                   ;    (1 if Single TT,
                                   ;    TT Port # if multiple TT's)
      SRRQHubResetTT       EQU  9  ;Reset Transaction Translator
                                   ;  SRValue = 0
                                   ;  SRIndex = TTPort
                                   ;    (1 if Single TT,
                                   ;    TT Port # if multiple TT's)
      SRRQHubGetTTState    EQU 10  ;Get Transaction Translator State
                                   ;  SRValue = TTFlags = 0
                                   ;  SRIndex = TTPort
                                   ;    (1 if Single TT,
                                   ;    TT Port # if multiple TT's)
                                   ;  First two bytes of returned data
                                   ;    are USB Flags, all set to 0
                                   ;  Next two bytes are vendor-specific flags
                                   ;  Size of remaining data is vendor-specific
                                   ;  Return data (other than first two bytes)
                                   ;    is vendor-specific
                                   ;  TT State after this request is undefined
      SRRQHubStopTT        EQU 11  ;Stop Transaction Translator
                                   ;  SRValue = 0
                                   ;  SRIndex = TTPort
                                   ;    (1 if Single TT,
                                   ;    TT Port # if multiple TT's)
    SRValue                 DW  ?  ;Value depends on Request Type
    SRIndex                 DW  ?  ;Index depends on Request Type
      ;If EndPoint,  Bits 3:0 = EndPoint Number
      ;              Bit    7 = 1 if IN EndPoint, 0 if OUT EndPoint
      ;              All other bits are 0
      ;If Interface, Bits 7:0 = Interface Number (low word)
      ;              All other bits are 0 (high word)
    SRLength                DW  ?  ;Length of Data (if there is Data)

   ENDS
  SetupRequestSize EQU TYPE (SetupRequest)

  ;----------------------------------------------------------------------------
  ;Format of data returned by a Get Device Descriptor
  ;----------------------------------------------------------------------------
  DeviceDescriptor   STRUC    ;Structure for a Device Descriptor
    DDLength            DB  ? ;Size of Descriptor in bytes
    DDDescType          DB DescrTypeDevice
    DDUSBRelease        DW  ? ;USB Compliance  bcd (0210h=v2.10)
    DDDvcClass          DB  ? ;Device Class (defined by USB-IF)
    DDDvcSubClass       DB  ? ;Device SubClass (defined by USB-IF)
    DDDvcProtocol       DB  ? ;Device Protocol (defined by USB-IF)
    DDMaxPktSize        DB  ? ;Max Packet Size for EndPoint 0
                              ;  MUST be 8, 16, 32, or 64
    DDVendorID          DW  ? ;Vendor ID (defined by USB-IF)
    DDProductID         DW  ? ;Product ID (defined by manufacturer)
    DDDeviceRelease     DW  ? ;Device Release Number (bcd)
    DDManufacturerIndx  DB  ? ;Index of Manufacturer String
    DDProductIndx       DB  ? ;Index of Product String
    DDSerialNumberIndx  DB  ? ;Index of Serial Number String
    DDNumConfigs        DB  ? ;Number of possible Configurations
   ENDS
  DeviceDescriptorSize EQU TYPE (DeviceDescriptor)

  ;----------------------------------------------------------------------------
  ;Format of data returned by a Get Configuration Descriptor
  ;----------------------------------------------------------------------------
  ConfigDescriptor     STRUC     ;Structure for a Config Descriptor
    CDLength              DB  ?  ;Size of Descriptor in bytes
    CDDescrType           DB DescrTypeConfig
    CDTotalLength         DW  ?  ;Total length of data returned for
                                 ;  this configuration (ALL data)
    CDNumInterfaces       DB  ?  ;Number of Interfaces in this Config
    CDConfigValue         DB  ?  ;Value to use in SetRequest to
                                 ;  set this configuration
    CDConfigurationIndx   DB  ?  ;Index of Configuration String
    CDAttributes          DB  ?  ;Configuration Attributes
      CDAttrBit7         EQU 80h ;Bit 7 must be set to 1
      CDAttrSelfPowered  EQU 40h ;Self Powered
      CDAttrRemoteWakeup EQU 20h ;Remote Wakeup Supported
      CDAttrBatteryPower EQU 10h ;Battery Powered
      ;Bits 3:0 = Reserved (0)
    CDMaxBusPower         DB  ?  ;Maximum Power Consumption FROM BUS
                                 ;  in 2mA units (*2 to get mA)
   ENDS
  ConfigDescriptorSize EQU TYPE (ConfigDescriptor)

  ;----------------------------------------------------------------------------
  ;Format of data returned by a Get Interface Descriptor
  ;Note that a GetInterface Request is undefined for a version 1.x Hub,
  ;   becuase it has only one Interface
  ;----------------------------------------------------------------------------
  InterfaceDescriptor   STRUC     ;Structure for an Interface Descr
    IDLength               DB  ?  ;Size of Descriptor in bytes
    IDDescType             DB DescrTypeInterface
    IDInterfaceNumber      DB  ?  ;Interface Number (0-based Index)
    IDAlternateSetting     DB  ?  ;Value used to select this alternate
                                  ;  setting for the Interface Number
    IDNumEndPoints         DB  ?  ;Number of Interfaces, excl 0
    IDInterfaceClass       DB  ?  ;Interface Class (defined by USB-IF)
    IDInterfaceSubClass    DB  ?  ;Interface SubClass (def by USB-IF)
    IDInterfaceProtocol    DB  ?  ;Interface Protocol (def by USB-IF)
    IDInterfaceIndx        DB  ?  ;Index of Interface String
   ENDS
  InterfaceDescriptorSize EQU TYPE (InterfaceDescriptor)

  ;----------------------------------------------------------------------------
  ;Device Qualifier is a structure containing the data returned by a
  ;  GetDescriptor Request for a Device Qualifier (USB 2.0)
  ;If device is operating Full-Speed (12Mbps), this returns info about
  ;  what the device does at High-Speed (480Mbps), and vice-versa
  ;----------------------------------------------------------------------------
  DeviceQualifierDescriptor STRUC ;Structure for a Device Qualifier Descriptor
    DQLength      DB ? ;Size of Descriptor in bytes
    DQDescrType   DB DescrTypeDvcQual
    DQUSBRelease  DW ? ;USB Compliance  bcd (0210h=v2.10)
    DQDvcClass    DB ? ;Device Class (defined by USB-IF)
    DQDvcSubClass DB ? ;Device SubClass (defined by USB-IF)
    DQDvcProtocol DB ? ;Device Protocol (defined by USB-IF)
    DQMaxPktSize  DB ? ;Max Packet Size for other speed
    DQNumConfigs  DB ? ;Number of other-speed Configurations
    DQReserved    DB 0 ;Reserved
   ENDS
  DeviceQualifierDescriptorSize EQU TYPE (DeviceQualifierDescriptor)

  ;----------------------------------------------------------------------------
  ;Format of data returned by a Get EndPoint Descriptor
  ;----------------------------------------------------------------------------
  EndPointDescriptor    STRUC     ;Structure for an EndPoint Descr
    EDLength               DB  ?  ;Size of Descriptor in bytes
    EDDescrType            DB DescrTypeEndPoint
    EDEndPointNumber       DB  ?  ;EndPoint Number
      EDDirectionIn       EQU 80h ;Direction = In (Ignored in Control EP's)
      ;Bits 6:4 = Reserved (0)
      EDNumberMask        EQU 0Fh ;EndPoint Number (0-15)
    EDAttributes           DB  ?  ;EndPoint attributes
      ;Bits 7:6 = Reserved (0)
      EDUsageTypeMask     EQU 30h ;Bits 5:4 = Usage Type
      EDUsageTypeSft      EQU  4  ;Bits to Shift by
        EDAttrImplicitFB  EQU 20h ;2 = Implicit Feedback Data EndPoint
        EDAttrFeedback    EQU 10h ;1 = Feedback EndPoint
        EDAttrData        EQU 00h ;0 = Data EndPoint
      EDSynchTypeMask     EQU 0Ch ;Bits 3:2 = Synchronization Type
      EDSynchTypeSft      EQU  2  ;Bits to Shift By
        EDAttrSynch       EQU 0Ch ;3 = Synchronous
        EDAttrAdaptive    EQU 08h ;2 = Adaptive
        EDAttrAsynch      EQU 04h ;1 = Asynchronous
      EDAttrTransTypeMask EQU 03h ;Bits 1:0 = Transfer Type
        EDAttrInterrupt   EQU 03h ;3 = Interrupt
        EDAttrBulk        EQU 02h ;2 = Bulk
        EDAttrIsoch       EQU 01h ;1 = Isochronous
        EDAttrControl     EQU 00h ;0 = Control
    EDMaxPktSize           DW  ?  ;Max Packet Size EndPoint can handle
    EDPollInterval         DB  ?  ;Polling Interval for Data Transfers
    ;The following two bytes only appear in some Isochronous Applications
    EDRefreshRate          DB  ?  ;Refresh Rate (1-9, power of 2 mS)
    EDSynchEndPoint        DB  ?  ;Synchronization EndPoint
   ENDS
  EndPointDescriptorSize EQU TYPE (EndPointDescriptor)

  ;----------------------------------------------------------------------------
  ;Hub Descriptor is a structure containing the data returned by a
  ;  GetDescriptor Request for a Hub
  ;----------------------------------------------------------------------------
  HubDescriptor           STRUC             ;Structure for a Hub Descriptor
    HDLength                 DB          ?  ;Size of Descriptor in bytes
    HDDescType               DB DescrTypeHub
    HDNumPorts               DB          ?  ;Number of downstream ports
    HDHubChar                DW          ?  ;Hub characteristics
      HDCharPwrSwitchMask   EQU       0003h ;Power switching Mode
        HDCharGlbPwrSwitch  EQU       0000h ;Global (Ganged) Power Switching
        HDCharIndPwrSwitch  EQU       0001h ;Individual Port Power Switching
        ;Bit 1 is actually reserved
      HDCharCompoundDvc     EQU       0004h ;1=Hub is part of Compound Device
      HDCharOverCurrMask    EQU       0018h ;Over-Current Protection Mode
        HDCharGlbOverCurr   EQU       0000h ;Over-Current Protection Globally
        HDCharIndOverCurr   EQU       0008h ;Over-Current Protection per-port
        HDCharNoOverCurr1   EQU       0010h ;No Over-Current Protection
        HDCharNoOverCurr2   EQU       0018h ; "  "     "        "
      HDCharTTThinkTimeMask EQU       0060h ;Transaction Translator Think Time (USB 2.0)
        HDCharThink08       EQU       0000h ;At most 8 FS Bit Times
        HDCharThink16       EQU       0020h ;At most 16 FS Bit Times
        HDCharThink24       EQU       0040h ;At most 24 FS Bit Times
        HDCharThink32       EQU       0060h ;At most 32 FS Bit Times
      HDCharSWIndicator     EQU       0080h ;Indicators can be SW Controlled (USB 2.0)
      ;Bits 08:15 = Reserved
    HDPowerOn2PowerGood      DB          ?  ;Time from beginning of power-on
                                            ;  Sequence for a port until
                                            ;  power is good  (2mS intervals)
    HDHubCurrent             DB          ?  ;Power draw of Hub in mA
    HDDvcRemovable           DB (256/8) DUP (?)
      ;Bit-mapped per device
      ;Bit 0 = Reserved, Bits 1->n are 1 if device is NOT removable
      ;Can be up to 255 devices
      ;Unmapped devices are 0 (to fill out space to be byte-aligned)
    HDPortPwrCtrlMask        DB (256/8) DUP (?)
      ;Bit-mapped per device
      ;All bits should be 1 (Legacy from USB version 1.0)
      ;Can be up to 255 devices
   ENDS
  HubDescriptorSize EQU 9 ;Only allow for a maximum of 7 Ports!!


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;MACROS
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

  JUMP MACRO
    JMP SHORT #1
   #EM


;哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌
;TSR DATA
;苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘

;==============================================================================
;TSR Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;INT2F Data (this needs to be the first data at the top of the file)
  ;If the user does a "TYPE USBHUB.COM" at the command line, this will
  ;  just show the program name and version, instead of sending all kinds of
  ;  annoying happy faces and BELs to the screen the way most programs do.
  ;This is also the same data that is used to test if the program is
  ;  already installed in memory.
  ;----------------------------------------------------------------------------
  NoType1:     DB               CR  ;To handle TYPE from command line
  ProgName:    DB        'USBHUB  ' ;Program Name
  ProgNameLen EQU       $-ProgName  ;Length of name
  ProgVerTxt:  DB           ' 0.08' ;Program version in ASCII
  Author:      DB '  Bret Johnson' ;Authors name
  AuthorLen   EQU         $-Author  ;Length of Author
  NoType2:     DB              EOF  ;To handle TYPE from command line
  ProgVer      DW             0008h ;Program version as a word
  HandleNum    DB              0C0h ;TSR multiplex handle number

  ;----------------------------------------------------------------------------
  ;Miscellaneous Yes/No TSR Flags
  ;----------------------------------------------------------------------------
  TSRFlags         DB 00h ;Miscellaneous Yes/No Flags
    Int14ReqInUse EQU 01h ;Int14 Request currently in use?
    Configing     EQU 02h ;In process of configing a device
    NoBeep        EQU 04h ;Don't beep the Speaker


;==============================================================================
;Stack Related
;==============================================================================
  StackInUse DB 0 ;Counter to keep track of "setup stack" calls
  OldSS      DW ? ;Original Stack Segment
  OldSP      DW ? ;Original Stack Pointer
  TempBX     DW ? ;Temporary Storage for BX while setting up Stack
  TempFlags  DW ? ;Temporary Storage for Flags while setting up Stack


;==============================================================================
;Hub Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Counter to keep track of Number of Hub Calls in Currently Progress
  ;----------------------------------------------------------------------------
  HubCallsInProg DB ?

  ;----------------------------------------------------------------------------
  ;Stage where New Device (external) search failed (for troubleshooting)
  ;----------------------------------------------------------------------------
  NewExtDeviceStage DB ? ;Stage Number
  NewExtDeviceError DW ? ;Error Code

  ;----------------------------------------------------------------------------
  ;Hub Call Table
  ;----------------------------------------------------------------------------
  EVEN 2
  HubCallTable:
    DB (HCEntries * HubCallStrucSize) DUP (0)


;==============================================================================
;USB Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Handle Number of New Device (Device 0) Registry
  ;----------------------------------------------------------------------------
  Reg0Handle DW ?

  ;----------------------------------------------------------------------------
  ;Int08 Countdown Timers
  ;----------------------------------------------------------------------------
  Int08Counter    DB 5 ;Countdown Timer to periodically check for new Devices
                       ;Initial Delay is 5 timer ticks (about 1/4 second)
                       ;Delays after initial one will also be about 1/4 second
                       ;Setting to 0 Disables the program
  DontLookCounter DW 0 ;Countdown Timer to not Look for New Hubs

  ;----------------------------------------------------------------------------
  ;Calls that the USB Host Driver can send to us after we're "registered"
  ;Our code is called with this function code in AX
  ;----------------------------------------------------------------------------
  OwnerCallFunctionTbl:
   ;Device Connect/Disconnect
    DB OwnerCallNewDvc        ;New Device Connected
     DW DeviceAdded
    DB OwnerCallDvcDisc       ;Existing Device Disconnected
     DW DeviceDisconnected
    DB OwnerCallDvc0Disc      ;Unregistered Device Disconnected
     DW Device0Disconnected
    DB OwnerCallDontLook      ;Don't Look for New Interface Temporarily
     DW StartDontLook
   ;Device Enable/Disable/Reset/Suspend/Resume/PwrOn/PwrOff/PwrReset
    DB OwnerCallDvcEnable     ;Device Enabled
     DW DeviceEnabled
    DB OwnerCallDvcDisable    ;Device Disabled
     DW DeviceDisabled
    DB OwnerCallDvcReset      ;Device Reset
     DW DeviceReset
    DB OwnerCallDvcSuspend    ;Device Suspend
     DW DeviceSuspend
    DB OwnerCallDvcResume     ;Device Resume
     DW DeviceResume
    DB OwnerCallDvcPwrOn      ;Device Power On
     DW DevicePowerOn
    DB OwnerCallDvcPwrOff     ;Device Power Off
     DW DevicePowerOff
    DB OwnerCallDvcPwrReset   ;Device Power Reset
     DW DevicePowerReset
   ;Host Connect/Disconnect
    DB OwnerCallNewHost       ;New Host has been Added
     DW NewHostAdded
    DB OwnerCallHostDisc      ;Existing Host Disconnected
     DW HostDisconnected
    DB OwnerCallHostHWErr     ;Host System/Processor Error
     DW HostHWErr
   ;Host Run/Stop/Reset/Suspend/Resume/Debug/SingleStep
    DB OwnerCallHostRun       ;Host Running
     DW HostRun
    DB OwnerCallHostStop      ;Host Stopped
     DW HostStop
    DB OwnerCallHostReset     ;Host Reset
     DW HostReset
    DB OwnerCallHostSuspend   ;Host Suspended
     DW HostSuspend
    DB OwnerCallHostResume    ;Host Resumed
     DW HostResume
    DB OwnerCallHostDebug     ;Host in Debug Mode
     DW HostDebug
    DB OwnerCallHostSST       ;Host Single-Stepped
     DW HostSST
   ;Timing Changes
    DB OwnerCallTimingChg     ;Host Timing Changed
     DW TimingChange
   ;Upstream Device Changes
    DB OwnerCallDvcDiscUS     ;Device Disconnect Upstream
     DW DeviceDisconnectedUS
    DB OwnerCallDvcEnableUS   ;Device Enable Upstream
     DW DeviceEnabledUS
    DB OwnerCallDvcDisableUS  ;Device Disable Upstream
     DW DeviceDisabledUS
    DB OwnerCallDvcResetUS    ;Device Reset Upstream
     DW DeviceResetUS
    DB OwnerCallDvcSuspendUS  ;Device Suspend Upstream
     DW DeviceSuspendUS
    DB OwnerCallDvcResumeUS   ;Device Resume Upstream
     DW DeviceResumeUS
    DB OwnerCallDvcPwrOnUS    ;Device Power On Upstream
     DW DevicePowerOnUS
    DB OwnerCallDvcPwrOffUS   ;Device Power Off Upstream
     DW DevicePowerOffUS
    DB OwnerCallDvcPwrResetUS ;Device Power Reset Upstream
     DW DevicePowerResetUS
   ;Calls specific to Hubs (other devices don't get these)
    DB HubCallEnumerated      ;Device Enumerated
     DW DeviceEnumerated
    DB HubCallEnable          ;Enable Device
     DW EnableDevice
    DB HubCallDisable         ;Disable Device
     DW DisableDevice
    DB HubCallReset           ;Reset Device
     DW ResetDevice
    DB HubCallSuspend         ;Suspend Device
     DW SuspendDevice
    DB HubCallResume          ;Resume Device
     DW ResumeDevice
    DB HubCallPwrOn           ;Power On Device
     DW PowerOnDevice
    DB HubCallPwrOff          ;Power Off Device
     DW PowerOffDevice
    DB HubCallPwrReset        ;Power Reset Device
     DW PowerResetDevice
   ;End of Table
    DB -1                     ;End of Table
     DW -1

  ;----------------------------------------------------------------------------
  ;Table to keep track of individual Devices
  ;----------------------------------------------------------------------------
  EVEN 2
  DeviceInfoTable:
    DB (MaxDevices*DeviceInfoStrucSize) DUP (0)

  ;----------------------------------------------------------------------------
  ;This table will keep track of Host Indexes and Address of incompatible
  ;  Devices that we find.
  ;If we don't keep track of them, we will get caught in an endless
  ;  loop of looking at the bad one every time we check (if it happens
  ;  to be the first one), and will never skip over it and be
  ;  able to find a "good" (compatible) Device.
  ;----------------------------------------------------------------------------
  EVEN 2
  BadDeviceTable:
    DB (MaxBadDevices*BadDeviceStrucSize) DUP (0)

  ;----------------------------------------------------------------------------
  ;Offset in InfoTable of Last Device we found (needed to print Descriptors)
  ;----------------------------------------------------------------------------
  LastDeviceFound DW DeviceInfoTable

  ;----------------------------------------------------------------------------
  ;Stage & Error Code where New Device search failed (for troubleshooting)
  ;----------------------------------------------------------------------------
  NewDeviceStage DB ?
  NewDeviceError DW ?

  ;----------------------------------------------------------------------------
  ;Data Structures needed to issue Requests to the USB Host
  ;----------------------------------------------------------------------------
  EVEN 2
  Int14Request:
    DB Int14RequestSize DUP (0) ;LookForNewDevice calls
  Int14Request2:
    DB Int14RequestSize DUP (0) ;Individual Hub calls
  Int14Request3:
    DB Int14RequestSize DUP (0) ;External Hub Calls

  ;----------------------------------------------------------------------------
  ;Storage Area for Data returned by USB Descriptors
  ;----------------------------------------------------------------------------
  DvcDescrData:
    DB DeviceDescriptorSize  DUP (?) ;Device Descriptor Data
  HubDescrData:
    DB HubDescriptorSize     DUP (?) ;Hub Descriptor Data
  CfgDescrData:
    DB (MaxDescriptorSize+1) DUP (?) ;Configuration Descriptor Data

  TotalDescrSize EQU $-HubDescrData ;Size of all Buffers combined


;==============================================================================
;Hub Class-Specific Control Requests
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Hub Class Feature Selectors (put in SRValue and send Get/SetFeature Req)
  ;Recipient = Hub (RecipDevice), SRIndex = 0
  ;----------------------------------------------------------------------------
  HFLocalPowerChange   EQU 0 ;Change in Local Power Status
  HFHOverCurrentChange EQU 1 ;Change in Over Current Status

  ;----------------------------------------------------------------------------
  ;Recipient = Port (RecipOther), SRIndex = Port Number (1-based)
  ;----------------------------------------------------------------------------
  HFPortConnect           EQU  0 ;Device is connected
  HFPortEnable            EQU  1 ;Port is Enabled
  HFPortSuspend           EQU  2 ;Port is Suspended
  HFPortOverCurrent       EQU  3 ;Device is drawing too much current
  HFPortReset             EQU  4 ;Port in Reset state
  HFPortPower             EQU  8 ;Port is Powered up
  HFPortLowSpeed          EQU  9 ;Connected device is Low Speed

  HFPortConnectChange     EQU 16 ;Change in Connect Status
  HFPortEnableChange      EQU 17 ;Change in Enabled Status
  HFPortSuspendChange     EQU 18 ;Change in Suspend Status
  HFPortOverCurrentChange EQU 19 ;Change in Over Current Status
  HFPortResetChange       EQU 20 ;Change in Reset Status

  HFPortTest              EQU 21 ;Put Port In Test Mode (USB 2.0)
                                 ;Test Mode Selectors (High byte of SRIndex):
                                 ;  00h     = Reserved
                                 ;  01h     = TestJ
                                 ;  02h     = TestK
                                 ;  03h     = TestSE0Nak
                                 ;  04h     = TestPacket
                                 ;  05h     = TestForceEnable
                                 ;  06h-3Fh = Reserved for Standard Tests
                                 ;  40h-BFh = Reserved
                                 ;  C0h-FFh = Reserved for Vendor-Specific Tests
  HFPortIndicator         EQU 22 ;SW Control of Indicator Lights (USB 2.0)
                                 ;Port Indicator Selectors (High byte of SRIndex):
                                 ;  00h     = Automatic (Default) Colors
                                 ;  01h     = Amber
                                 ;  02h     = Green
                                 ;  03h     = Off
                                 ;  04h-FFh = Reserved

  EVEN 2

  ;----------------------------------------------------------------------------
  ;Set Port Feature
  ;----------------------------------------------------------------------------
  SetPortFeatureReq:
    DB SRRTOut+SRRTTypeClass+SRRTRecipOther
    DB SRRQSetFeature
    DB ? ;Feature Selection
    DB 0
    DB ? ;Port Number to Set (1-based)
    DB ? ;Selector Code (for PortTest & SWIndicatCtl)
    DW 0

  I14RSetPortFeatureFtr  EQU I14RSetupReqData.SRValue[0] ;Byte
  I14RSetPortFeaturePort EQU I14RSetupReqData.SRIndex[0] ;Byte
  I14RSetPortFeatureSel  EQU I14RSetupReqData.SRIndex[1] ;Byte

  ;----------------------------------------------------------------------------
  ;Clear Port Feature
  ;----------------------------------------------------------------------------
  ClearPortFeatureReq:
    DB SRRTOut+SRRTTypeClass+SRRTRecipOther
    DB SRRQClearFeature
    DB ? ;Feature Selection
    DB 0
    DB ? ;Port Number to Set (1-based)
    DB ? ;Selector Code (for PortTest & SWIndicatCtl)
    DW 0

  I14RClearPortFeatureFtr  EQU I14RSetupReqData.SRValue[0] ;Byte
  I14RClearPortFeaturePort EQU I14RSetupReqData.SRIndex[0] ;Byte
  I14RClearPortFeatureSel  EQU I14RSetupReqData.SRIndex[1] ;Byte

  ;----------------------------------------------------------------------------
  ;Set (turn on) Port Power
  ;----------------------------------------------------------------------------
  SetPortPowerReq:
    DB SRRTOut+SRRTTypeClass+SRRTRecipOther
    DB SRRQSetFeature
    DW HFPortPower
    DB ? ;Port Number (1-based)
    DB 0
    DW 0

  I14RSetPortPowerPort EQU I14RSetupReqData.SRIndex[0] ;Byte

  ;----------------------------------------------------------------------------
  ;Get Hub Status
  ;----------------------------------------------------------------------------
  GetHubStatusReq:
    DB SRRTIn+SRRTTypeClass+SRRTRecipDevice
    DB SRRQGetStatus
    DW 0
    DW 0
    DW 4

  ;----------------------------------------------------------------------------
  ;Get Port Status
  ;----------------------------------------------------------------------------
  GetPortStatusReq:
    DB SRRTIn+SRRTTypeClass+SRRTRecipOther
    DB SRRQGetStatus
    DW 0
    DB ?  ;Port Number to Get Status of (1-based)
    DB 0  ;Is a word
    DW 4

  I14RGetPortStatusPort EQU I14RSetupReqData.SRIndex[0] ;Byte

  ;----------------------------------------------------------------------------
  ;Get Hub Descriptor
  ;----------------------------------------------------------------------------
  GetHubDescrReq:
    DB SRRTIn+SRRTTypeClass+SRRTRecipDevice
    DB SRRQGetDescriptor
    DB 0            ;Index 0
    DB DescrTypeHub ;Type = Hub
    DW 0
    DW HubDescriptorSize


;==============================================================================
;USB General-Purpose Control Requests
;==============================================================================
  EVEN 2

  ;----------------------------------------------------------------------------
  ;Get Device Descriptor
  ;----------------------------------------------------------------------------
  GetDvcDescrReq:
    DB SRRTIn+SRRTTypeStandard+SRRTRecipDevice
    DB SRRQGetDescriptor
    DB 0
    DB DescrTypeDevice
    DW 0
    DW DeviceDescriptorSize

  ;----------------------------------------------------------------------------
  ;Get Configuration Descriptor
  ;----------------------------------------------------------------------------
  GetCfgDescrReq:
    DB SRRTIn+SRRTTypeStandard+SRRTRecipDevice
    DB SRRQGetDescriptor
    DB 0 ;Configuration Value to Get (always 0?)
    DB DescrTypeConfig
    DW 0
    DW ConfigDescriptorSize ;Size will change for a Complete Config

  I14RGetCfgDescrValue EQU I14RSetupReqData.SRValue[0] ;Byte
  I14RGetCfgDescrSize  EQU I14RSetupReqData.SRLength   ;Word


;哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌
;TSR CODE
;苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘

;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO HANDLE INT 2Fh (TSR Multiplex)
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;HAVE INTERRUPT 2Fh RUN THIS PROGRAM EVERY TIME IT OCCURS
;Inputs:  AH = Function (Handle) number, C0h-FFh
;         AL = Subfunction number
;          (If MuxGetProgName): DI = 0
;Outputs:  (AL = MuxInstallChk):  AL = FFh if installed
;          (AL = MuxGetProgName): ES:[DI] = Pointer to ProgName
;          (AL = MuxGetProgVer):  AX = ProgVer (Program version number, AH=Major)
;          (AL = MuxGetAuthor):   ES:[DI] = Pointer to Author
;Changes:
;------------------------------------------------------------------------------
Int2FHdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int2F:
  STI                               ;Enable Interrupts
  CMP  AH,CS:HandleNum              ;Is this our handle?
  JE   Int2FInstall                 ;If so, jump to handle it
  CMP  W CS:Int2FHdr.OldVector[2],0 ;Is the Old Vector valid?
  JE   Int2FDone                    ;If not, handle it
  JMP  D CS:Int2FHdr.OldVector      ;If so, go to the next one in the chain
Int2FDone:                          ;Invalid vector before us
  IRET

Int2FInstall:
  CMP  AL,MuxInstallChk  ;Is it Install Check?
  JNZ  Int2FProgName     ;If not, try the next possibility
  MOV  AL,-1             ;Mark the flag byte
  IRET

Int2FProgName:
  CMP  AL,MuxGetProgName ;Is it Get Program Name?
  JNE  Int2FProgVer      ;If not, try the next possibility
  OR   DI,DI             ;Does DI=0?
  JNZ >N90               ;If not, it's not for us
  MOV  ES,CS             ;If so, point ES:[DI]
  MOV  DI,ProgName       ;  at ProgName
N90:                     ;Done
  IRET

Int2FProgVer:
  CMP  AL,MuxGetProgVer ;Is it Get Program Version?
  JNE  Int2FAuthor      ;If not, try the next one
  MOV  AX,CS:ProgVer    ;If so, do it
  IRET

Int2FAuthor:
  CMP  AL,MuxGetAuthor ;Is it Get Author?
  JNE >A90             ;If not, we're done
  MOV  ES,CS           ;If so, point ES:[DI]
  MOV  DI,Author       ;  at Author
A90:                   ;Done
  IRET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO LOOK FOR NEW USB DEVICES
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;CHECK AND SEE IF ANY NEW DEVICES HAVE BEEN CONNECTED, AND HANDLE THEM
;Inputs:  DS = ES = Our Data Area
;         CLD already issued
;Outputs:
;Changes: Looks for new, unowned (unconfigured) Device
;         If one is found, it is Configured, Port Power is turned on,
;           the Change Interrupt is enabled, and pointed at us
;NOTES:   When we first install this program into memory, we Registered with
;           the USB Drivers that we wanted to be informed as soon as a new
;           Device was attached.  We also poll the hosts periodically for a
;           new Device, just in case we somehow missed the Host informing us.
;         Whether this is in response to the Host telling us, or whether we
;           polled to find out, this section of code is called.
;         This section of code is actually a series of short pieces of code,
;           which are disjointed in time.  One section schedules a USB Request
;           with the Host Driver, and gives the Host Driver the address
;           of the NEXT section of code to perform when the Request is
;           completed.
;         Requests sent to a USB Host can take anywhere from a few
;           milliseconds to several hundred milliseconds to complete.
;         It is very bad for a TSR to just sit around waiting for something
;           to happen, especially when it can be a long time in coming.
;         This back-and-forth approach between the Host Driver and the Device
;           Driver makes the TSR run pretty efficiently.
;------------------------------------------------------------------------------
LookForNewDevice:
  CALL FindEmptyInfoBX              ;Look for an empty Info Table Entry (BX)
  JZ  >L901                         ;If none, just quit
  TEST TSRFlags,Int14ReqInUse       ;Is the Request Structure already in use?
  JNZ >L901                         ;If so, just quit
  OR   TSRFlags,Int14ReqInUse       ;If not, mark it as in use now
  MOV  SI,Int14Request              ;Point at our Int 14 Structure
  MOV  [SI].I14RRequestType,I14RRTFindUnRegIntf ;Request Type = Find Interface
  MOV  [SI].I14RHostIndex,-1        ;Any/All Hosts
  MOV  [SI].I14RSearchIndex,0       ;Start with Search Index 0
L10:                                ;Loop to here to find Device
  CALL DoInt14CallCXDXSI            ;Do it (uses DS:SI, CH = Addr, CL = Host,
                                    ;  DL = Interface, DH = Alt Interface)
  JC  >L80                          ;If no device, we're done
  CALL TestBadDevice                ;If one there, is it in our Bad List?
  JC  >L20                          ;If not, continue
  INC  [SI].I14RSearchIndex         ;If so, Increment the Search Index
  JMP  L10                          ;Keep looking
L20:                                ;Found a possible Device!
  MOV  [SI].I14RRequestType,I14RRTConfigingIntf ;Request Type = Configing
  MOV  W [SI].I14RHostIndex,CX      ;Store Host Index & Device Address
  CALL DoInt14CallSaveAllSI         ;Do it
  JNC >L30                          ;If OK, continue
  MOV  Int08Counter,2               ;If not, Look again Soon
  JMP >L80                          ;Done for now
L901:                               ;To avoid JMP > 128
  JMP >L90
L30:                                ;OK to Configure Interface
  MOV  NewDeviceStage,0             ;Stage
  MOV  NewDeviceError,0             ;  Zero
  CALL ClearDescriptorData          ;Clear out the data buffer
  OR   [BX].DIFlags,DIFlagInUse     ;Mark Info Table entry as in use
  MOV  W [BX].DIHostIndex,CX        ;Store Host Index & Device Address
  MOV  [BX].DIInterfaceNum,DL       ;Store Interface Number
  MOV  [SI].I14RUserPktID,BX        ;Set User Pkt ID to Info Table Offset
  MOV  [SI].I14RRequestType,I14RRTDoControl ;Request Type = Control
  MOV  [SI].I14RInterfaceNum,DL     ;Store Interface Number
  MOV  [SI].I14REndPoint,0          ;EndPoint 0
  MOV  CX,GetDvcDescrReq            ;Copy
  CALL CopySetupReqToInt14SI        ;  Request Pkt
  MOV  W [SI].I14RDataAddress[0],DvcDescrData    ;Put data here
  MOV  W [SI].I14RCallBackAddr[0],GotDeviceDescr ;Go here when done
  CALL DoInt14CallAXSI              ;Do it
  JNC >L90                          ;If it worked, we're done
  MOV  NewDeviceStage,1             ;Update Stage
  CALL FinishUpBadDevice            ;If not, mark it as bad
  JMP >L90                          ;Done
L80:                                ;No New Devices
  AND  TSRFlags,(NOT Int14ReqInUse) ;Mark the request as available
L90:                                ;Done
  RET                               ;NOT RETF here!

;------------------------------------------------------------------------------
;Inputs: [BX] = Info Table Pointer
;------------------------------------------------------------------------------
GotDeviceDescr:
  MOV  NewDeviceStage,20     ;Update Stage
  JNZ >D70                   ;If Error, handle it
  MOV  SI,Int14Request       ;Point at Int14 Request Structure
  MOV  CX,GetCfgDescrReq     ;Copy
  CALL CopySetupReqToInt14SI ;  Request Pkt
  MOV  W [SI].I14RDataAddress[0],CfgDescrData    ;Put data here
  MOV  W [SI].I14RCallBackAddr[0],GotConfigDescr ;Go here when done
  CALL DoInt14CallAXSI       ;Do it
  JNC >D90                   ;If it worked, we're done
  MOV  NewDeviceStage,21     ;Update Stage
D70:                         ;Error
  CALL FinishUpBadDevice     ;Mark it as Bad
D90:                         ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Info Table Pointer
;------------------------------------------------------------------------------
GotConfigDescr:
  MOV  NewDeviceStage,30     ;Update Stage
  JNZ >O70                   ;If Error, handle it
  MOV  NewDeviceStage,31     ;Update Stage
  MOV  SI,Int14Request       ;Point at Int14 Request Structure
  MOV  DI,CfgDescrData       ;Get the length
  MOV  AX,[DI].CDTotalLength ;  of the entire Descriptor
  CMP  AX,MaxDescriptorSize  ;Will it fit in our buffer?
  JAE >O70                   ;If not, Error
  MOV  W [SI].I14RGetCfgDescrSize,AX ;Store the number of bytes
  MOV  W [SI].I14RCallBackAddr[0],GotCompleteConfig ;Go here when done
  CALL DoInt14CallAXSI       ;Do it
  JNC >O90                   ;If it worked, we're done
  MOV  NewDeviceStage,32     ;Update Stage
O70:                         ;Error
  CALL FinishUpBadDevice     ;Mark it as Bad
O90:                         ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Info Table Pointer
;------------------------------------------------------------------------------
GotCompleteConfig:
  MOV  NewDeviceStage,40     ;Update Stage
  JNZ >P70                   ;If Error, handle it
  MOV  SI,Int14Request       ;Point at Int14 Request Structure
  MOV  CX,GetHubDescrReq     ;Copy
  CALL CopySetupReqToInt14SI ;  Request Pkt
  MOV  W [SI].I14RDataAddress[0],HubDescrData ;Put Data Here
  MOV  W [SI].I14RCallBackAddr[0],GotHubDescr ;Go here when done
  CALL DoInt14CallAXSI       ;Do it
  JNC >P90                   ;If it worked, we're done
  MOV  NewDeviceStage,41     ;Update Stage
P70:                         ;Error
  CALL FinishUpBadDevice     ;Mark it as Bad
P90:                         ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Info Table Pointer
;------------------------------------------------------------------------------
GotHubDescr:
  MOV  NewDeviceStage,50              ;Update Stage
  JNZ >H70                            ;If Error, handle it
  MOV  NewDeviceStage,200             ;Update Stage
  MOV  SI,HubDescrData                ;Point at Hub Descriptor Data
  CMP  [SI].HDDescType,DescrTypeHub   ;Is the Descriptor valid?
  JNE >H70                            ;If invalid, we're done
  MOV  NewDeviceStage,201             ;Update Stage
  MOV  AL,[SI].HDNumPorts             ;If OK, get the number of Ports
  OR   AL,AL                          ;Is it valid?
  JZ  >H70                            ;If not, error
  CMP  AL,MaxPorts                    ;Is it more than we can handle?
  JA  >H70                            ;If so, just quit
  MOV  [BX].DINumPorts,AL             ;If OK, save it
  MOV  AH,[SI].HDHubCurrent           ;Get and store
  MOV  [BX].DIHubCurrent,AH           ;  the Hub Current Draw
  TEST [SI].HDHubChar,HDCharIndPwrSwitch ;Does it suport Per-Port-Pwr Switching?
  JZ  >H20                            ;If not, skip down
  OR   [BX].DIFlags,DIFlagHubPPP      ;If so, mark it as supporting PPP
H20:                                  ;Done with Per-Port-Power Flag
  MOV  SI,Int14Request                ;Point at Int14 Request Structure
  MOV  CX,SetPortPowerReq             ;Copy
  CALL CopySetupReqToInt14SI          ;  Request Pkt
  MOV  B [SI].I14RSetPortPowerPort,AL ;Put Port number in the request
  MOV  W [SI].I14RCallBackAddr[0],SetPortPwr ;Go here when done
  MOV  NewDeviceStage,55              ;Update Stage
  CALL DoInt14CallAXSI                ;Do it
  JNC >H90                            ;If it worked, we're done
H70:                                  ;Error
  CALL FinishUpBadDevice              ;Mark it as Bad
H90:                                  ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Info Table Pointer
;------------------------------------------------------------------------------
SetPortPwr:
  MOV  DI,OFFSET NewDeviceStage ;Point [DI] at new Device Stage
  INC  B [DI]              ;Increment Stage
  TEST B [DI],1            ;Is it even?
  JZ  >P10                 ;If so, it's OK
  INC  B [DI]              ;If not, make it even
P10:                       ;NewDevieStage is OK
  OR   AX,AX               ;Was there an error from the previous call?
  JNZ >P70                 ;If so, handle it
  MOV  SI,Int14Request     ;Point at Int14 Request Structure
  DEC  B [SI].I14RSetPortPowerPort ;Go to next Port Number
  JZ  >P40                 ;If we've done all the Ports, continue
  CALL DoInt14CallAXSI     ;Do it
  JNC >P90                 ;If it worked, we're done
  JMP >P70                 ;If not, Error

P40:                       ;Done Powering up the Ports
  MOV  NewDeviceStage,80   ;Stage 60
  MOV  DX,SetUpInts        ;Code to call when done
  MOV  AL,HubDescrData.HDPowerOn2PowerGood ;Get Time to Wait
  OR   AL,AL               ;Is number of milliseconds 0?
  JNZ >P50                 ;If not, continue
  MOV  AL,50               ;If so, make it 50
P50:                       ;AL is OK
  XOR  AH,AH               ;AX = number of milliseconds to wait
  SHL  AX,1                ;  before Port Power is Good
  CALL StartOneTimeIntAXms ;Do it
  JNC >P90                 ;If it worked, we're done
  MOV  NewDeviceStage,81   ;Update Stage
P70:                       ;Error
  CALL FinishUpBadDevice   ;Mark it as Bad
P90:                       ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Info Table Pointer
;------------------------------------------------------------------------------
SetUpInts:
  MOV  NewDeviceStage,210                         ;Update Stage
  MOV  SI,Int14Request                            ;Point at Int14 Request
  MOV  [SI].I14RRequestType,I14RRTRegIntfOwner    ;Register as Owner
  MOV  W [SI].I14RCallBackAddr[0],DvcOwnerFarCall ;Owner Address
  CALL DoInt14CallAXCXSI                          ;Do it
  JC  >S70                                        ;If it didn't work, Error
  MOV  NewDeviceStage,211                         ;Update Stage
  MOV  [BX].DIRegHandle,CX                        ;Save the Registry Handle
  MOV  [SI].I14RRequestType,I14RRTDoInterruptPer  ;Periodic Interrupt
  MOV  [SI].I14RPeriodicity,19                    ;Every 19ms
  MOV  [SI].I14RFlags,I14RFlagIn                  ;Direction = In
  MOV  [SI].I14REndPoint,1                        ;EndPoint 1
  MOV  [SI].I14RDataSize,1                        ;Data size = 1 (max 7 ports)
  MOV  W [SI].I14RDataAddress[0],BX               ;Where to
  ADD  W [SI].I14RDataAddress[0],(OFFSET DIStatusChange) ;  put data
  MOV  W [SI].I14RCallBackAddr[0],HubChangeCode   ;Code to call
  CALL DoInt14CallAXCXSI                          ;Do it
  JC  >S70                                        ;If it didn't work, Error
  MOV  NewDeviceStage,212                         ;Update Stage
  MOV  [BX].DIIntHandle,CX                        ;Save the Interrupt Handle
  MOV  LastDeviceFound,BX                         ;Store as Last Hub Found
  MOV  [SI].I14RRequestType,I14RRTSendHubChar     ;Request = Send Hub Characteristics
  MOV  AL,[BX].DINumPorts                         ;Store number
  MOV  B [SI].I14RHubPort,AL                      ;  of Ports
  MOV  [SI].I14RConfigValue,0                     ;Start flags at 0
  TEST [BX].DIFlags,DIFlagHubPPP                  ;Does the Hub Support PPP?
  JZ  >S30                                        ;If not, skip down
  OR   [SI].I14RConfigValue,01h                   ;If so, mark it as supported
S30:                                              ;Have Hub characteristics
  CALL DoInt14CallSaveAllSI                       ;Send it
  JMP >S80                                        ;Done
S70:                                              ;Error
  CALL FinishUpBadDevice                          ;Mark it as Bad
  JMP >S90                                        ;Done
S80:                                              ;Hub is Configured
  MOV  [SI].I14RRequestType,I14RRTConfigIntfDone  ;Request = Done Configuring
  CALL DoInt14CallSaveAllSI                       ;Do it
  CMP  Int08Counter,0                             ;Disabled?
  JE  >S85                                        ;If so, Done
  MOV  Int08Counter,2                             ;Look for another Hub soon
S85:                                              ;DOne with Counter
  AND  TSRFlags,(NOT Int14ReqInUse)               ;Mark Request as Avail
S90:                                              ;Done
  RETF


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;SUPPORT FUNCTIONS NEEDED BY LOOKFORNEWDEVICE PROCESS
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;FINISH UP A BAD DEVICE ENTRY
;Inputs:  BX = Info Table Offset
;         (Info Table Entry contains Device Data)
;         DS = ES = TSR Data Area
;         Int14Request (contains Host/Address/Interface Data)
;Outputs: Resets DeviceInfoTable Entry
;         Marks Int14Request as available (not in use any more)
;         Updates NewDeviceStage & NewDeviceError
;         Puts Device info in BadDevice Table
;         Issues Request to Beep the Speaker
;Changes: DI,SI
;------------------------------------------------------------------------------
FinishUpBadDevice:
  MOV  SI,Int14Request              ;Point at Int14 Request Struc
  MOV  NewDeviceError,AX            ;Store Error Code
  CALL ResetDvcEntryBX              ;Reset the Dvc Info Entry that we Reserved
  MOV  [SI].I14RRequestType,I14RRTGetDvcStatus ;Request = Get Dvc Status
                                               ;(Make sure Device is still
                                               ;  plugged in)
  CALL DoInt14CallSaveAllSI         ;Issue the Request
  JC  >B10                          ;If error (no Device), don't add to Bad Tbl
  CALL AddBadDevice                 ;Add it to Bad Table
B10:                                ;Bad Device added to table, if appropriate
  TEST TSRFlags,NoBeep              ;Are we allowed to Beep the Speaker
  JNZ >B20                          ;If not, skip down
  MOV  [SI].I14RRequestType,I14RRTBeepSpeaker ;Want to beep the Speaker
  MOV  [SI].I14RHostIndex,-1        ;Any Host
  MOV  B [SI].I14RTimeout,3         ;Beep length = 3 DeciSeconds
  MOV  W [SI].I14RBeepFrequency,300 ;Frequency = 300Hz
  CALL DoInt14CallSaveAllSI         ;Do it
  MOV  B [SI].I14RTimeOut,0         ;Reset Timeout Value
B20:                                ;Done handling Beep
  MOV  [SI].I14RRequestType,I14RRTConfigIntfDone ;Request = Done Configuring
  CALL DoInt14CallSaveAllSI         ;Do it
  CMP  Int08Counter,0               ;Disabled?
  JE  >B90                          ;If so, Done
  MOV  Int08Counter,2               ;Look for another Device soon
B90:                                ;Done
  AND  TSRFlags,(NOT Int14ReqInUse) ;Mark the request as available
  RET

;------------------------------------------------------------------------------
;CLEAR OUT THE OLD DATA FROM THE DESCRIPTOR DATA BUFFERS
;Inputs:  DS = ES = TSR Data Area
;         CLD already issued
;Outputs:
;Changes: XDescrData Buffers become all zeroes
;------------------------------------------------------------------------------
ClearDescriptorData:
  PUSH AX,CX,DI          ;Save used registers
  MOV  DI,HubDescrData   ;Point at Buffers
  MOV  CX,TotalDescrSize ;Number of bytes to write
  XOR  AL,AL             ;Write zeroes
  REP  STOSB             ;Do it
  POP  DI,CX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY A REQUEST (CONTROL) STRUCTURE INTO THE INT14 STRUCTURE
;Inputs:  [CX] = Request Structure to Copy
;          DS  = TSR Data Area (contains both Request & Int14 Request)
;         [DI] = Int14 Request Structure to copy it to
;      or [SI] = Int14 Request Structure to copy it to
;Outputs:
;Changes: Int14 Structure contains Request Structure Data
;------------------------------------------------------------------------------
CopySetupReqToInt14SI:
  PUSH DI                    ;Save used registers
  MOV  DI,SI                 ;Put pointer in DI
  CALL CopySetupReqToInt14DI ;Copy it
  POP  DI                    ;Restore used registers
  RET

CopySetupReqToInt14DI:
  PUSH CX,DI,SI,ES                ;Save used registers
  MOV  ES,DS                      ;Point ES at correct Data Area
  ADD  DI,OFFSET I14RSetupReqData ;Point at correct part of structure
  MOV  SI,CX                      ;Point at structure to copy
  MOV  CX,(SetupRequestSize/2)    ;Number of words to copy
  REP  MOVSW                      ;Copy it
  POP  ES,SI,DI,CX                ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO HANDLE PERIODIC SCANNING FOR NEW DEVICES ATTACHED TO HUB PORTS
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;  MissingConnectIndex DB ? ;Index of next Hub to test for Missing Ports
;
;;------------------------------------------------------------------------------
;;LOOK FOR DEVICES ATTCHED TO HUB PORTS THAT ARE "STALLED" (NOT ENUMERATED)
;;Inputs:  DS = ES = TSR Data Area
;;         MissingConnectIndex
;;Ouputs:  Looks for newly connected devices that are "stalled" for some reason
;;Changes: MissignConnectIndex
;;NOTES: Sometimes (why, I don't know), new Devices are connected to a Hub,
;;         and the Change-in-Connect has been confirmed, but the Device
;;         has never been Enabled or Enumerated.  Unplugging and
;;         re-inserting the Device fixes the problem, but it should not
;;         be necessary for the User to do that.
;;       Therefore, we will periodically scan for Devices that got
;;         "stalled out" for some reason and go ahead an finish the
;;         enumeration process.
;;------------------------------------------------------------------------------
;FindMissingConnects:
;  PUSH AX,BX,DI                       ;Save used registers
;  TEST TSRFlags,Configing+FindMissing ;Already Looking/Configuring?
;  JNZ >F90                            ;If so, just quit
;  OR   TSRFlags,FindMissing           ;If not, mark as searching
;  MOV  BL,MissingConnectIndex         ;Get the Next Index to Test
;  MOV  BH,BL                          ;Store it as a completion value
;F10:                                  ;Loop to here for ech Host
;  CALL DIIndex2OffsetBL               ;Convert the Index to an Offset
;  TEST [DI].DIFlags,DIFlagInUse       ;Valid Hub?
;  JZ  >F50                            ;If not, skip down
;  MOV  BH,[DI].DINumPorts             ;Start with last Port Number
;  INC  BH                             ;  Plus 1
;  XOR  AX,AX                          ;Set AX <> 0,
;  DEC  AX                             ;  & clear ZF
;  PUSH AX,BX,CX,DX,DI,SI,BP           ;Save all registers
;  PUSH CS                             ;Look for
;  CALL DoMissingConnects              ;  Missing Connects
;  POP  BP,SI,DI,DX,CX,BX,AX           ;Restore all registers
;  CALL IncHubIndex                    ;Increment/Reset the Index
;  JMP >F80                            ;Done
;F50:                                  ;Not a valid Hub
;  CALL IncHubIndex                    ;Increment/Reset the Index
;  CMP  BL,BH                          ;Done all of the Hubs yet?
;  JNE  F10                            ;If not, keep testing
;  AND  TSRFlags,(NOT FindMissing)     ;Mark as done
;F80:                                  ;Done (Store new MissingConnectIndex)
;  MOV  MissingConnectIndex,BL         ;Store the Index for next time
;F90:                                  ;Done
;  POP  DI,BX,AX                       ;Restore used registers
;  RET
;
;;Inputs:  BL = Current Host Index
;;Outputs: BL = Incremented by 1, or reset to 0 when it gets too big
;;Changes:
;IncHubIndex:
;  INC  BL            ;Increment Index
;  CMP  BL,MaxDevices ;Is it too big?
;  JB  >X90           ;If not, we're done
;  XOR  BL,BL         ;If so, start it at 0 again
;X90:
;  RET
;
;;------------------------------------------------------------------------------
;;SCAN HUB FOR POSSIBLE MISSING CONNECTS, AND FIND OUT IF THEY ARE "STALLED"
;;Inputs:  DS = ES = TSR Data Area
;;         BL = Hub Info Index
;;         BH = Port Nubmer to test
;;         TSRFlags.FindMissing = True
;;         AX = 0 if previous call worked, <> 0 if not (or first call)
;;Outputs: Issues "Get Port Status" Requests to all Hub Ports that don't
;;            appear to have any devices on them yet
;;Changes: Can Change all registers!
;;------------------------------------------------------------------------------
;DoMissingConnects:
;  TEST TSRFlags,Configing           ;Another device being configured?
;  JNZ >C80                          ;If so, we're done
;  CALL DIIndex2OffsetBL             ;Convert the Index to an Offset (DI)
;  TEST [DI].DIFlags,DIFlagInUse     ;Hub still installed?
;  JZ  >C80                          ;If not, we're done
;  MOV  SI,Int14Request2             ;Point at Request Structure
;  MOV  B [SI].I14RUserPktID[0],BL   ;Put Hub Index in low byte of User Pkt ID
;  MOV  BL,BH                        ;Put Port Number
;  XOR  BH,BH                        ;  in BX
;  OR   AX,AX                        ;Error from last call (or first call)?
;  JNZ >C50                          ;If so, go to next port
;  TEST B [DI].DIPortStatus[0],DIPStConnected ;Device connected?
;  JZ  >C50                          ;If not, we're done with this port
;  TEST B [DI].DIPortStatus[2],DIPChConnect   ;Has it been confirmed yet?
;  JNZ >C50                          ;If not, wait for it to get confirmed
;C10:                                ;Found a missing Device!
;  MOV  BH,BL                        ;Put Port number in BH
;  MOV  BL,B [SI].I14RUserPktID[0]   ;Put Hub Index in BL
;  OR   TSRFlags,Configing           ;Mark as Configing
;  AND  TSRFlags,(NOT FindMissing)   ;Mark as Not finding any more
;  PUSH CS                           ;Handle a
;  CALL PortConnectChange            ;  new connect
;  JMP >C90                          ;We're done
;C50:                                ;Done with this Port
;  DEC  BL                           ;Decrement Port Number
;  JZ  >C80                          ;If this is last port, we're done
;  CMP  B [DI+BX-1].DIPort1Address,0 ;Valid Device already on this Port?
;  JE   C50                          ;If so, skip it
;  MOV  AX,W [DI].DIHostIndex        ;Copy Host Index
;  MOV  W [SI].I14RHostIndex,AX      ;  and Device Address
;  MOV  B [SI].I14RUserPktID[1],BL   ;Put port number in low byte of User Pkt ID
;  MOV  BH,BL                        ;Put Port Nubmer in BH
;  MOV  DX,DoMissingConnects         ;Code to call when done
;  CALL UpdatePortInfo               ;Send the Request
;  JMP >C90                          ;Done
;C80:
;  AND  TSRFlags,(NOT FindMissing)   ;Mark as done
;C90:                                ;Done
;  RETF


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO HANDLE CHANGES TO DEVICES ATTACHED TO THE HUB PORTS
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;DO THIS EVERY TIME A HUB DETECTS A CHANGE OF SOME SORT
;Inputs:  [BX] = Info Table Pointer
;------------------------------------------------------------------------------
HubChangeCode:
  JNZ >C90                        ;If error (probably NAK), just quit
  TEST TSRFlags,Configing         ;Still handling things from last time?
  JNZ >C90                        ;If so, wait until next time
  MOV  DI,BX                      ;Put Hub Info Pointer in DI
  CALL DIOffset2Index             ;Get the Hub Index (CL)
  MOV  BL,CL                      ;Put the Hub Index in BL (BH = undefined)
  CALL CopyHubInfoToInt14         ;Copy basic Info to Int14
                                  ;  Returns [DI] = Hub Info Entry,
                                  ;    [SI] = Int14Request2
  MOV  AL,[DI].DIStatusChange     ;Get the change byte
  OR   AL,AL                      ;Did anything really change?
  JZ  >C90                        ;If not, we're done
  TEST AL,1                       ;Is it a Hub Change (not a Port Change)?
  JNZ >C40                        ;If so, handle it
C20:                              ;It's a Port Change
  MOV  BH,1                       ;Start with
  MOV  AH,2                       ;  Port 1
  MOV  CX,MaxPorts                ;Test All ports
C30:                              ;Loop to here for each Port to test
  TEST AL,AH                      ;Did this Port Change?
  JNZ >C50                        ;If so, handle it
  SHL  AH,1                       ;If not, move to
  INC  BH                         ;  the next Port
  LOOP C30                        ;Keep looking
  JMP >C90                        ;Done
C40:                              ;It's a Hub Change (not a Port change)
  AND  TSRFlags,(NOT Configing)   ;Mark as done Configing
  MOV  [SI].I14RRequestType,I14RRTResetDevice ;Request = Reset Device
  CALL DoInt14CallSaveAllSI       ;Do it
  JMP >C90                        ;Done
C50:                              ;It's a Port Change (BH = Port Number)
  OR   TSRFlags,Configing         ;Mark as configuring a device
  MOV  NewExtDeviceStage,0        ;Stage 0
  MOV  NewExtDeviceError,0        ;Error 0
  MOV  B [SI].I14RUserPktID[1],BH ;Put Port Number in High byte of User Pkt ID
  MOV  DX,GotPortChangeData       ;Code to call when done
  CALL UpdatePortInfo             ;Get Port Information (rtns AX)
  JNC >C90                        ;If it worked, we're done
  MOV  NewExtDeviceStage,1        ;Update Stage
C70:                              ;Error
  AND  TSRFlags,(NOT Configing)   ;Done Configing
C90:                              ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BL = Hub Info Index
;         BH = Port Number
;------------------------------------------------------------------------------
GotPortChangeData:
  MOV  NewExtDeviceStage,10       ;Update stage
  JNZ >P70                        ;If Error, handle it
  CALL CopyHubInfoToInt14         ;Copy basic Info to Int14
                                  ;  Returns [DI] = Hub Info Entry,
                                  ;    [SI] = Int14Request2
  MOV  AL,B [DI].DIPortChangeStatus[0] ;Get Port Change Status
  MOV  W [SI].I14RCallBackAddr[0],ClearPortFeatureDone ;Go here when done
P10:                              ;Check for Basic Features to Clear
  CMP  HubCallsInProg,0           ;Are Hub Calls currently being processed?
  JNE >P20                        ;If so, don't worry about these changes
  MOV  AH,HFPortResetChange       ;Assume End-of-Reset
  TEST AL,DIPChReset              ;Is it?
  JNZ >P60                        ;If so, send it
  MOV  AH,HFPortSuspendChange     ;Assume change in Suspend
  TEST AL,DIPChSuspend            ;Is it?
  JNZ >P60                        ;If so, send it
  MOV  AH,HFPortEnableChange      ;Assume change in Enable
  TEST AL,DIPChEnable             ;Is it?
  JNZ >P60                        ;If so, send it
  MOV  AH,HFPortOverCurrentChange ;Assume change in OverCurrent
  TEST AL,DIPChOverCurrent        ;Is it?
                                  ;UnPower, Disable, or Reset Device Here?
  JNZ >P60                        ;If so, send it
P20:                              ;Check for Change in Connect Status
  TEST AL,DIPChConnect            ;Is it change in Connect Status?
  JZ  >P80                        ;If not, we're done
  MOV  AH,HFPortConnectChange     ;Change in Connect
  MOV  W [SI].I14RCallBackAddr[0],PortConnectChange ;Go here when Done
P60:                              ;Send ClearPortFeature Request
  MOV  CX,ClearPortFeatureReq     ;Copy
  CALL CopySetupReqToInt14SI      ;  Request Pkt
  MOV  B [SI].I14RClearPortFeaturePort,BH ;Port number to Clear Feature on
  MOV  B [SI].I14RClearPortFeatureFtr,AH ;Store the Feature ID to Clear
  CALL DoInt14CallAXSI            ;Do the request
  JNC >P90                        ;If it worked, we're done
  MOV  NewExtDeviceStage,11       ;Update stage
P70:                              ;Error
  MOV  NewExtDeviceError,AX       ;Store the Error Code
P80:                              ;Done, no Error
  AND  TSRFlags,(NOT Configing)   ;Done Configing
P90:                              ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BL = Hub Info Index
;         BH = Port Number
;------------------------------------------------------------------------------
ClearPortFeatureDone:
  MOV  NewExtDeviceStage,20     ;Update Stage
  JNZ >F70                      ;If Error, handle it
  CALL CopyHubInfoToInt14       ;Copy basic Info to Int14
                                ;  Returns [DI] = Hub Info Entry,
                                ;    [SI] = Int14Request2
  MOV  DX,GotPortChangeData     ;Code to call when done
  CALL UpdatePortInfo           ;Get Port Information (rtns AX)
  JNC >F90                      ;If it worked, we're done
  MOV  NewExtDeviceStage,21     ;Update Stage
F70:                            ;Error
  MOV  NewExtDeviceError,AX     ;Store the Error Code
  AND  TSRFlags,(NOT Configing) ;Done Configing
F90:                            ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BL = Hub Info Index
;         BH = Port Number
;------------------------------------------------------------------------------
PortConnectChange:
  MOV  NewExtDeviceStage,30      ;Update Stage
  JNZ >C70                       ;If Error, handle it
  CALL CopyHubInfoToInt14        ;Copy basic Info to Int14
                                 ;  Returns [DI] = Hub Info Entry,
                                 ;    [SI] = Int14Request2
  MOV  [SI].I14RHubPort,BH       ;Store Port Number in Request
  TEST B [DI].DIPortStatus[0],DIPStConnected ;Is a new Device Connected?
  JZ  >C40                       ;If not, handle a Disconnect

C10:                             ;Device Connected
  CALL GetAddress4Port           ;Port already used (AL)?
  JZ  >C20                       ;If not, continue
C15:                             ;Device Conn, has Address
  MOV  NewExtDeviceStage,31      ;Update Stage
  MOV  [SI].I14RDeviceAddress,AL ;Address to Reset
  MOV  [SI].I14RRequestType,I14RRTResetDevice ;Request = Reset Device
  CALL DoInt14CallAXSI           ;Do it
  JNC >C80                       ;If it worked, we're done
  CMP  AX,I14RErrHostCallInUse   ;If error, is it already resetting?
  JE  >C80                       ;If so, it's OK
  JMP >C70                       ;If not Error
C20:                             ;Device Conn, no Address yet
  MOV  NewExtDeviceStage,33      ;Update Stage
  MOV  W [SI].I14RCallBackAddr[0],NewDvcDisabled ;Where to go when done
  MOV  [SI].I14RRequestType,I14RRTDisableHubPort ;Request = Disable Port
  CALL DoInt14CallAXSI           ;Do it
  JNC >C90                       ;If it worked, we're done
  JMP >C70                       ;If not, Error

C40:                             ;Device Disconnected
  CALL GetAddress4Port           ;Was anything connected (AL)?
  JNZ >C50                       ;If so, Handle a Disconnect
C45:                             ;Device Disc, no Address yet
  MOV  NewExtDeviceStage,35      ;Update Stage
  MOV  [SI].I14RRequestType,I14RRTDisableHubPort ;Request = Disable Port
  CALL DoInt14CallAXSI           ;Do it
  JNC >C80                       ;If it worked, we're done
  JMP >C70                       ;If not, Error
C50:                             ;Device Disc, has Address
  MOV  NewExtDeviceStage,37      ;Update Stage
  MOV  [SI].I14RRequestType,I14RRTDvcDisc ;Request = Device Disconnect
  CALL DoInt14CallAXSI           ;Do it
  JC  >C70                       ;If it didn't work, Quit
  XOR  AL,AL                     ;If it did, mark the Port
  CALL SetAddress4Port           ;  as unused
  JMP >C80                       ;Done
C70:                             ;Error
  MOV  NewExtDeviceError,AX      ;Store the Error Code
C80:                             ;Done, No Error
  AND  TSRFlags,(NOT Configing)  ;Done Configing
C90:                             ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BL = Hub Info Index
;         BH = Port Number
;------------------------------------------------------------------------------
NewDvcDisabled:
  MOV  NewExtDeviceStage,50     ;Update Stage
  JNZ >D70                      ;If Error, handle it
  CALL CopyHubInfoToInt14       ;Copy basic Info to Int14
                                ;  Returns [DI] = Hub Info Entry,
                                ;    [SI] = Int14Request2
  MOV  DX,NewDvcPoweredUp       ;Where to go when done
  MOV  AX,250                   ;Delay 250ms
  CALL StartOneTimeIntAXms      ;Wait for Power Up
  JNC >D90                      ;If it worked, we're done
  MOV  NewExtDeviceStage,51     ;Update Stage
D70:                            ;Error
  MOV  NewExtDeviceError,AX     ;Store the Error Code
  AND  TSRFlags,(NOT Configing) ;Done Configing
D90:                            ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BL = Hub Info Index
;         BH = Port Number
;------------------------------------------------------------------------------
NewDvcPoweredUp:
NewDvcResetWait1:
  CALL CopyHubInfoToInt14       ;Copy basic Info to Int14
                                ;  Returns [DI] = Hub Info Entry,
                                ;    [SI] = Int14Request2
  ADD  NewExtDeviceStage,2      ;Update Stage
  MOV  DX,NewDvcResetWait2      ;Go here when done
  CALL UpdatePortInfo           ;Get latest port info (rtns AX)
  JNC >O90                      ;If it worked, we're done
O70:                            ;Error
  INC  NewExtDeviceStage        ;Increment Device Stage
  MOV  NewExtDeviceError,AX     ;Store the Error Code
  AND  TSRFlags,(NOT Configing) ;Done Configing
O90:                            ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BL = Hub Info Index
;         BH = Port Number
;------------------------------------------------------------------------------
NewDvcResetWait2:
  MOV  NewExtDeviceStage,60      ;Stage 60
  JNZ >W70                       ;If Error, handle it
  CALL CopyHubInfoToInt14        ;Copy basic Info to Int14
                                 ;  [DI] = Hub Info Entry,
                                 ;  [SI] = Int14Request2
  TEST B [DI].DIPortStatus[0],DIPStConnected ;Is the Device still Connected?
  JZ  >W75                       ;If not, we're done
  MOV  AL,B [DI].DIPortStatus[1] ;Get Byte that contains the Speed
  XOR  AH,AH                     ;Assume Full-Speed
  TEST AL,(DIPStLowSpeed SHR 8)  ;Low-Speed Device?
  JZ  >W30                       ;If not, check High-Speed
  OR   AH,I14RFlagLowSpeed       ;If so, set Low-Speed flag
  JMP >W40                       ;Continue
W30:                             ;Test High Speed
  TEST AL,(DIPStHiSpeed SHR 8)   ;High-Speed Device?
  JZ  >W40                       ;If not, continue
  OR   AH,I14RFlagHiSpeed        ;If so, set High-Speed flag
W40:                             ;Have speed accounted for (in AH)
  MOV  [SI].I14RFlags,AH         ;Mask in the Speed Flag
  MOV  [SI].I14RHubPort,BH       ;Hub Port Number
  MOV  [SI].I14RRequestType,I14RRTNewDvcConn ;Request = Device Connect
  MOV  W [SI].I14RCallBackAddr[0],NewDvcReady ;Go here when done
  CALL DoInt14CallAXSI           ;Do it
  JNC >W90                       ;If it worked, we're done
  CMP  AX,I14RErrHostCallInUse   ;If error, is it already resetting?
  JE  >W90                       ;If so, it's OK
W60:                             ;Error (Host is Busy)
  MOV  DX,NewDvcResetWait1       ;What to do when Delay is over
  MOV  AX,20                     ;Delay 20ms
  CALL StartOneTimeIntAXms       ;Do it
  JMP >W90                       ;Done
W70:                             ;Error
  MOV  NewExtDeviceError,AX      ;Store the Error Code
W75:                             ;Done - no Error
  AND  TSRFlags,(NOT Configing)  ;Mark as Done
W90:                             ;Done
  RETF

;------------------------------------------------------------------------------
;HANDLE A NEW DEVICE AFTER THE HOST HAS QUEUED THE RESET REQUEST
;Inputs:  AX = 0 if Device Reset was scheduled OK (ZF Set)
;            > 0 if Error (ZF Clear)
;              We will later receive HubCallEnumerated Call with Device Address
;         BL = Hub Info Index
;         BH = Port Number
;         CX = DX = 0
;Outputs: If OK, nothing
;         If Error, marks Hub Info Index as Bad Device
;Changes:
;NOTES: We mark the Device as Bad here, even though we don't really need to.
;       The Host will inform us a little bit later of the correct address,
;         be it a good address or a bad address, with a DeviceEnumerated
;         call.
;------------------------------------------------------------------------------
NewDvcReady:
  MOV  NewExtDeviceStage,70     ;Update Stage
  JZ  >R90                      ;If no Error, we're done
R70:                            ;Error
  MOV  NewExtDeviceStage,200    ;Update Stage
  MOV  NewExtDeviceError,AX     ;Store the Error Code
  MOV  AL,-1                    ;Set Address & Power to -1 (Bad Device)
  CALL SetAddress4Port          ;Set Address
  CALL SetPower4Port            ;Set Power
R90:                            ;Done
  AND  TSRFlags,(NOT Configing) ;Mark as done with Config
  RETF


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;SUPPORT CODE NEEDED TO PROCESS HUB PORT CHANGES
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;UPDATE THE PORT STATUS
;Inputs:   DS = ES = TSR Data Area
;         [SI] = Int 14 Request to use
;                 Filled with much appropriate data already
;                 (Host Index, Hub Address)
;         [DI] = Hub Info Pointer
;          BH  = Port Number to Get Info For
;          DX  = Far Call Address to call when done
;Outputs: CF = Clear if Request was sent OK
;              AX = 0
;            = Set if Error of some sort occured
;              AX = Error code associated with GetPortStatus Request
;Changes:
;NOTES: This actually gets called several times by other subroutines.
;       Because a Hub is a Remote Device, we need to query it in order
;         to find out what its current status is, and whether our last
;         request was successful or not.
;       This is the "common" routine used to do that.
;------------------------------------------------------------------------------
UpdatePortInfo:
  PUSH CX                              ;Save used registers
  MOV  CX,GetPortStatusReq             ;Copy
  CALL CopySetupReqToInt14SI           ;  Request Packet
  MOV  B [SI].I14RGetPortStatusPort,BH ;Store Port Number
  MOV  W [SI].I14RCallBackAddr[0],DX   ;Address to call when done
  MOV  W [SI].I14RDataAddress[0],DI    ;Where to store data
  ADD  W [SI].I14RDataAddress[0],(OFFSET DIPortStatus) ;Put Data Here
  CALL DoInt14CallAXSI                 ;Do it
  POP  CX                              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs:  BL = Hub Info Index, BH = Port Number
;         DS = ES = TSR Data area
;Outputs: [DI] = Hub Info Table entry
;         [SI] = Int14Request2
;                Data from Hub Info Table is copied into Int14 Request2
;                (Host Index & Device Address, EndPoint = 0, UserPktID = BX,
;                 Type = Control)
;------------------------------------------------------------------------------
CopyHubInfoToInt14:
  PUSH AX                            ;Save used registers
  CALL DIIndex2OffsetBL              ;Point at Hub Info Entry (DI)
  MOV  SI,Int14Request2              ;Point at Int14 Request Structure
  MOV  W [SI].I14RCallBackAddr[0],-1 ;Default Call Back Address
  MOV  [SI].I14RRequestType,I14RRTDoControl ;Default Type = Control
  MOV  AX,W [DI].DIHostIndex         ;Copy Host Index &
  MOV  W [SI].I14RHostIndex,AX       ;  Device (Hub) Address
  MOV  [SI].I14REndPoint,0           ;EndPoint 0
  MOV  [SI].I14RUserPktID,BX         ;User Packet ID
  POP  AX                            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET OR SET A DEVICE ADDRESS/POWER FROM/TO A HUB TABLE ENTRY
;Inputs:  ES = TSR Data Area
;         BL = Hub Info Index Number
;         BH = Port Number
;         If a Set, AL = Address/Power to Set
;Outputs: If a Get, AL = Address/Power from Table
;           ZF = Set if AL = 0 (Empty Entry)
;              = Clear if Valid Entry
;Changes:
;------------------------------------------------------------------------------
GetAddress4Port:
  PUSH CX,DX                          ;Save used registers
  XOR  CH,CH                          ;Mark as a Get
  MOV  DX,((OFFSET DIPort1Address)-1) ;Offset of Address
  JMP >P00                            ;Do it
;GetPower4Port:
;  PUSH CX,DX                          ;Save used registers
;  XOR  CH,CH                          ;Mark as a Get
;  MOV  DX,((OFFSET DIPort1Power)-1)   ;Offset of Power
;  JMP >P00                            ;Do it
SetAddress4Port:
  PUSH CX,DX                          ;Save used registers
  MOV  CH,-1                          ;Mark as a Set
  MOV  DX,((OFFSET DIPort1Address)-1) ;Offset of Address
  JMP >P00                            ;Do it
SetPower4Port:
  PUSH CX,DX                          ;Save used registers
  MOV  CH,-1                          ;Mark as a Set
  MOV  DX,((OFFSET DIPort1Power)-1)   ;Offset of Power
;  JMP >P00                            ;Do it
P00:
  PUSH BX,DI            ;Save used registers
  CALL DIIndex2OffsetBL ;Point at Hub Info Entry (DI)
  XOR  BL,BL            ;Convert Port Number
  XCHG BL,BH            ;  to a Word
  ADD  BX,DX            ;Add the Port Base Offset
  OR   CH,CH            ;Is it a Get?
  JNZ >P20              ;If not, do a Set
  MOV  AL,ES:[DI+BX]    ;Get the Address from the Table
  OR   AL,AL            ;Set return flag
  JMP >P90              ;Done
P20:                    ;It's a Set
  MOV  ES:[DI+BX],AL    ;Set the Table Entry
P90:                    ;Done
  POP  DI,BX            ;Restore used registers
  POP  DX,CX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE A ONE-TIME DELAY REQUEST (AX ms)
;Inputs:  DS:[SI] = Int 14 Request to use
;         AX      = Number of milliseconds to Delay
;         DX      = Far Call Address (Offset) to call when done
;Outputs: CF = Set if error of some sort (like Host not running)
;            = Clear if OK
;                Sends appropriate Request to the USB Host, which in turn
;                issue Far Call(s) to address DS:DX when the Delay is over
;Changes:
;------------------------------------------------------------------------------
StartOneTimeIntAXms:
  MOV  [SI].I14RRequestType,I14RRTDoInterrupt1T ;Request = One-time Interrupt
  MOV  [SI].I14RPeriodicity,AX       ;Set Periodicity
  MOV  W [SI].I14RCallBackAddr[0],DX ;Address to call when done
  CALL DoInt14CallSaveAllSI          ;Do it
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO PROCESS NOTIFICATIONS FROM THE HUB HARDWARE OR A HOST DRIVER
;  REGARDING DEVICE CHANGES
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;HANDLE A NOTIFICATION FROM THE HOST DRIVER FOR SOMETHING RELATED TO THE DEVICE
;Inputs:   DS = ES = TSR Data Area
;          AX  = Device Owner Call Code (various possibilities)
;         [BX] = Info Table Pointer (User Packet ID)
;          CX, DX depends on exact call type.  For many Hub-related calls:
;            CL = Hub Address
;            CH = Hub Port Number to send request to
;            DL = Hub Call Index (if Enable/Disable/Reset/Suspend/Resume)
;            DH = Host Index (if Enable/Disable/Reset/Suspend/Resume)
;Outputs: Depends on Call Type
;         Calls appropriate "subfunction" with [SI] pointed at Int14Request2,
;           and the Request initialized with HostIndex, DeviceAddress, Handle,
;           Flags, EndPoint, RequestType, and CallBackAddr
;Changes: Nearly all registers
;------------------------------------------------------------------------------
DvcOwnerFarCall:
  MOV  SI,Int14Request3              ;Point at Request Structure
  MOV  DI,BX                         ;Point DI at the Info Table Entry
  MOV  [SI].I14RUserPktID,BX         ;Default User Packet ID = Info Table Offset
  MOV  [SI].I14RRequestType,I14RRTDoControl ;Request Type = Control Packet
  MOV  W [SI].I14RCallBackAddr[0],-1 ;Do nothing when done
  MOV  BX,W [DI].DIHostIndex         ;Copy Host Index &
  MOV  W [SI].I14RHostIndex,BX       ;  Device Address
  MOV  [SI].I14RFlags,0              ;Default Direction = Out
  MOV  [SI].I14REndPoint,0           ;Default EndPoint = 0
  MOV  BX,OwnerCallFunctionTbl       ;Point at the Function Table
  CALL SearchByteToWordTbl           ;Look for the Function (in AL)
  JC  >H90                           ;If invalid function, quit
  CALL BX                            ;If OK, do it
H90:
  RETF

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST SAYING THAT A NEW DEVICE HAS BEEN ADDED
;Inputs:   DS = ES = TSR Data Area
;         [DI] = Info Table Pointer
;         [SI] = Int14Request Structure #3
;                HostIndex, DeviceAddress, & Handle copied
;                  from Hub Info Table to Int14 Structure
;                RequestType = DoControl
;                CallBackAddr = NullFarCall (Do nothing)
;                Flags = EndPoint = 0
;          CL  = Host Index
;          CH  = Device Address
;Outputs:  Int08Counter
;Changes:  Just sets Counter so that we look for a new Device soon using Int08
;------------------------------------------------------------------------------
DeviceAdded:
  CMP  Int08Counter,0 ;Disabled?
  JE  >A90            ;If so, quit
  MOV  Int08Counter,2 ;If not, look for a new Device right away
A90:                  ;Done
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST SAYING THAT A DEVICE HAS BEEN DISCONNECTED
;Inputs:   DS = ES = TSR Data Area
;         [DI] = Info Table Pointer
;         [SI] = Int14Request Structure #3
;                HostIndex, DeviceAddress, & Handle copied
;                  from Hub Info Table to Int14 Structure
;                RequestType = DoControl
;                CallBackAddr = NullFarCall (Do nothing)
;                Flags = EndPoint = 0
;          CL  = Host Index
;          CH  = Device Address
;Outputs:
;Changes: Removes Device from Configuration
;NOTES:   The Host Driver should automatically close the Periodic Interrupt
;         This is called if a REGISTERED Device has been disconnected.
;         This is also called when an Upstream device is Disconnected
;------------------------------------------------------------------------------
DeviceDisconnected:
  CALL ResetDvcEntryDI ;Delete entry from our table
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST SAYING THAT AN UNREGISTERED DEVICE IS DISCO'D
;Inputs:   DS = ES = TSR Data Area
;         [DI] = Info Table Pointer
;         [SI] = Int14Request Structure #3
;                HostIndex, DeviceAddress, & Handle copied
;                  from Hub Info Table to Int14 Structure
;                RequestType = DoControl
;                CallBackAddr = NullFarCall (Do nothing)
;                Flags = EndPoint = 0
;          CL  = Host Index
;          CH  = Device Address
;Outputs:
;Changes:
;NOTES: This is called if an UNREGISTERED Device has been disconnected,
;         so it will NOT be in DeviceInfoTable.  It may or may not be
;         in the BadDeviceTable.
;------------------------------------------------------------------------------
Device0Disconnected:
  CALL DeleteBadDevices ;Delete the Entries from Bad Device Table (Uses CX)
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST TO TEMPORARILY STOP LOOKING FOR DEVICES
;Inputs:   DS = ES = TSR Data Area
;         [DI] = Info Table Pointer
;         [SI] = Int14Request Structure #3
;                HostIndex, DeviceAddress, & Handle copied
;                  from Hub Info Table to Int14 Structure
;                RequestType = DoControl
;                CallBackAddr = NullFarCall (Do nothing)
;                Flags = EndPoint = 0
;          CL  = Host Index
;          CH  = Device Address
;          DL  = Interface Number
;          DH  = TimeOut Value to use (deciseconds)
;Outputs: DontLookCounter
;Changes:
;NOTES: This should only be called if a Device-specific Driver is trying
;         to take control of an already registered device from us.
;       We actually stop looking for ALL new Interfaces, rather than just
;         the one that is being requested.
;------------------------------------------------------------------------------
StartDontLook:
  PUSH AX,BX,DX           ;Save used registers
  MOV  DontLookCounter,-1 ;Start not looking
  CALL RlsDvcNoResetDI    ;Release the Device, don't Reset it
  MOV  AL,DH              ;Put deciseconds in AL
  XOR  AH,AH              ;Multiply
  MOV  BX,18206           ;  deciseconds
  MUL  BX                 ;  by
  MOV  BX,10000           ;  1.8206
  DIV  BX                 ;  (number of timer ticks per decisecond)
  CMP  DX,5000            ;Do we need to round up?
  JB  >S90                ;If not, continue
  INC  AX                 ;If so, round up
S90:                      ;Done
  INC  AX                 ;Add one more Timer Tick for good measure
  MOV  DontLookCounter,AX ;Store the Counter Value
  POP  DX,BX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM A HOST SAYING THAT IT'S BEEN UNINSTALLED
;Inputs:   DS = ES = TSR Data Area
;         [DI] = Info Table Pointer
;         [SI] = Int14Request Structure #3
;                HostIndex, DeviceAddress, & Handle copied
;                  from Hub Info Table to Int14 Structure
;                RequestType = DoControl
;                CallBackAddr = NullFarCall (Do nothing)
;                Flags = EndPoint = 0
;          CL  = USB Host Index that isn't there any more
;Outputs:
;Changes: Removes appropriate Host Index & Devices from Tables
;------------------------------------------------------------------------------
HostDisconnected:
  PUSH BX,DI                    ;Save used registers
  MOV  DI,DeviceInfoTable       ;Point at table
  MOV  BL,MaxDevices            ;Number of table entries
D20:                            ;Loop to here for each table entry
  TEST [DI].DIFlags,DIFlagInUse ;Empty Table Entry?
  JZ  >D40                      ;If so, skip it
  CMP  [DI].DIHostIndex,CL      ;Is it the Host this Device is on?
  JNE >D40                      ;If not, skip it
  CALL ResetDvcEntryDI          ;If so, delete it from the Info Table
D40:                            ;Done with this table entry
  ADD  DI,DeviceInfoStrucSize   ;Point at the next Table Entry
  DEC  BL                       ;Decrement loop counter
  JNZ  D20                      ;If not done yet, keep looking
  POP  DI,BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE VARIOUS REQUESTS FROM THE USB HOST DRIVER ABOUT UPSTREAM CHANGES
;Inputs:   DS = ES = TSR Data Segment
;          Other registers: Depends on Call
;Outputs:
;Changes: We don't care about any of these calls, since they don't directly
;           affect our program.  Any critical changes to upstream devices
;           are eventually reflected to us as a call directly addressing
;           one of our Devices, which is how we handle those things.
;------------------------------------------------------------------------------
DeviceEnabled:        ;Device Enabled
DeviceDisabled:       ;Device Disabled
DeviceReset:          ;Device Reset
DeviceSuspend:        ;Device Suspended
DeviceResume:         ;Device Resumed
DevicePowerOn:        ;Device Power On
DevicePowerOff:       ;Device Power Off
DevicePowerReset:     ;Device Power Reset
NewHostAdded:         ;New Host Added
HostHWErr:            ;Host System/Processor Error
HostRun:              ;Host Running
HostStop:             ;Host Stopped
HostReset:            ;Host Reset
HostSuspend:          ;Host Suspended
HostResume:           ;Host Resumed
HostDebug:            ;Host in Debug Mode
HostSST:              ;Host Single-Stepped
TimingChange:         ;Host Timing Change
DeviceDisconnectedUS: ;Device Disconnect Upstream
DeviceEnabledUS:      ;Device Enable Upstream
DeviceDisabledUS:     ;Device Disable Upstream
DeviceResetUS:        ;Device Reset Upstream
DeviceSuspendUS:      ;Device Suspend Upstream
DeviceResumeUS:       ;Device Resume Upstream
DevicePowerOnUS:      ;Device Power On Upstream
DevicePowerOffUS:     ;Device Power Off Upstream
DevicePowerResetUS:   ;Device Power Reset Upstream
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;SUPPORT CODE TO RELEASE/RESET A DEVICE
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;COMPLETELY RELEASE A DEVICE THAT WE CURRENTLY OWN (POSSIBLY INCLUDING A RESET)
;Inputs:   DS = ES = TSR Data Area
;         [DI] = Device Info Entry to Release
;         [SI] = Int 14 Request to use
;Outputs: Releases Device Entry
;           Closes Periodic Handle
;           Unregisters as Interface Owner
;           Resets Device (if appropriate)
;           Resets Device Info Entry
;Changes:
;------------------------------------------------------------------------------
RlsDvcNoResetDI:
  PUSH BX                            ;Save used registers
  XOR  BL,BL                         ;Mark as No Reset
  JMP >R00                           ;Do it
RlsDvcDoResetDI:
  PUSH BX                            ;Save used registers
  MOV  BL,-1                         ;Mark as a Reset
;  JMP >R00                           ;Do it
R00:
  PUSH AX                            ;Save used registers
  MOV  W [SI].I14RCallBackAddr[0],-1 ;Set CallBackAddr to nothing
  MOV  AX,W [DI].DIHostIndex         ;Copy Host Index and
  MOV  W [SI].I14RHostIndex,AX       ;  Device Address
  MOV  AX,[DI].DIIntHandle           ;Copy
  MOV  [SI].I14RRequestHandle,AX     ;  Interrupt Handle Number
  MOV  [SI].I14RRequestType,I14RRTCloseHandle ;Request = Close Handle
  CALL DoInt14CallSaveAllSI          ;Do it
  MOV  AX,[DI].DIRegHandle           ;Copy
  MOV  [SI].I14RRequestHandle,AX     ;  Registry Handle
  MOV  [SI].I14RRequestType,I14RRTUnRegIntfOwner ;Request = UnRegister
  CALL DoInt14CallSaveAllSI          ;Do it
  OR   BL,BL                         ;Need to Reset the Device?
  JZ  >R80                           ;If not, we're done
  MOV  [SI].I14RRequestType,I14RRTResetDevice ;Request = Reset
  CALL DoInt14CallSaveAllSI          ;Do it
R80:                                 ;Done with Host
  CALL ResetDvcEntryDI               ;Delete the Device Info Entry
  POP  AX                            ;Restore used registers
  POP  BX                            ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CALLS BELOW HERE ARE ONLY CALLS TO HUB DRIVERS.  OTHER TYPES OF DEVICES
;   DO NOT RECEIVE THEM.
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;The Host Driver should never even try to send a power-control request
;  to a Hub that does not support per-port-power switching.  We'll
;  check for it anyway, and if we do get called but do not support
;  Per-Port-Power-Switching, we'll simply return an error.

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST FOR AN ENUMERATED DEVICE
;Inputs:   DS = ES = TSR Data Segment
;         [SI] = Int 14 Structure #3 (Filled In)
;         [DI] = Info Table Pointer
;          CL  = Hub Address
;          CH  = Port Number
;          DL  = Host Index
;          DH  = New Device Address (-1 if Bad Device)
;Outputs: Adds/Updates Table Entry
;Changes: AX, BX, CX, DX
;------------------------------------------------------------------------------
DeviceEnumerated:
  MOV  NewExtDeviceStage,200     ;Stage 200
  MOV  BL,CH                     ;Put Port Number
  XOR  BH,BH                     ;  in BX
  MOV  B [DI+BX+((OFFSET DIPort1Address)-1)],DH ;Store the New Address
  CMP  DH,-1                     ;Bad Device?
  JNE >E10                       ;If not, continue
  MOV  AL,DH                     ;If so, Power = -1 also
  JMP >E50                       ;Jump to store it
E10:                             ;Valid Address
  MOV  [SI].I14RRequestType,I14RRTGetDvcPowerInfo ;Request = Get Power Info
  MOV  [SI].I14RDeviceAddress,DH ;Address to get it for
  MOV  AX,BX                     ;Save Port Number
  CALL DoInt14CallBXSI           ;Do it
  SHR  BX,1                      ;Divide Power by 2
  XCHG BX,AX                     ;Power in AL, Port # in BX
E50:                             ;AL contains Power
  MOV  B [DI+BX+((OFFSET DIPort1Power)-1)],AL ;Store Power
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST TO ENABLE/DISABLE/SUSPEND/RESUME/RESET A DEVICE
;Inputs:  [SI] = Int 14 Structure #3 (Filled In)
;         [DI] = Info Table Pointer
;          CH  = Port Number
;          DL  = Host Hub Call Index (returned to Host when we're done)
;          DH  = 0
;Outputs: Begins Enable Process
;Changes: AX, BX, CX, DX
;------------------------------------------------------------------------------
EnableDevice:
  MOV  AL,HCTypeEnable   ;Type = Enable
  JMP >D00               ;Do it
DisableDevice:
  MOV  AL,HCTypeDisable  ;Type = Disable
  JMP >D00               ;Do it
ResetDevice:
  MOV  AL,HCTypeReset    ;Type = Reset
  JMP >D00               ;Do it
SuspendDevice:
  MOV  AL,HCTypeSuspend  ;Type = Suspend
  JMP >D00               ;Do it
ResumeDevice:
  MOV  AL,HCTypeResume   ;Type = Resume
  JMP >D00               ;Do it
PowerOnDevice:
  MOV  AL,HCTypePwrOn    ;Type = Power On
  JMP >D00               ;Do it
PowerOffDevice:
  MOV  AL,HCTypePwrOff   ;Type = Power Off
  JMP >D00               ;Do it
PowerResetDevice:
  MOV  AL,HCTypePwrReset ;Type = Power Reset
;  JMP >D00               ;Do it
D00:
  CALL HubCallSetup1     ;Setup Pointers (BX, DI, SI)
  MOV  DX,XDeviceStatus0 ;Where to go when done
  CALL HubCallGetStatus  ;Get current Status of Device
  RET

;------------------------------------------------------------------------------
;Inputs:  [BX] = Hub Call Table Offset
;Here after initial Get Status Request
;------------------------------------------------------------------------------
XDeviceStatus0:
  CALL HubCallSetup2             ;Setup Pointers (BX, DI, SI, CH, AL)
  JNZ >Z701                      ;If error, quit
  MOV  DX,W [BX].HCPortData[0]   ;Get Port Status Data
  CMP  AL,HCTypePwrReset         ;Power Reset?
  JE  >Z35                       ;If so, jump to handle it
  CMP  AL,HCTypePwrOff           ;Power Off?
  JE  >Z30                       ;If so, jump to handle it
  CMP  AL,HCTypePwrOn            ;Power On?
  JE  >Z25                       ;If so, jump to handle it
  CMP  AL,HCTypeResume           ;Resume?
  JE  >Z20                       ;If so, jump to handle it
  CMP  AL,HCTypeSuspend          ;Suspend?
  JE  >Z15                       ;If so, jump to handle it
  CMP  AL,HCTypeReset            ;Reset?
  JE  >Z10                       ;If so, jump to handle it
  CMP  AL,HCTypeDisable          ;Disable?
  JE  >Z05                       ;If so, jump to handle it
Z02:                             ;Enable
  TEST DL,DIPStEnabled           ;Already Enabled?
  JNZ >Z801                      ;If so, we're done
  MOV  CL,HFPortEnable           ;CL = Port Feature to Set
  JMP >Z40                       ;Jump to do it
Z05:                             ;Disable
  TEST DL,DIPStEnabled           ;Already Disabled?
  JZ  >Z801                      ;If so, we're done
  MOV  CL,HFPortEnable           ;CL = Port Feature to Clear
  JMP >Z50                       ;Jump to do it
Z10:                             ;Reset
  TEST DL,DIPStEnabled           ;Already Disabled?
  JZ  >Z12                       ;If so, continue
  MOV  CL,I14RRTDisableHubPort   ;Need to Disable the Device
  JMP >Z60                       ;Jump to do it
Z12:                             ;Already Disabled for Reset
  MOV  CL,HFPortReset            ;CL = Feature to Set
  JMP >Z40                       ;Jump to do it
Z15:                             ;Suspend
  TEST DL,DIPStEnabled           ;Is it Enabled?
  JZ  >Z70                       ;If not, Error
  TEST DL,DIPStSuspended         ;Already Suspended?
  JNZ >Z801                      ;If so, we're done
  MOV  CL,HFPortSuspend          ;CL = Port Feature to Set
  JMP >Z40                       ;Jump to do it
Z20:                             ;Resume
  TEST DL,DIPStSuspended         ;Currently Suspended?
  JZ  >Z70                       ;If not, Error
  MOV  CL,HFPortSuspend          ;CL = Port Feature to Clear
  JMP >Z50                       ;Jump to do it
Z25:                             ;Power On
  TEST [DI].DIFlags,DIFlagHubPPP ;Is the Hub even Per-Port-Powered?
  JZ  >Z70                       ;If not, Error
  TEST DH,(DIPStPowered SHR 8)   ;Already Powered On?
  JNZ >Z801                      ;If so, we're done
  MOV  CL,HFPortPower            ;CL = Port Feature to Set
  JMP >Z40                       ;Jump to do it
Z701:                            ;To avoid JMP > 128
  JMP >Z70
Z801:                            ;To avoid JMP > 128
  JMP >Z80
Z901:                            ;To avoid JMP > 128
  JMP >Z90
Z30:                             ;Power Off
  TEST [DI].DIFlags,DIFlagHubPPP ;Is the Hub even Per-Port-Powered?
  JZ  >Z70                       ;If not, Error
  TEST DH,(DIPStPowered SHR 8)   ;Already Powered Off?
  JZ  >Z80                       ;If so, we're done
  MOV  CL,HFPortPower            ;CL = Port Feature to Clear
  JMP >Z50                       ;Jump to do it
Z35:                             ;Power Reset
  TEST [DI].DIFlags,DIFlagHubPPP ;Is the Hub even Per-Port-Powered?
  JZ  >Z70                       ;If not, Error
  MOV  CL,HFPortPower            ;CL = Port Feature to Clear
  JMP >Z50                       ;Jump to do it
Z40:                             ;Need to Set a Feature (in CL)
  MOV  DX,XDeviceFtrDone         ;Where to to when done
  CALL HubCallSetFtr             ;Do it
  JMP >Z90                       ;Done
Z50:                             ;Need to Clear a Feature (in CL)
  MOV  DX,XDeviceFtrDone         ;Where to to when done
  CALL HubCallClearFtr           ;Do it
  JMP >Z90                       ;Done
Z60:                             ;Need to do another Sub-Call (in CL)
  MOV  DX,XDeviceSubCallDone     ;Where to go when done
  CALL HubCallSubCall            ;Do it
  JMP >Z90                       ;Done
Z70:                             ;Error
  CALL FinishHubCallErr          ;Tell Host that we're done
  JMP >Z90                       ;Done
Z80:                             ;OK
  CALL FinishHubCallOK           ;Tell Host that we're done
Z90:                             ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BX = Hub Call Table Offset
;Here after Disabling for a Reset
;------------------------------------------------------------------------------
XDeviceSubCallDone:
  CALL HubCallSetup2     ;Setup Pointers (BX, DI, SI, CH, AL)
  JNZ >U70               ;If Error from last Call, Error
  MOV  DX,XDeviceFtrDone ;Where to go when done
  MOV  CL,HFPortReset    ;CL = Feature to Set
  CALL HubCallSetFtr     ;Do it
  JMP >U90               ;Done
U70:                     ;Error
  CALL FinishHubCallErr  ;Tell Host that we're done
U90:                     ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BX = Hub Call Table Offset
;Here after issuing Change Port Feature Request (all Request Types)
;------------------------------------------------------------------------------
XDeviceFtrDone:
  CALL HubCallSetup2          ;Setup Pointers (BX, DI, SI, CH, AL)
  JNZ >F70                    ;If Error from previous Call, handle it
  MOV  CL,HFPortEnableChange  ;Assume Enable or Disable
  CMP  AL,HCTypeDisable       ;Is it Enable or Disable?
  JBE >F40                    ;If so, jump to handle it
  MOV  CL,HFPortSuspendChange ;Assume Suspend
  CMP  AL,HCTypeSuspend       ;Is it Suspend?
  JE  >F40                    ;If so, jump to handle it
  CMP  AL,HCTypeReset         ;Is it Reset?
  JE  >F50                    ;If so, jump to handle it
  CMP  AL,HCTypeResume        ;Is it Resume?
  JE  >F50                    ;If so, jump to handle it
  CMP  AL,HCTypePwrReset      ;Is it Power Reset?
  JE  >F60                    ;If so, jump to handle it
  JMP >F80                    ;If Power On or Power Off, it worked!
F40:                          ;Need to Clear Feature (CL)
  MOV  DX,XDeviceCleared      ;Where to go when done
  CALL HubCallClearFtr        ;Do it
  JMP >F90                    ;Done
F50:                          ;Need to wait for Reset/Resume to Happen
  MOV  DX,XDeviceResXWait0    ;Where to go when done
  MOV  AX,50                  ;Wait 50ms
                              ;  Hubs use internal timers, which are supposed
                              ;  to take no more than 20ms to complete a
                              ;  Resume or a Reset.  After the call
                              ;  is done, we need to wait at least another
                              ;  10ms for the Bus to stabilize.
  CALL StartOneTimeIntAXms    ;Do it
  JNC >F90                    ;If it worked, we're done
  JMP >F70                    ;If not, Error
F60:                          ;Power Reset
  MOV  DX,XDevicePwrWait0     ;Where to go when Done
  MOV  AX,250                 ;Wait 250ms
  CALL StartOneTimeIntAXms    ;Do it
  JNC >F90                    ;If it worked, we're done
;  JMP >F70                    ;If not, Error
F70:                          ;Error
  CALL FinishHubCallErr       ;Tell Host that we're done
  JMP >F90                    ;Done
F80:                          ;OK
  CALL FinishHubCallOK        ;Tell Host that we're done
F90:                          ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs:  BX = Hub Call Table Offset
;Here after Enable, Disable, or Suspend with Change Cleared,
;  or after Power Reset is completed
;------------------------------------------------------------------------------
XDeviceCleared:
  CALL HubCallSetup2    ;Setup Pointers (BX, DI, SI, CH, AL)
  JZ  >C80              ;If last Call worked, we're done
C70:                    ;Error
  CALL FinishHubCallErr ;Tell Host that we're done
  JMP >C90              ;Done
C80:                    ;OK
  CALL FinishHubCallOK  ;Tell Host that we're done
C90:                    ;Done
  RETF

;------------------------------------------------------------------------------
;Power Reset
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
;Inputs:  BX = Hub Call Table Offset
;Here after Power Reset wait period (after powered off for 100ms)
;------------------------------------------------------------------------------
XDevicePwrWait0:
  CALL HubCallSetup2     ;Setup Pointers (BX, DI, SI, CH, AL)
  MOV  CL,HFPortPower    ;CL = Port Feature to Set
  MOV  DX,XDeviceCleared ;Where to go when done
  CALL HubCallSetFtr     ;Send the Request
  RETF

;------------------------------------------------------------------------------
;Resume & Reset
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
;Inputs:  BX = Hub Call Table Offset
;Here after Reset/Resume issued, and 50ms wait period (long enough for
;  the Reset/Resume to have been completed!).
;------------------------------------------------------------------------------
XDeviceResXWait0:
  CALL HubCallSetup2          ;Setup Pointers (BX, DI, SI, CH, AL)
  MOV  CL,HFPortResetChange   ;Assume Reset
  CMP  AL,HCTypeReset         ;Is it Reset?
  JE  >S20                    ;If so, continue
  MOV  CL,HFPortSuspendChange ;If no, it's a Resume
S20:                          ;Reset
  MOV  DX,XDeviceResXCleared  ;Go here when Done
  CALL HubCallClearFtr        ;Clear the Feature
  RETF

;------------------------------------------------------------------------------
;Inputs:  BX = Hub Call Table Offset
;NOTES: This one is only called by Resumes & Resets.
;       We do not need to wait on Enables, Disables, or Suspends
;------------------------------------------------------------------------------
XDeviceResXCleared:
  CALL HubCallSetup2       ;Setup Pointers (BX, DI, SI, CH, AL)
  JNZ >C70                 ;If Error from previous Call, handle it
  MOV  DX,XDeviceResXDone  ;Where to go when done
  MOV  AX,10               ;Wait 10ms
  CALL StartOneTimeIntAXms ;Do it
  JNC >C90                 ;If it worked, we're done
C70:                       ;Error
  CALL FinishHubCallErr    ;Tell Host that we're done
C90:                       ;Done
  RETF

;------------------------------------------------------------------------------
;Done!!
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
;Inputs:  BX = Hub Call Table Offset
;Here after Reset or Resume is completed
;------------------------------------------------------------------------------
XDeviceResXDone:
  CALL HubCallSetup2   ;Setup Pointers (BX, DI, SI, CH, AL)
  CALL FinishHubCallOK ;Tell Host that we're done
  RETF

;------------------------------------------------------------------------------
;CONVERT A HOST INDEX OFFSET TO AN INDEX
;Inputs:  DI = Offset to calculate
;Outputs: CL = Index
;Changes:
;------------------------------------------------------------------------------
DIOffset2Index:
  PUSH AX,BX,DX               ;Save used registers
  MOV  AX,DI                  ;Subtract out the offset
  SUB  AX,DeviceInfoTable     ;  of the beginning of the table
  XOR  DX,DX                  ;Divide by the
  MOV  BX,DeviceInfoStrucSize ;  size of each
  DIV  BX                     ;  table entry
  MOV  CL,AL                  ;Put it in CL for the return
  POP  DX,BX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SCHEDULE A HUB CALL SET PORT FEATURE TRANSACTION ON THE USB BUS
;Inputs:   CH  = Port Number
;          CL  = Feature to Set
;          DX  = Address to Call When Done
;         [SI] = Int 14 Request to use
;Outputs: CF = Clear if OK
;              Control Transaction is scheduled on the Bus
;            = Set if Error
;              Automatically calls FinishHubCall with Error Code
;Changes:
;------------------------------------------------------------------------------
HubCallSetFtr:
  PUSH CX                               ;Save used registers
  MOV  W [SI].I14RCallBackAddr[0],DX    ;Store Call Back Address
  PUSH CX                               ;Save Port and Feature
  MOV  CX,SetPortFeatureReq             ;Copy the
  CALL CopySetupReqToInt14SI            ;  Setup Request
  POP  CX                               ;Restore Port and Feature
  MOV  B [SI].I14RSetPortFeatureFtr,CL  ;Store Feature Code
  MOV  B [SI].I14RSetPortFeaturePort,CH ;Store Port Number
  CALL DoInt14CallAXSI                  ;Do it
  JNC >S80                              ;If it worked, we're done
S70:                                    ;Error
  CALL FinishHubCallErr                 ;Tell Host that we're done
  STC                                   ;Set Error Flag
  JMP >S90                              ;Done
S80:                                    ;OK
  CLC                                   ;Set OK Flag
S90:                                    ;Done
  POP  CX                               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SCHEDULE A HUB CALL CLEAR PORT FEATURE TRANSACTION ON THE USB BUS
;Inputs:   CH  = Port Number
;          CL  = Feature to Clear
;          DX  = Address to Call When Done
;         [SI] = Int 14 Request to use
;Outputs: CF = Clear if OK
;              Control Transaction is scheduled on the Bus
;            = Set if Error
;              Automatically calls FinishHubCall with Error Code
;Changes:
;------------------------------------------------------------------------------
HubCallClearFtr:
  PUSH CX                                 ;Save used registers
  MOV  W [SI].I14RCallBackAddr[0],DX      ;Store Call Back Address
  PUSH CX                                 ;Save Port and Feature
  MOV  CX,ClearPortFeatureReq             ;Copy the
  CALL CopySetupReqToInt14SI              ;  Setup Request
  POP  CX                                 ;Restore Port and Feature
  MOV  B [SI].I14RClearPortFeatureFtr,CL  ;Store Feature Code
  MOV  B [SI].I14RClearPortFeaturePort,CH ;Store Port Number
  CALL DoInt14CallSaveAllSI               ;Do it
  JNC >S80                                ;If it worked, we're done
S70:                                      ;Error
  CALL FinishHubCallErr                   ;Tell Host that we're done
  STC                                     ;Set Error Flag
  JMP >S90                                ;Done
S80:                                      ;OK
  CLC                                     ;Set OK Flag
S90:                                      ;Done
  POP  CX                                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SCHEDULE A HUB CALL GET PORT STATUS TRANSACTION ON THE USB BUS
;Inputs:   CH  = Port Number
;          DX  = Address to Call When Done
;         [SI] = Int 14 Request to use
;         [BX] = Hub Call Table Entry (where to put Data)
;Outputs: CF = Clear if OK
;              Control Transaction is scheduled on the Bus
;            = Set if Error
;              Automatically calls FinishHubCall with Error Code
;Changes:
;------------------------------------------------------------------------------
HubCallGetStatus:
  PUSH CX,DX                           ;Save used registers
  MOV  W [SI].I14RCallBackAddr[0],DX   ;Store Call Back Address
  LEA  DX,[BX].HCPortData              ;Calculate and Store
  MOV  W [SI].I14RDataAddress[0],DX    ;  Data Address Offset
  PUSH CX                              ;Save Port Number
  MOV  CX,GetPortStatusReq             ;Copy the
  CALL CopySetupReqToInt14SI           ;  Setup Request
  POP  CX                              ;Restore Port Number
  MOV  B [SI].I14RGetPortStatusPort,CH ;Store Port Number
  CALL DoInt14CallSaveAllSI            ;Do it
  JNC >S80                             ;If it worked, we're done
S70:                                   ;Error
  CALL FinishHubCallErr                ;Tell Host that we're done
  STC                                  ;Set Error Flag
  JMP >S90                             ;Done
S80:                                   ;OK
  CLC                                  ;Set OK Flag
S90:                                   ;Done
  POP  DX,CX                           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SCHEDULE A HUB SUB-CALL (ISSUE ANOTHER HUB/PORT REQUEST)
;Inputs:   CH  = Port Number
;          CL  = Request Type
;          DX  = Address to Call When Done
;         [SI] = Int 14 Request to use
;         [BX] = Hub Call Table Entry (where to put Data)
;Outputs: CF = Clear if OK
;              Control Transaction is scheduled on the Bus
;            = Set if Error
;              Automatically calls FinishHubCall with Error Code
;Changes:
;------------------------------------------------------------------------------
HubCallSubCall:
  MOV  W [SI].I14RCallBackAddr[0],DX ;Store Call Back Address
  MOV  [SI].I14RRequestType,CL       ;Store Request Type
  MOV  [SI].I14RHubPort,CH           ;Store Port Number
  CALL DoInt14CallSaveAllSI          ;Do it
  JNC >C80                           ;If it worked, we're done
C70:                                 ;Error
  CALL FinishHubCallErr              ;Tell Host that we're done
  STC                                ;Set Error Flag
  JMP >C90                           ;Done
C80:                                 ;OK
  CLC                                ;Set OK Flag
C90:                                 ;Done
  RET

;------------------------------------------------------------------------------
;SETUP POINTERS FOR "PRIMARY" HUB CALL PROCESSES
;Inputs:   DS  = ES = TSR Data Area
;          DI  = Hub Info Offset to Store
;          AL  = HC Type to store
;          CL  = Hub Address (don't really care about that)
;          CH  = Port Number to Store
;          DX  = Host Index Value to Store
;         [SI] = Int14Request3
;Outputs: CF = Clear if OK
;              [BX] = Table Entry to use (filled in)
;              [SI] = New Int 14 Request to use
;            = Set if Error
;              [BX] = Undefined
;               SI  = Unchanged
;         Stores BX as UserPktID in [SI] (Int14Structure)
;Changes:
;------------------------------------------------------------------------------
HubCallSetup1:
  PUSH CX                  ;Save used registers
  PUSHF                    ;Save Flags
  XOR  CL,CL               ;Start with Index 0
  MOV  BX,HubCallTable     ;Point at Table
  CLI                      ;Disable Interrupts
A10:                       ;Loop to here for each Interface
  CMP  [BX].HCDIOffset,0   ;Entry already used?
  JE  >A80                 ;If not, we're done
  ADD  BX,HubCallStrucSize ;If so, point at the next entry
  INC  CL                  ;Increment the Index
  CMP  CL,HCEntries        ;At the end of the Table yet?
  JB   A10                 ;If not keep looking
A70:                       ;Error
  POPF                     ;Restore Flags
  STC                      ;Set Error Flag
  JMP >A90                 ;Done
A80:                       ;OK
  INC  HubCallsInProg      ;Mark Hub Call as in Progress
  MOV  [BX].HCDIOffset,DI  ;Store Hub Info Table Offset
  MOV  [BX].HCPortNum,CH   ;Store Port Number
  MOV  [BX].HCHostIndex,DX ;Store Host Call Index
  MOV  [BX].HCType,AL      ;Store HC Type
  CALL HubCallSetup2       ;Fill in the INT 14 Request with base data
  POPF                     ;Restore Flags
  CLC                      ;Set OK Flag
A90:                       ;Done
  POP  CX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SETUP POINTERS FOR "SECONDARY" HUB CALL PROCESSES
;Inputs:  [BX] = Hub Call Offset to Use
;Outputs: [SI] = Int 14 Request, filled in
;         [DI] = HubInfo Entry to use
;          CH  = Port Number
;          AL  = [BX].HCType
;Changes:
;NOTES: This MUST preserve Flags!
;------------------------------------------------------------------------------
HubCallSetup2:
  LEA  SI,[BX].HCInt14Request        ;Point SI at Request Structure
  MOV  DI,[BX].HCDIOffset            ;Point DI at Device Info Table
  MOV  CH,[BX].HCPortNum             ;CH = Port Number
  MOV  [SI].I14RUserPktID,BX         ;UserPktID = Hub Call Index
  MOV  [SI].I14RRequestType,I14RRTDoControl ;Request Type = Control Packet
  MOV  W [SI].I14RCallBackAddr[0],-1 ;Do nothing when done
  MOV  AX,W [DI].DIHostIndex         ;Copy Host Index &
  MOV  W [SI].I14RHostIndex,AX       ;  Device Address
  MOV  [SI].I14RFlags,0              ;Direction = Out
  MOV  [SI].I14REndPoint,0           ;EndPoint = 0
  MOV  AL,[BX].HCType                ;AL = HCType (Feature Type)
  RET

;------------------------------------------------------------------------------
;FINISH UP A HUB CALL (TELL HOST DRIVER THAT IT IS COMPLETED)
;Inputs:  DS = ES = TSR Data Area
;         [SI] = Int14Request Structure to use (already filled in)
;         [BX] = Hub Call Table Entry (contains Host Handle Number to return)
;Outputs: Informs Host Driver that the Hub Call is Complete
;         Resets Hub Call Structure to 0
;Changes:
;------------------------------------------------------------------------------
FinishHubCallOK:
  PUSH AX                             ;Save used registers
  XOR  AX,AX                          ;Error Code = 0
  JMP >F00                            ;Do it
FinishHubCallErr:
  PUSH AX                             ;Save used registers
  MOV  AX,TDStsLargeCallErr           ;Error Code = Hub Call Problem
;  JMP >F00                            ;Do it
F00:
  MOV  [SI].I14RRequestType,I14RRTLargeCallDone ;Request Type = Long Call Done
  MOV  W [SI].I14RLargeCallRtnCode,AX ;Return Code = AX
  MOV  AX,W [BX].HCHostIndex          ;Put the Host Index
  MOV  [SI].I14RRequestHandle,AX      ;  into the Int 14 Request
  CALL DoInt14CallSaveAllSI           ;Tell the Host we're done
  MOV  [BX].HCDIOffset,0              ;Reset the Hub Call Entry
  DEC  HubCallsInProg                 ;Mark Hub Call as completed
  POP  AX                             ;Restore used Registers
  RET

;;------------------------------------------------------------------------------
;;MARK A DEVICE (PORT) AS NO LONGER ATTACHED
;;Inputs:  [DI] = Hub Info Table Entry
;;          CH  = Port Number
;;Outputs: Marks Device as no longer there
;;Changes:
;;------------------------------------------------------------------------------
;MarkDeviceAsGone:
;  PUSH BX,CX                          ;Save used registers
;  MOV  BX,((OFFSET DIPort1Address)-1) ;Point at the Entry
;  MOV  CL,CH                          ;  in the
;  XOR  CH,CH                          ;  Hub Info Table
;  ADD  BX,CX                          ;  for this Device
;  MOV  B [DI+BX],0                    ;Mark the Device as gone
;  MOV  B [DI+BX+((OFFSET DIPort1Power)-(OFFSET DIPort1Address))],0
;  POP  CX,BX                          ;Restore used registers
;  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;SUPPORT CODE FOR DEVICE INFO TABLE
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;RESET A DEVICE INFO TABLE ENTRY
;Inputs:  DS = ES = TSR Data Area
;        [BX] or [DI] = Info Table Entry to reset
;         CLD already issued
;Outputs:
;Changes: Resets (clears out) Device Info Table Entry
;         Unlike most routines, this one preserves Flags across the Call!
;------------------------------------------------------------------------------
ResetDvcEntryBX:
  PUSH DI              ;Save used registers
  MOV  DI,BX           ;Point DI at the Table Entry
  CALL ResetDvcEntryDI ;Reset the Entry
  POP  DI              ;Restore used registers
  RET

ResetDvcEntryDI:
  PUSH AX,CX,DI ;Save used registers
  PUSHF         ;Save flags
  CLI           ;Disable interrupts
  XOR  AX,AX    ;Need to store zeroes
  MOV  CX,(DeviceInfoStrucSize/2) ;Number of words in table entry
  REP  STOSW    ;Reset the table
  POPF          ;Restore flags
  POP  DI,CX,AX ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO FIND/STORE ENTRIES IN VARIOUS STRUCTURE-BASED TABLES
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;CONVERT A DEVICE INFO INDEX TO AN OFFSET
;Inputs:  ES = Data Segment where data is located
;         CL = Device Index, or BL = Device Index (if DIIndex2OffsetBL)
;Outputs: DI = Offset to Table Entry (Assuming ES is the segment)
;Changes:
;------------------------------------------------------------------------------
DIIndex2OffsetBL:
  PUSH CX             ;Save used registers
  MOV  CL,BL          ;Put Index in CL
  CALL DIIndex2Offset ;Do it
  POP  CX             ;Restore used registers
  RET

DIIndex2Offset:
  PUSH AX,CX,DX               ;Save used registers
  XOR  CH,CH                  ;Index is actually a byte
  MOV  DI,DeviceInfoTable     ;Offset to beginning of Table
  MOV  AX,DeviceInfoStrucSize ;Size of each entry
  MUL  CX                     ;Multiply Index by the size of each entry
  ADD  DI,AX                  ;Add the offset of the beginning of the table
  POP  DX,CX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND AN EMPTY INFO TABLE ENTRY
;Inputs:  DS = ES = TSR Data Area
;Outputs: ZF = Clear if OK (found an empty Table entry)
;              [BX] = Table Entry
;            = Set if error (Table is full)
;               BX  = 0
;Changes:
;------------------------------------------------------------------------------
FindEmptyInfoBX:
  PUSH CX                       ;Save used registers
  MOV  BX,DeviceInfoTable       ;Point at first Table Entry
  MOV  CX,MaxDevices            ;Number of Table Entries
E10:                            ;Loop to here to find empty Table Entry
  TEST [BX].DIFlags,DIFlagInUse ;Empty Table entry?
  JZ  >E90                      ;If so, continue
  ADD  BX,DeviceInfoStrucSize   ;Point at next table entry
  LOOP E10                      ;Keep looking
  XOR  BX,BX                    ;Table is full!
E90:                            ;Done
  OR   BX,BX                    ;Set Return Flag
  POP  CX                       ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;SUPPORT CODE FOR BAD DEVICE TABLE
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;ADD A BAD (INCOMPATIBLE) DEVICE HOST & ADDRESS TO THE TABLE
;Inputs:  DS:[SI] = Int 14 Structure containing Bad Device Data (Host/Addr/Intf)
;Outputs: Adds Host & Address to Bad Device Table
;Changes:
;------------------------------------------------------------------------------
AddBadDevice:
  PUSH AX,BX,CX                 ;Save used registers
  PUSHF                         ;Save Flags
  CLI                           ;Disable Interrupts
  MOV  BX,BadDeviceTable        ;Point at Table
  MOV  CX,MaxBadDevices         ;Number of Entries in Table
A20:                            ;Loop here to find empty table entry
  TEST [BX].BDFlags,BDFlagInUse ;This entry already used?
  JNZ >A50                      ;If so, skip it
  OR   [BX].BDFlags,BDFlagInUse ;If not, mark it as used
  MOV  AX,W [SI].I14RHostIndex  ;Store the Host Index
  MOV  W [BX].BDHostIndex,AX    ;  & Device Address
  MOV  AL,[SI].I14RInterfaceNum ;Store the
  MOV  [BX].BDInterfaceNum,AL   ;  Interface Number
  MOV  AX,NewDeviceError        ;Store the
  MOV  [BX].BDNewDeviceError,AX ;  Error Code
  MOV  AL,NewDeviceStage        ;Store the
  MOV  [BX].BDNewDeviceStage,AL ;  New Device Stage
  JMP >A90                      ;Done
A50:                            ;Entry not Empty
  ADD  BX,BadDeviceStrucSize    ;Point at next entry
  LOOP A20                      ;Keep going until we're done
A90:                            ;Done
  POPF                          ;Restore Flags
  POP  CX,BX,AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DELETE BAD (INCOMPATIBLE) DEVICE HOSTS & ADDRESSES FROM THE TABLE
;Inputs:  CL = Host Index, CH = Address
;Outputs: Deletes Host & Address from Bad Device Table
;Changes:
;NOTES: This is called as the result a a Device Disconnect, so we need to
;         delete all Interfaces of the Device.  There will probably only
;         be one Entry per Address, but we need to check all of them.
;------------------------------------------------------------------------------
DeleteBadDevices:
  PUSH AX,BX,CX,DX,DI            ;Save used registers
  PUSHF                          ;Save Flags
  MOV  AX,CX                     ;AL = Host Index, AH = Device Address
  MOV  DL,-1                     ;Don't care about the Interface Number
  CLI                            ;Disable Interrupts
D10:                             ;Loop here for each Table Entry
  CALL FindBadDeviceEntry        ;Any entries in the Table (returns BX)?
  JC  >D90                       ;If not, we're done
  PUSH AX                        ;If so, save used registers
  XOR  AX,AX                     ;Write zeroes
  MOV  CX,(BadDeviceStrucSize/2) ;Number of words to write
  MOV  DI,BX                     ;Point DI at Table Entry
  REP  STOSW                     ;Write them
  POP  AX                        ;Restore used registers
  JMP  D10                       ;Keep looking for more Entries
D90:                             ;Done
  POPF                           ;Restore Flags
  POP  DI,DX,CX,BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COMPARE A HOST AND ADDRESS TO SEE IF IT'S IN OUR BAD DEVICE TABLE
;Inputs:  CL = Host, CH = Address, DL = Interface, DH = Alt Interface
;Outputs: CF = Set if it's not in the Bad Device Table
;            = Clear if it is in Table
;Changes:
;NOTES: This ignores the Alt Interface Setting (we don't care about it).
;------------------------------------------------------------------------------
TestBadDevice:
  PUSH AX,BX              ;Save used registers
  MOV  AX,CX              ;AL = Host Index, AH = Device Address
                          ;DL = Interface Number
  CALL FindBadDeviceEntry ;Is it in the Table (returns BX)?
  POP  BX,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND A MATCHING HOST/ADDRESS/INTERFACE ENTRY IN THE BAD DEVICE TABLE
;Inputs:  AL = Host Index to find
;         AH = Device Address to find
;         DL = Interface Number to find
;              if -1, we don't care about the Interface Number
;Outputs: CF = Clear if Entry Found
;              BX = Entry Offset
;            = Set if Entry not found
;              BX = Undefined
;Changes:
;------------------------------------------------------------------------------
FindBadDeviceEntry:
  PUSH CX                       ;Save used registers
  PUSHF                         ;Save flags
  MOV  BX,BadDeviceTable        ;Point at Table
  MOV  CX,MaxBadDevices         ;Number of Entries in Table
  CLI                           ;Disable Interrupts
E20:                            ;Loop here to find empty table entry
  TEST [BX].BDFlags,BDFlagInUse ;Valid Entry?
  JZ  >E50                      ;If not, skip it
  CMP  W [BX].BDHostIndex,AX    ;Do the Host Index & Device Address match?
  JNE >E50                      ;If not, skip it
  CMP  DL,-1                    ;Do we care about the Interface Number?
  JE  >E80                      ;If not, we've found it!
  CMP  [BX].BDInterfaceNum,DL   ;Does the Interface Number match?
  JE  >E80                      ;If so, we've found it!
E50:                            ;Go to next entry
  ADD  BX,BadDeviceStrucSize    ;Point at the next entry
  LOOP E20                      ;Keep looking
E70:                            ;Error
  POPF                          ;Restore Flags
  STC                           ;Set Not Found Flag
  JMP >E90                      ;Done
E80:                            ;OK
  POPF                          ;Restore Flags
  CLC                           ;Set Found Flag
E90:                            ;Done
  POP  CX                       ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO ISSUE INT 14h CALLS TO THE HOST DRIVER
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;ISSUE AN INT 14 CALL TO THE USB HOST
;Inputs:  DS:[DX] = Int 14 Request (filled with appropriate data)
;      OR DS:[DI]
;      OR DS:[SI]
;Outputs: CF = Set if error (host stalled, etc.)
;            = Clear if OK
;Changes: Sends the appropriate info to the USB Host via Int 14 call
;------------------------------------------------------------------------------
DoInt14CallSaveAllSI:       ;Save all changed registers
                            ;  [SI] = Int14 Structure
  PUSH DX                   ;Save used registers
  MOV  DX,SI                ;Point DX at the Data Offset
  CALL DoInt14CallSaveAllDX ;Do it
  POP  DX                   ;Restore used registers
  RET

DoInt14CallAXSI:     ;Save all changed registers except AX
                     ;  [SI] = Int14 Structure
  PUSH DX            ;Save used registers
  MOV  DX,SI         ;Point DX at the Data Offset
  CALL DoInt14CallAX ;Do it
  POP  DX            ;Restore used registers
  RET

DoInt14CallAXCXSI:     ;Save all changed registers except AX & CX
                       ;  [SI] = Int14 Structure
  PUSH DX              ;Save used registers
  MOV  DX,SI           ;Point DX at the Data Offset
  CALL DoInt14CallAXCX ;Do it
  POP  DX              ;Restore used registers
  RET

DoInt14CallBXSI:     ;Save all changed registers except BX
                     ;  [SI] = Int14 Structure
  PUSH DX            ;Save used registers
  MOV  DX,SI         ;Point DX at the Data Offset
  CALL DoInt14CallBX ;Do it
  POP  DX            ;Restore used registers
  RET

DoInt14CallCXDI:     ;Save all changed registers except CX
                     ;  [DI] = Int14 Structure
  PUSH DX            ;Save used registers
  MOV  DX,DI         ;Point DX at the Data Offset
  CALL DoInt14CallCX ;Do it
  POP  DX            ;Restore used registers
  RET

DoInt14CallCXDXSI:     ;Save all changed registers except CX & DX
                       ;  [SI] = Int14 Structure
  MOV  DX,SI           ;Point DX at the Data Offset
  CALL DoInt14CallCXDX ;Do it
  RET

DoInt14CallSaveAllDX: ;Save all changed registers
                      ;  [DX] = Int14 Structure
  PUSH AX,BX,CX,DX    ;Save registers that Int14 changes!
  CALL DoInt14Call    ;Do it
  POP  DX,CX,BX,AX    ;Restore used registers
  RET

DoInt14CallAX:
  PUSH BX,CX,DX    ;Save registers that Int14 changes, except AX!!
  CALL DoInt14Call ;Do it
  POP  DX,CX,BX    ;Restore used registers
  RET

DoInt14CallAXCX:
  PUSH BX,DX      ;Save registers that Int14 changes, except AX & CX
  CALL DoInt14Call ;Do it
  POP  DX,BX       ;Restore used registers
  RET

DoInt14CallBX:
  PUSH AX,CX,DX    ;Save registers that Int14 changes, except BX!!
  CALL DoInt14Call ;Do it
  POP  DX,CX,AX    ;Restore used registers
  RET

DoInt14CallCX:
  PUSH AX,BX,DX    ;Save registers that Int14 changes, except CX!!
  CALL DoInt14Call ;Do it
  POP  DX,BX,AX    ;Restore used registers
  RET

DoInt14CallCXDX:
  PUSH AX,BX       ;Save registers that Int14 changes, except CX & DX!!
  CALL DoInt14Call ;Do it
  POP  BX,AX       ;Restore used registers
  RET

;Int 14 returns various values in AX, BX, CX, & DX
DoInt14Call:
  STI           ;Enable Interrupts
  MOV  AX,5001h ;Set Function
  MOV  BX,'US'  ;Set
  MOV  CX,'B!'  ;  Registers
  STC           ;Preset Error Flag
  INT  14h      ;Do it
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO HANDLE INT 08h (Timer Tick)
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;HAVE INTERRUPT 08 (TIMER) RUN THIS EVERY TIME IT OCCURS
;Inputs:
;Outputs: Searches for Newly attached Devices
;Changes:
;------------------------------------------------------------------------------
Int08Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int08:
  PUSHF                          ;Call the
  CALL D CS:Int08Hdr.OldVector   ;  Old Interrupt Handler
  STI                            ;Enable interrupts
  CLD                            ;Go forward with string functions
  CALL MakeStack                 ;Set up our own Stack Space
  PUSH DI,SI,DS,ES               ;Save used registers
  MOV  DS,CS                     ;Point DS and
  MOV  ES,CS                     ;  ES at our data area
  MOV  DI,OFFSET Int08Counter    ;Point DI at Int08Counter
  MOV  SI,OFFSET DontLookCounter ;Point BX at DontLookCounter
  CMP  W [SI],0                  ;Need to Decrement DontLookCounter?
  JE  >E20                       ;If not, continue
  DEC  W [SI]                    ;If so, Decrement it
  JNZ >E90                       ;If not 0 yet, quit
  CMP  B [DI],0                  ;Disabled?
  JE  >E90                       ;If so, quit
  MOV  B [DI],1                  ;If not, look for Device right away
E20:                             ;Done with DontLookCounter
  CMP  B [DI],0                  ;Are we supposed to look yet?
  JE  >E90                       ;If not, just quit
  DEC  B [DI]                    ;Decrement the Delay Counter
  JNZ >E90                       ;If not 0 yet, quit
  MOV  B [DI],182                ;If 0, reset for next time (approx 10 seconds)
  PUSH AX,BX,CX,DX,BP            ;Save used registers
  CALL LookForNewDevice          ;Look for a new Device
  POP  BP,DX,CX,BX,AX            ;Restore used registers
E90:                             ;Done
  POP  ES,DS,SI,DI               ;Restore used registers
  CALL ReturnStack               ;Restore Original Stack Space
  IRET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;MISCELLANEOUS SUPPORT FUNCTIONS
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;SEARCH A BYTE-TO-WORD LOOKUP TABLE FOR A MATCH
;Inputs:  ES:[BX] = Table to search
;         AL      = Byte to search for
;Outputs: CF = Clear if a byte match as found in table
;              BX = Word from Table
;            = Set if no match found in table
;              BX = unchanged
;Changes: Last Entry in Table (end-of-table marker) = DB -1, DW -1
;------------------------------------------------------------------------------
SearchByteToWordTbl:
  PUSH AX,SI,DS  ;Save used registers
  CLD            ;Go forward with string functions
  MOV  DS,ES     ;Point DS at correct data area
  MOV  SI,BX     ;Put pointer in SI
  MOV  AH,AL     ;Put byte to check in AH
B10:             ;Loop to here for each table entry
  LODSB          ;Get the next table entry
  CMP  AL,-1     ;Is it possibly the end of the table?
  JNE >B20       ;If not, continue
  CMP  W [SI],-1 ;Is it actually the end of the table?
  JE  >B70       ;If so, there's no match
B20:             ;Not end of table
  CMP  AL,AH     ;Is it a match?
  JE  >B80       ;If so, handle it!
  INC  SI,2      ;If not, skip over this table entry
  JMP  B10       ;And keep looking
B70:             ;No entry found
  STC            ;Set the not found flag
  JMP >B90       ;Quit
B80:             ;Entry found [SI]
  MOV  BX,[SI]   ;Point BX at the table entry
  CLC            ;Set the found flag
B90:             ;Done
  POP  DS,SI,AX  ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;STACK-RELATED FUNCTIONS
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;CREATE/DELETE OUR OWN STACK
;Inputs:  CS = TSR Data Area
;         StackInUse
;Outputs: Interrupts Enabled
;Changes: SS,SP to/from our stack
;------------------------------------------------------------------------------
MakeStack:
  CLI                  ;Disable interrupts
  PUSHF                ;Save
  POP  CS:TempFlags    ;  Flags
  INC  CS:StackInUse   ;Increment number-of-calls counter
  CMP  CS:StackInUse,1 ;Is this the first call?
  JNE >M90             ;If not, the stack is already in use
  MOV  CS:TempBX,BX    ;  BX in memory
  POP  BX              ;Save MakeStack's return address in BX
  MOV  CS:OldSS,SS     ;Save original SS
  MOV  CS:OldSP,SP     ;Save original SP
  MOV  SP,CS           ;Put our CS
  MOV  SS,SP           ;  into SS
  MOV  SP,LastTSRByte  ;SP = Top of Stack
  PUSH BX              ;Restore MakeStack's return address to stack
  MOV  BX,CS:TempBX    ;Restore BX from memory
M90:                   ;Done
  PUSH CS:TempFlags    ;Restore
  POPF                 ;  Flags
  STI                  ;Enable interrupts
  RET

ReturnStack:
  CLI                ;Disable interrupts
  PUSHF              ;Save
  POP  CS:TempFlags  ;  Flags
  DEC  CS:StackInUse ;Decrement number-of-calls counter
  JNZ >R90           ;If sack is still in use, quit
  MOV  CS:TempBX,BX  ;Save BX in memory
  POP  BX            ;Save MakeStack's return address in BX
  MOV  SS,CS:OldSS   ;Restore original SS
  MOV  SP,CS:OldSP   ;Restore original SP
  PUSH BX            ;Restore MakeStack's return address to stack
  MOV  BX,CS:TempBX  ;Restore BX from memory
R90:                 ;Done
  PUSH CS:TempFlags  ;Restore
  POPF               ;  Flags
  STI                ;Enable interrupts
  RET


;ChangeColor:
;  PUSHF             ;Save Flags
; PUSH DI,DS        ;Save used registers
;  MOV  DI,0B800h    ;Point DS at
;  MOV  DS,DI        ;  video memory
;  MOV  DI,4160      ;Point DI at Character we want to change
;;  XOR  DI,DI        ;Point DI at Character we want to change
;  INC  B [DI]       ;Change the character
;  XOR  B [DI+1],77h ;Toggle the Color
;  POP  DS,DI        ;Restore used registers
;  POPF              ;Restore flags
;  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;SPACE FOR OUR TSR STACK
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

  EVEN 16
  DB (StackSize/8) DUP ('TSRStack')


LastTSRByte:


;圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹
;圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹圹


;哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌
;DATA NEEDED TO INSTALL/UPDATE/SHOW STATUS (NOT NEEDED DIRECTLY IN TSR)
;苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘

;==============================================================================
;TSR Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Table of Interrupt Numbers that the TSR Intercepts
  ;First byte of each entry is the Interrupt Number
  ;Second word is the Pointer to our Interrupt Handler Code Header
  ;----------------------------------------------------------------------------
  IntNumTable:
    DB 2Fh       ;TSR Multiplex
     DW Int2FHdr
    DB 08h       ;Timer
     DW Int08Hdr
    DB 0         ;End of Table

  ;----------------------------------------------------------------------------
  ;Data needed to install as a TSR, Hooking into the Multiplex Int
  ;----------------------------------------------------------------------------
  FirstHandle DB 0 ;First available user handle for Int 2Fh


;==============================================================================
;Miscellaneous
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Miscellaneous Yes/No flags (individual bits)
  ;----------------------------------------------------------------------------
  ProgFlags        DB 00h ;General Program Flags #1
    Uninstall     EQU 01h ;Uninstall resident program?
    InMemory      EQU 02h ;Already installed in memory?
    UseLowMemory  EQU 04h ;User does not want us in High Memory
    MemoryMoved   EQU 08h ;TSR Memory has been moved by our Auto-Code
    DoEnvir       EQU 10h ;Parsing/Testing Environment variable
    DoStdIn       EQU 20h ;Parsing/Testing StdIn buffer
    FoundSuptFile EQU 40h ;Found Support File in the Path

  StatusFlags      DB 00h ;General Program Yes/No Flags #2
    Status        EQU 01h ;Show Status
    Descriptors   EQU 02h ;Show Hub/Config/Intf/EndPt Descriptors
    Alias         EQU 04h ;Write the Alias List to the Screen
    BadDevices    EQU 08h ;Write the Bad Devices List
    Help          EQU 10h ;User wants help?
    ExternalStage EQU 20h ;Show External Device Stage
    ErrLvl        EQU 40h ;Write ErrorLevel Table

  ;----------------------------------------------------------------------------
  ;Miscellaneous Strings we need to write to the screen
  ;----------------------------------------------------------------------------
  HexString: DB '0000',0
  CrLfMsg:   DB CR,LF,0
  SingleMsg: DB ' '
  NoMsg:     DB 0
  ;Space4Msg: DB ' '
  Space3Msg: DB ' '
  Space2Msg: DB ' '
  SpaceMsg:  DB ' ',0


;==============================================================================
;Pause Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings and Data needed to Pause the screen
  ;----------------------------------------------------------------------------
  PauseMsg:
    DB CR,LF
    DB ' MORE   (Esc stops Pausing, Ctrl-C stops Completely, any other Continues)',CR,0
  PauseNMsg:
    DB ' MORE                                                                    ',CR,LF,0
  PauseDMsg:
    DB '                                                                               ',CR,0
  PauseRows       DW ? ;Number of rows per screen
  PauseHeaderPtr  DW 1 ;Pointer to Header Message (start with a fake one <> 0)
  PauseHeaderSize DW 2 ;Number of lines in the Header Message
  PauseRowCount   DW 2 ;Current Row Counter


;==============================================================================
;DOS Environment Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Variables to search for our Environment Variable
  ;----------------------------------------------------------------------------
  EnvVarString:  DB 'USBHUB='      ;Environment Variable String
  EnvVarSize    EQU $-EnvVarString ;Length of String
  EnvVarPointer  DW -1             ;Pointer to Program Environment Variable

  ;----------------------------------------------------------------------------
  ;Variables to search for an extended Command Line String
  ;This should only be valid/needed if the Command Line Size (PSP:[80h]) is 7Eh
  ;----------------------------------------------------------------------------
  CmdLineVarString:  DB 'CMDLINE='         ;Environment Variable String
  CmdLineVarSize    EQU $-CmdLineVarString ;Length of String
  CmdLineVarPointer  DW -1                 ;Pointer to Program Environment Variable


;==============================================================================
;EXEC Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Size of our program stack (in bytes)
  ;----------------------------------------------------------------------------
  ProgStackSize EQU 512

  ;----------------------------------------------------------------------------
  ;Variables to Locate and Run another Program (EXEC Child Program)
  ;----------------------------------------------------------------------------
  PathToUse:      DB MaxPathSize DUP (0) ;Path to Use
  OurPathPointer  DW -1                  ;Pointer to our Path String
  CurrentPath:    DB  0                  ;Current Path (Zero-Length ASCIIZ)
  PathVarPointer  DW -1                  ;Pointer to PATH Environment Variable
  SupportFile:    DB 'USBSUPT1.COM',0    ;Support File Name to Look for
  PathVarString1: DB 'PATH='             ;PATH Environment String Header (DOS)
  PathVarString2: DB 'Path='             ;PATH Environment String Header (NT?)
  PathVarSize    EQU $-PathVarString2    ;Length of String

  ;----------------------------------------------------------------------------
  ;Variables needed to do EXEC Call
  ;----------------------------------------------------------------------------
  CmdTailSize DB CmdTailMax-2           ;Length of command tail (Maximize it)
  CmdTail:    DB CmdTailMax DUP (CR)    ;Command Tail for EXEC Call
  ParamBlock: DB ParamBlockSize DUP (?) ;Parameter Block for EXEC Call
  FCB1:       DB FCBSize DUP (?)        ;File Control Block #1
  FCB2:       DB FCBSize DUP (?)        ;File Control Block #2
  OldSPExec   DW ?                      ;SP may be destroyed by EXEC Call

  ;----------------------------------------------------------------------------
  ;Strings needed to write Descriptor Header Information to the screen
  ;----------------------------------------------------------------------------
  HostIndexMsg:  DB 'USB HOST INDEX: ',0
  DvcAddressMsg: DB 'DEVICE ADDRESS: ',0

  ;----------------------------------------------------------------------------
  ;Strings needed to set up Command Tail for Exec Call
  ;----------------------------------------------------------------------------
  DescriptorMsg:     DB 'Descriptor '
  DescriptorMsgAddr: DB 'xxxx:xxxx '
  DescriptorMsgHost: DB 'xxh '
  DescriptorMsgDvc:  DB 'xxh '
  DescriptorCallBk:  DB 'xxxx:xxxx'
                     DB  0

  TDStatusMsg:    DB 'TDStatusCode '
  TDStatusCode:   DB 'xxxxh '
  TDStatusCallBk: DB 'xxxx:xxxx'
                  DB 0

  Int14ErrMsg:    DB 'Int14ErrorCode '
  Int14ErrCode:   DB 'xxxxh '
  Int14ErrCallBk: DB 'xxxx:xxxx'
                  DB 0

  ;----------------------------------------------------------------------------
  ;Error Message for when the Support File is not found
  ;----------------------------------------------------------------------------
  NoSuptFileMsg:
    DB 'Error! Need Support File ',0


;==============================================================================
;Help Screen Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Data needed if the User has changed the name of the program from USBHUB
  ;----------------------------------------------------------------------------
  RealName:           ;Real name of our program (MUST end in 0)
    DB 'USBHUB',0,0,0 ;  & MUST have enough space for 8-char name
  RealNameSz DW 6     ;Size of RealName (not incl 0)

  ;----------------------------------------------------------------------------
  ;Syntax Help String (if user asks for Help)
  ;----------------------------------------------------------------------------
  SyntaxMsgHdr:
    DB 'SYNTAX: ',0
  SyntaxMsg:
    DB '[Options]',CR,LF
    DB LF
    DB '  ?       Show this HELP screen',CR,LF
    DB '  A       Show all ALIASES for these command line Options',CR,LF
    DB '  ErrLvl  Show all ErrorLevels (DOS Return Codes)',CR,LF
    DB '  U       UNINSTALL from memory',CR,LF
    DB '  L:Y/N   Force installation into LOW memory (Default = No)',CR,LF
    DB LF
    DB '  S  Display current STATUS of program & hubs',CR,LF
    DB '  C  Display CONFIGURATION (& other) descriptors of last hub found',CR,LF
    DB LF
    DB '  B         Show list of BAD (incompatible) hubs found',CR,LF
    DB '  Beep:Y/N  BEEP Speaker when bad hub is found (Default = Yes)',CR,LF
    DB LF
    DB '  X  Show stage where last eXTERNAL device failed to connect'
    DB 0


;==============================================================================
;Program Status Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings needed to print the Program Status to the screen
  ;----------------------------------------------------------------------------
  StatusHeader:
    DB '屯屯屯屯屯屯屯 HUB 屯屯屯屯屯屯屯  屯屯屯屯屯屯屯屯 PORTS 屯屯屯屯屯屯屯屯屯',CR,LF
    DB '                    P ~ N ~ O TOTAL          TOTL P ~   ~ E ~   ~ O ~ R L H   S',CR,LF
    DB '                    t P o O C POWER          POWR o C C E n S S O C R e o i T W',CR,LF
    DB '                HUB P o P C u  ON             ON  w o o n a u u C u e s S S e I',CR,LF
    DB 'HUB HST DVC ITF PWR w w w u r PORTS  PRT DVC PORT e n n b b s s u r s e p p s n',CR,LF
    DB 'IDX IDX ADR NUM  mA r r r r r (mA)   NUM ADR (mA) r n n l l p p r r t t d d t d',CR,LF
    DB '屯 屯 屯 屯 屯  屯屯屯 屯屯  屯 屯 屯屯 屯屯屯屯屯屯屯屯屯屯屯屯屯屯',CR,LF
    DB 0
  StatusSeparator:
    DB '哪 哪 哪 哪 哪  哪哪哪 哪哪  哪 哪 哪哪 哪哪哪哪哪哪哪哪哪哪哪哪哪哪',CR,LF
    DB 0
  NoHubsMsg:
    DB '## ## ## ## ## # No Hubs Configured ## #哪# #哪哪哪哪哪哪哪哪哪哪哪哪哪#',CR,LF,0
  HubStatusErrMsg:
    DB                      ' No Resp',0
  PortStatusErrMsg:
    DB                                                   '         No Response         ',0
  DashDashMsg:
    DB                                          '---  ---',0
  BadBadMsg:
    DB                                          'BAD  BAD',0

  StatusDWord      DD  ? ;Status Info's returned by Hub during Status Printout
  StatusReturnCode DW -1 ;Value to poll so we know when we have the StatusDWord


;==============================================================================
;Bad Device Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings needed to print Bad Device Table to the screen
  ;----------------------------------------------------------------------------
  BadDeviceHdr:
    DB '   BAD (INCOMPATIBLE) HUBS',CR,LF
    DB '屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯',CR,LF
    DB  LF
    DB 'HOST  DVC   INTF  STAGE  ERROR',CR,LF
    DB 'INDX  ADDR  NUM    NUM   CODE',CR,LF
    DB '哪哪  哪哪  哪哪  哪哪  哪哪',CR,LF
    DB  0

  NoneFoundMsg:
    DB '#哪#  #哪#  None  #哪# #哪#',CR,LF,0
  BadBeepMsg:
    DB 'Beep for Bad Hubs: ',0

  YesMsg: DB 'Yes',0
  NoMsgS: DB ' No',0


;==============================================================================
;Bad External Device Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings needed to print External Stage to the Screen
  ;----------------------------------------------------------------------------
  ExternalHdrMsg1:
    DB 'External Device Stage:  ',0
  ExternalHdrMsg2:
    DB CR,LF
    DB 'External Device Error: ',0

  ;----------------------------------------------------------------------------
  ;Strings needed to print Reset Stage to the Screen
  ;----------------------------------------------------------------------------
  ResetHdrMsg:
    DB 'Reset Stage:  ',0

;==============================================================================
;ErrorLevel Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;ErrorLevels, and Table for ErrorLevel Description Strings
  ;----------------------------------------------------------------------------
  ErLvlOption   EQU  1 ;Bad Option on the command line
  ErLvlMemory   EQU  2 ;Memory problem with the computer
  ErLvlUninst   EQU  3 ;Not in memory yet, can't perform Request
  ErLvlVersion  EQU  4 ;Another version of the program already installed
  ErLvlDOSVer   EQU  5 ;DOS Version too old
  ErLvlStdIn    EQU  6 ;StdIn file too big
  ErLvlNoHost   EQU  7 ;No USB Host Driver installed
  ErLvlHostInit EQU  8 ;Error while trying to initialize host request
  ErLvlNoData   EQU  9 ;No Report/Descriptor Data to Print
  ErLvlSuptFile EQU 10 ;Could not Find Support File

  ErrLvlHdr:
    DB  CR,LF
    DB '                     ERRORLEVELS (DOS RETURN CODES)',CR,LF
    DB '  屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯',CR,LF
    DB '   0 No Error.',CR,LF
    DB 0

  ErrLvlTbl:
    DB ErLvlOption
       DB "Bad Command-line Option.",0
    DB ErLvlMemory
       DB "Memory problem with the computer.",0
    DB ErLvlUninst
       DB "USBHUB is not installed in memory yet -- can't perform Request.",0
    DB ErLvlVersion
       DB "A different version of USBHUB is already installed in memory.",0
    DB ErLvlDOSVer
       DB "DOS must be at least version 3.00.",0
    DB ErLvlStdIn
       DB "The Redirected Input Option File (USBHUB < InFile) is too big.",0
    DB ErLvlNoHost
       DB "Could not find a compatible USB Host Driver in memory.",0
    DB ErLvlHostInit
       DB "Could not properly initialize the USB Host Driver.",0
    DB ErLvlNoData
       DB "There is no Configuration Descriptor data to write.",0
    DB ErLvlSuptFile
       DB "Could not find the required USBSUPT1.COM support file.",0
    DB -1,-1 ;End of Table


;==============================================================================
;Alias Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings needed to print Command Line Aliases to the screen
  ;----------------------------------------------------------------------------
  AliasHdrMsg:
    DB '                       ALIASES FOR COMMAND-LINE OPTIONS',CR,LF
    DB '屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯',CR,LF
    DB 0

  YesNoHdrMsg:
    DB '       ALIASES FOR YES & NO',CR,LF
    DB '屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯',CR,LF
    DB 0

  ;----------------------------------------------------------------------------
  ;Table needed to temporarily store Aliases.
  ;They are originally sorted in reverse alphabetical order.
  ;To write them in forward alphabetical order, we temporarily store
  ;  the String Pointers, in the original reverse order, in this table.
  ;  We then write the strings, starting with the last entry in this table
  ;  and moving backwards.
  ;The number of entries in this table must be AT LEAST as big as the largest
  ;  number of Aliases for a single command Option.  Most Options don't have
  ;  more than a dozen or so Aliases.
  ;----------------------------------------------------------------------------
  AliasSortTbl: DW 50 DUP (?) ;Table to store Alias Strings (to reverse order)


;==============================================================================
;Command-line (Parsing) Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Extra Memory Segment (used to store compressed contents of STDIN)
  ;----------------------------------------------------------------------------
  ExtraMemSegment DW ?

  ;----------------------------------------------------------------------------
  ;Data needed to Parse the command line for Options
  ;----------------------------------------------------------------------------
  ParseTest  DB Yes ;Testing the command for errors?
  ParseError DB  No ;Error while Parsing Command Line?

  ;----------------------------------------------------------------------------
  ;Various Parsing-related messages we may need to print to the screen
  ;----------------------------------------------------------------------------
  ParseCmdMsg:
    DB 'Error in the command-line Options for USBHUB:',CR,LF,0
  ParseEnvMsg:
    DB 'Error in the Environment variable "USBHUB":',CR,LF,0
  ParseStdInMsg:
    DB 'Error in the redirected input file ("USBHUB < {FileName}"):',0
  ParseErrMsg:
    DB '^ Error',CR,LF,LF,0
  ParseErrEnv:
    DB 'Reset the Environment variable (type "SET USBHUB=") and then',CR,LF
  ParseErrMsg2:
    DB 'Type "USBHUB ?" for Help.',CR,LF,0
  StdInTooBigMsg:
    DB 'The redirected input file ("USBHUB < {FileName}") is too big!',CR,LF,0

  Copyright:
    DB "USBHUB 0.08, (C) 2007-2009, Bret E. Johnson.",CR,LF
    DB "DOS Driver for up to 16 Generic USB ver 1 Hubs, with up to 7 ports on each Hub.",CR,LF
    DB  LF,0
  EnvMsg:
    DB  'Environment: ',0
  InstallMsg1:
    DB 'USBHUB has been ',0
  InstallMsgAuto:
    DB 'automatically ',0
  InstallMsgHigh:
    DB 'installed into Upper Memory.',0
  InstallMsgHole:
    DB 'installed into a Low Memory "Hole".',0
  InstallMsgNorm:
    DB 'installed into Low Memory.',0
  InstallMsgLast:
    DB CR,LF
    DB 'Type "USBHUB U" to Uninstall USBHUB from memory.',CR,LF,0
  DOSVerMsg:
    DB 'You must be using DOS version 3.00 or later to use this program.',0
  NoHostMsg:
    DB 'There must be a compatible USB Host Driver installed in memory',CR,LF
    DB '  (something like USBUHCI.COM) before this program can be installed.',0
  HostInitErrMsg:
    DB 'There was an error while trying to initialize the USB Host.',0
  NoEnvironMsg:
    DB 'There is no DOS Environment.',CR,LF
    DB 'There is something WEIRD going on here!',0
  ExtraMemoryMsg:
    DB 'There is not enough available memory to run this program!',0
  WrongVerMsg:
    DB 'Another version of USBHUB was found in memory.',CR,LF
    DB 'Please UNINSTALL the other version before continuing.',0
  NoDescrDataMsg:
    DB 'There is no Descriptor Data to Write!',0
  UninstallMsg:
    DB 'USBHUB has been Uninstalled from memory.',CR,LF,0
  NoUninstallMsg:
    DB 'Unable to Uninstall USBHUB from memory, but it has been Disabled.',CR,LF
    DB "Remove any TSR's installed after USBHUB and try again.",CR,LF
    DB LF
    DB 'To Re-Enable USBHUB, simply type "USBHUB" at the command-line.',0
  ReEnabledMsg:
    DB 'USBHUB has been Re-Enabled.',CR,LF
    DB LF,0
  UninstallErrMsg:
    DB "Can't find USBHUB in memory.",CR,LF
    DB 'You must install it before it can be Uninstalled.',0
  UpdateMsg:
    DB  'Resident USBHUB has been updated with new information.',0

  BadDvcErrMsg:
    DB 'Bad Device',0
  ExternalStageErrMsg:
    DB 'External Stage Error',0
  DescrErrMsg:
    DB 'Descriptor',0
  StatusErrMsg:
    DB 'Program Status',0
  DataErrMsg:
    DB ' Data is not available until after',CR,LF
    DB '  USBHUB has been installed into memory.',0


  ;----------------------------------------------------------------------------
  ;Strings needed to write the Command-line error message
  ;----------------------------------------------------------------------------
  MoreLeftMsg:   DB '<<-More}  ',0
  MoreRightMsg:  DB '  {More->>',0
  MoreMsgSize   EQU $-MoreRightMsg

  ;----------------------------------------------------------------------------
  ;Command Line Options with no single-character equivalents
  ;These must be in the same numerical order that we want the
  ;  Alias Option to Sort them in!
  ;----------------------------------------------------------------------------
  OptionBeep   EQU 1 ;Beep the speaker
  OptionErrLvl EQU 2 ;Write ErrorLevel Table

  ;----------------------------------------------------------------------------
  ;Command Line Options
  ;----------------------------------------------------------------------------
  SwitchList:
    DB 'Help',0
    DB  0, '?'
      ; ^              Beginning-of-List Marker
      ;    ^   ^        Code(s) to use

    DB 'UseLowMemory',0
    DB 'UseLowMem',0
    DB 'UseLowerMemory',0
    DB 'UseLowerMem',0
    DB 'UseLow',0
    DB  0, 'L'

    DB 'Uninstall',0
    DB  0, 'U'

    DB 'StatusTbl',0
    DB 'StatusTable',0
    DB  0, 'S'

    DB 'StatusOfHubs',0
    DB 'StatusOfHub',0
    DB  0, 'S'

    DB 'Status',0
    DB  0, 'S'

    DB 'Sounds',0
    DB 'Sound',0
    DB  0, OptionBeep

    DB 'ShowStatusTbl',0
    DB 'ShowStatusTable',0
    DB 'ShowStatus',0
    DB  0, 'S'

    DB 'Remove',0
    DB  0, 'U'

    DB 'Out',0
    DB  0, 'U'

    DB 'OptionAliases',0
    DB 'OptionAlias',0
    DB  0, 'A'

    DB 'LowMemory',0
    DB 'LowMem',0
    DB 'LowerMemory',0
    DB 'LowerMem',0
    DB 'Low',0
    DB  0, 'L'

    DB 'IntfDescriptor',0
    DB 'IntfDescr',0
    DB 'Intf',0
    DB  0, 'C'

    DB 'InterfaceDescriptor',0
    DB 'InterfaceDescr',0
    DB 'Interface',0
    DB  0, 'C'

    DB 'IncompatibleHubsList',0
    DB 'IncompatibleHubList',0
    DB 'IncompatibleHubs',0
    DB 'IncompatibleHub',0
    DB 'Incompatible',0
    DB  0, 'B'

    DB 'HubStatusTbl',0
    DB 'HubStatusTable',0
    DB 'HubStatus',0
    DB  0, 'S'

    DB 'HubDescriptor',0
    DB 'HubDescr',0
    DB  0, 'C'

    DB 'Hlp',0
    DB 'H',0
    DB  0, '?',

    DB 'ForceLowMemory',0
    DB 'ForceLowMem',0
    DB 'ForceLowerMemory',0
    DB 'ForceLowerMem',0
    DB 'ForceLow',0
    DB  0, 'L'

    DB 'ExternalStage',0
    DB 'ExternalDvcStage',0
    DB 'ExternalDeviceStage',0
    DB  0, 'X'

    DB 'ErrorLvlTbl',0
    DB 'ErrorLvlTable',0
    DB 'ErrorLvls',0
    DB 'ErrorLvl',0
    DB 'ErrorLevelTbl',0
    DB 'ErrorLevelTable',0
    DB 'ErrorLevels',0
    DB 'ErrorLevel',0
    DB  0, OptionErrLvl

    DB 'ErrLvlTbl',0
    DB 'ErrLvlTable',0
    DB 'ErrLvls',0
    DB 'ErrLvl',0
    DB 'ErrLevelTbl',0
    DB 'ErrLevelTable',0
    DB 'ErrLevels',0
    DB 'ErrLevel',0
    DB  0, OptionErrLvl

    DB 'ErLvlTbl',0
    DB 'ErLvlTable',0
    DB 'ErLvls',0
    DB 'ErLvl',0
    DB 'ErLevelTbl',0
    DB 'ErLevelTable',0
    DB 'ErLevels',0
    DB 'ErLevel',0
    DB  0, OptionErrLvl

    DB 'EndPointDescriptor',0
    DB 'EndPointDescr',0
    DB 'EndPoint',0
    DB  0, 'C'

    DB 'EndPtDescriptor',0
    DB 'EndPtDescr',0
    DB 'EndPt',0
    DB  0, 'C'

    DB 'DvcDescriptor',0
    DB 'DvcDescr',0
    DB 'Dvc',0
    DB  0, 'C'

    DB 'DeviceDescriptor',0
    DB 'DeviceDescr',0
    DB 'Device',0
    DB  0, 'C'

    DB 'Descriptors',0
    DB 'Descriptor',0
    DB 'Descrs',0
    DB 'Descr',0
    DB  0, 'C'

    DB 'ConfigurationDescriptor',0
    DB 'ConfigurationDescr',0
    DB 'Configuration',0
    DB  0, 'C'

    DB 'ConfigDescriptor',0
    DB 'ConfigDescr',0
    DB 'Config',0
    DB  0, 'C'

    DB 'CommandLineAliases',0
    DB 'CommandLineAlias',0
    DB  0, 'A'

    DB 'CmdLineAliases',0
    DB 'CmdLineAlias',0
    DB  0, 'A'

    DB 'Beeps',0
    DB 'Beep',0
    DB  0, OptionBeep

    DB 'BadHubsList',0
    DB 'BadHubList',0
    DB 'BadHubs',0
    DB 'BadHub',0
    DB 'Bad',0
    DB  0, 'B'

    DB 'Aliases',0
    DB 'Alias',0
    DB  0, 'A'

    DB 0            ;End of list


  ;----------------------------------------------------------------------------
  ;Switches for Yes/No Options
  ;----------------------------------------------------------------------------
  SwitchListYesNo:
    DB 'Yes',0
    DB  0, 'Y'

    DB 'True',0
    DB 'T',0
    DB  0, 'Y'

    DB 'On',0
    DB  0, 'Y'

    DB 'Off',0
    DB  0, 'N'

    DB 'No',0
    DB  0, 'N'

    DB 'False',0
    DB 'F',0
    DB  0, 'N'

    DB 'Enabled',0
    DB 'Enable',0
    DB  0, 'Y'

    DB 'Disabled',0
    DB 'Disable',0
    DB  0, 'N'

    DB '1',0
    DB  0, 'Y'

    DB '0',0
    DB  0, 'N'

    DB 0            ;End of list


  ;----------------------------------------------------------------------------
  ;TABLE OF SUBROUTINE OFFSETS TO PROCESS THE VARIOUS COMMAND LINE OPTIONS
  ;----------------------------------------------------------------------------
  SwitchTbl:
    DB  '?'
       DW DoSwitchH      ;Help
    DB  'A'
       DW DoSwitchA      ;Command Line Aliases
    DB  'B'
       DW DoSwitchB      ;Bad (Incompatible) Hubs
    DB  'C'
       DW DoSwitchC      ;Hub/Dvc/Cfg/Intf/EndPt Descriptors
    DB  'L'
       DW DoSwitchL      ;Low Memory
    DB  'S'
       DW DoSwitchS      ;Status
    DB  'U'
       DW DoSwitchU      ;Uninstall
    DB  'X'
       DW DoSwitchX      ;External Device Stage

    DB  OptionBeep
       DW DoSwitchBeep   ;Beep the Speaker
    DB  OptionErrLvl
       DW DoSwitchErrLvl ;ErrorLevel Table

    DB  0                ;End of Table


;哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌
;PROGRAM CODE (NOT NEEDED IN TSR)
;Needed to initialize/update/show status of TSR, but not actually needed
;  in memory while TSR is running
;苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘

;------------------------------------------------------------------------------
;INITIALIZE/UPDATE THE PROGRAM
;Inputs:
;Outputs: Lots of Stuff
;Changes: Everything
;------------------------------------------------------------------------------
Main:
  CLD                         ;Go forward with string functions
  MOV  SP,LastProgByte        ;Reset Stack Pointer
  CALL ResizeMemory           ;Resize our Memory Allocation
  CALL CopyNameToMCB          ;Copy our Program name to the MCB
  CALL SetupPauseNoHdr        ;Set up the Pause
  MOV  DX,Copyright           ;Write the
  CALL WriteZPause            ;  Copyright message
  CALL SetupExtraMem          ;Set up the Extra Memory Segment (Quits if Err)
  CALL TestMemory             ;See if we're already installed in memory
                              ;QUIT if another version is installed
  CALL GetRealName            ;Get the Real Program Name
  CALL SetupExec              ;Setup Exec Parameters
  CALL GetOurPath             ;Get the Pointer to Our Path
  CALL GetEnvVars             ;Get the Environment Variable Pointers
  CALL ParseIt                ;Parse the command line
  CALL ReleaseExtraMem        ;Release the Extra Memory Segment
  CALL ReEnable               ;Re-Enable the Program, if required
  CALL DoHelp                 ;Print Help and Quit, if necessary
  CALL DoAliases              ;Print Aliases and Quit, if necessary
  CALL DoErrLvls              ;Print ErrorLevel Table and Quit, if necessary
  CALL DoUninstall            ;Uninstall and quit, if necessary
  CALL DoBadDevices           ;Print Bad Devices and Quit if requested
  CALL DoDescriptors          ;Print USB Descriptors and Quit if requested
  CALL DoExternalStage        ;Print External Stage & Quit, if necessary
  CALL DoStatus               ;Print Status, if necessary
  CALL TestCompatibility      ;Test for compatibility (quit if not)
  TEST ProgFlags,InMemory     ;Are we already installed in memory?
  JZ  >M50                    ;If not, Install as a TSR
M40:                          ;Already Installed
  MOV  DX,UpdateMsg           ;If so, point at Update message
  XOR  AL,AL                  ;Errorlevel = 0
  JMP  Exit                   ;QUIT

M50:                          ;First-time installation (install as TSR)
  CALL DelEnvironment         ;Delete environment space (don't need it now)
  CALL MoveProgramToUMB       ;Move Program to Upper Memory, if possible
   ;All Subroutines after this MUST assume ES is TSR Segment, NOT CS!!
  MOV  DS,ES                  ;Point DS at TSR Data Area
M60:                          ;Ready to install TSR
  CALL InitTables             ;Initialize all Tables
  CALL ChangeInts             ;Change the interrupts to point at us
  CALL InitInts               ;Initialize periodic "Search for New Devices"
                              ;  (quits if there's a problem)
  MOV  DS,CS                  ;Point DS at Local Data Area

  XOR  AL,AL                  ;ErrorLevel = 0
  MOV  BX,DS                  ;Point BX at the Local Segment
  MOV  CX,ES                  ;Point CX at the TSR Segment
  MOV  DX,InstallMsg1         ;Write the first part of the
  CALL WriteZPause            ;  Install Message
  TEST ProgFlags,MemoryMoved  ;Did we move the TSR Memory?
  JZ  >M90                    ;If not, use TSR Exit
  MOV  DX,InstallMsgAuto      ;Write
  CALL WriteZPause            ;  "automatically"
  MOV  DX,InstallMsgHole      ;Assume we installed in a Low Memory Hole
  CMP  BX,CX                  ;Did we install in a UMB or a Low Memory Hole?
  JA  >M80                    ;If a Low Memory Hole, leave the message as is
  MOV  DX,InstallMsgHigh      ;If a UMB, point at Installed High message
M80:                          ;[DX] = appropriate Memory Message
  CALL WriteZPause            ;Write the Memory Message
  MOV  DX,InstallMsgLast      ;Point at the last part of the Installed Message
  JMP  Exit                   ;Done

M90:                          ;Exit Program as a TSR
  MOV  DX,InstallMsgNorm      ;Assume we're in Low Memory
  CMP  CX,0A000h              ;Are we in Low Memory?
  JB  >M95                    ;If so, continue
  MOV  DX,InstallMsgHigh      ;If not, point at the High Memory message
M95:                          ;[DX] = appropriate Memory Message to write
  CALL WriteZPause            ;Write the Memory Message
  MOV  DX,InstallMsgLast      ;Write the last part of the
  CALL WriteZPause            ;  Install Message
  MOV  DX,(LastTSRByte SHR 4) ;DX = number of TSR paragraphs
  MOV  AH,31h                 ;Function 31h (TSR), ErrorLevel in AL (0)
  INT  21h                    ;Do it

;------------------------------------------------------------------------------
;MAKE SURE THE MCB (MEMORY CONTROL BLOCK) CONTAINS OUR PROGRAM NAME
;Inputs:  DS = Local Data Area
;         DS:RealName = ASCIIZ Real Name of our program
;         CLD Already Issued
;Outputs:
;Changes: Data in MCB
;NOTES:   This makes sure that the MCB (Memory Control Block) for our
;           program contains our program name.  DOS 4+ does this
;           automatically, but DOS versions 1-3 do not.  This code
;           does not verify whihc DOS version is in use, but simply
;           fills in the MCB no matter what.
;         Our program name is needed inthe MCB to make sure other programs
;           can identify that we are installed in memory.  This code should
;           be added to all TSR's, so that memory-mapping programs
;           (like MAPMEM or ISLOADED) can tell which TSR's are installed
;           in memory.  It should also be added to all programs that
;           EXEC other programs, so that the EXEC'd program can figure out
;           who called it.
;         Programs that are not TSR's and do not EXEC other programs
;           do not need this code.
;------------------------------------------------------------------------------
CopyNameToMCB:
  PUSH CX,DI,SI,ES              ;Save used registers
  MOV  CX,DS                    ;Point ES:[DI]
  DEC  CX                       ;  at the Owners Name
  MOV  ES,CX                    ;  in the MCB
  MOV  DI,(OFFSET MCBOwnerName) ;  of our program
  MOV  SI,RealName              ;Point DS:[SI] at our Program Name
  MOV  CX,4                     ;Copy 4 words (8 bytes)
  REP  MOVSW                    ;Copy our program name to the MCB
  POP  ES,SI,DI,CX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SETUP/RELEASE AN EXTRA 64K MEMORY SEGMENT FOR OUR PROGRAM
;Inputs:  DS = Local Data Area
;Outputs: ExtraMemSegment = Segment of New Segment
;         Quits Program with Error Message if Memory Problem
;Changes:
;------------------------------------------------------------------------------
SetupExtraMem:
  PUSH AX,BX                 ;Save used registers
  MOV  BX,4096               ;Number of Paragraphs in 64k Program
  MOV  AH,4Ah                ;Service 4Ah (Modify memory allocation)
  INT  21h                   ;Do it (uses ES = Segment, BX = # Paragraphs)
  JC  >X70                   ;If Error, Quit
  MOV  AH,48h                ;Service 48h (Allocate Memory Block)
  INT  21h                   ;Do it (uses BX = # paragraphs, rtns AX = Sgmt)
  JC  >X70                   ;If Error, Quit
  MOV  CS:ExtraMemSegment,AX ;If OK, store the segment
  JMP >X90                   ;Done
X70:                         ;Error
  MOV  DX,ExtraMemoryMsg     ;Point at Error Message
  MOV  AL,ErLvlMemory        ;ErrorLevel = Memory Problem
  JMP  Exit                  ;Quit
X90:                         ;Done
  POP  BX,AX                 ;Restore used registers
  RET

ReleaseExtraMem:
  PUSH AX,BX,ES ;Save used registers
  MOV  BX,OFFSET ExtraMemSegment ;Point [BX] at the Extra Memory Segment
  CMP  W [BX],0 ;Did we already Release it?
  JE  >X90      ;If so, quit
  MOV  ES,[BX]  ;If not, ES = Segment to Remove
  MOV  AH,49h   ;Service 49h (Free Memory)
  INT  21h      ;Do it
  MOV  W [BX],0 ;Mark it as released
X90:            ;Done
  POP  ES,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RE-ENABLE THE PROGRAM IF IT WAS DISABLED DUE TO A FAILED UNINSTALL
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         DS:ProgFlags.InMemory
;         DS:ProgFlags.Uninstall
;         ES:Int08Counter (= 0 if TSR is Disabled)
;Outputs: If Installed as TSR, currently Disabled, and not Uninstalling:
;           ES:Int08Counter = 5
;         If any other status,
;           does nothing
;Changes:
;------------------------------------------------------------------------------
ReEnable:
  PUSH DX                  ;Save used registers
  TEST ProgFlags,InMemory  ;Already installed as TSR?
  JZ  >B90                 ;If not, quit
  TEST ProgFlags,Uninstall ;User wants us to Uninstall?
  JNZ >B90                 ;If so, quit
  CMP  ES:Int08Counter,0   ;Disabled?
  JNE >B90                 ;If not, quit
  MOV  ES:Int08Counter,5   ;Re-enable
  MOV  DX,ReEnabledMsg     ;Notify the user
  CALL WriteZPause         ;  about what we did
B90:                       ;Done
  POP  DX                  ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;Code needed because we are a TSR.  Needed to find existing Program
;  in memory, Uninstall from memory, etc.
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;CHECK MEMORY FOR COPY OF CODE TO SEE IF PROGRAM IS ALREADY INSTALLED
;Inputs:  ProgFlags.InMemory = No
;Outputs: ES = TSR program segment, whether a TSR yet or not
;         InMemory  = Yes if program is already installed as TSR
;                   = No if not
;         HandleNum = Multiplex interrupt handle number for Interrupt 2F
;Changes:
;------------------------------------------------------------------------------
TestMemory:
  PUSH AX,BX,CX,DX        ;Save all registers that might change
  PUSH DI,SI,BP,DS        ;  (includes everything except SS & SP)
  MOV  AH,0C0h            ;Function C0, (first available user handle)
M10:                      ;Loop to here for each handle number
  CLD                     ;Go forward with string functions
  XOR  BX,BX              ;Make sure
  XOR  CX,CX              ;  all registers
  XOR  DX,DX              ;  are zero
  MOV  HandleNum,AH       ;Store the handle number
  MOV  AL,MuxInstallChk   ;Install Check Function
  INT  2Fh                ;Do it
  CMP  AL,0FFh            ;Is this function installed?
  JNE >M40                ;If not, our code can't be installed yet
M12:                      ;Test Program Name
  MOV  AH,HandleNum       ;Get the handle number back again
  MOV  AL,MuxGetProgName  ;Get Program Name
  XOR  DI,DI              ;  Function
  INT  2Fh                ;Do it
  MOV  SI,ProgName        ;Point at our name
  MOV  CX,ProgNameLen     ;Get the string length
  REPE CMPSB              ;Compare the two strings
  JNE >M50                ;If not the same, it's not us
M14:                      ;Test Author
  MOV  AH,HandleNum       ;Get the handle number back again
  MOV  AL,MuxGetAuthor    ;Get Author Function
  INT  2Fh                ;Do it (returns ES:[DI])
  MOV  SI,Author          ;Point at our name
  MOV  CX,AuthorLen       ;Get the string length
  REPE CMPSB              ;Compare the two strings
  JNE >M50                ;If no match, it's somebody elses TSR, not ours
M16:                      ;Test Program Version
  MOV  AH,HandleNum       ;Get the handle number back again
  MOV  AL,MuxGetProgVer   ;Get Program Version Function
  INT  2Fh                ;Do it
  CMP  AX,ProgVer         ;Is it the same version?
  JE  >M80                ;If so, we've found it
M30:                      ;A different version is installed in memory
  MOV  AL,ErLvlVersion    ;If not, ErrorLevel = Wrong version
  MOV  DX,WrongVerMsg     ;Point to error message
  JMP  Exit               ;Quit
M40:                      ;No function installed at this handle at all
  CMP  FirstHandle,0      ;Have we already located an available handle?
  JNE >M50                ;If so, just keep searching
  MOV  AH,HandleNum       ;If not, store this one
  MOV  FirstHandle,AH     ;  as the first available
M50:                      ;Increment the Handle number and try again
  MOV  DS,CS              ;Make sure another
  MOV  ES,CS              ;  Int 2F installation check routine
  MOV  AH,HandleNum       ;  hasn't changed things
  ADD  AH,1               ;Look at the next handle number
  JNC  M10                ;If still less than FFh, keep looking
  MOV  AH,FirstHandle     ;If we've searched them all, we're not in memory
  MOV  HandleNum,AH       ;  so go ahead and store our handle number
  JMP >M90                ;And we're done
M80:                      ;We've already been installed (ES contains segment)
  OR   ProgFlags,InMemory ;Mark as already installed
M90:                      ;We're done
  POP  DS,BP,SI,DI        ;Restore
  POP  DX,CX,BX,AX        ;  all registers
  RET

;------------------------------------------------------------------------------
;PRINT MESSAGE IN DX AND QUIT WITH ERRORLEVEL IN AL
;Inputs:  AL = Errorlevel to exit program with
;         CS:[DX] = Message to Print (to ERR)
;Outputs:
;Changes: Quits program
;------------------------------------------------------------------------------
Exit:
  MOV  DS,CS           ;Point DS at Segment where Error Message is Located
  CALL ReleaseExtraMem ;Release the Extra memory Segment
  OR   AL,AL           ;Was there an Error?
  JZ  >X80             ;If not, jump to handle a normal termination
  CALL BeepErr         ;If error, Beep Once
  CALL WriteZErr       ;Write message to ERR
  CALL WriteCrLfErr    ;Move down
  JMP >X90             ;Jump to quit
X80:                   ;No Error - Write to CON
  CALL WriteZPause     ;Write the message to CON
  CALL WriteCrLfPause  ;Write a New Line
X90:                   ;We're done!!
  MOV  AH,4Ch          ;Service 4Ch (terminate program)
  INT  21h             ;Do it

;------------------------------------------------------------------------------
;FINISH UP A "CAN'T PERFORM REQUEST BECAUSE WE'RE NOT INSTALLED YET" ERROR
;Inputs:  DS:[DX] = First message to Print
;Outputs: Writes Message pointed at by DS:[DX]
;         Sets Exit ErrorLevel (ErLvlUninst)
;         Writes Second Half of Error Message
;Changes: Terminates Program
;------------------------------------------------------------------------------
FinishDataErr:
  CALL WriteZErr      ;Write first part of Error Message
  MOV  AL,ErLvluninst ;ErrorLevel = not installed yet
  MOV  DX,DataErrMsg  ;Point at second part of Error Message
  JUMP Exit           ;Terminate program

;------------------------------------------------------------------------------
;UNINSTALL RESIDENT PROGRAM
;Inputs:  ES = TSR Code Segment
;Outputs:
;Changes: Attempts to Uninstall Program from memory
;------------------------------------------------------------------------------
DoUninstall:
  TEST ProgFlags,Uninstall ;Are we supposed to Uninstall?
  JZ  >U90                 ;If not, just quit
  TEST ProgFlags,InMemory  ;If so, are we even installed yet?
  JZ  >U60                 ;If not, there's an error
  MOV  ES:Int08Counter,0   ;Disable the TSR
  CALL UnconfigureDevices  ;Disable all of the Devices that are configured
  MOV  SI,IntNumTable      ;Point at the Interrupt Address Table
  CALL CompareInts         ;Can we Uninstall the Interrupt Vectors?
  JC  >U70                 ;If not, we can't Uninstall
  MOV  AH,49h              ;If not, service 49h (Release Memory, uses ES)
  INT  21h                 ;Do it
  JC  >U70                 ;If unable to do it, quit with error
U20:                       ;OK to Restore Interrupts
  CALL UnRegDvc0Owner      ;Unregister as a Device 0 Owner
  CALL RestoreInts         ;Restore Int's back to normal
  MOV  AX,50               ;Wait a little while
  CALL DelayMSAX           ;  for things to take effect
  MOV  CX,((LastTSRByte-StackSize)/2) ;Number of Words in TSR
  XOR  DI,DI               ;Start of TSR Data Area
  XOR  AX,AX               ;Fill with Zeroes
  REP  STOSW               ;Do it
  MOV  DX,UninstallMsg     ;Point to successful uninstall message
  XOR  AL,AL               ;Errorlevel = 0
  JUMP Exit                ;QUIT
U60:                       ;Not in memory yet - can't Uninstall
  MOV  DX,UninstallErrMsg  ;Point at error message
  MOV  AL,ErLvlUninst      ;Errorlevel = Not Installed Yet
  JUMP Exit                ;QUIT
U70:                       ;Another TSR is in the way - can't Uninstall
  MOV  DX,NoUninstallMsg   ;Point at error message
  MOV  AL,ErLvlMemory      ;Errorlevel = Memory Problem
  JUMP Exit                ;QUIT
U90:                       ;No need to Uninstall
  RET

;------------------------------------------------------------------------------
;CLOSE ALL OPEN HANDLES & UNCONFIGURE DEVICES THAT WE'RE CONTROLLING
;Inputs:  ES = TSR Data Segment
;Outputs:
;Changes: Closes Open Handles, Unconfigures Devices
;------------------------------------------------------------------------------
UnconfigureDevices:
  PUSH CX,DI,SI,DS              ;Save used registers
  MOV  DS,ES                    ;Point DS at TSR Data
  MOV  SI,Int14Request          ;Point at Request Structure
  MOV  DI,DeviceInfoTable       ;Point at Table
  MOV  CX,MaxDevices            ;Number of Table Entries
G10:                            ;Loop to here for each Entry
  TEST [DI].DIFlags,DIFlagInUse ;Valid Entry?
  JZ  >G30                      ;If not, skip it
  CALL RlsDvcDoResetDI          ;Release & Reset the Device
G30:                            ;Done with this entry
  ADD  DI,DeviceInfoStrucSize   ;Point at next entry
  LOOP G10                      ;Keep going until we're done
  POP  DS,SI,DI,CX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;UNREGISTER AS A DEVICE 0 (NEW DEVICE) OWNER
;Inputs:  DS = Local Data Area
;         ES = TSR Data Segment
;Outputs:
;Changes: Unregisters as Device 0 Owner
;NOTES: We do this as a separate item from UnconfigureDevices, and perform it
;         after we've verified that we can actually Uninstall the program.
;       If we are unable to Uninstall and simply Disable ourselves, we don't
;         want to go through the bother of re-Registering as a Device 0 Owner
;         again.  We leave our Device 0 Registration in effect, but effectively
;         just ignore it until we re-Enable ourselves.
;------------------------------------------------------------------------------
UnRegDvc0Owner:
  PUSH AX,SI,DS                      ;Save used registers
  MOV  DS,ES                         ;Point DS at TSR Data
  MOV  SI,Int14Request               ;Point at Request Structure
  MOV  W [SI].I14RCallBackAddr[0],-1 ;Set CallBackAddr to nothing
  MOV  [SI].I14RRequestType,I14RRTUnRegIntfOwner ;Unregister as owner
  MOV  [SI].I14RHostIndex,-1         ;All Hosts
  MOV  [SI].I14RDeviceAddress,0      ;Address 0 (New Connects)
  MOV  AX,Reg0Handle                 ;Handle Number
  MOV  [SI].I14RRequestHandle,AX     ;  returned by Host
  CALL DoInt14CallSaveAllSI          ;Do it
  POP  DS,SI,AX                      ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;Code to Copy Data from the redirected input file, "compressing" it and
;  storing it in our local memory buffer.
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;READ THE DATA FROM STDIN (REDIRECTED INPUT) AND STORE IT IN OUR BUFFER
;Inputs:  ExtraMemSegment
;Outputs:
;Changes: Fills up StdInBuffer
;         As data is read, multiple spaces are converted to single spaces,
;           and EOL's (CR/LF) are also changed to spaces
;         Last character of buffer is a 0
;         Quits with error message if StdIn is too big for buffer
;------------------------------------------------------------------------------
FillStdInBuffer:
  PUSH AX,DI,ES             ;Save used registers
  CALL FlushKbdBuff         ;Don't let keyboard buffer mess with File Input
  MOV  ES,ExtraMemSegment   ;Point ES:DI at
  XOR  DI,DI                ;  our Buffer
  MOV  AL,' '               ;Start the buffer
  STOSB                     ;  with a space
B10:                        ;Loop to here for each character
  CALL ReadStdInChar        ;Get the next character
  JZ  >B80                  ;If end of input, we're done
B15:                        ;AL contains the next character
  CMP  AL,EOF               ;Is it End-of-File?
  JE  >B80                  ;If so, it's the end of input
B20:                        ;Test for Comment
  CMP  AL,';'               ;Is it the start of a comment?
  JNE >B30                  ;If not, try the next possibility
  CALL SkipOverStdInComment ;If so, skip over the comment
  JC  >B80                  ;If EOF, we're done
  JMP  B10                  ;If not EOF, continue
B30:                        ;Test for String
  CMP  AL,'"'               ;Double Quote?
  JE  >B35                  ;If so, handle a string
  CMP  AL,"'"               ;Single Quote?
  JE  >B35                  ;If so, handle a string
  CMP  AL,"`"               ;Left Quote?
  JNE >B40                  ;If not, try the next possibility
B35:                        ;It's a String
  CALL GetStdInString       ;Get the rest of the String
  JC  >B80                  ;If error, just quit (Error handled later)
  JMP  B10                  ;If OK, continue
B40:                        ;Test for EOL
  CMP  AL,CR                ;Carriage Return?
  JE  >B45                  ;If so, handle it
  CMP  AL,LF                ;Carriage Return?
  JNE >B50                  ;If not, it's a regular character
B45:                        ;End of Line
  CALL AddSpace2StdInBuff   ;Add a Space to the Buffer, if needed
  JMP  B10                  ;Continue
B50:                        ;Is a regular character
  CALL AddChar2StdInBuff    ;Add the character to the buffer
  JMP  B10                  ;Continue
B80:                        ;Done, no error
  XOR  AL,AL                ;Mark the end
  STOSB                     ;  of the buffer
B90:                        ;Done
  POP  ES,DI,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER A COMMENT IN THE REDIRECTED INPUT FILE
;Inputs:  DS = Local Data Area
;         ES:[DI] = StdInBuffer
;         AL = Semicolon (the start of the Comment)
;Outputs: CF = Clear if OK (not EOF)
;            = Set if we've reached EOF
;         Quits Program with error message if Buffer gets full
;Changes:
;NOTES: This looks for either an EOF or LF character to indicate the end of
;         the comment.  If we see a CR, we simply skip it and wait for the LF
;         that should immediately follow the CR.
;       If a line ends in a CR or CR/LF combination, this will not work
;         this will not work correctly.  However, no file we work with
;         should ever be in that format.
;------------------------------------------------------------------------------
SkipOverStdInComment:
  PUSH AX                 ;Save used registers
C10:                      ;Loop to here for each character on the line
  CALL ReadStdInChar      ;Get the next character (AL)
  JZ  >C70                ;If no characters available, EOF
  CMP  AL,EOF             ;End-of-File character?
  JE  >C70                ;If so, we're done
  CMP  AL,CR              ;Carriage Return?
  JE  >C20                ;If so, End of Comment
  CMP  AL,LF              ;Line Feed?
  JNE  C10                ;If not, keep looking
C20:                      ;End of Line
  CALL AddSpace2StdInBuff ;Add a Space to the Buffer if we need it
  JMP >C80                ;Done
C70:                      ;EOF
  STC                     ;Set EOF Flag
  JMP >C90                ;Done
C80:                      ;Not EOF
  CLC                     ;Set not EOF Flag
C90:                      ;Done
  POP  AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY A STRING FROM STDIN TO THE STDINBUFFER
;Inputs:  DS = Local Data Area
;         ES:[DI] = StdInBuffer
;         AL = Quote Characer (the start of the String)
;Outputs: CF = Clear if OK (not EOF)
;            = Set if we've reached EOF (Bad String)
;         Quits Program with error message if Buffer gets full
;Changes:
;NOTES: This looks for the matching Quote Character to indicate the end of
;         the String.
;       If we find an EOF, CR, or LF in the string, we return a CF to indicate
;         a bad String.
;------------------------------------------------------------------------------
GetStdInString:
  PUSH AX                 ;Save used registers
  MOV  AH,AL              ;Save quote character
  CALL AddSChar2StdInBuff ;Add the Quote Character to the Buffer
S10:                      ;Loop to here for each character of string
  CALL ReadStdInChar      ;Get the next character (AL)
  JZ  >S70                ;If no characters available, Error
  CMP  AL,EOF             ;End-of-File character?
  JE  >S70                ;If so, Error
  CMP  AL,CR              ;Carriage Return?
  JE  >S70                ;If so, Error
  CMP  AL,LF              ;Line Feed?
  JE  >S70                ;If so, Error
  CALL AddSChar2StdInBuff ;Add the Character to the Buffer
  CMP  AL,AH              ;Is it the end-of-string character?
  JNE  S10                ;If not, keep looking
  JMP >S80                ;Done
S70:                      ;EOF (Bad String)
  STC                     ;Set EOF Flag
  JMP >S90                ;Done
S80:                      ;String is OK
  CLC                     ;Set OK flag
S90:                      ;Done
  POP  AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ A CHARACTER FROM STDIN (REDIRECTED INPUT)
;Inputs:
;Outputs: AL = Next character from StdIn
;              ZF Clear
;            = 0 if no character to get
;              ZF Set
;Changes:
;------------------------------------------------------------------------------
ReadStdInChar:
  PUSH DX      ;Save used registers
  MOV  DH,AH   ;Save original AH
  MOV  AH,06h  ;Function 06h
  MOV  DL,0FFh ;  (Direct Console Input)
  INT  21h     ;Do it (returns AL and ZF)
  MOV  AH,DH   ;Restore original AH
  POP  DX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADD A CHARACTER OR STRING CHARACTER TO THE END OF THE STDIN BUFFER
;Inputs:  DS = Local Data Area
;         ES:[DI] = StdInBuffer
;         AL = Character to add to end of Buffer
;         CLD already issued
;Outputs: Returns to calling program if Character was added OK
;         Quits Program with Error if Buffer is already full
;Changes: DI (maybe)
;------------------------------------------------------------------------------
AddSpace2StdInBuff:
  PUSH AX                ;Save used registers
  MOV  AL,' '            ;Add a Space to the Buffer
  CALL AddChar2StdInBuff ;  if we need it
  POP  AX                ;Restore used registers
  RET

AddChar2StdInBuff:
  CMP  AL,' '            ;Are we adding a space?
  JNE >B00               ;If not, just add it
  CMP  B ES:[DI-1],AL    ;If so, is there already a space?
  JNE >B00               ;If not, just add it
  JMP >B90               ;If so, we're done
AddSChar2StdInBuff:
B00:                     ;Add the character to the Buffer
  CMP  DI,65534          ;Is the Buffer full?
  JAE >B70               ;If so, Error
  STOSB                  ;If not, Store the Character
  JMP >B90               ;Done
B70:                     ;Buffer already Full
  MOV  DX,StdInTooBigMsg ;Point at error message
  MOV  AL,ErLvlStdIn     ;ErrorLevel = problem with StdIn
  JMP  Exit              ;Quit
B90:                     ;Done
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;Code to Initialize various Tables and Structures
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;INITIALIZE TABLES AND STRUCTURES TO THEIR APPROPRIATE VALUES
;Inputs:  ES = TSR Data Area
;         DS = Area where Int14Requests are stored that we want to configure
;Outputs:
;Changes: Various things
;------------------------------------------------------------------------------
InitTables:
  PUSH CX,DI               ;Save used registers
  MOV  DI,Int14Request     ;Point at first Int 14h Request
  MOV  CX,3                ;CX = Number of Requests to fill in
I10:                       ;Loop to here for each Request
  CALL InitInt14Req        ;Initialize the Request Structure
  ADD  DI,Int14RequestSize ;Point at the next Structure
  LOOP I10                 ;Keep going until we're done
  MOV  DI,HubCallTable+(OFFSET HCInt14Request) ;Point at first Int 14h Request
;  MOV  CX,3                ;CX = Number of Requests to fill in
  MOV  CX,HCEntries        ;CX = Number of Requests to fill in
I20:                       ;Loop to here for each Request
  CALL InitInt14Req        ;Initialize the Request Structure
  ADD  DI,HubCallStrucSize ;Point at the next structure
  LOOP I20                 ;Keep going until we're done
  POP  DI,CX               ;Restore used registers
  RET

InitInt14Req:
  MOV  [DI].I14RDvcClass,DvcClassHub          ;Device Class = Hub
  MOV  [DI].I14RDvcSubClass,DvcSubClassNone   ;Device Sub Class = None
  MOV  [DI].I14RDvcProtocol,DvcProtocolNone   ;Device Protocol = None
  MOV  [DI].I14RIntfClass,IntfClassHub        ;Interface Class = Hub
  MOV  [DI].I14RIntfSubClass,IntfSubClassNone ;Interface SubClass = None
  MOV  [DI].I14RIntfProtocol,IntfProtocolNone ;Interface Protocol = None
  MOV  [DI].I14RVendorID,-1                   ;Vendor ID = Don't Care
  MOV  [DI].I14RProductID,-1                  ;Product ID = Don't Care
  MOV  W [DI].I14RDataAddress[2],ES           ;Set Segment
  MOV  W [DI].I14RCallBackAddr[2],ES          ;  Registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE NECESSARY INTERRUPTS TO CHECK FOR A NEW DEVICE
;Inputs:  DS = ES = TSR Data Area
;Outputs:
;Changes:
;------------------------------------------------------------------------------
InitInts:
  PUSH CX,DI                    ;Save used registers
I10:                            ;Register Interface 0 Owner
  MOV  DI,Int14Request          ;Point at Request Structure
  MOV  [DI].I14RRequestType,I14RRTRegIntfOwner ;Register as Owner
  MOV  [DI].I14RHostIndex,-1    ;Any/All Hosts
  MOV  [DI].I14RDeviceAddress,0 ;New Device
  MOV  W [DI].I14RCallBackAddr[0],DvcOwnerFarCall ;Code to call
  MOV  [DI].I14RUserPktID,0     ;Packet ID 0
  CALL DoInt14CallCXDI          ;Do it
  JC  >I70                      ;If error, quit
  MOV  Reg0Handle,CX            ;Save Registry Handle
  JMP >I90                      ;Done
I70:                            ;Error
  MOV  DX,HostInitErrMsg        ;If not, point at Error Message
  MOV  AL,ErLvlHostInit         ;Error Initializing Host
  JMP  Exit                     ;Done
I90:                            ;It worked
  POP  DI,CX                    ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;Code to save/initialize/restore Interrupt Vectors
;This code is needed in every program that intercepts Interrupt Vectors.
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;INITIALIZE ALL APPROPRIATE INTERRUPT VECTORS TO OUR TSR CODE
;Inputs:  ES = Data area to store Interrupt Vectors in (Presumably a UMB)
;         CS = Data Area where Interrupt Number Table is stored
;         CLD Already Issued!
;Outputs:
;Changes: Various Int vectors
;------------------------------------------------------------------------------
ChangeInts:
  PUSH AX,DI,SI,DS    ;Save used registers
  MOV  DS,ES          ;Point DS at TSR Data Area
  MOV  SI,IntNumTable ;Point at our Interrupt Nubmer Table
C10:                  ;Loop to here for each table entry
  MOV  AL,CS:[SI]     ;Get Interrupt Number
  OR   AL,AL          ;Is it the end of the table?
  JZ  >C90            ;If so, we're done
  MOV  DI,CS:[SI+1]   ;If valid, get our Code Header Offset
  CALL ChangeInt      ;Point the Interrupt at our code
  ADD  SI,3           ;Point at the next table entry
  JMP  C10            ;Keep going until we're done
C90:                  ;Done with the Interrupt Table
  POP  DS,SI,DI,AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHANGE INTERRUPT VECTOR TO THIS PROGRAMS INTERRUPT ROUTINE, AND SAVE THE OLD
;Inputs:  DS:[DI] = Pointer to our new interrupt header
;         AL = Interrupt number to change
;Outputs:
;Changes: Interrupt vector
;------------------------------------------------------------------------------
ChangeInt:
  PUSH AX,BX,DX,ES            ;Save used registers
  CALL InitIntHdr             ;Initialize our Interrupt Header
  MOV  AH,35h                 ;Service 35h (Get interrupt vector)
  INT  21h                    ;Do it (returns ES:BX)
  MOV  W [DI].OldVector,BX    ;Save it
  MOV  W [DI].OldVector[2],ES ;  in [DI]
  LEA  DX,[DI].CodeJmp        ;Point DS:DX at our code address
  MOV  AH,25h                 ;Service 25h (Set interrupt vector)
  INT  21h                    ;Do it
  POP  ES,DX,BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE THE DATA IN A REMOVABLE INTERRUPT VECTOR HEADER
;Inputs:  DS:[DI] = Pointer to Our Interrupt Header Structure
;Outputs:
;Changes: The Interrupt Header Data
;------------------------------------------------------------------------------
InitIntHdr:
  MOV  [DI].HdwreRst,0CBh   ;Hardware Reset Code = CBh = RETF
  MOV  [DI].CodeJmp,10EBh   ;Jump to Real Code = EBh 10h = JMP ENDS
  MOV  [DI].Signature,424Bh ;Signature for Removable Vector Header = 424Bh
  MOV  [DI].EOIFlag,0       ;We will not be issuing EOI's
  MOV  [DI].HdwreJmp,0F4EBh ;Jump to Hardware Reset = EBh F4h = JMP HdwreRst
  RET

;------------------------------------------------------------------------------
;CHECK THE INTERRUPT VECTORS TO SEE IF THEY'VE BEEN REHOOKED BY ANOTHER PROGRAM
;Inputs:  ES = TSR Data area
;         CLD Already Issued!
;Outputs: CF = Clear if Vectors are OK (We can safely Uninstall our Program)
;            = Set if at least one Vector is unchangeably rehooked
;Changes:
;------------------------------------------------------------------------------
CompareInts:
  PUSH AX,DX,SI          ;Save used registers
  MOV  SI,IntNumTable    ;Point at our interrupt number table
C10:                     ;Loop to here for each table entry
  LODSB                  ;Get the Interrupt Number
  OR   AL,AL             ;Is it the end of the table?
  JZ  >C80               ;If so, we're done
  MOV  DX,[SI]           ;If valid, get our Code Header Offset
  ADD  DX,OFFSET CodeJmp ;Add the Offset to the actual Vector Address
  CALL CompareInt        ;Has it been unchangeably rehooked?
  JC  >C70               ;If so, we can't Uninstall our Program
  INC  SI,2              ;Point at the next table entry
  JMP  C10               ;Keep going until we're done
C70:                     ;At lest one Interupt has been rehooked
  STC                    ;Set the Rehooked flag
  JMP >C90               ;We're done
C80:                     ;Vectors can be Uninstalled
  CLC                    ;Set the OK flag
C90:                     ;We're done
  POP  SI,DX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COMPARE OUR INTERRUPT ADDRESS TO MEMORY SEE IF IT'S BEEN REHOOKED
;Inputs:  ES:[DX] = Vector address to test (our TSR's address)
;         AL = Interrupt number to test
;Outputs: CF = Clear if OK to remove
;         CF = Set if rehooked and can't be removed
;Changes:
;------------------------------------------------------------------------------
CompareInt:
  PUSH BX,CX,ES ;Save used registers
  MOV  CX,ES    ;Point CX:DX at our vector
  CALL FindInt  ;Look for it (returns ES:BX and CF
  POP  ES,CX,BX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESTORE ALL INTERRUPT VECTORS BACK TO THEIR ORIGINAL STATE
;Inputs:  ES = Data Area where original Vector information is stored
;         CLD already issued!
;Outputs:
;Changes: Various Int vectors
;------------------------------------------------------------------------------
RestoreInts:
  PUSH AX,DI,SI       ;Save used registers
  MOV  SI,IntNumTable ;Point at our Interrupt Nubmer Table
R10:                  ;Loop to here for each table entry
  LODSB               ;Get the Interrupt Number
  OR   AL,AL          ;Is it the end of the table?
  JZ  >R90            ;If so, we're done
  MOV  DI,[SI]        ;If valid, get our Code Header Offset
  CALL RestoreInt     ;Restore Interrupt Vector back to original
  INC  SI,2           ;Point at the next table entry
  JMP  R10            ;Keep going until we're done
R90:                  ;We're done
  POP  SI,DI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESTORE INTERRUPT VECTOR TO ITS ORIGINAL PLACE
;Inputs:  ES:[DI] = Pointer to our Interrupt Header
;         AL = Interrupt number to restore
;Outputs:
;Changes: Interrupt vector back to where it belongs
;Notes:   If we got to here, nothing should have intercepted
;           an interrupt that we haven't checked for.
;         We shouldn't have to worry about running into a road-block!
;------------------------------------------------------------------------------
RestoreInt:
  PUSHF                          ;Save flags
  PUSH BX,CX,DX,SI,BP,ES         ;Save used registers
  MOV  SI,W ES:[DI].OldVector    ;Put the address we'll need to store
  MOV  BP,W ES:[DI].OldVector[2] ;  in BP:SI
  MOV  CX,ES                     ;Point CX:DX
  LEA  DX,[DI].CodeJmp           ;  at our address
  CALL FindInt                   ;Search for it (returns ES:BX)
  CLI                            ;Disable interrupts
  MOV  ES:[BX],SI                ;Store the
  MOV  ES:[BX+2],BP              ;  address
  POP  ES,BP,SI,DX,CX,BX         ;Restore used registers
  POPF                           ;Restore flags
  RET

;------------------------------------------------------------------------------
;SEARCH FOR AN INTERRUPT VECTOR ADDRESS (TO SEE IF OUR CODE CAN BE REMOVED)
;Inputs:  CX:DX = Interrupt Vector address to find (address of our TSR code)
;         AL = Interrupt number to find
;Outputs: CF = Clear if OK to remove
;           ES:BX = address where it is stored
;         CF = Set if rehooked and can't be removed
;           ES:BX = unknown state
;Changes:
;------------------------------------------------------------------------------
FindInt:
  PUSH AX                                ;Save used registers
  XOR  AH,AH                             ;Point ES:BX
  ADD  AX,AX                             ;  at the
  ADD  AX,AX                             ;  main
  MOV  BX,AX                             ;  interupt
  XOR  AX,AX                             ;  vector
  MOV  ES,AX                             ;  table
  CMP  ES:[BX],DX                        ;Is the offset the same as ours?
  JNE >F20                               ;If not, it can't be ours
  CMP  ES:[BX+2],CX                      ;Is the segment the same as ours?
  JE  >F80                               ;If so, it's ours - we're done
F20:                                     ;The main interrupt vector has changed
  LES  BX,ES:[BX]                        ;Get the current vector address
F30:                                     ;Loop for each removable interrupt
  CALL TestIntHdr                        ;Is this a removable interrupt?
  JC  >F70                               ;If not, we can't be removed
  CMP  W ES:[BX-IntOfst].OldVector,DX    ;If so, is the old offset ours?
  JNE >F50                               ;If not, keep looking
  CMP  W ES:[BX-IntOfst].OldVector[2],CX ;If so, is old segment ours?
  JNE >F50                               ;If not, keep looking
  ADD  BX,(OFFSET OldVector) - IntOfst   ;If so, ES:BX = old vector pointer
  JMP >F80                               ;And we're done
F50:                                     ;Removable, but doesn't point at us
  LES  BX,ES:[BX-IntOfst].OldVector      ;Get its old vector address
  JMP  F30                               ;And keep looking for our vector
F70:                                     ;Been rehooked and can't be removed
  STC                                    ;Set the "rehooked" flag
  JMP >F90                               ;We're done
F80:                                     ;It's not rehooked, or it's removable
  CLC                                    ;Set the "OK to remove" flag
F90:                                     ;We're done
  POP  AX                                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN INTERRUPT POINTER TO SEE IF IT'S REMOVABLE
;Inputs:  ES:BX = Interrupt Vector to test
;Outputs: CF = Set if it's not a removable vector
;            = Clear if it is removable
;Changes:
;Notes:   The references to [BX-IntOfst] instead of [BX] are because of
;           our "unusual" Interrupt Header Structure design
;         We have included the (unneeded) Hardware Reset Routine code
;           (a simple RETF) in our Header Structure for efficiency
;------------------------------------------------------------------------------
TestIntHdr:
  PUSH AX,BX,DS                      ;Save used registers
  MOV  DS,ES                         ;Point DS at the interrupt segment
  CMP  B [BX-IntOfst].CodeJmp,0EBh   ;Is the first instruction a Short JMP?
  JNE >H70                           ;If not, it's not removable
  CMP  [BX-IntOfst].Signature,0424Bh ;Is there a Removeable Interrupt Signature?
  JNE >H70                           ;If not, it's not removable
  MOV  AL,[BX-IntOfst].EOIFlag       ;Get the EOI flag
  OR   AL,AL                         ;Is it zero?
  JZ  >H10                           ;If so, continue checking
  CMP  AL,80h                        ;Is it 80h?
  JNE >H70                           ;If not, it's not removable
H10:                                 ;EOI flag is OK
  CMP  B [BX-IntOfst].HdwreJmp,0EBh  ;Is the HdwreJmp instruction a Short JMP?
  JE  >H80                           ;If so, it's removable!
H70:                                 ;Vector is not removable
  STC                                ;Set the "not removable" flag
  JMP >H90                           ;We're done
H80:                                 ;Vector is removable
  CLC                                ;Set the "removable" flag
H90:                                 ;We're done
  POP  DS,BX,AX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF AN INTERRUPT VECTOR HAS A VALID ADDRESS (other than 0)
;Inputs:  AL = Interrupt number to test
;Outputs: ZF = Set if invalid address (Segment = 0)
;            = Clear if valid address (Segment <> 0)
;Changes:
;------------------------------------------------------------------------------
TestInt:
  PUSH BX,DS      ;Save used registers
  XOR  BX,BX      ;Point DS at the
  MOV  DS,BX      ;  Interrupt Table
  MOV  BL,AL      ;Point BX
  SHL  BX,1       ;  at the Interrupt
  SHL  BX,1       ;  we're looking for
  CMP  W [BX+2],0 ;Is the Segment valid (set the return flag)?
  POP  DS,BX      ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE NEEDED TO SET UP AND DO SCREEN PAUSES
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;SETUP PARAMETERS FOR DOING A SCREEN PAUSE (FOR PRINTING A LARGE TABLE)
;Inputs:  DS = Local Data Area
;         DS:[DX] = ASCIIZ Header to Print at top of each screen
;                   Last character of the Header MUST be an LF
;                   If SetupPauseNoHdr, we "inject" NoMsg as the Header
;Outputs: Pauses the screen with a MORE message every time it gets full
;NOTES:   If a Screen Header is really large (almost taking up the whole
;           screen itself, with little room for data), this procedure
;           may not work correctly.  This procedure does not validate
;           the size of the Header -- it simply assumes that it is a
;           "reasonable" size compared to the size of the screen.  Most
;           anything that needs a Screen Header (a long data table) will
;           only have a few lines of Header, so this should be OK as a
;           general purpose procedure.
;         After this Setup is complete (which should be near the beginning
;           of MAIN, before anything is sent to the screen), WriteZPause
;           must be called for ALL screen writing to CON:, not WriteZCon!
;         The Pausing occurs in "real time", meaning we can send things
;           to the Pause routine a byte, line, or several screens at a
;           time for processing.  Because we do it in "real time",
;           we can end up with extra MORE's and screen Headers appearing
;           on screen than are actually needed.  During a screen
;           transition (or a transition to a new Header) whether we
;           actually need to write anything or not depends on if there
;           is actually any real data coming afterward (in time), which
;           of course we don't know (since it hasn't happened yet).
;           So, we must assume there is more data to come and process the
;           MORE's and Screen Headers accordingly.  This only causes problems
;           (in the form of extraneous MORE's and Screen Headers)
;           when things happen near the bottom of the screen.
;           DOS's MORE utiltiy (and other programs of similar ilk) do not
;           process in "real time", but rather store things in a Temporary
;           File and then process the file.
;------------------------------------------------------------------------------
SetupPauseNoHdr:
  PUSH DX         ;Save used registers
  MOV  DX,NoMsg   ;Point at 0-length Message
  CALL SetupPause ;Setup the Pause
  POP  DX         ;Restore used registers
  RET

SetupPause:
  PUSH AX,BX,CX,DI,SI     ;Save used registers
  MOV  SI,OFFSET PauseHeaderPtr ;Point [SI] at PauseHeaderPtr
  CMP  W [SI],-1          ;Has the user already cancelled us?
  JE  >S90                ;If so, just quit
  CMP  W [SI],0           ;Has the user stopped pausing already?
  JE  >S85                ;If so, just write the header
  CALL TestRedir          ;Is our output redirected?
  JNC >S10                ;If not, setup our Headers
  MOV  W [SI],0           ;Mark as Redirected or Pausing Stopped/Disabled
  JMP >S85                ;Jump to write the Header and Quit
S10:                      ;Output not redirected
  CALL GetScreenRows      ;Store the number of rows
  MOV  PauseRows,AX       ;  on the screen
  CALL CountZLinesCX      ;Calculate the number of lines
  INC  CX,2               ;  in the new Header
  MOV  DI,PauseRowCount   ;Get the Current Row count
  ADD  DI,CX              ;Add the size of the new header
  SUB  DI,3               ;Adjust for Headers
  DEC  AX                 ;Will writing the new Header
  CMP  DI,AX              ;  cause a Pause event?
  JB  >S50                ;If not, handle it
S20:                      ;New Header is too big to fit on screen
  MOV  W [SI],NoMsg       ;Point Header for second page at nothing
  MOV  PauseHeaderSize,2  ;Set Pause Header Size
  PUSH CX                 ;Save New Header Size
  SUB  AX,PauseRowCount   ;Calculate how many rows to fill up the screen
  MOV  CX,AX              ;Put number of rows in CX
  INC  CX                 ;Adjust it
S30:                      ;Loop to here to fill up the screen
  CALL WriteCrLfPause     ;Write a new line
  LOOP S30                ;Keep going until we're done
  POP  CX                 ;Restore New Header Size
  CMP  W [SI],-1          ;Did the user cancel during the header transition?
  JE  >S90                ;If so, we're done
  CMP  W [SI],0           ;Did the user stop Pausing during the transition?
  JE  >S85                ;If so, just write the Header
S50:                      ;Need to adjust current Row Count
  SUB  PauseRowCount,2    ;Adjust things for the previous Header
S80:                      ;Store new Header Info
  MOV  [SI],DX            ;Store the Header Address
  MOV  PauseHeaderSize,CX ;Store the Header Size
  ADD  PauseRowCount,CX   ;Add the Header Size to the Row Count
  MOV  AX,PauseRows       ;Compensate if
  CMP  AX,PauseRowCount   ;  the new header
  JAE >S85                ;  put us past
  DEC  AX                 ;  the end
  MOV  PauseRowCount,AX   ;  of hte screen
S85:                      ;Write Header
  CALL WriteZCon          ;Write the Header
S90:                      ;We're done
  POP  SI,DI,CX,BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHECK TO SEE IF STDOUT HAS BEEN REDIRECTED
;Inputs:
;Outputs: CF = Clear if STDOUT is normal (usually the screen)
;            = Set if STDOUT been redirected
;Changes:
;------------------------------------------------------------------------------
TestRedir:
  PUSH AX,BX,DX        ;Save used registers
  MOV  AX,4400h        ;Function 4400h (Get Device Info)
  MOV  BX,StdOutHandle ;Device = STDOUT
  INT  21h             ;Do it (returns DX, changes AX)
  JC  >R80             ;If error, assume not Redirected
  AND  DL,(DvcInfoIsDevice+DvcInfoIsStdOut) ;Mask out unwanted bits
  CMP  DL,(DvcInfoIsDevice+DvcInfoIsStdOut) ;Is it still the STDOUT Device?
  JE  >R80             ;If so, it's not Redirected
R70:                   ;STDOUT has been Redirected
  STC                  ;Set the Redirected flag
  JMP >R90             ;Done
R80:                   ;STDOUT is not Redirected
  CLC                  ;Set the Not-Redirected flag
R90:                   ;Done
  POP  DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NUMBER OF VIDEO ROWS ON THE SCREEN
;Inputs:
;Outputs: AX = Number of text rows on the screen
;                (usually 25, 43, or 50)
;Changes:
;------------------------------------------------------------------------------
GetScreenRows:
  PUSH BX,CX,DS  ;Save used registers
  MOV  AX,40h    ;Point ES to
  MOV  DS,AX     ;  BIOS data area
  MOV  AH,12h    ;Function 12h (EGA Alternate Select)
  MOV  BX,0FF10h ;Subfunction (BL) 10h (Return EGA information)
                 ;  Preset unrealistic return value (BH)
  INT  10h       ;Do it (returns AX, BX, CX)
  CMP  BL,10h    ;Is the function supported (EGA or better)?
  JE  >R50       ;If not, jump to handle MDA/CGA
  CMP  BH,0FFh   ;Is the return value valid?
  JE  >R50       ;If not, jump to handle MDA/CGA
  TEST B [87h],8 ;If so, is bit 3 of the EGA information byte set?
  JNZ >R50       ;If so, EGA is not the active display
  XOR  AX,AX     ;Get # of
  MOV  AL,[84h]  ;  rows - 1
  JMP >R90       ;We're done
R50:             ;Video card is less than EGA (MDA or CGA)
  MOV  AX,24     ;Number of rows must be 25
R90:             ;We're done
  INC  AX        ;Bump the number of rows by 1
  POP  DS,CX,BX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ASCIIZ STRING(s) TO THE SCREEN, PAUSING WHEN IF NECESSARY
;Inputs:  DS:[DX] = String to write
;         PauseRows, PauseHeaderPtr, PauseHeaderSize, PauseRowCount
;         CS = Local Data Area
;Outputs: PauseRowCount
;Changes: Pauses the screen and waits for user input, if necessary
;NOTES: This should be called instead of WriteZCon every time something
;         is written during the Pausing.
;       A string can be written by WriteZCon during the pausing, as long
;         as the string does not contain a Line Feed.  Any line containing
;         a Line Feed must come through here or the Line Count will get
;         screwed up!
;------------------------------------------------------------------------------
WriteZPauseFar:
  CALL WriteZPause
  RETF

WriteZPause:
  PUSH AX,BX,CX,DX          ;Save used registers
  MOV  AX,CS:PauseHeaderPtr ;Put Header Pointer in AX
  CMP  AX,-1                ;Has the Output been cancelled by the user?
  JE  >P90                  ;If so, don't write anything at all
  OR   AX,AX                ;Is STDOUT Redirected?
  JZ  >P80                  ;If so, just write it with no Pausing
  CALL CountZLinesCX        ;Count how many Lines are in the string
  MOV  AX,CS:PauseRowCount  ;Add the new lines
  ADD  AX,CX                ;  to the current lines
  CMP  AX,CS:PauseRows      ;Will we be at or past the end of the screen?
  JB  >P70                  ;If not, just write it
  JE  >P20                  ;If at the end of the screen, handle it
  SUB  AX,CS:PauseRows      ;If not, find
  SUB  CX,AX                ;  the end of the String
  CALL FindEndOfLines       ;  we need to write ([BX])
  MOV  AL,[BX]              ;Save the character that's there now
  MOV  B [BX],0             ;Replace it with a 0
  CALL WriteZPause          ;Write it (will Pause correctly)
  MOV  [BX],AL              ;Restore original character
  MOV  DX,BX                ;Use the new string pointer
  CALL WriteZPause          ;Write it (Pausing if necessary)
  JMP >P90                  ;Done
P20:                        ;At end of screen
  CALL WriteZCon            ;Write the String
  CALL HandlePause          ;Handle the Pause (may change Pointers/Counters)
  JMP >P90                  ;We're done for now
P70:                        ;Store new Row Count
  MOV  CS:PauseRowCount,AX  ;Save the new Row Count
P80:                        ;Write the String
  CALL WriteZCon            ;Write the string
P90:                        ;Done
  POP  DX,CX,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE PAUSE LINE, AND WAIT FOR A KEYSTROKE
;Inputs:  CS = Local Data Area
;         PauseRows, PauseHeaderPtr, PauseHeaderSize, PauseRowCount
;Outputs: PauseRowCount, PauseHeaderPtr
;Changes: Pauses the screen and waits for user input, if necessary
;------------------------------------------------------------------------------
HandlePause:
  PUSH AX,BX,DX,DS        ;Save String Segment
  MOV  DS,CS              ;Point DS at our Data Segment
  MOV  BX,OFFSET PauseHeaderPtr ;Point [BX] at the Pause Header
  MOV  DX,PauseMsg        ;Write the
  CALL WriteZCon          ;  Enter a Keystroke message
  CALL FlushKbdBuff       ;Clear the keyboard buffer
L10:                      ;Loop to here to wait for a keystroke
  CALL GetKey             ;Is there a key in the keystroke buffer?
  JZ   L10                ;If not, keep waiting until there is
  MOV  DX,PauseDMsg       ;Delete the
  CALL WriteZCon          ;  MORE Message
  CMP  AL,CtrlC           ;Was the keystroke a Control-C?
  JE  >L40                ;If so, jump to handle it
  CMP  AL,Escape          ;Was the keystroke an Escape?
  JNE >L20                ;If not, just keep going
  MOV  W [BX],0           ;If so, mark us as redirected (stop Pausing)
  JMP >L90                ;And quit
L20:                      ;Continue with the Pause
  MOV  DX,PauseNMsg       ;Write the
  CALL WriteZCon          ;  MORE Replacement Line
  MOV  DX,[BX]            ;Point DX at the Header
  CALL WriteZCon          ;Write it
  MOV  AX,PauseHeaderSize ;Reset the Row Count
  MOV  PauseRowCount,AX   ;Store the new Row Count
  JMP >L90                ;We're done for now
L40:                      ;Ctrl-C (stop altogether)
  MOV  W [BX],-1          ;Mark as stopped
L90:                      ;Done
  POP  DS,DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE NUMBER OF LINES IN AN ASCIIZ STRING (COUNT CR/LF COMBINATIONS)
;Inputs:  DS:[DX] = Pointer to String to measure
;         CLD already issued
;Outputs: CX = Number of LF's in the String (may be 0)
;         ZF = Set if CX = 0
;            = Clear if CX > 0
;Changes:
;------------------------------------------------------------------------------
CountZLinesCX:
  PUSH AX,SI ;Save used registers
  MOV  SI,DX ;Put the pointer in DI
  XOR  CX,CX ;Initialize Lines Counter
Z10:         ;Loop to here for each character
  LODSB      ;Get the next character
  OR   AL,AL ;Is it the end of the string?
  JZ  >Z90   ;If so, we're done
  CMP  AL,LF ;Is it a Line Feed?
  JNE  Z10   ;If not, it's not a new line
  INC  CX    ;If so, Increment the Line Counter
  JMP  Z10   ;Keep looking
Z90:         ;We're done
  OR   CX,CX ;Set return flag
  POP  SI,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE POINTER AFTER THE FIRST SEVERAL LINES OF A STRING
;Inputs:  DS:[DX] = String to use
;         CX = Number of lines to "skip"
;         CLD already issued
;Outputs: DS:[BX] = "New" String Pointer (after the last line written)
;Changes:
;NOTES: This assumes that the string actually has MORE than the number of
;         lines in AX (it does not look for the end of an ASCIIZ string).
;------------------------------------------------------------------------------
FindEndOfLines:
  PUSH AX,CX  ;Save used registers
  PUSH DI,ES  ;Save used registers
  MOV  BX,CX  ;BX = Line Counter
  MOV  ES,DS  ;Point ES:[DI] at
  MOV  DI,DX  ;  the string
  MOV  AL,LF  ;Look for Line Feeds
  MOV  CX,-1  ;Maximize counter
L10:          ;Loop to here for each new line
  REPNE SCASB ;Look for the end-of-line character
  DEC  BX     ;Decrement the Line Counter
  JNZ  L10    ;If not 0 yet, keep looking
  MOV  BX,DI  ;Store the new string beginning
L90:          ;Done
  POP  ES,DI  ;Restore used registers
  POP  CX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FLUSH KEYBOARD BUFFER
;Inputs:
;Outputs:
;Changes: Flushes the Keyboard Buffer
;------------------------------------------------------------------------------
FlushKbdBuff:
  PUSH AX     ;Save used registers
F10:          ;Loop to here for each key
  CALL GetKey ;Get a key from the keyboard buffer
  JNZ  F10    ;If there was one, get another
  POP  AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ CHARACTER FROM THE KEYBOARD BUFFER
;Inputs:
;Outputs: AH = Keyboard scan code
;         AL = ASCII value of keypress (0 if extended ASCII)
;         AX = 0 if no key is waiting
;Changes: ZF = Set if no key in buffer (AX = 0)
;            = Clear if a key was found (AX = key)
;------------------------------------------------------------------------------
GetKey:
  MOV  AH,1  ;Service 1 (Keystroke waiting?)
  INT  16h   ;Do It
  JZ  >K10   ;If no key waiting, we're done
  XOR  AH,AH ;If a key is waiting, service 0 (Get keystroke)
  INT  16h   ;Do It
  JMP >K90   ;We're done
K10:         ;No keystroke waiting
  XOR  AX,AX ;Make sure AX=0
K90:         ;We're done
  OR   AX,AX ;Set the found/not found flag
  RET

;------------------------------------------------------------------------------
;WRITE A CR/LF TO THE CONSOLE WITH A PAUSE
;Inputs:
;Outputs: To Screen, Updates Pause Counters
;Changes:
;------------------------------------------------------------------------------
WriteCrLfPause:
  PUSH DX          ;Save used registers
  MOV  DX,CrLfMsg  ;Write a Cr/Lf to
  CALL WriteZPause ;  the Pause Device
  POP  DX          ;Restore used registers
  RET

WriteCrLfPause2:
  CALL WriteCrLfPause ;Move down
  CALL WriteCrLfPause ;  2 lines
  RET

WriteCrLfErr:
  PUSH DX         ;Save used registers
  MOV  DX,CrLfMsg ;Write a Cr/Lf to
  CALL WriteZErr  ;  the ERR Device
  POP  DX         ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;Some generic code to write strings, etc.
;This code is needed in almost every program we write.
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;GETS RID OF ENVIRONMENT INFORMATION - NOT NEEDED IN TSR
;Inputs:
;Outputs:
;Changes: Quits if problem releasing memory
;------------------------------------------------------------------------------
DelEnvironment:
  PUSH AX,ES            ;Save used registers
  MOV  ES,[PSPEnvirSeg] ;Point ES at the Environment Segment
  MOV  AH,49h           ;Service 49h (free up memory)
  INT  21h              ;Do it
  JNC >E90              ;If no error occurred, Quit
  MOV  DX,NoEnvironMsg  ;If error, point to message
  MOV  AL,ErLvlMemory   ;Errorlevel = Memory Problem
  JMP  Exit             ;QUIT
E90:                    ;We're done
  POP  ES,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;BEEP THE SPEAKER
;Inputs:
;Outputs: Beeps the speaker
;Changes:
;------------------------------------------------------------------------------
BeepErr:
  PUSH AX,BX    ;Save used registers
  XOR  BX,BX    ;BH = Video page = 0
  MOV  AX,0E07h ;AH = 0Eh = Function = Write TTY
                ;AL = 07h = Character to write = BEL
  INT  10h      ;Do it
  POP  BX,AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CAPITALIZE A CHARACTER (Byte)
;Inputs:  AL = character to be capitalized
;Outputs: AL = capitalized character
;Changes:
;------------------------------------------------------------------------------
Capitalize:
  CMP  AL,'a'     ;Is it less than 'a'?
  JB  >Z90        ;If so, quit
  CMP  AL,'z'     ;Is it more than 'z'?
  JA  >Z90        ;If so, quit
  SUB  AL,'a'-'A' ;If between 'a' and 'z', capitalize it
Z90:
  RET

;------------------------------------------------------------------------------
;WRITE A SPECIFIC CHARACTER OR SET OF CHARACTERS TO THE SCREEN
;Inputs:
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
WriteAL:
  PUSH DX              ;Save used registers
  MOV  DL,AL           ;Write what's in AL
  JMP >C00             ;Do it
WriteBlock:
  PUSH DX              ;Save used registers
  MOV  DL,''          ;Write a Block Character
  JMP >C00             ;Do it
WriteHexEnd:
  PUSH DX              ;Save used registers
  MOV  DL,'h'          ;Write an h
  JMP >C00             ;Do it
WritePeriod:
  PUSH DX              ;Save used registers
  MOV  DL,'.'          ;Write a Dot
  JMP >C00             ;Do it
WriteY:
  PUSH DX              ;Save used registers
  MOV  DL,'Y'          ;Write a Y
  JMP >C00             ;Do it
WriteSpace:
  PUSH DX              ;Save used registers
  MOV  DX,SpaceMsg     ;Point at Message
  JMP >C10             ;Do it
Write2Spaces:
  PUSH DX              ;Save used registers
  MOV  DX,Space2Msg    ;Point at Message
  JMP >C10             ;Do it
Write3Spaces:
  PUSH DX              ;Save used registers
  MOV  DX,Space3Msg    ;Point at Message
  JMP >C10             ;Do it
C00:
  MOV  SingleMsg[0],DL ;Put the character in the Single Character String
  MOV  DX,SingleMsg    ;Point at Single Character String
C10:                   ;DX is pointed at String
  CALL WriteZPause     ;Write the String
  POP  DX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE SOME SPACES TO THE SCREEN
;Inputs:  CL = Number of spaces to write
;         SpaceMsg
;Outputs: To the screen
;Changes:
;------------------------------------------------------------------------------
WriteSpaces:
  PUSH CX,DX       ;Save used registers
  OR   CL,CL       ;Should we write 0 spaces?
  JZ  >S90         ;If so, we're done
  XOR  CH,CH       ;If OK, change it to a word
  MOV  DX,SpaceMsg ;Point at the message
S10:               ;Loop to here for each space
  CALL WriteZPause ;Write the space
  LOOP S10         ;Keep going until we're done
S90:               ;We're done
  POP  DX,CX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT NIBBLE, BYTE, OR WORD TO HEX CHARACTER STRING, AND WRITE IT
;Inputs:  AL/AX = Nibble/Byte/Word to be written
;         CLD must be set already!
;Outputs: Writes to the Screen
;Changes: HexString
;------------------------------------------------------------------------------
;WriteNibbleHex:
;  PUSH BX             ;Save used registers
;  MOV  BX,3           ;Need to start of offset 3 in string
;  JMP >H00            ;Jump to do it
;WriteByteHex:
;  PUSH BX             ;Save used registers
;  MOV  BX,2           ;Need to start of offset 2 in string
;  JMP >H00            ;Jump to do it
WriteWordHex:
  PUSH BX             ;Save used registers
  XOR  BX,BX          ;Need to start of offset 0 in string
;  JMP >H00            ;Jump to do it
H00:                  ;Start converting the strings
  PUSH DX,DI          ;Save used registers
  MOV  DI,HexString   ;Point DS:[DI] at HexString
  MOV  DX,DI          ;Point DS:[DX] at HexString
  CALL Word2HexString ;Convert the entire Word to a String
  ADD  DX,BX          ;Point DX at the beginning of where we write
  CALL WriteZPause    ;Write it
  POP  DI,DX          ;Restore used registers
  POP  BX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A BYTE OR WORD TO A HEXADECIMAL STRING (2 OR 4 CHARACTERS)
;Inputs:  AX = Word to Convert to a Hex String
;         DS = Local Data Area
;         CLD already issued
;Outputs: DS:[DI]
;Changes: DI
;------------------------------------------------------------------------------
Byte2HexString:
  PUSH AX,ES            ;Save used registers
  MOV  ES,DS            ;Point ES:[DI] at the String
  CALL Word2HexString10 ;Convert it
  POP  ES,AX            ;Restore used registers
  RET

Word2HexString:
  PUSH AX,BX,ES         ;Save used registers
  MOV  BX,AX            ;Save original Word
  MOV  ES,DS            ;Point ES:[DI] at
  CALL Word2HexString00 ;Convert it
  POP  ES,BX,AX         ;Restore used registers
  RET

Word2HexString00:
  MOV  AL,BH            ;Convert High Byte
  CALL Word2HexString10 ;  to ASCII
  MOV  AL,BL            ;Work with Low Byte
Word2HexString10:       ;Convert Byte to ASCII
  AAM  10h              ;Separate Low & High Nibbles
  XCHG AH,AL            ;Put High Nibble in AL
  CALL Word2HexString20 ;Convert High Nibble to ASCII
  XCHG AH,AL            ;Work with Low Nibble
Word2HexString20:       ;Convert Nibble to ASCII
  ADD  AL,90h           ;Convert BCD
  DAA                   ;  to Decimal
  ADC  AL,40h           ;Convert Decimal
  DAA                   ;  to ASCII
  STOSB                 ;Store the Nibble
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE OR WORD TO THE SCREEN AS A DECIMAL
;Inputs:  AL/AX = Byte/Word to Write
;Outputs:
;Changes:
;------------------------------------------------------------------------------
;WriteByteMin:
;  PUSH AX,BX         ;Save used registers
;  XOR  AH,AH         ;Make sure high byte is 0
;  MOV  BH,1          ;Mark as doing minimum
;  JMP >W00           ;Do it
;WriteWordMin:
;  PUSH AX,BX         ;Save used registers
;  MOV  BH,1          ;Mark as doing minimum
;  JMP >W00           ;Do it
ByteToString:
  PUSH AX,BX         ;Save the original word & BP
  XOR  AH,AH         ;Make sure high byte is 0
  XOR  BH,BH         ;BH = No Minimum, Byte
  JMP >W00           ;Jump to start the loop
WordToString:
  PUSH AX,BX         ;Save the original word
  MOV  BH,2          ;BP = No Minimum, Word
W00:                 ;Do a word or a byte
  PUSH CX,DX,SI      ;Save used registers
  MOV  SI,SingleMsg  ;Point at the single character message
  XOR  BL,BL         ;Test for first non-zero character is false
  MOV  CX,10000      ;First divisor is 10,000
W20:                 ;Loop to here for each character
  XOR  DX,DX         ;High word of Dividend = 0
  DIV  CX            ;Divide DX:AX by current divisor
  OR   AX,AX         ;Is this a non-zero character?
  JNZ >W30           ;If so, we need to write it
  OR   BL,BL         ;Has there already been a non-zero character?
  JNZ >W30           ;If so, we need to write it
  CMP  CX,1          ;Is this the last character?
  JE  >W30           ;If so, we need to write it
  TEST BH,1          ;Are we doing a minimum?
  JNZ >W40           ;If not, don't write anything
  MOV  AL,' '        ;Assume a space
  TEST BH,2          ;Doing a word?
  JNZ >W35           ;If so, write the space
  CMP  CX,100        ;If not, doing the hundreds character?
  JBE >W35           ;If so, write the space
  JMP >W40           ;If not, don't write anything
W30:                 ;We need to write this character
  INC  BL            ;Test for first non-zero character is true
  ADD  AL,'0'        ;Convert the Number to ASCII
W35:                 ;Write the character
  MOV  [SI],AL       ;Write the
  CALL WriteZPauseSI ;  character
W40:                 ;Skip this character - just make it a space
  CMP  CX,1          ;Was this the last division to do?
  JE  >W90           ;If so, we're done
  MOV  AX,DX         ;If not, start next loop with remainder of division
  PUSH AX            ;Save register for a second
  XOR  DX,DX         ;So dividend won't be messed up
  MOV  AX,CX         ;Want to divide divisor in CX
  MOV  CX,10         ;Want to divide by 10
  DIV  CX            ;Divide it
  MOV  CX,AX         ;Store it back in CX
  POP  AX            ;Restore register
  JMP  W20           ;And do it again
W90:                 ;We're done
  POP  SI,DX,CX      ;Restore used registers
  POP  BX,AX         ;Restore original word & BP
  RET

;------------------------------------------------------------------------------
;SEARCH A BYTE-TO-STRING LOOKUP TABLE FOR A MATCHING ENTRY
;Inputs:  DS:[BX] = Table to search
;         AL      = Byte to search for
;         CLD already issued
;Outputs: CF = Clear if a byte match as found in table
;              BX = Pointer to the String
;            = Set if no match found in table
;              BX = unchanged
;Changes:
;NOTES: Last Entry in Table (end-of-table marker) = DW -1
;------------------------------------------------------------------------------
SearchByte2StringTbl:
  PUSH AX,SI            ;Save used registers
  CLD                   ;Go forward with string functions
  MOV  SI,BX            ;Put pointer in SI
  MOV  AH,AL            ;Put byte to check in AH
S10:                    ;Loop to here for each table entry
  LODSB                 ;Get the next table entry
  CMP  AL,-1            ;Is it possibly the end of the table?
  JNE >S20              ;If not, continue
  CMP  B [SI],-1        ;Is it actually the end of the table?
  JE  >S70              ;If so, there's no match
S20:                    ;Not end of table
  CMP  AL,AH            ;Is it a match?
  JE  >S80              ;If so, handle it!
  CALL SkipOverStringSI ;If not, skip over the string
  JMP  S10              ;And keep looking
S70:                    ;No entry found
  STC                   ;Set the not found flag
  JMP >S90              ;Quit
S80:                    ;Entry found [SI]
  MOV  BX,SI            ;Point BX at the String
  CLC                   ;Set the found flag
S90:                    ;Done
  POP  SI,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER AN ASCIIZ STRING
;Inputs:  DS:[SI] = ASCIIZ String to Skip Over
;Outputs:
;Changes: [SI] points at character after the 0
;------------------------------------------------------------------------------
SkipOverStringSI:
  PUSH CX            ;Save used registers
  CALL CalcStrSizeSI ;Calculate the size of the string
  ADD  SI,CX         ;Add it to the pointer
  INC  SI            ;Skip over the 0
  POP  CX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LENGTH OF AN ASCIIZ STRING
;Inputs:  DS:[SI] = ASCIIZ String to wrok with
;Outputs: CX = Length of String
;         ZF = Set if string is 0 length
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
CalcStrSizeSI:
  PUSH DX            ;Save used registers
  MOV  DX,SI         ;Calculate the
  CALL CalcStrSizeDX ;  length of the string
  POP  DX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE AN ASCIIZ STRING, POINTED AT BY SI, TO PAUSE
;Inputs:  DS:[SI] = ASCIIZ String to Write
;Outputs: To Screen (CON)
;Changes:
;------------------------------------------------------------------------------
WriteZPauseSI:
  PUSH DX          ;Save used registers
  MOV  DX,SI       ;Write the
  CALL WriteZPause ;  string
  POP  DX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ASCIIZ STRING TO CON OR TO ERR
;Inputs:  DS:[DX] = Pointer to string
;         CS = Local Data Area
;Outputs: Writes the string to CON or ERR
;Changes:
;------------------------------------------------------------------------------
WriteZCon:                  ;Write to CON
  CMP  CS:PauseHeaderPtr,-1 ;Should we write anything?
  JE  >Z90                  ;If not, just quit
  PUSH BX                   ;Save used register
  MOV  BX,StdOutHandle      ;Write to STDOUT
  JMP >Z00                  ;Jump to do it
WriteZErr:                  ;Write to ERR
  PUSH BX                   ;Save used register
  MOV  BX,StdErrHandle      ;Write to STDERR
Z00:
  PUSH AX,CX                ;Save used registers
  CALL CalcStrSizeDX        ;Calculate the size of the string (returns CX)
  JZ  >Z80                  ;If nothing to write, just quit
  MOV  AH,40h               ;Function 40h (Write to Device)
  INT  21h                  ;Do it
Z80:                        ;We're done
  POP  CX,AX                ;Restore used registers
  POP  BX                   ;Restore used register
Z90:                        ;We're done
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LENGTH OF AN ASCIIZ STRING
;Inputs:  DS:[DX] = Pointer to the string
;Outputs: CX = Length of the string
;         ZF = Set if string is 0 length
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
CalcStrSizeDX:
  PUSH AX,DI  ;Save used registers
  PUSH ES     ;Save used registers
  MOV  ES,DS  ;Point ES:[DI]
  MOV  DI,DX  ; at the string
  XOR  AL,AL  ;Look for a 0
  MOV  CX,-1  ;Start with max count for REPNE
  REPNE SCASB ;Find the end of the string
  NOT  CX     ;Calculate the size
  DEC  CX     ;  of the string (sets ZF)
  POP  ES     ;Restore used registers
  POP  DI,AX  ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;Code to parse the command line for switches, and print errors.
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;PARSE THE COMMAND LINE FOR SWITCHES
;Inputs:
;Outputs: All kinds of stuff!
;Changes:
;------------------------------------------------------------------------------
ParseIt:
  CALL FixCmdLineCR    ;Replace CR at end of Command Line with a 0
  CALL FillStdInBuffer ;Copy redirected input to our buffer, if needed
                       ;  Quits if error
  MOV  ParseTest,Yes   ;Test input strings for errors
  CALL ParseThings     ;Do all input strings
  MOV  ParseTest,No    ;Parse string for real
  CALL ParseThings     ;Do all input strings
P90:
  RET

ParseThings:
  PUSH SI                      ;Save used registers
  MOV  SI,EnvVarPointer        ;Point at our Environment Variable
  CMP  SI,-1                   ;Is there an Environment Variable to parse?
  JE  >P30                     ;If no, skip it
  OR   ProgFlags,DoEnvir       ;Mark as doing the Environment
  CMP  ParseTest,Yes           ;Just doing the Test Run?
  JE  >P20                     ;If so, don't write the variable contents yet
  MOV  DX,EnvMsg               ;Write the first part of the
  CALL WriteZPause             ;  environment message to the screen
  CALL WriteEnvCon             ;Write the environment variable contents
  CALL WriteCrLfPause2         ;Move down
P20:                           ;Do the Environment Variable
  CALL ParseCmdLine            ;Parse the Environment (quits if Error)
P30:                           ;Do StdIn
  AND  ProgFlags,(NOT DoEnvir) ;Mark as doing Command Line
  OR   ProgFlags,DoStdIn       ;Parse the
  XOR  SI,SI                   ;  StdIn buffer
  CALL ParseCmdLine            ;  Quit if error
  AND  ProgFlags,(NOT DoStdIn) ;  is found
  MOV  SI,81h                  ;Assume "real" Command Line
  CMP  CmdLineVarPointer,-1    ;Have a CMDLINE Environment variable?
  JE  >P50                     ;If not, just do regular command line
  MOV  SI,CmdLineVarPointer    ;If so, point at the variable
P50:                           ;Pointed at Command Line Tail
  CALL ParseCmdLine            ;Parse Command Line
  POP  SI                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PARSE THE COMMAND LINE FOR SWITCHES
;Inputs:  ParseTest
;         [SI] = Option String to Parse
;Outputs:
;Changes: SI
;------------------------------------------------------------------------------
ParseCmdLine:
  PUSH AX             ;Save used registers
P10:                  ;Look for the next switch
  CALL IsSpaceOrEOX   ;Look for a valid character
  JZ  >P90            ;If EOL, we're done
  CMP  AL,'/'         ;Is it a slash?
  JE  >P20            ;If so, jump to handle it
  CMP  AL,'-'         ;Is it a dash?
  JE  >P20            ;If so, jump to handle it
  DEC  SI             ;If not, point back at the first character
  JMP >P30            ;Continue
P20:                  ;It's a slash or a dash
  CALL IsSpaceOrEOL   ;Look for a valid switch character
  JZ  >P70            ;If no character, there's an error
P30:                  ;Look for the switch
  CALL GetSwitch      ;See if it matches one of our switches
  JNZ  P10            ;If a match, look for the next switch
P70:                  ;Error - tell the user where it was
  CALL WriteCmdErr    ;Display the error for the user
  MOV  AL,ErLvlOption ;ErrorLevel = Bad Option on command line
  MOV  DX,NoMsg       ;Point at an empty message
  JMP  Exit           ;Print error message and quit
P90:                  ;We're done
  POP  AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE SWITCH CHARACTERS, AND DO WHATEVER IT IS THEY'RE ASKING
;Inputs:  DS:[SI] = Command line pointer
;Outputs: Lots of stuff!!!
;         ParseError
;         ZF = Set if Error
;            = Clear if OK
;Changes:
;------------------------------------------------------------------------------
GetSwitch:
  PUSH AX,BX,DI,BP         ;Save used registers
  MOV  BX,SwitchList       ;Point at the list of switch code words
  CALL GetCode             ;See if its a match
  JNC >S10                 ;If so, jump to test it
  CALL GetNextChar         ;If not, it's a single character
  CALL Capitalize          ;Capitalize it
S10:                       ;We have a Switch to test!
  MOV  BX,SwitchTbl        ;Point at the Table of Offsets
S20:                       ;Loop to here for each table entry
  MOV  AH,[BX]             ;Get the switch from our table?
  OR   AH,AH               ;Is it the end of the table?
  JZ  >S70                 ;If so, there's an error
  CMP  AL,AH               ;If a valid entry, is it a match?
  JE  >S30                 ;If so, jump to handle it
  ADD  BX,3                ;If not, point at the next table entry
  JMP  S20                 ;And keep looking
S30:                       ;It's a match from the table
  MOV  DI,OFFSET ProgFlags ;Point [DI] at ProgFlags
  MOV  BP,OFFSET TSRFlags  ;Point [BP] at TSRFlags
  MOV  AH,ParseTest        ;Pass the "Testing" flag
  OR   AH,AH               ;Set the ZF for Testing
  CALL W [BX+1]            ;Do the Switch stuff
  JMP >S90                 ;And quit
S70:                       ;There's an error
  MOV  ParseError,Yes      ;Mark the error flag
S90:                       ;We're done
  CMP  ParseError,Yes      ;Set/Clear the error flag
  POP  BP,DI,BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Display Help (Syntax) Message
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchH:
  OR   B [DI+1],Help ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Display ErrorLevel Table
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchErrLvl:
  OR   B [DI+1],ErrLvl ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Display list of Command-line (Option) Aliases
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchA:
  OR   B [DI+1],Alias ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Uninstall Program from Memory
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchU:
  OR   B [DI],Uninstall ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Install Program in Lower Memory, even if Upper Memory is available
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchL:
  PUSH AX                   ;Save used registers
  MOV  AL,UseLowMemory      ;Bit mask to use
  CALL DoSwitchWithYNPrgFwd ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Display Program Status
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchS:
  OR   B [DI+1],Status ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display list of Bad Devices
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchB:
  OR   B [DI+1],BadDevices ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display USB Descriptors of Last Device found
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchC:
  OR   B [DI+1],Descriptors ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Beep Speaker when "Bad" Devices are discovered
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchBeep:
  PUSH AX                   ;Save used registers
  MOV  AL,NoBeep            ;Bit mask to use
  CALL DoSwitchWithYNTsrRvs ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Display External Device Stage
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchX:
  OR   B [DI+1],ExternalStage ;Set the appropriate Flag
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;Support routines for processing Switces
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;GET A YES/NO OPTION FOR A COMMAND-LINE SWITCH
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK
;              ZF = Set if No
;                   AL = 0 (No)
;                 = Clear if Yes
;                   AL = -1 (Yes)
;            = Set if Error
;              AL = 0
;Changes:
;------------------------------------------------------------------------------
GetYesNo4Switch:
  PUSH BX,CX              ;Save used registers
  MOV  CH,AH              ;Save original AH
  CALL SkipColonEquals    ;Skip Colon/Equals (if there)
  MOV  BX,SwitchListYesNo ;Point at the list of code words
  CALL GetCode            ;See if its a match
  JNC >Y20                ;If so, jump to test it
  CALL GetNextChar        ;If not, get a single character
  JZ  >Y70                ;If end-of-line, error
  CALL Capitalize         ;Capitalize it
Y20:                      ;Got a character
  CMP  AL,'Y'             ;Is it Yes?
  JE  >Y40                ;If so, handle it
  CMP  AL,'N'             ;Is it No?
  JNE >Y70                ;If not, error
Y30:                      ;No
  XOR  AL,AL              ;If so, make it No
  JMP >Y80                ;Done
Y40:                      ;Yes
  MOV  AL,Yes             ;Mark it as a Yes
  JMP >Y80                ;Done
Y70:                      ;Error
  XOR  AL,AL              ;Set AL to 0
  STC                     ;Set Error Flag
  JMP >Y90                ;Done
Y80:                      ;OK
  OR   AL,AL              ;Set Zero Flag for Return
  CLC                     ;Set OK Flag
Y90:                      ;Done
  MOV  AH,CH              ;Restore original AH
  POP  CX,BX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A SWITCH WITH A YES/NO OPTION
;Inputs:  [SI] = Command Line Pointer
;         ES = TSR Data Area
;         DS = Local Data Area
;         AL = Bit mask to Set/Unset
;         AH = ParseTest status
;Outputs: Sets/Unsets bit in ES:TSRFlags or DS:ProgFlags as appropriate
;Changes:
;NOTES: If we are changing the resident (TSR) part of the program
;         (ES:TSRFlags), we do not actually change anything unless
;         ParseTest is set to No.  If we are changing the transient
;         part of the program (DS:ProgFlags), we change it no matter
;         what ParseTest is set to.
;       Forward and Reverse refer to Forward and Reverse Logic.  With
;         Forward Logic, if the user says Yes, we set the particular bit
;         to 1.  With Reverse Logic, when the user says Yes, we set
;         to bit to 0.
;------------------------------------------------------------------------------
DoSwitchWithYNTsrRvs:
  PUSH CX                  ;Save used registers
  MOV  CL,-1               ;Mark as Reverse Logic
  JMP >Y000                ;Jump to do ES:TSRFlags
;DoSwitchWithYNTsrFwd:
;  PUSH CX                  ;Save used registers
;  XOR  CL,CL               ;Mark as Forward Logic
;  JMP >Y000                ;Jump to do ES:TSRFlags
;DoSwitchWithYNPrgRvs:
;  PUSH CX                  ;Save used registers
;  MOV  CL,-1               ;Mark as Reverse Logic
;  JMP >Y001                ;Jump to do DS:ProgFlags
DoSwitchWithYNPrgFwd:
  PUSH CX                  ;Save used registers
  XOR  CL,CL               ;Mark as Forward Logic
  JMP >Y001                ;Jump to do DS:ProgFlags
Y000:                      ;ES:TSRFlags
  PUSH BX                  ;Save used registers
  MOV  BX,OFFSET TSRFlags  ;Point at TSR Flags
  JMP >Y00                 ;Do it
Y001:                      ;DS:ProgFlags
  PUSH BX                  ;Save used registers
  MOV  BX,OFFSET ProgFlags ;Point at TSR Flags
;  JMP >Y00                 ;Do it
Y00:
  PUSH AX                  ;Save used registers
  MOV  CH,AL               ;Save Bit Mask to set
  CALL GetYesNo4Switch     ;Get the Yes/No parameter (AL)
  JC  >Y70                 ;If error, handle it
  OR   AL,AL               ;Is it Yes?
  JNZ >Y20                 ;If so, jump to handle it
Y10:                       ;No
  OR   CL,CL               ;Is it Forward Logic?
  JZ  >Y40                 ;If so, jump to handle it
  JMP >Y50                 ;If not, jump to handle Reverse Logic
Y20:                       ;Yes
  OR   CL,CL               ;Is it Forward Logic?
  JZ  >Y50                 ;If so, jump to handle it
Y40:                       ;Unset the Bit
  NOT  CH                  ;Need to Unset
  CMP  BX,LastTSRByte      ;Is it for ProgFlags?
  JAE >Y45                 ;If so, jump to handle it
Y42:                       ;Unset ES:TSRFlags
  OR   AH,AH               ;Just the Test Run?
  JNZ >Y90                 ;If so, quit
  AND  ES:[BX],CH          ;Unset the appropriate flag
  JMP >Y90                 ;Done
Y45:                       ;Unset DS:ProgFlags
  AND  [BX],CH             ;Unset the appropriate flag
  JMP >Y90                 ;Done
Y50:                       ;Set the Bit
  CMP  BX,LastTSRByte      ;Is it for ProgFlags?
  JAE >Y55                 ;If so, jump to handle it
Y52:                       ;Set ES:TSRFlags
  OR   AH,AH               ;Just the Test Run?
  JNZ >Y90                 ;If so, quit
  OR   ES:[BX],CH          ;Set the appropriate flag
  JMP >Y90                 ;Done
Y55:                       ;Set DS:ProgFlags
  OR   [BX],CH             ;Set the appropriate flag
  JMP >Y90                 ;Done
Y70:                       ;Error
  MOV  ParseError,Yes      ;Mark as an Error
Y90:                       ;Done
  POP  AX                  ;Restore used registers
  POP  BX                  ;Restore used registers
  POP  CX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;REPLACE THE CARRIAGE RETURN AT THE END OF THE CMD LINE TAIL WITH A 0
;Inputs:  CS = DS = PSP Segment
;Outputs:
;Changes: Last Byte of Command Tail
;------------------------------------------------------------------------------
FixCmdLineCR:
  PUSH AX,CX,DI,ES   ;Save used registers
  MOV  AL,CR         ;Look for a CR
  MOV  CX,7Fh        ;Maximize Byte Counter
  MOV  ES,DS         ;Point ES:[DI]
  MOV  DI,81h        ;  at the Command Line Tail
  REPNE SCASB        ;Look for the CR
  MOV  B ES:[DI-1],0 ;Replace the CR with a 0
  POP  ES,DI,CX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT CHARACTER FROM THE ENVIRONMENT OR COMMAND LINE
;Inputs:  [SI] = Pointer (Command Line or Environment)
;Outputs: AL = The next character
;         ZF = Set if End-Of-Line (Character = ASCII 0)
;            = Clear if "real" character
;Changes: SI
;------------------------------------------------------------------------------
GetNextChar:
  PUSH DS                   ;Save used registers
  TEST ProgFlags,DoStdIn    ;Are we doing StdIn?
  JNZ >N20                  ;If so, jumpto handleit
  TEST ProgFlags,DoEnvir    ;Are we doing the Program Environment Variable?
  JNZ >N10                  ;If so, handle it
  CMP  CmdLineVarPointer,-1 ;Need to use the CMDLINE Environment variable?
  JE  >N90                  ;If not, just do the "real" command line
N10:                        ;Get next character from the Environment
  MOV  DS,[PSPEnvirSeg]     ;Point at the Environment Segment
  JMP >N90                  ;Continue
N20:                        ;StdIn
  MOV  DS,ExtraMemSegment   ;Poitn DS at the correct Segment
N90:                        ;DS:[SI] points at the next character
  LODSB                     ;Get the character from the "real" command line
  OR   AL,AL                ;Set ZF if EOL
  POP  DS                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER SPACES TO FIND THE NEXT LEGITIMATE CHARACTER, TESTING FOR EOL
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: ZF = Set if EOL
;               AL  = Unchanged
;              [SI] = End-of-Line Character
;            = Clear if not EOL
;               AL  = First non-space character
;              [SI] = Character AFTER the next non-space character
;Changes:
;------------------------------------------------------------------------------
IsSpaceOrEOX:
  CALL IsSpaceOrEOL ;Skip over the spaces
  JZ  >X90          ;If end-of-line, we're done
  CALL GetNextChar  ;If not, get the next character
  OR   AL,AL        ;Set return flag
X90:                ;Done
  RET

;------------------------------------------------------------------------------
;SKIP OVER SPACES TO FIND LEGITIMATE CHARACTERS, AND TEST FOR EOL
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: ZF = Set if EOL
;            = Clear if legitimate character
;              [SI] = The Next non-Space Character
;Changes:
;------------------------------------------------------------------------------
IsSpaceOrEOL:
  PUSH AX          ;Save used registers
L10:               ;Loop to here to skip over spaces
  CALL GetNextChar ;Get the next character
  CMP  AL,' '      ;Is it a space?
  JE   L10         ;If so, get the next character
  CMP  AL,Tab      ;Is it a Tab?
  JE   L10         ;If so, get the next character
  DEC  SI          ;If not, point back at the character
  OR   AL,AL       ;Set EOL flag
  POP  AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER A COLON OR EQUALS, IF THERE
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: CF = Clear if Colon or Equals was found (and skipped)
;              [SI] = First non-Space Character after the Colon/Equals
;            = Set if No Colon or Equals was found
;              [SI] = First non-Space Character after where we were looking
;Changes:
;------------------------------------------------------------------------------
SkipColonEquals:
  PUSH AX           ;Save used registers
  CALL IsSpaceOrEOX ;Skip over the Spaces
  JZ  >Q75          ;If End-of-Line, nothing to get
  CMP  AL,':'       ;Is it a Colon?
  JE  >Q80          ;If so, we're done
  CMP  AL,'='       ;Is it an equals?
  JE  >Q80          ;If so, we're done
Q70:                ;No Colon/Equals Found
  DEC  SI           ;Point back at the character
Q75:                ;[SI] correct
  STC               ;Set return flag
  JMP >Q90          ;Done
Q80:                ;Colon/Equals Found
  CALL IsSpaceOrEOL ;Go to the next character
  CLC               ;Set return flag
Q90:                ;Done
  POP  AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A CODE WORD FROM THE COMMAND LINE TO A WORD FROM THE LOOKUP TABLE
;Inputs:  DS:[SI] = Command Line Pointer
;         DS:[BX] = List to Test
;Outputs: CF = Clear if a match was found
;              AL = Entry from Table
;              [SI] = Next character after the Code Match
;         CF = Set if no match found (error)
;              AL = Unchanged
;              SI = Unchanged
;Changes: SI if valid match found
;------------------------------------------------------------------------------
GetCode:
  PUSH BX,DX         ;Save used registers
  MOV  DX,AX         ;Save AX in case there's no match
C10:                 ;Loop to here for each list of words
  CMP  B [BX],0      ;Are we at the end of our table?
  JE  >C80           ;If so, we couldn't find a match
  XOR  AH,AH         ;Assume it's a match
  PUSH SI            ;Save our command line pointer for a second
C20:                 ;Loop to here for each character in a word
  CALL GetNextChar   ;Get the next character
  CALL Capitalize    ;Capitalize it
  CALL CmpALBXNoCase ;Is it a match?
  JZ  >C30           ;If so, handle it
  INC  AH            ;If not, mark us as no match
C30:                 ;The character is tested
  INC  BX            ;Point at the next character in our test word
  CMP  B [BX],0      ;Are we at the end of the word?
  JNE  C20           ;If not, keep going until we're done
  INC  BX            ;Point at the next word or code list
  OR   AH,AH         ;Was it a match?
  JZ  >C50           ;If so, jump to handle it
  POP  SI            ;If not, restore our command line pointer
  CMP  B [BX],0      ;Is this the end of our word list?
  JNE  C10           ;If not, just test the next word
  INC  BX,2          ;If so, skip over the codes
  JMP  C10           ;Keep going until we're done with our list
C50:                 ;We've found a match!
  POP  AX            ;Lose our original command line pointer
  DEC  BX            ;Point back at the end-of-word marker
C60:                 ;Loop to here to find the end-of-list
  MOV  AX,[BX]       ;Get the next two characters in our list
  INC  BX            ;Point at the next character for next time
  OR   AX,AX         ;Is this the start of our code list?
  JNE  C60           ;If not, keep looking
  INC  BX            ;If so, point at the character we're looking for
  MOV  DL,[BX]       ;Get the character from the table
  CLC                ;Mark our OK flag
  JMP >C90           ;And we're done
C80:                 ;No match found
  STC                ;Mark us as no match
C90:                 ;We're done
  MOV  AX,DX         ;Set AX to the correct value
  POP  DX,BX         ;Restore used registers
  RET

CmpALBXNoCase:
  PUSH AX         ;Save used registers
  CALL Capitalize ;Capitalize AL
  MOV  AH,AL      ;Store it in AH
  MOV  AL,[BX]    ;Get [BX]
  CALL Capitalize ;Capitalize it
  CMP  AL,AH      ;Compare AL & [BX]
  POP  AX         ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;Code the tell the user where the Command Line Error Occurred
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;WRITE THE COMMAND LINE OR ENVIRONMENT ERROR INFORMATION TO THE SCREEN
;Inputs:  [SI] = Command line Pointer (if Command Line)
;              = StdIn Buffer Pointer (if StdIn String)
;              = Environment Pointer (if Environment Variable)
;         ProgFlags2.DoEnvir, DoStdIn
;Outputs:
;Changes: Writes information to screen
;------------------------------------------------------------------------------
WriteCmdErr:
  PUSH AX,BX,CX,DX        ;Save used registers
  PUSH DI,SI,BP           ;Save used registers
  CALL FindBadChar        ;Find the actual bad character in the string (SI)
  CALL SetupCmdErrStrings ;Set up the String Pointers and Sizes
                          ;DI:[AX] = Command Line String
                          ;DS:[BX] = Program name at beginning of String
                          ;    CX  = Size of BX String
                          ;DS:[DX] = Header String
                          ;DS:[BP] = Footer String
  CALL WriteZErr          ;Write the Header
  CALL WriteCrLfErr       ;Move
  CALL WriteCrLfErr       ;  down
  SUB  SI,AX              ;Calculate the number
  ADD  CX,SI              ;  of spaces
  DEC  CX                 ;  to write
  CALL WriteCmdString     ;Write the Command-line String (may modify CX)
  CALL WriteCrLfErr       ;Move down
  MOV  B SingleMsg[0],' ' ;Want to write spaces
  MOV  DX,SingleMsg       ;Point at the string
E60:                      ;Loop to here to write each space (number in CX)
  CALL WriteZErr          ;Write the space
  LOOP E60                ;Keep writing them until we're done
  MOV  DX,ParseErrMsg     ;Write the Pointer Part
  CALL WriteZErr          ;  of the Error Message
  MOV  DX,BP              ;Write the last part
  CALL WriteZErr          ;  of the message
  POP  BP,SI,DI           ;Restore used registers
  POP  DX,CX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GO BACKWARDS IN AN ERRORED OPTION STRING TO INDICATE TO USER WHERE ERROR WAS
;Inputs:  SI = Option String Pointer (Environment, StdIn, or Command Line)
;                where error was found
;Outputs: SI = Options String Pointer, adjusted to point at a "Real" character
;Changes:
;------------------------------------------------------------------------------
FindBadChar:
  PUSH AX          ;Save used registers
  DEC  SI          ;Go back 1 character to start
B10:               ;Loop to here to find a legitimate character
  CALL GetNextChar ;Get the character
  JZ  >B40         ;If end-of-line, keep going back
  CMP  AL,' '      ;Is it a space?
  JNE >B90         ;If not, we're done
B40:               ;Need to keep going back
  SUB  SI,2        ;Go back to the previous character
  JMP  B10         ;Keep looking
B90:               ;Done
  POP  AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SET UP THE STRING POINTERS AND SIZES TO BE ABLE TO WRITE THE COMMAND ERROR
;Inputs:  DS = Local Data Area
;Outputs: DI:[AX] = Command-line String to write
;         DS:[DX] = First Error Message (Header) to write
;         DS:[BX] = Second message to write (first part of Command string)
;             CX  = Number of Bytes to add to String Size
;         DS:[BP] = Third message to write (Footer)
;Changes:
;------------------------------------------------------------------------------
SetupCmdErrStrings:
  TEST ProgFlags,DoEnvir    ;Working with the Environment?
  JNZ >S40                  ;If so, handle it
  TEST ProgFlags,DoStdIn    ;Working with StdIn?
  JNZ >S50                  ;If so, handle it
S10:                        ;Command Line
  MOV  AX,81h               ;DI:[AX] =
  MOV  DI,DS                ;  Command-line Tail
  MOV  BX,RealName          ;DS:[BX] = Program Name
  MOV  CX,RealNameSz        ;CX = Size of [BX] String
  CMP  CmdLineVarPointer,-1 ;Real Command Line?
  JE  >S30                  ;If so, continue
S20:                        ;CMDLINE Environment Variable
  MOV  DI,[PSPEnvirSeg]     ;DI:[AX] =
  MOV  AX,CmdLineVarPointer ;  CMDLINE
  SUB  AX,CmdLineVarSize    ;  Environment Variable
S30:                        ;Have Command-line parameters set up
  MOV  DX,ParseCmdMsg       ;DS:[DX] = Header String
  MOV  BP,ParseErrMsg2      ;DS:[BP] = Footer String
  JMP >S90                  ;Done
S40:                        ;Environment
  MOV  DI,[PSPEnvirSeg]     ;DI:[AX] =
  MOV  AX,EnvVarPointer     ;  USBKEYB
  SUB  AX,EnvVarSize        ;  Environment Variable
  MOV  BX,NoMsg             ;DS:[BX] = Second message to write
  XOR  CX,CX                ;CX = Size of [BX] String
  MOV  DX,ParseEnvMsg       ;DS:[DX] = Header String
  MOV  BP,ParseErrEnv       ;DS:[BP] = Footer String
  JMP >S90                  ;Done
S50:                        ;StdIn
  MOV  DI,ExtraMemSegment   ;DI:[AX] =
  XOR  AX,AX                ;  StdIn Buffer
  MOV  BX,NoMsg             ;DS:[BX] = Second message to write
  XOR  CX,CX                ;CX = Size of [BX] String
  MOV  DX,ParseStdInMsg     ;DS:[DX] = Header String
  MOV  BP,ParseErrMsg2      ;DS:[BP] = Footer String
S90:                        ;Done
  RET

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF THE COMMAND STRING, WITH MORE MESSAGES AS NEEDED
;Inputs:  CS = DS = Local Data Area
;         DS:[BX] = First String to write (may not be needed!)
;         DI:[AX] = Second String (main part) to write
;             CX  = Number of Spaces to write at beginning (if normal)
;Outputs: CX = Adjusted number of spaces to write
;Changes:
;------------------------------------------------------------------------------
WriteCmdString:
  PUSH AX,BX,DX,DI,SI      ;Save used registers
  PUSH BP,DS,ES            ;Save used registers
  MOV  BP,CX               ;Save the original Space Counter in BP
  MOV  ES,DI               ;Save the second string Pointer
  MOV  SI,AX               ;  in ES:[SI]
  MOV  DX,BX               ;Save the length
  CALL CalcStrSizeDX       ;  of the first string
  MOV  DI,CX               ;  in DI
  MOV  DS,ES               ;Save the length
  CALL CalcStrSizeSI       ;  of the second string
  MOV  AX,CX               ;  in AX
  CMP  BP,70               ;Are there too many spaces to fit on one line?
  JBE >G20                 ;If not, continue
G10:                       ;Need to lop off the beginning
  SUB  BP,DI               ;We will not be
  XOR  DI,DI               ;  writing the
  MOV  BX,NoMsg            ;  first string
  CMP  BP,70               ;Are there still too many spaces to fit?
  JBE >G20                 ;If not, continue
  MOV  BX,MoreLeftMsg      ;Point at the More Message
  ADD  BP,MoreMsgSize      ;Compensate number of spaces for More Message
  MOV  DI,60               ;We want the number of spaces to be 60
  SUB  DI,BP               ;Calculate how far into the Second string
  NEG  DI                  ;  we need to start to accomplish that
  MOV  BP,59               ;BP = New Number of Spaces
  ADD  SI,DI               ;  where we need to start writing
  SUB  AX,DI               ;  of second string
  MOV  DI,MoreMsgSize      ;DI = Size of new first string (More Message)
G20:                       ;Beginning of line is accounted for
  MOV  DS,CS               ;Write the
  MOV  DX,BX               ;  first
  CALL WriteZErr           ;  string
  MOV  DS,ES               ;Point DS:[DX] at the
  MOV  DX,SI               ;  second string
  ADD  DI,AX               ;Calculate total length of both strings
  CMP  DI,79               ;Will it fit on one line?
  JBE >G40                 ;If so, continue
  MOV  BX,(80-MoreMsgSize) ;Calculate how many characters
  SUB  BX,DI               ;  of the second string
  ADD  BX,AX               ;  we need to write
  MOV  AL,[SI+BX]          ;Save the old character in the string
  MOV  B [SI+BX],0         ;Convert it to an end-of-string character
  CALL WriteZErr           ;Write the truncated string
  MOV  [SI+BX],AL          ;Restore the original character of the string
  MOV  DS,CS               ;Write the
  MOV  DX,MoreRightMsg     ;  More Message
G40:                       ;Write last message
  CALL WriteZErr           ;Write it
G90:                       ;Done
  MOV  CX,BP               ;Return CX = number of spaces to write
  POP  ES,DS,BP            ;Restore used registers
  POP  SI,DI,DX,BX,AX      ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;Miscellaneous Command-line related stuff
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;GET OUR REAL PROGRAM NAME
;Inputs:
;Outputs: RealName, RealNameSz
;Changes:
;------------------------------------------------------------------------------
GetRealName:
  PUSH AX,CX,DI,SI      ;Save used registers
  PUSH DS,ES            ;Save used registers
  MOV  DS,[PSPEnvirSeg] ;Point DS and ES
  MOV  ES,DS            ;  at the environment segment
  XOR  DI,DI            ;Point at the beginning of Environment variable list
  MOV  CX,-1            ;Max out the count limiter
  XOR  AX,AX            ;Need to look for a double 0
N10:                    ;Loop to here to skip over environment variables
  REPNE SCASB           ;Look for the end of this environment variable
  CMP  B [DI],0         ;Is it the end of the variable list (double zero)?
  JNE  N10              ;If not, keep skipping over environment variables
  CMP  W [DI+1],0       ;If so, is there at least one string after the env?
  JE  >N90              ;If not, we're done
  LEA  SI,[DI+3]        ;If so, point DS:[SI] at the True Name
  MOV  ES,CS            ;Point ES (for ES:[DI]) at our local data
N20:                    ;Loop to here to skip over drive/path info
  MOV  DI,RealName      ;Point at the beginning of our data area
  XOR  CX,CX            ;Start the length counter at 0
N30:                    ;Loop to here for each character in the name
  LODSB                 ;Get the next character of the name
  CMP  AL,'.'           ;Is it a dot?
  JE  >N40              ;If so, we may have the name
  CMP  AL,BackSlash     ;Is it a path separator?
  JE   N20              ;If so, start looking for the name again
  CALL Capitalize       ;If part of a name, capitalize the character
  STOSB                 ;Store it in our data area
  INC  CX               ;Increment the size counter
  JMP  N30              ;And keep looking for more characters
N40:                    ;We may have the name
  LODSB                 ;Get the next character of the name
  OR   AL,AL            ;End of the name?
  JZ  >N50              ;If so, it really was our program name
  CMP  AL,BackSlash     ;Was it a Directory with a dotted name?
  JE   N20              ;If so, keep looking for a file name
  JMP  N40              ;If not, keep looking for the end of the name
N50:                    ;Have the name
  XOR  AL,AL            ;Store
  STOSB                 ;  a 0
  MOV  CS:RealNameSz,CX ;Store the Size
N90:                    ;We're done
  POP  ES,DS            ;Restore used registers
  POP  SI,DI,CX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE POINTERS TO THE ENVIRONMENT VARIABLES WE NEED
;Inputs:  CS = DS = Local Data Area (also PSP Data Area)
;Outputs: Various Environment Pointers
;Changes:
;------------------------------------------------------------------------------
GetEnvVars:
  PUSH BX,CX,SI                    ;Save used registers
  MOV  SI,PathVarString1           ;Get
  MOV  BX,OFFSET PathVarPointer    ;  the
  MOV  CX,PathVarSize              ;  PATH
  CALL GetEnvVarPointer            ;  Pointer
  JNZ >V20                         ;If OK, continue
  MOV  SI,PathVarString2           ;If no, try
  CALL GetEnvVarPointer            ;  "Path" instead of "PATH"
V20:                               ;Get Program Variable
  MOV  SI,EnvVarString             ;Get
  MOV  BX,OFFSET EnvVarPointer     ;  our
  MOV  CX,EnvVarSize               ;  Program Variable
  CALL GetEnvVarPointer            ;  Pointer
V50:                               ;Get CMDLINE string
  CMP  B [80h],7Eh                 ;Is command line size maxed out?
  JB  >V90                         ;If not, don't worry about CMDLINE Env Var
  MOV  SI,CmdLineVarString         ;Get
  MOV  BX,OFFSET CmdLineVarPointer ;  the
  MOV  CX,CmdLineVarSize           ;  CMDLINE
  CALL GetEnvVarPointer            ;  Pointer
  CALL AdjustCmdLine               ;Compensate CMDLINE Pointer for Program Name
V90:                               ;Done
  POP  SI,CX,BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE POINTER TO AN ENVIRONMENT VARIABLE
;Inputs:   CS = DS = Local Data Area (also contains PSP)
;         [BX] = Where to store the Pointer at
;          CX  = Length of String
;         [SI] = Environment Variable String to Look for (ends in =)
;Outputs: ZF = Set if Error (Variable not found)
;               [BX] = -1
;             = Clear if OK (variable was found)
;               [BX] = Pointer to String (in Environment Segment, NOT PSP!!)
;Changes:
;------------------------------------------------------------------------------
GetEnvVarPointer:
  PUSH AX,CX,SI,BP      ;Save used registers
  PUSH DS,ES            ;Save used registers
  MOV  W [BX],-1        ;Default = -1 (does not exist)
  MOV  ES,[PSPEnvirSeg] ;ES:[DI] =
  XOR  DI,DI            ;  Environment Variable List
  MOV  DX,CX            ;Save the Size
  MOV  BP,SI            ;Save the original Pointer
  XOR  AL,AL            ;Need to look for 0's
V10:                    ;Loop to here for each Environment variable
  MOV  CX,DX            ;CX = Number of bytes to test
  MOV  SI,BP            ;DS:[SI] = String to Test for
  REPE CMPSB            ;Is it a match?
  JZ   >V30             ;If so, continue
  MOV  CX,-1            ;Max out the count limiter
  REPNE SCASB           ;Look for the end of this environment variable
  CMP  B ES:[DI],AL     ;End of Environment?
  JNE  V10              ;If not, keep looking
  JMP >V90              ;If so, no variable
V30:                    ;Found it!
  MOV  [BX],DI          ;Store the Pointer
V90:                    ;Done
  CMP  W [BX],-1        ;Set return flag
  POP  ES,DS            ;Restore used registers
  POP  BP,SI,CX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADJUST THE CMDLINE ENVIRONMENT VARIABLE POINT TO POINT AT THE COMMAND TAIL
;Inputs:  DS = Local Data Area (and PSP Segment)
;         CmdLineVarPtr (-1 if does not exist)
;           Unadjusted for Program Path/Name
;Outputs: CmdLineVarPtr
;           Adjusted (Program Path/Name skipped over to leave Command Tail)
;Changes:
;NOTES: The CMDLINE environment variable, which is only set by SOME
;         versions of DOS, contains the entire contents of the command
;         line.  The "entire contents" includes our executable file name
;         (including the path, if it was provided), but does not include
;         the redirection and/or piping parameters.
;       This routine skips over the executable file name part and simply
;         points at the command tail (the "Options" part of the command line).
;       The CMDLINE variable is used by some versions of DOS (such as 4DOS/NDOS
;         and DOS 95) to allow the command-line to be longer than the 126
;         characters normally allowed by DOS.
;------------------------------------------------------------------------------
AdjustCmdLine:
  PUSH AX,DX,SI,DS             ;Save used registers
  MOV  SI,CmdLineVarPointer    ;[SI] = CMDLINE environment variable contents
  CMP  SI,-1                   ;Anything there?
  JE  >J90                     ;If not, no need for changes
  MOV  DL,"/"                  ;Assume Get SwitchChar function is unsupported
  MOV  AX,3700h                ;Function 3700h (Get DOS SwitchChar)
  INT  21h                     ;Do it (returns DL)
  MOV  DS,[PSPEnvirSeg]        ;DS:[SI] = CMDLINE contents
J10:                           ;Loop to here to skip initial spaces & tabs
  LODSB                        ;Get the next character
  CMP  AL,' '                  ;Space?
  JE   J10                     ;If so, keep skipping
  CMP  AL,Tab                  ;Tab?
  JE   J10                     ;If so, keep skipping
J20:                           ;Skipped initial Tabs & Spaces
  DEC  SI                      ;Point back at the first character
  XOR  AH,AH                   ;Assume no quotes
  CMP  AL,Quote2               ;Double Quote (part of LFN Path & File Name)?
  JNE >J30                     ;If not, continue
  MOV  AH,AL                   ;If so, mark as a quote
  INC  SI                      ;Update the Pointer
J30:                           ;Loop to here for each character
  LODSB                        ;Get next character
  OR   AH,AH                   ;Are we looking for a Quoted Path/File Name?
  JZ  >J40                     ;If not, continue
J35:                           ;Looking for the Closing Quote
  CMP  AL,AH                   ;Is it the Closing Quote?
  JNE >J50                     ;If not, keep looking
  JMP >J85                     ;If so, we're done
J40:                           ;Not a Quoted Path/File Name
  OR   AL,AL                   ;End of variable?
  JE  >J80                     ;If so, handle it
  CMP  AL,' '                  ;Space?
  JE  >J80                     ;If so, we're done
  CMP  AL,Tab                  ;Tab?
  JE  >J80                     ;If so, we're done
  CMP  AL,'/'                  ;Slash?
  JE  >J80                     ;If so, we're done
  CMP  AL,DL                   ;SwitchChar?
  JE  >J80                     ;If so, we're done
J50:                           ;Not end-of-name
  JMP  J30                     ;Keep looking
J80:                           ;[SI-1] = CMDLINE Pointer
  DEC  SI                      ;Point at beginning of string
J85:                           ;[SI] = New CMDLINE Pointer
  MOV  CS:CmdLineVarPointer,SI ;Store it
J90:                           ;Done
  POP  DS,SI,DX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE ENVIRONMENT VARIABLE CONTENTS TO THE SCREEN
;Inputs:  EnvVarPointer (-1 if no Environment variable exists)
;Outputs:
;Changes: Writes to CON or ERR
;------------------------------------------------------------------------------
WriteEnvCon:
  CMP  EnvVarPointer,-1 ;Is there even an Environment variable to write?
  JE  >W90              ;If not, we're done
  PUSH DX,DS            ;Save used registers
  MOV  DX,EnvVarPointer ;Point at the
  SUB  DX,EnvVarSize    ;  beginning of the Variable
  MOV  DS,[PSPEnvirSeg] ;Point at the Environment Segment
  CALL WriteZPause      ;Write it
  POP  DS,DX            ;Restore used registers
W90:                    ;We're done
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;Code to write special messages to the screen (Help, Status, etc.)
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯
;Write Program Help Message
;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯

;------------------------------------------------------------------------------
;PRINT THE SYNTAX HELP MESSAGE AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;Outputs: Writes Help Message to the screen
;Changes: Quits program
;------------------------------------------------------------------------------
DoHelp:
  TEST StatusFlags,Help ;Does the user want help?
  JZ  >H90              ;If not, we're done
  MOV  DX,SyntaxMsgHdr  ;Write the first part of
  CALL WriteZPause      ;  the Help Message
  MOV  DX,RealName      ;Write the Real
  CALL WriteZPause      ;  Program Name
  CALL WriteSpace       ;Write a space
  MOV  DX,SyntaxMsg     ;Point at the last part of the Help Message
  XOR  AL,AL            ;ErrorLevel=0
  JMP  Exit             ;And QUIT
H90:                    ;No need to do help
  RET


;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯
;Write Bad Device List
;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯

;------------------------------------------------------------------------------
;PRINT THE BAD DEVICE TABLE AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;         ES = TSR Data Area
;Outputs: Writes contents of Bad Device Table to the screen
;Changes: Quits program
;         Lots of Registers
;------------------------------------------------------------------------------
DoBadDevices:
  TEST StatusFlags,BadDevices ;Does the user want the Bad Device List?
  JZ  >B000                   ;If not, we're done
  TEST ProgFlags,InMemory     ;Are we installed in memory yet?
  JNZ >B00                    ;If so, continue
  MOV  DX,BadDvcErrMsg        ;If not, point at the first part of Error Message
  JMP  FinishDataErr          ;Terminate program
B000:
  RET

B00:                               ;Write it
  MOV  DX,BadBeepMsg               ;Write the
  CALL WriteZPause                 ;  Beep Header
  MOV  DX,YesMsg                   ;Assume Yes
  TEST ES:TSRFlags,NoBeep          ;Is it Yes?
  JZ  >B05                         ;If so, continue
  MOV  DX,NoMsgS                   ;If not, point at No Message
B05:                               ;Have Beep Status Message
  CALL WriteZPause                 ;Write the Beep Status
  CALL WriteCrLfPause2             ;Move down
  MOV  DX,BadDeviceHdr             ;Write the
  CALL WriteZPause                 ;  Header
  CALL TestSupportFile             ;Look for the Support File in the Path
  XOR  BL,BL                       ;Start Bad Counter at 0
  MOV  SI,BadDeviceTable           ;Point at Bad Table
  MOV  CX,MaxBadDevices            ;Number of Table Entries
B10:                               ;Loop to here for each table entry
  TEST ES:[SI].BDFlags,BDFlagInUse ;Valid Entry?
  JZ  >B40                         ;If not, skip it
  INC  BL                          ;Increment Bad Counter
  CALL WriteSpace                  ;Write
  MOV  AL,ES:[SI].BDHostIndex      ;  the
  CALL ByteToString                ;  Host Index
  CALL Write3Spaces                ;Write
  MOV  AL,ES:[SI].BDDvcAddress     ;  the
  CALL ByteToString                ;  Device Address
  CALL Write3Spaces                ;Write
  MOV  AL,ES:[SI].BDInterfaceNum   ;  the
  CALL ByteToString                ;  Interface Number
  CALL WriteSpace                  ;Move over
  CALL WriteBadStage               ;Write the Stage details
B40:                               ;Go to next entry
  ADD  SI,BadDeviceStrucSize       ;Point at next Entry
  LOOP B10                         ;Keep going until we're done
  OR   BL,BL                       ;Were there any Bad Devices?
  JNZ >B70                         ;If so, we're done
  MOV  DX,NoneFoundMsg             ;If not, write
  CALL WriteZPause                 ;  "None Found" Message
B70:                               ;Done
  MOV  DX,NoMsg                    ;Write nothing when done
  XOR  AL,AL                       ;ErrorLevel=0
  JMP  Exit                        ;And QUIT

;------------------------------------------------------------------------------
;WRITE THE BAD STAGE INFORMATION TO THE SCREEN
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [SI] = Bad Device Table Entry
;                Already checked for Validity (BDFlagInUse = True)
;                Host Index, Device Address, & Interface Number alread written
;Outputs: Write Try, Stage, and Error Code Numbers to the Table
;Changes:
;------------------------------------------------------------------------------
WriteBadStage:
  PUSH AX,CX                       ;Save used registers
  MOV  AL,ES:[SI].BDNewDeviceStage ;Write the
  CALL ByteToString                ;  Stage Number
  CALL Write2Spaces                ;Move over
  MOV  CX,ES:[SI].BDNewDeviceError ;Write the
  CALL WriteBadError               ;  Error Code
  CALL WriteCrLfPause              ;Move down
  POP  CX,AX                       ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;Support Code needed to Write Error Codes
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;WRITE THE ERROR CODE ND APPROPRIATE DESCRIPTION TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         AL = Stage Number
;         CX = Error Code to write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteBadError:
  PUSH AX,CX,DX         ;Save used registers
  XCHG AX,CX            ;AX = Error Code, CL = Stage
  CALL WriteWordHex     ;Write the Error Code
  CALL WriteHexEnd      ;Write an h
  CMP  CL,200           ;Is the stage more than 200?
  JAE >E90              ;If so, the Error Code is meaningless
  CALL Write2Spaces     ;Move over
  TEST ProgFlags,FoundSuptFile ;Is there a Support File in the Path?
  JNZ >E20              ;If so, continue
E10:                    ;No Support File
  MOV  DX,NoSuptFileMsg ;If not, write first part
  CALL WriteZPause      ;  of Error Message
  MOV  DX,SupportFile   ;Write the Support
  CALL WriteZPause      ;  File Name
  JMP >E90              ;Done
E20:                    ;OK to call support File
  TEST CL,1             ;Is it even (TD Status) or odd (Int 14h Error)?
  JZ  >E50              ;If Even, jump to handle it
E40:                    ;Int 14h Error Code (Stage is Odd)
  CALL WriteInt14Err    ;Write the Int 14h Error Code
  JMP >E90              ;Done
E50:                    ;TD Status Code (Stage is Even)
  CALL WriteTDStsErr    ;Write the TD Status Error Code
E90:                    ;Done
  POP  DX,CX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE TD STATS OR INT 14H ERROR DESCRIPTION TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         AX = TD Status Code to write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteTDStsErr:
  PUSH BX,CX,DX           ;Save used registers
  MOV  BX,TDStatusCode    ;[BX] = Where to write Code Number
  MOV  CX,TDStatusCallBk  ;[CX] = Where to write Screen-writing Address
  MOV  DX,TDStatusMsg     ;[DX] = Start of command-tail string
  JMP >R00                ;Do it
WriteInt14Err:
  PUSH BX,CX,DX           ;Save used registers
  MOV  BX,Int14ErrCode    ;[BX] = Where to write Code Number
  MOV  CX,Int14ErrCallBk  ;[CX] = Where to write Screen-writing Address
  MOV  DX,Int14ErrMsg     ;[DX] = Start of command-tail string
;  JMP >R00               ;Do it
R00:
  PUSH AX                 ;Save used registers
  CALL WriteWordToString  ;Write the Error Code to our string
  MOV  BX,CX              ;Write our
  MOV  AX,CS              ;  screen-writing
  MOV  CX,WriteZPauseFar  ;  code address
  CALL WriteSegmentOffset ;  to the string
  MOV  BX,DX              ;Copy our String
  CALL CopyToCmdTail      ;  to the Command Tail String
  CALL DoExec             ;Write the Description
  POP  AX                 ;Restore used registers
  POP  DX,CX,BX           ;Restore used registers
  RET


;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯
;Write External Device Stage
;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯

;------------------------------------------------------------------------------
;WRITE THE DESCRIPTORS OF THE LAST DEVICE TO THE SCREEN, IF NECESSARY
;Inputs:  ES:NewExtDeviceStage
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoExternalStage:
  TEST StatusFlags,ExternalStage ;Anything to do?
  JZ  >X000                      ;If not, we're done
  TEST ProgFlags,InMemory        ;Are we installed in memory yet?
  JNZ >X00                       ;If so, continue
  MOV  DX,ExternalStageErrMsg    ;If not, point at the first part of Error Msg
  JMP  FinishDataErr             ;Terminate program
X000:
  RET

X00:                           ;Write it
  CALL TestSupportFile         ;Look for the Support File in the Path
  MOV  DX,ExternalHdrMsg1      ;Write the
  CALL WriteZPause             ;  Header
  MOV  AL,ES:NewExtDeviceStage ;Write the
  CALL ByteToString            ;  Stage Number
  MOV  DX,ExternalHdrMsg2      ;Write the
  CALL WriteZPause             ;  Header
  MOV  CX,ES:NewExtDeviceError ;Write the Error Code
  CALL WriteBadError           ;  and Description
  MOV  DX,NoMsg                ;Write nothing
  XOR  AL,AL                   ;ErrorLevel = 0
  JMP  Exit                    ;Quit
X90:                           ;Done
  RET


;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯
;Write Command-Line Aliases
;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯

;------------------------------------------------------------------------------
;PRINT THE COMMAND LINE ALIASES AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;Outputs: Writes Aliases to the screen
;Changes: Quits program
;------------------------------------------------------------------------------
DoAliases:
  TEST StatusFlags,Alias  ;Does user want to see the Aliases?
  JZ  >A95                ;If not, we're done
  PUSH BX,DX,SI           ;Save used registers

  CALL WriteCrLfPause     ;Move down
  MOV  DX,AliasHdrMsg     ;Set up
  CALL SetupPause         ;  the Header
  MOV  SI,SwitchList      ;Point at Tbl of Aliases
  MOV  BX,'?'+('Z' SHL 8) ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNoNum   ;Write the Aliases
  MOV  BX,1+(31 SHL 8)    ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNoNum   ;Write the Aliases
  CALL WriteCrLfPause2    ;Move down

  MOV  DX,YesNoHdrMsg     ;Set up
  CALL SetupPause         ;  the Header
  MOV  SI,SwitchListYesNo ;Point at Table of Aliases
  MOV  BX,'N'+('Y' SHL 8) ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNoNum   ;Write the Aliases

A90:                      ;Done
  POP  SI,DX,BX           ;Restore used registers
  MOV  DX,NoMsg           ;Don't write anything
  XOR  AL,AL              ;ErrorLevel = 0
  JMP  Exit               ;Quit
A95:                      ;No need to write Aliases
  RET

;------------------------------------------------------------------------------
;WRITE THE LIST OF SWITCH CHARACTERS TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         BL = Minimum Value to look for in the Table
;         DH = Maximum Value to look for in the Table
;         SI = Switch List ("Code Word") Table
;Outputs: Writes List of Switch Characters to the Screen
;Changes:
;NOTES:   Sets CH =  0 if we write Blocks for Switches < " "
;                 = -1 if we write numbers for the all Switches (0-255)
;                 = -2 if we subtract 128 from the numbers (128-255)
;------------------------------------------------------------------------------
;DoAliasesGoNum:
;  PUSH CX               ;Save used registers
;  MOV  CH,1             ;Mark as writing Numbers, not needing to modify
;  JMP >G00              ;Continue
DoAliasesGoNoNum:
  PUSH CX               ;Save used registers
  XOR  CH,CH            ;Mark as not writing Numbers
;  JMP >G00              ;Continue
G00:
  PUSH AX,DI            ;Save used registers
  MOV  DI,AliasSortTbl  ;Point at the Alias Sort Table
  MOV  AL,BL            ;Start with the Lower Limit
G10:                    ;Loop to here for each Alias
  CALL GetAliasPointers ;Get the Alias Pointers
  JZ  >G60              ;If none for this entry, go to the next one
G20:                    ;Have at least one valid Alias
  CALL WriteCrLfPause   ;If valid, move down
  OR   CH,CH            ;Writing Single characters?
  JNZ >G40              ;If not, handle full numbers
  MOV  CL,78            ;Write this many characters per line
  CMP  AL,' '           ;Is there a valid single-character equivalent?
  JB  >G30              ;If not, don't write it
  CALL WriteAL          ;If so, write it
  JMP >G50              ;Continue
G30:                    ;Not a writable character
  CALL WriteBlock       ;Write a Block Character
  JMP >G50              ;Continue
G40:                    ;Need to write Numbers
  MOV  CL,76            ;Write this many characters per line
  PUSH AX               ;Save the number for a second
  CMP  CH,2             ;Do we need to modify the Number?
  JNE >G45              ;If not, continue
  AND  AL,(NOT 80h)     ;Subtract 128 from it
G45:                    ;Write the Number
  CALL ByteToString     ;Write the Switch as a Number
  POP  AX               ;Restore the Number
G50:                    ;Done writing single character
  CALL WriteAliases     ;Write the Alias List
G60:                    ;Done with this Code
  CMP  AL,BH            ;Have we done the whole list yet?
  JE  >G90              ;If so, we're done
  INC  AL               ;If not, go to the next possibility
  JMP  G10              ;Keep going until we're done
G90:                    ;Done
  POP  DI,AX            ;Restore used registers
  POP  CX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET STRING POINTERS FOR ALL ALIASES FOR A SINGLE CHARACTER OPTION
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;          AL  = Switch Table entry to look for (not 0)
;         [SI] = Switch Table to look through, sorted backwards
;         [DI] = Alias Sort Table
;Outputs:  ZF = Clear if OK
;               [DI] = Filled with String Pointers, sorted backwards
;                      Last Entry is always a 0
;             = Set if no matches found
;                      First Entry is 0
;Changes:
;------------------------------------------------------------------------------
GetAliasPointers:
  PUSH AX,BX,CX,DX      ;Save used registers
  PUSH DI,SI            ;Save used registers
  MOV  CX,DI            ;Sve original pointer
P10:                    ;Loop to here for each Table Entry
  MOV  DX,SI            ;Save beginning Alias Pointer
P20:                    ;Loop to here to find the end of an Alias List Entry
  CMP  B [SI],0         ;End of Alias List?
  JE  >P30              ;If so, handle it
  CALL SkipOverStringSI ;If not, skip over the string
  JMP  P20              ;Keep looking
P30:                    ;End of Alias List Entry
  MOV  BX,SI            ;Save End-of-Entry Pointer
  CMP  AL,[SI+1]        ;Is this entry a match?
  JNE >P50              ;If not, go to the next one
  MOV  SI,DX            ;Point at Alias String
P40:                    ;Loop to here for each Alias String
  CMP  B [SI],0         ;End of the entry?
  JE  >P50              ;If so, we're done
  MOV  [DI],SI          ;If not, store it in the sort table
  INC  DI,2             ;Update the Table Pointer
  CALL SkipOverStringSI ;Skip over the string
  JMP  P40              ;Keep going until we have all of the strings
P50:                    ;Done with this entry
  MOV  SI,BX            ;Get End-of-Entry Pointer
  INC  SI,2             ;Skip over End-of-Entry stuff
  CMP  B [SI],0         ;End of Table?
  JNE  P10              ;If not, keep looking
P90:                    ;Done
  MOV  W [DI],0         ;Make sure last entry is a 0
  CMP  CX,DI            ;Set return flag
  POP  SI,DI            ;Restore used registers
  POP  DX,CX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ALL ALIAS STRINGS FOR A SINGLE CHARACTER OPTION
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = Alias String Pointer Table (Sorted backwards)
;                  Last Entry is a 0
;          CL  = Number of characters left available to write on first line
;                 (76 if Writing Numbers, 78 if Writing Characters)
;         CLD already issued
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteAliases:
  PUSH AX,BX,CX,DX    ;Save used registers
  PUSH DI,SI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at the Local Data Area
  MOV  BL,CL          ;BL = Character Countdown Measurer
  MOV  BH,CL          ;BH = Original Counter
  MOV  DX,DI          ;Save start-of-table Pointer
  MOV  CX,-1          ;Maximize counter
  XOR  AX,AX          ;Find the last
  REPNE SCASW         ;  entry in
  SUB  DI,4           ;  the Table
W10:                  ;Loop to here for each Alias String
  CMP  DI,DX          ;Are we done writing?
  JB  >W90            ;If so, quit
  MOV  SI,[DI]        ;Get the next string
  DEC  DI,2           ;Update the table pointer
  CALL CalcStrSizeSI  ;See how long the string is
  OR   BL,BL          ;Is the character counter down to 0?
  JZ  >W20            ;If so, we need to reset it
  CMP  CL,BL          ;Is this string too long to fit on this line?
  JB  >W40            ;If not, go ahead and write it
W20:                  ;Need to start a new line
  CALL WriteCrLfPause ;Start a new line
  PUSH CX             ;Save String Size for a second
  MOV  CL,79          ;Calculate how many
  SUB  CL,BH          ;  spaces to write
  CALL WriteSpaces    ;Write the spaces
  POP  CX             ;Restore String Size
  MOV  BL,BH          ;Reset the character counter
W40:                  ;Write the Alias String
  SUB  BL,CL          ;Update the
  DEC  BL             ;  character counter
  CALL WriteSpace     ;Write a Space
  CALL WriteZPauseSI  ;Write the string
  JMP  W10            ;Keep writing
W90:                  ;Done
  CALL WriteCrLfPause ;Move down
  POP  ES,SI,DI       ;Restore used registers
  POP  DX,CX,BX,AX    ;Restore used registers
  RET


;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯
;Write the ErrorLevel Table
;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯

;------------------------------------------------------------------------------
;WRITE ERRORLEVEL TABLE TO THE SCREEN AND QUIT
;Inputs:  CS = DS = Local Data Area
;Outputs: Writes ErrorLevel Table to the Screen
;Changes: Quits Program
;         Several registers
;------------------------------------------------------------------------------
DoErrLvls:
  TEST StatusFlags,ErrLvl   ;Does the user want to see the ErrorLevels?
  JZ  >V95                  ;If not quit
  MOV  DX,ErrLvlHdr         ;Write the
  CALL SetupPause           ;  Table Header
  MOV  AL,1                 ;Start with ErrorLevel 1
V10:                        ;Loop to here for each table entry
  MOV  BX,ErrLvlTbl         ;Table to search
  CALL SearchByte2StringTbl ;Valid ErrorLevel?
  JC  >V50                  ;If not, keep looking
  CALL WriteSpace           ;Move Over
  CALL ByteToString         ;If valid, write the Number
  CALL WriteSpace           ;Write a space
  MOV  DX,BX                ;Write the
  CALL WriteZPause          ;  Description String
  CALL WriteCrLfPause       ;Write a New Line
V50:                        ;Done with this entry
  INC  AL                   ;Increment ErrorLevel
  JNZ  V10                  ;If not rolled over yet, keep looking
V90:                        ;Done
  MOV  DX,NoMsg             ;Don't write anything
  XOR  AL,AL                ;ErrorLevel = 0
  JMP  Exit                 ;Quit
V95:                        ;No need to write Aliases
  RET


;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯
;Write Program/Hubs Status
;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯

;------------------------------------------------------------------------------
;WRITE THE CURRENT PROGRAM STATUS TO THE SCREEN
;Inputs:  ES = TSR Data Area
;         Status (Flag)
;Outputs: Writes a bunch of stuff to the screen if Status Flag is True
;Changes:
;------------------------------------------------------------------------------
DoStatus:
  TEST StatusFlags,Status ;Need to to anything?
  JZ  >S000               ;If not, quit
  TEST ProgFlags,InMemory ;Are we installed in memory yet?
  JNZ >S00                ;If so, go ahead and do it
  MOV  DX,StatusErrMsg    ;If not, point at the first part of Error Message
  JMP  FinishDataErr      ;Terminate program
S000:
  RET

S00:
  PUSH AX,CX,DX,DI                  ;Save used registers
  MOV  DX,StatusHeader              ;Write the
  CALL SetupPause                   ;  Header
  XOR  CX,CX                        ;CL = Index, CH = Hub Counter
S10:                                ;Loop to here for each Hub
  CALL DIIndex2Offset               ;  to Offset (DI)
  TEST ES:[DI].DIFlags,DIFlagInUse  ;In Use?
  JZ  >S50                          ;If not, skip this Index
  INC  CH                           ;If so, increment the Hub Counter
  MOV  AL,CL                        ;Write the
  CALL ByteToString                 ;  Index
  CALL WriteSpace                   ;Write
  MOV  AL,ES:[DI].DIHostIndex       ;  the
  CALL ByteToString                 ;  Host Index
  CALL WriteSpace                   ;Write
  MOV  AL,ES:[DI].DIDvcAddress      ;  the
  CALL ByteToString                 ;  Device Address
  CALL WriteSpace                   ;Write
  MOV  AL,ES:[DI].DIInterfaceNum    ;  the
  CALL ByteToString                 ;  Interface Number
  CALL WriteSpace                   ;Write
  MOV  AL,ES:[DI].DIHubCurrent      ;  the
  CALL ByteToString                 ;  Hub Current
  CALL WriteSpace                   ;Move Over
  TEST ES:[DI].DIFlags,DIFlagHubPPP ;Hub supports PPP?
  JNZ >S20                          ;If so, jump to write a Y
  CALL WritePeriod                  ;If not, write a Period
  JMP >S25                          ;Continue
S20:                                ;Hub Supports PPP
  CALL WriteY                       ;Write a Y
S25:                                ;Done with PPP Status
  CALL WriteHostStatus              ;Get and write the Host Status Bits
                                    ;  This also sets up Int14Request
  XOR  AL,AL                        ;Write the
  CALL WriteTotalPower              ;  Total Port Power
  CALL Write2Spaces                 ;Move Over
  CALL WritePorts                   ;Write the Status of all the Ports
  MOV  DX,StatusSeparator           ;Write the
  CALL WriteZPause                  ;  Separator Line
S50:                                ;Done with this Hub
  INC  CL                           ;Increment the Index
  CMP  CL,MaxDevices                ;Have we done them all?
  JNE  S10                          ;If not, keep writing
  OR   CH,CH                        ;Was there at least one hub?
  JNZ >S90                          ;If so, we're done
  MOV  DX,NoHubsMsg                 ;If not, write the
  CALL WriteZPause                  ;  No Hubs Message
S90:                                ;Done
  CALL WriteCrLfPause               ;Write a New Line
  POP  DI,DX,CX,AX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;OBTAIN AND WRITE THE HOST STATUS BITS TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         ES:[DI] = Hub Info Table Entry to write Status of
;                   (contains Host Index and Hub Address)
;Outputs:
;Changes: Writes Status to the Screen
;         DS:Int14Request
;------------------------------------------------------------------------------
WriteHostStatus:
  PUSH AX,CX,DX,SI           ;Save used registers
  MOV  SI,Int14Request       ;Point at Request Structure
  MOV  CX,GetHubStatusReq    ;Copy Control Packet
  CALL CopySetupReqToInt14SI ;  into Reqeust
  CALL GetStatusDWord        ;Schedule the Request
  JC  >H70                   ;If error, handle it
  MOV  AX,DIHChLocalPower    ;Write
  CALL WriteYesNo2           ;  Change in Local Power Status
  MOV  AX,DIHStNoLocalPower  ;Write
  CALL WriteYesNo0           ;  Bus Power Status
  MOV  AX,DIHChOverCurrent   ;Write
  CALL WriteYesNo2           ;  Change in Over Current Status
  MOV  AX,DIHStOverCurrent   ;Write
  CALL WriteYesNo0           ;  Over Current Status
  JMP >H90                   ;Done
H70:                         ;Error getting Status
  MOV  DX,HubStatusErrMsg    ;Write the
  CALL WriteZPause           ;  Error message
H90:                         ;Done
  POP  SI,DX,CX,AX           ;Restore used registers
  RET

;;------------------------------------------------------------------------------
;;OBTAIN AND WRITE THE TOTAL POWER DRAWN BY ALL HUB PORTS COMBINED
;;Inputs:  ES = TSR Data Area
;;         ES:[DI] = Hub Info Table Entry to write Total of
;;Outputs:
;;Changes: Writes Total Power to the Screen
;;------------------------------------------------------------------------------
;WriteTotalPower:
;  PUSH AX,BX,CX,DI            ;Save used registers
;  XOR  BX,BX                  ;Total Power starts with 0
;  XOR  CH,CH                  ;Get the
;  MOV  CL,ES:[DI].DINumPorts  ;  Total Number of Ports
;  ADD  DI,OFFSET DIPort1Power ;Point ES:[DI] at Power Entries
;P10:                          ;Loop to here for each Port
;  MOV  AL,ES:[DI-((OFFSET DIPort1Power)-(OFFSET DIPort1Address))] ;Get Dvc Addr
;  CMP  AL,1                   ;Valid Address?
;  JBE >P50                    ;If not, go to next one
;  CMP  AL,127                 ;Valid Address?
;  JA  >P50                    ;If not, go to next one
;  XOR  AH,AH                  ;Get the
;  MOV  AL,ES:[DI]             ;  Port Power
;  SHL  AX,1                   ;Multipy by 2 (convert to mA)
;  ADD  BX,AX                  ;Add it to the running total
;P50:                          ;Go to next entry
;  INC  DI                     ;Point at the next entry
;  LOOP P10                    ;Keep going until we're done
;  CALL WriteSpace             ;Move Over
;  MOV  AX,BX                  ;Write the
;  CALL WordToString           ;  Total Power
;  POP  DI,CX,BX,AX            ;Restore used registers
;  RET

;------------------------------------------------------------------------------
;WRITE THE TOTAL POWER USED DOWNSTREAM FROM A HUB PORT
;Inputs:  Int14Request with Host Index & Device Address already filled in
;         AL = Port to get Power for (0 if all Ports)
;Outputs: To Screen
;Changes:
;NOTES: If AL = 0 (all ports), we write a space and then a word (5 characters)
;       If AL > 0 (specific port), we use a total of 5 characters
;------------------------------------------------------------------------------
WriteTotalPower:
  PUSH AX,BX,SI            ;Save used registers
  OR   AL,AL               ;Need to write an extra space?
  JNZ >P20                 ;If not, continue
P10:                       ;Write an extra space
  CALL WriteSpace          ;Move over
P20:                       ;Handled extra space, if needed
  MOV  SI,Int14Request     ;If so, point [SI] at the Interrupt 14 Request
  MOV  [SI].I14RRequestType,I14RRTGetHubPowerDraw ;Request Type = Get Power Draw
  MOV  [SI].I14RHubPort,AL ;Store Hub Port
  CALL DoInt14CallBXSI     ;Do it (returns BX = Total Power)
  MOV  AX,BX               ;Write the
  CALL WordToString        ;  Power Draw
  POP  SI,BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE STATUS FO ALL OF THE PORTS ON A HUB
;Inputs:  ES = TSR Data Area
;         ES:[DI] = Hub Info Table Entry to write Port Status of
;Outputs:
;Changes: Writes Port Statuses to the Screen
;------------------------------------------------------------------------------
WritePorts:
  PUSH AX,BX,CX,DX,SI        ;Save used registers
  MOV  SI,Int14Request       ;Point at the Int 14 Request
  MOV  BX,1                  ;Start with Port 1
  JMP >P20                   ;Start Writing
P10:                         ;Loop to here for each Port
  MOV  CL,37                 ;Write a bunch
  CALL WriteSpaces           ;  of spaces
P20:                         ;First Port doesn't need the Spaces
  MOV  AL,BL                 ;Write the
  CALL ByteToString          ;  Port Number
  CALL WriteSpace            ;Move Over
  MOV  AL,ES:[DI+BX-1+(OFFSET DIPort1Address)]
  OR   AL,AL                 ;Empty Address?
  JZ  >P22                   ;If so, Handle it
  CMP  AL,1                  ;Invalid Address?
  JE  >P25                   ;If so, handle it
  CMP  AL,127                ;Invalid Address?
  JA  >P25                   ;If not, handle it
  CALL ByteToString          ;Write the Device Address
  MOV  AL,BL                 ;Write the
  CALL WriteTotalPower       ;  Total Power on the Port
;  MOV  AL,ES:[DI+BX-1+(OFFSET DIPort1Power)]
;  XOR  AH,AH                 ;Multiply Power by 2
;  SHL  AX,1                  ;  (convert to milliamps)
;  CALL WordToString          ;Write it
  JMP >P30                   ;Done with Power
P22:                         ;No Device
  MOV  DX,DashDashMsg        ;Write the
  CALL WriteZPause           ;  Dashes Message
  JMP >P30                   ;Done with Address & Power
P25:                         ;Bad Device
  MOV  DX,BadBadMsg          ;Write the
  CALL WriteZPause           ;  Bad Message
P30:                         ;Done with Address & Power
  MOV  CX,GetPortStatusReq   ;Copy Control Packet
  CALL CopySetupReqToInt14SI ;  into Reqeust
  MOV  B [SI].I14RGetPortStatusPort,BL ;Store Port Number in Request
  CALL GetStatusDWord        ;Get the Status
  JC  >P35                   ;If error, hande it
  CALL WritePortStatus       ;Write the bit-level Status
  JMP >P60                   ;Done
P35:                         ;Problem with Status
  MOV  DX,PortStatusErrMsg   ;Write the
  CALL WriteZPause           ;  Port Error Message
P60:                         ;Done with this Port
  CALL WriteCrLfPause        ;Start a New Line
  INC  BX                    ;Increment the Port Number
  CMP  BL,ES:[DI].DINumPorts ;Done all of the Ports Yet?
  JBE  P10                   ;If not, keep writing
P90:                         ;Done
  POP  SI,DX,CX,BX,AX        ;Restore used registers
  RET

WritePortStatus:
  PUSH AX                   ;Save used registers
  MOV  AX,DIPStPowered      ;Write
  CALL WriteYesNo0          ;  Powered Status
  MOV  AX,DIPChConnect      ;Write
  CALL WriteYesNo2          ;  Change in Connect Status
  MOV  AX,DIPStConnected    ;Write
  CALL WriteYesNo0          ;  Connected Status
  MOV  AX,DIPChEnable       ;Write
  CALL WriteYesNo2          ;  Change in Enabl Status
  MOV  AX,DIPStEnabled      ;Write
  CALL WriteYesNo0          ;  Enabled Status
  MOV  AX,DIPChSuspend      ;Write
  CALL WriteYesNo2          ;  Change in Suspend Status
  MOV  AX,DIPStSuspended    ;Write
  CALL WriteYesNo0          ;  Suspended Status
  MOV  AX,DIPChOverCurrent  ;Write
  CALL WriteYesNo2          ;  Change in Over Current Status
  MOV  AX,DIPStOverCurrent  ;Write
  CALL WriteYesNo0          ;  Over Current Status
  MOV  AX,DIPChReset        ;Write
  CALL WriteYesNo2          ;  Change in Reset Status
  MOV  AX,DIPStReset        ;Write
  CALL WriteYesNo0          ;  Reset Status
  MOV  AX,DIPStLowSpeed     ;Write
  CALL WriteYesNo0          ;  Low Speed Status
  MOV  AX,DIPStHiSpeed      ;Write
  CALL WriteYesNo0          ;  Hi Speed Status
  MOV  AX,DIPStTestMode     ;Write
  CALL WriteYesNo0          ;  Test Mode Status
  MOV  AX,DIPStIndicatSWCtl ;Write
  CALL WriteYesNo0          ;  Software Indicator Control Status
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE STATUS OF A HUB OR PORT
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         DS:[SI] = Int 14 Request to use
;                   Already has Setup Packet copied into the Request
;         ES:[DI] = Hub Info Entry
;Outputs: CF = Clear if it worked OK
;            = Set if Error
;Changes: Schedules Request to get Status of a Hub or a Port onto the USB Bus
;------------------------------------------------------------------------------
GetStatusDWord:
  PUSH AX,BX,DI                              ;Save used registers
  MOV  AX,W ES:[DI].DIHostIndex              ;Copy the Host Index
  MOV  W [SI].I14RHostIndex,AX               ;  and Device Address
  MOV  [SI].I14REndPoint,0                   ;EndPoint 0
  MOV  W [SI].I14RCallBackAddr[2],CS         ;Code to Call
  MOV  W [SI].I14RCallBackAddr[0],StatusDone ;  when done
  MOV  W [SI].I14RDataAddress[2],CS          ;Where to
  MOV  W [SI].I14RDataAddress[0],OFFSET StatusDWord ;  put data
  MOV  [SI].I14RRequestType,I14RRTDoControl  ;Request Type = Control
  MOV  BX,5                                  ;Try it 5 times
  MOV  DI,OFFSET StatusReturnCode            ;[DI] = Status Retrun
S10:                                         ;Loop to here to re-attempt
  MOV  W [DI],-1                             ;Initialize so we know when done
  CALL DoInt14CallSaveAllSI                  ;Do it
  JC  >S70                                   ;If error, quit
S30:                                         ;Loop to here to wait
  CMP  W [DI],-1                             ;Done yet?
  JE   S30                                   ;If not, keep waiting
  CMP  W [DI],0                              ;Error?
  JE  >S80                                   ;If not, it's OK
S70:                                         ;See if we need to try again
  DEC  BX                                    ;Tried enough times yet?
  JZ  >S75                                   ;If so, quit with error
  MOV  AX,BX                                 ;If not,
  INC  AX                                    ;  wait
  SHL  AX,1                                  ;  a few
  CALL DelayMSAX                             ;  milliseconds
  JMP  S10                                   ;Try again
S75:                                         ;Error
  STC                                        ;Set Error Flag
  JMP >S90                                   ;Done
S80:                                         ;OK
  CLC                                        ;Set OK Flag
S90:                                         ;Done
  POP  DI,BX,AX                              ;Restore used registers
  RET

StatusDone:
  MOV  StatusReturnCode,AX
  RETF

;------------------------------------------------------------------------------
;WRITE A YES/NO BIT VALUE TO THE SCREEN
;Inputs:  AX = Value to test with
;         StatusDWord[0] (if WriteYesNo0)
;         StatusDWord[2] (if WriteYesNo2)
;Outputs: Writes Y/N value to the Screen
;Changes:
;------------------------------------------------------------------------------
WriteYesNo0:
  PUSH DI                          ;Save used registers
  MOV  DI,((OFFSET StatusDWord)+0) ;Point at First word of Status
  JMP >Y00                         ;Do it
WriteYesNo2:
  PUSH DI                          ;Save used registers
  MOV  DI,((OFFSET StatusDWord)+2) ;Point at Second word of Status
;  JMP >Y00                         ;Do it
Y00:
  CALL WriteSpace                  ;Write a Space
  TEST AX,[DI]                     ;Is the bit set?
  JNZ >Y20                         ;If so, write a Yes
  CALL WritePeriod                  ;If not, write a Dot
  JMP >Y90                         ;Done
Y20:                               ;Bit is Set
  CALL WriteY                      ;Write a Y
Y90:                               ;Done
  POP  DI
  RET


;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯
;Write Hub/Device/Config Descriptors
;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯

;------------------------------------------------------------------------------
;WRITE THE DESCRIPTORS OF THE LAST DEVICE TO THE SCREEN, IF NECESSARY
;Inputs:  ES:HubDescrData
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoDescriptors:
  TEST StatusFlags,Descriptors ;Does the user want to see the Descriptors?
  JZ  >D000                    ;If not, quit
  TEST ProgFlags,InMemory      ;Are we installed in memory yet?
  JNZ >D00                     ;If so, go ahead and do it
  MOV  DX,DescrErrMsg          ;If not, point at first part of Error Message
  JMP  FinishDataErr           ;Terminate program
D000:
  RET

D00:
  CALL TestLastDevice          ;Anything to do (quits if not)?
  MOV  DI,ES:LastDeviceFound   ;Get Info Table Pointer
  MOV  AX,ES                   ;Write the address
  MOV  CX,DvcDescrData         ;  of the Descriptor Data
  MOV  BX,DescriptorMsgAddr    ;  to the
  CALL WriteSegmentOffset      ;  Command Line Parameters
  MOV  BX,DescriptorMsgHost    ;Write
  MOV  AL,ES:[DI].DIHostIndex  ;  the
  CALL WriteByteToString       ;  Host Index
  INC  BX                      ;  and the
  MOV  AL,ES:[DI].DIDvcAddress ;  Device Address
  CALL WriteByteToString       ;  to the string
  MOV  AX,CS                   ;Write our
  MOV  CX,WriteZPauseFar       ;  Call-Back Address
  MOV  BX,DescriptorCallBk     ;  to the
  CALL WriteSegmentOffset      ;  Command Tail String
  MOV  BX,DescriptorMsg        ;Copy our String
  CALL CopyToCmdTail           ;  to the Command Tail String
  CALL DoExec                  ;Write the Descriptors
  MOV  DX,NoMsg                ;Write nothing
  XOR  AL,AL                   ;ErrorLevel = 0
  JMP  Exit                    ;Quit


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;Support Code needed to Write USB Descriptors
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;TEST AND SEE IF WE CAN PRINT A DESCRIPTOR (LASTDEVICEFOUND & SUPPORTFILE)
;Inputs:  ES = TSR Data Area
;         LastDeviceFound
;Outputs: Quits program if error
;         Initializes PathToUse, Prints Header if OK
;Changes:
;------------------------------------------------------------------------------
TestLastDevice:
  PUSH AX,DX,SI                    ;Save used registers
  MOV  SI,ES:LastDeviceFound       ;Get the Device Pointer that this is for
  TEST ES:[SI].DIFlags,DIFlagInUse ;Device still there?
  JNZ >L10                         ;If so, continue
  MOV  DX,NoDescrDataMsg           ;Point at Error Message
  MOV  AL,ErLvlNoData              ;ErrorLevel = No Data
  JMP  Exit                        ;Quit
L10:                               ;Have some Data
  CALL TestSupportFile             ;Look for the Support File in the Path
  JNZ >L20                         ;If found, continue
  MOV  DX,NoSuptFileMsg            ;If not, write first part
  CALL WriteZErr                   ;  of Error Message
  MOV  DX,SupportFile              ;Write the
  CALL WriteZErr                   ;  File Name
  JMP  Exit                        ;Quit

L20:                               ;Everything is OK
  MOV  DX,HostIndexMsg             ;Write
  CALL WriteZPause                 ;  the
  MOV  AL,ES:[SI].DIHostIndex      ;  Host
  CALL ByteToString                ;  Index
  CALL WriteCrLfPause              ;Write a new line
  MOV  DX,DvcAddressMsg            ;Write
  CALL WriteZPause                 ;  the
  MOV  AL,ES:[SI].DIDvcAddress     ;  Device
  CALL ByteToString                ;  Address
  CALL WriteCrLfPause2             ;Write 2 new lines
L90:                               ;Done
  POP  SI,DX,AX                    ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO DELAY FOR A LITTLE WHILE
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;DELAY FOR A GIVEN NUMBER OF MILLISECONDS
;Inputs:  AX = number of milliseconds to wait (0-65,535)
;Outputs:
;Changes:
;------------------------------------------------------------------------------
DelayMSAX:
  PUSH AX,BX,DX  ;Save used registers
  OR   AX,AX     ;Is there anything to do?
  JZ  >D90       ;If not, just quit
  MOV  DX,1000   ;Convert
  MUL  DX        ;  to
  MOV  BX,AX     ;  microseconds (DX:BX)
D10:             ;Loop to here for each 65535 uS
  OR   DX,DX     ;Counted down high word yet?
  JZ  >D30       ;If so, handle it
  DEC  DX        ;Decrement high word
  MOV  AX,-1     ;Maximum microseconds
  JMP >D50       ;Do it
D30:             ;Counted down high word
  OR   BX,BX     ;Anything to do?
  JZ  >D90       ;If not, we're done
  MOV  AX,BX     ;Get Low Word
  XOR  BX,BX     ;Make sure it's zero next time
D50:             ;AX = Microseconds to wait
  CALL DelayUSAX ;Delay the number of microseconds specified
  JMP  D10       ;See if we need to wait some more
D90:             ;We're done
  POP  DX,BX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DELAY FOR A GIVEN NUMBER OF MICROSECONDS
;Inputs:  AX = number of microseconds to wait (0-65535)
;Outputs:
;Changes:
;   NOTE: Delays will be slightly longer than what's asked for, never shorter.
;         Accuracy decreases with small delays or slow computers!
;------------------------------------------------------------------------------
DelayUSAX:
  PUSH AX,BX           ;Save used registers
  OR   AX,AX           ;Is there anything to do?
  JZ  >D90             ;If not, just quit
  MOV  BX,AX           ;Put it in BX
  MOV  AX,(0FFFFh/3)+1 ;Maximum time for each sub-delay
D10:                   ;Loop to here for each sub-delay
  CMP  BX,AX           ;Is it more than the maximum?
  JA  >D40             ;If so, just do the sub-delay
  MOV  AX,BX           ;If not, just do the remainder that's left
D40:                   ;Do the delay
  CALL DoDelayUS       ;Do the US Delay
  SUB  BX,AX           ;SUbtract out how long we just waited
  JNZ  D10             ;If not 0 yet, do the sub-delay again
D90:                   ;We're done
  POP  BX,AX           ;Restore used registers
  RET

DoDelayUS:
  PUSH AX,BX,CX,DX ;Save used registers
  SHL  AX,1        ;Multiply by 2
  MOV  BX,11932    ;Compensate for the fact
  MUL  BX          ;  that the clock frequency
  MOV  BX,10000    ;  is actually
  DIV  BX          ;  1.19318 MHz
  MOV  DX,AX       ;Save it
  CLI              ;Disable interrupts
  CALL GetTimer    ;Get the starting timer tick counter
  MOV  CX,AX       ;Save it
D20:               ;Keep looping to here until we've waited long enough
  MOV  BX,CX       ;Get the starting timer tick counter
  CALL GetTimer    ;Get the current timer tick counter
  SUB  BX,AX       ;Calculate the elapsed time
  CMP  BX,DX       ;Has it been long enough?
  JB   D20         ;If not, keep waiting
  STI              ;Enable interrupts
D90:               ;We're done
  POP  DX,CX,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET CURRENT TIMER COUNTER FROM PORT 40h (THE CLOCK INTERRUPT)
;Inputs:
;Outputs: AX = Current timer counter word
;Changes:
;------------------------------------------------------------------------------
GetTimer:
  MOV  AL,06h ;Bits 7:6 =  00 = Timer 0
              ;Bits 5:4 =  00 = Latch Counter
              ;Bits 3:1 = 011 = Mode 3 (Square Wave)
              ;Bit    0 =   0 = Binary Counter (16 bits)
  OUT  43h,AL ;Tell the PIT what wer'e going to do
  IN   AL,40h ;Get LSB of timer counter
  MOV  AH,AL  ;Save it
  IN   AL,40h ;Get MSB of timer counter
  XCHG AH,AL  ;Put things in the right order
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;Code to test and see if the computer is compatible or not.
;Tests DOS Version, Hardware installed, etc. as appropriate to make sure
;  we don't do something that could crash the computer.
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;TEST THE COMPUTER TO SEE IF IT'S COMPATIBLE (CPU, DOS VERSION, WHATEVER)
;Inputs:  InMemory
;Outputs: Quits the program if Computer is Incompatible
;         Returns if Computer is OK
;         Stores all kinds of values in memory variables
;Changes:
;------------------------------------------------------------------------------
TestCompatibility:
  PUSH AX,DX              ;Save used registers
  TEST ProgFlags,InMemory ;Are we already installed?
  JNZ >C90                ;If so, no need to test again
  MOV  AL,ErLvlDOSVer     ;Assume incorrect
  MOV  DX,DOSVerMsg       ;  DOS Version
  CALL TestDOSVer         ;  new enough?
  JC  >C70                ;If not, quit
  MOV  AL,ErLvlNoHost     ;Assume Host Driver
  MOV  DX,NoHostMsg       ;  is not installed
  CALL TestUSBHost        ;Is there a USB Host Driver installed?
  JNC >C90                ;If not, we're OK
C70:                      ;The computer is incompatible for some reason
  JMP  Exit               ;Quit!
C90:                      ;The computer is compatible!
  POP  DX,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST THE CURRENT DOS VERSION
;Inputs:  MinDOSVer (EQUate)
;Outputs: CF = Clear if DOS version >= MinDOSVer
;         CF = Set if DOS version < MinDOSVer
;Changes:
;------------------------------------------------------------------------------
TestDOSVer:
  PUSH AX,BX,CX     ;Save used registers
  MOV  AX,3000h     ;Service 30h (get DOS version number)
                    ;  DOS 5.0 requires AL = 00h, may change BX and CX
  INT  21h          ;Do it (Returns AL= Major, AH = Minor)
  XCHG AL,AH        ;Swap Major and Minor versions for testing
  CMP  AX,MinDOSVer ;Is the version new enough?
  JAE >D80          ;If so, it's OK
D70:                ;DOS is older than the minimum
  STC               ;Set the "too old" flag
  JMP >D90          ;We're done
D80:                ;DOS is >= the minimum
  CLC               ;Set the OK flag
D90:                ;We're done
  POP  CX,BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A COMPATIBLE USB HOST DRIVER IS INSTALLED
;Inputs:
;Outputs: CF = Set if error (No Host Driver Installed)
;            = Clear if OK
;Changes:
;------------------------------------------------------------------------------
TestUSBHost:
  PUSH AX,BX,CX ;Save used registers
  MOV  AX,5000h ;Function 5000h (Install Check)
  MOV  BX,'US'  ;Set
  MOV  CX,'B!'  ;  registers
  STC           ;Preset Error Flag
  INT  14h      ;Do it
  JC  >U70      ;If Error, USB Host can't be installed
  OR   AX,AX    ;Is AX Correct?
  JNZ >U70      ;If not, Error
  CMP  BX,'B!'  ;Is BX correct?
  JNE >U70      ;If not, Error
  CMP  CX,'US'  ;Is CX correct?
  JE  >U80      ;If so, it's installed
U70:            ;Not installed
  STC           ;Set Error Flag
  JMP >U90      ;Done
U80:            ;Installed
  CLC           ;Set OK flag
U90:            ;Done
  POP  CX,BX,AX ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO SET UP COMMAND TAIL WITH PROPER PARAMETERS FOR EXEC CALL
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;WRITE A SEGMENT:OFFSET COMBINATION TO A STRING VARIABLE
;Inputs:   AX  = Segment to Write
;          CX  = Offset to Write
;         [BX] = String to Write to
;Outputs: Converts AX:CX to a Hex String and stores at [BX]
;Changes:
;------------------------------------------------------------------------------
WriteSegmentOffset:
  PUSH AX,DI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at Local Data Area
  MOV  DI,BX          ;Point DI at String
  CALL Word2HexString ;Store the Segment
  MOV  AL,':'         ;Store the
  STOSB               ;  Colon
  MOV  AX,CX          ;Store
  CALL Word2HexString ;  the Offset
  POP  ES,DI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A WORD AS HEX TO A STRING
;Inputs:   AX  = Word to Write
;         [BX] = String to write to
;Outputs:
;Changes: BX
;------------------------------------------------------------------------------
WriteWordToString:
  PUSH AX,DI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at Local Data Area
  MOV  DI,BX          ;Point DI at String
  CALL Word2HexString ;Store the Word
  MOV  AL,'h'         ;Write the
  STOSB               ;  'h'
  ADD  BX,5           ;Update Pointer
  POP  ES,DI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE AS HEX TO A STRING
;Inputs:  AL   = Byte to Write
;         [BX] = String to write to
;Outputs:
;Changes: BX
;------------------------------------------------------------------------------
WriteByteToString:
  PUSH AX,DI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at Local Data Area
  MOV  DI,BX          ;Point DI at String
  CALL Byte2HexString ;Store the Byte
  MOV  AL,'h'         ;Write the
  STOSB               ;  'h'
  ADD  BX,3           ;Update Pointer
  POP  ES,DI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY A STRING INTO THE COMMAND TAIL
;Inputs:  [BX] = ASCIIZ String to Copy
;Outputs: To CmdTail
;Changes:
;------------------------------------------------------------------------------
CopyToCmdTail:
  PUSH AX,CX,DX,DI,SI,ES ;Save used registers
  MOV  ES,DS             ;Point ES at Local Data Area
  MOV  CX,(CmdTailMax/2) ;Number of Words to Copy
  MOV  AX,CR+(CR SHL 8)  ;Fill with CR's
  MOV  DI,CmdTail        ;Point at Command Tail
  PUSH DI                ;Save Pointer
  REP  STOSW             ;Fill the Command Tail
  POP  DI                ;Restore Pointer
  MOV  DX,BX             ;Calculate number of bytes
  CALL CalcStrSizeDX     ;  to copy
  MOV  CmdTailSize,CL    ;Store the Command Tail Size
  MOV  SI,BX             ;Copy the string
  REP  MOVSB             ;  to the Command Tail
  POP  ES,SI,DI,DX,CX,AX ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO EXEC ANOTHER PROGRAM
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;SETUP PARAMETERS TO BE ABLE TO PERFORM THE EXEC FUNCTION
;Inputs:
;Outputs:
;Changes: Lots of stuff
;------------------------------------------------------------------------------
SetupExec:
  PUSH AX,SI                       ;Save used registers
  MOV  SI,ParamBlock               ;Point at Parameter Block
  MOV  AX,CS                       ;Use our data segment
  MOV  [SI].PBEnvirSegment,0       ;Use Copy of our Environment
  MOV  W [SI].PBCmdTailPtr[0],OFFSET CmdTailSize
  MOV  W [SI].PBCmdTailPtr[2],AX   ;Command Tail Pointer
  MOV  W [SI].PBFCB1Offset[0],FCB1
  MOV  W [SI].PBFCB1Offset[2],AX   ;FCB #1 Pointer
  MOV  W [SI].PBFCB2Offset[0],FCB2
  MOV  W [SI].PBFCB2Offset[2],AX   ;FCB #1 Pointer
  POP  SI,AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PERFORM THE EXEC FUNCTION
;Inputs:  ParamBlock set up with appropriate data
;         CmdTail/CmdTailSize set up with appropriate Info
;         PathToUse contains Child Program to Call
;         DS = Our data Area
;Outputs: CF = Clear if Program Returned ErrorLevel 0
;Changes: Performs EXEC Function
;------------------------------------------------------------------------------
DoExec:
  PUSH ES            ;Save used register
  MOV  ES,DS         ;Point ES at our Data Area
  PUSH AX,BX,CX,DX   ;Save all registers
  PUSH DI,SI,BP      ;Save all registers
  MOV  OldSPExec,SP  ;Save the Stack Pointer (may be destroyed by Call)
  MOV  DX,PathToUse  ;DS:[DX] = Child Program to Run
  MOV  BX,ParamBlock ;ES:[BX] = Parameter Block
  MOV  AX,4B00h      ;Function 4B00h (Load and Execute child program)
  INT  21h           ;Do it (May Destroy BX & DX)
  JC  >X70           ;If Error, quit
X00:                 ;When the Child Program Exits, here we are!
  CLD                ;Go forward with string functions
  CLI                ;Disable interrupts
  MOV  DS,CS         ;Restore
  MOV  ES,DS         ;  all
  MOV  SS,CS         ;  Segments
  MOV  SP,OldSPExec  ;Restore Stack Pointer
  STI                ;Enable interrupts
  MOV  AH,4Dh        ;Function 4Dh (Get ErrorLevel)
  INT  21h           ;Do it (Returns AH = Term Type, AL = ErrorLevel)
  OR   AL,AL         ;ErrorLevel 0?
  JZ  >X80           ;If so, it was OK
X70:                 ;Error
  STC                ;Set Error Flag
  JMP >X90           ;Done
X80:                 ;OK
  CLC                ;Set OK Flag
X90:                 ;Done
  POP  BP,SI,DI      ;Restore all registers
  POP  DX,CX,BX,AX   ;Restore all registers
  POP  ES            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;LOOK FOR THE SUPPORT FILE SOMEHWERE IN THE PATH
;Inputs:  DS = Local Data Area
;         SupportFile
;         ProgFlags.FoundSuptFile = False
;Outputs: ZF = Clear if Support File Found
;              ProgFlags.FoundSuptFile = True
;Outputs: ZF = Set if Support File Not Found
;              ProgFlags.FoundSuptFile = False
;Changes:
;------------------------------------------------------------------------------
TestSupportFile:
  PUSH DI,SI                ;Save used registers
  MOV  SI,OFFSET ProgFlags  ;Point [SI] at ProgFlags
  MOV  DI,SupportFile       ;Look for the
  CALL FindSupportFile      ;  Support File
  JC  >S90                  ;If not found, quit
  OR   B [SI],FoundSuptFile ;If found, mark it as found
S90:                        ;Done
  TEST B [SI],FoundSuptFile ;Set return flag
  POP  SI,DI                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE LOCATION OF THE SUPPORT FILE
;Inputs:  [DI] = FIleName to Look for
;Outputs: CF = Clear if OK (File Found)
;              PathToUse = Path & FileName Concatenated Together
;            = Set if Error (File not Found)
;              PathToUse = Undefined
;Changes: Various Path pointer Registers (OurPathPointer, PathVarPointer, etc.)
;------------------------------------------------------------------------------
FindSupportFile:
  PUSH AX,SI,DS,ES       ;Save used registers
F10:                     ;Do Our Path
  MOV  SI,OurPathPointer ;Point SI at our Path pointer
  CMP  SI,-1             ;Valid?
  JE  >F20               ;If not, skip it
  MOV  AX,[PSPEnvirSeg]  ;Point ES at
  MOV  ES,AX             ;  Environment Segment
  CALL CopyPathName      ;Copy it
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F20:                     ;Do Current Path
  MOV  ES,CS             ;Point ES at us
  MOV  SI,CurrentPath    ;If not, try the Current Path
  CALL CopyPathName      ;Copy it
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F30:                     ;Do Environment PATH
  MOV  SI,PathVarPointer ;SI = Environment PATH Pointer
  CMP  SI,-1             ;Is it valid?
  JE  >F70               ;If not, we're done
  MOV  AX,[PSPEnvirSeg]  ;Point ES at Path
  MOV  ES,AX             ;  (Environment) Segment
F35:                     ;Loop to here for each element in PATH
  CALL CopyPathName      ;Copy the PATH element
  JC  >F70               ;If End of Path, we're done
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F40:                     ;Loop to here to skip over PATH Element
  MOV  AL,ES:[SI]        ;Get next character
  INC  SI                ;Increment Pointer
  OR   AL,AL             ;End of PATH?
  JZ  >F70               ;If so, we're done
  CMP  AL,';'            ;End of PATH Element?
  JNE  F40               ;If not, Keep looking
  JMP  F35               ;Try the next Element
F70:                     ;Error
  STC                    ;Set Error Flag
  JMP >F90               ;Done
F80:                     ;Found our File
  CLC                    ;Set OK flag
F90:                     ;Done
  POP  ES,DS,SI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEE IF THE SUPPORT FILE EXISTS
;Inputs:  PathToUse
;Outputs: CF = Clear if OK (File Found)
;            = Set if Error (File not Found)
;Changes:
;------------------------------------------------------------------------------
FindFile:
  PUSH AX,BX,CX,DX   ;Save used registers
  PUSH DS,ES         ;Save used registers
  MOV  AH,2Fh        ;Function 2Fh (Get DTA Address)
  INT  21h           ;Do it (returns ES:BX)
  MOV  AH,1Ah        ;Function 1Ah (Set DTA Address)
  MOV  DX,FCB1       ;DS:DX = New DTA Address
  INT  21h           ;Do it
  MOV  AX,4E00h      ;Function 4Eh (Find First Matching File)
  MOV  CX,FAttrToUse ;Search for any file, including Hidden
  MOV  DX,PathToUse  ;DS:DX = ASCIIZ FileName to search for
  INT  21h           ;Do it (returns CF)
  PUSHF              ;Save return flag
  MOV  DS,ES         ;Point DS:DX
  MOV  DX,BX         ;  at the old DTA
  MOV  AH,1Ah        ;Function 1Ah (Set DTA Address)
  INT  21h           ;Do it
  POPF               ;Restore return flag
  POP  ES,DS         ;Restore used registers
  POP  DX,CX,BX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CREATE A COMPLETE PATH NAME GIVEN A PATH AND A FILE NAME
;Inputs:  ES:[SI] = Path name to Copy
;         DS:[DI] = FileName to Append to the Path
;Outputs: PathToUse = Path & File Concatenated Together
;NOTES: The Path String can either end with a 0 (ASCIIZ String) or a SemiColon
;         (the way strings are stored in the PATH Environment variable).
;       This code will properly handle an empty Path String, which will
;         simply set PathToUse to the FileName.
;       The FileName must be an ASCIIZ String.
;------------------------------------------------------------------------------
CopyPathName:
  PUSH AX,BX,CX,DI,SI,DS,ES  ;Save used registers
  PUSH DS                    ;Point ES
  PUSH ES                    ;  at our data,
  POP  DS                    ;  DS at
  POP  ES                    ;  Path Data
  MOV  BX,DI                 ;Save File Name Pointer
  XOR  AX,AX                 ;Fill with Zeroes
  MOV  CX,(MaxPathSize/2)    ;Number of Words to Write
  MOV  DI,PathToUse          ;Where to write them
  PUSH DI                    ;Save Pointer
  REP  STOSW                 ;Reset the Buffer
  POP  DI                    ;Restore Pointer
  XOR  CL,CL                 ;Start String Length Counter at 0
N10:                         ;Loop to here for each character in Path
  LODSB                      ;Get next character
  OR   AL,AL                 ;End of Path?
  JZ  >N20                   ;If so, do Filename
  CMP  AL,';'                ;End of Path (Environment PATH)?
  JE  >N20                   ;If so, do FileName
  INC  CL                    ;Increment String Length Counter
  STOSB                      ;If not, store the character
  JMP  N10                   ;Keep going
N20:                         ;Done with Path
  OR   CL,CL                 ;Any characters at all in the Path?
  JZ  >N30                   ;If so, is Current Path, and don't want backslash!
  CMP  B ES:[DI-1],Backslash ;Path ends in a Backslash?
  JE  >N30                   ;If so, it's OK
  MOV  AL,Backslash          ;If not, store
  STOSB                      ;  a Backslash
N30:                         ;Path is OK
  MOV  DS,ES                 ;Point DS:[SI]
  MOV  SI,BX                 ;  at the File Name
N40:                         ;Loop to here for each character in File name
  LODSB                      ;Get next character
  OR   AL,AL                 ;End of File Name?
  JZ  >N90                   ;If so, we're done
  STOSB                      ;If not, store it
  JMP  N40                   ;Keepgoing
N90:                         ;Done
  POP  ES,DS,SI,DI,CX,BX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE PATH THAT OUR PROGRAM IS IN
;Inputs:
;Outputs: OurPathPointer = Pointer to Our Path String (in Environment Segment)
;                        = -1 if we couldn't find our own Path
;Changes:
;------------------------------------------------------------------------------
GetOurPath:
  PUSH AX,CX,DI,SI,DS,ES    ;Save used registers
  MOV  AX,[PSPEnvirSeg]     ;Point DS & ES
  MOV  DS,AX                ;  at the
  MOV  ES,AX                ;  Environment segment
  XOR  DI,DI                ;Point at the beginning of Environment list
  MOV  CX,-1                ;Max out the count limiter
  XOR  AX,AX                ;Need to look for a double 0
N10:                        ;Loop to here to skip over Environment vars
  REPNE SCASB               ;Look for the end of this environment variable
  CMP  [DI],AL              ;Is it the end of the variable list (double 0)?
  JNE  N10                  ;If not, keep skipping over Environment vars
  CMP  [DI+1],AX            ;If so, is there a string after the Envir?
  JE  >N70                  ;If not, we're done
  ADD  DI,3                 ;Point DI and SI at the
  MOV  SI,DI                ;  True Name
  MOV  CS:OurPathPointer,DI ;Store the Pointer
N20:                        ;Loop to here to find the end of the PATH
  LODSB                     ;Get the next character of the name
  CMP  AL,':'               ;Is it a Colon?
  JE  >N30                  ;If so, possible end-of-path
  CMP  AL,Backslash         ;Is it backslash?
  JE  >N30                  ;If so, possible end-of-path
  OR   AL,AL                ;End of File Name?
  JZ  >N50                  ;If so, we're done
  JMP >N40                  ;If not, keep looking
N30:                        ;Update end-of-path Pointer
  MOV  DI,SI                ;Save possible end-of-path pointer
N40:                        ;Not end-of-path yet
  JMP  N20                  ;Keep looking
N50:                        ;At end of Path
  CMP  DI,CS:OurPathPointer ;Was there a real path?
  JE  >N70                  ;If not, error
  MOV  B [DI],0             ;If OK, put 0 at end of Path
  JMP >N90                  ;Done
N70:                        ;No Path
  MOV  CS:OurPathPointer,-1 ;Set Pointer
N90:                        ;Done
  POP  ES,DS,SI,DI,CX,AX    ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO AUTOMATICALLY MOVE THE PROGRAM INTO UPPER MEMORY
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;TRY TO ALLOCATE A UMB, AND COPY THE PROGRAM TO THE UMB SEGMENT
;Inputs:  DS = ES = Current Data Segment
;Outputs: ES = New Data Segment (in UMB or Low Memory Hole)
;              If no UMB or Low Memory Hole is available, ES remains unchanged
;         Entire TSR Portion of Program is copied to new Segment
;Changes:
;------------------------------------------------------------------------------
MoveProgramToUMB:
  PUSH AX,BX,CX,DX,DI,SI      ;Save used registers
  MOV  AX,DS                  ;Save original Data Segment
  CMP  AX,0A000h              ;Already in Upper Memory?
  JAE >U90                    ;If so, just quit
  TEST ProgFlags,UseLowMemory ;Does user want us in Low Memory?
  JNZ >U90                    ;If so, just quit
  MOV  BX,(LastTSRByte SHR 4) ;Number of Paragraphs to Allocate
  CALL AllocateUMBDOS         ;Try to get a UMB from DOS (Returns ES)
  JZ  >U90                    ;If it didn't work, quit
  MOV  DX,ES                  ;Save new Segment
  PUSH DS                     ;Save data Segment
  MOV  AX,DS                  ;Point DS
  DEC  AX                     ;  at current
  MOV  DS,AX                  ;  MCB
  MOV  AX,ES                  ;Point ES
  DEC  AX                     ;  at new
  MOV  ES,AX                  ;  MCB
  MOV  SI,OFFSET MCBOwnerName ;Copy
  MOV  DI,SI                  ;  the
  MOV  CX,4                   ;  Owner
  REP  MOVSW                  ;  Name
  POP  DS                     ;Restore Data Segment
  MOV  ES:[MCBOwnerID],DX     ;Make itself the Owner
  MOV  AH,26h                 ;Function 26h (Create new PSP, DX = Segment)
  INT  21h                    ;Do it
  MOV  ES,DX                  ;Point ES at new Segment again
  ADD  DX,BX                  ;Calculate where next Segment will be
  MOV  ES:[PSPNextSegment],DX ;Store it in the PSP
  MOV  CL,3                   ;Calculate
  SHL  BX,CL                  ;  number
  MOV  CX,BX                  ;  of words
  SUB  CX,(PSPStrucSize/2)    ;  to Copy
  MOV  SI,PSPStrucSize        ;SI = Old Data
  MOV  DI,SI                  ;DI = New Data
  REP  MOVSW                  ;Copy Program to new Segment
  OR   ProgFlags,MemoryMoved  ;Mark memory as having been moved
U90:                          ;Done
  POP  SI,DI,DX,CX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TRY TO ALLOCATE A UMB THROUGH DOS
;Inputs:  BX = Number of Paragraphs to Allocate
;Outputs: ZF = Clear if OK
;              ES = Segment of Allocated UMB
;            = Set if Error
;              ES = Unchanged
;Changes:
;NOTES: Allocating USB's through DOS normally requires a
;         DOS=HIGH,UMB line in CONFIG.SYS
;------------------------------------------------------------------------------
AllocateUMBDOS:
  PUSH AX,BX,CX,DX   ;Save used registers
  PUSH DI,SI         ;Save used registers
  MOV  CX,ES         ;Save original ES
  MOV  DI,BX         ;Save Number of Paragraphs to Allocate
  MOV  AX,5800h      ;Function 5800h (Get Memory Allocation Strategy)
  INT  21h           ;Do it (returns AX)
  JC  >D90           ;If error, quit
  MOV  SI,AX         ;If OK, save it
  MOV  AX,5802h      ;Function 5802h (Get UMB Link State - DOS 5+ Only)
  INT  21h           ;Do it (Returns AL)
  JC  >D90           ;If error, quit
  MOV  DL,AL         ;If OK, Save it
  MOV  BX,UMBLinkYes ;Enable UMB's in DOS Memory Chain
  MOV  AX,5803h      ;Function 5803h (Set UMB Link State)
  INT  21h           ;Do it
  JC  >D90           ;If error, quit
  MOV  BX,StrategyHighLowBest ;Strategy = Try High, then Low, Best Fit
  MOV  AX,5801h      ;Do
  INT  21h           ;  it
  JC  >D80           ;If error, quit
D20:                 ;Strategy is set
  MOV  BX,DI         ;BX = # of Paragraphs to Allocate
  MOV  AH,48h        ;Function 48h (Allocate Memory)
  INT  21h           ;Do it (returns AX = Segment)
  JC  >D80           ;If error, quit
  MOV  ES,AX         ;If OK, put Segment in ES
  CMP  AX,0A000h     ;Is it really a UMB?
  JAE >D80           ;If so, continue
  MOV  DI,CS         ;If not, is it a memory "hole" lower in memory
  CMP  AX,DI         ;  than we are (from a previously removed TSR)?
  JB  >D80           ;If so, continue
  MOV  AH,49h        ;Function 49h (Free Memory, Segment in ES)
  INT  21h           ;Do it
  MOV  ES,CX         ;Restore original ES
D80:                 ;Restore original UMB Link State & Strategy
  XOR  BH,BH         ;Restore
  MOV  BL,DL         ;  original
  MOV  AX,5803h      ;  UMB
  INT  21h           ;  Link State
  MOV  BX,SI         ;Restore original
  MOV  AX,5801h      ;  Memory Allocation
  INT  21h           ;  Strategy
D90:                 ;Done
  MOV  AX,ES         ;Set
  CMP  CX,AX         ;  Return Flag
  POP  SI,DI         ;Restore used registers
  POP  DX,CX,BX,AX   ;Restore used registers
  RET


;;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;;CODE TO SET UP A DATA STORAGE SEGMENT AT THE TOP OF CONVENTIONAL MEMORY
;;  This is needed because if UMBPCI (or anoterh similar program) is used
;;    to allocate UMB's insted of a program like EMM386, we can't access
;;    the UMB's with DMA or PCI Bus Mastering.  Any data that the PCI Host
;;    Controller needs to talk to must be in conventional memory.
;;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;
;;Test for UMB support.
;;Test for VCPI, install in UMB if so.  If Real Mode & not VPCI, install low
;
;
;;Inputs:
;
;
;  DataSegment DW ? ;Segment of our data area in conventional memory
;
;
;AllocateMem:
;  PUSH AX,BX,DX,ES        ;Save used registers
;  ;Need to set up memory allocation strategy?
;  MOV  AH,48h             ;Function 48h (Allocate Memory)
;  MOV  BX,-1              ;Number of Paragraphs = 65535
;  INT  21h                ;Do it (should return error)
;                          ;  Returns CF, BX = Maximum Size
;  JNC >A75                ;If no error, we have a problem!
;  SUB  BX,((2048+(OFFSET PSPFiller1)+16+15) SHR 4) ;BX = # bytes to allocate
;                          ;  (Leave size of Data Area
;                          ;    + partial PSP
;                          ;    + 1 paragraph for MCB)
;  MOV  AH,48h             ;Function 48h (Allocate Memory)
;  INT  21h                ;Do it (returns CF, AX = Segment)
;  JC  >A75                ;If error, quit
;  MOV  ES,AX              ;Store the Segment
;  MOV  BX,((2048+(OFFSET PSPFiller1)+15) SHR 4) ;BX = # Paragraphs to allocate
;  MOV  AH,48h             ;Function 48h (Allocate Memory)
;  INT  21h                ;Do it (returns CF, AX = Segment)
;  JC  >A70                ;If error, quit
;  MOV  DataSegment,AX     ;Store the Segment Address
;  MOV  AH,49h             ;Function 49h (Free Memory Segment at ES)
;  INT  21h                ;Do it
;  MOV  DX,AX              ;DX = New Segment
;  DEC  AX                 ;Point ES
;
;;Copy Name?
;
;;Use INT 21h, Function 5803h to see if UMB's exist in DOS
;
;  MOV  ES,AX              ;  at the MCB
;  MOV  ES:[MCBOwnerID],DX ;Make itself the Owner (so DOS won't delete it)
;  MOV  ES,DX              ;ES = New Segment
;  MOV  AH,26h             ;Function 26h (Create new PSP, DX = Segment)
;  INT  21h                ;Do it
;  ADD  DX,((2048+(OFFSET PSPFiller1)+15) SHR 4) ;DX = Next Segment to use
;  MOV  ES:[PSPNextSegment],DX ;Store it in the PSP
;  JMP >A80                ;Done
;A70:                      ;Error - unallocate memory
;  MOV  AH,49h             ;Function 49h (Free Memory Segment at ES)
;  INT  21h                ;Do it
;A75:                      ;Error
;  STC                     ;Set return flag
;  JMP >A90                ;Done
;A80:                      ;OK
;  CLC                     ;Set return flag
;A90:                      ;Done
;  POP  ES,DX,BX,AX        ;Restore used registers
;  RET
;
;
;;--------D-2148-------------------------------
;;INT 21 - DOS 2+ - ALLOCATE MEMORY
;;        AH = 48h
;;        BX = number of paragraphs to allocate
;;Return: CF clear if successful
;;            AX = segment of allocated block
;;        CF set on error
;;            AX = error code (07h,08h) (see #01680 at AH=59h/BX=0000h)
;;            BX = size of largest available block
;;Notes:  DOS 2.1-6.0 coalesces free blocks while scanning for a block to
;;          allocate
;;        .COM programs are initially allocated the largest available memory
;;          block, and should free some memory with AH=49h before attempting any
;;          allocations
;;        under the FlashTek X-32 DOS extender, EBX contains a protected-mode
;;          near pointer to the allocated block on a successful return
;;SeeAlso: AH=49h,AH=4Ah,AH=58h,AH=83h
;;
;;
;;--------D-2149-------------------------------
;;INT 21 - DOS 2+ - FREE MEMORY
;;        AH = 49h
;;        ES = segment of block to free
;;Return: CF clear if successful
;;        CF set on error
;;            AX = error code (07h,09h) (see #01680 at AH=59h/BX=0000h)
;;Notes:  apparently never returns an error 07h, despite official docs; DOS 2.1+
;;          code contains only an error 09h exit
;;        DOS 2.1-6.0 does not coalesce adjacent free blocks when a block is
;;          freed, only when a block is allocated or resized
;;        the code for this function is identical in DOS 2.1-6.0 except for
;;          calls to start/end a critical section in DOS 3.0+
;;SeeAlso: AH=48h,AH=4Ah
;;
;;
;;--------D-214A-------------------------------
;;INT 21 - DOS 2+ - RESIZE MEMORY BLOCK
;;        AH = 4Ah
;;        BX = new size in paragraphs
;;        ES = segment of block to resize
;;Return: CF clear if successful
;;        CF set on error
;;            AX = error code (07h,08h,09h) (see #01680 at AH=59h/BX=0000h)
;;            BX = maximum paragraphs available for specified memory block
;;Notes:  under DOS 2.1-6.0, if there is insufficient memory to expand the block
;;          as much as requested, the block will be made as large as possible
;;        DOS 2.1-6.0 coalesces any free blocks immediately following the block
;;          to be resized
;SeeAlso: AH=48h,AH=49h,AH=83h






;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;SPACE AND CODE TO PROCESS OUR PROGRAM STACK
;  This code and must be physically at the END of the Program,
;    but must be one of the FIRST procedures called by the Program.
;  In addition, the Stack Pointer (SP) must be set properly
;    (to LastProgByte - 2) BEFORE this code is called.
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;RESIZE OUR MEMORY ALLOCATION TO THE MINIMUM SIZE NEEDED
;Inputs:  SP = LastProgByte - 2
;         ES = Local Segment
;Outputs: Rellocates Memory to the minimum size required to run the program
;Changes:
;------------------------------------------------------------------------------
ResizeMemory:
  PUSH AX,BX  ;Save used registers
  MOV  AH,4Ah ;Function 4Ah (Resize Memory Block pointed at by ES)
  MOV  BX,(LastProgByte SHR 4) ;BX = Number of Paragraphs to Resize to
  INT  21h    ;Do it
  POP  BX,AX  ;Restore used registers
  RET

  EVEN 16
  DB (ProgStackSize/8) DUP ('PrgStack')

LastProgByte:
