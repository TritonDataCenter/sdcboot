  JMP Main ;Skip over Data to Main Program


;==============================================================================
;NOTE: This program is written for and compiled with Eric Isaacson's A386
;      assembly language compiler, using Options +P3 -F (80386+ CPU and
;      no FPU).
;==============================================================================


;Disable more stuff in S option so transition isn't so slow?  Disable
;  SMI?  Repoint Controller Code?


;In DOCS:



;哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌
;EQUATE/STRUCTURE/MACRO DEFINITIONS
;苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘

;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;EQUATES
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;==============================================================================
;Miscellaneous
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special Codes
  ;----------------------------------------------------------------------------
  No  EQU  0 ;Miscellaneous Yes/No tests
  Yes EQU -1 ;      "        "  "    "


;==============================================================================
;CPU Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Bit masks in the CPU Flags Register
  ;----------------------------------------------------------------------------
  CarryFlag  EQU 0001h ;Carry Flag
  ParityFlag EQU 0004h ;Parity Flag
  AuxFlag    EQU 0010h ;Auxiliary Flag
  ZeroFlag   EQU 0040h ;Zero Flag
  SignFlag   EQU 0080h ;Sign Flag
  TrapFlag   EQU 0100h ;Trap Flag
  IntFlag    EQU 0200h ;Interrupt Flag
  DirFlag    EQU 0400h ;Direction Flag
  OFFlag     EQU 0800h ;Overflow Flag


;==============================================================================
;CONsole/Screen Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special ASCII Characters
  ;----------------------------------------------------------------------------
  Tab       EQU  9 ;Tab
  LF        EQU 10 ;Line Feed
  FormFeed  EQU 12 ;FormFeed
  CR        EQU 13 ;Carriage Return
  EOF       EQU 26 ;End-of-File
  Quote2    EQU 34 ;Double quote
  Quote1    EQU 39 ;Single quote
  BackSlash EQU 92 ;BackSlash (\)

  ;----------------------------------------------------------------------------
  ;Special Keys that can be pressed during Pause routine
  ;----------------------------------------------------------------------------
  CtrlC  EQU  3 ;Control-C Keystroke
  Escape EQU 27 ;Escape Keystroke


;==============================================================================
;DOS Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;;Minimum DOS Version required to use this program
  ;----------------------------------------------------------------------------
  MinDOSVer EQU 0300h

  ;----------------------------------------------------------------------------
  ;DOS Memory Allocation Strategies
  ;----------------------------------------------------------------------------
  StrategyLowFirst     EQU 00h ;First Fit, Low Memory Only
  StrategyLowBest      EQU 01h ;Best Fit, Low Memory Only
  StrategyLowLast      EQU 02h ;Last Fit, Low Memory Only
  ;For DOS 3&4, anything >2 is Last Fit Low Memory
  ;Below are for DOS 5+ Only
  StrategyHighFirst    EQU 40h ;First Fit, High Memory Only
  StrategyHighBest     EQU 41h ;Best Fit, High Memory Only
  StrategyHighLast     EQU 42h ;Last Fit, High Memory Only
  StrategyHighLowFirst EQU 80h ;First Fit, Try High Memory then Low Memory
  StrategyHighLowBest  EQU 81h ;Best Fit, Try High Memory then Low Memory
  StrategyHighLowLast  EQU 82h ;Last Fit, Try High Memory then Low Memory

  ;----------------------------------------------------------------------------
  ;UMB Link States
  ;----------------------------------------------------------------------------
  UMBLinkNo  EQU 00h ;UMB's are not part of DOS Memory Chain
  UMBLinkYes EQU 01h ;UMB's are in DOS Memory Chain (DOS=HIGH,UMB in CONFIG.SYS)

  ;----------------------------------------------------------------------------
  ;Sizes of various DOS data structures
  ;----------------------------------------------------------------------------
  FCBSize     EQU  44 ;Size of DOS File Control Block
  CmdTailMax  EQU 128 ;Maximum size of a DOS Command Tail
  MaxPathSize EQU  64 ;Maximum Size of a DOS Path/FileName String

  ;----------------------------------------------------------------------------
  ;Special "hard-coded" DOS Device Handles.
  ;These Handles are permanently hard-coded in DOS, and are always open.
  ;There is no need to issue Find, Open, or Close calls to these
  ;  devices - you can just use them at will.
  ;----------------------------------------------------------------------------
  StdInHandle  EQU 0 ;Standard Input Device Handle
  StdOutHandle EQU 1 ;Standard Output Device Handle
  StdErrHandle EQU 2 ;Standard Error Device Handle
  StdAuxHandle EQU 3 ;Standard Auxiliary Device Handle (COM1 by default)
  StdPrnHandle EQU 4 ;Standard Printer Device Handle (LPT1 by default)

  ;----------------------------------------------------------------------------
  ;Codes returned by INT 21h, Function 4400h (Get Device Information)
  ;----------------------------------------------------------------------------
  ;If bit 7 is Set (is a Device):
  DvcInfoIsStdIn    EQU 0001h ;STDIN
  DvcInfoIsStdOut   EQU 0002h ;STDOUT
  DvcInfoIsNUL      EQU 0004h ;NUL
  DvcInfoIsClock    EQU 0008h ;CLOCK$
  DvcInfoInt29h     EQU 0010h ;Uses Int 29h (Special Device)
  DvcInfoBinary     EQU 0020h ;Binary (Raw) Mode
  DvcInfoEOF        EQU 0040h ;EOF on Input
  DvcInfoIsDevice   EQU 0080h ;Is a Device (not a File)
  DvcInfoKEYB       EQU 0100h ;Unknown (set by DOS 6.2x KEYB program)
  DvcInfoOpenClose  EQU 0800h ;Supports Open/Close calls
  DvcInfoOutputBusy EQU 2000h ;Supports Output until Busy
  DvcInfoIOCTL      EQU 4000h ;Can process IOCTL requests (INT 21h, Func 4402h)

  ;If bit 7 is Clear (is a File):
  DvcInfoDriveMask    EQU 003Fh ;Drive number (0 = A:)
  DvcInfoNotWritten   EQU 0040h ;File has not been written (Dirty Buffer?)
  ;Bit 7 = Clear!
  DvcInfoInt24h       EQU 0100h ;Generate Int 24h on Errors (DOS 4 only)
  DvcInfoNotRemovable EQU 0800h ;Media Not Removable
  DvcInfoNoDateTime   EQU 4000h ;Don't set File Date/Time on Closing (DOS 3.0+)
  DvcInfoRemote       EQU 8000h ;File is Remote (DOS 3.0+)


;==============================================================================
;USB Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;General
  ;----------------------------------------------------------------------------
  Int14RequestSize EQU 64 ;Size of Int 14 USB Request Data Structure

  ;----------------------------------------------------------------------------
  ;Status Codes returned by GetHostStatus
  ;----------------------------------------------------------------------------
  HostStatusRunning   EQU  01h ;Host is running Normally
  HostStatusStopped   EQU  02h ;Host is Stopped/Halted
  HostStatusSuspended EQU  03h ;Host is in Global Suspend Mode
  HostStatusDebugMode EQU  04h ;Host is in Debug (Single-Step) Mode
  HostStatusUnknown   EQU 0FFh ;Host is in a Unknown/Unrecognized Mode


;==============================================================================
;PCI Related
;Including USB-specific data stored in the PCI Configuration Space
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Programming Interfaces for USB Controllers.
  ;----------------------------------------------------------------------------
  ProgIntfUHCI EQU 00h ;UHCI
  ProgIntfOHCI EQU 10h ;OHCI
  ProgIntfEHCI EQU 20h ;EHCI

  ;----------------------------------------------------------------------------
  ;Offsets of base PCI Registers.  These are common to all PCI Devices.
  ;Any offsets above these are Device-specific.
  ;----------------------------------------------------------------------------
  PCIVendorID           EQU   00h ;Vendor ID Register
  PCIProductID          EQU   02h ;Product ID Register
  PCICfgCmd             EQU   04h ;Configuration Command Register
    PCICfgIOAccess      EQU 0001h ;I/O Access Enable
    PCICfgMemoryAccess  EQU 0002h ;Memory Access Enable
    PCICfgBusMaster     EQU 0004h ;Bus Master Enable
    PCICfgSpecialCycle  EQU 0008h ;Special Cycle Recognition Enable
    PCICfgMemWriteInv   EQU 0010h ;Memory Write and Invalidate Enable
    PCICfgVGASnoop      EQU 0020h ;VGA Palette Snoop Enable
    PCICfgParityErr     EQU 0040h ;Parity Error Response Enable
    PCICfgWaitCycles    EQU 0080h ;Wait Cycles Enable
    PCICfgSysErrLine    EQU 0100h ;System Error Line (SERR#) Enable
    PCICfgBack2Back     EQU 0200h ;Fast Back-to-Back Transactions Enable
    PCICfgIntDisable    EQU 0400h ;Do NOT allow Interrupts to be generated
    ;Bits 11-15 = Reserved
  PCIStatus             EQU   06h ;PCI Status Register (all bits R/WC, NOT R/W)
    ;Bits 0-2 = Reserved
    PCIStsIntAsserted   EQU 0008h ;Interrupt is Asserted
    PCIStsCapabilities  EQU 0010h ;Capabilities List
    PCISts66MHzCapable  EQU 0020h ;Capable of 66 MHz
    PCIStsUserFeatures  EQU 0040h ;User Defined Features
    PCIStsBack2Back     EQU 0080h ;Fast Back-to-Back Capable
    PCIStsDataParityErr EQU 0100h ;Data Parity Error Detected
    PCIStsDevSelTiming  EQU 0600h ;Device Select # Timing Status (2 bits)
    PCIStsSigTargAbort  EQU 0800h ;Signaled Target Abort
    ;Bit 12 = Reserved (0)
    PCIStsRxMasterAbort EQU 2000h ;Received Master Abort
    ;Bit 14 = Reserved (0)
    PCIStsDetParityErr  EQU 8000h ;Detected Parity Error

  ;----------------------------------------------------------------------------
  ;These are ones we need for USB Hosts.
  ;----------------------------------------------------------------------------
  PCIBaseMemAddr        EQU         10h ;Base Memory Address (OHCI/EHCI, DWord)
    OHCIMemMask         EQU 0FFFF_F000h ;Mask for OHCI Base Memory Address
    EHCIMemMask         EQU 0FFFF_FF00h ;Mask for EHCI Base Memory Address
    EHCIMem64           EQU 00000_0004h ;Address may use 64-bit memory
  PCIBaseIOAddr         EQU         20h ;Base I/O Address (UHCI, Word)
    UHCIIOMask          EQU      0FFE0h ;Mask for I/O Base Address
  PCIIRQNum             EQU         3Ch ;IRQ Number (OHCI/UHCI/EHCI)
  PCIUSBVersion         EQU         60h ;USB Version (UHCI/EHCI, Byte)
  PCIEFrameLengthAdj    EQU         61h ;Frame Length Adjustment (EHCI, B)
    EFrameLenMask       EQU         3Fh ;Only uses lower 6 bits (0-63)
  PCIEPortWakeCap       EQU         62h ;Port Wake Capabilities (EHCI, Opt, W)
    EPortWakeSupp       EQU       0001h ;BIOS uses this optional register
                                        ;If used, bits 1-15 indicate that Ports
                                        ;  1-15 can be used for Remote Wakeup
  PCIULegacySupp        EQU        0C0h ;Legacy Support Info (UHCI)
    ULSSMI60REn         EQU       0001h ;SMI# on Port 60h Read Enable  RW
    ULSSMI60WEn         EQU       0002h ;SMI# on Port 60h Write Enable  RW
    ULSSMI64REn         EQU       0004h ;SMI# on Port 64h Read Enable  RW
    ULSSMI64WEn         EQU       0008h ;SMI# on Port 64h Write Enable  RW
    ULSSMIUSBIRQEn      EQU       0010h ;SMI# on USB IRQ Enable  RW
    ULSA20PassThruEn    EQU       0020h ;A20 Gate Pass Through Enable  RW
    ULSA20PassThruSts   EQU       0040h ;A20 Gate Pass Through Status  RO
    ULSSMIEndPassThruEn EQU       0080h ;SMI# at End of Pass Through Enable  RW
    ULSTrap60R          EQU       0100h ;Trap by Port 60h Read Status  RWC
    ULSTrap60W          EQU       0200h ;Trap by Port 60h Write Status  RWC
    ULSTrap64R          EQU       0400h ;Trap by Port 64h Read Status  RWC
    ULSTrap64W          EQU       0800h ;Trap by Port 64h Write Status  RWC
    ULSUSBIRQSts        EQU       1000h ;USB IRQ Status (1=USB IRQ Active)  RO
    ULSUSBPIRQEn        EQU       2000h ;USB PIRQD Enable (1=IRQ Enabled)   RW
    ;Bit 14 = Reserved
    ULSA20EndPasThruSts EQU       8000h ;End of A20 Gate Pass Through Status  RWC

  ;----------------------------------------------------------------------------
  ;EHCI Legacy Support Extended Capabilities
  ;2 DWords, Offset in PCI Configuration Space stored in Base Memory
  ;----------------------------------------------------------------------------
  EXCapability          EQU          0  ;Offset from EECP Offset stored in BAR
    EXCapabilityMask    EQU 00000_00FFh ;Capabilities ID Mask
      EXCLegacySupp     EQU         01h ;Extended Capability = Legacy Support
    EXCapNextCapMask    EQU 00000_FF00h ;Offset in PCI Space of Next Capability

  ;----------------------------------------------------------------------------
  ;EHCI Legacy Support
  ;----------------------------------------------------------------------------
    ELSBIOSSemaphore    EQU 00001_0000h ;BIOS-Owned Semaphore
    ;Bits 17-23 = Reserved
    ELSSysSemaphore     EQU 00100_0000h ;System-Owned Semaphore
    ;Bits 25-31 = Reserved

  ;----------------------------------------------------------------------------
  ;EHCI Legacy Support Control/Status (2nd DWord)
  ;----------------------------------------------------------------------------
  EXLSCtrlStatus        EQU          4  ;Offset from EECP Offset stored in BAR
    ELSSMICompleteEn    EQU 00000_0001h ;SMI on USB Complete Enable
    ELSSMIUSBErrorEn    EQU 00000_0002h ;SMI on USB Error Enable
    ELSSMIPortChgEn     EQU 00000_0004h ;SMI on Port Change Enable
    ELSSMIFrameRollEn   EQU 00000_0008h ;SMI on Frame List Rollover Enable
    ELSSMISysErrorEn    EQU 00000_0010h ;SMI on Host System Error Enable
    ELSSMIAsyncAdvEn    EQU 00000_0020h ;SMI on Async Advance Enable
    ;Bits 06-12 = Reserved
    ELSSMIOSOwnerEn     EQU 00000_2000h ;SMI on OS Ownership Enable
    ELSSMIPCICmdEn      EQU 00000_4000h ;SMI on PCI Command Enable
    ELSSMIBaseAddrEn    EQU 00000_8000h ;SMI on Base Memory Address Enable
    ;These bits shadow the EUSBStatus Register
    ELSSMIComplete      EQU 00001_0000h ;SMI on USB Complete
    ELSSMIUSBError      EQU 00002_0000h ;SMI on USB Error
    ELSSMIPortChg       EQU 00004_0000h ;SMI on Port Change
    ELSSMIFrameRoll     EQU 00008_0000h ;SMI on Frame List Rollover
    ELSSMISysError      EQU 00010_0000h ;SMI on Host System Error
    ELSSMIAsyncAdv      EQU 00020_0000h ;SMI on Async Advance
    ;Bits 22-28 = Reserved
    ELSSMIOSOwner       EQU 02000_0000h ;SMI on OS Ownership
    ELSSMIPCICmd        EQU 04000_0000h ;SMI on PCI Command
    ELSSMIBaseAddr      EQU 08000_0000h ;SMI on Base Memory Address


;==============================================================================
;EHCI Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;EHCI Frame Length Base Value (16 High-Speed Bit Times)
  ;----------------------------------------------------------------------------
  EFrameLenBase EQU 59488 ;Base of Frame-Length Adjustment Register
                          ;  PCIEFrameLengthAdj adds to this to get the bus rate

  ;----------------------------------------------------------------------------
  ;Offsets from the Base Memory Address for various data elements
  ;EHCI Capabilities Registers
  ;----------------------------------------------------------------------------
  ECapabilityLen    EQU         00h ;Capability Length (Byte) (Op Regs follow)
  ;1 Byte Reserved
  EHCIVersion       EQU         02h ;HCI Version (Word) BCD, High Byte = Major
  EStrucParams      EQU         04h ;Structural Parameters (DWord)
    ENumPortsMask   EQU 00000_000Fh ;Number of Ports (1-15)
    EPortPwrCtl     EQU 00000_0010h ;Port Power Control
    ;Bits 05-06 = Reserved
    EPtRoutingRules EQU 00000_0080h ;Port Routing Rules
    EPtsPerCompMask EQU 00000_0F00h ;Number of Port Per Companion Controller
    ENumCompMask    EQU 00000_F000h ;Number of Companion Controllers
    EPtIndicators   EQU 00001_0000h ;LED Indicator Control supported
    ;Bits 17-19 = Reserved
    EDebugPortMask  EQU 000F0_0000h ;Debug Port Number
    ;Bits 24-31 = Reserved
  ECapabilityParams EQU         08h ;Capability Parameters (DWord)
    E64BitAddr      EQU 00000_0001h ;64-bit Addressing Supported
    EProgFrameLen   EQU 00000_0002h ;Frame List Length is Programmable
    EAsyncParkSupt  EQU 00000_0004h ;Asynchronous Schedule Park Supported
    ;Bit 3 = Reserved
    EIsochSchedThr  EQU 00000_00F0h ;Isochronous Scheduling Threshold
    EExCapPtrMask   EQU 00000_FF00h ;Extended Capabilites Offset (EECP)
                                    ;  in PCI Configuration Space
    ;Bits 16-31 = Reserved
  EPortRouting      EQU         0Ch ;Companion Port Routing Description
                                    ;Array of Nibbles, only valid if
                                    ;  EPtRoutingRules = 1

  ;----------------------------------------------------------------------------
  ;Offsets from the Base Memory + ECapabilityLen for various data elements
  ;EHCI Operational Registers
  ;----------------------------------------------------------------------------
  ECommand           EQU         00h ;USB Command Register
    ECRunStop        EQU 00000_0001h ;Run/Stop
    ECHostReset      EQU 00000_0002h ;Host Controller Reset
    ECFrListSizeMask EQU 00000_000Ch ;Frame List Size Mask
      ECFrList1024   EQU 00000_0000h ;Frame List = 1024 Elements (4096 Bytes)
      ECFrList512    EQU 00000_0004h ;Frame List =  512 Elements (2048 Bytes)
      ECFrList256    EQU 00000_0008h ;Frame List =  256 Elements (1024 Bytes)
      ECFRListResv   EQU 00000_000Ch ;Reserved
    ECPerSchedEn     EQU 00000_0010h ;Periodic Schedule Enable
    ECAsyncSchedEn   EQU 00000_0020h ;Asynchronous Schedule Enable
    ECIntAsyncAdvDB  EQU 00000_0040h ;Interrupt On Async Advance Doorbell
    ECLightReset     EQU 00000_0080h ;Light Host Controller Reset
    ECAsyncParkCount EQU 00000_0300h ;Asynchronous Sechedule Park Mode Count
    ;Bit 10 = Reserved
    ECAsyncParkEn    EQU 00000_0800h ;Asynchronous Park Mode Enable
    ;Bits 12-15 = Reserved
    ECIntThreshMask  EQU 000FF_0000h ;Interrupt Threshold (def = 8 = 1ms)
                                     ;1, 2, 4, 8, 16, 32, 64
                                     ;Maximum Interrupt Rate in micro-frames
    ;Bits 24=31 = Reserved
  EStatus            EQU         04h ;USB Status Register
    ESUSBInt         EQU 00000_0001h ;USB Interrupt
    ESUSBErrInt      EQU 00000_0002h ;USB Error Interrupt
    ESPortChgDetect  EQU 00000_0004h ;Port Change Detect
    ESFrameListRoll  EQU 00000_0008h ;Frame List Rollover
    ESSystemErr      EQU 00000_0010h ;Host System Error
    ESIntAsyncAdv    EQU 00000_0020h ;Interrupt on Async Advance
    ;Bits 06-11 = Reserved
    ESHostHalted     EQU 00000_1000h ;Host Halted
    ESReclamation    EQU 00000_2000h ;Reclamation (Async Schedule Empty)
    ESPerSchedSts    EQU 00000_4000h ;Periodic Schedule Status (Enabled)
    ESAsyncSchedSts  EQU 00000_8000h ;Async Schedule Status (Enabled)
    ;Bits 16-31 = Reserved
  EIntEnable         EQU         08h ;Interrupt Enable Register
    EIUSBIntEn       EQU 00000_0001h ;USB Interrupt enable
    EIUSBErrIntEn    EQU 00000_0002h ;USB Error Interrupt Enable
    EIPtChgIntEn     EQU 00000_0004h ;Port Change Interrupt Enable
    EIFrLstRollIntEn EQU 00000_0008h ;Frame List Rollover Interrupt Enable
    EISysErrIntEn    EQU 00000_0010h ;Host System Error Interrupt Enable
    EIAsyncAdvIntEn  EQU 00000_0020h ;Interrupt on Async Advance Enable
    ;Bits 06-31 = Reserved
  EFrameIndex        EQU         0Ch ;Frame Index (Frame Number)
    EFrameIdxMask    EQU 00000_3FFFh ;Only uses 14 bits
                                     ;  Lower 3 bits = Microframe
    ;Bits 14-31 = Reserved
  ECtrlDSSegment     EQU         10h ;Control DS Segment (if 64-bit Memory)
  EPerListAddr       EQU         14h ;Periodic Frame List Memory Address
    EPerListMask     EQU 0FFFF_F000h ;Must be 4K-Page aligned
  EAsyncListAddr     EQU         18h ;Asynchronouse List Memory Address
    EAsyncListMask   EQU 0FFFF_FFE0h ;Must be 32-byte aligned
  EConfigFlag        EQU         40h ;Configure Flag
    EConfigured      EQU 00000_0001h ;Host is Configured
    ;Bits 01-31 = Reserved
  EPortSC1           EQU         44h ;Port 1 Status & Control
    EPtConnStatus    EQU 00000_0001h ;Connect Status
    EPtConnStatChg   EQU 00000_0002h ;Connect Status Change
    EPtPortEnable    EQU 00000_0004h ;Port Enabled
    EPtPortEnChg     EQU 00000_0008h ;Port Enabled/Disabled Status has changed
    EPtOverCurrSts   EQU 00000_0010h ;OverCurrent Detected
    EPtOverCurrChg   EQU 00000_0020h ;OverCurrent Detection Change
    EPtResumeDetect  EQU 00000_0040h ;Resume Detect
    EPtSuspend       EQU 00000_0080h ;Port in Suspend State
    EPtReset         EQU 00000_0100h ;Port in Reset State
    ;Bit 09 = Reserved
    EPtLineStsMask   EQU 00000_0C00h ;Line Status
      EPtLineStsSE0  EQU 00000_0000h ;Status = SE0
      EPtLineStsJ    EQU 00000_0400h ;Status = J-state
      EPtLineStsK    EQU 00000_0800h ;Status = K-state
      EPtLineStsErr  EQU 00000_0C00h ;Status = Undefined
    EPtPortPower     EQU 00000_1000h ;Port Power
    EPtPortOwnerComp EQU 00000_2000h ;Port Owner = Companion
    EPtPortIndicator EQU 00000_C000h ;Port Indicator Control
      EPtIndOff      EQU 00000_0000h ;Port Indicator = Off
      EPtIndAmber    EQU 00000_4000h ;Port Indicator = Amber (Yellow)
      EPtIndGreen    EQU 00000_8000h ;Port Indicator = Green
      EPtIndErr      EQU 00000_C000h ;Port Indicator = Undefined
    EPtTestControl   EQU 0000F_0000h ;Port Test Control
      EPtTestNone    EQU 00000_0000h ;Test Mode = not Enabled
      EPtTestJ       EQU 00001_0000h ;Test J-state
      EPtTestK       EQU 00002_0000h ;Test K-state
      EPtTestSE0     EQU 00003_0000h ;Test SE0-NAK
      EPtTestPacket  EQU 00004_0000h ;Test Packet
      EPtTestEnable  EQU 00005_0000h ;Test Force-Enable
      ;All other values = Reserved
    EPtWakeOnConnEn  EQU 00010_0000h ;Wake on Connect Enable
    EPtWakeOnDiscEn  EQU 00020_0000h ;Wake on Disconnect Enable
    EPtWakeOnOCurEn  EQU 00040_0000h ;Wake on Over-Current Enable
    ;Bits 23-31 = Reserved


;==============================================================================
;UHCI Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;UHCI Frame Timing Base Value
  ;----------------------------------------------------------------------------
  USOFModifyBase EQU 11936 ;Base of Start-of-Frame Modify Register
                           ;  USOFModify adds to this to get the bus rate

  ;----------------------------------------------------------------------------
  ;UHCI Offsets from the Base I/O Address for various data elements
  ;----------------------------------------------------------------------------
  UCommand          EQU 0000h ;Offset to USB Command Register (Word)  RW
    UCRunStop       EQU 0001h ;Run/Stop
    UCHostReset     EQU 0002h ;Host Controller Reset
    UCGlobalReset   EQU 0004h ;Global Reset
    UCGlobalSuspend EQU 0008h ;Enter Global Suspend Mode
    UCGlobalResume  EQU 0010h ;Force Global Resume
    UCSoftDebug     EQU 0020h ;Software Debug Mode
    UCConfigured    EQU 0040h ;Configure Flag = Host Controller Configured
    UCMaxPkt64      EQU 0080h ;Max Pkt Size = 64 bytes (Bandwidth Reclamation)
  UStatus           EQU 0002h ;Offset to USB Status (Word)  RWC
    USUSBInt        EQU 0001h ;USB Interrupt
    USUSBErrInt     EQU 0002h ;USB Error Interrupt
    USResumeDetect  EQU 0004h ;Resume Detect
    USSystemErr     EQU 0008h ;Host Controller System Error
    USProcessorErr  EQU 0010h ;Host Controller Processor Error
    USHostHalted    EQU 0020h ;Host Controller Halted
    USErrorMask     EQU 001Fh ;All Errors Mask (excludes HC Halted)
  UIntEnable        EQU 0004h ;Offset to USB Interrupt Enable Register (Word)
    UITimeoutCRC    EQU 0001h ;Timeout/CRC Interrupt Enable
    UIResume        EQU 0002h ;Resume Interrupt Enable
    UIIntOnComplete EQU 0004h ;Interrupt On Complete Enable
    UIShortPkt      EQU 0008h ;Short Packet Interrupt Enable
  UFrameNum         EQU 0006h ;Offset to Current Frame Number (Word, 0-1023)RW
    UFrNumIndexMask EQU 03FFh ;Mask to convert Frame Number to Frame Index
                              ;  (Frame number actually goes from 0-2047)
    UFrNumNumMask   EQU 07FFh ;To make sure no extra bits are there
  UFrameListAddr    EQU 0008h ;Offset to Current Frame List Address (DWord) RW
  USOFModify        EQU 000Ch ;Offset to Start of Frame Modify (Byte)
                              ;SOF Timing = 11936 + this (0-127, def = 64)
  UPortSC1          EQU 0010h ;Offset to Port 1 Status/Control (Word)
  UPortSC2          EQU 0012h ;Offset to Port 2 Status/Control (Word)
    UPtConnStatus   EQU 0001h ;Connect Status  RO
    UPtConnStatChg  EQU 0002h ;Connect Status Change  RWC
    UPtPortEnable   EQU 0004h ;Port Enabled  RW
    UPtPortEnChg    EQU 0008h ;Port Enabled/Disabled Status has changed  RWC
    UPtLineStatP    EQU 0010h ;Line Status (Logical Level of D+)  RO
    UPtLineStatM    EQU 0020h ;Line Status (Logical Level of D-)  RO
    UPtResumeDetect EQU 0040h ;Resume Detect  RW
    UPtOverCurrSts  EQU 0080h ;OverCurrent Detected
                              ;  Only on some newer Controllers  RO
    UPtOverCurrChg  EQU 0080h ;OverCurrent Detection Change
                              ;  Only on some newer Controllers  RWC
    ;Bit 7 = Reserved (always 1)
    UPtLowSpeed     EQU 0100h ;Low Speed Device Attached  RO
    UPtPortReset    EQU 0200h ;Port in Reset State  RW
    UPtSuspend      EQU 1000h ;Port in Suspend State  RW
    ;Bits 13-15 = Reserved


;==============================================================================
;Program Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Size of our program stack (in bytes)
  ;----------------------------------------------------------------------------
  ProgStackSize EQU 1200


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;STRUCTURES
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;==============================================================================
;DOS/CPU Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Program Segment Prefix (PSP)
  ;----------------------------------------------------------------------------
  PSPStruc      STRUC
    PSPDOSExit     DW       20CDh ;Int 20h Call
    PSPNextSegment DW          ?  ;Segment of First Byte of Memory beyond Program
    PSPCPMCall5    DB   6 DUP (?) ;CPM Far Call 5
    PSPInt22Addr   DD          ?  ;Stored Int 22h Handler
    PSPInt23Addr   DD          ?  ;Stored Int 23h (Ctrl-Break) Handler
    PSPInt24Addr   DD          ?  ;Stored Int 23h (Critical Error) Handler
    PSPParentPSP   DW          ?  ;Segment of Parent PSP
    PSPJFT         DB  20 DUP (?) ;Job File Table (20 File Handles)
    PSPEnvirSeg    DW          ?  ;Environment Segment for PSP
    PSPSSSPOnEntry DD          ?  ;Processes SS:SP on Entry to last Int 21h Call
    PSPJFTSize     DW          ?  ;Number of entries in JFT (default = 20)
    PSPJFTPointer  DD          ?  ;Pointer to JFT (Default = PSP:0018h)
    PSPPreviousPSP DD          ?  ;Pointer to previous PSP (Default = FFFF:FFFF)
    PSPFiller1     DB  18 DUP (?) ;Misc stuff used by SHARE, Windows, etc.
                                  ;Memory Below here available to TSR!
    PSPFiller2     DB   2 DUP (?) ;Unused in DOS <= 6.00
    PSPInt21       DW       21CDh ;Int 21h Call
    PSPRETF        DB        0CBh ;RETF Call
    PSPFiller3     DB   9 DUP (?) ;Can be used to make Extended FCB from FCB1
    PSPFCB1        DB  16 DUP (?) ;First File Control Block
    PSPFCB2        DB  16 DUP (?) ;Second File Control Block
    PSPFiller4     DB   4 DUP (?) ;Unused
    PSPCmdLineLen  DB          ?  ;Command Line Length & DTA
    PSPCmdLine     DB 127 DUP (?) ;Command Line String
   ENDS
  PSPStrucSize EQU (TYPE PSPStruc) ;Should be 256 bytes

  ;----------------------------------------------------------------------------
  ;Memory Control Block (MCB)
  ;----------------------------------------------------------------------------
  MCBStruc STRUC
    MCBID              DB        ?  ;Memory Control Block ID
      MCBIDValid      EQU       'M' ;Memory Block is Valid
      MCBIDLastInList EQU       'Z' ;Memory Block is Last in List
    MCBOwnerID         DW        ?  ;PSP Segment of Owner
                                    ;   0 = Owns Self
                                    ;   6 = DR-DOS XMS UMB
                                    ;   7 = DR-DOS Excluded Upper Memory
                                    ;   8 = Belongs to DOS
                                    ;FFFx = 386Max
    MCBSize            DW        ?  ;Size in Paragraphs
    MCBFiller          DB 3 DUP (?) ;Filler
    MCBOwnerName       DB 8 DUP (?) ;Owner Name
   ENDS
  MCBStrucSize EQU (TYPE MCBStruc) ;Should be 16 bytes

  ;----------------------------------------------------------------------------
  ;Structure needed to Initialize DOS EXEC Function
  ;----------------------------------------------------------------------------
  ParamBlockStruc STRUC
    PBEnvirSegment   DW ? ;Environment Segment to use (0 = Copy Callers Segment)
    PBCmdTailPtr     DD ? ;Pointer to Command Tail
    PBFCB1Offset     DD ? ;Pointer to File Control Block #1
    PBFCB2Offset     DD ? ;Pointer to File Control Block #2
    PBSSSPOnReturn   DD ? ;Holds Childs Initial SS:SP on Return (if AL = 01)
    PBCSIPOnReturn   DD ? ;Holds Entry Point (CS:IP) on Return (if AL = 01)
   ENDS
  ParamBlockSize EQU (TYPE ParamBlockStruc) ;Size of EXEC Parameter Block

  ;----------------------------------------------------------------------------
  ;DTA (Disk Transfer Area) after Find First Matching File (INT 21h, Func 4Eh)
  ;The first several bytes of the DTA are DOS version specific, and
  ;  we don't care about that data anyway.  We only care about the data
  ;  that is documented and the same across all versions of DOS.
  ;----------------------------------------------------------------------------
  FindFirstStruc   STRUC            ;Find First Matching File
    FFVerSpecific     DB 21 DUP (0) ;DOS Version-specific Data
    FFAttribs         DB         ?  ;File Attributes
      FAttrReadOnly  EQU        01h ;Read-Only
      FAttrHidden    EQU        02h ;Hidden
      FAttrSystem    EQU        04h ;System
      FAttrVolume    EQU        08h ;Volume Label
      ;Bit 3 = Execute-only (Novell Netware)
      FAttrDirectory EQU        10h ;Directory
      FAttrArchive   EQU        20h ;Archive
      FAttrUnused    EQU        40h ;Unused
                                    ;DOS 3+ returns this bit set if file
                                    ;  is actually a character device
                                    ;DOS Window underneath Windows XP doesn't
      ;Bit 7 = Delete Pending (OpenDOS, NovellDOS)
      ;      = Shareable (Novell Netware)
    FFTime            DW         ?  ;File Creation Time
    FFDate            DW         ?  ;File Creation Date
    FFSize            DD         ?  ;File Size
    FFName            DB 13 DUP (?) ;ASCIIZ File Name & Extension
   ENDS

   FAttrToUse EQU FAttrHidden+FAttrSystem
     ;Attributes to use in DOS's Find First Matching File Function
     ;DOS ignores the Read-Only and and Archive bits, so they don't matter


;==============================================================================
;CPU/Memory Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Global Descriptor Table Structure
  ;When building a GDT, need an empty one of these plus one for each
  ;  "real" GDT (Segment) Descriptor we will use
  ;----------------------------------------------------------------------------
  GDTStruc STRUC
    GDTSegLimit       DW        ?  ;Segment Limit (bytes/pages)
    GDTAddress24      DB 3 DUP (?) ;First 3 bytes of Segment Start (Linear Addr)
    GDTRights         DB        ?  ;Access rights (93h for Mem Copy Functions)
      RtSegType      EQU       0Fh ;Segment Type in bits 0-3
       ;System Segments
        STReserved0  EQU       00h ;Reserved
        STAvail16TSS EQU       01h ;Available 16-bit TSS
        STLDT        EQU       02h ;Local Descriptor table
        STBusy16TSS  EQU       03h ;Busy 16-bit TSS
        ST16CallGate EQU       04h ;16-bit Call Gate
        STTaskGate   EQU       05h ;Task Gate
        ST16IntGate  EQU       06h ;16-bit Interrupt Gate
        ST16TrapGate EQU       07h ;16-bit Trap Gate
        STReserved8  EQU       08h ;Reserved
        STAvail32TSS EQU       09h ;Available 32-bit TSS
        STReservedA  EQU       0Ah ;Reserved
        STBusy32TSS  EQU       0Bh ;Busy 32-bit TSS
        ST32CallGate EQU       0Ch ;32-bit Call Gate
        STReservedD  EQU       0Dh ;Reserved
        ST32IntGate  EQU       0Eh ;32-bit Interrupt Gate
        ST32TrapGate EQU       0Fh ;32-bit Trap Gate
       ;Application Segments
        STAccessed   EQU       01h ;Accessed
        STNotAccess  EQU       00h ;  Not Accessed
        STCSReadable EQU       02h ;Readable (Code Segments)
        STCSNoRead   EQU       00h ;  Non-Readable
        STDSWritable EQU       02h ;Writeable (Data Segments)
        STDSNoWrite  EQU       00h ;  Non-Writeable
        STCSConform  EQU       04h ;Conforming (Code Segments)
        STCSNConform EQU       00h ;  Non-Conforming
        STDSExpDown  EQU       04h ;Expand Down (Data Segments)
        STDSExpUp    EQU       00h ;  Expand Up
        STCodeSeg    EQU       08h ;Code Segment (0 = Data Segment)
        STDataSeg    EQU       00h ;  Data Segment
        ;Bits 4-7 = Reserved/Unused?
      RtDescrTypeApp EQU       10h ;Descriptor Type = Application (0 = System)
      RtDescrPriv    EQU       60h ;Descriptor Privilege Level in bits 6-5
        DescrPriv0   EQU       00h ;Privilege Level 0
        DescrPriv1   EQU       20h ;Privilege Level 1
        DescrPriv2   EQU       40h ;Privilege Level 2
        DescrPriv3   EQU       60h ;Privilege Level 3
      RtSegInRAM     EQU       80h ;Segment is Present In RAM
    GDTXRights        DB        ?  ;Extended rights
      XRSegLim4      EQU       0Fh ;Bits 0-3 = high 4 bits of Segment Limit
      XRAvail        EQU       10h ;Available
      XRReserved     EQU       20h ;Reserved (0)
      XROpSize32     EQU       40h ;Default Operation Size = 32 bits (0 = 16 bits)
      XRGranul4K     EQU       80h ;Granularity = 4K Page (0 = byte granularity)
    GDTAddress32      DB        ?  ;High byte of 32-bit Segment Start (Linear Addr)
   ENDS
  RightsToUse  EQU 93h ;Basic Rights to Use
                       ;93h = RtSegInRAM+DescrPriv0+RtDesrTypeApp+STDataSeg
                       ;     +STDSWritable+STDSExpUp+STDSWritable+STNotAccess
  XRightsToUse EQU (XROpSize32+XRGranul4K) ;Extended Rights we will use
  GDTSize      EQU (TYPE GDTStruc)         ;Size of Structure

  ;----------------------------------------------------------------------------
  ;Structure for Copy Extended Memory Function
  ;----------------------------------------------------------------------------
  MemCopyStruc STRUC
    MCNullSegment DB GDTSize DUP (0) ;Null Entry (Initialize to Zeroes))
    MCDSSegment   DB GDTSize DUP (0) ;Data Segment (Initialize to Zeroes)
    MCSrcSegment  DB GDTSize DUP (?) ;Source Data Segment (Copy from Here)
    MCDstSegment  DB GDTSize DUP (?) ;Destination Data Segment (Copy to Here)
    MCCSSegment   DB GDTSize DUP (0) ;Code Segment (Initialize to Zeroes)
    MCSSSegment   DB GDTSize DUP (0) ;Stack Segment (Initialize to Zeroes)
   ENDS
  MemCopySize EQU (TYPE MemCopyStruc) ;Size of Structure


;==============================================================================
;USB Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;This is the format for a request sent to Int 14h to Send/Receive Data
  ;It contains the type of request, etc.
  ;----------------------------------------------------------------------------
  Int14RequestStruc         STRUC      ;Structure for an Int 14 Request
    I14RRequestType            DB   ?  ;Type of Request
      I14RRTHostClass         EQU  00h ;Host/System/OS Class
        I14RRTGetHostSWInfo   EQU  01h ;Get Host Software Info
        I14RRTGetHostHWInfo   EQU  02h ;Get Host Hardware Info
        I14RRTGetHostVendInfo EQU  03h ;Get Host Vendor Info
        I14RRTGetHostStatus   EQU  04h ;Get Current Host Status
        I14RRTHostRun         EQU  08h ;Start/Run/Resume Host
        I14RRTHostStop        EQU  09h ;Stop Host
        I14RRTHostReset       EQU  0Ah ;Reset Host
        I14RRTHostSuspend     EQU  0Bh ;Global Suspend Host
        I14RRTHostResume      EQU  0Ch ;Force Global Resume on Host
      I14RRTTimingClass       EQU  10h ;Frame Timing Class
        I14RRTRegTmgOwner     EQU  11h ;Register as Timing Owner
        I14RRTUnRegTmgOwner   EQU  12h ;UnRegister as Timing Owner
        I14RRTIncTiming       EQU  13h ;Increment (Slow Down) Frame Timing
        I14RRTDecTiming       EQU  14h ;Decrement (Speed Up) Frame Timing
        I14RRTChangeTiming    EQU  15h ;Change Frame Timing (by Large Amount)
      I14RRTHubClass          EQU  20h ;Hub Class
        I14RRTGetDvcHubInfo   EQU  21h ;Get Hub Info for Device
        I14RRTNewDvcConn      EQU  24h ;Hub has Detected new Device
        I14RRTDvcDisc         EQU  25h ;Device has been Disconnected
        I14RRTSendHubChar     EQU  27h ;Send Hub Characteristics to Host
        I14RRTEnableHubPort   EQU  28h ;Enable Device given Hub & Port
        I14RRTDisableHubPort  EQU  29h ;Disable Device given Hub & Port
        I14RRTResetHubPort    EQU  2Ah ;Reset Device given Hub & Port
        I14RRTSuspendHubPort  EQU  2Bh ;Suspend Device given Hub & Port
        I14RRTResumeHubPort   EQU  2Ch ;Resume Device given Hub & Port
        I14RRTPwrOnHubPort    EQU  2Dh ;Power On Device given Hub & Port
        I14RRTPwrOffHubPort   EQU  2Eh ;Power Off Device given Hub & Port
        I14RRTPwrResetHubPort EQU  2Fh ;Power Reset Device given Hub & Port
      I14RRTTPowerClass       EQU  30h ;Power Class
        I14RRTGetDvcPowerInfo EQU  31h ;Get Power Info for Device
        I14RRTGetHubPowerDraw EQU  32h ;Get Power Draw for Hub
        I14RRTPwrOnDevice     EQU  3Dh ;Power On Device given Dvc Addr
        I14RRTPwrOffDevice    EQU  3Eh ;Power Off Device given Dvc Addr
        I14RRTPwrResetDevice  EQU  3Fh ;Power Reset Device given Dvc Addr
      I14RRTDeviceClass       EQU  40h ;Device Class
        I14RRTGetDvcClassInfo EQU  41h ;Get Device Class Info
        I14RRTGetDvcVendInfo  EQU  42h ;Get Device Vendor Info
        I14RRTGetDvcStatus    EQU  43h ;Get Device Status
        I14RRTEnableDevice    EQU  48h ;Enable/Resume Device given Dvc Addr
        I14RRTDisableDevice   EQU  49h ;Disable Device given Dvc Addr
        I14RRTResetDevice     EQU  4Ah ;Reset Device given Dvc Addr
        I14RRTSuspendDevice   EQU  4Bh ;Suspend Device given Dvc Addr
        I14RRTResumeDevice    EQU  4Ch ;Resume Device given Dvc Addr
      I14RRTConfigClass       EQU  50h ;Configuration Class
        I14RRTConfigingIntf   EQU  51h ;Driver is Configuring an Interface
        I14RRTConfigIntfDone  EQU  52h ;Interface Configuration is Complete
        I14RRTSetNewConfig    EQU  58h ;Set/Change Device Config Value
      I14RRTInterfaceClass    EQU  60h ;Interface Class
        I14RRTFindRegIntf     EQU  62h ;Look for Registered Interface
        I14RRTFindUnRegIntf   EQU  63h ;Look for Unregistered Interface
        I14RRTRegIntfOwner    EQU  64h ;Register as Interface Owner
        I14RRTUnRegIntfOwner  EQU  65h ;Unregister as Interface Owner
        I14RRTIntfDontLook    EQU  68h ;Existing Interface Owner Don't Look
      I14RRTAltIntfClass      EQU  70h ;Alternate Interface Class
        I14RRTGetAltIntfInfo  EQU  71h ;Get Alternate Interface Info
      I14RRTEndPointClass     EQU  80h ;End Point Class
        I14RRTGetDataX        EQU  81h ;Get Current DataX Value
        I14RRTIncDataX        EQU  88h ;Increment/Toggle DataX Value
      I14RRTPacketClass       EQU  90h ;Packet Class
        I14RRTDoIsoch         EQU  94h ;Schedule Isochronous Transaction
        I14RRTDoInterruptPer  EQU  95h ;Schedule Periodic Interrupt
        I14RRTDoControl       EQU  96h ;Schedule Control/Setup Request
        I14RRTDoBulk          EQU  97h ;Schedule Bulk Transaction
        I14RRTDoInterrupt1T   EQU  98h ;Schedule One-Time Interrupt
        I14RRTCloseHandle     EQU  9Ch ;Close/Remove Scheduled Transaction
        I14RRTChangeIntPer    EQU  9Dh ;Change Periodicity of Interrupt
        I14RRTGetTransStatus  EQU  9Fh ;Get Status of Packet Transaction
      I14RRTMiscClass         EQU 0A0h ;Miscellaneous Class
        I14RRTLargeCallDone   EQU 0A1h ;Large (Complicated) Call Complete
        I14RRTBeepSpeaker     EQU 0AFh ;Beep the Speaker
      I14RRTInterHostClass    EQU 0E0h ;Inter-Host Communication Class
      I14RRTInternalClass     EQU 0F0h ;Host Internal/Troubleshooting Class
    I14RFlags                  DB   ?  ;Bit-level flags
      I14RFlagIn              EQU  01h ;In Direction
      I14RFlagLowSpeed        EQU  02h ;Low-Speed Device
      I14RFlagHiSpeed         EQU  04h ;High-Speed Device
      I14RFlagNoRetries       EQU  10h ;No Auto Retries for Control
      I14RFlagShortPktOK      EQU  20h ;No Retries for Short Packets
      I14RFlagSpecificFrame   EQU  40h ;Use Specific Frame Number
      I14RFlagAddrIsPhys      EQU  80h ;Data Address is Physical
    I14RHostIndex              DB   ?  ;Host Index
    I14RDeviceAddress          DB   ?  ;USB Device Address
      I14RHubAddress          EQU (OFFSET I14RDeviceAddress)
    I14REndPoint               DB   ?  ;EndPoint or Port or Alt Interface
      I14RHubPort             EQU (OFFSET I14REndPoint)
      I14RAltInterface        EQU (OFFSET I14REndPoint)
    I14RConfigValue            DB   ?  ;Configuration Value
      I14RCloseID             EQU (OFFSET I14RConfigValue)
      I14RDataX               EQU (OFFSET I14RConfigValue)
    I14RInterfaceNum           DB   ?  ;Interface Number
    I14RSearchIndex            DB   ?  ;Search Index
    I14RVendorID               DW   ?  ;Vendor ID
    I14RProductID              DW   ?  ;Product ID
    I14RDvcClass               DB   ?  ;Device Class
    I14RDvcSubClass            DB   ?  ;Device SubClass
    I14RDvcProtocol            DB   ?  ;Device Protocol
    I14RIntfClass              DB   ?  ;Interface Class
    I14RIntfSubClass           DB   ?  ;Interface SubClass
    I14RIntfProtocol           DB   ?  ;Interface Protocol
    I14RRequestHandle          DW   ?  ;Request Handle Number
    I14RPeriodicity            DW   ?  ;Interrupt Periodicity/Duration
      I14RBeepFrequency       EQU (OFFSET I14RPeriodicity)
    I14RTimeout                DW   ?  ;Transaction Time Out Value
    I14RDataAddress            DD   ?  ;Data Address
    I14RDataSize               DW   ?  ;Size of Data (Bytes)
    I14RCallBackAddr           DD   ?  ;Call Back Address (CS:IP format)
      I14RLargeCallRtnCode    EQU (OFFSET I14RCallBackAddr)
    I14RUserPktID              DW   ?  ;User Packet ID
    I14RSetupReqData           DQ   ?  ;Setup Request Data (8 bytes)
    I14RFrameTiming            DW   ?  ;Frame Timing Value (def = 12000)
      I14RFrameIndex          EQU (OFFSET I14RFrameTiming)
                                       ;Starting Frame of Isoch Schedule
    I14RIsochSchedAddr         DD   ?  ;Address of Isoch Schedule
    I14RFiller  DB (Int14RequestSize-$) DUP (0)

   ENDS


;==============================================================================
;OHCI Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;OHCI Operational Registers
  ;  Offsets from the Base Memory Address stored in the PCI Configuration Space
  ;  The entire Operational Register Space is 4kB
  ;----------------------------------------------------------------------------
  OHCIOpRegsStruc STRUC
    ;--------------------------------------------------------------------------
    ;Control & Status
    ;--------------------------------------------------------------------------
    OORVersion           DD          ?  ;OHCI Version
      OVersionMask      EQU 00000_00FFh ;Version in low byte, BCD
      OLegacySupport    EQU 00000_0100h ;Legacy Support Registers are available
     ;Bits 09-31 = Reserved
    OORControl           DD          ?  ;Control Register
      OCtlBulkRatioMask EQU 00000_0003h ;Control/Bulk Service Ratio
        OCtlBulkRatio1  EQU 00000_0000h ;1:1
        OCtlBulkRatio2  EQU 00000_0001h ;2:1
        OCtlBulkRatio3  EQU 00000_0002h ;3:1
        OCtlBulkRatio4  EQU 00000_0003h ;4:1
      OPerListEnable    EQU 00000_0004h ;Periodic Interrupt List Enable
      OIsochEnable      EQU 00000_0008h ;Isochronous ED Enable
      OCtlListEnable    EQU 00000_0010h ;Control List Enable
      OBulkListEnable   EQU 00000_0020h ;Bulk List Enable
      OHostStateMask    EQU 00000_00C0h ;Host Functional State
        OStateReset     EQU 00000_0000h ;Reset
        OStateResume    EQU 00000_0040h ;Resume
        OStateNormal    EQU 00000_0080h ;Operational (Normal)
        OStateSuspend   EQU 00000_00C0h ;Suspend
      OIntRouting       EQU 00000_0100h ;Interrupt Routing (as opposed to SMI)
      ORmtWakeConn      EQU 00000_0200h ;Remote Wakeup Connected (set by BIOS)
      ORmtWakeEnable    EQU 00000_0400h ;Remote Wakeup Enable
     ;Bits 11-31 = Reserved
    OORCmdStatus         DD          ?  ;Command Status Register
      OHostSWReset      EQU 00000_0001h ;Host Software Reset
      OCtlListFilled    EQU 00000_0002h ;Control List Filled
      OBulkListFilled   EQU 00000_0004h ;Bulk List Filled
      OOwnerChgReq      EQU 00000_0008h ;Ownership Change Request
      ;Bits 04-15 = Reserved
      OSchedOverrunCnt  EQU 00003_0000h ;Schedule Overrun Count
        OSchedOverrun0  EQU 00000_0000h ;Schedule Overrun Count = 0
        OSchedOverrun1  EQU 00001_0000h ;Schedule Overrun Count = 1
        OSchedOverrun2  EQU 00002_0000h ;Schedule Overrun Count = 2
        OSchedOverrun3  EQU 00003_0000h ;Schedule Overrun Count = 3
      ;Bits 18-31 = Reserved

    ;--------------------------------------------------------------------------
    ;Interrupts
    ;--------------------------------------------------------------------------
    OORIntStatus         DD          ?  ;Interrupt Status Register
      OIntSchedOverrun  EQU 00000_0001h ;Schedule Overrun Interrupt
      OIntWriteBackDone EQU 00000_0002h ;Write Back Done Head Interrupt
      OIntStartOfFrame  EQU 00000_0004h ;Start-of-Frame Interrupt
      OIntResumeDetect  EQU 00000_0008h ;Resume Detected Interrupt
      OIntUnrecoverable EQU 00000_0010h ;Unrecoverable Error Interrupt
      OIntFrameNumOF    EQU 00000_0020h ;Frame Number Overflow Interrupt
      OIntRHStatusChg   EQU 00000_0040h ;Root Hub Status Interrupt
      ;Bits 07-29 = Reserved
      OIntOwnerChg      EQU 04000_0000h ;Ownership Change Interrupt
      ;Bit     31 = 0
    OORIntEnable         DD          ?  ;Interrupt Enable Register
      ;Bits 00-30 = Same as OORIntStatus
      OMasterIntEnable  EQU 08000_0000h ;Master Interrupt Enable
    OORIntDisable        DD          ?  ;Interrupt Disable Register
      ;Bits 00-31 = Same as OORIntEnable

    ;--------------------------------------------------------------------------
    ;Memory Pointers
    ;--------------------------------------------------------------------------
    OORHCCAAddress       DD          ?  ;Host Controller Comm Area Phys Address
      ;Bits 00-07 = 0
      OHCCAAddrMask     EQU 0FFFF_FF00h ;Minimum 256-bit Align (could be more)
    OORPerCurrED         DD          ?  ;Phys Addr of Current Isoch/Int ED
      ;Bits 00-03 = 0
      OPerCurrEDMask    EQU 0FFFF_FFF0h ;Paragraph-aligned
    OORCtlHeadED         DD          ?  ;Phys Addr of First Control ED
      ;Bits 00-03 = 0
      OCtlHeadEDMask    EQU 0FFFF_FFF0h ;Paragraph-aligned
    OORCtlCurrED         DD          ?  ;Phys Addr of Current Control ED
      ;Bits 00-03 = 0
      OCtlCurrEDMask    EQU 0FFFF_FFF0h ;Paragraph-aligned
    OORBulkHeadED        DD          ?  ;Phys Addr of First Bulk ED
      ;Bits 00-03 = 0
      OBulkHeadEDMask   EQU 0FFFF_FFF0h ;Paragraph-aligned
    OORBulkCurrED        DD          ?  ;Phys Addr of Current Bulk ED
      ;Bits 00-03 = 0
      OBulkCurrEDMask   EQU 0FFFF_FFF0h ;Paragraph-aligned
    OORDoneHead          DD          ?  ;Phys Addr of last ED in Done Queue
      ;Bits 00-03 = 0                   ;Normally don't need to use this
      ODoneEDMask       EQU 0FFFF_FFF0h ;Paragraph-aligned

    ;--------------------------------------------------------------------------
    ;Framing
    ;--------------------------------------------------------------------------
    OORFrmInterval       DD          ?  ;Frame Interval & Max FS Packet Size
      OFrmIntervalMask  EQU 00000_3FFFh ;Frame Interval (Bits between SOFs)
      ;Bits 14-15 = Reserved
      OFrmMaxFSPktSize  EQU 07FFF_0000h ;Full-Speed Maximum Packet Size
      OFrmIntervalTgl   EQU 08000_0000h ;Frame Interval Toggle
    OORFrmRemaining      DD          ?  ;Frame Remaining
      OFrmRemainingMask EQU 00000_3FFFh ;Frame Time Remaining (Bits)
      ;Bits 14-30 - Reserved
      OFrmRemainingTgl  EQU 08000_0000h ;Frame Remaining Toggle
    OORFrmNumber         DD          ?  ;Frame Number
      OFrmNumberMask    EQU 00000_FFFFh ;Frame Number
      ;Bits 16-31 = Reserved
    OORPerStart          DD          ?  ;Periodic Start
      OPerStartMask     EQU 00000_3FFFh ;Periodic Start
      ;Bits 14-31 = Reserved
    OORLSThresh          DD          ?  ;Low-Speed Start Threshold
      OLSThreshMask     EQU 00000_0FFFh ;Low-Speed Start Threshold

    ;--------------------------------------------------------------------------
    ;Root Hub
    ;--------------------------------------------------------------------------
    OORRHDescrA          DD          ?  ;Root Hub Descriptor A
      ONumRHPortsMask   EQU 00000_00FFh ;Number of Root Hub Ports (0-15)
      OPerPortPwr       EQU 00000_0100h ;Per-Port Power Switching
      ONoPwrSwitching   EQU 00000_0200h ;No Power Switching
      OCompoundDvc      EQU 00000_0400h ;Part of Compound Device (0)
      OPerPortOverCurr  EQU 00000_0800h ;Per-port Over-Current Protection
      ONoOverCurr       EQU 00000_1000h ;No Over-Current Protection
      ;Bits 13-23 = Reserved
      OPwrGoodTimeMask  EQU 0FF00_0000h ;Power-On-to-Power-Good Time / 2 (mS)
    OORRHDescrB          DD          ?  ;Root Hub Descriptor B
      ;Bit 00 = Reserved
      ODvcRemoveMask    EQU 00000_FFFEh ;Device Removable (Bit 1 = Port 1, ...)
      ;Bit 16 = Reserved
      OPerPortPwrMask   EQU 0FFFE_0000h ;Port is Per-Port Power Switched
                                        ;  (Bit 17 = Port 1, ...)
    OORRHStatus          DD          ?  ;Root Hub Status
      OLclPwrSts        EQU 00000_0001h ;(R) Local Power Status (0)
        OClearGlobalPwr EQU OLclPwrSts  ;(W) Clear Global Power
     OGlobalOverCurr    EQU 00000_0002h ;(RO) Global Over-Current Indicator
      ;Bits 02-14 = Reserved
      ORHRmtWakeEnable  EQU 00000_8000h ;(R) Connect Status Change is Rmt Wakeup
                                        ;(W) Enable Remote Wakeup
      OLclPwrChg        EQU 00001_0000h ;(R) Local Power Status Change (0)
        OSetGlobalPwr   EQU OLclPwrChg  ;(W) Set Global Power
      OOverCurrChange   EQU 00002_0000h ;(R) Over-Current Change
                                        ;(W) Acknowledge Over-Current Change
      ;Bits 18 - 30 = Reserved
      OClrRmtWakeEn     EQU 08000_0000h ;(WO) Clear Device Remote Wakeup Enable

    OORRHPtStatus01      DD          ?  ;Root Hub Port 01 Status
      OPtConnect        EQU 00000_0001h ;(R) Current Connect Status
        OPtClrEnable    EQU OPtConnect  ;(W) Clear Port Enable
      OPtEnable         EQU 00000_0002h ;(R) Port Enable Status
        OPtSetEnable    EQU OPtEnable   ;(W) Set Port Enable
      OPtSuspend        EQU 00000_0004h ;(R) Port Suspend Status
        OPtSetSuspend   EQU OPtSuspend  ;(W) Set Port Suspend
      OPtOverCurr       EQU 00000_0008h ;(R) Port Over-Current Indicator
        OPtClrSuspend   EQU OPtOverCurr ;(W) Clear Port Suspend Status
      OPtReset          EQU 00000_0010h ;(R) Port Reset In Progress
        OPtSetReset     EQU OPtReset    ;(W) Set Port Reset
      ;Bits 05-07 = Reserved
      OPtPwrOn          EQU 00000_0100h ;(R) Port Power is On
        OPtSetPwr       EQU OPtReset    ;(W) Set Port Power
      OPtLowSpeed       EQU 00000_0200h ;(R) Low-Speed Device is Attached
        OPtClrPwr       EQU OPtLowSpeed ;(W) Clear Port Power
      ;Bits 10-15 = Reserved
      OPtConnectChg     EQU 00001_0000h ;Port Connect Status Change
      OPtEnableChg      EQU 00002_0000h ;Port Enable Status Change
      OPtSuspendChg     EQU 00004_0000h ;Port Suspend Status Change
      OPtOverCurrChg    EQU 00008_0000h ;Port Over-Current Indicator Change
      OPtResetChg       EQU 00010_0000h ;Port Reset Status Change
      ;Bits 21-31 = Reserved
    OORRHPtStatus02      DD          ?  ;Root Hub Port 02 Status
    OORRHPtStatus03      DD          ?  ;Root Hub Port 03 Status
    OORRHPtStatus04      DD          ?  ;Root Hub Port 04 Status
    OORRHPtStatus05      DD          ?  ;Root Hub Port 05 Status
    OORRHPtStatus06      DD          ?  ;Root Hub Port 06 Status
    OORRHPtStatus07      DD          ?  ;Root Hub Port 07 Status
    OORRHPtStatus08      DD          ?  ;Root Hub Port 08 Status
    OORRHPtStatus09      DD          ?  ;Root Hub Port 09 Status
    OORRHPtStatus10      DD          ?  ;Root Hub Port 10 Status
    OORRHPtStatus11      DD          ?  ;Root Hub Port 11 Status
    OORRHPtStatus12      DD          ?  ;Root Hub Port 12 Status
    OORRHPtStatus13      DD          ?  ;Root Hub Port 13 Status
    OORRHPtStatus14      DD          ?  ;Root Hub Port 14 Status
    OORRHPtStatus15      DD          ?  ;Root Hub Port 15 Status

   ENDS
  OORSize EQU (TYPE OHCIOpRegsStruc) ;Size of Structure (90h/144)

  ;----------------------------------------------------------------------------
  ;After the "Standard" Operation Registers (above), there is a reserved space
  ;  of 112 bytes (7 paragraphs), then the four Legacy Support Registers.
  ;----------------------------------------------------------------------------
  OLegacyOffset    EQU       0100h ;Offset of Legacy Support Registers in the
                                   ;  Operational Registers Area.  Only
                                   ;  applicable if OLegacySupport is set.
  OLegacyControl   EQU       0100h ;Offset of Legacy Control Register
    OLegEnabled    EQU 00000_0001h ;Legacy Support Enabled
    OLegEmulInt    EQU 00000_0002h ;Emulation Interrupt Condition (Read-Only)
    OLegCharPend   EQU 00000_0004h ;Character Pending
    OLegIRQEnable  EQU 00000_0008h ;IRQ1/IRQ12 Generation Enabled
    OLegExtIRQEn   EQU 00000_0010h ;External IRQ Enable (IRQ1/IRQ12 from Keyb)
    OLegA20Seq     EQU 00000_0020h ;Gate A20 Sequence
    OLegIRQ01Act   EQU 00000_0040h ;IRQ1 from Keyb Controller has occurred
    OLegIRQ12Act   EQU 00000_0080h ;IRQ12 from Keyb Controller has occurred
    OLegA20State   EQU 00000_0100h ;State of A20 Gate on Keyb controller
    ;Bits 09-31 = Reserved
  OLegacyInput     EQU       0104h ;Offset of Legacy Input Register
                                   ;  Stores data written to Ports 60h & 64h
    OLegacyInMask  EQU 00000_00FFh ;Data is only 1 byte long
  OLegacyOutput    EQU       0108h ;Offset of Legacy Output Register
                                   ;  Stores data read from Port 60h
    OLegacyOutMask EQU 00000_00FFh ;Data is only 1 byte long
  OLegacyStatus    EQU       010Ch ;Offset of Legacy Status Register
    OLegOutFull    EQU 00000_0001h ;Output Buffer is full
    OLegInFull     EQU 00000_0002h ;Input Buffer is full
    OLegBootFlag   EQU 00000_0004h ;Warm/Cold Boot flag
    OLegPort64     EQU 00000_0008h ;Output to Port 64h (not Port 60h)
    OLegNoInhibit  EQU 00000_0010h ;Keyboard is Not Inhibited
    OLegAuxOutFul  EQU 00000_0020h ;Auxiliary Output (IRQ12/Mouse), not IRQ1
    OLegTimeOut    EQU 00000_0040h ;Time-out has occurred
    OLegParityErr  EQU 00000_0080h ;Parity Error
    ;Bits 08-31 = Reserved


;哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌
;DATA
;哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌

;==============================================================================
;Miscellaneous Strings we need to write to the screen
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Help Message to write on Errors.
  ;This MUST also be the first Data at the top of the File.  If it is, the user
  ;  can simply do a "TYPE USBHOSTS.COM" and get this Screen, without even
  ;  needing to execute the Program.
  ;------------------------------------------------------------------------------
  Copyright:
    DB CR
    DB 'USBHOSTS 0.06, (C) 2007-2009, Bret E. Johnson.',CR,LF
    DB LF,0

  HelpMsg:
    DB 'This program simply looks for all of the "standard" USB Host Controllers it',CR,LF
    DB '  can find and lets you know a little bit of information about them.',CR,LF
    DB 'Most people have no idea that there are actually several different kinds of',CR,LF
    DB '  USB Host Controllers, and that they work VERY differently from each other.',CR,LF
    DB 'This program tells you how many USB Host Controllers are actually installed',CR,LF
    DB '  on your computer, and what kind they are (OHCI, UHCI, or EHCI).',CR,LF
    DB  LF
    DB 'OHCI stands for "OPEN Host Controller Interface", and is a Standard',CR,LF
    DB '  developed by a consortium of vendors, including Microsoft, Compaq, and',CR,LF
    DB '  National Semiconductor.  It only works with USB version 1 (maximum 12 Mbps).',CR,LF
    DB 'UHCI stands for "UNIVERSAL Host Controller Interface", and was developed',CR,LF
    DB '  by Intel.  It actually was developed before the OHCI Specification.',CR,LF
    DB '  Like OHCI, UHCI only works with USB version 1 (maximum 12 Mbps).',CR,LF
    DB 'EHCI stands for "ENHANCED Host Controller Interface", and, like UHCI,',CR,LF
    DB '  was developed by Intel.  As far as I know, it is the ONLY Host Controller',CR,LF
    DB '  Specification that will work with USB version 2 (maximum 480 Mbps).',CR,LF
    DB '  If this program finds an EHCI-compatible (USB 2) Controller, it should also',CR,LF
    DB '  find at least one OHCI- or UHCI-compatible Controller.  The two different',CR,LF
    DB '  Controllers (an EHCI and a OHCI/UHCI) will be integrated into the same',CR,LF
    DB '  Device, and will "divide" the work between each other.  The EHCI Controller',CR,LF
    DB '  handles the Fast-speed (480 Mbps) devices, and the other Controller (OHCI',CR,LF
    DB '  or UHCI) handles the Full- & Low-speed (12 & 1.5 Mbps) devices.'
    DB 0,EOF

  ;----------------------------------------------------------------------------
  ;Various Strings needed to print numbers and such to the screen
  ;----------------------------------------------------------------------------
  HCIMsg:    DB 'HCI',0
  HexString: DB '0000_0000',0
  SingleMsg: DB ' ',0
  CrLfMsg:   DB CR,LF
  NoMsg:     DB 0
  Space2Msg: DB ' '
  SpaceMsg:  DB ' ',0

  ;----------------------------------------------------------------------------
  ;Strings and Data needed to Pause the screen
  ;----------------------------------------------------------------------------
  PauseMsg:
    DB CR,LF
    DB ' MORE   (Esc stops Pausing, Ctrl-C stops Completely, any other Continues)',CR,0
  PauseNMsg:
    DB ' MORE                                                                    ',CR,LF,0
  PauseDMsg:
    DB '                                                                               ',CR,0
  PauseRows       DW ? ;Number of rows per screen
  PauseHeaderPtr  DW 1 ;Pointer to Header Message (start with a fake one <> 0)
  PauseHeaderSize DW 2 ;Number of lines in the Header Message
  PauseRowCount   DW 2 ;Current Row Counter


;==============================================================================
;Strings to write USB Hosts Statuses
;==============================================================================

  HeaderMsg0:
    DB '       PCI BUS',CR,LF
    DB '      屯屯屯屯屯                             BASE           USB DRIVER',CR,LF
    DB '      I   B  D F                      BASE   PHYSICAL   屯屯屯屯屯屯屯屯屯',CR,LF
    DB 'HOST  d   u  v n              USB IRQ I/O    MEMORY     HST             BW',CR,LF
    DB 'TYPE  x   s  c c  VENDR PROD  VER NUM ADDR   ADDRESS    IDX   STATUS   USED',CR,LF
  DividerMsg:
    DB '屯屯   屯 屯   屯屯 屯屯 屯 屯 屯屯 屯屯屯屯屯  屯 屯屯屯屯屯 屯屯',CR,LF,0

  RunningMsg:   DB 'Running   ',0
  SuspendedMsg: DB 'Suspended ',0
  StoppedMsg:   DB 'Stopped   ',0
  DebugMsg:     DB 'Debug Mode',0
  UnknownMsg:   DB 'Unknown   ',0

  NewHostDivider:
    DB CR,LF,LF
    DB 79 DUP ('')
    DB CR,LF
    DB 79 DUP ('')
    DB CR,LF
    DB 79 DUP ('')
    DB CR,LF,LF
    DB 0

  NoDataMsg:
    DB CR,LF
    DB 'Could not obtain detailed data from the USB Host.',0

  StopDividerMsg:
    DB 79 DUP ('')
    DB CR,LF
    DB 0

  WaitingMsg1:
    DB 'Stopping Enhanced Host Controller #',0
  WaitingMsg2:
    DB '.  This may take several seconds...',CR,LF,LF,0

  EHCIStopMsg1:
    DB 'Enhanced Host Controller #',0
  EHCIStopMsg2:
    DB ' has been stopped.',0


;==============================================================================
;Strings and data to write detailed OHCI Host Status
;==============================================================================

  HeaderMsgOHCI1:
    DB '                                                                   STATUS屯',CR,LF
    DB '                                                                   S O R R S',CR,LF
    DB '  屯屯屯GENERAL屯屯屯屯  屯屯屯屯屯屯屯屯FRAMING屯屯屯屯屯屯屯屯  W w W W c',CR,LF
    DB '         HOST                   T       T       PERID LOW   MAX    R n k k h',CR,LF
    DB '  HCI CONTROLLER  HOST    FRAME g FRAME g FRAME START SPEED FS     s e C E O',CR,LF
    DB '  VER COMM AREA   STATE   TIME  l REMAN l NUMBR THRES THRES PACKT  t r n n R',CR,LF
    DB '  屯 屯屯屯屯屯 屯屯屯  屯屯屯 屯屯屯 屯屯 屯屯 屯屯 屯屯  屯屯屯屯',CR,LF
    DB 0

  HeaderMsgOHCI2:
    DB '  屯屯屯屯屯屯屯屯屯END-POINT DESCRIPTOR ADDRESSES (hex)屯屯屯屯屯屯屯屯屯屯',CR,LF
    DB '  屯PERIODIC屯  屯屯屯屯CONTROL屯屯屯屯   屯屯屯屯BULK屯屯屯屯屯  屯DONE屯',CR,LF
    DB '            E I            E F           C           E F',CR,LF
    DB '            n s            n i           B           n i',CR,LF
    DB '            a o            a l           R           a l',CR,LF
    DB '            b E            b l           a           b l',CR,LF
    DB '   CURRENT  l n    HEAD    l d  CURRENT  t   HEAD    l d  CURRENT     HEAD   ',CR,LF
    DB '  屯屯屯屯屯屯  屯屯屯屯屯屯 屯屯屯屯  屯屯屯屯屯屯 屯屯屯屯  屯屯屯屯',CR,LF
    DB 0

  HeaderMsgOHCI3:
    DB '  屯屯屯屯屯ROOT HUB屯屯屯屯屯   屯屯屯屯屯屯屯屯PORTS屯屯屯屯屯屯屯屯',CR,LF
    DB '   P P N ~ P N R  ~ O      TOTAL      N P P ~   ~ E ~   ~ O ~ R L     TOTL',CR,LF
    DB '   o t o P t o m  O C POWR POWER    P o t o C C E n S S O C R e o     POWR',CR,LF
    DB '   r P P o O O W  C u GOOD  ON      o R P w o o n a u u C u e s S      ON',CR,LF
    DB '   t w w w C C a  u r TIME PORTS    r m w e n n b b s s u r s e p DVC PORT',CR,LF
    DB '   s r r r r r k  r r (mS) (mA)     t v r r n n l l p p r r t t d ADR (mA)',CR,LF
    DB '  屯屯屯屯屯屯屯  屯 屯屯 屯屯   屯 屯 屯屯屯屯屯屯屯屯屯屯屯 屯 屯屯',CR,LF
    DB 0

  HeaderMsgOHCI4:
    DB '                         屯屯屯屯屯屯屯LEGACY SUPPORT屯屯屯屯屯屯屯',CR,LF
    DB '  屯屯INTERRUPTS屯屯   屯屯ENABLE屯屯屯  屯屯STATUS屯屯  DATA屯',CR,LF
    DB '  M I  O U R S F S W R   E E C I E I I A A    T P N O   A P ',CR,LF
    DB '  a n  w n t t r c r e   n m h R x R R 2 2  B i a o u I u r ',CR,LF
    DB '  s t  n R H F # h B s   a I P Q I Q Q 0 0  o m r I t n x t ',CR,LF
    DB '  t R  e e u r O O a D   b n n E R 0 1 S S  o O E n F F F 6 ',CR,LF
    DB '  r t  r c b m F R k t   l t d n Q 1 2 q t  t t r h l l l 4  IN  OUT',CR,LF
    DB '  屯     屯屯屯       屯屯屯 屯   屯  屯屯屯  屯 屯',CR,LF
    DB 0

    OHCIOpRegData:       ;Operational Registers Data Area copied from OHCI Host
      DB OORSize DUP (?) ;144 Bytes
    OHCILegacyData:      ;Legacy Support Data Area copied from OHCI Host
      DB (4*4) DUP (?)   ;4 DWords

    EORSize EQU 202      ;202 Bytes for Capability & Operational Registers
                         ;  (assuming 15 Ports on Host)
    EHCIRegData:         ;Capability & Operational Registers Data Area
                         ;  copied from EHCI Host
      DB EORSize DUP (?)

  OStateMsgs:
    DB 'Reset  ',0
    DB 'Resume ',0
    DB 'Normal ',0
  OStateMsgLast:
    DB 'Suspend',0
  OStateMsgSize EQU ($-OStateMsgLast)


;==============================================================================
;Strings to write detailed EHCI Host Status
;==============================================================================

  HeaderMsgEHCI1:
    DB '        屯屯GENERAL屯屯  屯PERIODIC屯 屯屯ASYNC屯屯屯屯',CR,LF
    DB '            C 6 R L  I  I      LIST   S      LIST  S   D R',CR,LF
    DB '          H o 4 e t  s  n             t            t P r e',CR,LF
    DB '        R a n B s R  o  t             a            a a B c  FRAM P',CR,LF
    DB '  EHCI  u l f i e s  T  T             t            t r e l  LIST r  FRAME FRAME',CR,LF
    DB '  VERSN n t g t t t  h  h   ADDRESS   s  ADDRESS   s k l m  SIZE g  TIME  NUMBR',CR,LF
    DB '  屯屯 屯 屯 屯 屯 屯  屯屯屯屯屯屯 屯屯屯屯屯屯屯屯屯  屯屯屯  屯屯 屯屯',CR,LF
    DB 0

  HeaderMsgEHCI2:
    DB '  屯屯屯HUB屯屯屯  屯屯屯屯屯屯屯屯屯屯屯屯屯PORTS屯屯屯屯屯屯屯屯屯屯屯屯屯',CR,LF
    DB '   P P R # P TOTAL     D R   R P ~   ~ E ~ O   R R W W W     TOTL',CR,LF
    DB '   o t u C P POWER   P e m C t o C C E n O C S e e C D O     POWR',CR,LF
    DB '   r P l o C  ON     o b t o C w o o n a C u u s s o i C      ON ',CR,LF
    DB '   t w e m m PORTS   r u W m m e n n b b u r s D e n s u DVC PORT',CR,LF
    DB '   s r s p p (mA)    t g k p p r n n l l r r p t t n c r ADR (mA) STS LED TEST',CR,LF
    DB '  屯屯屯屯屯 屯屯  屯 屯屯屯 屯屯屯屯屯屯屯屯屯 屯屯 屯 屯屯 屯 屯 屯屯',CR,LF
    DB 0

  HeaderMsgEHCI3:
    DB '  INTERRUPT   屯屯LEGACY SUPPORT屯屯',CR,LF
    DB '    U S P F A     S  C U S P F A  O P B',CR,LF
    DB '    S y t r s   B y  o S y t r s  S C s',CR,LF
    DB '  U B s C m y   I s  m B s C m y  O I A',CR,LF
    DB '  S E E h R A   O t  p E E h R A  w C d',CR,LF
    DB '  B r r g l v   S m  l r r g l v  n m r',CR,LF
    DB '   屯 屯屯   屯   屯 屯屯  屯屯',CR,LF
    DB 0

  ;----------------------------------------------------------------------------
  ;EHCI Port Status Lookup Table
  ;----------------------------------------------------------------------------
  EPtStatusTbl:
    DB  00h, 'SE0',0 ;SE0
    DB  01h, 'JSt',0 ;J-State
    DB  02h, 'KSt',0 ;K-State
    DB  -1,  'Err',0 ;Undefined (Error)

  ;----------------------------------------------------------------------------
  ;EHCI LED Indicator Lookup Table
  ;----------------------------------------------------------------------------
  EPtIndicatorTbl:
    DB  00h, 'Off',0 ;Off
    DB  01h, 'Amb',0 ;Amber
    DB  02h, 'Grn',0 ;Green
    DB  -1,  'Err',0 ;Undefined (Error)

  ;----------------------------------------------------------------------------
  ;EHCI Test Status Lookup Table
  ;----------------------------------------------------------------------------
  EPtTestTbl:
    DB  00h, 'None',0 ;None (Normal)
    DB  01h, 'J-St',0 ;J-State
    DB  02h, 'K-St',0 ;K-State
    DB  03h, 'SE0 ',0 ;SE0-NAK
    DB  04h, 'Pakt',0 ;Packet
    DB  05h, 'Enbl',0 ;Force-Enable
    DB  -1,  'Err!',0 ;Undefined/Error


;==============================================================================
;Strings to write detailed UHCI Host Status
;==============================================================================

  HeaderMsgUHCI1:
    DB '  屯屯屯屯GENERAL屯屯屯屯',CR,LF
    DB '      C P D P S   H F E R',CR,LF
    DB '    H o k e r y G C G G e',CR,LF
    DB '  R a n t b c s R R R S s  FRAME LIST',CR,LF
    DB '  u l f 6 u E E s s s u D  BASE       FRAME FRAME',CR,LF
    DB '  n t g 4 g r r t t m s t  ADDRESS    TIME  NUMBR',CR,LF
    DB '  屯 屯屯 屯 屯 屯屯  屯屯屯屯屯 屯屯 屯屯',CR,LF
    DB 0

  HeaderMsgUHCI2:
    DB '  屯屯屯屯屯屯屯ROOT HUB屯屯屯屯屯屯屯   INTERRUPTS   LEGACY SUPPORT',CR,LF
    DB '  TOTAL    ~   ~ E   R R L L L     TOTL     U  O R S T                A A',CR,LF
    DB '  POWER  P C C E n S e e o i i     POWR     S  n e h O   P S          2 2',CR,LF
    DB '   ON    o o o n a u s s S n n      ON    U B  C s P C   I M  6 6 6 6 0 0',CR,LF
    DB '  PORTS  r n n b b s D e p D D DVC PORT   S E  m u k R   R I  4 4 0 0 P E',CR,LF
    DB '  (mA)   t n n l l p t t d - + ADR (mA)   B r  p m t C   Q #  W R W R T d',CR,LF
    DB '  屯屯  屯屯屯屯屯屯屯 屯屯 屯 屯屯   屯  屯屯屯   屯  屯屯屯屯屯',CR,LF
    DB 0


;==============================================================================
;EXEC Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Variables to Locate and Run another Program (EXEC Child Program)
  ;----------------------------------------------------------------------------
  PathToUse:      DB MaxPathSize DUP (0) ;Path to Use
  OurPathPointer  DW -1                  ;Pointer to our Path String
  CurrentPath:    DB  0                  ;Current Path (Zero-Length ASCIIZ)
  PathVarPointer  DW -1                  ;Pointer to PATH Environment Variable
  SupportFile:    DB 'VENDORID.COM',0    ;Support File Name to Look for
  PathVarString1: DB 'PATH='             ;PATH Environment String Header (DOS)
  PathVarString2: DB 'Path='             ;PATH Environment String Header (NT?)
  PathVarSize    EQU $-PathVarString2    ;Length of String

  ;----------------------------------------------------------------------------
  ;Strings needed to set up Command Tail for Exec Call
  ;----------------------------------------------------------------------------
  WordCmdTail:    DB 'PCI xxxxh xxxx:xxxx',0 ;Command Tail String

  ;----------------------------------------------------------------------------
  ;Variables needed to do EXEC Call
  ;----------------------------------------------------------------------------
  CmdTailSize DB CmdTailMax-2           ;Length of command tail (Maximize it)
  CmdTail:    DB CmdTailMax DUP (CR)    ;Command Tail for EXEC Call
  ParamBlock: DB ParamBlockSize DUP (?) ;Parameter Block for EXEC Call
  FCB1:       DB FCBSize DUP (?)        ;File Control Block #1
  FCB2:       DB FCBSize DUP (?)        ;File Control Block #2
  OldSPExec   DW ?                      ;SP may be destroyed by EXEC Call


;==============================================================================
;Data needed to determine who our Parent Program is
;==============================================================================

  ;----------------------------------------------------------------------------
  ;ASCIIZ Name of our Parent (the name stored in the MCB for our Parents PSP)
  ;----------------------------------------------------------------------------
  ParentName: DB 9 DUP (0)

  ;----------------------------------------------------------------------------
  ;Is our Parent a DOS Shell?
  ;----------------------------------------------------------------------------
  ParentIsShell DB No

  ;----------------------------------------------------------------------------
  ;CallBack Addresses that may be provided by another program
  ;An offset of -1 (the first word) indicates an invalid address
  ;----------------------------------------------------------------------------
  CallBackAddr  DD -1 ;Address for General Writing
  CallBackAddr2 DD -1 ;Address to write Headers

  ;----------------------------------------------------------------------------
  ;Table of possible DOS Shell programs (COMMAND.COM or equivalents)
  ;Must be capitalized, 8 characters ASCIIZ (not including 0 at end) max
  ;More things could be added to this table if they are discovered;
  ;  e.g., if FreeDOS or DR DOS or ... use a Shell Name other than COMMAND
  ;----------------------------------------------------------------------------
  DOSShellTbl:
    DB 'COMMAND',0 ;Standard DOS
    DB 'CMD',0     ;Windows NT & IBM OS/2
    DB 'NDOS',0    ;Norton Shell (from Norton Utilities)
    DB '4DOS',0    ;4DOS
    DB '4NT',0     ;4NT
    DB '4OS2',0    ;4OS2
    DB 0           ;End of Table


;==============================================================================
;DOS Environment Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Variables to search for an extended Command Line String
  ;This should only be valid/needed if the Command Line Size (PSP:[80h]) is 7Eh
  ;----------------------------------------------------------------------------
  CmdLineVarString:  DB 'CMDLINE='         ;Environment Variable String
  CmdLineVarSize    EQU $-CmdLineVarString ;Length of String
  CmdLineVarPointer  DW -1                 ;Pointer to Program Environment Variable


;==============================================================================
;Program/USB Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Data Structures needed to issue Requests to the USB Host
  ;----------------------------------------------------------------------------
  EVEN 2
  Int14Request: DB Int14RequestSize DUP (0)

  ;----------------------------------------------------------------------------
  ;Temporary Data we need to store while procesing things
  ;----------------------------------------------------------------------------
  PCIDevFunc  DB  ? ;Device & Function Number of USB on PCI
                    ;Bits 7-3 = Device, Bits 2-0 = Function
  PCIBusNum   DB  ? ;PCI Bus Number of USB
  HostIndex   DB -1 ;Host Index, if compatible Host Driver controls Host
                    ;  -1 = No Host Driver, or incompatible Host Driver
  BaseAddress DD  ? ;Base I/O Address of Host if UHCI,
                    ;Base Memory Address of Host if OHCI or EHCI)


;==============================================================================
;Memory Related
;==============================================================================

  MemCopyTable: DB MemCopySize DUP (0) ;Descriptor Table needed for Mem copy


;==============================================================================
;Help Screen Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Data needed if the User has changed the name of the program from USBHOSTS
  ;----------------------------------------------------------------------------
  RealName:
    DB 'USBHOSTS',0 ;Real name of our program (MUST end in 0)
                    ;  & MUST have enough space for 8-char name
  RealNameSz DW 8   ;Size of RealName (not incl 0)

  ;----------------------------------------------------------------------------
  ;Syntax Help String (if user asks for, or otherwise needs, Help)
  ;----------------------------------------------------------------------------
  SyntaxMsgHdr:
    DB 'SYNTAX: ',0
  SyntaxMsg:
    DB '[Options]',CR,LF
    DB LF
    DB '  ?  Show this HELP screen',CR,LF
    DB '  A  Show all ALIASES for these command line options',CR,LF
    DB '  V  Show all errorleVels (DOS return codes)',CR,LF
    DB LF
    DB '  D    Show DETAILED status of All Hosts',CR,LF
    DB '  E #  Show Detailed status of ENHANCED Host, PCI Search Index #',CR,LF
    DB '  O #  Show Detailed status of OPEN Host, PCI Search Index #',CR,LF
    DB '  U #  Show Detailed status of UNIVERSAL Host, PCI Search Index #',CR,LF
    DB LF
    DB '  With no Options, shows a Summary (not Detailed) status of all USB Hosts',CR,LF
    DB LF
    DB '  S #  STOP (unconfigure) Enhanced Host, PCI Search Index #',CR,LF
    DB LF
    DB 'If running from inside another program (if not running from the command-line),',CR,LF
    DB '  the other options can be followed by two hex call-back addresses',CR,LF
    DB '  (#Segment:#Offset) to which the output and headers will be written.',CR,LF
    DB 'See USBHOSTS.DOC for details.',CR,LF
    DB 0


;==============================================================================
;Alias Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings needed to print Command Line Aliases to the screen
  ;----------------------------------------------------------------------------
  AliasHdrMsg:
    DB '                   ALIASES FOR COMMAND-LINE OPTIONS',CR,LF
    DB '屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯',CR,LF,0

  ;----------------------------------------------------------------------------
  ;Table needed to temporarily store Aliases.
  ;They are originally sorted in reverse alphabetical order.
  ;To write them in forward alphabetical order, we temporarily store
  ;  the String Pointers, in the original reverse order, in this table.
  ;  We then write the strings, starting with the last entry in this table
  ;  and moving backwards.
  ;The number of entries in this table must be AT LEAST as big as the largest
  ;  number of Aliases for a single command Option.  Most Options don't have
  ;  more than a dozen or so Aliases.
  ;----------------------------------------------------------------------------
  AliasSortTbl: DW 100 DUP (?) ;Table to store Alias Strings (to reverse order)


;==============================================================================
;ErrorLevel Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;ErrorLevels, and Table for ErrorLevel Description Strings
  ;----------------------------------------------------------------------------
  ErLvlOption  EQU 1 ;Bad Option on the command line
  ErLvlDOSVer  EQU 2 ;DOS Version too old
  ErLvlNo386   EQU 3 ;Not a 386+ CPU
  ErLvlNoPCI   EQU 4 ;No PCI BIOS installed
  ErLvlNoHosts EQU 5 ;No USB Hosts installed

  ErrLvlHdr:
    DB '          ERRORLEVELS (DOS RETURN CODES)',CR,LF
    DB '  屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯',CR,LF
    DB '   0 No Error.',CR,LF,0

  ErrLvlTbl:
    DB ErLvlOption
       DB "Bad Command-line Option.",0
    DB ErLvlDOSVer
       DOSVerMsg:
       DB "DOS must be at least version 3.00.",0
    DB ErLvlNo386
       No386Msg:
       DB "This program requires at least an 80386 CPU.",0
    DB ErLvlNoPCI
       NoPCIMsg:
       DB "Could not find a PCI-compatible BIOS.",0
    DB ErLvlNoHosts
       NoHostsMsg:
       DB "There are no USB Host Controllers installed.",0
    DB -1,-1 ;End of Table


;==============================================================================
;Data Needed to Process the Command Line
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Data needed to Parse the command line for Options
  ;----------------------------------------------------------------------------
  ParseTest  DB Yes ;Testing the command for errors?
  ParseError DB  No ;Error while Parsing Command Line?

  ;----------------------------------------------------------------------------
  ;Various Parsing-related messages we may need to print to the screen
  ;----------------------------------------------------------------------------
  ParseCmdMsg:
    DB 'Error in the command-line Options for USBHOSTS:',CR,LF,0
  ParseErrMsg:
    DB '^ Error',CR,LF,LF,0
  ParseErrMsg2:
    DB 'Type "USBHOSTS ?" for Help.',CR,LF,0

  ;----------------------------------------------------------------------------
  ;Strings needed for a non-existent Host Index
  ;----------------------------------------------------------------------------
  NoHostMsg1:
    DB 'HCI Host with PCI Search Index #',0
  NoHostMsg2:
    DB ' does not exist.',0

  ;----------------------------------------------------------------------------
  ;Strings needed to write the Command-line error message
  ;----------------------------------------------------------------------------
  MoreLeftMsg:   DB '<<-More}  ',0
  MoreRightMsg:  DB '  {More->>',0
  MoreMsgSize   EQU $-MoreRightMsg

  ;----------------------------------------------------------------------------
  ;Miscellaneous Yes/No flags
  ;----------------------------------------------------------------------------
  ProgFlags   DB 00h ;Miscellaneous Yes/No Flags
    Help     EQU 01h ;Write the Help Screen
    Alias    EQU 02h ;Write Alias Table
    ErrLvl   EQU 04h ;Write ErrorLevel Table
    WroteOne EQU 08h ;Wrote at least one Host Detail
    AllHosts EQU 10h ;Write Details for all Hosts

  ;----------------------------------------------------------------------------
  ;Command Line Options
  ;----------------------------------------------------------------------------
  SwitchList:
    DB 'Help',0
    DB  0, '?'
      ; ^              Beginning-of-List Marker
      ;    ^   ^        Code(s) to use

    DB 'UniversalHst',0
    DB 'UniversalHost',0
    DB 'UniversalHCI',0
    DB 'Universal',0
    DB  0, 'U'

    DB 'UnconfigureHst',0
    DB 'UnconfigureHost',0
    DB 'UnconfigureEnhancedHst',0
    DB 'UnconfigureEnhancedHost',0
    DB 'UnconfigureEnhancedHCI',0
    DB 'UnconfigureEnhanced',0
    DB 'UnconfigureEHCI',0
    DB 'Unconfigure',0
    DB  0, 'S'

    DB 'UHCI',0
    DB  0, 'U'

    DB 'StopHst',0
    DB 'StopHost',0
    DB 'StopEnhancedHst',0
    DB 'StopEnhancedHost',0
    DB 'StopEnhancedHCI',0
    DB 'StopEnhanced',0
    DB 'StopEHCI',0
    DB 'Stop',0
    DB  0, 'S'

    DB 'OptionAliases',0
    DB 'OptionAlias',0
    DB  0, 'A'

    DB 'OpenHst',0
    DB 'OpenHost',0
    DB 'OpenHCI',0
    DB 'Open',0
    DB  0, 'O'

    DB 'OHCI',0
    DB  0, 'O'

    DB 'Hlp',0
    DB 'H',0
    DB  0, '?'

    DB 'ErrorLvlTbl',0
    DB 'ErrorLvlTable',0
    DB 'ErrorLvls',0
    DB 'ErrorLvl',0
    DB 'ErrorLevelTbl',0
    DB 'ErrorLevelTable',0
    DB 'ErrorLevels',0
    DB 'ErrorLevel',0
    DB  0, 'V'

    DB 'ErrLvlTbl',0
    DB 'ErrLvlTable',0
    DB 'ErrLvls',0
    DB 'ErrLvl',0
    DB 'ErrLevelTbl',0
    DB 'ErrLevelTable',0
    DB 'ErrLevels',0
    DB 'ErrLevel',0
    DB  0, 'V'

    DB 'ErLvlTbl',0
    DB 'ErLvlTable',0
    DB 'ErLvls',0
    DB 'ErLvl',0
    DB 'ErLevelTbl',0
    DB 'ErLevelTable',0
    DB 'ErLevels',0
    DB 'ErLevel',0
    DB  0, 'V'

    DB 'EnhancedHst',0
    DB 'EnhancedHost',0
    DB 'EnhancedHCI',0
    DB 'Enhanced',0
    DB  0, 'E'

    DB 'EHCI',0
    DB  0, 'E'

    DB 'Details',0
    DB 'Detail',0
    DB  0, 'D'

    DB 'CommandLineAliases',0
    DB 'CommandLineAlias',0
    DB  0, 'A'

    DB 'CmdLineAliases',0
    DB 'CmdLineAlias',0
    DB  0, 'A'

    DB 'AllHostsDetails',0
    DB 'AllHosts',0
    DB 'AllHostDetails',0
    DB 'AllHost',0
    DB 'AllDetails',0
    DB 'All',0
    DB  0, 'D'

    DB 'Aliases',0
    DB 'Alias',0
    DB  0, 'A'

    DB  0 ;End of list

  ;----------------------------------------------------------------------------
  ;Table of Subroutine Offsets to Process the Various Command Line Options
  ;----------------------------------------------------------------------------
  SwitchTbl:
    DB '?'          ;Help
       DW DoSwitchH
    DB 'A'          ;Command-line Aliases
       DW DoSwitchA
    DB 'D'          ;All Hosts Details
       DW DoSwitchD
    DB 'E'          ;EHCI Host Details
       DW DoSwitchE
    DB 'O'          ;OHCI Host Details
       DW DoSwitchO
    DB 'S'          ;Stop (unconfigure) EHCI Host
       DW DoSwitchS
    DB 'U'          ;UHCI Host Details
       DW DoSwitchU
    DB 'V'          ;ErrorLevel Table
       DW DoSwitchV
    DB 0 ;End of Table


;哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌哌
;CODE
;苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘苘

;------------------------------------------------------------------------------
;DO THE PROGRAM THING!
;Inputs:
;Outputs: Lots of Stuff
;Changes: Everything
;------------------------------------------------------------------------------
Main:
  CLD                     ;Go forward with string functions
  MOV  SP,LastProgByte    ;Reset Stack Pointer
  CALL ResizeMemory       ;Resize our Memory Allocation
  CALL CopyNameToMCB      ;Copy our Program name to the MCB
  CALL SetupPauseNoHdr    ;Set up the Pause
  CALL TestParentShell    ;See if our Parent is a DOS Command Shell
  JNZ >M10                ;If not, don't write the Copyright
  MOV  DX,Copyright       ;If so, write the
  CALL WriteZPause        ;  Copyright message
M10:                      ;Copyright written, if appropriate
  CALL GetRealName        ;Get the Real Program Name
  CALL SetupExec          ;Setup Exec Parameters
  CALL GetOurPath         ;Get the Pointer to Our Path
  CALL GetEnvVars         ;Get the Environment variables
  CALL FixCmdLineCR       ;Replace CR at end of Command Line with a 0
  MOV  ParseTest,Yes      ;Test the command-line
  CALL ParseThings        ;  for errors (quit if Error)
  CALL DoHelp             ;Print Help and Quit, if necessary
  CALL DoAliases          ;Print Aliases and Quit, if necessary
  CALL DoErrLvls          ;Print ErrorLevel Table and Quit, if necessary
  CALL TestCompatibility  ;Test for hardware compatibility (quit if error)
  MOV  ParseTest,No       ;Parse the Command-line
  CALL ParseThings        ;  for real
  TEST ProgFlags,WroteOne ;Did we already write some Host Details?
  JNZ >M80                ;If so, don't write the summary
M20:                      ;Need to write Summary or Details for ALL Hosts
  TEST ProgFlags,AllHosts ;Should we do Summary or Detail?
  JNZ >M30                ;If Detail, jump to handle it
M25:                      ;Do All Hosts Summary
  CALL DoAllSummary       ;Do a Summary Status of All Hosts
  JMP >M80                ;Done
M30:                      ;Do All Hosts Detail
  CALL DoAllDetail        ;Do a Detail Status of All Hosts
M80:                      ;Done writing
  MOV  DX,NoMsg           ;Point at empty message
M90:                      ;We're done
  XOR  AL,AL              ;Quit with ErrorLevel = 0
;  JMP  Exit

;------------------------------------------------------------------------------
;PRINT MESSAGE IN DX AND QUIT WITH ERRORLEVEL IN AL
;Inputs:  AL = Errorlevel to exit program with
;         DS:[DX] = Message to Print (to ERR)
;Outputs:
;Changes: Quits program
;------------------------------------------------------------------------------
Exit:
  OR   AL,AL       ;Was there an Error?
  JZ  >X80         ;If not, jump to handle a normal termination
  CALL BeepErr     ;If error, Beep Once
  CALL WriteZErr   ;Write message to ERR
  MOV  DX,CrLfMsg  ;Write a
  CALL WriteZErr   ;  new line
  JMP >X90         ;Jump to quit
X80:               ;No Error - Write to CON
  CALL WriteItDX   ;Write the message to CON
X90:               ;We're done!!
  MOV  AH,4Ch      ;Service 4Ch (terminate program)
  INT  21h         ;Do it

;------------------------------------------------------------------------------
;MAKE SURE THE MCB (MEMORY CONTROL BLOCK) CONTAINS OUR PROGRAM NAME
;Inputs:  DS = Local Data Area
;         DS:RealName = ASCIIZ Real Name of our program
;         CLD Already Issued
;Outputs:
;Changes: Data in MCB
;NOTES:   This makes sure that the MCB (Memory Control Block) for our
;           program contains our program name.  DOS 4+ does this
;           automatically, but DOS versions 1-3 do not.  This code
;           does not verify whihc DOS version is in use, but simply
;           fills in the MCB no matter what.
;         Our program name is needed inthe MCB to make sure other programs
;           can identify that we are installed in memory.  This code should
;           be added to all TSR's, so that memory-mapping programs
;           (like MAPMEM or ISLOADED) can tell which TSR's are installed
;           in memory.  It should also be added to all programs that
;           EXEC other programs, so that the EXEC'd program can figure out
;           who called it.
;         Programs that are not TSR's and do not EXEC other programs
;           do not need this code.
;------------------------------------------------------------------------------
CopyNameToMCB:
  PUSH CX,DI,SI,ES              ;Save used registers
  MOV  CX,DS                    ;Point ES:[DI]
  DEC  CX                       ;  at the Owners Name
  MOV  ES,CX                    ;  in the MCB
  MOV  DI,(OFFSET MCBOwnerName) ;  of our program
  MOV  SI,RealName              ;Point DS:[SI] at our Program Name
  MOV  CX,4                     ;Copy 4 words (8 bytes)
  REP  MOVSW                    ;Copy our program name to the MCB
  POP  ES,SI,DI,CX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;BEEP THE SPEAKER
;Inputs:
;Outputs: Beeps the speaker
;Changes:
;------------------------------------------------------------------------------
BeepErr:
  PUSH AX,BX    ;Save used registers
  XOR  BX,BX    ;BH = Video page = 0
  MOV  AX,0E07h ;AH = 0Eh = Function = Write TTY
                ;AL = 07h = Character to write = BEL
  INT  10h      ;Do it
  POP  BX,AX    ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO DETERMINE WHO OUR PARENT PROGRAM IS
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;COPY THE CAPITALIZED NAME OF OUR PARENT PROGRAM TO A LOCAL STRING (PARENTNAME)
;Inputs:  ParentIsShell = No
;Outputs: ParentIsShell = Yes if Parent Program has a Shell Name
;                         ZF = Set
;                       = No if Parent Program does not have a Shell Name
;                         ZF = Clear
;Changes:
;------------------------------------------------------------------------------
TestParentShell:
  PUSH AX,BX,DI,SI       ;Save used registers
  CALL GetParentNameCaps ;Get our Parents Capitalized Name
  JZ  >S80               ;If invalid, assume we're at a command-line
  MOV  SI,DOSShellTbl    ;Point at our table of Shell Names
S10:                     ;Loop to here for each table entry
  MOV  DI,ParentName     ;Point DI at our Parents Name
  MOV  BX,SI             ;Save the current table pointer
  CMP  B [BX],0          ;End of the Table?
  JE  >S90               ;If so, it's not a Command Shell
S20:                     ;Loop to here for each character in the string
  MOV  AL,[BX]           ;Get the next table character
  OR   AL,AL             ;End of the table string?
  JZ  >S40               ;If so, handle it
S30:                     ;Not end of table string
  CMP  AL,[DI]           ;Does the character match?
  JNE >S60               ;If not, try the next table entry
  INC  BX                ;If so, increment
  INC  DI                ;  our Pointers
  JMP  S20               ;and keep testing
S40:                     ;End of our table string
  CMP  B [DI],0          ;End of the Parents Name string?
  JE  >S80               ;If so, it's a match
S60:                     ;Not a match
  CALL SkipOverStringSI  ;Point at the next table entry
  JMP  S10               ;Keep going until we're done
S80:                     ;Is a Command Shell
  MOV  ParentIsShell,Yes ;Store the result for later
S90:                     ;Done
  CMP  ParentIsShell,Yes ;Set the return flag
  POP  SI,DI,BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY THE CAPITALIZED NAME OF OUR PARENT PROGRAM TO A LOCAL STRING (PARENTNAME)
;Inputs:  ES = Local Data Area
;         CLD already issued
;Outputs: ParentName
;         ZF = Clear if ParentName is valid (greater than 0 length)
;            = Set if Invalid (0-length, such as under the DOSBox program)
;Changes:
;------------------------------------------------------------------------------
GetParentNameCaps:
  PUSH AX,CX,DI,SI,DS         ;Save used registers
  MOV  AX,[PSPParentPSP]      ;Point DS at
  DEC  AX                     ;  the MCB of our
  MOV  DS,AX                  ;  Parents PSP
  MOV  SI,OFFSET MCBOwnerName ;Point DS:[SI] at the Owners name
  MOV  DI,ParentName          ;Point ES:[DI] at our storage area
  MOV  CX,8                   ;Copy 8 bytes
P10:                          ;Loop to here for each character
  LODSB                       ;Get the next byte
  CALL Capitalize             ;Capitalize it
  STOSB                       ;Store it
  LOOP P10                    ;Keep going until we're done
  CMP  ES:B ParentName[0],0   ;Set return flag
  POP  DS,SI,DI,CX,AX         ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO TEST THE COMPUTER FOR MINIMUM COMPATIBILITY (DOS VERSION, ETC)
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;TEST THE COMPUTER TO SEE IF IT'S COMPATIBLE (CPU, DOS VERSION, WHATEVER)
;Inputs:  InMemory
;Outputs: Quits the program if Computer is Incompatible
;         Returns if Computer is OK
;         Stores all kinds of values in memory variables
;Changes:
;------------------------------------------------------------------------------
TestCompatibility:
  PUSH AX,DX           ;Save used registers
  MOV  AL,ErLvlDOSVer  ;Assume incorrect
  MOV  DX,DOSVerMsg    ;  DOS Version
  CALL TestDOSVer      ;  new enough?
  JC  >C70             ;If not, error
  MOV  AL,ErLvlNo386   ;Assume CPU is
  MOV  DX,No386Msg     ;  not 386+
  CALL Test80386       ;Is the CPU at least an 80386?
  JC  >C70             ;If not, error
  MOV  AL,ErLvlNoPCI   ;Assume no PCI
  MOV  DX,NoPCIMsg     ;  BIOS is installed
  CALL TestPCI         ;Is a PCI BIOS installed?
  JC  >C70             ;If not error
  MOV  AL,ErLvlNoHosts ;Assume no USB
  MOV  DX,NoHostsMsg   ;  Hosts are installed
  CALL TestAnyHosts    ;Are any USB Hosts installed?
  JNC >C90             ;If so, we're OK
C70:                   ;The computer is incompatible for some reason
  JMP  Exit            ;Quit!
C90:                   ;The computer is compatible!
  POP  DX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST THE CURRENT DOS VERSION
;Inputs:  MinDOSVer (EQUate)
;Outputs: CF = Clear if DOS version >= MinDOSVer
;         CF = Set if DOS version < MinDOSVer
;Changes:
;------------------------------------------------------------------------------
TestDOSVer:
  PUSH AX,BX,CX     ;Save used registers
  MOV  AX,3000h     ;Service 30h (get DOS version number)
                    ;  DOS 5.0 requires AL = 00h, may change BX and CX
  INT  21h          ;Do it (Returns AL= Major, AH = Minor)
  XCHG AL,AH        ;Swap Major and Minor versions for testing
  CMP  AX,MinDOSVer ;Is the version new enough?
  JAE >D80          ;If so, it's OK
D70:                ;DOS is older than the minimum
  STC               ;Set the "too old" flag
  JMP >D90          ;We're done
D80:                ;DOS is >= the minimum
  CLC               ;Set the OK flag
D90:                ;We're done
  POP  CX,BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THE CPU IS AN 80386+ (CAN HANDLE 32-BIT INSTRUCTIONS)
;Inputs:
;Outputs: CF = Clear if the CPU is an 80386+
;            = Set if CPU is not an 80386+
;Changes:
;------------------------------------------------------------------------------
Test80386:
  PUSH AX,BX     ;Save used registers
  PUSHF          ;Save flags
  CALL Test8086  ;Is it an 8086?
  JNC >E70       ;If so, it can't be an 80386
  MOV  BX,0F000h ;Flags mask for testing (these bits always clear on 80286)
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  OR   AX,BX     ;Try to set the
  PUSH AX        ;  four high bits
  POPF           ;  of the flags
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  TEST AX,BX     ;Are any of the four high bits set?
  JNZ >E80       ;If so, it's not an 80286 - it must be an 80386+
E70:             ;It's not an 80386
  POPF           ;Restore flags
  STC            ;Set the not 80386 flag
  JMP >E90       ;We're done
E80:             ;It is an 80386
  POPF           ;Restore flags
  CLC            ;Set the 80386 flag
E90:             ;We're done
  POP  BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THE CPU IS AN 8086/8088
;Inputs:
;Outputs: CF = Clear if the CPU is an 8086/8088
;            = Set if not at 8086/8088
;Changes:
;NOTE: Unlike the other CPU tests, this is not a "greater than or equal to".
;      The CPU must be EXACTLY an 8086/8088, or this returns with CF set.
;------------------------------------------------------------------------------
Test8086:
  PUSH AX,BX     ;Save used registers
  PUSHF          ;Save flags
  MOV  BX,0F000h ;Flags mask for testing (these bits always set on 8086/8088)
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  AND  AX,0FFFh  ;Try to clear the
  PUSH AX        ;  four high bits
  POPF           ;  of the flags
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  AND  AX,BX     ;Are the four high bits
  CMP  AX,BX     ;  of the flags set?
  JE  >E80       ;If so, it's an 8086/8088
  POPF           ;Restore flags
E70:             ;It is not an 8086/8088
  STC            ;Set the not 8086/8088 flag
  JMP >E90       ;We're done
E80:             ;It is an 8086/8088
  POPF           ;Restore flags
  CLC            ;Set the 8086/8088 flag
E90:             ;We're done
  POP  BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A PCI BIOS IS INSTALLED
;Inputs:
;Outputs: CF = Clear if a PCI BIOS is installed
;            = Set if a PCI BIOS is not installed
;Changes:
;------------------------------------------------------------------------------
TestPCI:
  PUSH EAX,EBX,ECX    ;Save used registers
  PUSH EDX,EDI        ;Save used registers
  PUSHFD              ;Save flags
  MOV  AX,0B101h      ;Function B101h (PCI BIOS installation check)
  XOR  EDX,EDX        ;EDX = 0 in case of bad call
  XOR  EDI,EDI        ;EDI = 0 in case of bad call
  STC                 ;Set carry flag in case of bad call
  INT  1Ah            ;Do it
  JC  >P70            ;If error, no PCI installed
  CMP  EDX,2049_4350h ;Did it return EDX = ' ICP'?
  JE  >P80            ;If so, PCI is installed
P70:                  ;PCI not installed
  POPFD               ;Restore flags
  STC                 ;Set the not installed flag
  JMP >P90            ;We're done
P80:                  ;PCI is installed
  POPFD               ;Restore flags
  CLC                 ;Set the installed flag
P90:                  ;We're done
  POP  EDI,EDX        ;Restore used registers
  POP  ECX,EBX,EAX    ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;MISCELLANEOUS COMPATIBILITY/CAPABILITY TESTS
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;TEST AND SEE IF ANY USB HOST CONTROLLERS ARE INSTALLED
;Inputs:
;Outputs: CF = Clear if at least one USB Host Controller is installed
;            = Set if no USB Host Controllers were found
;Changes:
;------------------------------------------------------------------------------
TestAnyHosts:
  PUSH AX,SI           ;Save used registers
  XOR  SI,SI           ;SI = PCI Search Index 0
  MOV  AL,ProgIntfUHCI ;AL = Programming Interface = UHCI
  CALL TestHost        ;Any Hosts Installed?
  JNC >Y80             ;If so, we're done
  MOV  AL,ProgIntfOHCI ;AL = Programming Interface = OHCI
  CALL TestHost        ;Any Hosts Installed?
  JNC >Y80             ;If so, we're done
  MOV  AL,ProgIntfEHCI ;AL = Programming Interface = EHCI
  CALL TestHost        ;Any Hosts Installed?
  JNC >Y80             ;If so, we're done
Y70:                   ;No Hosts Installed
  STC                  ;Set return flag
  JMP >Y90             ;Done
Y80:                   ;At least one Host
  CLC                  ;Set return flag
Y90:                   ;Done
  POP  SI,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST TO SEE IF THE CPU IS IN REAL MODE
;Inputs:  CPU already tested for 80286+
;Outputs: ZF = Set if Real Mode
;            = Clear if Protected (V86) Mode
;Changes:
;------------------------------------------------------------------------------
TestRealMode:
  PUSH AX   ;Save used registers
  SMSW AX   ;Get the Machine Status Word
  TEST AL,1 ;Set return flag
  POP  AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST TO SEE IF THE PAGING IS TURNED ON IN THE CPU
;Inputs:  CPU already tested for 80386+
;Outputs: CF = Set if Paging is On/Enabled
;            = Clear if Paging is Off/Disabled
;Changes:
;------------------------------------------------------------------------------
TestPaging:
  PUSH EAX     ;Save used registers
  MOV  EAX,CR0 ;Get CPU Control Register 0
  ROL  EAX,1   ;Set return flag
  POP  EAX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF VCPI IS INSTALLED (VIRTUAL CONTROL PROGRAM INTERFACE)
;Inputs:
;Outputs: CF = Clear if installed
;            = Set if not installed
;Changes:
;------------------------------------------------------------------------------
TestVCPI:
  PUSH AX,BX     ;Save used registers
  MOV  AL,67h    ;Is Int 67h
  CALL TestInt   ;  even installed?
  JZ  >V70       ;If not, VCPI can't be installed
  CALL TestDPMI  ;Is DPMI installed?
  JNC >V70       ;If so, VCPI can't be installed
                 ;Note that this DPMI test should avoid problems with Windows,
                 ;  which doesn't like the direct VCPI test
  MOV  AX,0DE00h ;Function DE00h (VCPI Install Check)
  INT  67h       ;Do it (also returns BX = version)
  OR   AH,AH     ;Is it installed?
  JZ  >V80       ;If so, jump to set the installed flag
V70:             ;VCPI is not installed
  STC            ;Set the not installed flag
  JMP >V90       ;We're done
V80:             ;VCPI is installed
  CLC            ;Set the installed flag
V90:             ;We're done
  POP  BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF AN INTERRUPT VECTOR HAS A VALID ADDRESS (other than 0)
;Inputs:  AL = Interrupt number to test
;Outputs: ZF = Set if invalid address (all zeroes)
;            = Clear if valid address (anything other than zeroes)
;Changes:
;------------------------------------------------------------------------------
TestInt:
  PUSH AX,BX,ES ;Save used registers
  MOV  AH,35h   ;Function 35h (get Interrupt Vector), AL = Int # to get
  INT  21h      ;Do it (returns ES:BX)
  MOV  AX,ES    ;Put the segment in AX so we can test it
  OR   AX,AX    ;Is the segment valid (set the return flag)?
  POP  ES,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF DPMI IS INSTALLED (DOS PROTECTED MODE INTERFACE)
;Inputs:
;Outputs: CF = Clear if DPMI is installed
;            = Set if DPMI is not installed
;Changes:
;------------------------------------------------------------------------------
TestDPMI:
  PUSH AX,BX,CX,DX ;Save used registers
  PUSH DI,SI,ES    ;Save used registers
  MOV  AX,1687h    ;Function 1687h (DPMI Install Check)
  INT  2Fh         ;Do it (returns all kinds of stuff)
  OR   AX,AX       ;Is it installed?
  JZ  >D80         ;If so, jump to set the installed flag
D70:               ;DPMI is not installed
  STC              ;Set the not installed flag
  JMP >D90         ;We're done
D80:               ;DPMI is installed
  CLC              ;Set the installed flag
D90:               ;We're done
  POP  ES,SI,DI    ;Restore used registers
  POP  DX,CX,BX,AX ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO TEST AND WRITE THE STATUS OF THE USB HOST CONTROLLERS
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;WRITE SUMMARY STATUS FOR ALL USB CONTROLLERS
;Inputs:
;Outputs: Writes necessary messages to screen displaying information
;Changes:
;------------------------------------------------------------------------------
DoAllSummary:
  PUSH CX,DX,SI        ;Save used registers
  MOV  DX,HeaderMsg0   ;Write the
  CALL WriteHeader0    ;  Header
U10:                   ;Do UHCI Controllers
  XOR  SI,SI           ;Start with Index 0
  MOV  CH,ProgIntfUHCI ;Mark as UHCI
U15:                   ;Loop to here for each UHCI Controller
  CALL TestUHCI        ;Look for a Controller
  JC  >U17             ;If none, try next possibility
  INC  SI              ;Go to next Index
  CALL WriteCrLfPause  ;Write a new line
  JMP  U15             ;Keep looking
U17:                   ;Done with OHCI Controllers
  CALL WriteSumDivider ;Write Divider Line, if appropriate
U20:                   ;Do OHCI Controllers
  XOR  SI,SI           ;Start with Index 0
  MOV  CH,ProgIntfOHCI ;Mark as OHCI
U25:                   ;Loop to here for each UHCI Controller
  CALL TestOHCI        ;Look for a Controller
  JC  >U27             ;If none, try next possibility
  INC  SI              ;Go to next Index
  CALL WriteCrLfPause  ;Write a new line
  JMP  U25             ;Keep looking
U27:                   ;Done with OHCI Controllers
  CALL WriteSumDivider ;Write Divider Line, if appropriate
U30:                   ;Look for UHCI Controllers
  XOR  SI,SI           ;Start with Index 0
  MOV  CH,ProgIntfEHCI ;Mark as EHCI
U35:                   ;Loop to here for each UHCI Controller
  CALL TestEHCI        ;Look for a Controller
  JC  >U80             ;If none, try next possibility
  INC  SI              ;Go to next Index
  CALL WriteCrLfPause  ;Write a new line
  JMP  U35             ;Keep looking
U80:                   ;Done
  POP  SI,DX,CX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE DIVIDER MESSAGE BETWEEN USB SUMMARY HOST TYPES, IF APPROPRIATE
;Inputs:  SI = Number of Hosts Written in previous Type
;         ProgFlags.AllHosts = True if we are writing Details
;Outputs: Writes Divider line to the screen, if appropriate
;Changes:
;------------------------------------------------------------------------------
WriteSumDivider:
  PUSH DX                 ;Save used registers
  TEST ProgFlags,AllHosts ;Are we writing details?
  JNZ >D90                ;If so, we never write Divider Lines
  OR   SI,SI              ;If not, did we write anything the last time?
  JZ  >D90                ;If not, quit
  MOV  DX,DividerMsg      ;If so, write the
  CALL WriteItDX          ;  Divider Line
D90:                      ;Done
  POP  DX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE DETAIL STATUS FOR ALL USB CONTROLLERS
;Inputs:
;Outputs: Writes necessary messages to screen displaying information
;Changes:
;------------------------------------------------------------------------------
DoAllDetail:
  PUSH AX,SI             ;Save used registers
D10:                     ;Do UHCI Controllers
  XOR  SI,SI             ;Start with Index 0
  MOV  AL,ProgIntfUHCI   ;Mark as UHCI
D15:                     ;Loop to here for each UHCI Controller
  CALL TestHost          ;Look for a Controller
  JC  >D20               ;If none, try next possibility
  CALL WriteHostComplete ;If so, write Status
  INC  SI                ;Go to next Index
  JMP  D15               ;Keep looking
D20:                     ;Do OHCI Controllers
  XOR  SI,SI             ;Start with Index 0
  MOV  AL,ProgIntfOHCI   ;Mark as OHCI
D25:                     ;Loop to here for each UHCI Controller
  CALL TestHost          ;Look for a Controller
  JC  >D30               ;If none, try next possibility
  CALL WriteHostComplete ;If so, write Status
  INC  SI                ;Go to next Index
  JMP  D25               ;Keep looking
D30:                     ;Look for UHCI Controllers
  XOR  SI,SI             ;Start with Index 0
  MOV  AL,ProgIntfEHCI   ;Mark as EHCI
D35:                     ;Loop to here for each UHCI Controller
  CALL TestHost          ;Look for a Controller
  JC  >D80               ;If none, try next possibility
  CALL WriteHostComplete ;If so, write Status
  INC  SI                ;Go to next Index
  JMP  D35               ;Keep looking
D80:                     ;Done
  POP  SI,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THERE IS A PARTICULAR HOST CONTROLLER INSTALLED
;Inputs:  SI = Index Number to Test (starts with 0)
;         AL = PCI Programming Interface, if TestXHCI
;Outputs: CF = Clear if a Host is found
;              Writes Basic Info to Screen
;            = Set if no Host is Found
;Changes:
;------------------------------------------------------------------------------
TestXHCI:
  PUSH BX                ;Save used registers
  MOV  BX,TestUHCI       ;Assume UHCI
  CMP  AL,ProgIntfUHCI   ;Is it UHCI?
  JE  >X80               ;If so, continue
  MOV  BX,TestOHCI       ;Assume OHCI
  CMP  AL,ProgIntfOHCI   ;Is it OHCI?
  JE  >X80               ;If so, continue
  MOV  BX,TestEHCI       ;It must be EHCI
X80:                     ;[BX] = Test SubRoutine to call
  CALL BX                ;Call the SubRoutine
  POP  BX                ;Restore used registers
  RET

TestOHCI:
  PUSH CX                ;Save used registers
  MOV  CX,'O'+(ProgIntfOHCI SHL 8) ;OHCI
  JMP >H00               ;Do it
TestUHCI:
  PUSH CX                ;Save used registers
  MOV  CX,'U'+(ProgIntfUHCI SHL 8) ;UHCI
  JMP >H00               ;Do it
TestEHCI:
  PUSH CX                ;Save used registers
  MOV  CX,'E'+(ProgIntfEHCI SHL 8) ;EHCI
;  JMP >H00               ;Do it
H00:
  PUSH EAX,BX,DX,BP      ;Save used registers
  MOV  AL,CH             ;Look for
  CALL TestHost          ;  a Host (uses AL & SI)
  JC  >H70               ;If none found, error
  MOV  AL,CL             ;Write
  CALL WriteAL           ;  the
  MOV  DX,HCIMsg         ;  Host
  CALL WriteItDX         ;  Type
  MOV  AX,SI             ;Write the
  CALL ByteToString      ;  Search Index
  CALL WriteSpace        ;Move over
  CALL WriteBusInfo      ;Write the PCI Bus/DvcFunc, Vendor ID, & Product ID
                         ;Returns BP = Vendor ID
  CALL WriteVersion      ;Write the version
  MOV  BL,PCIIRQNum      ;Write
  CALL ReadPCIByte       ;  the
  CALL ByteToString      ;  IRQ Number
  CALL WriteSpace        ;Move over
  CALL WriteBaseAddr     ;Write Base I/O or Memory Address
  CALL WriteIndexStatus  ;Write the Driver Status
  CALL WriteCrLfPause    ;Move Down
  MOV  CL,18             ;Move
  CALL WriteSpaces       ;  over
  MOV  AX,BP             ;Write the
  CALL WriteVendorString ;  Vendor Description
  CALL WriteCrLfPause    ;Move down
  JMP >H80               ;Done
H70:                     ;USB not installed
  STC                    ;Set the not installed flag
  JMP >H90               ;We're done
H80:                     ;USB is installed
  CLC                    ;Set the installed flag
H90:                     ;We're done
  POP  BP,DX,BX,EAX      ;Restore used registers
  POP  CX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A PARTICULAR TYPE OF USB HOST CONTROLLER IS INSTALLED
;Inputs:  AL = Programming Interface to test for (UHCI=00h, OHCI=10h, EHCI=20h)
;         SI = Index Number to search for
;Outputs: CF = Clear if Host is Found
;              PCIDevFunc
;            = Set if Error
;Changes:
;------------------------------------------------------------------------------
TestHost:
  PUSH EAX,EBX,ECX,EDX ;Save used registers
  PUSH DI,SI           ;Save used registers
  PUSHFD               ;Save flags
  MOV  ECX,000C_0300h  ;Class = 0Ch (Serial Bus)
                       ;SubClass = 03h (USB)
                       ;SI = Index Number
  MOV  CL,AL           ;CL = Programming Interface
  MOV  AX,0B103h       ;Function B103h (Find PCI Class Code)
  STC                  ;Preset Error Flag
  INT  1Ah             ;Do it (Returns BX = USB Dev Function)
  JNC >H80             ;If found, we're done
H70:                   ;No Host Found
  POPFD                ;Restore flags
  STC                  ;Set the not found flag
  JMP >H90             ;We're done
H80:                   ;Host Found
  MOV  W PCIDevFunc,BX ;Store Device and Function
  POPFD                ;Restore flags
  CLC                  ;Set the found flag
H90:                   ;We're done
  POP  SI,DI           ;Restore used registers
  POP  EDX,ECX,EBX,EAX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE PCI BUS, DEVICE, AND FUNCTION NUMBERS TO THE SCREEN
;Inputs:  PCIDevFunc, PCIBusNum
;         SI = PCI Search Index
;Outputs: Writes PCI Bus, Device, Function to the Screen
;           followed by Vendor & Product ID
;         Returns BP = Vendor ID
;Changes:
;------------------------------------------------------------------------------
WriteBusInfo:
  PUSH AX,BX,DX        ;Save used registers
  MOV  AL,PCIBusNum    ;Write the
  CALL ByteToString    ;  PCI Bus Number
  MOV  AL,PCIDevFunc   ;Write the
  SHR  AL,3            ;  PCI
  CALL ByteToString    ;  PCI Bus Number
  CALL WriteSpace      ;Move over
  MOV  AL,PCIDevFunc   ;Write the
  AND  AL,07h          ;  PCI
  CALL WriteByteMin    ;  Function Number
  CALL Write2Spaces    ;Move over
  MOV  BL,PCIVendorID  ;Write
  CALL ReadPCIWord     ;  the
  CALL WriteWordHex    ;  Vendor Number
  CALL WriteHexEnd     ;  in Hex
  MOV  BP,AX           ;We'll be returning the Vendor Number
  CALL WriteSpace      ;Move over
  MOV  BL,PCIProductID ;Write
  CALL ReadPCIWord     ;  the
  CALL WriteWordHex    ;  Product Number
  CALL WriteHexEnd     ;  in Hex
  CALL WriteSpace      ;Move over
  POP  DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE USB VERSION NUMBER TO THE SCREEN
;Inputs:  CH = Host Programming Interface Type
;Outputs: Writes Version Number to screen
;Changes:
;------------------------------------------------------------------------------
WriteVersion:
  PUSH AX,BX,CX           ;Save used registers
  CMP  CH,ProgIntfOHCI    ;Is it OHCI?
  JNE >V20                ;If not, we can get the Version
V10:                      ;PCI Space does not contain the Version
  MOV  CL,3               ;Write some
  CALL WriteBlocks        ;  Blocks
  JMP >V90                ;Done
V20:                      ;PCI Space contains the Version
  MOV  BL,PCIUSBVersion   ;Get the
  CALL ReadPCIByte        ;  Version
  CALL WriteByteAsVersion ;Write it
V90:                      ;Done
  CALL WriteSpace         ;Move over
  POP  CX,BX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE AS A BCD VERSION NUMBER (MAJOR.MINOR)
;Inputs:  AL = Byte to Write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteByteAsVersion:
  ROL  AL,4           ;Write the
  CALL WriteNibbleHex ;  high nibble
  CALL WritePeriod    ;Write a Dot
  ROL  AL,4           ;Write the
  CALL WriteNibbleHex ;  low nibble
  RET

;------------------------------------------------------------------------------
;WRITE A WORD AS A BCD VERSION NUMBER (MAJOR.MINOR)
;Inputs:  AX = Word to Write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteWordAsVersion:
  PUSH CX             ;Save used registers
  MOV  CL,4           ;Rotoate 1 nibble (4 bits) at a time
  ROL  AX,CL          ;Write the
  CALL WriteNibbleHex ;  high nibble of AH
  ROL  AX,CL          ;Write the
  CALL WriteNibbleHex ;  low nibble of AH
  CALL WritePeriod    ;Write a Dot
  ROL  AX,CL          ;Write the
  CALL WriteNibbleHex ;  high nibble of AL
  ROL  AX,CL          ;Write the
  CALL WriteNibbleHex ;  low nibble of AL
  POP  CX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE BASE ADDRESS TO THE SCREEN (I/O OR MEMORY)
;Inputs:  CH = Host Programming Interface Type
;Outputs: Writes Base Address to screen
;         Stores BaseAddress (I/O if UHCI, Memory if OHCI/EHCI)
;Changes:
;------------------------------------------------------------------------------
WriteBaseAddr:
  PUSH EAX,BX,CX,EDX     ;Save used registers
  MOV  BL,PCIBaseMemAddr ;Assume OHCI or EHCI
  MOV  EDX,OHCIMemMask   ;Assume OHCI
  CMP  CH,ProgIntfOHCI   ;Is it UHCI, OHCI, OR EHCI?
  JA  >A20               ;If EHCI, handle it
  JE  >A30               ;If OHCI, handle it
A10:                     ;UHCI
  MOV  BL,PCIBaseIOAddr  ;Write
  CALL ReadPCIDWord      ;  the
  AND  AX,UHCIIOMask     ;  Base
  CALL WriteWordHex      ;  I/O Address
  CALL WriteHexEnd       ;  in Hex
  MOV  W BaseAddress,AX  ;Save it for later
  CALL WriteSpace        ;Move over
  MOV  CL,10             ;Write some
  CALL WriteBlocks       ;  Blocks
  JMP >A90               ;Done
A20:                     ;EHCI
  MOV  EDX,EHCIMemMask   ;Set EHCI Address Mask
A30:                     ;OHCI or EHCI
  CALL ReadPCIDWord      ;Get the Base Memory Address
  MOV  BaseAddress,EAX   ;Save it for later
  AND  EAX,EDX           ;Mask out the unneeded bytes
  MOV  CL,5              ;Write some
  CALL WriteBlocks       ;  Blocks
  CALL WriteSpace        ;Move over
  CALL WriteDWordHex     ;Write the Address
  CALL WriteHexEnd       ;  in Hex
A90:                     ;Done
  CALL Write2Spaces      ;Move over
  POP  EDX,CX,BX,EAX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE USB API INDEX AND STATUS, IF THE HOST IS USING ONE OF OUR DRIVERS
;Inputs:
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteIndexStatus:
  PUSH AX,BX,CX,DX,SI         ;Save used registers
  MOV  HostIndex,-1           ;Start with invalid Host Index
  CALL TestUSBHost            ;Are there any compatible Host Drivers installed?
  JC  >I70                    ;If not, write Unknown
  MOV  SI,Int14Request        ;Point at our Request Structure
  MOV  [SI].I14RRequestType,I14RRTGetHostHWInfo ;Get Host Hardware Info
  MOV  [SI].I14RHostIndex,0   ;Host Index 0
I10:                          ;Loop to here to find the correct Index
  CALL DoInt14CallSI          ;Do it
  JC  >I30                    ;If Error, go to the next one
I20:                          ;It's a valid Host Index
  CMP  DX,W PCIDevFunc        ;Is it the Host we're looking for?
  JE  >I40                    ;If so, continue
I30:                          ;Not the correct Index
  CMP  [SI].I14RHostIndex,15  ;Have we already tested all the Host Indexes?
  JE  >I70                    ;If so, write Unknown
  INC  [SI].I14RHostIndex     ;If not, try the next one
  JMP  I10                    ;Keep going until we're done
I40:                          ;It's the one we're looking for
  MOV  [SI].I14RRequestType,I14RRTGetHostStatus ;Get Host Status
  CALL DoInt14CallSI          ;Do it
  JC  >I90                    ;If error, quit
  MOV  AL,[SI].I14RHostIndex  ;Write the
  CALL ByteToString           ;  Index Number
  MOV  HostIndex,AL           ;Store the Host Index Number
  CALL WriteSpace             ;Move over
  MOV  DX,RunningMsg          ;Assume Running
  CMP  BL,HostStatusRunning   ;Is it Running?
  JE  >I50                    ;If so, continue
  MOV  DX,StoppedMsg          ;Assume Stopped
  CMP  BL,HostStatusStopped   ;Is it Stopped?
  JE  >I50                    ;If so, continue
  MOV  DX,SuspendedMsg        ;Assume Suspended
  CMP  BL,HostStatusSuspended ;Is it Suspended?
  JE  >I50                    ;If so, continue
  MOV  DX,DebugMsg            ;Assume Debug Mode
  CMP  BL,HostStatusDebugMode ;Is it in Debug Mode?
  JE  >I50                    ;If so, continue
  MOV  DX,UnknownMsg          ;If none of these, it's Unknown
I50:                          ;DX contains Status Message
  CALL WriteItDX              ;Write the Status
  CALL WriteSpace             ;Move over
  MOV  AL,BH                  ;Write the
  CALL ByteToString           ;  Bandwidth
  CALL WritePercent           ;  Percent
  JMP >I90                    ;Done
I70:                          ;No Host Driver installed
  MOV  CL,3                   ;Write some
  CALL WriteBlocks            ;  Blocks
  CALL WriteSpace             ;Move over
  MOV  CL,10                  ;Write some
  CALL WriteBlocks            ;  Blocks
  CALL WriteSpace             ;Move over
  MOV  CL,4                   ;Write some
  CALL WriteBlocks            ;  Blocks
I90:                          ;Done
  POP  SI,DX,CX,BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A VENDOR ID TO A STRING, AND WRITE IT
;Inputs:  AX = VendorID to Look for
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteVendorString:
  PUSH AX,BX,DI          ;Save used registers
  CMP  PauseHeaderPtr,-1 ;Are we supposed to write anything?
  JE  >R90               ;If not, just quit
  MOV  DI,SupportFile    ;FileName to Look For
  CALL FindSupportFile   ;Look for the File
  JC  >R90               ;If not there, quit
  MOV  BX,WordCmdTail    ;Point at the Vendor ID in the command tail string
  PUSH BX                ;Save the Pointer
  ADD  BX,4              ;Point at the Vendor ID in the command-tail string
  CALL WriteWordToString ;Convert the Vendor ID to a Hex String
  ADD  BX,6              ;Point at the Segment in the command-tail string
  CALL CopyCallBackAddr  ;Write teh appropriate call-back address
  POP  BX                ;Copy our string
  CALL CopyToCmdTail     ;  to the Command Tail String
  CALL DoExec            ;Call the Support Program
R90:                     ;No need to do help
  POP  DI,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY THE APPROPRIATE CALL-BACK ADDRESS TO THE EXEC PARAMETER STRING
;Inputs:   DS  = Local data Area
;         [BX] = Where the write the Segment:Offset of the Call-back Address
;          ParentIsShell
;          CallBackAddr
;Outputs: DS:[BX] = Call-back address to use
;                   If ParentIsShell = Yes, CS:WriteZPauseFar
;                   If ParentIsShell = No & CallBackAddr is valid,
;                                      A copy of CallBackAddr
;------------------------------------------------------------------------------
CopyCallBackAddr:
  PUSH AX,CX,DI          ;Save used registers
  MOV  AX,CS             ;Assume we're at the
  MOV  CX,WriteZPauseFar ;  command-line
  CMP  ParentIsShell,Yes ;Are we at the command-line?
  JE  >K50               ;If so, continue
  MOV  DI,OFFSET CallBackAddr ;If not, point at the Call-back address
  CMP  W [DI+0],-1       ;Is the Call-back Address valid?
  JE  >K50               ;If not, use our address
  MOV  AX,[DI+2]         ;If so, use the
  MOV  CX,[DI+0]         ;  externally-provided Call-back Address
K50:                     ;AX:CX contains Segment:Offset to use
  CALL CopySegmentOffset ;Store the Segment:Offset
  POP  DI,CX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A SEGMENT:OFFSET COMBINATION TO A STRING VARIABLE
;Inputs:   AX  = Segment to Write
;          CX  = Offset to Write
;         [BX] = String to Write to
;Outputs: Converts AX:CX to a Hex String and stores at [BX]
;Changes:
;------------------------------------------------------------------------------
CopySegmentOffset:
  PUSH AX,DI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at Local Data Area
  MOV  DI,BX          ;Point DI at String
  CALL Word2HexString ;Store the Segment
  MOV  AL,':'         ;Store the
  STOSB               ;  Colon
  MOV  AX,CX          ;Store
  CALL Word2HexString ;  the Offset
  POP  ES,DI,AX       ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO READ AND WRITE DATA FROM THE PCI ADDRESS SPACE OR USB CONTROLLER
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;READ A CONFIGURATION BYTE, WORD, OR DWORD FROM THE PCI CONTROLLER
;Inputs:  BL = Offset of PCI Configuration Register to use
;         PCIDevFunc
;Outputs: CF = Set if error, Clear if OK
;         AL = Byte, AX if Word, EAX if DWord
;         EAX = ??? if the call fails!
;Changes: Could change "unaffected" parts of ECX???
;NOTE:    Calls May require up to 1024 bytes of Stack!
;         Can unpredictably affect any and all flags except CF and IF
;------------------------------------------------------------------------------
ReadPCIByte:
  PUSH BP              ;Save used registers
  XOR  BP,BP           ;Mark as a Byte
  JMP  >P00            ;Jump to do it
ReadPCIWord:
  PUSH BP              ;Save used registers
  MOV  BP,1            ;Mark as a Word
  JMP  >P00            ;Jump to do it
ReadPCIDWord:
  PUSH BP              ;Save used registers
  MOV  BP,2            ;Mark as a DWord
;  JMP  >P00            ;Jump to do it
P00:
  PUSH EBX,ECX,EDX,DI  ;Save used registers
  PUSH EAX             ;Save original EAX
  XOR  BH,BH           ;Put register
  MOV  DI,BX           ;Put register offset in DI
  MOV  AX,BP           ;Function numbers are B108h (Byte), B109h (Word),
  ADD  AX,0B108h       ;  and B10Ah (DWord)
  MOV  BX,W PCIDevFunc ;Get Device & Function numbers for the Host Controller
  STC                  ;Preset the error flag
  INT  1Ah             ;Do it (returns Carry Flag, and CL/CX/ECX)
  POP  EAX             ;Restore original EAX
  JC  >P70             ;If error, we're done
  CMP  BP,1            ;Were we doing a Byte, Word, or DWord?
  JE  >P20             ;If a Word, jump to handle it
  JA  >P30             ;If a DWord, jump to handle it
P10:                   ;Doing a Byte
  MOV  AL,CL           ;If a Byte, handle it
  JMP >P80             ;We're done
P20:                   ;Doing a Word
  MOV  AX,CX           ;Handle a Word
  JMP >P80             ;We're done
P30:                   ;Doing a DWord
  MOV  EAX,ECX         ;Handle a DWord
  JMP >P80             ;We're done
P70:                   ;There's an error
  STC                  ;Set the error flag
  JMP >P90             ;We're done
P80:                   ;It went OK
  CLC                  ;Set the OK flag
P90:                   ;We're done
  POP  DI,EDX,ECX,EBX  ;Restore used registers
  POP  BP              ;Restorer used registers
  RET

;------------------------------------------------------------------------------
;WRITE A CONFIGURATION BYTE, WORD, OR DWORD TO THE PCI CONTROLLER
;Inputs:  BL = Offset of PCI Configuration Register to use
;         AL = Byte, AX if Word, ACX if DWord
;Outputs: CF = Set if error, Clear if OK
;Changes:
;NOTE:    Calls May require up to 1024 bytes of Stack!
;         Can unpredictably affect any and all flags except CF and IF
;------------------------------------------------------------------------------
;WritePCIByte:
;  PUSH EDX             ;Save used registers
;  XOR  DX,DX           ;Mark as a Byte
;  JMP  >P00            ;Jump to do it
WritePCIWord:
  PUSH EDX             ;Save used registers
  MOV  DX,1            ;Mark as a Word
;  JMP  >P00            ;Jump to do it
;WritePCIDWord:
;  PUSH EDX             ;Save used registers
;  MOV  DX,2            ;Mark as a DWord
;;  JMP  >P00            ;Jump to do it
P00:
  PUSH EAX,EBX,ECX,DI  ;Save used registers
  XOR  BH,BH           ;Put register offset
  MOV  DI,BX           ;  in DI
  MOV  ECX,EAX         ;Put what to write in (E)Cx
  MOV  AX,DX           ;Function numbers are B10Bh (Byte), B10Ch (Word),
  ADD  AX,0B10Bh       ;  and B10Dh (DWord)
  MOV  BX,W PCIDevFunc ;Get Device & Function numbers for the Host Controller
  STC                  ;Preset the error flag
  INT  1Ah             ;Do it (returns Carry Flag)
P90:                   ;We're done
  POP  DI,ECX,EBX,EAX  ;Restore used registers
  POP  EDX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ A CONFIGURATION BYTE, WORD, OR DWORD FROM THE UHCI HOST CONTROLLER
;Inputs:  BL = Offset from Base Address to get
;         BaseAddress
;Outputs: AL if Byte, AX if word, EAX if DWord
;Changes:
;NOTES: On the HP Laptop, an IN EAX,DX sometimes locks up the computer
;         (not all the time, just sometimes).  So, to get a DWord, we do
;         the two "sub-Words" separately and combine them together.
;       We shouldn't need to do this, but it seems to be the only way to
;         get it to work.
;------------------------------------------------------------------------------
ReadHostByte:
  XOR  AL,AL  ;Mark as a Byte
  JMP >H00    ;Jump to do it
ReadHostWord:
  MOV  AL,1   ;Mark as a Word
  JMP >H00    ;Jump to do it
ReadHostDWord:
  MOV  AL,2   ;Mark as a DWord
;  JMP >H00    ;Jump to do it
H00:
  PUSH BX,DX  ;Save used registers
  MOV  DX,W BaseAddress ;Get the Base I/O Address
  XOR  BH,BH  ;Add in the
  ADD  DX,BX  ;  appropriate offset
  CMP  AL,1   ;Are we doing a Byte, Word, or DWord?
  JE  >H20    ;If a word, jump to handle it
  JA  >H40    ;If a DWord, jump to handle it
H10:          ;Doing a Byte
  IN   AL,DX  ;Do the byte
  JMP >H90    ;We're done
H20:          ;Doing a Word
  IN   AX,DX  ;Do the word
  JMP >H90    ;We're done
H40:          ;Doing a DWord
  IN   AX,DX  ;Read the Low Word
  PUSH AX     ;Save it on the stack
  INC  DX,2   ;Read the
  IN   AX,DX  ;  High Word
  SHL  EAX,16 ;Put it in the High Word of EAX
  POP  AX     ;Put the Low Word in EAX
H90:          ;We're done
  POP  DX,BX  ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO WRITE DETAILED STATUS TO THE SCREEN
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;WRITE THE HOST DETAILS, COMPLETE WITH HEADER AND DIVIDER LINE IF NEEDED
;Inputs:  DS = ES = Local Data Area
;         AL = PCI Programming Interface Type (ProgIntfUHCI, etc.)
;         SI = PCI Search Index
;         ProgFlags.WroteOne (set if we've already written at least one)
;Outputs: To Screen
;         ProgFlags.WroteOne is set
;Changes:
;------------------------------------------------------------------------------
WriteHostComplete:
  PUSH AX,DX              ;Save used registers
  TEST ProgFlags,WroteOne ;Have we already written at least one?
  JZ  >C10                ;If not, just write the Header
  MOV  DX,NewHostDivider  ;If so, write a
  CALL WriteItDX          ;  divider line
C10:                      ;Handled extra spacing, if needed
  MOV  DX,HeaderMsg0      ;Write the
  CALL WriteHeader0       ;  Host Header
  CALL TestHost           ;Is this a valid Search Index?
  JC  >C70                ;If not, handle it
  CALL TestXHCI           ;Write the Host Summary
  CALL WriteDetails       ;Write Host Details
  JMP >C90                ;Done
C70:                      ;No Host at this Index!
  MOV  AH,AL              ;AH = Programming Interface
  MOV  AL,'U'             ;Assume UHCI
  CMP  AH,ProgIntfOHCI    ;Which kind of Programming Interface is it?
  JB  >C75                ;If UHCI, continue
  MOV  AH,'O'             ;Assume OHCI
  JE  >C75                ;If OHCI, continue
  MOV  AL,'E'             ;It must be EHCI
C75:                      ;AL = Programming Interface in ASCII
  CALL WriteBadHostIdx    ;Write the Error Message
C90:                      ;Done
  OR   ProgFlags,WroteOne ;Mark as having written one
  POP  DX,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE DETAILED HOST STATUS TO THE SCREEN (TYPE-SPECIFIC)
;Inputs:  AL = Programming Interface we're currently using
;         PCIBusNum, PCIDevFunc filled int
;Outputs: To Screen
;Changes
;NOTES: The output varies depending on the type of Host currently under test
;         (UHCI, OHCI, or EHCI).
;       The output is also very long, taking up many lines of screen.
;       WriteDetails2 is called when we're doing all Hosts.
;------------------------------------------------------------------------------
WriteDetails:
  PUSH BX                 ;Save used registers
  MOV  BX,WriteUHCIStatus ;Assume UHCI
  CMP  AL,ProgIntfUHCI    ;Is it UHCI?
  JE  >D20                ;If so, handle it
  MOV  BX,WriteOHCIStatus ;Assume OHCI
  CMP  AL,ProgIntfOHCI    ;Is it OHCI?
  JE  >D20                ;If so, handle it
  MOV  BX,WriteEHCIStatus ;If not, it must be EHCI
D20:                      ;[BX] = Code to Call
  CALL BX                 ;Do it
  CALL WriteCrLfPause     ;Move down
  POP  BX                 ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO WRITE DETAILED OHCI STATUS TO THE SCREEN
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;WRITE DETAILED OHCI HOST STATUS TO THE SCREEN
;Inputs:  PCIDevFunc, PCIBusNum
;Outputs: Writes Details of OHCI Host Status
;Changes:
;------------------------------------------------------------------------------
WriteOHCIStatus:
  CALL CopyOHCIMemory ;Copy Base Memory to our data area
  JNC >O00            ;If OK, continue
  PUSH DX             ;If error, save used registers
  MOV  DX,NoDataMsg   ;Write the
  CALL WriteItDX      ;  Error Message
  POP  DX             ;Restore used registers
  RET

O00:
  PUSH EAX,BX,CX,DX,SI,BP         ;Save used registers

;;;;;;;;;;;;;;;;;;;;;;;;;
;SAVE CURRENT PCI CONFIG;
;;;;;;;;;;;;;;;;;;;;;;;;;
  MOV  BL,PCICfgCmd                ;Store the
  CALL ReadPCIWord                 ;  original PCI
  MOV  BP,AX                       ;  Configuration Command Register
  OR   AX,PCICfgIOAccess+PCICfgMemoryAccess ;Enable I/O & Memory Access
  CALL WritePCIWord                ;Tell the PCI Bus about it

;;;;;;;;
;HEADER;
;;;;;;;;
  MOV  DX,HeaderMsgOHCI1           ;Write Header
  CALL WriteHeader1

;;;;;;;;;
;GENERAL;
;;;;;;;;;
  CALL Write2Spaces                ;Move over
  MOV  SI,OHCIOpRegData            ;Point [SI] at the Operational Registers
  MOV  AL,B [SI].OORVersion[0]     ;Write the OHCI Version
  CALL WriteByteAsVersion
  CALL WriteSpace                  ;Move over
  MOV  EAX,[SI].OORHCCAAddress     ;Write the HCCA Address
  CALL WriteDWordHex
  CALL WriteHexEnd
  CALL WriteOHostState             ;Write the Host State

;;;;;;;;;
;FRAMING;
;;;;;;;;;
  MOV  AX,W [SI].OORFrmInterval[0] ;Write Frame Time (Interval)
  AND  AX,OFrmIntervalMask
  CALL WordToString
  MOV  AL,B [SI].OORFrmInterval[3] ;Write Frame Interval Toggle
  MOV  BH,(OFrmIntervalTgl SHR 24)
  CALL WriteYesNoALBH
  CALL WriteSpace                  ;Move over
  MOV  AX,W [SI].OORFrmRemaining[0] ;Write Frame Time Remaining
  AND  AX,OFrmRemainingMask
  CALL WordToString
  MOV  AL,B [SI].OORFrmRemaining[3] ;Write Frame Time Remaining Toggle
  MOV  BH,(OFrmRemainingTgl SHR 24)
  CALL WriteYesNoALBH
  CALL WriteSpace                  ;Move over
  MOV  AX,W [SI].OORFrmNumber[0]   ;Write Frame Number
  CALL WordToString
  CALL WriteSpace                  ;Move over
  MOV  AX,W [SI].OORPerStart[0]    ;Write Periodic Start Threshold
  AND  AX,OPerStartMask
  CALL WordToString
  CALL WriteSpace                  ;Move over
  MOV  AX,W [SI].OORLSThresh[0]    ;Write Low-Speed Threshold
  AND  AX,OLSThreshMask
  CALL WordToString
  CALL WriteSpace                  ;Move over
  MOV  AX,W [SI].OORFrmInterval[2] ;Write Maximum Full-Speed Packet Size
  AND  AX,(OFrmMaxFSPktSize SHR 16)
  CALL WordToString

;;;;;;;;
;STATUS;
;;;;;;;;
  CALL WriteSpace                  ;Move over
  MOV  AX,W [SI].OORControl[0]     ;AX = Control
  MOV  DX,W [SI].OORCmdStatus[0]   ;DX = Command Status
  MOV  BH,OHostSWReset             ;Write Software Reset Status
  CALL WriteYesNoDLBH
  MOV  BH,OOwnerChgReq             ;Write Ownership Change Status
  CALL WriteYesNoDLBH
  MOV  BH,(ORmtWakeConn SHR 8)     ;Write Remote Wakeup Connected Status
  CALL WriteYesNoAHBH
  MOV  BH,(ORmtWakeEnable SHR 8)   ;Write Remote Wakeup Enabled Status
  CALL WriteYesNoAHBH
  CALL WriteSpace                  ;Move over
  MOV  AL,B [SI].OORCmdStatus[2]   ;Write Schedule Overrun Count
  AND  AL,3
  CALL WriteByteMin

;;;;;;;;
;HEADER;
;;;;;;;;
  MOV  DX,HeaderMsgOHCI2           ;Write Header
  CALL WriteHeader2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;END-POINT DESCRIPTOR ADDRESSES;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  CALL Write2Spaces                ;Move over
  MOV  EAX,[SI].OORPerCurrED       ;Write Periodic Current ED
  AND  AL,(OPerCurrEDMask AND 0FFh)
  CALL WriteDWordHex
  MOV  AL,B [SI].OORControl[0]     ;Write Periodic List Enabled
  MOV  BH,OPerListEnable
  CALL WriteYesNoALBH
  MOV  BH,OIsochEnable             ;Write Isochronous Enabled
  CALL WriteYesNoALBH
  CALL Write2Spaces                ;Move over
  MOV  EAX,[SI].OORCtlHeadED       ;Write Control Head ED
  AND  AL,(OCtlHeadEDMask AND 0FFh)
  CALL WriteDWordHex
  MOV  AL,B [SI].OORControl[0]     ;Write Control List Enabled
  MOV  BH,OCtlListEnable
  CALL WriteYesNoALBH
  MOV  AL,B [SI].OORCmdStatus[0]   ;Write Control List Filled
  MOV  BH,OCtlListFilled
  CALL WriteYesNoALBH
  CALL WriteSpace                  ;Move over
  MOV  EAX,[SI].OORCtlCurrED       ;Write Control Current ED
  AND  AL,(OCtlCurrEDMask AND 0FFh)
  CALL WriteDWordHex
  CALL WriteSpace                  ;Move over
  MOV  AL,B [SI].OORControl[0]     ;Write Control/Bulk Ratio
  AND  AL,OCtlBulkRatioMask
  INC  AL
  CALL WriteByteMin
  CALL WriteSpace                  ;Move over
  MOV  EAX,[SI].OORBulkHeadED      ;Write Bulk Head ED
  AND  AL,(OBulkHeadEDMask AND 0FFh)
  CALL WriteDWordHex
  MOV  AL,B [SI].OORControl[0]     ;Write Bulk List Enabled
  MOV  BH,OBulkListEnable
  CALL WriteYesNoALBH
  MOV  AL,B [SI].OORCmdStatus[0]   ;Write Bulk List Filled
  MOV  BH,OBulkListFilled
  CALL WriteYesNoALBH
  CALL WriteSpace                  ;Move over
  MOV  EAX,[SI].OORBulkCurrED      ;Write Bulk Current ED
  AND  AL,(OBulkCurrEDMask AND 0FFh)
  CALL WriteDWordHex
  CALL Write2Spaces                ;Move over
  MOV  EAX,[SI].OORDoneHead        ;Write Done Head ED
  AND  AL,(ODoneEDMask AND 0FFh)
  CALL WriteDWordHex

;;;;;;;;
;HEADER;
;;;;;;;;
  MOV  DX,HeaderMsgOHCI3           ;Write Header
  CALL WriteHeader2

;;;;;;;;;;
;ROOT HUB;
;;;;;;;;;;
  CALL WriteSpace                  ;Move over
  MOV  AX,W [SI].OORRHDescrA[0]    ;Write Number of Ports
  CALL ByteToString
  MOV  BH,(OPerPortPwr SHR 8)      ;Write Per-Port Power Control
  CALL WriteYesNoAHBH
  MOV  BH,(ONoPwrSwitching SHR 8)  ;Write No Power-Switching Control
  CALL WriteYesNoAHBH
  MOV  AL,B [SI].OORRHStatus[2]    ;Write Power Status Change
  MOV  BH,(OSetGlobalPwr SHR 16)
  CALL WriteYesNoALBH
  MOV  AX,W [SI].OORRHDescrA[0]    ;Write Per-Port Over-Current Control
  MOV  BH,(OPerPortOverCurr SHR 8)
  CALL WriteYesNoAHBH
  MOV  BH,(ONoOverCurr SHR 8)      ;Write No Over-Current Protection
  CALL WriteYesNoAHBH
  MOV  AX,W [SI].OORRHStatus[0]    ;Write Remote Wakeup Change
  MOV  BH,(ORHRmtWakeEnable SHR 8)
  CALL WriteYesNoAHBH
  CALL WriteSpace                  ;Move over
  MOV  DX,W [SI].OORRHStatus[2]    ;Write Over-Current Change
  MOV  BH,OOverCurrChange
  CALL WriteYesNoDLBH
  MOV  BH,OGlobalOverCurr          ;Write Global Over-Current
  CALL WriteYesNoALBH
  XOR  AX,AX                       ;Write Power-On-To-Power-Good Time
  MOV  AL,B [SI].OORRHDescrA[3]
  SHL  AX,1
  CALL WordToString
  XOR  CH,CH                       ;Write the
  CALL WriteTotalPower             ;  Total Power
  CALL Write2Spaces                ;Move over
  MOV  CX,0100                     ;CH = Port, CL = Spaces to write
  CALL WriteOPortStatus            ;Write the Status of Port 1
  MOV  CL,34                       ;Set the Indent value
O10:                               ;Loop to here for each Port
  INC  CH                          ;Increment the Port Number
  CMP  CH,B [SI].OORRHDescrA[0]    ;Is this a valid Port?
  JA  >O15                         ;If not, continue
  CALL WriteOPortStatus            ;If s, write the status of this port
  JMP  O10                         ;Keep going until we're done
O15:                               ;Done with Ports Status

;;;;;;;;
;HEADER;
;;;;;;;;
  MOV  DX,HeaderMsgOHCI4           ;Write Header
  CALL WriteHeader1

;;;;;;;;;;;;
;INTERRUPTS;
;;;;;;;;;;;;
  CALL WriteSpace                  ;Move over
  MOV  AL,B [SI].OORIntEnable[3]   ;Write Master Interrupt Enable
  MOV  BH,(OMasterIntEnable SHR 24)
  CALL WriteYesNoALBH
  MOV  AL,B [SI].OORControl[1]     ;Write Interrupt Routing
  MOV  BH,(OIntRouting SHR 8)
  CALL WriteYesNoALBH
  CALL WriteSpace                  ;Move over
  MOV  AL,B [SI].OORIntEnable[3]   ;Write Ownership Change Interrupt
  MOV  AH,B [SI].OORIntStatus[3]
  MOV  BH,(OIntOwnerChg SHR 24)
  CALL WriteYNBALAHBH
  MOV  AL,B [SI].OORIntEnable[0]   ;Write Unrecoverable Interrupt
  MOV  AH,B [SI].OORIntStatus[0]
  MOV  BH,OIntUnrecoverable
  CALL WriteYNBALAHBH
  MOV  BH,OIntRHStatusChg          ;Write Root Hub Change Interrupt
  CALL WriteYNBALAHBH
  MOV  BH,OIntStartOfFrame         ;Write Start-of-Frame Interrupt
  CALL WriteYNBALAHBH
  MOV  BH,OIntFrameNumOF           ;Write Frame Number Overflow Interrupt
  CALL WriteYNBALAHBH
  MOV  BH,OIntSchedOverrun         ;Write Schedule Overrun Interrupt
  CALL WriteYNBALAHBH
  MOV  BH,OIntWriteBackDone        ;Write Write-Back Done Interrupt
  CALL WriteYNBALAHBH
  MOV  BH,OIntResumeDetect         ;Write Resume Detect Interrupt
  CALL WriteYNBALAHBH

;;;;;;;;;;;;;;;;
;LEGACY SUPPORT;
;;;;;;;;;;;;;;;;
  CALL Write2Spaces                ;Move over
  TEST B [SI].OORVersion[1],(OLegacySupport SHR 8) ;Any Legacy Support at all?
  JNZ >O20                         ;If so, continue
  CALL WriteSpace                  ;If not, move over
  MOV  CL,43                       ;Fill with
  CALL WriteBlocks                 ;  Blocks
  JMP >O90                         ;Done
O20:                               ;Legacy Support installed
  MOV  SI,OHCILegacyData           ;Point DS:[SI] at the Legacy Data
  MOV  AX,W [SI].(OLegacyControl-OLegacyOffset)
  MOV  BH,OLegEnabled              ;Write Legacy Enabled
  CALL WriteYesNoALBH
  MOV  BH,OLegEmulInt              ;Write Emulation Interrupt Condition
  CALL WriteYesNoALBH
  MOV  BH,OLegCharPend             ;Write Character Pending
  CALL WriteYesNoALBH
  MOV  BH,OLegIRQEnable            ;Write IRQ Enable
  CALL WriteYesNoALBH
  MOV  BH,OLegExtIRQEn             ;Write External IRQ Enable
  CALL WriteYesNoALBH
  MOV  BH,OLegIRQ01Act             ;Write IRQ 01 Active
  CALL WriteYesNoALBH
  MOV  BH,OLegIRQ12Act             ;Write IRQ 12 Active
  CALL WriteYesNoALBH
  MOV  BH,OLegA20Seq               ;Write Gate A20 Sequence
  CALL WriteYesNoALBH
  MOV  BH,(OLegA20State SHR 8)     ;Write A20 State
  CALL WriteYesNoAHBH
  CALL WriteSpace                  ;Move over
  MOV  AX,W [SI].(OLegacyStatus-OLegacyOffset)
  MOV  BH,OLegBootFlag             ;Write Boot Flag
  CALL WriteYesNoALBH
  MOV  BH,OLegTimeOut              ;Write TimeOut Error
  CALL WriteYesNoALBH
  MOV  BH,OLegParityErr            ;Write Parity Error
  CALL WriteYesNoALBH
  MOV  BH,OLegNoInhibit            ;Write No Kebyoard Inhibit
  CALL WriteYesNoALBH
  MOV  BH,OLegOutFull              ;Write Output Full
  CALL WriteYesNoALBH
  MOV  BH,OLegInFull               ;Write Input Full
  CALL WriteYesNoALBH
  MOV  BH,OLegAuxOutFul            ;Write Auxiliary Output Full
  CALL WriteYesNoALBH
  MOV  BH,OLegPort64               ;Write Port 64h
  CALL WriteYesNoALBH
  CALL Write2Spaces                ;Move over
  MOV  AL,B [SI].(OLegacyInput-OLegacyOffset)
  CALL WriteByteHex                ;Write Port 60h/64h Input Data
  CALL WriteHexEnd
  CALL WriteSpace                  ;Move over
  MOV  AL,B [SI].(OLegacyOutput-OLegacyOffset)
  CALL WriteByteHex                ;Write Port 60h/64h Output Data
  CALL WriteHexEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;RESTORE ORIGINAL PCI CONFIG;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
O90:                               ;Done
  MOV  AX,BP                       ;Restore the
  MOV  BL,PCICfgCmd                ;  original PCI
  CALL WritePCIWord                ;  Configuration Command register

  POP  BP,SI,DX,CX,BX,EAX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY OHCI BASE MEMORY DATA TO OUR LOCAL DATA AREA
;Inputs:  BaseAddress
;Outputs: OHCIOpRegData, OHCILegacyData
;Changes:
;------------------------------------------------------------------------------
CopyOHCIMemory:
  PUSH EAX,CX,DI         ;Save used registers
  MOV  EAX,BaseAddress   ;EAX = Physical Address to Copy From
  MOV  DI,OHCIOpRegData  ;ES:[DI] = Where to Copy Data To
  MOV  CX,(OORSize/2)    ;CX = Number of Words to Copy
  CALL CopyFromPhysMem   ;Do it
  JC  >M70               ;If error, quit
  ADD  EAX,OLegacyOffset ;EAX = Physical Address to Copy From
  MOV  DI,OHCILegacyData ;ES:[DI] = Where to Copy Data To
  MOV  CX,(4*4/2)        ;CX = Number of Words to Copy
  CALL CopyFromPhysMem   ;Do it
  JNC >M80               ;If OK, we're done
M70:                     ;Error
  STC                    ;Set error flag
  JMP >M90               ;Done
M80:                     ;OK
  CLC                    ;Set OK flag
M90:                     ;Done
  POP  DI,CX,EAX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE STATE OF AN OHCI HOST
;Inputs:  [SI] = Operation Register Data Area
;         OStateMsgs
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteOHostState:
  PUSH AX,DX                   ;Save used registers
  CALL WriteSpace              ;Move over
  MOV  AL,B [SI].OORControl[0] ;Put the
  AND  AL,OHostStateMask       ;  Host State Code
  SHR  AL,6                    ;  in AL
  INC  AL                      ;Convert it to a 1-based number
  MOV  DX,OStateMsgs           ;Point at the Description Table
S10:                           ;Loop to here to find the right string
  DEC  AL                      ;Are we pointed at the right string?
  JZ  >S30                     ;If so, jump to write it
  ADD  DX,OStateMsgSize        ;If not, point at the next message
  JMP  S10                     ;Keep going until we find it
S30:                           ;[DX] = String to Write
  CALL WriteItDX               ;Write it
  CALL Write2Spaces            ;Move over
  POP  DX,AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE STATUS OF A SINGLE OHCI ROOT HUB PORT STATUS & CONTROL REGISTER
;Inputs:  [SI] = Operational Registers Data
;          CH  = Port Number to write
;          CL  = Number of Spaces to write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteOPortStatus:
  PUSH EAX,BX,CX,DX           ;Save used registers
  CALL WriteSpaces            ;Move over
  MOV  AL,CH                  ;Write the
  CALL ByteToString           ;  Port Number
  MOV  EAX,[SI].OORRHDescrB   ;Get the Removable & Per-Port Power Masks
  CALL DoBitTestCHAX          ;Write the Removable Status
  SHR  EAX,16                 ;Write the
  CALL DoBitTestCHAX          ;  Per-Port Power Status
  PUSH CX                     ;Save Port #
  DEC  CH                     ;Convert Port # to Bit #
  MOV  BX,(OFFSET OORRHPtStatus01) ;Point [SI+BX]
  SHR  CX,8                   ;  at the
  SHL  CX,2                   ;  Port Status
  ADD  BX,CX                  ;  Offset
  POP  CX                     ;Restore Port Number
  MOV  AX,[SI+BX]             ;AX = Low Word of Port Status
  MOV  DX,[SI+BX+2]           ;DX = High Word of Port Status
  MOV  BH,(OPtPwrOn SHR 8)    ;Write Port Power
  CALL WriteYesNoAHBH
  MOV  BH,OPtConnectChg       ;Write Connect Change
  CALL WriteYesNoDLBH
  MOV  BH,OPtConnect          ;Write Connect Status
  CALL WriteYesNoALBH
  MOV  BH,OPtEnableChg        ;Write Enable Change
  CALL WriteYesNoDLBH
  MOV  BH,OPtEnable           ;Write Enable Status
  CALL WriteYesNoALBH
  MOV  BH,OPtSuspendChg       ;Write Suspend Change
  CALL WriteYesNoDLBH
  MOV  BH,OPtSuspend          ;Write Suspend Status
  CALL WriteYesNoALBH
  MOV  BH,OPtOverCurrChg      ;Write Over-Current Change
  CALL WriteYesNoDLBH
  MOV  BH,OPtOverCurr         ;Write Over-Current Status
  CALL WriteYesNoALBH
  MOV  BH,OPtResetChg         ;Write Reset Change
  CALL WriteYesNoDLBH
  MOV  BH,OPtReset            ;Write Reset Status
  CALL WriteYesNoALBH
  MOV  BH,(OPtLowSpeed SHR 8) ;Write Low-Speed Status
  CALL WriteYesNoAHBH
  CALL WriteDvcAddress        ;Write the Device Address
  CALL WriteTotalPower        ;Write the Power Draw on the Port
  CALL WriteCrLfPause         ;Move down
  POP  DX,CX,BX,EAX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A SPACE AND THEN A YES OR NO TO THE SCREEN FOR A BIT #
;Inputs:  AX = Status Word to test
;         CH = Bit # to test for
;Outputs: To the screen
;Changes:
;------------------------------------------------------------------------------
DoBitTestCHAX:
  PUSH AX,BX,CX   ;Save used registers
  CALL WriteSpace ;Move over
  XOR  BX,BX      ;Put Bit #
  MOV  BL,CH      ;  in BX
  MOV  CL,'Y'     ;Assume Yes
  BT   AX,BX      ;Test the bit
  JC  >X20        ;If set, write Yes
  MOV  CL,'.'     ;If not, write a Dot
X20:              ;[DX] = String to write
  MOV  AL,CL      ;Write the
  CALL WriteAL    ;  character
  POP  CX,BX,AX   ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO WRITE DETAILED UHCI STATUS TO THE SCREEN
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;WRITE DETAILED UHCI HOST STATUS TO THE SCREEN
;Inputs:  PCIDevFunc, PCIBusNum
;Outputs: Writes Details of UHCI Host Status
;Changes:
;------------------------------------------------------------------------------
WriteUHCIStatus:
  PUSH EAX,BX,CX,DX,BP        ;Save used registers

;;;;;;;;;;;;;;;;;;;;;;;;;
;SAVE CURRENT PCI CONFIG;
;;;;;;;;;;;;;;;;;;;;;;;;;
  MOV  BL,PCICfgCmd           ;Store the
  CALL ReadPCIWord            ;  original PCI
  MOV  BP,AX                  ;  Configuration Command Register
  OR   AX,PCICfgIOAccess+PCICfgMemoryAccess ;Enable I/O & Memory Access
  CALL WritePCIWord           ;Tell the PCI Bus about it

;;;;;;;;
;HEADER;
;;;;;;;;
  MOV  DX,HeaderMsgUHCI1      ;Write Header
  CALL WriteHeader1

;;;;;;;;;
;GENERAL;
;;;;;;;;;
  CALL WriteSpace             ;Move over
  MOV  BL,UStatus             ;Get USB Status Register
  CALL ReadHostWord
  MOV  DX,AX                  ;Put it in DX
  MOV  BL,UCommand            ;Get USB Command Register
  CALL ReadHostWord
  MOV  BH,UCRunStop           ;Write Running
  CALL WriteYesNoALBH
  MOV  BH,USHostHalted        ;Write Halted
  CALL WriteYesNoDLBH
  MOV  BH,UCConfigured        ;Write Configured
  CALL WriteYesNoALBH
  MOV  BH,UCMaxPkt64          ;Write Max Packet Size
  CALL WriteYesNoALBH
  MOV  BH,UCSoftDebug         ;Write Software Debug
  CALL WriteYesNoALBH
  MOV  BH,USProcessorErr      ;Write Processor Error
  CALL WriteYesNoDLBH
  MOV  BH,USSystemErr         ;Write System Error
  CALL WriteYesNoDLBH
  MOV  BH,UCGlobalReset       ;Write Global Reset
  CALL WriteYesNoALBH
  MOV  BH,UCHostReset         ;Write Host Controller Reset
  CALL WriteYesNoALBH
  MOV  BH,UCGlobalResume      ;Write Force Global Resume
  CALL WriteYesNoALBH
  MOV  BH,UCGlobalSuspend     ;Write Enter Global Suspend
  CALL WriteYesNoALBH
  MOV  BH,USResumeDetect      ;Write Resume Detect
  CALL WriteYesNoDLBH

;;;;;;;;;
;FRAMING;
;;;;;;;;;
  CALL Write2Spaces           ;Move over
  MOV  BL,UFrameListAddr      ;Write the Frame List Base Address
  CALL ReadHostDWord
  AND  EAX,0FFFF_F000h
  CALL WriteDWordHex
  CALL WriteHexEnd
  CALL WriteSpace             ;Move over
  CALL GetUFrameTiming        ;Write the Frame Timing Value
  CALL WordToString
  CALL WriteSpace             ;Move over
  MOV  BL,UFrameNum           ;Write the Frame Number
  CALL ReadHostWord
  CALL WordToString

;;;;;;;;
;HEADER;
;;;;;;;;
  MOV  DX,HeaderMsgUHCI2      ;Write Header
  CALL WriteHeader2

  CALL WriteSpace             ;Move over
  MOV  BL,UStatus             ;Get USB Status Register
  CALL ReadHostWord
  MOV  DX,AX                  ;Put it in DX

;;;;;;;;;;;;;;;;;;
;TOTAL POWER DRAW;
;;;;;;;;;;;;;;;;;;
  XOR  CH,CH                  ;Write Total Power Draw
  CALL WriteTotalPower

;;;;;;;;;;;;;;;;;
;ROOT HUB PORT 1;
;;;;;;;;;;;;;;;;;
  MOV  AL,1                   ;Write Root Hub Port 1 Status
  CALL ByteToString
  MOV  CH,AL
  MOV  BL,UPortSC1
  CALL ReadHostWord
  CALL WriteUPortStatus
  CALL Write2Spaces           ;Move over

;;;;;;;;;;;;
;INTERRUPTS;
;;;;;;;;;;;;
  MOV  BL,UIntEnable          ;Get USB Interrupt Enable Register
  CALL ReadHostWord
  MOV  BH,USUSBInt            ;Write USB Interrupt
  CALL WriteYesNoDLBH
  MOV  BH,USUSBErrInt         ;Write USB Error Interrupt
  CALL WriteYesNoDLBH
  CALL WriteSpace             ;Move over
  MOV  BH,UIIntOnComplete     ;Write Interrupt on Complete Status
  CALL WriteYesNoALBH
  MOV  BH,UIResume            ;Write Resume Interrupt Status
  CALL WriteYesNoALBH
  MOV  BH,UIShortPkt          ;Write Short Packet Interrupt Enabled Status
  CALL WriteYesNoALBH
  MOV  BH,UITimeoutCRC        ;Write Timeout/CRC Interrupt Status
  CALL WriteYesNoALBH

;;;;;;;;;;;;;;;;
;LEGACY SUPPORT;
;;;;;;;;;;;;;;;;
  CALL Write2Spaces           ;Move over
  MOV  BL,PCIULegacySupp      ;Get the Legacy Support Register
  CALL ReadPCIWord
  MOV  CX,AX                  ;Save Legacy Support Register
  MOV  AL,AH                  ;Write PIRQ
  SHR  AL,1
  MOV  BH,(ULSUSBIRQSts SHR 8)
  CALL WriteYNBALAHBH
  MOV  AX,CX                  ;Restore Legacy Support Register
  CALL WriteSpace             ;Move over
  TEST AL,ULSSMIUSBIRQEn      ;Is SMI# Enabled?
  JNZ >U13                    ;If so, jumot to handle it
U10:                          ;SMI# Disabled
  CALL WriteBlock             ;Write a Block
  JMP >U16                    ;Done
U13:                          ;SMI# Enabled
  CALL WritePeriod            ;WRite a Period (don't know if On or Not)
U16:                          ;Done with SMI#
  CALL WriteSpace             ;Move over
  MOV  BH,ULSSMI64WEn         ;Write Trap/SMI on Port 64h Write
  CALL WriteYNBALAHBH
  MOV  BH,ULSSMI64REn         ;Write Trap/SMI on Port 64h Read
  CALL WriteYNBALAHBH
  MOV  BH,ULSSMI60WEn         ;Write Trap/SMI on Port 60h Write
  CALL WriteYNBALAHBH
  MOV  BH,ULSSMI60REn         ;Write Trap/SMI on Port 60h Read
  CALL WriteYNBALAHBH
  MOV  AH,AL                  ;Write A20 Gate Pass-through
  SHR  AH,1
  MOV  BH,ULSA20PassThruEn
  CALL WriteYNBALAHBH
  MOV  AX,CX                  ;Restore Legacy Support Register
  MOV  BH,ULSSMIEndPassThruEn ;Write SMI at End of A20 Pass-through
  CALL WriteYNBALAHBH

;;;;;;;;;;;;;;;;;
;ROOT HUB PORT 2;
;;;;;;;;;;;;;;;;;
  CALL WriteCrLfPause         ;Move down
  MOV  CL,7                   ;Move
  CALL WriteSpaces            ;  over
  MOV  AL,2                   ;Write Root Hub Port 2 Status
  CALL ByteToString
  MOV  CH,AL
  MOV  BL,UPortSC2
  CALL ReadHostWord
  CALL WriteUPortStatus

  CALL WriteCrLfPause         ;Move down

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;RESTORE ORIGINAL PCI CONFIG;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  MOV  AX,BP                  ;Restore the
  MOV  BL,PCICfgCmd           ;  original PCI
  CALL WritePCIWord           ;  Configuration Command register

  POP  BP,DX,CX,BX,EAX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE CURRENT FRAME TIMING VALUE (BITS/FRAME) FOR A UHCI HOST
;Inputs:  DS = ES = Local Data Area
;Outputs: AX = Current Frame Timing (Bits/Frame)
;Changes:
;------------------------------------------------------------------------------
GetUFrameTiming:
  PUSH BX                ;Save used registers
  MOV  BL,USOFModify     ;Get Start-Of-Frame
  CALL ReadHostByte      ;  Modification Register
  XOR  AH,AH             ;Convert it to a Word
  ADD  AX,USOFModifyBase ;Add in the Base Value
  POP  BX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE STATUS OF A SINGLE UHCI ROOT HUB PORT STATUS & CONTROL REGISTER
;Inputs:  AX = Port Status and Control Register
;         CH = Port Number
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteUPortStatus:
  PUSH AX,BX
  MOV  BH,UPtConnStatChg       ;Write the Connect Status Changed State
  CALL WriteYesNoALBH
  MOV  BH,UPtConnStatus        ;Write the Connected Status
  CALL WriteYesNoALBH
  MOV  BH,UPtPortEnChg         ;Write the Enabled Status Changed State
  CALL WriteYesNoALBH
  MOV  BH,UPtPortEnable        ;Write the Enabled Status
  CALL WriteYesNoALBH
  MOV  BH,(UPtSuspend SHR 8)   ;Write the Suspend State
  CALL WriteYesNoAHBH
  MOV  BH,UPtResumeDetect      ;Write the Resume Detect State
  CALL WriteYesNoALBH
  MOV  BH,(UPtPortReset SHR 8) ;Write the Port Reset State
  CALL WriteYesNoAHBH
  MOV  BH,(UPtLowSpeed SHR 8)  ;Write the Low Speed Device Attached State
  CALL WriteYesNoAHBH
  MOV  BH,UPtLineStatM         ;Write the Line Status D- State
  CALL WriteYesNoALBH
  MOV  BH,UPtLineStatP         ;Write the Line Status D- State
  CALL WriteYesNoALBH
  CALL WriteDvcAddress         ;Write the Device Address
  CALL WriteTotalPower         ;Write the Port Power Draw
  POP  BX,AX
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO WRITE DETAILED EHCI STATUS TO THE SCREEN
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;WRITE DETAILED EHCI HOST STATUS TO THE SCREEN
;Inputs:  PCIDevFunc, PCIBusNum
;Outputs: Writes Details of EHCI Host Status
;Changes:
;------------------------------------------------------------------------------
WriteEHCIStatus:
  CALL CopyEHCIMemory ;Copy Base Memory to our data area
  JNC >S00            ;If OK, continue
  PUSH DX             ;If error, save used registers
  MOV  DX,NoDataMsg   ;Write the
  CALL WriteItDX      ;  Error Message
  POP  DX             ;Restore used registers
  RET

S00:
  PUSH EAX,BX,CX,DX,DI,SI,BP  ;Save used registers

;;;;;;;;;;;;;;;;;;;;;;;;;
;SAVE CURRENT PCI CONFIG;
;;;;;;;;;;;;;;;;;;;;;;;;;
  MOV  BL,PCICfgCmd                ;Store the
  CALL ReadPCIWord                 ;  original PCI
  MOV  BP,AX                       ;  Configuration Command Register
  OR   AX,PCICfgIOAccess+PCICfgMemoryAccess ;Enable I/O & Memory Access
  CALL WritePCIWord                ;Tell the PCI Bus about it

;;;;;;;;
;HEADER;
;;;;;;;;
  MOV  DX,HeaderMsgEHCI1           ;Write Header
  CALL WriteHeader1

;;;;;;;;;;;;;;;;
;SETUP POINTERS;
;;;;;;;;;;;;;;;;
  CALL Write2Spaces                ;Move over
  MOV  SI,EHCIRegData              ;Point [SI] at the Capability Registers
  XOR  BX,BX                       ;Point [SI+BX] at the
  MOV  BL,[SI].ECapabilityLen[0]   ;  Operational Registers
  MOV  DI,SI                       ;Point [DI] at the
  ADD  DI,BX                       ;  Operational Registers

;;;;;;;;;
;GENERAL;
;;;;;;;;;
  MOV  AX,W [SI].EHCIVersion[0]    ;Write the EHCI Version
  CALL WriteWordAsVersion
  MOV  AL,B [DI].ECommand[0]       ;Write Running
  MOV  BH,ECRunStop
  CALL WriteYesNoALBH
  MOV  AL,B [DI].EStatus[1]        ;Write Halted
  MOV  BH,(ESHostHalted SHR 8)
  CALL WriteYesNoALBH
  MOV  AL,B [DI].EConfigFlag[0]    ;Write Configured State
  MOV  BH,EConfigured
  CALL WriteYesNoALBH
  MOV  AL,B [SI].ECapabilityParams[0] ;Write 64-bit Address Capability
  MOV  BH,E64BitAddr
  CALL WriteYesNoALBH
  MOV  AL,B [DI].ECommand[0]       ;Write Host Reset
  MOV  BH,ECHostReset
  CALL WriteYesNoALBH
  MOV  BH,ECLightReset             ;Write Light Reset
  CALL WriteYesNoALBH
  MOV  AL,B [DI].ECapabilityParams[0] ;Write Isochronous Scheduling Threshold
  SHR  AL,4
  CALL ByteToString
  MOV  AL,B [DI].ECommand[2]       ;Write Interrupt Threshold
  CALL ByteToString
  CALL Write2Spaces                ;Move over
  MOV  EAX,[DI].EPerListAddr       ;Write Periodic List Address
  AND  AX,(EPerListMask AND 0FFFFh)
  CALL WriteDWordHex
  CALL WriteHexEnd
  MOV  AH,B [DI].EStatus[1]        ;Write Periodic List Status
  SHR  AH,2
  MOV  AL,B [DI].ECommand[0]
  MOV  BH,ECPerSchedEn
  CALL WriteYNBALAHBH
  CALL WriteSpace                  ;Move over
  MOV  EAX,[DI].EAsyncListAddr     ;Write Async List Address
  AND  AX,(EAsyncListMask AND 0FFFFh)
  CALL WriteDWordHex
  CALL WriteHexEnd
  MOV  AH,B [DI].EStatus[1]        ;Write Async List Status
  SHR  AH,2
  MOV  AL,B [DI].ECommand[0]
  MOV  BH,ECAsyncSchedEn
  CALL WriteYNBALAHBH
  CALL WriteAsyncPark              ;Write Async Park Status/Count
  MOV  AL,B [DI].ECommand[0]       ;Write Async Advance Doorbell
  MOV  BH,ECIntAsyncAdvDB
  CALL WriteYesNoALBH
  MOV  AL,B [DI].EStatus[1]        ;Write Reclamation Status
  MOV  BH,(ESReclamation SHR 8)
  CALL WriteYesNoALBH
  CALL WriteFrameListLen           ;Write Frame List Length
  CALL WriteFrameTime              ;Write Frame Time
  CALL WriteSpace                  ;Move over
  MOV  AX,W [DI].EFrameIndex[0]    ;Write Frame Number (Index)
  AND  AX,EFrameIdxMask
  CALL WordToString

;;;;;;;;
;HEADER;
;;;;;;;;
  MOV  DX,HeaderMsgEHCI2           ;Write Header
  CALL WriteHeader2

;;;;;;;;;;
;ROOT HUB;
;;;;;;;;;;
  CALL WriteSpace                  ;Move over
  MOV  AL,B [SI].EStrucParams[0]   ;Write number of Hub Ports
  AND  AL,ENumPortsMask
  CALL ByteToString
  MOV  AX,W [SI].EStrucParams[0]   ;Write Port Power Control
  MOV  BH,EPortPwrCtl
  CALL WriteYesNoALBH
  MOV  BH,EPtRoutingRules          ;Write Port Routing Rules
  CALL WriteYesNoALBH
  SHR  AX,12                       ;Write Number of Companion Controllers
  CALL WriteSpace
  CALL WriteNibbleHex
  CALL WriteSpace                  ;Move over
  MOV  AL,B [SI].EStrucParams[1]   ;Write Number of Ports per Companion
  AND  AL,(EPtsPerCompMask SHR 8)
  CALL WriteNibbleHex
  XOR  CH,CH                       ;Write Total Power
  CALL WriteTotalPower
  CALL WriteSpace                  ;Move over

;;;;;;;;;;;
;HUB PORTS;
;;;;;;;;;;;

  MOV  DL,B [SI].EStrucParams[0]   ;Put number of Hub Ports
  AND  DL,ENumPortsMask            ;  in DL
  MOV  CX,0100                     ;CH = Port, CL = Spaces to write
  CALL WriteEPortStatus            ;Write the Status of Port 1
  MOV  CL,19                       ;Use 19 spaces from now on
E10:                               ;Loop to here for each Port
  INC  CH                          ;Increment the Port Number
  CMP  CH,DL                       ;Is this a valid Port?
  JA  >E15                         ;If not, continue
  CALL WriteEPortStatus            ;If s, write the status of this port
  JMP  E10                         ;Keep going until we're done
E15:

;;;;;;;;
;HEADER;
;;;;;;;;
  MOV  DX,HeaderMsgEHCI3           ;Write Header
  CALL WriteHeader1

;;;;;;;;;;;;
;INTERRUPTS;
;;;;;;;;;;;;
  CALL WriteSpace                  ;Move over
  MOV  AL,B [DI].EIntEnable        ;Write USB Interrupt
  MOV  AH,B [DI].EStatus[0]
  MOV  BH,ESUSBInt
  CALL WriteYNBALAHBH
  MOV  BH,ESUSBErrInt              ;Write USB Error Interrupt
  CALL WriteYNBALAHBH
  MOV  BH,ESSystemErr              ;Write System Error Interrupt
  CALL WriteYNBALAHBH
  MOV  BH,ESPortChgDetect          ;Write Port Change Detect Interrupt
  CALL WriteYNBALAHBH
  MOV  BH,ESFrameListRoll          ;Write Frame List Rollover Interrupt
  CALL WriteYNBALAHBH
  MOV  BH,ESIntAsyncAdv            ;Write Interrupt on Async Advance
  CALL WriteYNBALAHBH

;;;;;;;;;;;;;;;;
;LEGACY SUPPORT;
;;;;;;;;;;;;;;;;
  CALL Write2Spaces                ;Move over
  MOV  BL,[SI].ECapabilityParams   ;Get the Extended Capabilities Offset (PCI)
E50:                               ;Loop to here to find Legacy Support
  OR   BL,BL                       ;Are there any more Extended Capabilities?
  JZ  >E56                         ;If not, we're done
E52:                               ;We have some Extended Capabilities
  CALL ReadPCIDWord                ;Get the Extended Capabilities
  CMP  AL,EXCLegacySupp            ;Is it Legacy Support?
  JNE >E54                         ;If not, keep looking
  ROL  EAX,16                      ;Put Semaphore Flags in AX
  MOV  BH,(ELSBIOSSemaphore SHR 16) ;Write BIOS Semaphore
  CALL WriteYesNoALBH
  MOV  BH,(ELSSysSemaphore SHR 24) ;Write Operating System Semaphore
  CALL WriteYesNoAHBH
  CALL WriteSpace                  ;Move over
  ADD  BL,4                        ;Get the actual Legacy Support
  CALL ReadPCIDWord                ;  Enable & Status Registers
  MOV  CX,AX                       ;Save the low word (Enables) in CX
  ROL  EAX,16                      ;Save the high word
  MOV  DX,AX                       ;  (the Status) in DX
  MOV  AL,CL                       ;AL = Low byte of Enables
  MOV  AH,DL                       ;AH = Low byte of Status
  MOV  BH,ELSSMICompleteEn         ;Write SMI on USB Complete
  CALL WriteYNBALAHBH
  MOV  BH,ELSSMIUSBErrorEn         ;Write SMI on USB Error
  CALL WriteYNBALAHBH
  MOV  BH,ELSSMISysErrorEn         ;Write SMI on System Error
  CALL WriteYNBALAHBH
  MOV  BH,ELSSMIPortChgEn          ;Write SMI on Port Change
  CALL WriteYNBALAHBH
  MOV  BH,ELSSMIFrameRollEn        ;Write SMI on Frame List Rollover
  CALL WriteYNBALAHBH
  MOV  BH,ELSSMIAsyncAdvEn         ;Write SMI on Async Advance
  CALL WriteYNBALAHBH
  CALL WriteSpace                  ;Move over
  MOV  AL,CH                       ;Write WMI on OS Ownership
  MOV  AH,DH
  MOV  BH,(ELSSMIOSOwnerEn SHR 8)  ;Write SMI on Async Advance
  CALL WriteYNBALAHBH
  MOV  BH,(ELSSMIPCICmdEn SHR 8)   ;Write SMI on PCI Command
  CALL WriteYNBALAHBH
  MOV  BH,(ELSSMIBaseAddrEn SHR 8) ;Write SMI on Base Memory Address
  CALL WriteYNBALAHBH
  JMP >E60                         ;Done
E54:                               ;Extended Capabilities <> Legacy Support
  MOV  BL,AH                       ;Get the Next Extended Capabilities Pointer
  JMP  E50                         ;Keep looking for Legacy Support
E56:                               ;No Legacy Support
  MOV  CL,23                       ;Write
  CALL WriteSpace                  ;  23
  CALL WriteBlocks                 ;  Blocks
E60:                               ;Done with Legacy Support

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;RESTORE ORIGINAL PCI CONFIG;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  MOV  AX,BP                       ;Restore the
  MOV  BL,PCICfgCmd                ;  original PCI
  CALL WritePCIWord                ;  Configuration Command register

  POP  BP,SI,DI,DX,CX,BX,EAX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY EHCI BASE MEMORY DATA TO OUR LOCAL DATA AREA
;Inputs:  BaseAddress
;Outputs: CF = Clear if OK
;              EHCIOpRegData, EHCILegacyData
;            = Set if Error
;              Data area unchanged
;Changes:
;------------------------------------------------------------------------------
CopyEHCIMemory:
  PUSH EAX,CX,DI       ;Save used registers
  MOV  EAX,BaseAddress ;EAX = Physical Address to Copy From
  MOV  DI,EHCIRegData  ;ES:[DI] = Where to Copy Data To
  MOV  CX,(EORSize/2)  ;CX = Number of Words to Copy
  CALL CopyFromPhysMem ;Do it (returns CF)
  POP  DI,CX,EAX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE ASYNC PARK STATUS TO THE SCREEN
;Inputs:  [SI] = EHCI Capability Registers
;         [DI] = EHCI Operational Registers
;Outputs: To Screen
;Changes:
;NOTES: There are three data "areas" associated with the Async Park Status:
;         Supported, Enabled, and Count.  If Not Supported, we write a
;         Block.  If supported but Disabled, we write a Dot.
;         If Supported and Enabled, we write the Count.
;------------------------------------------------------------------------------
WriteAsyncPark:
  PUSH AX                          ;Save used registers
  CALL WriteSpace                  ;Move over
  TEST B [SI].ECapabilityParams[0],EAsyncParkSupt ;Async Park Supported?
  JNZ >K20                         ;If so, continue
K10:                               ;Not Supported
  CALL WriteBlock                  ;Write a Block
  JMP >K90                         ;Done
K20:                               ;Is Supported
  MOV  AX,W [DI].ECommand[0]       ;Test if
  TEST AH,(ECAsyncParkEn SHR 8)    ;  Enabled
  JNZ >K40                         ;If so, continue
K30:                               ;Disabled
  CALL WritePeriod                 ;If not, write a Dot
  JMP >K90                         ;Done
K40:                               ;Supported and Enabled
  SHR  AX,8                        ;Write
  AND  AL,(ECAsyncParkCount SHR 8) ;  the
  CALL WriteNibbleHex              ;  Count
K90:                               ;Done
  POP  AX                          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE FRAME LIST LENGTH TO THE SCREEN
;Inputs:  [SI] = EHCI Capability Registers
;         [DI] = EHCI Operational Registers
;Outputs: To Screen
;Changes:
;NOTES: We check for both Programmability & Size.
;------------------------------------------------------------------------------
WriteFrameListLen:
  PUSH AX,BX,CX              ;Save used registers
  CALL WriteSpace            ;Move over
  MOV  BX,1024               ;Assume it's
  MOV  CH,'.'                ;  not programmable
  TEST B [SI].ECapabilityParams[0],EProgFrameLen ;Is Frame Length Programmable?
  JZ  >Z90                   ;If not, we're done
Z10:                         ;It is programmable
  MOV  CH,'Y'                ;Mark as Programmable
  MOV  AL,B [DI].ECommand[0] ;Get the
  AND  AL,ECFrListSizeMask   ;  Frame List
  SHR  AL,2                  ;  Length Code
  MOV  CL,AL                 ;Put it in CL
  SHR  BX,CL                 ;Calculate the Size (assume no Reserved)
Z90:                         ;Done (BX = Size)
  MOV  AX,BX                 ;Write the
  CALL WordToString          ;  Size
  CALL WriteSpace            ;Move over
  MOV  AL,CH                 ;Write the
  CALL WriteAL               ;  Programmability
  POP  CX,BX,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE FRAME TIME TO THE SCREEN
;Inputs:
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteFrameTime:
  PUSH AX,BX                 ;Save used registers
  CALL Write2Spaces          ;Move over
  MOV  BL,PCIEFrameLengthAdj ;Get the
  CALL ReadPCIByte           ;  Frame Length Adjuster
  AND  AL,EFrameLenMask      ;Mask out unwanted bits
  XOR  AH,AH                 ;Convert it to a Word
  SHL  AX,4                  ;Multiply by 16
  ADD  AX,EFrameLenBase      ;Add in the Base
  CALL WordToString          ;Write it
  POP  BX,AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE STATUS OF A SINGLE EHCI ROOT HUB PORT STATUS & CONTROL REGISTER
;Inputs:  [SI] = EHCI Capability Registers
;         [DI] = EHCI Operational Registers
;          CH  = Port Number to write
;          CL  = Number of Spaces to write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteEPortStatus:
  PUSH EAX,BX,CX,DX                ;Save used registers
  CALL WriteSpaces                 ;Move over
  MOV  AL,CH                       ;Write the
  CALL ByteToString                ;  Port Number
  CALL WriteSpace                  ;Move over
  MOV  AL,B [SI].EStrucParams[2]   ;Get the
  SHR  AL,4                        ;  Debug Port Number
  CMP  AL,CL                       ;Is it the Port we're writing?
  MOV  AL,'.'                      ;Assume it's not our Port
  JNE >P15                         ;If not, continue
P10:                               ;It's our Port
  MOV  AL,'Y'                      ;Mark as our Port
P15:                               ;AL = Yes or No
  CALL WriteAL                     ;Write the Debug Port Status
  MOV  BL,PCIEPortWakeCap          ;Get the
  CALL ReadPCIWord                 ;  Remote Wakeup Support Capabilities
  TEST AL,EPortWakeSupp            ;Is Remote Wakeup Support even Supported?
  JNZ >P25                         ;If so, continue
  CALL WriteBlock                  ;If not, just write a Block
  JMP >P30                         ;Continue
P25:                               ;Remote Wakeup is supported
  CALL DoBitTestCHAX               ;Write the Status
P30:                               ;Done with Remote Wakeup
  CALL WritePortCompanion          ;Write the Companion Host Number
  XOR  BX,BX                       ;Point [DI+BX]
  MOV  BL,CH                       ;  at the
  DEC  BX                          ;  correct
  SHL  BX,2                        ;  Port Offset
  MOV  AX,W [DI+BX].EPortSC1[0]    ;AX = Low Word of Port Status & Control
  MOV  DX,W [DI+BX].EPortSC1[2]    ;DX = Low Word of Port Status & Control
  MOV  BH,(EPtPortOwnerComp SHR 8) ;Write
  CALL WriteYesNoAHBH              ;  Port Ownership
  MOV  BH,(EPtPortPower SHR 8)     ;Write
  CALL WriteYesNoAHBH              ;  Port Power
  MOV  BH,EPtConnStatChg           ;Write
  CALL WriteYesNoALBH              ;  Connect Change
  MOV  BH,EPtConnStatus            ;Write
  CALL WriteYesNoALBH              ;  Connect Status
  MOV  BH,EPtPortEnChg             ;Write
  CALL WriteYesNoALBH              ;  Enable Change
  MOV  BH,EPtPortEnable            ;Write
  CALL WriteYesNoALBH              ;  Enable Status
  MOV  BH,EPtOverCurrChg           ;Write
  CALL WriteYesNoALBH              ;  Over-Current Change
  MOV  BH,EPtOverCurrSts           ;Write
  CALL WriteYesNoALBH              ;  Over-Current Status
  MOV  BH,EPtSuspend               ;Write
  CALL WriteYesNoALBH              ;  Suspend Status
  MOV  BH,EPtResumeDetect          ;Write
  CALL WriteYesNoALBH              ;  Resume Detect Status
  MOV  BH,(EPtReset SHR 8)         ;Write
  CALL WriteYesNoAHBH              ;  Reset Status
  MOV  BH,EPtWakeOnConnEn          ;Write
  CALL WriteYesNoDLBH              ;  Wake on Connect Enable
  MOV  BH,EPtWakeOnDiscEn          ;Write
  CALL WriteYesNoDLBH              ;  Wake on Disconnect Enable
  MOV  BH,EPtWakeOnOCurEn          ;Write
  CALL WriteYesNoDLBH              ;  Wake on Over-Current Enable
  CALL WriteDvcAddress             ;Write the Device Address
  CALL WriteTotalPower             ;Write the Power used on the Port
  CALL WriteSpace                  ;Move over
  PUSH AX                          ;Save the Port Status & Control Flags
  AND  AH,(EPtLineStsMask SHR 8)   ;Get the
  SHR  AH,2                        ;  Port Status
  MOV  AL,AH                       ;  Code
  MOV  BX,EPtStatusTbl             ;Write the
  CALL DoByte2StringTbl            ;  Port Status
  CALL WriteSpace                  ;Move over
  POP  AX                          ;Restore the Port Status & Control Flags
  TEST B [SI].EStrucParams[2],(EPtIndicators SHR 16) ;Are Indicators Supported?
  JNZ >P45                         ;If so, write them
  CALL WriteBlock                  ;If not,
  CALL WriteBlock                  ;  just write
  CALL WriteBlock                  ;  Blocks
  JMP >P50                         ;Continue
P45:                               ;Indicators Supported
  AND  AH,(EPtPortIndicator SHR 8) ;Get the
  SHR  AH,14                       ;  Port Indicator
  MOV  AL,AH                       ;  Code
  MOV  BX,EPtIndicatorTbl          ;Write the
  CALL DoByte2StringTbl            ;  Port Status
  CALL WriteSpace                  ;Move over
P50:                               ;Done with Indicators
  CALL WriteSpace                  ;Move over
  AND  DL,(EPtTestControl SHR 16)  ;Get the
  MOV  AL,DL                       ;  Port Test Flag
  MOV  BX,EPtTestTbl               ;Write the
  CALL DoByte2StringTbl            ;  Test Status
  CALL WriteCrLfPause              ;Move down
  POP  DX,CX,BX,EAX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE STATUS OF A SINGLE EHCI ROOT HUB PORT STATUS & CONTROL REGISTER
;Inputs:  [SI] = EHCI Capability Registers
;         [DI] = EHCI Operational Registers
;          CH  = Port Number to write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WritePortCompanion:
  PUSH AX,BX,CX                   ;Save used registers
  CALL WriteSpace                 ;Move over
  TEST B [SI].EStrucParams[0],EPtRoutingRules ;Does Host use Routing Rules?
  JZ  >C30                        ;If not, handle it
C10:                              ;Host uses Routing Rules
  XOR  BX,BX                      ;Get
  MOV  BL,CH                      ;  two
  DEC  BX                         ;  Companion
  SHR  BL,1                       ;  Host
  MOV  AL,[SI+BX].EPortRouting[0] ;  Numbers
  TEST CH,1                       ;Is it an Even Port Number?
  JZ  >C80                        ;If so, we're done
  SHR  AL,4                       ;If not, move Companion Number into low nibble
  JMP >C80                        ;Done
C30:                              ;Does not use Routing Rules
  MOV  AL,B [SI].EStrucParams[1]  ;Get the number of Ports
  AND  AL,(EPtsPerCompMask SHR 8) ;  per Companion Host
  OR   AL,AL                      ;Is it 0?
  JNZ >C35                        ;If not, continue
  CALL WriteBlock                 ;If so, write a Block
  JMP >C90                        ;Done
C35:                              ;Not 0 Ports per companion
  SHR  CX,8                       ;Divide the
  XCHG AX,CX                      ;  Port Index by the
  DEC  AX                         ;  Number of Ports
  DIV  CL                         ;  per Companion
C80:                              ;AL Low Nibble = 0-based Companion Host #
  INC  AL                         ;Convert to 1-based Number
  CALL WriteNibbleHex             ;Write the Compantion Port Number
C90:                              ;Done
  POP  CX,BX,AX                   ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO ISSUE INT 14h CALLS TO THE HOST DRIVER
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;TEST AND SEE IF A COMPATIBLE USB HOST DRIVER IS INSTALLED
;Inputs:
;Outputs: CF = Set if error (No Host Driver Installed)
;            = Clear if OK
;Changes:
;------------------------------------------------------------------------------
TestUSBHost:
  PUSH AX,BX,CX ;Save used registers
  MOV  AX,5000h ;Function 5000h (Install Check)
  MOV  BX,'US'  ;Set
  MOV  CX,'B!'  ;  registers
  STC           ;Preset Error Flag
  INT  14h      ;Do it
  JC  >U70      ;If Error, USB Host can't be installed
  OR   AX,AX    ;Is AX Correct?
  JNZ >U70      ;If not, Error
  CMP  BX,'B!'  ;Is BX correct?
  JNE >U70      ;If not, Error
  CMP  CX,'US'  ;Is CX correct?
  JE  >U80      ;If so, it's installed
U70:            ;Not installed
  STC           ;Set Error Flag
  JMP >U90      ;Done
U80:            ;Installed
  CLC           ;Set OK flag
U90:            ;Done
  POP  CX,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE AN INT 14 CALL TO THE USB HOST
;Inputs:  DS:[DX] = Int 14 Request (filled with appropriate data)
;Outputs: CF = Set if error (host stalled, etc.)
;            = Clear if OK
;Changes: Sends the appropriate info to the USB Host via Int 14 call
;------------------------------------------------------------------------------
DoInt14CallSI:
  STI           ;Enable Interrupts
  MOV  DX,SI    ;Point DS:[DX] at the Request
  MOV  AX,5001h ;Set Function
  MOV  BX,'US'  ;Set
  MOV  CX,'B!'  ;  Registers
  STC           ;Preset Error Flag
  INT  14h      ;Do it
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;SUPPORT CODE FOR WRITING HOST STATUSES
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;WRITE A SPACE AND THEN A BLOCK, YES, OR NO TO THE SCREEN
;Inputs: AL = Status Byte to test for Block Character
;               (Block indicates "Not Supported" or "Not Enabled")
;        AH = Status Byte to test for Yes (Y) or No (Period) Character
;               (Only written if Block Character is not Written)
;        BH = Mask to test for in (Uses same mask for AL & AH)
;Outputs: To the screen
;Changes:
;------------------------------------------------------------------------------
WriteYNBALAHBH:
  TEST AL,BH          ;Is the flag supported/enabled?
  JNZ >K20            ;If so, continue
  CALL WriteSpace     ;If no, write a Space
  CALL WriteBlock     ;Write a Block
  JMP >K90            ;Done
K20:                  ;Enabled/Supported
  CALL WriteYesNoAHBH ;Write the Yes/No Status
K90:                  ;Done
  RET

;------------------------------------------------------------------------------
;WRITE A SPACE AND THEN A YES OR NO TO THE SCREEN
;Inputs: AL/AH = Status Byte to test (If WriteYesNoAL or WriteYesNoAH)
;        DL/DH = Status Byte to test (If WriteYesNoDL or WriteYesNoDH)
;        BH    = Mask to test for
;Outputs: To the screen
;Changes:
;------------------------------------------------------------------------------
WriteYesNoALBH:
  PUSH AX         ;Save used registers
  MOV  AH,AL      ;Put test byte into AH
  JMP >Y00        ;Jump to do it
WriteYesNoAHBH:
  PUSH AX         ;Save used registers
  JMP >Y00        ;Jump to do it
WriteYesNoDLBH:
  PUSH AX         ;Save used registers
  MOV  AH,DL      ;Put test byte into AH
;  JMP >Y00        ;Jump to do it
;WriteYesNoDHBH:
;  PUSH AX         ;Save used registers
;  MOV  AH,DH      ;Put test byte into AH
;  JMP >Y00        ;Jump to do it
Y00:
  CALL WriteSpace ;Move over
  MOV  AL,'Y'     ;Assume Yes
  TEST AH,BH      ;Is it Yes?
  JNZ >Y20        ;If so, write Yes
  MOV  AL,'.'     ;If not, write a Dot
Y20:              ;[DX] = String to write
  CALL WriteAL    ;Write the character
  POP  AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE STRING FROM A BYTE-TO-STRING LOOKUP TABLE
;Inputs:   AL  = Byte to Search for
;         [BX] = Table to Search in (last entry = -1)
;          CLD already issued
;         DS = ES = Data Area where Table is stored
;Outputs: String from Table is written to the screen
;         If exact match is not found, Last Entry (with byte = -1) is written
;Changes:
;------------------------------------------------------------------------------
DoByte2StringTbl:
  PUSH AX,CX     ;Save used registers
  PUSH DI,SI     ;Save used registers
  MOV  DI,BX     ;Point [DI] at the Table
  MOV  AH,AL     ;Put the search byte in AH
B10:             ;Loop to here to find the entry
  MOV  SI,DI     ;Point [SI] at the next table entry
  LODSB          ;Get the table entry byte
  CMP  AL,AH     ;Is it the one we're looking for?
  JE  >B90       ;If so, write it
  CMP  AL,-1     ;If not, is it the last table entry?
  JE  >B90       ;If so, write it
  MOV  CX,-1     ;If not,
  XOR  AL,AL     ;  jump to
  INC  DI        ;  the next
  REPNE SCASB    ;  table entry
  JMP  B10       ;Keep looking
B90:             ;Done
  CALL WriteItSI ;Write the String
  POP  SI,DI     ;Restore used registers
  POP  CX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET AND WRITE THE DEVICE ADDRESS FOR A SPECIFIC PORT ON THE ROOT HUB
;Inputs:  HostIndex (-1 if invalid Host)
;         Int14Request with Host Index already filled in
;         CH = Port to get Device Address for
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteDvcAddress:
  PUSH AX,BX,CX,DX,SI,BP          ;Save used registers
  CALL WriteSpace                 ;Move over
  CMP  HostIndex,-1               ;Valid Host Index?
  JE  >A70                        ;If not, just write blocks
  MOV  AL,1                       ;AL = Hub Address to test for
  MOV  AH,CH                      ;AH = Port Number to test for
  MOV  BP,AX                      ;Put test value in BP
  MOV  SI,Int14Request            ;Point [SI] at the Interrupt 14 Request
  MOV  [SI].I14RRequestType,I14RRTGetDvcHubInfo ;Request Type = Get Hub & Port
  MOV  [SI].I14RDeviceAddress,2   ;Start with Device Address 2
A10:                              ;Loop to here to find correct Device
  CALL DoInt14CallSI              ;Do it (returns CF, BX = Hub Address & Port)
  JC  >A30                        ;If error, it's not the address we want
  CMP  BX,BP                      ;Is it the Hub & Port we're looking for?
  JE  >A50                        ;If so, we've found it
A30:                              ;Not correct address
  CMP  [SI].I14RDeviceAddress,127 ;Was this the last possible address?
  JE  >A70                        ;If so, there's no Device
  INC  [SI].I14RDeviceAddress     ;If not, go to the next one
  JMP  A10                        ;Keep looking
A50:                              ;It's the one we're looking for!
  MOV  AL,[SI].I14RDeviceAddress  ;Write
  CALL ByteToString               ;  the address
  JMP >A90                        ;Done
A70:                              ;No address found
  MOV  CL,3                       ;Write some
  CALL WriteBlocks                ;  blocks
A90:                              ;Done
  POP  BP,SI,DX,CX,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE TOTAL POWER USED DOWNSTREAM FROM THE ROOT HUB PORTS
;Inputs:  HostIndex (-1 if invalid Host)
;         Int14Request with Host Index already filled in
;         CH = Port to get Power for (0 if all Ports)
;Outputs: To Screen
;Changes:
;NOTES: If CH = 0 (all ports), we write a space and then a word (5 characters)
;       If CH > 0 (specific port), we use a total of 5 characters
;------------------------------------------------------------------------------
WriteTotalPower:
  PUSH AX,BX,CX,DX,SI          ;Save used registers
  OR   CH,CH                   ;Need to write an extra space?
  JNZ >P20                     ;If not, continue
P10:                           ;Write an extra space
  CALL WriteSpace              ;Move over
P20:                           ;Handled extra space, if needed
  CMP  HostIndex,-1            ;Valid Host Index?
  JE  >P70                     ;If not, handle it
  MOV  SI,Int14Request         ;If so, point [SI] at the Interrupt 14 Request
  MOV  [SI].I14RRequestType,I14RRTGetHubPowerDraw ;Request Type = Get Power Draw
  MOV  B [SI].I14RHubAddress,1 ;Hub Address = 1 (Root Hub)
  MOV  [SI].I14RHubPort,CH     ;Store Hub Port
  CALL DoInt14CallSI           ;Do it (returns BX = Total Power)
  MOV  AX,BX                   ;Write the
  CALL WordToString            ;  Power Draw
  JMP >P90                     ;Done
P70:                           ;No power details available
  MOV  CL,5                    ;Assume Port 0
  OR   CH,CH                   ;Is it port 0?
  JZ  >P75                     ;If so, continue
  DEC  CL                      ;If not, modify number of Blocks
  CALL WriteSpace              ;Write a Space
P75:                           ;CL = Number of Blocks to write
  CALL WriteBlocks             ;  blocks
P90:                           ;Done
  POP  SI,DX,CX,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE INVALID HOST INDEX ERROR MESSAGE TO THE SCREEN
;Inputs:  AL = Host Type ('E', 'O', or 'U')
;         SI = PCI Search Index
;Outputs: Writes "xHCI Index is invalid" type message to the screen
;Changes:
;------------------------------------------------------------------------------
WriteBadHostIdx:
  PUSH AX,DX         ;Save used registers
  CALL WriteAL       ;Write first part
  MOV  DX,NoHostMsg1 ;  of
  CALL WriteItDX     ;  error message
  MOV  AX,SI         ;Write the
  CALL WriteWordMin  ;  Search Index
  MOV  DX,NoHostMsg2 ;Write the last part of
  CALL WriteItDX     ;  the Error Message
  POP  DX,AX         ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO COPY DATA TO/FROM EXTENDED MEMORY FROM/TO OUR DATA AREA
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;COPY DATA TO/FROM A PHYSICAL ADDRESS FROM/TO TO A SEGMENT:OFFSET ADDRESS
;Inputs:  DS = ES = Local Data Area
;         EAX     = Physical Memory Address
;         ES:[DI] = Segment:Offset Memory Address
;         CX      = Number of Words to Copy (note WORDS, not bytes)
;Outputs: CF = Clear if OK
;              Data is copied
;            = Set if Error
;Changes: MemCopyTable
;NOTES: This uses the System BIOS "Copy Extended Memory" function
;         (INT 15h, Function 87h) to perform the Copy.  It works under
;         all Protected Mode Memory Managers that I have tried
;         (DPMI, VCPI, and "regular"), so can provide a straightforward
;         way to do things.  The only issue to overcome is being able
;         to convert a physical address to a linear address, which is what
;         the BIOS function needs.  The method to do that depends on
;         which Protected Mode Memory Manager is currently in use.
;       Attempting to convert a physical address to a linear address
;         (a function that is supposed to be supported by all DPMI servers)
;         crashes every computer I've tried it on.  If it's not supported,
;         it should simply return with an error rather than crashing
;         the computer.
;       The value in CX is a Word count, not a byte count.  Data does not
;         need to be word-aligned.
;       According to the Spec, the value in CX can be anything between
;         0 and 32,768 (Words).  On at least one computer of mine, CX cannot
;         be larger than 9 or the function fails.  Therefore, we divide
;         the call into several sub-calls that each copy a maximum of
;         1 paragraph (8 Words) at a time.
;------------------------------------------------------------------------------
CopyFromPhysMem:
  PUSH DX                   ;Save used registers
  MOV  DX,CopyFromPhysMemGo ;SI = Code Address to Call
  JMP >Y00                  ;Do it
CopyToPhysMem:
  PUSH DX                   ;Save used registers
  MOV  DX,CopyToPhysMemGo   ;SI = Code Address to Call
;  JMP >Y00                  ;Do it
Y00:
  PUSH EAX,BX,ECX,DI  ;Save used registers
  AND  ECX,0000_FFFFh ;Mask out high Word of ECX
  MOV  BX,CX          ;Save original Word Count
Y10:                  ;Loop to here for each Paragraph (8 Words)
  MOV  CX,BX          ;Put updated Counter in CX
  OR   CX,CX          ;Anything left to copy?
  JZ  >Y80            ;If not, we're done
  CMP  CX,8           ;Is there more than 8 words left to copy?
  JBE >Y30            ;If not, just do it
  MOV  CX,8           ;If so, just do 8 Words
Y30:                  ;CX = Number of Words to Copy this time
  SUB  BX,CX          ;Subtract Words sent from the Counter
  CALL DX             ;Do the Copy
  JC  >Y90            ;If error, quit
  ADD  CX,CX          ;Convert Word Counter to Byte Counter
  ADD  EAX,ECX        ;Update Physical Address
  ADD  DI,CX          ;Update Segment:Offset Address
  JMP  Y10            ;Do it again
Y80:                  ;Success
  CLC                 ;Set success retrun flag
Y90:                  ;Done
  POP  DI,ECX,BX,EAX  ;Restore used registers
  POP  DX             ;Restore used registers
  RET

CopyFromPhysMemGo:
  PUSH BX,DX                  ;Save used registers
  MOV  BX,OFFSET MCSrcSegment ;Source Segment = Physical
  MOV  DX,OFFSET MCDstSegment ;Destination Segment = Segment:Offset
  JMP >P00                    ;Do it
CopyToPhysMemGo:
  PUSH BX,DX                  ;Save used registers
  MOV  BX,OFFSET MCDstSegment ;Destination Segment = Physical
  MOV  DX,OFFSET MCSrcSegment ;Source Segment = Segment:Offset
;  JMP >P00                    ;Do it
P00:
  PUSH EAX,EDI,SI       ;Save used registers
  CALL InitMemCopyTable ;Initialize the Descriptor Table
  MOV  SI,MemCopyTable  ;Point ES:[SI] at the Descriptor Table
  CALL Phys2Linear      ;Convert the Physical Address to a Linear Address
  JC  >P70              ;If error, quit
  CALL CopyEAX2GDTAddr  ;Store the Physical Address
  XOR  EAX,EAX          ;Convert ES Segment
  MOV  AX,ES            ;  to a
  SHL  EAX,4            ;  Linear Address
  AND  EDI,0000_FFFFh   ;Add in
  ADD  EAX,EDI          ;  the DI Offset
  MOV  BX,DX            ;Store the
  CALL CopyEAX2GDTAddr  ;  Segment:Offset Address
  MOV  AH,87h           ;AH = Function = 87h (Copy Extended Memory)
                        ;CX = # of Words to Copy (Max 8000h)
                        ;ES:[SI] = Memory Copy Descriptor Table
  STC                   ;Preset Error Flag
  CLI                   ;Disable interrupts
  INT  15h              ;Do it (Returns CF & AH)
  STI                   ;Enable interrupts
  OR   AH,AH            ;Did it work?
  JZ  >P80              ;If so, we're done
P70:                    ;Error
  STC                   ;Set error flag
  JMP >P90              ;Done
P80:                    ;OK
  CLC                   ;Set OK flag
P90:                    ;Done
  POP  SI,EDI,EAX       ;Restore used registers
  POP  DX,BX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;STORE A 32-BIT LINEAR ADDRESS INTO A GDT ENTRY
;Inputs:  EAX  = Linear Address to Store
;         [SI] = GDT Table to Store it in
;          BX  = Offset of GDT Entry in Table to use
;Outputs: Stores EAX in the GDT Entry appropriately
;Changes:
;NOTES: A 32-bit GDT entry stores the low 3 bytes in the address in one place
;         and the high byte in another, so a simple MOV instruction won't work.
;------------------------------------------------------------------------------
CopyEAX2GDTAddr:
  PUSH EAX                          ;Save used registers
  MOV  W [SI+BX].GDTAddress24[0],AX ;Store
  SHR  EAX,16                       ;  the
  MOV  B [SI+BX].GDTAddress24[2],AL ;  Destination
  MOV  B [SI+BX].GDTAddress32[0],AH ;  Address
  POP  EAX                          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE DESCRIPTOR TABLE
;Inputs:  DS = ES = Local Data Area
;         CLD already issued
;Outputs: Initializes MemCopyTable values
;Changes:
;NOTES: This initializes all values in the Memory Copy Descriptor Table except
;         the Linear Memory Addresses.  After calling this subroutine, the
;         Caller simply needs to fill in the Memory Addresses and issue
;         the BIOS Call.
;       This sets the segment limits that are needed to guarantee full
;         transfer of a 64K Segment, even if it is not properly aligned.
;------------------------------------------------------------------------------
InitMemCopyTable:
  PUSH AX,BX,CX,DI,SI                  ;Save used registers
  MOV  DI,MemCopyTable                 ;Point [DI] at the Descriptor Table
  MOV  CX,(MemCopySize/2)              ;CX = Number of Words to Write
  XOR  AX,AX                           ;Write Zeroes
  REP  STOSW                           ;Set Table to all zeroes
  MOV  BX,MemCopyTable                 ;Point [BX] at the Table
  MOV  SI,OFFSET MCSrcSegment          ;SI = Source Offset
  MOV  DI,OFFSET MCDstSegment          ;DI = Destination Offset
  MOV  [BX+SI].GDTSegLimit,17          ;Setup Segment Limits (big enough
  MOV  [BX+DI].GDTSegLimit,17          ;  for entire 64k Segment)
  MOV  [BX+SI].GDTRights,RightsToUse   ;Setup
  MOV  [BX+DI].GDTRights,RightsToUse   ;  Basic Rights
  MOV  [BX+SI].GDTXRights,XRightsToUse ;Setup Extended Rights & High Nibble
  MOV  [BX+DI].GDTXRights,XRightsToUse ;  of 20-bit Segment Limit
  POP  SI,DI,CX,BX,AX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A PHYSICAL ADDRESS TO A LINEAR ADDRESS
;Inputs:  EAX = Physical Address to Convert
;Outputs: CF = Clear if OK
;              EAX = Linear Address associated with Physical Address
;            = Set if Error
;              EAX = Unchanged
;Changes:
;NOTES: The linear address returned is intended to be used with the
;         BIOS Extended Memory Copy Function (INT 15h, function 87h).
;       Using it for any other purpose may or may not work.
;------------------------------------------------------------------------------
Phys2Linear:
  PUSH EBX          ;Save used registers
  MOV  EBX,EAX      ;Save original EAX
  CALL TestRealMode ;Are we in Real Mode?
  JZ  >L80          ;If so, we're done (Physical = Linear)
  CALL TestDPMI     ;If not, are we under DPMI?
  JNC >L70          ;If so, error
  CALL TestVCPI     ;If not, are we under VCPI?
  JC  >L70          ;If not, we can't convert it
  CALL Test1MBVCPI  ;If so, see if it's in the first MB (Rtns EAX)
  JNC >L80          ;If so, we're done
  CALL TestPaging   ;If not, is Paging Enabled?
  JNC >L80          ;If not, Linear Address = Physical Address
L70:                ;Error
  MOV  EAX,EBX      ;Restore original EAX
  STC               ;Set error flag
  JMP >L90          ;Done
L80:                ;OK
  CLC               ;Set OK flag
L90:                ;Done
  POP  EBX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A PHYSICAL ADDRESS IS IN THE FIRST MB UNDER VCPI
;Inputs:  EAX = Physical Address to Test/Convert
;Outputs: CF = Clear if Address is in First MB
;              EAX = Linear Address associated with Physical Address
;            = Set if Address is not in First MB
;              EAX = Unchanged
;------------------------------------------------------------------------------
Test1MBVCPI:
  PUSH EBX,CX,EDX      ;Save used registers
  PUSH EDI,ESI,EBP     ;Save used registers
  MOV  EBP,EAX         ;Save original EAX
  AND  EAX,0FFFF_F000h ;Convert EAX to a 4k Page Base Address
  MOV  EDI,EBP         ;Save Page Offset
  SUB  EDI,EAX         ;  in EDI
  MOV  ESI,EAX         ;Store Page Base Offset in ESI
  XOR  CX,CX           ;Start with Page 0
V10:                   ;Write the next page
  MOV  AX,0DE06h       ;Function DE06h (Get Phys Addr of Page in first MB)
                       ;CX = Page Number
  INT  67h             ;Do it (Rtns AH, EDX)
  OR   AH,AH           ;Did it work?
  JNZ >V30             ;If not, try the next one
  CMP  EDX,ESI         ;Does the base Page Physical Address match?
  JNE >V30             ;If not, try the next one
  XOR  EAX,EAX         ;If so, put the
  MOV  AX,CX           ;  Base Linear Address
  SHL  EAX,12          ;  in EAX
  ADD  EAX,EDI         ;Add in the Offset
  JMP >V80             ;Done
V30:                   ;Done testing this Page
  INC  CX              ;Increment the Page Number
  CMP  CX,256          ;Done all of the pages yet?
  JB   V10             ;If not, keep going
V70:                   ;Not in first MB
  MOV  EAX,EBP         ;Restore original EAX
  STC                  ;Set return flag
  JMP >V90             ;Done
V80:                   ;In first MB
  CLC                  ;Set OK flag
V90:                   ;Done
  POP  EBP,ESI,EDI     ;Restore used registers
  POP  EDX,CX,EBX      ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO PARSE THE COMMAND LINE FOR SWITCHES, AND PRINT ERRORS.
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;PARSE THE COMMAND LINE FOR SWITCHES
;Inputs:  DS = Local Data Area
;Outputs: All kinds of stuff!
;Changes:
;------------------------------------------------------------------------------
ParseThings:
  PUSH SI                   ;Save used registers
  MOV  SI,81h               ;Assume "real" Command Line
  CMP  CmdLineVarPointer,-1 ;Have a CMDLINE Environment variable?
  JE  >P20                  ;If not, just do regular command line
  MOV  SI,CmdLineVarPointer ;If so, point at the variable
P20:                        ;Pointed at Command Line Tail
  CALL ParseCmdLine         ;Parse Command Line
  POP  SI                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PARSE THE COMMAND LINE FOR SWITCHES
;Inputs:  ParseTest
;         [SI] = Option String to Parse
;Outputs:
;Changes: SI
;------------------------------------------------------------------------------
ParseCmdLine:
  PUSH AX             ;Save used registers
P10:                  ;Look for the next switch
  CALL IsSpaceOrEOX   ;Look for a valid character
  JZ  >P90            ;If EOL, we're done
  CMP  AL,'/'         ;Is it a slash?
  JE  >P20            ;If so, jump to handle it
  CMP  AL,'-'         ;Is it a dash?
  JE  >P20            ;If so, jump to handle it
  DEC  SI             ;If not, point back at the first character
  JMP >P30            ;Continue
P20:                  ;It's a slash or a dash
  CALL IsSpaceOrEOL   ;Look for a valid switch character
  JZ  >P70            ;If no character, there's an error
P30:                  ;Look for the switch
  CALL GetSwitch      ;See if it matches one of our switches
  JNZ  P10            ;If a match, look for the next switch
P70:                  ;Error - tell the user where it was
  CALL WriteCmdErr    ;Display the error for the user
  MOV  AL,ErLvlOption ;ErrorLevel = Bad Option on command line
  MOV  DX,NoMsg       ;Point at an empty message
  JMP  Exit           ;Print error message and quit
P90:                  ;We're done
  POP  AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE SWITCH CHARACTERS, AND DO WHATEVER IT IS THEY'RE ASKING
;Inputs:  DS:[SI] = Command line pointer
;Outputs: Lots of stuff!!!
;         ParseError
;         ZF = Set if Error
;            = Clear if OK
;Changes:
;------------------------------------------------------------------------------
GetSwitch:
  PUSH AX,BX,DI            ;Save used registers
  CALL GetCallBackAddrs    ;Look for the call-back addresses
  JNC >S90                 ;If we got them, we're done
  MOV  BX,SwitchList       ;Point at the list of switch code words
  CALL GetCode             ;See if its a match
  JNC >S10                 ;If so, jump to test it
  CALL GetNextChar         ;If not, it's a single character
  CALL Capitalize          ;Capitalize it
S10:                       ;We have a Switch to test!
  MOV  BX,SwitchTbl        ;Point at the Table of Offsets
S20:                       ;Loop to here for each table entry
  MOV  AH,[BX]             ;Get the switch from our table?
  OR   AH,AH               ;Is it the end of the table?
  JZ  >S70                 ;If so, there's an error
  CMP  AL,AH               ;If a valid entry, is it a match?
  JE  >S30                 ;If so, jump to handle it
  ADD  BX,3                ;If not, point at the next table entry
  JMP  S20                 ;And keep looking
S30:                       ;It's a match from the table
  MOV  DI,OFFSET ProgFlags ;Point [DI] at ProgFlags
  MOV  AH,ParseTest        ;Pass the "Testing" flag
  OR   AH,AH               ;Set the ZF for Testing
  CALL W [BX+1]            ;Do the Switch stuff
  JMP >S90                 ;And quit
S70:                       ;There's an error
  MOV  ParseError,Yes      ;Mark the error flag
S90:                       ;We're done
  CMP  ParseError,Yes      ;Set/Clear the error flag
  POP  DI,BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Display Help (Syntax) Message
;Inputs:   DS = ES = Local Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchH:
  OR   B [DI],Help ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Display ErrorLevel Table
;Inputs:   DS = ES = Local Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchV:
  OR   B [DI],ErrLvl ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Display list of Command-line (Option) Aliases
;Inputs:   DS = ES = Local Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchA:
  OR   B [DI],Alias ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Write Details for All Hosts
;Inputs:   DS = ES = Local Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchD:
  OR   B [DI],AllHosts ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Stop an EHCI Host from Running
;Inputs:   DS = ES = Local Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchS:
  PUSH EAX,EBX,CX,DX,DI,BP      ;Save used registers
  XOR  EBX,EBX                  ;High Word of EBX = 0
  CALL GetNumber                ;Get the PCI Search to use
  MOV  BP,SI                    ;Save Command Line Pointer
  JC  >S70                      ;If no number, error
  MOV  DX,AX                    ;Save the PCI Search Index
  CMP  ParseTest,Yes            ;Is this just the test run?
  JE  >S95                      ;If so, don't do anything
  CALL WriteStopping1           ;Write Header
  MOV  SI,AX                    ;SI = PCI Search Index
  MOV  AL,ProgIntfEHCI          ;AL = Programming Interface
  CALL TestHost                 ;Look for the Host (sets CF, stores PCIDevFunc)
  JC  >S72                      ;If no Host, quit
  CALL GetEHCIBaseAddr          ;Get the Base Memory Address (stores BaseAddress)
  CALL CopyEHCIMemory           ;Copy Base Memory to our data area
  JC  >S74                      ;If Error, Quit
  MOV  DI,EHCIRegData           ;[DI] = Capability Registers
  MOV  EAX,BaseAddress          ;EAX = Base Address (Capability Registers)
;  PUSH EAX,DI                   ;Momentarily save base pointers
;  ADD  DI,EXLSCtrlStatus        ;[DI] = SMI Enable Configuration
;  ADD  EAX,EXLSCtrlStatus       ;EAX = SMI Enable Configuration
;  MOV  D [DI],0                 ;Disable all SMI generation
;  MOV  CX,2                     ;Send two words
;  CALL CopyToPhysMem            ;Update the Host Controller Registers
;  POP  DI,EAX                   ;Restore base pointers
;  JC  >S74                      ;If Memory Copy Failed, Error
  MOV  BL,[DI].ECapabilityLen   ;EBX = Capability Length
  ADD  DI,BX                    ;[DI] = Operational Registers (ECommand)
  ADD  EAX,EBX                  ;EAX  = Operational Registers (ECommand)
  AND  B [DI],(NOT ECRunStop)   ;Stop the Host
  MOV  CX,1                     ;Send one word
  CALL CopyToPhysMem            ;Update the Host Controller Registers
  JC  >S74                      ;If Memory Copy Failed, Error
  ADD  DI,EConfigFlag           ;[DI] = Configuration Flag
  ADD  EAX,EConfigFlag          ;EAX  = Configuration Flag
  AND  B [DI],(NOT EConfigured) ;Unconfigure Host
  CALL CopyToPhysMem            ;Update the Host Controller Registers
  JC  >S74                      ;If Memory Copy Failed, Error
  JMP >S80                      ;Done
S70:                            ;Parsing Error
  MOV  ParseError,Yes           ;Mark as an error
  JMP >S95                      ;Done
S72:                            ;Invalid EHCI Host Index
  MOV  AL,'E'                   ;Write the
  CALL WriteBadHostIdx          ;  Error Message (uses AL, SI)
  JMP >S90                      ;Done
S74:                            ;Can't download Data from Host
  MOV  DX,NoDataMsg             ;Write the
  CALL WriteItDX                ;  Error Message
  JMP >S90                      ;Done
S80:                            ;OK
  CALL WriteStopping2           ;Write OK message
S90:                            ;Done
  OR   ProgFlags,WroteOne       ;Mark as having done something
  CALL WriteStopping3           ;Finish up screen
S95:                            ;Done
  MOV  SI,BP                    ;Restore command line pointer
  POP  BP,DI,DX,CX,EBX,EAX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE BASE MEMORY ADDRESS FOR AN EHCI CONTROLLER
;Inputs:  PCIDevFunc already filled in
;Outputs: BaseAddress (Memory)
;Changes:
;------------------------------------------------------------------------------
GetEHCIBaseAddr:
  PUSH EAX,BX            ;Save used registers
  MOV  BL,PCIBaseMemAddr ;BL = Data Offset in PCI Configuration Space
  CALL ReadPCIDWord      ;Read the Data
  MOV  BaseAddress,EAX   ;Store the Data
  POP  BX,EAX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE STOPPING MESSAGES TO THE SCREEN
;Inputs:  DX = EHCI PCI Search Index we are Stopping
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
WriteStopping1:
  PUSH AX,DX              ;Save used registers
  MOV  AX,DX              ;AX = PCI Search Index
  TEST ProgFlags,WroteOne ;Already wrote something?
  JZ  >P20                ;If not, continue
  CALL WriteCrLfPause2    ;If so, move down
P20:                      ;Moved down, as necessary
  MOV  DX,StopDividerMsg  ;Write a
  CALL WriteItDX          ;  Dividing Line
  MOV  DX,WaitingMsg1     ;Write first part
  CALL WriteItDX          ;  of Message
  CALL WriteWordMin       ;Write the PCI Search Index
  MOV  DX,WaitingMsg2     ;Write last part
  CALL WriteItDX          ;  of Message
  POP  DX,AX              ;Restore used registers
  RET

WriteStopping2:
  PUSH AX,DX             ;Save used registers
  MOV  AX,DX             ;AX = PCI Search Index
  MOV  DX,EHCIStopMsg1   ;Write the first part
  CALL WriteItDX         ;  of the Message
  CALL WriteWordMin      ;Write the PCI Search Index
  MOV  DX,EHCIStopMsg2   ;Write the last part
  CALL WriteItDX         ;  of the Message
  POP  DX,AX             ;Restore used registers
  RET

WriteStopping3:
  PUSH DX                ;Save used registers
  CALL WriteCrLfPause    ;Move down
  MOV  DX,StopDividerMsg ;Write a
  CALL WriteItDX         ;  Dividing Line
  CALL WriteCrLfPause    ;Move down
  POP  DX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Write Details for a Particular Host Controller
;Inputs:   DS = ES = Local Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchE:
  PUSH BX              ;Save used registers
  MOV  BL,ProgIntfEHCI ;BL = Programming Interface
  JMP >H00             ;Do it
DoSwitchO:
  PUSH BX              ;Save used registers
  MOV  BL,ProgIntfOHCI ;BL = Programming Interface
  JMP >H00             ;Do it
DoSwitchU:
  PUSH BX              ;Save used registers
  MOV  BL,ProgIntfUHCI ;BL = Programming Interface
;  JMP >H00             ;Do it
H00:
  PUSH AX,DI             ;Save used registers
  CALL GetNumber         ;Get the PCI Search to use
  MOV  DI,SI             ;Save Command Line Pointer
  JC  >H70               ;If no Index, Error
  CMP  ParseTest,Yes     ;Is this just the test run?
  JE  >H90               ;If so, don't write anything
  MOV  SI,AX             ;If so, SI = Search Index
  MOV  AL,BL             ;AL = Programming Interface
  CALL WriteHostComplete ;Write Summary & Details
  JMP >H90               ;Done
H70:                     ;Error
  MOV  ParseError,Yes    ;Mark as an error
H90:                     ;Done
  MOV  SI,DI             ;Restore command line pointer
  POP  DI,AX             ;Restore used registers
  POP  BX                ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO GET A NUMBER FROM A STRING (HEX OR DECIMAL)
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;GET A NUMBER FROM A STRING (CAN BE DECIMAL OR HEX)
;Inputs:  [SI] = String Pointer
;Outputs: CF = Clear if we got a valid number
;              AX = Number
;            = Set if Error (no number found)
;              AX = 0
;Changes: SI points at next byte after the number
;NOTES: A Hex String must start with '0x' and/or end in 'H'!
;------------------------------------------------------------------------------
GetNumber:
  PUSH BX           ;Save used registers
  MOV  BX,AX        ;Save original AX
  CALL IsSpaceOrEOL ;Skip past spaces
  JZ  >N70          ;If End-of-Line, Error
  CALL TestForHex   ;Is it a Hex Number?
  JC  >N20          ;If not, try a decimal
  CALL Test0xPrefix ;Skip over the 0x (C-style) prefix, if there
  CALL GetHex       ;If so, get it
  JNC >N80          ;If OK, we're done
  JMP >N70          ;If not, Error
N20:                ;Not Hex
  CALL GetDecimal   ;Try a Decimal
  JNC >N80          ;If OK, we're done
N70:                ;Error
  MOV  AX,BX        ;Restore original AX
  STC               ;Set Error Flag
  JMP >N90          ;Done
N80:                ;OK
  CLC               ;Set OK Flag
N90:                ;Done
  POP  BX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII STRING TO SEE IF IT IS A HEX STRING (ENDS IN H)
;Inputs:  [SI] = String to test
;Outputs: CF = Clear if it is a Hex String
;            = Set if Error (not a Hex String)
;Changes:
;NOTES: A valid Hex String will contain numerals 0-9, A-F, and Underscores,
;         and will end in an H.  It cannot contain spaces.
;------------------------------------------------------------------------------
TestForHex:
  PUSH AX,SI        ;Save used registers
  CALL Test0xPrefix ;Test for the 0x (C-style) prefix (changes SI)
  JNC >H80          ;If so, it's Hex
  CALL GetNextChar  ;Get the
  DEC  SI           ;  first character
  CALL IsHexNumber  ;A valid Hex Number?
  JC  >H70          ;If not, Error
H40:                ;Loop to here for each character
  CALL GetNextChar  ;Get the next character
  CALL IsHexNumber  ;A valid Hex Number?
  JNC  H40          ;If so, keep looking
  CMP  AL,'_'       ;An Underscore?
  JE   H40          ;If so, keep looking
  CALL IsHexEnd     ;End of the Hex Number?
  JZ  >H80          ;If so, we're done
H70:                ;Not Hex
  STC               ;Set error Flag
  JMP >H90          ;Done
H80:                ;Is Hex
  CLC               ;Set OK Flag
H90:                ;Done
  POP  SI,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST FOR A 0x (C-STYLE) HEX PREFIX
;Inputs:  [SI] = String to test
;Outputs: CF = Set if not a 0x Prefix
;              SI unchanged
;            = Clear if not a 0x Prefix
;              [SI] = Character after the 0x
;Changes:
;------------------------------------------------------------------------------
Test0xPrefix:
  PUSH AX,BX       ;Save used registers
  MOV  BX,SI       ;Save original Pointer
  CALL GetNextChar ;Get the next character
  CMP  AL,'0'      ;Is it a 0?
  JNE >X70         ;If not, it's not a Prefix
X20:               ;Loop to here to skip over all zeroes
  CALL GetNextChar ;Get the next charcter
  CMP  AL,'0'      ;Is it another 0?
  JE   X20         ;If so, keep skipping the zeroes
  CALL Capitalize  ;If not, capitalize it
  CMP  AL,'X'      ;Is it an X?
  JNE >X70         ;If not, it's not a 0x Prefix
  CALL GetNextChar ;Get the next charcter
  CALL IsHexNumber ;Is it a Hex Number?
  JNC >X80         ;If so, it's a 0x Prefix
X70:               ;Not a 0x Prefix
  MOV  SI,BX       ;Restore original pointer
  STC              ;Set return flag
  JMP >X90         ;Done
X80:               ;Is a 0x Prefix
  DEC  SI          ;Point back at the first hex number
  CLC              ;Set return flag
X90:               ;Done
  POP  BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT SERIES OF HEX CHARACTERS, AND CONVERT THEM TO A NUMBER
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK
;              AX = Character string converted to a number, ?? if not
;            = Set if Error
;              AX = Unchanged
;Changes:
;NOTES: The string can either have an H at the end or not, and this code
;         will work.
;------------------------------------------------------------------------------
GetHex:
  PUSH BX,CX,DX    ;Save used registers
  MOV  DX,AX       ;Save original AX
  XOR  BX,BX       ;Start with zero
  MOV  CX,4        ;CL = bits to shift by, CH = Character Counter
  XOR  AH,AH       ;Set High byte to 0
D10:               ;Loop to here for each character
  CALL GetNextChar ;Get the next character
  CALL IsHexNumber ;A valid Hex Number?
  JNC >D20         ;If so, continue
  CMP  AL,'_'      ;If not, is it an Underscore?
  JE  >D45         ;If so, keep looking
  JMP >D50         ;If not, we're done
D20:               ;Valid Hex Number
  INC  CH          ;Increment the character counter
  SHL  BX,CL       ;Make room for the New Nibble
  JNC >D40         ;If we're not too big yet, keep going
  DEC  SI          ;If too big, Point back at bad character
  JMP >D70         ;Error
D40:               ;OK to add in new Nibble
  ADD  BX,AX       ;Add in the new Nibble
D45:               ;Done with this character
  JMP  D10         ;Jump to get next character
D50:               ;Done getting string
  DEC  SI          ;Point back at the bad character
  OR   CH,CH       ;Any valid characters at all?
  JZ  >D70         ;If not, error
  CALL GetNextChar ;Is the next character
  CALL IsHexEnd    ;  an H?
  JZ  >D80         ;If so, we're done
  DEC  SI          ;If not, point back at the non-H
  JMP >D80         ;Done
D70:               ;There was an error
  MOV  AX,DX       ;Restore original AX
  STC              ;Mark the error flag
  JMP >D90         ;And quit
D80:               ;We have a good number
  MOV  AX,BX       ;Put the value where it belongs
  CLC              ;Mark the OK flag
D90:               ;We're done
  POP  DX,CX,BX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT SERIES OF NUMERIC CHARACTERS, AND CONVERT THEM TO A NUMBER
;Inputs:  [SI] = Command Line Pointer
;Outputs: AX = decimal character string converted to a number, ?? if not
;         CF = Clear if AX is OK
;            = Set if no decimal found
;Changes: SI points at character after the number
;------------------------------------------------------------------------------
GetDecimal:
  PUSH BX,CX,DX     ;Save used registers
  XOR  AX,AX        ;Start with zero
  XOR  BX,BX        ;  "    "    "   - accumulator
  MOV  CX,10        ;CX = multiplier & digit limit comparer
  CALL IsSpaceOrEOX ;Skip over the spaces
  JZ  >D70          ;If EOL, Error
  SUB  AL,'0'       ;If not, convert it to a number
  CMP  AL,9         ;Is it really a number?
  JA  >D70          ;If not, there's an error
  DEC  SI           ;If so, step back to the number
D10:                ;Loop to here for each character
  CALL GetNextChar  ;Get the next character
  SUB  AL,'0'       ;Change it to 0-9 range
  XOR  AH,AH        ;Extend byte to word
  CMP  AX,CX        ;Is it a digit?
  JAE >D80          ;If not, we're done
  CMP  BX,6553      ;Is our number getting too big?
  JB  >D20          ;If not, jump to store it
  CMP  AL,5         ;If so, will this number make it too big?
  JA  >D70          ;If so, there's an error
D20:                ;Add the digit to our number
  XCHG AX,BX        ;Swap accumulation into AX, new digit into BX
  MUL  CX           ;Multiply the previous accumulation by 10
  ADD  BX,AX        ;Add in the new digit
  JMP  D10          ;Jump to get next character
D70:                ;There was an error
  STC               ;Mark the error flag
  JMP >D90          ;And quit
D80:                ;We have a good number
  DEC  SI           ;Point back at the non-number
  MOV  AX,BX        ;Put the value where it belongs
  CLC               ;Mark the OK flag
D90:                ;We're done
  POP  DX,CX,BX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A HEX NUMERAL (BETWEEN 0 AND F)
;Inputs:  AL = ASCII Character to Test
;Outputs: CF = Clear if it is a Number
;              AL = ASCII Code converted to a real Number
;            = Set if Error (not a Number)
;              AL = Unchanged
;Changes:
;------------------------------------------------------------------------------
IsHexNumber:
  PUSH BX          ;Save used registers
  MOV  BL,AL       ;Save the character in case we need to restore it
  CALL IsNumber    ;A Decimal Number?
  JNC >H85         ;If so, we're done
  CALL Capitalize  ;If not, Capitalize it
  CMP  AL,'A'      ;A Hex Number?
  JB  >H70         ;If not, Error
  CMP  AL,'F'      ;A Hex Number?
  JBE >H80         ;If so, handle it
H70:               ;Not a Number
  MOV  AL,BL       ;Restore original character
  STC              ;Set Error Flag
  JMP >H90         ;Done
H80:               ;A Number > 9
  SUB  AL,('A'-10) ;Convert it to a real number
  JMP >H90         ;Done
H85:               ;OK (is a Number)
  CLC              ;Set OK Flag
H90:               ;Done
  POP  BX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A NUMERAL (BETWEEN 0 AND 9)
;Inputs:  AL = ASCII Character to Test
;Outputs: CF = Clear if it is a Number
;              AL = ASCII Code converted to a real Number
;            = Set if Error (not a Number)
;              AL = Unchanged
;Changes:
;------------------------------------------------------------------------------
IsNumber:
  CMP  AL,'0' ;A Number?
  JB  >N70    ;If not, Error
  CMP  AL,'9' ;A Number?
  JBE >N80    ;If so, handle it
N70:          ;Not a Number
  STC         ;Set Error Flag
  JMP >N90    ;Done
N80:          ;A number
  SUB  AL,'0' ;Convert it to a real number
  CLC         ;Set OK Flag
N90:          ;Done
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A PARTICULAR CHARACTER
;Inputs:  AL = ASCII Character to Test
;Outputs: ZF = Set if it is the appropriate character
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
IsHexEnd:
  PUSH AX         ;Save used registers
  CALL Capitalize ;Capitalize the Character
  CMP  AL,'H'     ;See if it matches
  POP  AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;REPLACE THE CARRIAGE RETURN AT THE END OF THE CMD LINE TAIL WITH A 0
;Inputs:  CS = DS = PSP Segment
;Outputs:
;Changes: Last Byte of Command Tail
;------------------------------------------------------------------------------
FixCmdLineCR:
  PUSH AX,CX,DI,ES   ;Save used registers
  MOV  AL,CR         ;Look for a CR
  MOV  CX,7Fh        ;Maximize Byte Counter
  MOV  ES,DS         ;Point ES:[DI]
  MOV  DI,81h        ;  at the Command Line Tail
  REPNE SCASB        ;Look for the CR
  MOV  B ES:[DI-1],0 ;Replace the CR with a 0
  POP  ES,DI,CX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT CHARACTER FROM THE ENVIRONMENT OR COMMAND LINE
;Inputs:  [SI] = Pointer (Command Line or Environment)
;Outputs: AL = The next character
;         ZF = Set if End-Of-Line (Character = ASCII 0)
;            = Clear if "real" character
;Changes: SI
;------------------------------------------------------------------------------
GetNextChar:
  PUSH DS                   ;Save used registers
  CMP  CmdLineVarPointer,-1 ;Need to use the CMDLINE Environment variable?
  JE  >N90                  ;If not, just do the "real" command line
  MOV  DS,[PSPEnvirSeg]     ;Point at the Environment Segment
N90:                        ;DS:[SI] points at the next character
  LODSB                     ;Get the character from the "real" command line
  OR   AL,AL                ;Set ZF if EOL
  POP  DS                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER SPACES TO FIND THE NEXT LEGITIMATE CHARACTER, TESTING FOR EOL
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: ZF = Set if EOL
;               AL  = Unchanged
;              [SI] = End-of-Line Character
;            = Clear if not EOL
;               AL  = First non-space character
;              [SI] = Character AFTER the next non-space character
;Changes:
;------------------------------------------------------------------------------
IsSpaceOrEOX:
  CALL IsSpaceOrEOL ;Skip over the spaces
  JZ  >X90          ;If end-of-line, we're done
  CALL GetNextChar  ;If not, get the next character
  OR   AL,AL        ;Set return flag
X90:                ;Done
  RET

;------------------------------------------------------------------------------
;SKIP OVER SPACES TO FIND LEGITIMATE CHARACTERS, AND TEST FOR EOL
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: ZF = Set if EOL
;            = Clear if legitimate character
;              [SI] = The Next non-Space Character
;Changes:
;------------------------------------------------------------------------------
IsSpaceOrEOL:
  PUSH AX          ;Save used registers
L10:               ;Loop to here to skip over spaces
  CALL GetNextChar ;Get the next character
  CMP  AL,' '      ;Is it a space?
  JE   L10         ;If so, get the next character
  CMP  AL,Tab      ;Is it a Tab?
  JE   L10         ;If so, get the next character
  DEC  SI          ;If not, point back at the character
  OR   AL,AL       ;Set EOL flag
  POP  AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A CODE WORD FROM THE COMMAND LINE TO A WORD FROM THE LOOKUP TABLE
;Inputs:  DS:[SI] = Command Line Pointer
;         DS:[BX] = List to Test
;Outputs: CF = Clear if a match was found
;              AL = Entry from Table
;              [SI] = Next character after the Code Match
;         CF = Set if no match found (error)
;              AL = Unchanged
;              SI = Unchanged
;Changes: SI if valid match found
;------------------------------------------------------------------------------
GetCode:
  PUSH BX,DX         ;Save used registers
  MOV  DX,AX         ;Save AX in case there's no match
C10:                 ;Loop to here for each list of words
  CMP  B [BX],0      ;Are we at the end of our table?
  JE  >C80           ;If so, we couldn't find a match
  XOR  AH,AH         ;Assume it's a match
  PUSH SI            ;Save our command line pointer for a second
C20:                 ;Loop to here for each character in a word
  CALL GetNextChar   ;Get the next character
  CALL Capitalize    ;Capitalize it
  CALL CmpALBXNoCase ;Is it a match?
  JZ  >C30           ;If so, handle it
  INC  AH            ;If not, mark us as no match
C30:                 ;The character is tested
  INC  BX            ;Point at the next character in our test word
  CMP  B [BX],0      ;Are we at the end of the word?
  JNE  C20           ;If not, keep going until we're done
  INC  BX            ;Point at the next word or code list
  OR   AH,AH         ;Was it a match?
  JZ  >C50           ;If so, jump to handle it
  POP  SI            ;If not, restore our command line pointer
  CMP  B [BX],0      ;Is this the end of our word list?
  JNE  C10           ;If not, just test the next word
  INC  BX,2          ;If so, skip over the codes
  JMP  C10           ;Keep going until we're done with our list
C50:                 ;We've found a match!
  POP  AX            ;Lose our original command line pointer
  DEC  BX            ;Point back at the end-of-word marker
C60:                 ;Loop to here to find the end-of-list
  MOV  AX,[BX]       ;Get the next two characters in our list
  INC  BX            ;Point at the next character for next time
  OR   AX,AX         ;Is this the start of our code list?
  JNE  C60           ;If not, keep looking
  INC  BX            ;If so, point at the character we're looking for
  MOV  DL,[BX]       ;Get the character from the Table
  CLC                ;Mark our OK flag
  JMP >C90           ;And we're done
C80:                 ;No match found
  STC                ;Mark us as no match
C90:                 ;We're done
  MOV  AX,DX         ;Set AX to the correct value
  POP  DX,BX         ;Restore used registers
  RET

CmpALBXNoCase:
  PUSH AX         ;Save used registers
  CALL Capitalize ;Capitalize AL
  MOV  AH,AL      ;Store it in AH
  MOV  AL,[BX]    ;Get [BX]
  CALL Capitalize ;Capitalize it
  CMP  AL,AH      ;Compare AL & [BX]
  POP  AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CAPITALIZE A CHARACTER (Byte)
;Inputs:  AL = character to be capitalized
;Outputs: AL = capitalized character
;Changes:
;------------------------------------------------------------------------------
Capitalize:
  CMP  AL,'a'     ;Is it less than 'a'?
  JB  >C90        ;If so, quit
  CMP  AL,'z'     ;Is it more than 'z'?
  JA  >C90        ;If so, quit
  SUB  AL,'a'-'A' ;If between 'a' and 'z', capitalize it
C90:
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE THE TELL THE USER WHERE THE COMMAND LINE ERROR OCCURRED
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;WRITE THE COMMAND LINE OR ENVIRONMENT ERROR INFORMATION TO THE SCREEN
;Inputs:  [SI] = Command line Pointer (if Command Line)
;              = StdIn Buffer Pointer (if StdIn String)
;              = Environment Pointer (if Environment Variable)
;         DoEnvir, DoStdIn
;Outputs:
;Changes: Writes information to screen
;------------------------------------------------------------------------------
WriteCmdErr:
  PUSHA                   ;Save all registers
  CALL FindBadChar        ;Find the actual bad character in the string (SI)
  CALL SetupCmdErrStrings ;Set up the String Pointers and Sizes
                          ;DI:[AX] = Command Line String
                          ;DS:[BX] = Program name at beginning of String
                          ;    CX  = Size of BX String
                          ;DS:[DX] = Header String
                          ;DS:[BP] = Footer String
  CALL WriteZErr          ;Write the Header
  CALL WriteCrLfErr       ;Move
  CALL WriteCrLfErr       ;  down
  SUB  SI,AX              ;Calculate the number
  ADD  CX,SI              ;  of spaces
  DEC  CX                 ;  to write
  CALL WriteCmdString     ;Write the Command-line String (may modify CX)
  CALL WriteCrLfErr       ;Move down
  MOV  B SingleMsg[0],' ' ;Want to write spaces
  MOV  DX,SingleMsg       ;Point at the string
E60:                      ;Loop to here to write each space (number in CX)
  CALL WriteZErr          ;Write the space
  LOOP E60                ;Keep writing them until we're done
  MOV  DX,ParseErrMsg     ;Write the Pointer Part
  CALL WriteZErr          ;  of the Error Message
  MOV  DX,BP              ;Write the last part
  CALL WriteZErr          ;  of the message
  POPA                    ;Restore all registers
  RET

;------------------------------------------------------------------------------
;GO BACKWARDS IN AN ERRORED OPTION STRING TO INDICATE TO USER WHERE ERROR WAS
;Inputs:  SI = Option String Pointer (Environment, StdIn, or Command Line)
;                where error was found
;Outputs: SI = Options String Pointer, adjusted to point at a "Real" character
;Changes:
;------------------------------------------------------------------------------
FindBadChar:
  PUSH AX          ;Save used registers
  DEC  SI          ;Go back 1 character to start
B10:               ;Loop to here to find a legitimate character
  CALL GetNextChar ;Get the character
  JZ  >B40         ;If end-of-line, keep going back
  CMP  AL,' '      ;Is it a space?
  JNE >B90         ;If not, we're done
B40:               ;Need to keep going back
  SUB  SI,2        ;Go back to the previous character
  JMP  B10         ;Keep looking
B90:               ;Done
  POP  AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SET UP THE STRING POINTERS AND SIZES TO BE ABLE TO WRITE THE COMMAND ERROR
;Inputs:  DS = Local Data Area
;Outputs: DI:[AX] = Command-line String to write
;         DS:[DX] = First Error Message (Header) to write
;         DS:[BX] = Second message to write (first part of Command string)
;             CX  = Number of Bytes to add to String Size
;         DS:[BP] = Third message to write (Footer)
;Changes:
;------------------------------------------------------------------------------
SetupCmdErrStrings:
  MOV  AX,81h          ;DI:[AX] =
  MOV  DI,DS           ;  Command-line Tail
  MOV  BX,RealName     ;DS:[BX] = Program Name
  MOV  CX,RealNameSz   ;CX = Size of [BX] String
  MOV  DX,ParseCmdMsg  ;DS:[DX] = Header String
  MOV  BP,ParseErrMsg2 ;DS:[BP] = Footer String
  RET

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF THE COMMAND STRING, WITH MORE MESSAGES AS NEEDED
;Inputs:  CS = DS = Local Data Area
;         DS:[BX] = First String to write (may not be needed!)
;         DI:[AX] = Second String (main part) to write
;             CX  = Number of Spaces to write at beginning (if normal)
;Outputs: CX = Adjusted number of spaces to write
;Changes:
;------------------------------------------------------------------------------
WriteCmdString:
  PUSH AX,BX,DX,DI,SI      ;Save used registers
  PUSH BP,DS,ES            ;Save used registers
  MOV  BP,CX               ;Save the original Space Counter in BP
  MOV  ES,DI               ;Save the second string Pointer
  MOV  SI,AX               ;  in ES:[SI]
  MOV  DX,BX               ;Save the length
  CALL CalcStrSizeDX       ;  of the first string
  MOV  DI,CX               ;  in DI
  MOV  DS,ES               ;Save the length
  CALL CalcStrSizeSI       ;  of the second string
  MOV  AX,CX               ;  in AX
  CMP  BP,70               ;Are there too many spaces to fit on one line?
  JBE >G20                 ;If not, continue
G10:                       ;Need to lop off the beginning
  SUB  BP,DI               ;We will not be
  XOR  DI,DI               ;  writing the
  MOV  BX,NoMsg            ;  first string
  CMP  BP,70               ;Are there still too many spaces to fit?
  JBE >G20                 ;If not, continue
  MOV  BX,MoreLeftMsg      ;Point at the More Message
  ADD  BP,MoreMsgSize      ;Compensate number of spaces for More Message
  MOV  DI,60               ;We want the number of spaces to be 60
  SUB  DI,BP               ;Calculate how far into the Second string
  NEG  DI                  ;  we need to start to accomplish that
  MOV  BP,59               ;BP = New Number of Spaces
  ADD  SI,DI               ;  where we need to start writing
  SUB  AX,DI               ;  of second string
  MOV  DI,MoreMsgSize      ;DI = Size of new first string (More Message)
G20:                       ;Beginning of line is accounted for
  MOV  DS,CS               ;Write the
  MOV  DX,BX               ;  first
  CALL WriteZErr           ;  string
  MOV  DS,ES               ;Point DS:[DX] at the
  MOV  DX,SI               ;  second string
  ADD  DI,AX               ;Calculate total length of both strings
  CMP  DI,79               ;Will it fit on one line?
  JBE >G40                 ;If so, continue
  MOV  BX,(80-MoreMsgSize) ;Calculate how many characters
  SUB  BX,DI               ;  of the second string
  ADD  BX,AX               ;  we need to write
  MOV  AL,[SI+BX]          ;Save the old character in the string
  MOV  B [SI+BX],0         ;Convert it to an end-of-string character
  CALL WriteZErr           ;Write the truncated string
  MOV  [SI+BX],AL          ;Restore the original character of the string
  MOV  DS,CS               ;Write the
  MOV  DX,MoreRightMsg     ;  More Message
G40:                       ;Write last message
  CALL WriteZErr           ;Write it
G90:                       ;Done
  MOV  CX,BP               ;Return CX = number of spaces to write
  POP  ES,DS,BP            ;Restore used registers
  POP  SI,DI,DX,BX,AX      ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;MISCELLANEOUS COMMAND-LINE RELATED STUFF
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;GET OUR REAL PROGRAM NAME
;Inputs:
;Outputs: RealName, RealNameSz
;Changes:
;------------------------------------------------------------------------------
GetRealName:
  PUSH AX,CX,DI,SI      ;Save used registers
  PUSH DS,ES            ;Save used registers
  MOV  DS,[PSPEnvirSeg] ;Point DS and ES
  MOV  ES,DS            ;  at the environment segment
  XOR  DI,DI            ;Point at the beginning of Environment variable list
  MOV  CX,-1            ;Max out the count limiter
  XOR  AX,AX            ;Need to look for a double 0
N10:                    ;Loop to here to skip over environment variables
  REPNE SCASB           ;Look for the end of this environment variable
  CMP  B [DI],0         ;Is it the end of the variable list (double zero)?
  JNE  N10              ;If not, keep skipping over environment variables
  CMP  W [DI+1],0       ;If so, is there at least one string after the env?
  JE  >N90              ;If not, we're done
  LEA  SI,[DI+3]        ;If so, point DS:[SI] at the True Name
  MOV  ES,CS            ;Point ES (for ES:[DI]) at our local data
N20:                    ;Loop to here to skip over drive/path info
  MOV  DI,RealName      ;Point at the beginning of our data area
  XOR  CX,CX            ;Start the length counter at 0
N30:                    ;Loop to here for each character in the name
  LODSB                 ;Get the next character of the name
  CMP  AL,'.'           ;Is it a dot?
  JE  >N40              ;If so, we may have the name
  CMP  AL,BackSlash     ;Is it a path separator?
  JE   N20              ;If so, start looking for the name again
  CALL Capitalize       ;If part of a name, capitalize the character
  STOSB                 ;Store it in our data area
  INC  CX               ;Increment the size counter
  JMP  N30              ;And keep looking for more characters
N40:                    ;We may have the name
  LODSB                 ;Get the next character of the name
  OR   AL,AL            ;End of the name?
  JZ  >N50              ;If so, it really was our program name
  CMP  AL,BackSlash     ;Was it a Directory with a dotted name?
  JE   N20              ;If so, keep looking for a file name
  JMP  N40              ;If not, keep looking for the end of the name
N50:                    ;Have the name
  XOR  AL,AL            ;Store
  STOSB                 ;  a 0
  MOV  CS:RealNameSz,CX ;Store the Size
N90:                    ;We're done
  POP  ES,DS            ;Restore used registers
  POP  SI,DI,CX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE POINTERS TO THE ENVIRONMENT VARIABLES WE NEED
;Inputs:  CS = DS = Local Data Area (also PSP Data Area)
;Outputs: Various Environment Pointers
;Changes:
;------------------------------------------------------------------------------
GetEnvVars:
  PUSH BX,CX,SI                    ;Save used registers
  MOV  SI,PathVarString1           ;Get
  MOV  BX,OFFSET PathVarPointer    ;  the
  MOV  CX,PathVarSize              ;  PATH
  CALL GetEnvVarPointer            ;  Pointer
  JNZ >V20                         ;If OK, continue
  MOV  SI,PathVarString2           ;If no, try
  CALL GetEnvVarPointer            ;  "Path" instead of "PATH"
V20:                               ;Got PATH variable
  CMP  B [80h],7Eh                 ;Is command line size maxed out?
  JB  >V90                         ;If not, don't worry about CMDLINE Env Var
  MOV  SI,CmdLineVarString         ;Get
  MOV  BX,OFFSET CmdLineVarPointer ;  the
  MOV  CX,CmdLineVarSize           ;  CMDLINE
  CALL GetEnvVarPointer            ;  Pointer
  CALL AdjustCmdLine               ;Compensate CMDLINE Pointer for Program Name
V90:                               ;Done
  POP  SI,CX,BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE POINTER TO AN ENVIRONMENT VARIABLE
;Inputs:   CS = DS = Local Data Area (also contains PSP)
;         [BX] = Where to store the Pointer at
;          CX  = Length of String
;         [SI] = Environment Variable String to Look for (ends in =)
;Outputs: ZF = Set if Error (Variable not found)
;               [BX] = -1
;             = Clear if OK (variable was found)
;               [BX] = Pointer to String (in Environment Segment, NOT PSP!!)
;Changes:
;------------------------------------------------------------------------------
GetEnvVarPointer:
  PUSH AX,CX,SI,BP      ;Save used registers
  PUSH DS,ES            ;Save used registers
  MOV  W [BX],-1        ;Default = -1 (does not exist)
  MOV  ES,[PSPEnvirSeg] ;ES:[DI] =
  XOR  DI,DI            ;  Environment Variable List
  MOV  DX,CX            ;Save the Size
  MOV  BP,SI            ;Save the original Pointer
  XOR  AL,AL            ;Need to look for 0's
V10:                    ;Loop to here for each Environment variable
  MOV  CX,DX            ;CX = Number of bytes to test
  MOV  SI,BP            ;DS:[SI] = String to Test for
  REPE CMPSB            ;Is it a match?
  JZ   >V30             ;If so, continue
  MOV  CX,-1            ;Max out the count limiter
  REPNE SCASB           ;Look for the end of this environment variable
  CMP  B ES:[DI],AL     ;End of Environment?
  JNE  V10              ;If not, keep looking
  JMP >V90              ;If so, no variable
V30:                    ;Found it!
  MOV  [BX],DI          ;Store the Pointer
V90:                    ;Done
  CMP  W [BX],-1        ;Set return flag
  POP  ES,DS            ;Restore used registers
  POP  BP,SI,CX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADJUST THE CMDLINE ENVIRONMENT VARIABLE POINT TO POINT AT THE COMMAND TAIL
;Inputs:  DS = Local Data Area (and PSP Segment)
;         CmdLineVarPtr (-1 if does not exist)
;           Unadjusted for Program Path/Name
;Outputs: CmdLineVarPtr
;           Adjusted (Program Path/Name skipped over to leave Command Tail)
;Changes:
;NOTES: The CMDLINE environment variable, which is only set by SOME
;         versions of DOS, contains the entire contents of the command
;         line.  The "entire contents" includes our executable file name
;         (including the path, if it was provided), but does not include
;         the redirection and/or piping parameters.
;       This routine skips over the executable file name part and simply
;         points at the command tail (the "Options" part of the command line).
;       The CMDLINE variable is used by some versions of DOS (such as 4DOS/NDOS
;         and DOS 95) to allow the command-line to be longer than the 126
;         characters normally allowed by DOS.
;------------------------------------------------------------------------------
AdjustCmdLine:
  PUSH AX,DX,SI,DS             ;Save used registers
  MOV  SI,CmdLineVarPointer    ;[SI] = CMDLINE environment variable contents
  CMP  SI,-1                   ;Anything there?
  JE  >J90                     ;If not, no need for changes
  MOV  DL,"/"                  ;Assume Get SwitchChar function is unsupported
  MOV  AX,3700h                ;Function 3700h (Get DOS SwitchChar)
  INT  21h                     ;Do it (returns DL)
  MOV  DS,[PSPEnvirSeg]        ;DS:[SI] = CMDLINE contents
J10:                           ;Loop to here to skip initial spaces & tabs
  LODSB                        ;Get the next character
  CMP  AL,' '                  ;Space?
  JE   J10                     ;If so, keep skipping
  CMP  AL,Tab                  ;Tab?
  JE   J10                     ;If so, keep skipping
J20:                           ;Skipped initial Tabs & Spaces
  DEC  SI                      ;Point back at the first character
  XOR  AH,AH                   ;Assume no quotes
  CMP  AL,Quote2               ;Double Quote (part of LFN Path & File Name)?
  JNE >J30                     ;If not, continue
  MOV  AH,AL                   ;If so, mark as a quote
  INC  SI                      ;Update the Pointer
J30:                           ;Loop to here for each character
  LODSB                        ;Get next character
  OR   AH,AH                   ;Are we looking for a Quoted Path/File Name?
  JZ  >J40                     ;If not, continue
J35:                           ;Looking for the Closing Quote
  CMP  AL,AH                   ;Is it the Closing Quote?
  JNE >J50                     ;If not, keep looking
  JMP >J85                     ;If so, we're done
J40:                           ;Not a Quoted Path/File Name
  OR   AL,AL                   ;End of variable?
  JE  >J80                     ;If so, handle it
  CMP  AL,' '                  ;Space?
  JE  >J80                     ;If so, we're done
  CMP  AL,Tab                  ;Tab?
  JE  >J80                     ;If so, we're done
  CMP  AL,'/'                  ;Slash?
  JE  >J80                     ;If so, we're done
  CMP  AL,DL                   ;SwitchChar?
  JE  >J80                     ;If so, we're done
J50:                           ;Not end-of-name
  JMP  J30                     ;Keep looking
J80:                           ;[SI-1] = CMDLINE Pointer
  DEC  SI                      ;Point at beginning of string
J85:                           ;[SI] = New CMDLINE Pointer
  MOV  CS:CmdLineVarPointer,SI ;Store it
J90:                           ;Done
  POP  DS,SI,DX,AX             ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO GET "SPECIAL" VALUES FROM THE COMMAND-LINE (INDENTS, ADDRESSES, ETC.)
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;GET THE CALL BACK ADDRESSES FROM THE COMMAND-LINE, IF THERE
;Inputs:  [SI] = Command-Line Pointer
;         CallBackAddr  = -1
;         CallBackAddr2 = -1
;         ParentIsShell
;Outputs: CF = Clear if OK (got a valid Addresses)
;                CallBackAddr(2) = Address (converted to a number) if
;                                    ParentShell = No
;            = Set if Error (invalid address format)
;                CallBackAddr(2) = -1 in Offset if none or invalid addresses,
;                                    or ParentIsShell = Yes,
;                                    or anything follows the addresses
;Changes: SI
;------------------------------------------------------------------------------
GetCallBackAddrs:
  PUSH AX,BX,CX,DX,DI,ES     ;Save used registers
  MOV  CX,SI                 ;Save original command-line pointer
  CMP  ParentIsShell,Yes     ;Are we being run from the command-line?
  JE  >C75                   ;If so, don't bother looking for a call-back addr
  CALL IsSpaceOrEOL          ;Skip over the spaces
  JZ  >C75                   ;If end-of-line, no Call-Back Address provided
  CALL GetSegmentOffset      ;Look for 1st Segment:Offset (returns CF, ES:BX)
  JC  >C75                   ;If none found, no call-back address provided
  MOV  DX,ES                 ;Save first call-back address
  MOV  DI,BX                 ;  in DX:DI
  CALL GetSegmentOffset      ;Look for 2nd Segment:Offset (returns CF, ES:BX)
  JC  >C70                   ;If none found, error
  CALL IsSpaceOrEOL          ;If valid, is there anything else following it?
  JNZ >C70                   ;If so, error
  MOV  W CallBackAddr2[0],BX ;If everything's OK, store the second Offset
  MOV  W CallBackAddr2[2],ES ;Store the second Segment
  MOV  W CallBackAddr[0],DI  ;Store the first Offset
  MOV  W CallBackAddr[2],DX  ;Store the first Segment
  JMP >C80                   ;Done
C70:                         ;Error
  MOV  ParseError,Yes        ;Mark as an Error
C75:                         ;No Address/Invalid format
  MOV  SI,CX                 ;Restore original command-line pointer
  STC                        ;Set error flag
  JMP >C90                   ;Done
C80:                         ;OK
  CLC                        ;Set OK flag
C90:                         ;Done
  POP  ES,DI,DX,CX,BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT SERIES OF CHARACTERS, AND CONVERT THEM TO A SEGMENT:OFFSET
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK
;              ES:BX = Segment:Offset string converted to numbers
;            = Set if Error
;              ES:BX Unchanged
;Changes:
;------------------------------------------------------------------------------
GetSegmentOffset:
  PUSH AX,CX,DX     ;Save used registers
  MOV  CX,ES        ;Save original ES
  MOV  DX,BX        ;Save original BX
  CALL IsSpaceOrEOL ;Skip past the spaces
  JZ  >O70          ;If End of Line, Error
  CALL GetHex       ;Get the Segment
  JC  >O70          ;If error, quit
  MOV  ES,AX        ;If OK, store the Segment
  CALL IsSpaceOrEOX ;Skip over spaces
  JZ  >O70          ;If End of Line, Error
  CMP  AL,':'       ;Is it a Colon?
  JNZ >O70          ;If not, error
  CALL IsSpaceOrEOL ;Skip past the spaces
  JZ  >O70          ;If End of Line, Error
  CALL GetHex       ;Get the Offset
  JC  >O70          ;If error, quit
  MOV  BX,AX        ;If OK, store the Offset
  JMP >O80          ;Done
O70:                ;Error
  MOV  ES,CX        ;Restore original ES
  MOV  BX,DX        ;Restore original BX
  STC               ;Set error flag
  JMP >O90          ;Done
O80:                ;OK
  CLC               ;Set OK flag
O90:                ;Done
  POP  DX,CX,AX     ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO WRITE SPECIAL MESSAGES TO THE SCREEN (HELP, STATUS, ETC.)
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯
;Write Program Help Message
;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯

;------------------------------------------------------------------------------
;PRINT THE SYNTAX HELP MESSAGE AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;Outputs: Writes Help Message to the screen
;Changes: Quits program
;------------------------------------------------------------------------------
DoHelp:
  TEST ProgFlags,Help  ;Does the user want help?
  JZ  >H90             ;If not, we're done
  MOV  DX,SyntaxMsgHdr ;Write the first part
  CALL WriteItDX       ;  of the Help Message
  MOV  DX,RealName     ;Write the
  CALL WriteItDX       ;  Real Program Name
  CALL WriteSpace      ;Write a space
  MOV  DX,SyntaxMsg    ;Point at the last part of the Help Message
  XOR  AL,AL           ;ErrorLevel = 0
  JMP  Exit            ;Quit
H90:                   ;No need to do help
  RET


;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯
;Write Command-Line Aliases
;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯

;------------------------------------------------------------------------------
;PRINT THE COMMAND LINE ALIASES AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;Outputs: Writes Aliases to the screen
;Changes: Quits program
;------------------------------------------------------------------------------
DoAliases:
  TEST ProgFlags,Alias    ;Does user want to see the Aliases?
  JZ  >A95                ;If not, we're done
  PUSH BX,DX,SI           ;Save used registers
  CALL WriteCrLfPause     ;Move down
  MOV  DX,AliasHdrMsg     ;Set up
  CALL WriteHeader0       ;  the Header
  MOV  SI,SwitchList      ;Point at Tbl of Aliases
  MOV  BX,'?'+('Z' SHL 8) ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNoNum   ;Write the Aliases
  MOV  BX,1+(31 SHL 8)    ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNoNum   ;Write the Aliases
A90:                      ;Done
  POP  SI,DX,BX           ;Restore used registers
  MOV  DX,NoMsg           ;Don't write anything
  XOR  AL,AL              ;ErrorLevel = 0
  JMP  Exit               ;Quit
A95:                      ;No need to write Aliases
  RET

;------------------------------------------------------------------------------
;WRITE THE LIST OF SWITCH CHARACTERS TO THE SCREEN
;Inputs:  DS = ES = Local Data Area
;         BL = Minimum Value to look for in the Table
;         DH = Maximum Value to look for in the Table
;         SI = Switch List ("Code Word") Table
;Outputs: Writes List of Switch Characters to the Screen
;Changes:
;NOTES:   Sets CH =  0 if we write Blocks for Switches < " "
;                 = -1 if we write numbers for the all Switches (0-255)
;                 = -2 if we subtract 128 from the numbers (128-255)
;------------------------------------------------------------------------------
;DoAliasesGoNum80h:
;  PUSH CX               ;Save used registers
;  MOV  CH,2             ;Mark as writing Numbers, needing to subtract 128
;  JMP >G00              ;Continue
;DoAliasesGoNum:
;  PUSH CX               ;Save used registers
;  MOV  CH,1             ;Mark as writing Numbers, not needing to modify
;  JMP >G00              ;Continue
DoAliasesGoNoNum:
  PUSH CX               ;Save used registers
  XOR  CH,CH            ;Mark as not writing Numbers
;  JMP >G00              ;Continue
;G00:
  PUSH AX,DI            ;Save used registers
  MOV  DI,AliasSortTbl  ;Point at the Alias Sort Table
  MOV  AL,BL            ;Start with the Lower Limit
G10:                    ;Loop to here for each Alias
  CALL GetAliasPointers ;Get the Alias Pointers
  JZ  >G60              ;If none for this entry, go to the next one
G20:                    ;Have at least one valid Alias
  CALL WriteCrLfPause   ;If valid, move down
  OR   CH,CH            ;Writing Single characters?
  JNZ >G40              ;If not, handle full numbers
  MOV  CL,78            ;Write this many characters per line
  CMP  AL,' '           ;Is there a valid single-character equivalent?
  JB  >G30              ;If not, don't write it
  CALL WriteAL          ;If so, write it
  JMP >G50              ;Continue
G30:                    ;Not a writable character
  CALL WriteBlock       ;Write a Block Character
  JMP >G50              ;Continue
G40:                    ;Need to write Numbers
  MOV  CL,76            ;Write this many characters per line
  PUSH AX               ;Save the number for a second
  CMP  CH,2             ;Do we need to modify the Number?
  JNE >G45              ;If not, continue
  AND  AL,(NOT 80h)     ;Subtract 128 from it
G45:                    ;Write the Number
  CALL ByteToString     ;Write the Switch as a Number
  POP  AX               ;Restore the Number
G50:                    ;Done writing single character
  CALL WriteAliases     ;Write the Alias List
G60:                    ;Done with this Code
  CMP  AL,BH            ;Have we done the whole list yet?
  JE  >G90              ;If so, we're done
  INC  AL               ;If not, go to the next possibility
  JMP  G10              ;Keep going until we're done
G90:                    ;Done
  POP  DI,AX            ;Restore used registers
  POP  CX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET STRING POINTERS FOR ALL ALIASES FOR A SINGLE CHARACTER OPTION
;Inputs:   DS = ES = Local Data Area
;          AL  = Switch Table entry to look for (not 0)
;         [SI] = Switch Table to look through, sorted backwards
;         [DI] = Alias Sort Table
;Outputs:  ZF = Clear if OK
;               [DI] = Filled with String Pointers, sorted backwards
;                      Last Entry is always a 0
;             = Set if no matches found
;                      First Entry is 0
;Changes:
;------------------------------------------------------------------------------
GetAliasPointers:
  PUSH AX,BX,CX,DX      ;Save used registers
  PUSH DI,SI            ;Save used registers
  MOV  CX,DI            ;Sve original pointer
P10:                    ;Loop to here for each Table Entry
  MOV  DX,SI            ;Save beginning Alias Pointer
P20:                    ;Loop to here to find the end of an Alias List Entry
  CMP  B [SI],0         ;End of Alias List?
  JE  >P30              ;If so, handle it
  CALL SkipOverStringSI ;If not, skip over the string
  JMP  P20              ;Keep looking
P30:                    ;End of Alias List Entry
  MOV  BX,SI            ;Save End-of-Entry Pointer
  CMP  AL,[SI+1]        ;Is this entry a match?
  JNE >P50              ;If not, go to the next one
  MOV  SI,DX            ;Point at Alias String
P40:                    ;Loop to here for each Alias String
  CMP  B [SI],0         ;End of the entry?
  JE  >P50              ;If so, we're done
  MOV  [DI],SI          ;If not, store it in the sort table
  INC  DI,2             ;Update the Table Pointer
  CALL SkipOverStringSI ;Skip over the string
  JMP  P40              ;Keep going until we have all of the strings
P50:                    ;Done with this entry
  MOV  SI,BX            ;Get End-of-Entry Pointer
  INC  SI,2             ;Skip over End-of-Entry stuff
  CMP  B [SI],0         ;End of Table?
  JNE  P10              ;If not, keep looking
P90:                    ;Done
  MOV  W [DI],0         ;Make sure last entry is a 0
  CMP  CX,DI            ;Set return flag
  POP  SI,DI            ;Restore used registers
  POP  DX,CX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ALL ALIAS STRINGS FOR A SINGLE CHARACTER OPTION
;Inputs:   DS = ES = Local Data Area
;         [DI] = Alias String Pointer Table (Sorted backwards)
;                  Last Entry is a 0
;          CL  = Number of characters left available to write on first line
;                 (76 if Writing Numbers, 78 if Writing Characters)
;         CLD already issued
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteAliases:
  PUSHA               ;Save all registers
  PUSH ES             ;Save used registers
  MOV  ES,DS          ;Point ES at the Local Data Area
  MOV  BL,CL          ;BL = Character Countdown Measurer
  MOV  BH,CL          ;BH = Original Counter
  MOV  DX,DI          ;Save start-of-table Pointer
  MOV  CX,-1          ;Maximize counter
  XOR  AX,AX          ;Find the last
  REPNE SCASW         ;  entry in
  SUB  DI,4           ;  the Table
W10:                  ;Loop to here for each Alias String
  CMP  DI,DX          ;Are we done writing?
  JB  >W90            ;If so, quit
  MOV  SI,[DI]        ;Get the next string
  DEC  DI,2           ;Update the table pointer
  CALL CalcStrSizeSI  ;See how long the string is
  OR   BL,BL          ;Is the character counter down to 0?
  JZ  >W20            ;If so, we need to reset it
  CMP  CL,BL          ;Is this string too long to fit on this line?
  JB  >W40            ;If not, go ahead and write it
W20:                  ;Need to start a new line
  CALL WriteCrLfPause ;Start a new line
  PUSH CX             ;Save String Size for a second
  MOV  CL,79          ;Calculate how many
  SUB  CL,BH          ;  spaces to write
  CALL WriteSpaces    ;Write the spaces
  POP  CX             ;Restore String Size
  MOV  BL,BH          ;Reset the character counter
W40:                  ;Write the Alias String
  SUB  BL,CL          ;Update the
  DEC  BL             ;  character counter
  CALL WriteSpace     ;Write a Space
  CALL WriteItSI      ;Write the string
  JMP  W10            ;Keep writing
W90:                  ;Done
  CALL WriteCrLfPause ;Move down
  POP  ES             ;Restore used registers
  POPA                ;Restore all registers
  RET


;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯
;Write the ErrorLevel Table
;屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯

;------------------------------------------------------------------------------
;WRITE ERRORLEVEL TABLE TO THE SCREEN AND QUIT
;Inputs:  CS = DS = Local Data Area
;Outputs: Writes ErrorLevel Table to the Screen
;Changes: Quits Program
;         Several registers
;------------------------------------------------------------------------------
DoErrLvls:
  TEST ProgFlags,ErrLvl     ;Does the user want to see the ErrorLevels?
  JZ  >V95                  ;If not quit
  MOV  DX,ErrLvlHdr         ;Write the
  CALL WriteHeader0         ;  Table Header
  MOV  AL,1                 ;Start with ErrorLevel 1
V10:                        ;Loop to here for each table entry
  MOV  BX,ErrLvlTbl         ;Table to search
  CALL SearchByte2StringTbl ;Valid ErrorLevel?
  JC  >V50                  ;If not, keep looking
  CALL WriteSpace           ;Move Over
  CALL ByteToString         ;If valid, write the Number
  CALL WriteSpace           ;Write a space
  MOV  DX,BX                ;Write the
  CALL WriteItDX            ;  Description String
  CALL WriteCrLfPause       ;Write a New Line
V50:                        ;Done with this entry
  INC  AL                   ;Increment ErrorLevel
  JNZ  V10                  ;If not rolled over yet, keep looking
V90:                        ;Done
  MOV  DX,NoMsg             ;Don't write anything
  XOR  AL,AL                ;ErrorLevel = 0
  JMP  Exit                 ;Quit
V95:                        ;No need to write Aliases
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO WRITE VARIOUS THINGS (NUMBERS AND SUCH) TO THE SCREEN
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;WRITE A SPECIFIC CHARACTER OR SET OF CHARACTERS TO THE SCREEN
;Inputs:
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
WriteAL:
  PUSH DX              ;Save used registers
  MOV  DL,AL           ;Write what's in AL
  JMP >C00             ;Do it
WriteBlock:
  PUSH DX              ;Save used registers
  MOV  DL,''          ;Write a Block
  JMP >C00             ;Do it
WriteHexEnd:
  PUSH DX              ;Save used registers
  MOV  DL,'h'          ;Write an h
  JMP >C00             ;Do it
WritePercent:
  PUSH DX              ;Save used registers
  MOV  DL,'%'          ;Write a Period
  JMP >C00             ;Do it
WritePeriod:
  PUSH DX              ;Save used registers
  MOV  DL,'.'          ;Write a Period
  JMP >C00             ;Do it
Write2Spaces:
  PUSH DX              ;Save used registers
  MOV  DX,Space2Msg    ;Point at message
  JMP >C10             ;Do it
WriteSpace:
  PUSH DX              ;Save used registers
  MOV  DX,SpaceMsg     ;Point at message
  JMP >C10             ;Do it
C00:
  MOV  SingleMsg[0],DL ;Put the character in the Single Character String
  MOV  DX,SingleMsg    ;Point at Single Character String
C10:                   ;DX is pointed at String
  CALL WriteItDX       ;Write the String
  POP  DX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A STRING OF SPACES, DOTS, OR BLOCKS TO THE SCREEN
;Inputs:  CL = Number of characters to Write
;Outputs: Writes to the Screen
;Changes:
;------------------------------------------------------------------------------
WriteBlocks:
  PUSH BX             ;Save used registers
  MOV  BX,WriteBlock  ;BX = Code to Issue
  JMP >P00            ;Do it
WriteSpaces:
  PUSH BX             ;Save used registers
  MOV  BX,WriteSpace  ;BX = Code to Issue
;  JMP >P00            ;Do it
P00:
  PUSH CX             ;Save used registers
  OR   CL,CL          ;Write any spaces at all?
  JZ  >P90            ;If not, quit
  XOR  CH,CH          ;If so, convert byte to a word
P10:                  ;Loop to here for each space
  CALL BX             ;Write a character
  LOOP P10            ;Keep writing until we're done
P90:                  ;Done
  POP  CX             ;Restore used registers
  POP  BX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT BYTE, WORD, OR DWORD TO HEX CHARACTER STRING, AND WRITE IT
;Inputs:  AL/AX = Nibble/Byte/Word to be written
;         CLD must be set already!
;Outputs: Writes to the Screen
;Changes: HexString
;------------------------------------------------------------------------------
WriteNibbleHex:
  PUSH BX             ;Save used registers
  MOV  BX,8           ;Need to start of offset 8 in string
  JMP >H00            ;Jump to do it
WriteByteHex:
  PUSH BX             ;Save used registers
  MOV  BX,7           ;Need to start of offset 7 in string
  JMP >H00            ;Jump to do it
WriteWordHex:
  PUSH BX             ;Save used registers
  MOV  BX,5           ;Need to start of offset 5 in string
  JMP >H00            ;Jump to do it
WriteDWordHex:
  PUSH BX             ;Save used registers
  XOR  BX,BX          ;Need to start of offset 0 in string
;  JMP >H00            ;Jump to do it
H00:                  ;Start converting the strings
  PUSH DX,DI          ;Save used registers
  MOV  DI,HexString   ;Point DS:[DI] at HexString
  MOV  DX,DI          ;Point DS:[DX] at HexString
  ROR  EAX,16         ;Convert the High Word
  CALL Word2HexString ;  to a String
  INC  DI             ;Skip over the Underscore
  ROR  EAX,16         ;Convert the Low Word
  CALL Word2HexString ;  to a String
  ADD  DX,BX          ;Point DX at the beginning of where we write
  CALL WriteItDX      ;Write it
  POP  DI,DX          ;Restore used registers
  POP  BX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A BYTE OR WORD TO A HEXADECIMAL STRING (2 OR 4 CHARACTERS)
;Inputs:  AX = Word to Convert to a Hex String
;         DS = Local Data Area
;         CLD already issued
;Outputs: DS:[DI]
;Changes: DI
;------------------------------------------------------------------------------
Word2HexString:
  PUSH AX,BX,ES         ;Save used registers
  MOV  BX,AX            ;Save original Word
  MOV  ES,DS            ;Point ES:[DI] at
  CALL Word2HexString00 ;Convert it
  POP  ES,BX,AX         ;Restore used registers
  RET

Word2HexString00:
  MOV  AL,BH            ;Convert High Byte
  CALL Word2HexString10 ;  to ASCII
  MOV  AL,BL            ;Work with Low Byte
Word2HexString10:       ;Convert Byte to ASCII
  AAM  10h              ;Separate Low & High Nibbles
  XCHG AH,AL            ;Put High Nibble in AL
  CALL Word2HexString20 ;Convert High Nibble to ASCII
  XCHG AH,AL            ;Work with Low Nibble
Word2HexString20:       ;Convert Nibble to ASCII
  ADD  AL,90h           ;Convert BCD
  DAA                   ;  to Decimal
  ADC  AL,40h           ;Convert Decimal
  DAA                   ;  to ASCII
  STOSB                 ;Store the Nibble
  RET

;Byte2HexString:
;  PUSH AX,ES            ;Save used registers
;  MOV  ES,DS            ;Point ES:[DI] at the String
;  CALL Word2HexString10 ;Convert it
;  POP  ES,AX            ;Restore used registers
;  RET

;------------------------------------------------------------------------------
;WRITE A BYTE OR WORD TO THE SCREEN AS A DECIMAL (EXTRA SPACES INCLUDED)
;Inputs:  AL/AX = Byte/Word to Write
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteByteMin:
  PUSH AX,BX        ;Save used registers
  XOR  AH,AH        ;Make sure high byte is 0
  MOV  BH,1         ;Mark as doing minimum
  JMP >W00          ;Do it
WriteWordMin:
  PUSH AX,BX        ;Save used registers
  MOV  BH,1         ;Mark as doing minimum
  JMP >W00          ;Do it
ByteToString:
  PUSH AX,BX        ;Save the original word & BP
  XOR  AH,AH        ;Make sure high byte is 0
  XOR  BH,BH        ;BH = No Minimum, Byte
  JMP >W00          ;Jump to start the loop
WordToString:
  PUSH AX,BX        ;Save the original word
  MOV  BH,2         ;BP = No Minimum, Word
W00:                ;Do a word or a byte
  PUSH CX,DX,SI     ;Save used registers
  MOV  SI,SingleMsg ;Point at the single character message
  XOR  BL,BL        ;Test for first non-zero character is false
  MOV  CX,10000     ;First divisor is 10,000
W20:                ;Loop to here for each character
  XOR  DX,DX        ;High word of Dividend = 0
  DIV  CX           ;Divide DX:AX by current divisor
  OR   AX,AX        ;Is this a non-zero character?
  JNZ >W30          ;If so, we need to write it
  OR   BL,BL        ;Has there already been a non-zero character?
  JNZ >W30          ;If so, we need to write it
  CMP  CX,1         ;Is this the last character?
  JE  >W30          ;If so, we need to write it
  TEST BH,1         ;Are we doing a minimum?
  JNZ >W40          ;If not, don't write anything
  MOV  AL,' '       ;Assume a space
  TEST BH,2         ;Doing a word?
  JNZ >W35          ;If so, write the space
  CMP  CX,100       ;If not, doing the hundreds character?
  JBE >W35          ;If so, write the space
  JMP >W40          ;If not, don't write anything
W30:                ;We need to write this character
  INC  BL           ;Test for first non-zero character is true
  ADD  AL,'0'       ;Convert the Number to ASCII
W35:                ;Write the character
  MOV  [SI],AL      ;Write the
  CALL WriteItSI    ;  character
W40:                ;Skip this character - just make it a space
  CMP  CX,1         ;Was this the last division to do?
  JE  >W90          ;If so, we're done
  MOV  AX,DX        ;If not, start next loop with remainder of division
  PUSH AX           ;Save register for a second
  XOR  DX,DX        ;So dividend won't be messed up
  MOV  AX,CX        ;Want to divide divisor in CX
  MOV  CX,10        ;Want to divide by 10
  DIV  CX           ;Divide it
  MOV  CX,AX        ;Store it back in CX
  POP  AX           ;Restore register
  JMP  W20          ;And do it again
W90:                ;We're done
  POP  SI,DX,CX     ;Restore used registers
  POP  BX,AX        ;Restore original word & BP
  RET

;------------------------------------------------------------------------------
;WRITE ASCIIZ STRING TO CON OR TO ERR
;Inputs:  DS:[DX] = Pointer to string
;         CS = Local Data Area
;Outputs: Writes the string to CON or ERR
;Changes:
;------------------------------------------------------------------------------
WriteZCon:                  ;Write to CON
  CMP  CS:PauseHeaderPtr,-1 ;Should we write anything?
  JE  >Z90                  ;If not, just quit
  PUSH BX                   ;Save used register
  MOV  BX,StdOutHandle      ;Write to STDOUT
  JMP >Z00                  ;Jump to do it
WriteZErr:                  ;Write to ERR
  PUSH BX                   ;Save used register
  MOV  BX,StdErrHandle      ;Write to STDERR
Z00:
  PUSH AX,CX                ;Save used registers
  CALL CalcStrSizeDX        ;Calculate the size of the string (returns CX)
  JZ  >Z80                  ;If nothing to write, just quit
  MOV  AH,40h               ;Function 40h (Write to Device)
  INT  21h                  ;Do it
Z80:                        ;We're done
  POP  CX,AX                ;Restore used registers
  POP  BX                   ;Restore used register
Z90:                        ;We're done
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LENGTH OF AN ASCIIZ STRING
;Inputs:  DS:[DX] = Pointer to the string
;Outputs: CX = Length of the string
;         ZF = Set if string is 0 length
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
CalcStrSizeDX:
  PUSH AX,DI  ;Save used registers
  PUSH ES     ;Save used registers
  MOV  ES,DS  ;Point ES:[DI]
  MOV  DI,DX  ; at the string
  XOR  AL,AL  ;Look for a 0
  MOV  CX,-1  ;Start with max count for REPNE
  REPNE SCASB ;Find the end of the string
  NOT  CX     ;Calculate the size
  DEC  CX     ;  of the string (sets ZF)
  POP  ES     ;Restore used registers
  POP  DI,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEARCH A BYTE-TO-STRING LOOKUP TABLE FOR A MATCHING ENTRY
;Inputs:  DS:[BX] = Table to search
;         AL      = Byte to search for
;         CLD already issued
;Outputs: CF = Clear if a byte match as found in table
;              BX = Pointer to the String
;            = Set if no match found in table
;              BX = unchanged
;Changes:
;NOTES: Last Entry in Table (end-of-table marker) = DW -1
;------------------------------------------------------------------------------
SearchByte2StringTbl:
  PUSH AX,SI            ;Save used registers
  CLD                   ;Go forward with string functions
  MOV  SI,BX            ;Put pointer in SI
  MOV  AH,AL            ;Put byte to check in AH
S10:                    ;Loop to here for each table entry
  LODSB                 ;Get the next table entry
  CMP  AL,-1            ;Is it possibly the end of the table?
  JNE >S20              ;If not, continue
  CMP  B [SI],-1        ;Is it actually the end of the table?
  JE  >S70              ;If so, there's no match
S20:                    ;Not end of table
  CMP  AL,AH            ;Is it a match?
  JE  >S80              ;If so, handle it!
  CALL SkipOverStringSI ;If not, skip over the string
  JMP  S10              ;And keep looking
S70:                    ;No entry found
  STC                   ;Set the not found flag
  JMP >S90              ;Quit
S80:                    ;Entry found [SI]
  MOV  BX,SI            ;Point BX at the String
  CLC                   ;Set the found flag
S90:                    ;Done
  POP  SI,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP TO THE END OF AN ASCIIZ STRING
;Inputs:  DS:[SI] = ASCIIZ String to Skip Over
;Outputs: [SI]    = Next Byte After String
;Changes:
;------------------------------------------------------------------------------
SkipOverStringSI:
  PUSH CX,DX         ;Save used registers
  MOV  DX,SI         ;Calculate the size
  CALL CalcStrSizeDX ;  of the string (CX, does not include the Zero)
  INC  CX            ;Compensate for the Zero
  ADD  SI,CX         ;Add it to the Pointer
  POP  DX,CX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LENGTH OF AN ASCIIZ STRING
;Inputs:  DS:[SI] = ASCIIZ String to wrok with
;Outputs: CX = Length of String
;         ZF = Set if string is 0 length
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
CalcStrSizeSI:
  PUSH DX            ;Save used registers
  MOV  DX,SI         ;Calculate the
  CALL CalcStrSizeDX ;  length of the string
  POP  DX            ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO WRITE OUR OUTPUT, EITHER TO PAUSE OR TO THE USER-PROVIDED ADDRESS
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;WRITE AN ASCIIZ STRING, POINTED AT BY SI, TO PAUSE OR TO PROVIDED CALL-BACK
;Inputs:  DS:[SI] = ASCIIZ String to Write
;Outputs: To Pause or to user-provided Code Address
;Changes:
;------------------------------------------------------------------------------
WriteItSI:
  PUSH DX        ;Save used registers
  MOV  DX,SI     ;Write the
  CALL WriteItDX ;  string
  POP  DX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE OUR OUTPUT TO PAUSE, OR TO THE PROVIDED CALL-BACK ADDRESS
;Inputs:  DS:[DX] = ASCIIZ String to Write
;         CalloBackAddr (-1 in Offset if invalid)
;Outputs: Either to Pause, or to the call-back address
;Changes:
;------------------------------------------------------------------------------
WriteItDX:
  CMP  W CallBackAddr[0],-1 ;Is there a valid call-back address?
  JE  >W50                  ;If not, write to Pause
  CMP  ParentIsShell,Yes    ;Double-check whether we are at a command-line
                            ;  (we shouldn't need to do this, but will anyway)
  JE  >W50                  ;If so, write to Pause
  PUSH AX,BX,CX,DX,DI,SI    ;Save
  PUSH BP,DS,ES             ;  all registers
  CALL D CallBackAddr       ;If not, call the provided code address
  POP  ES,DS,BP             ;Restore
  POp  SI,DI,DX,CX,BX,AX    ;  all registers
  JMP >W90                  ;Done
W50:                        ;Write to Pause
  CALL WriteZPause          ;Write to Pause
W90:                        ;Done
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE NEEDED TO SET UP AND DO SCREEN PAUSES
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;SETUP PARAMETERS FOR DOING A SCREEN PAUSE (FOR PRINTING A LARGE TABLE)
;Inputs:  DS = Local Data Area
;         DS:[DX] = ASCIIZ Header to Print at top of each screen
;                   Last character of the Header MUST be an LF
;                   If SetupPauseNoHdr, we "inject" NoMsg as the Header
;Outputs: Pauses the screen with a MORE message every time it gets full
;NOTES:   If a Screen Header is really large (almost taking up the whole
;           screen itself, with little room for data), this procedure
;           may not work correctly.  This procedure does not validate
;           the size of the Header -- it simply assumes that it is a
;           "reasonable" size compared to the size of the screen.  Most
;           anything that needs a Screen Header (a long data table) will
;           only have a few lines of Header, so this should be OK as a
;           general purpose procedure.
;         After this Setup is complete (which should be near the beginning
;           of MAIN, before anything is sent to the screen), WriteZPause
;           must be called for ALL screen writing to CON:, not WriteZCon!
;         The Pausing occurs in "real time", meaning we can send things
;           to the Pause routine a byte, line, or several screens at a
;           time for processing.  Because we do it in "real time",
;           we can end up with extra MORE's and screen Headers appearing
;           on screen than are actually needed.  During a screen
;           transition (or a transition to a new Header) whether we
;           actually need to write anything or not depends on if there
;           is actually any real data coming afterward (in time), which
;           of course we don't know (since it hasn't happened yet).
;           So, we must assume there is more data to come and process the
;           MORE's and Screen Headers accordingly.  This only causes problems
;           (in the form of extraneous MORE's and Screen Headers)
;           when things happen near the bottom of the screen.
;           DOS's MORE utiltiy (and other programs of similar ilk) do not
;           process in "real time", but rather store things in a Temporary
;           File and then process the file.
;------------------------------------------------------------------------------
SetupPauseNoHdr:
  PUSH DX         ;Save used registers
  MOV  DX,NoMsg   ;Point at 0-length Message
  CALL SetupPause ;Setup the Pause
  POP  DX         ;Restore used registers
  RET

SetupPause:
  PUSH AX,BX,CX,DI,SI     ;Save used registers
  MOV  SI,OFFSET PauseHeaderPtr ;Point [SI] at PauseHeaderPtr
  CMP  W [SI],-1          ;Has the user already cancelled us?
  JE  >S90                ;If so, just quit
  CMP  W [SI],0           ;Has the user stopped pausing already?
  JE  >S85                ;If so, just write the header
  CALL TestRedir          ;Is our output redirected?
  JNC >S10                ;If not, setup our Headers
  MOV  W [SI],0           ;Mark as Redirected or Pausing Stopped/Disabled
  JMP >S85                ;Jump to write the Header and Quit
S10:                      ;Output not redirected
  CALL GetScreenRows      ;Store the number of rows
  MOV  PauseRows,AX       ;  on the screen
  CALL CountZLinesCX      ;Calculate the number of lines
  INC  CX,2               ;  in the new Header
  MOV  DI,PauseRowCount   ;Get the Current Row count
  ADD  DI,CX              ;Add the size of the new header
  SUB  DI,3               ;Adjust for Headers
  DEC  AX                 ;Will writing the new Header
  CMP  DI,AX              ;  cause a Pause event?
  JB  >S50                ;If not, handle it
S20:                      ;New Header is too big to fit on screen
  MOV  W [SI],NoMsg       ;Point Header for second page at nothing
  MOV  PauseHeaderSize,2  ;Set Pause Header Size
  PUSH CX                 ;Save New Header Size
  SUB  AX,PauseRowCount   ;Calculate how many rows to fill up the screen
  MOV  CX,AX              ;Put number of rows in CX
  INC  CX                 ;Adjust it
S30:                      ;Loop to here to fill up the screen
  CALL WriteCrLfPause     ;Write a new line
  LOOP S30                ;Keep going until we're done
  POP  CX                 ;Restore New Header Size
  CMP  W [SI],-1          ;Did the user cancel during the header transition?
  JE  >S90                ;If so, we're done
  CMP  W [SI],0           ;Did the user stop Pausing during the transition?
  JE  >S85                ;If so, just write the Header
S50:                      ;Need to adjust current Row Count
  SUB  PauseRowCount,2    ;Adjust things for the previous Header
S80:                      ;Store new Header Info
  MOV  [SI],DX            ;Store the Header Address
  MOV  PauseHeaderSize,CX ;Store the Header Size
  ADD  PauseRowCount,CX   ;Add the Header Size to the Row Count
  MOV  AX,PauseRows       ;Compensate if
  CMP  AX,PauseRowCount   ;  the new header
  JAE >S85                ;  put us past
  DEC  AX                 ;  the end
  MOV  PauseRowCount,AX   ;  of the screen
S85:                      ;Write Header
  CALL WriteZCon          ;Write the Header
S90:                      ;We're done
  POP  SI,DI,CX,BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHECK TO SEE IF STDOUT HAS BEEN REDIRECTED
;Inputs:
;Outputs: CF = Clear if STDOUT is normal (usually the screen)
;            = Set if STDOUT been redirected
;Changes:
;------------------------------------------------------------------------------
TestRedir:
  PUSH AX,BX,DX        ;Save used registers
  MOV  AX,4400h        ;Function 4400h (Get Device Info)
  MOV  BX,StdOutHandle ;Device = STDOUT
  INT  21h             ;Do it (returns DX, changes AX)
  JC  >R80             ;If error, assume not Redirected
  AND  DL,(DvcInfoIsDevice+DvcInfoIsStdOut) ;Mask out unwanted bits
  CMP  DL,(DvcInfoIsDevice+DvcInfoIsStdOut) ;Is it still the STDOUT Device?
  JE  >R80             ;If so, it's not Redirected
R70:                   ;STDOUT has been Redirected
  STC                  ;Set the Redirected flag
  JMP >R90             ;Done
R80:                   ;STDOUT is not Redirected
  CLC                  ;Set the Not-Redirected flag
R90:                   ;Done
  POP  DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NUMBER OF VIDEO ROWS ON THE SCREEN
;Inputs:
;Outputs: AX = Number of text rows on the screen
;                (usually 25, 43, or 50)
;Changes:
;------------------------------------------------------------------------------
GetScreenRows:
  PUSH BX,CX,DS  ;Save used registers
  MOV  AX,40h    ;Point ES to
  MOV  DS,AX     ;  BIOS data area
  MOV  AH,12h    ;Function 12h (EGA Alternate Select)
  MOV  BX,0FF10h ;Subfunction (BL) 10h (Return EGA information)
                 ;  Preset unrealistic return value (BH)
  INT  10h       ;Do it (returns AX, BX, CX)
  CMP  BL,10h    ;Is the function supported (EGA or better)?
  JE  >R50       ;If not, jump to handle MDA/CGA
  CMP  BH,0FFh   ;Is the return value valid?
  JE  >R50       ;If not, jump to handle MDA/CGA
  TEST B [87h],8 ;If so, is bit 3 of the EGA information byte set?
  JNZ >R50       ;If so, EGA is not the active display
  XOR  AX,AX     ;Get # of
  MOV  AL,[84h]  ;  rows - 1
  JMP >R90       ;We're done
R50:             ;Video card is less than EGA (MDA or CGA)
  MOV  AX,24     ;Number of rows must be 25
R90:             ;We're done
  INC  AX        ;Bump the number of rows by 1
  POP  DS,CX,BX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ASCIIZ STRING(s) TO THE SCREEN, PAUSING WHEN IF NECESSARY
;Inputs:  DS:[DX] = String to write
;         PauseRows, PauseHeaderPtr, PauseHeaderSize, PauseRowCount
;         CS = Local Data Area
;Outputs: PauseRowCount
;Changes: Pauses the screen and waits for user input, if necessary
;NOTES: This should be called instead of WriteZCon every time something
;         is written during the Pausing.
;       A string can be written by WriteZCon during the pausing, as long
;         as the string does not contain a Line Feed.  Any line containing
;         a Line Feed must come through here or the Line Count will get
;         screwed up!
;------------------------------------------------------------------------------
WriteZPauseFar:
  CALL WriteZPause
  RETF

WriteZPause:
  PUSH AX,BX,CX,DX          ;Save used registers
  MOV  AX,CS:PauseHeaderPtr ;Put Header Pointer in AX
  CMP  AX,-1                ;Has the Output been cancelled by the user?
  JE  >P90                  ;If so, don't write anything at all
  OR   AX,AX                ;Is STDOUT Redirected?
  JZ  >P80                  ;If so, just write it with no Pausing
  CALL CountZLinesCX        ;Count how many Lines are in the string
  MOV  AX,CS:PauseRowCount  ;Add the new lines
  ADD  AX,CX                ;  to the current lines
  CMP  AX,CS:PauseRows      ;Will we be at or past the end of the screen?
  JB  >P70                  ;If not, just write it
  JE  >P20                  ;If at the end of the screen, handle it
  SUB  AX,CS:PauseRows      ;If not, find
  SUB  CX,AX                ;  the end of the String
  CALL FindEndOfLines       ;  we need to write ([BX])
  MOV  AL,[BX]              ;Save the character that's there now
  MOV  B [BX],0             ;Replace it with a 0
  CALL WriteZPause          ;Write it (will Pause correctly)
  MOV  [BX],AL              ;Restore original character
  MOV  DX,BX                ;Use the new string pointer
  CALL WriteZPause          ;Write it (Pausing if necessary)
  JMP >P90                  ;Done
P20:                        ;At end of screen
  CALL WriteZCon            ;Write the String
  CALL HandlePause          ;Handle the Pause (may change Pointers/Counters)
  JMP >P90                  ;We're done for now
P70:                        ;Store new Row Count
  MOV  CS:PauseRowCount,AX  ;Save the new Row Count
P80:                        ;Write the String
  CALL WriteZCon            ;Write the string
P90:                        ;Done
  POP  DX,CX,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE PAUSE LINE, AND WAIT FOR A KEYSTROKE
;Inputs:  CS = Local Data Area
;         PauseRows, PauseHeaderPtr, PauseHeaderSize, PauseRowCount
;Outputs: PauseRowCount, PauseHeaderPtr
;Changes: Pauses the screen and waits for user input, if necessary
;------------------------------------------------------------------------------
HandlePause:
  PUSH AX,BX,DX,DS        ;Save String Segment
  MOV  DS,CS              ;Point DS at our Data Segment
  MOV  BX,OFFSET PauseHeaderPtr ;Point [BX] at the Pause Header
  MOV  DX,PauseMsg        ;Write the
  CALL WriteZCon          ;  Enter a Keystroke message
  CALL FlushKbdBuff       ;Clear the keyboard buffer
L10:                      ;Loop to here to wait for a keystroke
  CALL GetKey             ;Is there a key in the keystroke buffer?
  JZ   L10                ;If not, keep waiting until there is
  MOV  DX,PauseDMsg       ;Delete the
  CALL WriteZCon          ;  MORE Message
  CMP  AL,CtrlC           ;Was the keystroke a Control-C?
  JE  >L40                ;If so, jump to handle it
  CMP  AL,Escape          ;Was the keystroke an Escape?
  JNE >L20                ;If not, just keep going
  MOV  W [BX],0           ;If so, mark us as redirected (stop Pausing)
  JMP >L90                ;And quit
L20:                      ;Continue with the Pause
  MOV  DX,PauseNMsg       ;Write the
  CALL WriteZCon          ;  MORE Replacement Line
  MOV  DX,[BX]            ;Point DX at the Header
  CALL WriteZCon          ;Write it
  MOV  AX,PauseHeaderSize ;Reset the Row Count
  MOV  PauseRowCount,AX   ;Store the new Row Count
  JMP >L90                ;We're done for now
L40:                      ;Ctrl-C (stop altogether)
  MOV  W [BX],-1          ;Mark as stopped
L90:                      ;Done
  POP  DS,DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE NUMBER OF LINES IN AN ASCIIZ STRING (COUNT CR/LF COMBINATIONS)
;Inputs:  DS:[DX] = Pointer to String to measure
;         CLD already issued
;Outputs: CX = Number of LF's in the String (may be 0)
;         ZF = Set if CX = 0
;            = Clear if CX > 0
;Changes:
;------------------------------------------------------------------------------
CountZLinesCX:
  PUSH AX,SI ;Save used registers
  MOV  SI,DX ;Put the pointer in DI
  XOR  CX,CX ;Initialize Lines Counter
Z10:         ;Loop to here for each character
  LODSB      ;Get the next character
  OR   AL,AL ;Is it the end of the string?
  JZ  >Z90   ;If so, we're done
  CMP  AL,LF ;Is it a Line Feed?
  JNE  Z10   ;If not, it's not a new line
  INC  CX    ;If so, Increment the Line Counter
  JMP  Z10   ;Keep looking
Z90:         ;We're done
  OR   CX,CX ;Set return flag
  POP  SI,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE POINTER AFTER THE FIRST SEVERAL LINES OF A STRING
;Inputs:  DS:[DX] = String to use
;         CX = Number of lines to "skip"
;         CLD already issued
;Outputs: DS:[BX] = "New" String Pointer (after the last line written)
;Changes:
;NOTES: This assumes that the string actually has MORE than the number of
;         lines in AX (it does not look for the end of an ASCIIZ string).
;------------------------------------------------------------------------------
FindEndOfLines:
  PUSH AX,CX  ;Save used registers
  PUSH DI,ES  ;Save used registers
  MOV  BX,CX  ;BX = Line Counter
  MOV  ES,DS  ;Point ES:[DI] at
  MOV  DI,DX  ;  the string
  MOV  AL,LF  ;Look for Line Feeds
  MOV  CX,-1  ;Maximize counter
L10:          ;Loop to here for each new line
  REPNE SCASB ;Look for the end-of-line character
  DEC  BX     ;Decrement the Line Counter
  JNZ  L10    ;If not 0 yet, keep looking
  MOV  BX,DI  ;Store the new string beginning
L90:          ;Done
  POP  ES,DI  ;Restore used registers
  POP  CX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FLUSH KEYBOARD BUFFER
;Inputs:
;Outputs:
;Changes: Flushes the Keyboard Buffer
;------------------------------------------------------------------------------
FlushKbdBuff:
  PUSH AX     ;Save used registers
F10:          ;Loop to here for each key
  CALL GetKey ;Get a key from the keyboard buffer
  JNZ  F10    ;If there was one, get another
  POP  AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ CHARACTER FROM THE KEYBOARD BUFFER
;Inputs:
;Outputs: AH = Keyboard scan code
;         AL = ASCII value of keypress (0 if extended ASCII)
;         AX = 0 if no key is waiting
;Changes: ZF = Set if no key in buffer (AX = 0)
;            = Clear if a key was found (AX = key)
;------------------------------------------------------------------------------
GetKey:
  MOV  AH,1  ;Service 1 (Keystroke waiting?)
  INT  16h   ;Do It
  JZ  >K10   ;If no key waiting, we're done
  XOR  AH,AH ;If a key is waiting, service 0 (Get keystroke)
  INT  16h   ;Do It
  JMP >K90   ;We're done
K10:         ;No keystroke waiting
  XOR  AX,AX ;Make sure AX=0
K90:         ;We're done
  OR   AX,AX ;Set the found/not found flag
  RET

;------------------------------------------------------------------------------
;WRITE A CR/LF TO THE CONSOLE WITH A PAUSE
;Inputs:
;Outputs: To Screen, Updates Pause Counters
;Changes:
;------------------------------------------------------------------------------
WriteCrLfPause2:
  CALL WriteCrLfPause ;Write two
  CALL WriteCrLfPause ;  new lines
  RET

WriteCrLfPause:
  PUSH DX         ;Save used registers
  MOV  DX,CrLfMsg ;Write a Cr/Lf to
  CALL WriteItDX  ;  the Pause Device
  POP  DX         ;Restore used registers
  RET

WriteCrLfErr:
  PUSH DX         ;Save used registers
  MOV  DX,CrLfMsg ;Write a Cr/Lf to
  CALL WriteZErr  ;  the ERR Device
  POP  DX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SETUP A HEADER STRING TO THE PAUSE ROUTINE
;Inputs:  DS = Local Data Area
;         DS:[DX] = Header String to Write
;         CallBackAddr2 = Filled in if we're being EXEC'd
;Outputs: To screen (if we're not EXEC'd)
;         To CallBackAddr2 (if we are EXEC'd)
;Changes:
;------------------------------------------------------------------------------
WriteHeader2:
  CALL WriteCrLfPause        ;Move down
WriteHeader1:
  CALL WriteCrLfPause        ;Move down
WriteHeader0:
  CMP  W CallBackAddr2[0],-1 ;Is there a valid call-back address?
  JE  >H50                   ;If not, write it locally
  CMP  ParentIsShell,Yes     ;Double-check whether we are at a command-line
                             ;  (we shouldn't need to do this, but will anyway)
  JE  >H50                   ;If so, write it locally
  PUSH AX,BX,CX,DX,DI,SI     ;Save
  PUSH BP,DS,ES              ;  all registers
  CALL D CallBackAddr2       ;If not, call the provided code address
  POP  ES,DS,BP              ;Restore
  POp  SI,DI,DX,CX,BX,AX     ;  all registers
  JMP >H90                   ;Done
H50:                         ;Write to Pause
  CALL SetupPause            ;Write the Header
H90:                         ;Done
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO SET UP COMMAND TAIL WITH PROPER PARAMETERS FOR EXEC CALL
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;WRITE A WORD AS HEX TO A STRING
;Inputs:  AX   = Word to Write
;         [BX] = String to write to
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteWordToString:
  PUSH DI,ES          ;Save used registers
  MOV  ES,DS          ;Point ES at Local Data Area
  MOV  DI,BX          ;Point DI at String
  CALL Word2HexString ;Store the Segment
  POP  ES,DI          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY A STRING INTO THE COMMAND TAIL
;Inputs:  [BX] = ASCIIZ String to Copy
;Outputs: To CmdTail
;Changes:
;------------------------------------------------------------------------------
CopyToCmdTail:
  PUSH AX,CX,DX,DI,SI,ES ;Save used registers
  MOV  ES,DS             ;Point ES at Local Data Area
  MOV  CX,(CmdTailMax/2) ;Number of Words to Copy
  MOV  AX,CR+(CR SHL 8)  ;Fill with CR's
  MOV  DI,CmdTail        ;Point at Command Tail
  PUSH DI                ;Save Pointer
  REP  STOSW             ;Fill the Command Tail
  POP  DI                ;Restore Pointer
  MOV  DX,BX             ;Calculate number of bytes
  CALL CalcStrSizeDX     ;  to copy
  MOV  CmdTailSize,CL    ;Store the Command Tail Size
  MOV  SI,BX             ;Copy the string
  REP  MOVSB             ;  to the Command Tail
  POP  ES,SI,DI,DX,CX,AX ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;CODE TO EXEC ANOTHER PROGRAM
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;SETUP PARAMETERS TO BE ABLE TO PERFORM THE EXEC FUNCTION
;Inputs:
;Outputs:
;Changes: Lots of stuff
;------------------------------------------------------------------------------
SetupExec:
  PUSH AX,SI                       ;Save used registers
  MOV  SI,ParamBlock               ;Point at Parameter Block
  MOV  AX,CS                       ;Use our data segment
  MOV  [SI].PBEnvirSegment,0       ;Use Copy of our Environment
  MOV  W [SI].PBCmdTailPtr[0],OFFSET CmdTailSize
  MOV  W [SI].PBCmdTailPtr[2],AX   ;Command Tail Pointer
  MOV  W [SI].PBFCB1Offset[0],FCB1
  MOV  W [SI].PBFCB1Offset[2],AX   ;FCB #1 Pointer
  MOV  W [SI].PBFCB2Offset[0],FCB2
  MOV  W [SI].PBFCB2Offset[2],AX   ;FCB #1 Pointer
  POP  SI,AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PERFORM THE EXEC FUNCTION
;Inputs:  ParamBlock set up with appropriate data
;         CmdTail/CmdTailSize set up with appropriate Info
;         PathToUse contains Child Program to Call
;         DS = Our data Area
;Outputs: CF = Clear if Program Returned ErrorLevel 0
;Changes: Performs EXEC Function
;------------------------------------------------------------------------------
DoExec:
  PUSH ES            ;Save used register
  MOV  ES,DS         ;Point ES at our dta Area
  PUSHA              ;Save all registers
  MOV  OldSPExec,SP  ;Save the Stack Pointer (may be destroyed by Call)
  MOV  DX,PathToUse  ;DS:[DX] = Child Program to Run
  MOV  BX,ParamBlock ;ES:BX = Parameter Block
  MOV  AX,4B00h      ;Function 4B00h (Load and Execute child program)
  INT  21h           ;Do it (May Destroy BX & DX)
  JC  >X70           ;If Error, quit
X00:                 ;When the Child Program Exits, here we are!
  CLD                ;Go forward with string functions
  CLI                ;Disable interrupts
  MOV  DS,CS         ;Restore
  MOV  ES,DS         ;  all
  MOV  SS,CS         ;  Segments
  MOV  SP,OldSPExec  ;Restore Stack Pointer
  STI                ;Enable interrupts
  MOV  AH,4Dh        ;Function 4Dh (Get ErrorLevel)
  INT  21h           ;Do it (Returns AH = Term Type, AL = ErrorLevel)
  OR   AL,AL         ;ErrorLevel 0?
  JZ  >X80           ;If so, it was OK
X70:                 ;Error
  STC                ;Set Error Flag
  JMP >X90           ;Done
X80:                 ;OK
  CLC                ;Set OK Flag
X90:                 ;Done
  POPA               ;Restore all registers
  POP  ES            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE LOCATION OF THE SUPPORT FILE
;Inputs:  [DI] = FIleName to Look for
;Outputs: CF = Clear if OK (File Found)
;              PathToUse = Path & FileName Concatenated Together
;            = Set if Error (File not Found)
;              PathToUse = Undefined
;Changes: Various Path pointer Registers (OurPathPointer, PathVarPointer, etc.)
;------------------------------------------------------------------------------
FindSupportFile:
  PUSH AX,SI,ES          ;Save used registers
F10:                     ;Do Our Path
  MOV  SI,OurPathPointer ;Point [SI] at our Path pointer
  CMP  SI,-1             ;Valid?
  JE  >F20               ;If not, skip it
  MOV  ES,[PSPEnvirSeg]  ;Point ES at the Environment Segment
  CALL CopyPathName      ;Copy it
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F20:                     ;Do Current Path
  MOV  ES,CS             ;Point ES at us
  MOV  SI,CurrentPath    ;If not, try the Current Path
  CALL CopyPathName      ;Copy it
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F30:                     ;Do Environment PATH
  MOV  SI,PathVarPointer ;SI = Environment PATH Pointer
  CMP  SI,-1             ;Is it valid?
  JE  >F70               ;If not, we're done
  MOV  ES,[PSPEnvirSeg]  ;Point ES at the PATH (Environment) Segment
F35:                     ;Loop to here for each element in PATH
  CALL CopyPathName      ;Copy the PATH element
  JC  >F70               ;If End of Path, we're done
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F40:                     ;Loop to here to skip over PATH Element
  MOV  AL,ES:[SI]        ;Get next character
  INC  SI                ;Increment Pointer
  OR   AL,AL             ;End of PATH?
  JZ  >F70               ;If so, we're done
  CMP  AL,';'            ;End of PATH Element?
  JNE  F40               ;If not, Keep looking
  JMP  F35               ;Try the next Element
F70:                     ;Error
  STC                    ;Set Error Flag
  JMP >F90               ;Done
F80:                     ;Found our File
  CLC                    ;Set OK flag
F90:                     ;Done
  POP  ES,SI,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEE IF THE SUPPORT FILE EXISTS
;Inputs:  PathToUse
;Outputs: CF = Clear if OK (File Found)
;            = Set if Error (File not Found)
;Changes:
;------------------------------------------------------------------------------
FindFile:
  PUSH AX,BX,CX,DX   ;Save used registers
  PUSH DS,ES         ;Save used registers
  MOV  AH,2Fh        ;Function 2Fh (Get DTA Address)
  INT  21h           ;Do it (returns ES:BX)
  MOV  AH,1Ah        ;Function 1Ah (Set DTA Address)
  MOV  DX,FCB1       ;DS:DX = New DTA Address
  INT  21h           ;Do it
  MOV  AX,4E00h      ;Function 4Eh (Find First Matching File)
  MOV  CX,FAttrToUse ;Search for any file, including Hidden
  MOV  DX,PathToUse  ;DS:DX = ASCIIZ FileName to search for
  INT  21h           ;Do it (returns CF)
  PUSHF              ;Save return flag
  MOV  DS,ES         ;Point DS:DX
  MOV  DX,BX         ;  at the old DTA
  MOV  AH,1Ah        ;Function 1Ah (Set DTA Address)
  INT  21h           ;Do it
  POPF               ;Restore return flag
  POP  ES,DS         ;Restore used registers
  POP  DX,CX,BX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CREATE A COMPLETE PATH NAME GIVEN A PATH AND A FILE NAME
;Inputs:  ES:[SI] = Path name to Copy
;         DS:[DI] = FileName to Append to the Path
;Outputs: PathToUse = Path & File Concatenated Together
;NOTES: The Path String can either end with a 0 (ASCIIZ String) or a SemiColon
;         (the way strings are stored in the PATH Environment variable).
;       This code will properly handle an empty Path String, which will
;         simply set PathToUse to the FileName.
;       The FileName must be an ASCIIZ String.
;------------------------------------------------------------------------------
CopyPathName:
  PUSH AX,BX,CX,DI,SI,DS,ES  ;Save used registers
  PUSH DS                    ;Point ES
  PUSH ES                    ;  at our data,
  POP  DS                    ;  DS at
  POP  ES                    ;  Path Data
  MOV  BX,DI                 ;Save File Name Pointer
  XOR  AX,AX                 ;Fill with Zeroes
  MOV  CX,(MaxPathSize/2)    ;Number of Words to Write
  MOV  DI,PathToUse          ;Where to write them
  PUSH DI                    ;Save Pointer
  REP  STOSW                 ;Reset the Buffer
  POP  DI                    ;Restore Pointer
  XOR  CL,CL                 ;Start String Length Counter at 0
N10:                         ;Loop to here for each character in Path
  LODSB                      ;Get next character
  OR   AL,AL                 ;End of Path?
  JZ  >N20                   ;If so, do Filename
  CMP  AL,';'                ;End of Path (Environment PATH)?
  JE  >N20                   ;If so, do FileName
  INC  CL                    ;Increment String Length Counter
  STOSB                      ;If not, store the character
  JMP  N10                   ;Keep going
N20:                         ;Done with Path
  OR   CL,CL                 ;Any characters at all in the Path?
  JZ  >N30                   ;If so, is Current Path, and don't want backslash!
  CMP  B ES:[DI-1],Backslash ;Path ends in a Backslash?
  JE  >N30                   ;If so, it's OK
  MOV  AL,Backslash          ;If not, store
  STOSB                      ;  a Backslash
N30:                         ;Path is OK
  MOV  DS,ES                 ;Point DS:[SI]
  MOV  SI,BX                 ;  at the File Name
N40:                         ;Loop to here for each character in File name
  LODSB                      ;Get next character
  OR   AL,AL                 ;End of File Name?
  JZ  >N90                   ;If so, we're done
  STOSB                      ;If not, store it
  JMP  N40                   ;Keepgoing
N90:                         ;Done
  POP  ES,DS,SI,DI,CX,BX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE PATH THAT OUR PROGRAM IS IN
;Inputs:
;Outputs: OurPathPointer = Pointer to Our Path String (in Environment Segment)
;                        = -1 if we couldn't find our own Path
;Changes:
;------------------------------------------------------------------------------
GetOurPath:
  PUSH AX,BX,CX,DI,SI   ;Save used registers
  PUSH DS,ES            ;Save used registers
  MOV  BX,OFFSET OurPathPointer ;Point at where we're storing
  MOV  DS,[PSPEnvirSeg] ;Point DS and ES
  MOV  ES,DS            ;  at the Environment segment
  XOR  DI,DI            ;Point at the beginning of Environment list
  MOV  CX,-1            ;Max out the count limiter
  XOR  AX,AX            ;Need to look for a double 0
N10:                    ;Loop to here to skip over Environment vars
  REPNE SCASB           ;Look for the end of this environment variable
  CMP  [DI],AL          ;Is it the end of the variable list (double 0)?
  JNE  N10              ;If not, keep skipping over Environment vars
  CMP  [DI+1],AX        ;If so, is there a string after the Envir?
  JE  >N70              ;If not, we're done
  ADD  DI,3             ;Point DI and SI at the
  MOV  SI,DI            ;  True Name
  MOV  CS:[BX],DI       ;Store the Pointer
N20:                    ;Loop to here to find the end of the PATH
  LODSB                 ;Get the next character of the name
  CMP  AL,':'           ;Is it a Colon?
  JE  >N30              ;If so, possible end-of-path
  CMP  AL,Backslash     ;Is it a backslash?
  JE  >N30              ;If so, possible end-of-path
  OR   AL,AL            ;End of File Name?
  JZ  >N50              ;If so, we're done
  JMP >N40              ;If not, keep looking
N30:                    ;Update end-of-path Pointer
  MOV  DI,SI            ;Save possible end-of-path pointer
N40:                    ;Not end-of-path yet
  JMP  N20              ;Keep looking
N50:                    ;At end of Path
  CMP  DI,CS:[BX]       ;Was there a real Path?
  JE  >N70              ;If not, error
  MOV  B [DI],0         ;If OK, put 0 at end of Path
  JMP >N90              ;Done
N70:                    ;No Path
  MOV  W CS:[BX],-1     ;Set Pointer as Invalid
N90:                    ;Done
  POP  ES,DS            ;Restore used registers
  POP  SI,DI,CX,BX,AX   ;Restore used registers
  RET


;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北
;SPACE AND CODE TO PROCESS OUR PROGRAM STACK
;  This code and must be physically at the END of the Program,
;    but must be one of the FIRST procedures called by the Program.
;  In addition, the Stack Pointer (SP) must be set properly
;    (to LastProgByte - 2) BEFORE this code is called.
;北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北北

;------------------------------------------------------------------------------
;RESIZE OUR MEMORY ALLOCATION TO THE MINIMUM SIZE NEEDED
;Inputs:  SP = LastProgByte - 2
;         ES = Local Segment
;Outputs: Rellocates Memory to the minimum size required to run the program
;Changes:
;------------------------------------------------------------------------------
ResizeMemory:
  PUSH AX,BX  ;Save used registers
  MOV  AH,4Ah ;Function 4Ah (Resize Memory Block pointed at by ES)
  MOV  BX,(LastProgByte SHR 4) ;BX = Number of Paragraphs to Resize to
  INT  21h    ;Do it
  POP  BX,AX  ;Restore used registers
  RET

  EVEN 16
  DB (ProgStackSize/8) DUP ('PrgStack')

LastProgByte:
