  JMP Main ;Skip over Data to Main Program


;==============================================================================
;NOTE: This program is written for and compiled with Eric Isaacson's A386
;      assembly language compiler, using Options +P3 -F (80386+ CPU and
;      no FPU).
;==============================================================================

;Fix TDStatus so it prints on same line if called with specific parameters
;  (not whole table) and called from other program

;Hitting Ctrl-C while displaying all USB Vendors doesn't work right

;What happens if a Descriptor if the first byte is a small value and
;  is not the Descriptor Length?  Need to handle this possibility!

;In Int 14 Requests, display data being sent (buffer contents) if OUT and
;  in first 1MB of memory.  Just for Control??  Just first several bytes?

;Look for CMDLINE environment variable!

;For DescrType Option, do General and Class-Specific types also (categorized
;  by Dvc/Intf Class)?

;Class Usage Description Examples
;00h Device    Unspecifiedclass 0 (Device class is unspecified. Interface descriptors are used for determining the required drivers.)
;01h Interface Audio speaker, microphone, sound card
;02h Both      Communications and CDC Control ethernet adapter, modem, serial port adapter
;03h Interface Human Interface Device (HID) keyboard, mouse
;05h Interface Physical Interface Device (PID) force feedback joystick
;06h Interface Image digital camera
;07h Interface Printer laser printer, Inkjet printer
;08h Interface Mass Storage USB flash drive, memory card reader, digital audio player
;09h Device    USB hub full speed hub, hi-speed hub
;0Ah Interface CDC-Data (This class is used together with class 02h - Communications and CDC Control.)
;0Bh Interface Smart Card USB smart card reader
;0Dh Interface Content Security -
;0Eh Interface Video webcam
;0Fh Interface Personal Healthcare -
;DCh Both      Diagnostic Device USB compliance testing device
;E0h Interface Wireless Controller Wi-Fi adapter, Bluetooth adapter
;EFh Both      Miscellaneous ActiveSync device
;FEh Interface Application Specific IrDA Bridge
;FFh Both      Vendor Specific (This class code indicates that the device needs vendor specific drivers.)


;Add all Wireless Descriptor Types!!
;  Wireless = v2.5, has extra descriptors that don't appear with GetConfig

;Need to know Class/SubClass/Protocol to properly decode non-general
;  (class/interface-specific) Control Requests.  Either that, or we just
;  don't decode them at all.

;Need to download Device Qualifier & Other Speed Cfg Descriptors in
;  USBUHCI?  Don't think so, since EHCI driver should do that.  Can't
;  imagine a Device actually changing Device Types between 1 and 2,
;  though could definitely see changing Interface characteristics.
;  At least experiment with it to see what happens.
;In this program, have option to download ALL descriptors, including
;  Device Qualifier & Other Speed Configuration, as well as Report
;  and Physical for HID's, On-the-Go, Debug, Interface Asodciation, etc.
;  Try them ALL.

;In other programs, have option to both download descriptors of last
;  attached Device or download entire descriptors for a specific device
;  (based on Index).  If specific device, just pass call on to this
;  program.

;Modify all Programs to have 1024 bytes Config Descr Size?  Definitely
;  need in HID programs, maybe not in Printer, etc.

;Need way to download Report/Physical Descriptors from an HID Device from
;  inside this program.  May not have a compatible Driver installed to
;  be able to download it.  Definitely need for troubleshooting/building
;  new drivers.
;  Need to do this for Device/Config Descriptors also.  Option =
;  DownloadConfigDescr (e.g), followed by HostIndex & DeviceAddress
;  (shouldn't need any other data??)

;Need an ErLvlOption?

;Belkin Bluetooth has bad HID Descriptor at end!!  Find out what that's about.
;  Need Bluetooth Descriptor Types

;Also Need Options for AudioTerminalTypes, AudioSpatial, etc.

;For Plantronics Headset, the Bass/Treble/Balance Increment/Decrement
;  Controls don't translate correctly (Big/Little Endian issues).
;  Figure out correct Endianness and fix it!


;In Docs:
;Descrs 0-20 are general, 21+ are device/vendor specific.  We
;  decipher generals and many class-specific, as long as they are
;  included in the "get Complete Configuration Request".  We also do
;  HID Physical & Report Descriptors, and Hub Descriptors.
;USB is designed so that Descriptors "build" on each other.  That is, many
;  times it is not possible to properly decode a particular descriptor
;  unless some other Descriptors were decoded first (and appropriate
;  information gleaned from them (like Device/Interface Class/SubClass/
;  Protocol/Version).  Therefore, as a rule it is not possible to decode
;  "stand-alone" descriptors except for some types of general descriptors.
;  The Decriptor decoding of this program assumes that the COMPLETE
;  set of descriptors are downloaded, with the Device Descriptor first,
;  flowwed by all of the descriptors downloaded with a "Get Complete
;  Configuration" Request (this will include Interface, EndPoint, and,
;  in many cases, some sort of Class-Specific Descriptor(s).
;  It is NEVER possible to decode a Class-Specific Descriptor (Type >= 20h)
;  without proper knowledge of the associated Device and Interface Descriptors,
;  at a minimum.  In certain cases, knowledge of data contained in other
;  Descriptors may also be required.
;Decoding USB Descriptors is complicated and convoluted.  In many cases,
;  it is not possible to decode a stand-alone descriptor without some sort
;  of "context".  The "context" is usually obtained from the Descriptors
;  that come before it in a complete list of Descriptors (i.e, the Descriptors
;  farther down the list "build upon" the Descriptors that came earlier).
;  This program assumes that it has the complete "chain" of Descriptors
;  (downloaded with "Get Device Descriptor" and "Get Configuration Descriptor"
;  Requests).  The Device Descriptor should be first in the chain, and MUST
;  come before any Interface Descriptors (since some Interface Descriptors
;  cannot be decoded properly without knowledge of data contained in the
;  Device Descriptor).
;Downloading all Descriptors from a Device initially takes 4 separate
;  steps.  Download first 8 bytes of Device Descriptor (obtain
;  Max Packet Size for EndPoint 0), Download complete Device Descriptor,
;  Download basic Configuration Descriptor (get Complete Size), download
;  entire Configuration Descriptor (includes Interface, EndPoint, and
;  various other USB and Class-Specific Descriptors).
;Calls other "sub-support" programs, including VENDORID.COM and
;  HIDSUPT1.Com, may in future need additionals.
;Cannot properly decode class/vendor/xx-specific control requests, since
;  that requires knowledge of Class/Vendor-Specific details, which can't
;  be gleaned accurately.  In addition, proper Request decoding may depend
;  in some cases on the current "state" of a particular Device, which
;  is simply too complicated to process in this kind of "general-purpose"
;  program.  This does properly decode "general" Control Requests, however.
;In general, just writes data as it sees it with no error checking.  Could
;  especially be problem with Descriptor Decoding, since many Devices
;  have bad Descriptors.


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;EQUATE/STRUCTURE/MACRO DEFINITIONS
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;EQUATES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;==============================================================================
;Miscellaneous
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special Codes
  ;----------------------------------------------------------------------------
  No  EQU  0 ;Miscellaneous Yes/No tests
  Yes EQU -1 ;      "        "  "    "


;==============================================================================
;CPU Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Bit masks in the CPU Flags Register
  ;----------------------------------------------------------------------------
  CarryFlag  EQU 0001h ;Carry Flag
  ParityFlag EQU 0004h ;Parity Flag
  AuxFlag    EQU 0010h ;Auxiliary Flag
  ZeroFlag   EQU 0040h ;Zero Flag
  SignFlag   EQU 0080h ;Sign Flag
  TrapFlag   EQU 0100h ;Trap Flag
  IntFlag    EQU 0200h ;Interrupt Flag
  DirFlag    EQU 0400h ;Direction Flag
  OFFlag     EQU 0800h ;Overflow Flag


;==============================================================================
;CONsole/Screen Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special ASCII Characters
  ;----------------------------------------------------------------------------
  Tab       EQU  9 ;Tab
  LF        EQU 10 ;Line Feed
  FormFeed  EQU 12 ;FormFeed
  CR        EQU 13 ;Carriage Return
  EOF       EQU 26 ;End-of-File
  Quote2    EQU 34 ;Double quote
  Quote1    EQU 39 ;Single quote
  BackSlash EQU 92 ;BackSlash (\)

  ;----------------------------------------------------------------------------
  ;Special Keys that can be pressed during Pause routine
  ;----------------------------------------------------------------------------
  CtrlC  EQU  3 ;Control-C Keystroke
  Escape EQU 27 ;Escape Keystroke


;==============================================================================
;DOS Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;;Minimum DOS Version required to use this program
  ;----------------------------------------------------------------------------
  MinDOSVer EQU 0300h

  ;----------------------------------------------------------------------------
  ;Sizes of various DOS data structures
  ;----------------------------------------------------------------------------
  FCBSize     EQU  44 ;Size of DOS File Control Block
  CmdTailMax  EQU 128 ;Maximum size of a DOS Command Tail
  MaxPathSize EQU  64 ;Maximum Size of a DOS Path/FileName String

  ;----------------------------------------------------------------------------
  ;Special "hard-coded" DOS Device Handles.
  ;These Handles are permanently hard-coded in DOS, and are always open.
  ;There is no need to issue Find, Open, or Close calls to these
  ;  devices - you can just use them at will.
  ;----------------------------------------------------------------------------
  StdInHandle  EQU 0 ;Standard Input Device Handle
  StdOutHandle EQU 1 ;Standard Output Device Handle
  StdErrHandle EQU 2 ;Standard Error Device Handle
  StdAuxHandle EQU 3 ;Standard Auxiliary Device Handle (COM1 by default)
  StdPrnHandle EQU 4 ;Standard Printer Device Handle (LPT1 by default)

  ;----------------------------------------------------------------------------
  ;Codes returned by INT 21h, Function 4400h (Get Device Information)
  ;----------------------------------------------------------------------------
  ;If bit 7 is Set (is a Device):
  DvcInfoIsStdIn    EQU 0001h ;STDIN
  DvcInfoIsStdOut   EQU 0002h ;STDOUT
  DvcInfoIsNUL      EQU 0004h ;NUL
  DvcInfoIsClock    EQU 0008h ;CLOCK$
  DvcInfoInt29h     EQU 0010h ;Uses Int 29h (Special Device)
  DvcInfoBinary     EQU 0020h ;Binary (Raw) Mode
  DvcInfoEOF        EQU 0040h ;EOF on Input
  DvcInfoIsDevice   EQU 0080h ;Is a Device (not a File)
  DvcInfoKEYB       EQU 0100h ;Unknown (set by DOS 6.2x KEYB program)
  DvcInfoOpenClose  EQU 0800h ;Supports Open/Close calls
  DvcInfoOutputBusy EQU 2000h ;Supports Output until Busy
  DvcInfoIOCTL      EQU 4000h ;Can process IOCTL requests (INT 21h, Func 4402h)

  ;If bit 7 is Clear (is a File):
  DvcInfoDriveMask    EQU 003Fh ;Drive number (0 = A:)
  DvcInfoNotWritten   EQU 0040h ;File has not been written (Dirty Buffer?)
  ;Bit 7 = Clear!
  DvcInfoInt24h       EQU 0100h ;Generate Int 24h on Errors (DOS 4 only)
  DvcInfoNotRemovable EQU 0800h ;Media Not Removable
  DvcInfoNoDateTime   EQU 4000h ;Don't set File Date/Time on Closing (DOS 3.0+)
  DvcInfoRemote       EQU 8000h ;File is Remote (DOS 3.0+)


;==============================================================================
;USB Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;General
  ;----------------------------------------------------------------------------
  Int14RequestSize EQU  64 ;Size of Int 14 USB Request Data Structure
  MaxStrSize       EQU 254 ;Maximum size of a String Descriptor

  ;----------------------------------------------------------------------------
  ;Descriptor Types
  ;Put in High Byte of SRValue for GetDescriptor & SetDescriptor Requests
  ;  (Descriptor Index in low byte)
  ;Returned in DescrType of Descriptor Structures
  ;For this program, we will only concern ourselves with "general" descriptors,
  ;  which are returned by the high-level Get Descriptor Requests.
  ;We will not process Class/Interface/Device/Vendor-Specific requests in
  ;  this program, but will issue a Request to a Sub-Program Instead.
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;USB Descriptor Types
  ;----------------------------------------------------------------------------
  DescrTypeDevice    EQU 01h ;Device
  DescrTypeConfig    EQU 02h ;Configuration
  DescrTypeString    EQU 03h ;String
  DescrTypeInterface EQU 04h ;Interface
  DescrTypeEndPoint  EQU 05h ;EndPoint
  DescrTypeDvcQual   EQU 06h ;Device Qualifier
  DescrTypeOtherSpd  EQU 07h ;Other Speed Configuration
  DescrTypeIntfPower EQU 08h ;Interface Power
  DescrTypeOnTheGo   EQU 09h ;On-the-Go
  DescrTypeDebug     EQU 0Ah ;Debug
  DescrTypeIntfAssoc EQU 0Bh ;Interface Association
  ;Types 12 - 17 (0Ch - 11h) are added for Wireless USB
  DescrTypeWSecurity EQU 0Ch ;Wireless USB Security
  DescrTypeWKey      EQU 0Dh ;Wireless USB Key
  DescrTypeWEncrType EQU 0Eh ;Wireless USB Encryption Type
  DescrTypeWBOS      EQU 0Fh ;Wireless USB Binary-device Object Store
  DescrTypeWDvcCap   EQU 10h ;Wireless USB Device Capability
  DescrTypeWEndPtCmp EQU 11h ;Wireless USB Endpoint Companion


  ;Anything higher than 1Fh is Class/Interface/Device/Vendor-Specific,
  ;  which means it is not unique
  DescrTypeHID         EQU 21h ;Human Interface Device
  DescrTypeHIDReport   EQU 22h ;Report (from HID)
  DescrTypeHIDPhysical EQU 23h ;Physical Descriptor (from HID)

  DescrTypeIrDA        EQU 21h ;IrDA Bridge

  DescrTypeHub         EQU 29h ;Hub

  ;----------------------------------------------------------------------------
  ;Possible Error Codes to return to calling program on completion of TD
  ;  These are bit-mapped, so we can have more than one at a time
  ;----------------------------------------------------------------------------
  TDStsOK             EQU 0000h ;ACK Received (TD completed OK / no errors)
  TDStsNAKReceived    EQU 0001h ;NAK Received
  TDStsStalled        EQU 0002h ;TD is Stalled
  TDStsTimeout        EQU 0004h ;TD has timed out (Bulk/Control)
  TDStsOverDue        EQU 0008h ;TD is OverDue (Int/Isoch)
  TDStsShortPacket    EQU 0010h ;TD Short Packet Detected
  TDStsBabbleDetected EQU 0020h ;Babble Detected
  TDStsCRCTOReceived  EQU 0040h ;CRC/TimeOut Error Received
  TDStsBitStuffError  EQU 0080h ;Rx Data contained > 6 ones in a row
  TDStsDataBuffErr    EQU 0100h ;Data Buffer Error
  TDStsControlSetup   EQU 1000h ;Error actually occurred during Control Setup
  TDStsDvcRemoved     EQU 2000h ;Device removed while TD was in progress
  TDStsLargeCallErr   EQU 8000h ;Error during Large Call

  ;----------------------------------------------------------------------------
  ;Error Codes Returned by Int 14h Requests
  ;----------------------------------------------------------------------------
  I14RErrNone           EQU 0000h ;No Error
  I14RErrResources      EQU 0001h ;Insufficient Resources/Memory
  I14RErrHostHardware   EQU 0002h ;Unknown/Hardware Problem with Host
  I14RErrReqTypeNoSupt  EQU 0003h ;Request Type recognized, but not Supported
  I14RErrRequestType    EQU 0011h ;Invalid Request Type
  I14RErrFlags          EQU 0012h ;Invalid Flags
  I14RErrHostIndex      EQU 0013h ;Invalid Host Index
  I14RErrDeviceAddress  EQU 0014h ;Invalid Device Address
  I14RErrHubAddress     EQU 0014h ;Invalid Hub Address
  I14RErrEndPoint       EQU 0015h ;Invalid EndPoint
  I14RErrHubPort        EQU 0015h ;Invalid Hub Port
  I14RErrAltIntf        EQU 0015h ;Invalid Alternate Interface
  I14RErrConfigValue    EQU 0016h ;Invalid Configuration Value
  I14RErrCloseID        EQU 0016h ;Invalid Closure ID
  I14RErrDataX          EQU 0016h ;Invalid DataX Value
  I14RErrInterfaceNum   EQU 0017h ;Invalid Interface Number
  I14RErrSearchIndex    EQU 0018h ;Invalid Search Index
  I14RErrVendorProdID   EQU 0019h ;Invalid Vendor ID
  I14RErrDvcIntf        EQU 001Ah ;Invalid Device/Interface value
  I14RErrRequestHandle  EQU 001Bh ;Invalid Request Handle
  I14RErrPeriodicity    EQU 001Ch ;Invalid Periodicity
  I14RErrBeepFrequency  EQU 001Ch ;Invalid Beep Frequency
  I14RErrTimeOut        EQU 001Dh ;Invalid Timeout
  I14RErrDataAddress    EQU 001Eh ;Invalid Data Address
  I14RErrDataSize       EQU 001Fh ;Invalid Data Size (Low Speed <= 8)
  I14RErrCallBackAddr   EQU 0021h ;Invalid Call Back Address
  I14RErrLCRtnCode      EQU 0021h ;Invalid Large Call Return Code
  I14RErrUserPktID      EQU 0022h ;Invalid User Pkt ID (matches on unregistry)
  I14RErrSetupReqData   EQU 0023h ;Invalid Setup Request Data
  I14RErrFrameTiming    EQU 0024h ;Invalid Frame Timing
  I14RErrFrameIndex     EQU 0024h ;Invalid Frame Index
  I14RErrIsochArray     EQU 0025h ;Invalid Entry in Isoch Array Data
  I14RErrHostHalted     EQU 0031h ;Host is Halted/Suspended
  I14RErrIntfNotFound   EQU 0032h ;Interface not found (on FindIntf/RegIntf)
  I14RErrIntfInConfig   EQU 0033h ;Interface already beging Configured
  I14RErrIntfAlreadyReg EQU 0034h ;Interface already Registered
  I14RErrHostCallInUse  EQU 0035h ;Host Run/Stop/etc. already running
  I14RErrNoPortPower    EQU 0036h ;Per-Port-Power not Supported by Hub
  I14RErrAlreadyBeeping EQU 0037h ;Another Beep Request is already being handled
  I14RErrDebugMode      EQU 0041h ;Tried to Single Step with No Debug Mode
  I14RErrTimingOwned    EQU 0051h ;Problem with Frame Timing Owner
  I14RErrTimingLimit    EQU 0052h ;Frame Timing is already at the Limit
  I14RErrTmgChgInProg   EQU 0053h ;Timing Change already in progress


;==============================================================================
;Program Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Size of our program stack (in bytes)
  ;We need a relatively large stack, since some of our code is recursive
  ;  and therefore can use quite a bit of stack space.
  ;----------------------------------------------------------------------------
  ProgStackSize EQU 512

  ;----------------------------------------------------------------------------
  ;ErrorLevels
  ;----------------------------------------------------------------------------
  ErLvlDOSVer EQU 1 ;DOS Version too old
  ErLvlNo386  EQU 2 ;Not a 386+ CPU

  ;----------------------------------------------------------------------------
  ;Flags Byte at beginning of most Tables
  ;With this Flag at the beginning of each Table, the underlying code knows how
  ;  to parse out the Table "automatically."  This makes the "high-level" code
  ;  easier to write, since it doesn't need to concern itself with how each
  ;  individual Table is layed out.  The high-level code just calls a single
  ;  Table-parsing routine that handles all of the details.
  ;----------------------------------------------------------------------------
  TblFlagByte       EQU 01h ;Table Index is a Byte
  TblFlagWord       EQU 02h ;Table Index is a Word
  TblFlagDWord      EQU 04h ;Table Index is a DWord
  TblFlagHasOffset  EQU 08h ;Table has an Offset (after the String)
  TblFlagBitMask    EQU 10h ;Table is a BitMask Table
  TblFlagBitMap     EQU 20h ;Table is a BitMap table
  TblFlagSequential EQU 40h ;Table is sequential strings (no Indexes included)

  ;----------------------------------------------------------------------------
  ;Maximum number of "Push Global States" Allowed while Printing Report Descr
  ;----------------------------------------------------------------------------
  NumReportPushes EQU 4 ;Maximum number of Push Global Reports Allowed

  ;----------------------------------------------------------------------------
  ;Flags needed to write Bytes/Words/DWords from Tables
  ;----------------------------------------------------------------------------
  WriteByteMinFlag   EQU 01h ;Write in Minimum Space
  WriteByteWordFlag  EQU 02h ;Writing a Word (not a Byte)
  WriteByteDWordFlag EQU 04h ;Writing a DWord (not a Byte or Word)

  ;----------------------------------------------------------------------------
  ;Length of a Descriptor Header Line
  ;----------------------------------------------------------------------------
  DescrLineLen EQU 33


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;STRUCTURES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;==============================================================================
;DOS/CPU Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Program Segment Prefix (PSP)
  ;----------------------------------------------------------------------------
  PSPStruc      STRUC
    PSPDOSExit     DW       20CDh ;Int 20h Call
    PSPNextSegment DW          ?  ;Segment of First Byte of Memory beyond Program
    PSPCPMCall5    DB   6 DUP (?) ;CPM Far Call 5
    PSPInt22Addr   DD          ?  ;Stored Int 22h Handler
    PSPInt23Addr   DD          ?  ;Stored Int 23h (Ctrl-Break) Handler
    PSPInt24Addr   DD          ?  ;Stored Int 23h (Critical Error) Handler
    PSPParentPSP   DW          ?  ;Segment of Parent PSP
    PSPJFT         DB  20 DUP (?) ;Job File Table (20 File Handles)
    PSPEnvirSeg    DW          ?  ;Environment Segment for PSP
    PSPSSSPOnEntry DD          ?  ;Processes SS:SP on Entry to last Int 21h Call
    PSPJFTSize     DW          ?  ;Number of entries in JFT (default = 20)
    PSPJFTPointer  DD          ?  ;Pointer to JFT (Default = PSP:0018h)
    PSPPreviousPSP DD          ?  ;Pointer to previous PSP (Default = FFFF:FFFF)
    PSPFiller1     DB  18 DUP (?) ;Misc stuff used by SHARE, Windows, etc.
                                  ;Memory Below here available to TSR!
    PSPFiller2     DB   2 DUP (?) ;Unused in DOS <= 6.00
    PSPInt21       DW       21CDh ;Int 21h Call
    PSPRETF        DB        0CBh ;RETF Call
    PSPFiller3     DB   9 DUP (?) ;Can be used to make Extended FCB from FCB1
    PSPFCB1        DB  16 DUP (?) ;First File Control Block
    PSPFCB2        DB  16 DUP (?) ;Second File Control Block
    PSPFiller4     DB   4 DUP (?) ;Unused
    PSPCmdLineLen  DB          ?  ;Command Line Length & DTA
    PSPCmdLine     DB 127 DUP (?) ;Command Line String
   ENDS
  PSPStrucSize EQU (TYPE PSPStruc) ;Should be 256 bytes

  ;----------------------------------------------------------------------------
  ;Memory Control Block (MCB)
  ;----------------------------------------------------------------------------
  MCBStruc STRUC
    MCBID              DB        ?  ;Memory Control Block ID
      MCBIDValid      EQU       'M' ;Memory Block is Valid
      MCBIDLastInList EQU       'Z' ;Memory Block is Last in List
    MCBOwnerID         DW        ?  ;PSP Segment of Owner
                                    ;   0 = Owns Self
                                    ;   6 = DR-DOS XMS UMB
                                    ;   7 = DR-DOS Excluded Upper Memory
                                    ;   8 = Belongs to DOS
                                    ;FFFx = 386Max
    MCBSize            DW        ?  ;Size in Paragraphs
    MCBFiller          DB 3 DUP (?) ;Filler
    MCBOwnerName       DB 8 DUP (?) ;Owner Name
   ENDS
  MCBStrucSize EQU (TYPE MCBStruc) ;Should be 16 bytes

  ;----------------------------------------------------------------------------
  ;Structure needed to Initialize DOS EXEC Function
  ;----------------------------------------------------------------------------
  ParamBlockStruc STRUC
    PBEnvirSegment   DW ? ;Environment Segment to use (0 = Copy Callers Segment)
    PBCmdTailPtr     DD ? ;Pointer to Command Tail
    PBFCB1Offset     DD ? ;Pointer to File Control Block #1
    PBFCB2Offset     DD ? ;Pointer to File Control Block #2
    PBSSSPOnReturn   DD ? ;Holds Childs Initial SS:SP on Return (if AL = 01)
    PBCSIPOnReturn   DD ? ;Holds Entry Point (CS:IP) on Return (if AL = 01)
   ENDS
  ParamBlockSize EQU (TYPE ParamBlockStruc) ;Size of EXEC Parameter Block

  ;----------------------------------------------------------------------------
  ;DTA (Disk Transfer Area) after Find First Matching File (INT 21h, Func 4Eh)
  ;The first several bytes of the DTA are DOS version specific, and
  ;  we don't care about that data anyway.  We only care about the data
  ;  that is documented and the same across all versions of DOS.
  ;----------------------------------------------------------------------------
  FindFirstStruc   STRUC            ;Find First Matching File
    FFVerSpecific     DB 21 DUP (0) ;DOS Version-specific Data
    FFAttribs         DB         ?  ;File Attributes
      FAttrReadOnly  EQU        01h ;Read-Only
      FAttrHidden    EQU        02h ;Hidden
      FAttrSystem    EQU        04h ;System
      FAttrVolume    EQU        08h ;Volume Label
      ;Bit 3 = Execute-only (Novell Netware)
      FAttrDirectory EQU        10h ;Directory
      FAttrArchive   EQU        20h ;Archive
      FAttrUnused    EQU        40h ;Unused
                                    ;DOS 3+ returns this bit set if file
                                    ;  is actually a character device
                                    ;DOS Window underneath Windows XP doesn't
      ;Bit 7 = Delete Pending (OpenDOS, NovellDOS)
      ;      = Shareable (Novell Netware)
    FFTime            DW         ?  ;File Creation Time
    FFDate            DW         ?  ;File Creation Date
    FFSize            DD         ?  ;File Size
    FFName            DB 13 DUP (?) ;ASCIIZ File Name & Extension
   ENDS

   FAttrToUse EQU FAttrHidden+FAttrSystem
     ;Attributes to use in DOS's Find First Matching File Function
     ;DOS ignores the Read-Only and and Archive bits, so they don't matter


;==============================================================================
;USB Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;This is the format for a request sent to Int 14h to Send/Receive Data
  ;It contains the type of request, etc.
  ;----------------------------------------------------------------------------
  Int14RequestStruc         STRUC      ;Structure for an Int 14 Request
    I14RRequestType            DB   ?  ;Type of Request
      I14RRTHostClass         EQU  00h ;Host/System/OS Class
        I14RRTGetHostSWInfo   EQU  01h ;Get Host Software Info
        I14RRTGetHostHWInfo   EQU  02h ;Get Host Hardware Info
        I14RRTGetHostVendInfo EQU  03h ;Get Host Vendor Info
        I14RRTGetHostStatus   EQU  04h ;Get Current Host Status
        I14RRTHostRun         EQU  08h ;Start/Run/Resume Host
        I14RRTHostStop        EQU  09h ;Stop Host
        I14RRTHostReset       EQU  0Ah ;Reset Host
        I14RRTHostSuspend     EQU  0Bh ;Global Suspend Host
        I14RRTHostResume      EQU  0Ch ;Force Global Resume on Host
      I14RRTTimingClass       EQU  10h ;Frame Timing Class
        I14RRTRegTmgOwner     EQU  11h ;Register as Timing Owner
        I14RRTUnRegTmgOwner   EQU  12h ;UnRegister as Timing Owner
        I14RRTIncTiming       EQU  13h ;Increment (Slow Down) Frame Timing
        I14RRTDecTiming       EQU  14h ;Decrement (Speed Up) Frame Timing
        I14RRTChangeTiming    EQU  15h ;Change Frame Timing (by Large Amount)
      I14RRTHubClass          EQU  20h ;Hub Class
        I14RRTGetDvcHubInfo   EQU  21h ;Get Hub Info for Device
        I14RRTNewDvcConn      EQU  24h ;Hub has Detected new Device
        I14RRTDvcDisc         EQU  25h ;Device has been Disconnected
        I14RRTSendHubChar     EQU  27h ;Send Hub Characteristics to Host
        I14RRTEnableHubPort   EQU  28h ;Enable Device given Hub & Port
        I14RRTDisableHubPort  EQU  29h ;Disable Device given Hub & Port
        I14RRTResetHubPort    EQU  2Ah ;Reset Device given Hub & Port
        I14RRTSuspendHubPort  EQU  2Bh ;Suspend Device given Hub & Port
        I14RRTResumeHubPort   EQU  2Ch ;Resume Device given Hub & Port
        I14RRTPwrOnHubPort    EQU  2Dh ;Power On Device given Hub & Port
        I14RRTPwrOffHubPort   EQU  2Eh ;Power Off Device given Hub & Port
        I14RRTPwrResetHubPort EQU  2Fh ;Power Reset Device given Hub & Port
      I14RRTTPowerClass       EQU  30h ;Power Class
        I14RRTGetDvcPowerInfo EQU  31h ;Get Power Info for Device
        I14RRTGetHubPowerDraw EQU  32h ;Get Power Draw for Hub
        I14RRTPwrOnDevice     EQU  3Dh ;Power On Device given Dvc Addr
        I14RRTPwrOffDevice    EQU  3Eh ;Power Off Device given Dvc Addr
        I14RRTPwrResetDevice  EQU  3Fh ;Power Reset Device given Dvc Addr
      I14RRTDeviceClass       EQU  40h ;Device Class
        I14RRTGetDvcClassInfo EQU  41h ;Get Device Class Info
        I14RRTGetDvcVendInfo  EQU  42h ;Get Device Vendor Info
        I14RRTGetDvcStatus    EQU  43h ;Get Device Status
        I14RRTEnableDevice    EQU  48h ;Enable/Resume Device given Dvc Addr
        I14RRTDisableDevice   EQU  49h ;Disable Device given Dvc Addr
        I14RRTResetDevice     EQU  4Ah ;Reset Device given Dvc Addr
        I14RRTSuspendDevice   EQU  4Bh ;Suspend Device given Dvc Addr
        I14RRTResumeDevice    EQU  4Ch ;Resume Device given Dvc Addr
      I14RRTConfigClass       EQU  50h ;Configuration Class
        I14RRTConfigingIntf   EQU  51h ;Driver is Configuring an Interface
        I14RRTConfigIntfDone  EQU  52h ;Interface Configuration is Complete
        I14RRTSetNewConfig    EQU  58h ;Set/Change Device Config Value
      I14RRTInterfaceClass    EQU  60h ;Interface Class
        I14RRTFindRegIntf     EQU  62h ;Look for Registered Interface
        I14RRTFindUnRegIntf   EQU  63h ;Look for Unregistered Interface
        I14RRTRegIntfOwner    EQU  64h ;Register as Interface Owner
        I14RRTUnRegIntfOwner  EQU  65h ;Unregister as Interface Owner
        I14RRTIntfDontLook    EQU  68h ;Existing Interface Owner Don't Look
      I14RRTAltIntfClass      EQU  70h ;Alternate Interface Class
        I14RRTGetAltIntfInfo  EQU  71h ;Get Alternate Interface Info
      I14RRTEndPointClass     EQU  80h ;End Point Class
        I14RRTGetDataX        EQU  81h ;Get Current DataX Value
        I14RRTIncDataX        EQU  88h ;Increment/Toggle DataX Value
      I14RRTPacketClass       EQU  90h ;Packet Class
        I14RRTDoIsoch         EQU  94h ;Schedule Isochronous Transaction
        I14RRTDoInterruptPer  EQU  95h ;Schedule Periodic Interrupt
        I14RRTDoControl       EQU  96h ;Schedule Control/Setup Request
        I14RRTDoBulk          EQU  97h ;Schedule Bulk Transaction
        I14RRTDoInterrupt1T   EQU  98h ;Schedule One-Time Interrupt
        I14RRTCloseHandle     EQU  9Ch ;Close/Remove Scheduled Transaction
        I14RRTChangeIntPer    EQU  9Dh ;Change Periodicity of Interrupt
        I14RRTGetTransStatus  EQU  9Fh ;Get Status of Packet Transaction
      I14RRTMiscClass         EQU 0A0h ;Miscellaneous Class
        I14RRTLargeCallDone   EQU 0A1h ;Large (Complicated) Call Complete
        I14RRTBeepSpeaker     EQU 0AFh ;Beep the Speaker
      I14RRTInterHostClass    EQU 0E0h ;Inter-Host Communication Class
        I14RRTHostAdded       EQU 0E1h ;New Host Driver has been installed
        I14RRTHostDeleted     EQU 0E2h ;Host Driver is being removed from Mem
        I14RRTRegDvc0Host     EQU 0E3h ;Inform other Hosts of Device 0 Reg
        I14RRTUnRegDvc0Host   EQU 0E4h ;Inform other Hosts of Device 0 UnReg
        I14RRTCopyNDTable     EQU 0E5h ;Copy New Device Onership Table
      I14RRTInternalClass     EQU 0F0h ;Host Internal/Troubleshooting Class
        I14RRTHostDebug       EQU 0FDh ;Put Host Into Debug Mode
        I14RRTHostSingleStep  EQU 0FEh ;SingleStep the Host (Debug Mode)
    I14RFlags                  DB   ?  ;Bit-level flags
      I14RFlagIn              EQU  01h ;In Direction
      I14RFlagLowSpeed        EQU  02h ;Low-Speed Device
      I14RFlagHiSpeed         EQU  04h ;High-Speed Device
      I14RFlagNoRetries       EQU  10h ;No Auto Retries for Control
      I14RFlagShortPktOK      EQU  20h ;No Retries for Short Packets
      I14RFlagSpecificFrame   EQU  40h ;Use Specific Frame Number
      I14RFlagAddrIsPhys      EQU  80h ;Data Address is Physical
    I14RHostIndex              DB   ?  ;Host Index
    I14RDeviceAddress          DB   ?  ;USB Device Address
      I14RHubAddress          EQU (OFFSET I14RDeviceAddress)
    I14REndPoint               DB   ?  ;EndPoint or Port or Alt Interface
      I14RHubPort             EQU (OFFSET I14REndPoint)
      I14RAltInterface        EQU (OFFSET I14REndPoint)
    I14RConfigValue            DB   ?  ;Configuration Value
      I14RCloseID             EQU (OFFSET I14RConfigValue)
      I14RDataX               EQU (OFFSET I14RConfigValue)
    I14RInterfaceNum           DB   ?  ;Interface Number
    I14RSearchIndex            DB   ?  ;Search Index
    I14RVendorID               DW   ?  ;Vendor ID
    I14RProductID              DW   ?  ;Product ID
    I14RDvcClass               DB   ?  ;Device Class
    I14RDvcSubClass            DB   ?  ;Device SubClass
    I14RDvcProtocol            DB   ?  ;Device Protocol
    I14RIntfClass              DB   ?  ;Interface Class
    I14RIntfSubClass           DB   ?  ;Interface SubClass
    I14RIntfProtocol           DB   ?  ;Interface Protocol
    I14RRequestHandle          DW   ?  ;Request Handle Number
    I14RPeriodicity            DW   ?  ;Interrupt Periodicity/Duration
      I14RBeepFrequency       EQU (OFFSET I14RPeriodicity)
    I14RTimeout                DW   ?  ;Transaction Time Out Value
    I14RDataAddress            DD   ?  ;Data Address
    I14RDataSize               DW   ?  ;Size of Data (Bytes)
    I14RCallBackAddr           DD   ?  ;Call Back Address (CS:IP format)
      I14RLargeCallRtnCode    EQU (OFFSET I14RCallBackAddr)
    I14RUserPktID              DW   ?  ;User Packet ID
    I14RSetupReqData           DQ   ?  ;Setup Request Data (8 bytes)
    I14RFrameTiming            DW   ?  ;Frame Timing Value (def = 12000)
      I14RFrameIndex          EQU (OFFSET I14RFrameTiming)
                                       ;Starting Frame of Isoch Schedule
    I14RIsochSchedAddr         DD   ?  ;Address of Isoch Schedule
    I14RFiller  DB (Int14RequestSize-$) DUP (0)

   ENDS

  ;----------------------------------------------------------------------------
  ;Device Request is a structure containing data required by a USB Setup Packet
  ;----------------------------------------------------------------------------
  SetupRequest           STRUC     ;Structure for a Standard Setup Pkt
    SRRequestType           DB  ?  ;Request Type
      SRRTOut              EQU 00h ;0=Out (Host to Device)
      SRRTIn               EQU 80h ;1=In (Device to Host)
      SRRTTypeMask         EQU 60h ;Mask for Type
        SRRTTypeStandard   EQU 00h ;Type 0 = Standard
        SRRTTypeClass      EQU 20h ;Type 1 = Class
        SRRTTypeVendor     EQU 40h ;Type 2 = Vendor
                                   ;Type 3 = Reserved
      SRRTRecipientMask    EQU 1Fh ;Mask for Recipient Type
        SRRTRecipDevice    EQU 00h ;Recipient Type 0 = Device
        SRRTRecipInterface EQU 01h ;Recipient Type 1 = Interface
        SRRTRecipEndPoint  EQU 02h ;Recipient Type 2 = EndPoint
        SRRTRecipOther     EQU 03h ;Recipient Type 3 = Other
                                   ;Types 4-31 = Reserved
    SRRequest               DB  ?  ;Specific Request
      SRRQGetStatus        EQU  0  ;Request  0 = Get Status
      SRRQClearFeature     EQU  1  ;Request  1 = Clear Feature
      SRRQGetState         EQU  2  ;Request  2 = Get State
      SRRQSetFeature       EQU  3  ;Request  3 = Set Feature
                                   ;Request  4 = Reserved
      SRRQSetAddress       EQU  5  ;Request  5 = Set Address
      SRRQGetDescriptor    EQU  6  ;Request  6 = Get Descriptor
      SRRQSetDescriptor    EQU  7  ;Request  7 = Set Descriptor
      SRRQGetConfig        EQU  8  ;Request  8 = Get Configuration
      SRRQSetConfig        EQU  9  ;Request  9 = Set Configuration
      SRRQGetInterface     EQU 10  ;Request 10 = Get Interface
      SRRQSetInterface     EQU 11  ;Request 11 = Set Interface
      SRRQSynchFrame       EQU 12  ;Request 12 = Synch Frame
    SRValue                 DW  ?  ;Value depends on Request Type
    SRIndex                 DW  ?  ;Index depends on Request Type
      ;If EndPoint,  Bits 3:0 = EndPoint Number
      ;              Bit    7 = 1 if IN EndPoint, 0 if OUT EndPoint
      ;              All other bits are 0
      ;If Interface, Bits 7:0 = Interface Number (low word)
      ;              All other bits are 0 (high word)
    SRLength                DW  ?  ;Length of Data (if there is Data)

   ENDS
  SetupRequestSize EQU TYPE (SetupRequest)

  ;----------------------------------------------------------------------------
  ;This is the structure for a Global State "Stack" Item while Parsing a
  ;  Report Descriptor.
  ;Report Descriptors can have a "Push Global State" and a "Pop Global State"
  ;  in them, which actually needs to save several items (those here in this
  ;  Structure, to be specific).
  ;In the documentation describing Report Descriptors, in references Global,
  ;  Main, Global, & Local Items, but the definition of the PUSH/POP actually
  ;  only refers to Global Items.  So, it is unclear whether a PUSH is supposed
  ;  to really save everything (which is what we do here), or just save truly
  ;  Global Items (which is a smaller subset of this particular Structure).
  ;I haven't yet ran across a real Device which uses the PUSH/POP functions,
  ;  so it's hard to say whether this program is correct or not.  If it is
  ;  incorrect, obviously we'll need to make some changes!!
  ;----------------------------------------------------------------------------
  ReportItemStruc STRUC
    Collection      DB ?
    Delimiter       DB ? ;1 = Open Set, 2 = Close Set
    UsagePage       DB ?
    UnitExponent    DB ?

    DesignatorIndex DD ?
    DesignatorMin   DD ?
    DesignatorMax   DD ?
    LogicalMin      DD ?
    LogicalMax      DD ?
    PhysicalMin     DD ?
    PhysicalMax     DD ?
    ReportCount     DD ?
    ReportSize      DD ?
    ReportID        DD ?
    StringIndex     DD ?
    StringMin       DD ?
    StringMax       DD ?
    Units           DD ?
    Usage           DD ?
    UsageMin        DD ?
    UsageMax        DD ?
   ENDS
  ReportItemSize EQU TYPE ReportItemStruc


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;MACROS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

  SwapDSES MACRO ;Exchange DS & ES with each other
    PUSH DS
    PUSH ES
    POP  DS
    POP  ES
   #EM


;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;DATA
;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

;==============================================================================
;Miscellaneous Strings we need to write to the screen
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Help Message to write on Errors.
  ;This MUST also be the first Data at the top of the File.  If it is, the user
  ;  can simply do a "TYPE USBSUPT1.COM" and get the Help Screen, without even
  ;  needing to execute the Program.
  ;------------------------------------------------------------------------------
  Copyright:
    DB CR
    DB 'USBSUPT1 0.07, (C) 2007-2009, Bret E. Johnson.',CR,LF
    DB LF,0

  HelpMsg:
    DB 'This program is designed as a Support Program, to be called from',CR,LF
    DB '  "inside" some of my other USB-related Programs.  Because it is designed',CR,LF
    DB '  to called from "inside" another program, it does not have all of the',CR,LF
    DB '  nice things that a "real", stand-alone program should have.',CR,LF
    DB '  However it does contain a lot of useful/interesting tidbits of information.',CR,LF
    DB LF
    DB "I should warn you that if you're not pretty familiar with the technical",CR,LF
    DB '  details of how USB is organized, this information may actually confuse you',CR,LF
    DB "  more than it helps you, but it's still there for your viewing pleasure.",CR,LF
    DB LF
    DB 'If the Option asks for number(s) to be entered (#), they can generally be',CR,LF
    DB '  entered in decimal (0-65535) or in hexadecimal (0h-FFFFh).  The exception',CR,LF
    DB '  to this is #Segment:#Offset, which must ALWAYS be in hexadecimal.',CR,LF
    DB '  If you leave number(s) out, ALL possible values will usually be displayed.',CR,LF
    DB LF
    DB 'If running from inside another program (if not running from the command-line),',CR,LF
    DB '  the number(s) can be followed with a hex call-back address (#Segment:#Offset)',CR,LF
    DB '  to which the output will be written.  See USBSUPT1.DOC for details.',CR,LF
    DB LF
    DB LF
    DB 'GENERAL USB DESCRIPTORS (Device, Config, Interface, EndPoint):',CR,LF
    DB '  DeviceClass       #Class',CR,LF
    DB '  DeviceSubClass    #Class #SubClass',CR,LF
    DB '  DeviceProtocol    #Class #SubClass #Protocol',CR,LF
    DB '  InterfaceClass    #Class',CR,LF
    DB '  InterfaceSubClass #Class #SubClass',CR,LF
    DB '  InterfaceProtocol #Class #SubClass #Protocol',CR,LF
    DB '  DeviceDescription #DClass #DSubClass #DProtocol #IClass #ISubClass #IProtocol',CR,LF
    DB '  DescriptorType    #Type',CR,LF
    DB '  Vendor            #Vendor',CR,LF
    DB '  Descriptor        #Segment:#Offset #HostIndex #DvcAddress',CR,LF
    DB LF
    DB 'HID (HUMAN INTERFACE DEVICE) DESCRIPTORS:',CR,LF
    DB '  PhysicalBias       #Bias',CR,LF
    DB '  PhysicalDesignator #Designator',CR,LF
    DB '  PhysicalQualifier  #Qualifier',CR,LF
    DB '  PhysicalDescriptor #Segment:#Offset',CR,LF
    DB '  ReportCollection   #Collection',CR,LF
    DB '  ReportDelimiter    #Delimiter',CR,LF
    DB '  ReportTag          #Tag',CR,LF
    DB '  ReportDescriptor   #Segment:#Offset',CR,LF
    DB '  UsagePage          #UsagePage',CR,LF
    DB '  Usage              #UsagePage #Usage',CR,LF
    DB LF
    DB 'OTHER/MISCELLANEOUS:',CR,LF
    DB '  Aliases',CR,LF
    DB '  Country        #Country',CR,LF
    DB '  Language       #Language',CR,LF
    DB '  Dialect        #Language #Dialect',CR,LF
    DB '  StringLanguage #StringLanguage',CR,LF
    DB '  Int14Structure #Segment:#Offset',CR,LF
    DB '  ControlPacket  #Segment:#Offset',CR,LF
    DB '  Int14ErrorCode #Int14ErrorCode',CR,LF
    DB '  TDStatusCode   #TDStatusCode',CR,LF
    DB 0
    DB EOF

  ;----------------------------------------------------------------------------
  ;Incompatibility Strings we may write to the screen
  ;----------------------------------------------------------------------------
  DOSVerMsg:
    DB 'You must be using DOS version 3.00 or later to use this program.',0
  No386Msg:
    DB 'The CPU in the computer must be at least an 80386.',0

  ;----------------------------------------------------------------------------
  ;Our Progran Name as an ASCIIZ String (9 characters long)
  ;----------------------------------------------------------------------------
  RealName: DB 'USBSUPT1',0

  ;----------------------------------------------------------------------------
  ;Various Strings needed to print numbers and such to the screen
  ;----------------------------------------------------------------------------
  HexString: DB '0000_0000',0
  CrLfMsg:   DB CR,LF,0
  SingleMsg: DB ' '
  NoMsg:     DB 0

  CommaSpaceMsg:   DB ', ',0
  QuestionsMsg:    DB '???',0
  IllegalAttrMsg:  DB 'Illegal Attributes',0
  UnknownXMsg:     DB 'Unknown!',0
  UnknownMsg:      DB 'Unknown',0
  IllegalMsg:      DB 'Illegal',0
  AttribMsg:       DB ' Attribute ',0
  LanguageSMsg:    DB ' Language',0
  DialectSMsg:     DB ' Dialect',0
  MilliAmpMsg1:    DB ' (',0
  MilliAmpMsg2:    DB ' mA)',0
  MilliSecMsg1:    DB ' (',0
  MilliSecMsg2:    DB ' mS)',0
  MonoMsg:         DB 'Monophonic',0
  NoneMsg:         DB 'None',0
  UnAvailMsg:      DB 'Unavailable',0
  AltInterfaceMsg: DB 'Alternate '
  InterfaceMsg:    DB 'Interface = ',0
  EndPointMsg:     DB 'EndPoint = ',0
  AddressMsg:      DB 'Address = ',0
  LanguageMsg:     DB 'Language = ',0
  ConfigMsg:       DB 'Configuration = ',0
  FeatureMsg:      DB 'Feature = ',0
  EqualsSpaceMsg:  DB '= ',0
  UnknownDataMsg:  DB '__Unknown Data',0
  ReservedMsg:     DB 'Reserved',0
  TotalLengthMsg:  DB 'Descr Total Length',0

  ;----------------------------------------------------------------------------
  ;Strings and Data needed to Pause the screen
  ;----------------------------------------------------------------------------
  PauseMsg:
    DB CR,LF
    DB ' MORE   (Esc stops Pausing, Ctrl-C stops Completely, any other Continues)',CR,0
  PauseNMsg:
    DB ' MORE                                                                    ',CR,LF,0
  PauseDMsg:
    DB '                                                                               ',CR,0
  PauseRows       DW ? ;Number of rows per screen
  PauseHeaderPtr  DW 1 ;Pointer to Header Message (start with a fake one <> 0)
  PauseHeaderSize DW 2 ;Number of lines in the Header Message
  PauseRowCount   DW 2 ;Current Row Counter


;==============================================================================
;Alias Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings needed to print Command Line Aliases to the screen
  ;----------------------------------------------------------------------------
  AliasHdrMsg:
    DB '                   ALIASES FOR COMMAND-LINE OPTIONS',CR,LF
    DB 'ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ',CR,LF
    DB 0

  ;----------------------------------------------------------------------------
  ;Table needed to temporarily store Aliases.
  ;They are originally sorted in reverse alphabetical order.
  ;To write them in forward alphabetical order, we temporarily store
  ;  the String Pointers, in the original reverse order, in this table.
  ;  We then write the strings, starting with the last entry in this table
  ;  and moving backwards.
  ;The number of entries in this table must be AT LEAST as big as the largest
  ;  number of Aliases for a single command Option.  Most Options don't have
  ;  more than a dozen or so Aliases.
  ;----------------------------------------------------------------------------
  AliasSortTbl: DW 50 DUP (?) ;Table to store Alias Strings (to reverse order)


;==============================================================================
;Miscellaneous Data
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Miscellaneous Yes/No Flags
  ;----------------------------------------------------------------------------
  MiscFlags     DB  ?  ;Miscellaneous Yes/No Flags
    EndOfDescr EQU 01h ;Done processing a Descriptor Entry

  ;----------------------------------------------------------------------------
  ;Flag to Print All Vendor ID's instead of just one
  ;----------------------------------------------------------------------------
  DoAllVendors DB No

  ;----------------------------------------------------------------------------
  ;Number of Spaces to Indent while printing things
  ;----------------------------------------------------------------------------
  Indent DB ?


;==============================================================================
;EXEC Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Variables to Locate and Run another Program (EXEC Child Program)
  ;----------------------------------------------------------------------------
  PathToUse:       DB MaxPathSize DUP (0) ;Path to Use
  OurPathPointer   DW -1                  ;Pointer to our Path String
  CurrentPath:     DB  0                  ;Current Path (Zero-Length ASCIIZ)
  SupportFileVend: DB 'VENDORID.COM',0    ;Support File for Vendor Codes
  SupportFileUni:  DB 'UNI2ASCI.COM',0    ;Support File for UniCode Translation
  SupportFileHID:  DB 'HIDSUPT1.COM',0    ;Support File for Human Interface
                                          ;  Device Report & Physical Descr's

  PathVarString1:  DB 'PATH='             ;PATH Environment String Header (DOS)
  PathVarString2:  DB 'Path='             ;PATH Environment String Header (NT?)
  PathVarSize     EQU $-PathVarString2    ;Length of String
  PathVarPointer   DW -1                  ;Pointer to PATH Environment Variable

  ;----------------------------------------------------------------------------
  ;Variables needed to do EXEC Call
  ;----------------------------------------------------------------------------
  CmdTailSize DB CmdTailMax-2           ;Length of command tail (Maximize it)
  CmdTail:    DB CmdTailMax DUP (CR)    ;Command Tail for EXEC Call
  ParamBlock: DB ParamBlockSize DUP (?) ;Parameter Block for EXEC Call
  FCB1:       DB FCBSize DUP (?)        ;File Control Block #1
  FCB2:       DB FCBSize DUP (?)        ;File Control Block #2
  OldSPExec   DW ?                      ;SP may be destroyed by EXEC Call

  ;----------------------------------------------------------------------------
  ;Strings needed to EXEC VENDORID.COM
  ;----------------------------------------------------------------------------
  AllMsg: DB 'USB A',0
  USBMsg: DB 'USB',0

  ;----------------------------------------------------------------------------
  ;Strings needed to EXEC HIDSUPT1 file for various Options
  ;----------------------------------------------------------------------------
  PhysBiasMsg:   DB 'PhysicalBias',0
  PhysDescrMsg:  DB 'PhysicalDescr',0
  PhysDesigMsg:  DB 'PhysicalDesignator',0
  PhysQualMsg:   DB 'PhysicalQualifier',0

  RptCollMsg:    DB 'RptCollection',0
  RptDelimitMsg: DB 'RptDelimiter',0
  RptDescrMsg:   DB 'RptDescr',0
  RptTagMsg:     DB 'RptTag',0

  UsageMsg:      DB 'Usage',0
  UsagePageMsg:  DB 'UsagePage',0

  ;----------------------------------------------------------------------------
  ;Error Message for when the Support File is not found
  ;----------------------------------------------------------------------------
  NoSuptFileMsg:
    DB 'Error! Need Support File ',0


;==============================================================================
;Data needed to determine who our Parent Program is
;==============================================================================

  ;----------------------------------------------------------------------------
  ;ASCIIZ Name of our Parent (the name stored in the MCB for our Parents PSP)
  ;----------------------------------------------------------------------------
  ParentName: DB 9 DUP (0)

  ;----------------------------------------------------------------------------
  ;Is our Parent a DOS Shell?
  ;----------------------------------------------------------------------------
  ParentIsShell DB No

  ;----------------------------------------------------------------------------
  ;CallBack Address that may be provided by another program
  ;An offset of -1 (the first word) indicates an invalid address
  ;----------------------------------------------------------------------------
  CallBackAddr DD -1

  ;----------------------------------------------------------------------------
  ;Table of possible DOS Shell programs (COMMAND.COM or equivalents)
  ;Must be capitalized, 8 characters ASCIIZ (not including 0 at end) max
  ;More things could be added to this table if they are discovered;
  ;  e.g., if FreeDOS or DR DOS or ... use a Shell Name other than COMMAND
  ;----------------------------------------------------------------------------
  DOSShellTbl:
    DB 'COMMAND',0 ;Standard DOS
    DB 'CMD',0     ;Windows NT & IBM OS/2
    DB 'NDOS',0    ;Norton Shell (from Norton Utilities)
    DB '4DOS',0    ;4DOS
    DB '4NT',0     ;4NT
    DB '4OS2',0    ;4OS2
    DB 0           ;End of Table


;==============================================================================
;USB Related
;==============================================================================

  ;------------------------------------------------------------------------------
  ;Data Structure needed to issue Requests to the USB Host
  ;------------------------------------------------------------------------------
  EVEN 2
  Int14Request:
    DB Int14RequestSize DUP (0)

  ;----------------------------------------------------------------------------
  ;Get String Descriptor
  ;----------------------------------------------------------------------------
  GetStringDescrReq:     DB SRRTIn+SRRTTypeStandard+SRRTRecipDevice
                         DB SRRQGetDescriptor
  GetStringIndex:        DB ?               ;String Index
                         DB DescrTypeString ;Type = String (High Byte of SRValue)
  GetStringLanguageID:   DW 0409h           ;Language ID = English
  GetStringDescrReqSize: DW MaxStrSize      ;Maximum Size

  I14RStringDescrSize EQU I14RSetupReqData.SRLength ;Word

  StringDescrData: DB (MaxStrSize+2) DUP (0) ;Data returned by String Descriptor
  GotStringDescr   DW -1                     ;Flag to monitor when it's done


;==============================================================================
;Data Needed to Process the Command Line
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Data needed to Parse the command line for Options
  ;----------------------------------------------------------------------------
  ParseError DB No ;Error while Parsing Command Line?

  ;----------------------------------------------------------------------------
  ;Data needed to process a Device Description Request
  ;  This stores the Class, SubClass, Protocols for the Device and Interface
  ;----------------------------------------------------------------------------
  DvcDescriptionData:
    DB 6 DUP (0)

  ;----------------------------------------------------------------------------
  ;Codes for different Command-Line Switches
  ;NOTE: The numerical order here is what the Alias Option uses to sort things.
  ;----------------------------------------------------------------------------
  AliasSwitch              EQU  1
  ControlPktSwitch         EQU  2
  CountrySwitch            EQU  3
  DescriptorSwitch         EQU  4
  DescriptorTypeSwitch     EQU  5
  DeviceClassSwitch        EQU  6
  DeviceDescriptionSwitch  EQU  7
  DeviceProtocolSwitch     EQU  8
  DeviceSubClassSwitch     EQU  9
  DialectSwitch            EQU 10
  I14RErrorSwitch          EQU 11
  Int14StrucSwitch         EQU 12
  InterfaceClassSwitch     EQU 13
  InterfaceProtocolSwitch  EQU 14
  InterfaceSubClassSwitch  EQU 15
  LanguageSwitch           EQU 16
  PhysicalBiasSwitch       EQU 17
  PhysicalDescrSwitch      EQU 18
  PhysicalDesignatorSwitch EQU 19
  PhysicalQualifierSwitch  EQU 20
  ReportCollectionSwitch   EQU 21
  ReportDelimiterSwitch    EQU 22
  ReportDescrSwitch        EQU 23
  ReportTagSwitch          EQU 24
  StringLanguageSwitch     EQU 25
  TDStatusSwitch           EQU 26
  UsageSwitch              EQU 27
  UsagePageSwitch          EQU 28
  VendorSwitch             EQU 29

  TestSwitch               EQU 50 ;Use Test Descriptor

  ;----------------------------------------------------------------------------
  ;Command Line Options
  ;----------------------------------------------------------------------------
  SwitchList:
    DB 'Vendr',0
    DB 'Vendor',0
    DB  0, VendorSwitch

    DB 'UsagePage',0
    DB  0, UsagePageSwitch

    DB 'Usage',0
    DB  0, UsageSwitch

    DB 'Test',0
    DB 0, TestSwitch

    DB 'TDStsCode',0
    DB 'TDSts',0
    DB 'TDStatusCode',0
    DB 'TDStatus',0
    DB  0, TDStatusSwitch

    DB 'StringLanguage',0
    DB 'StringLang',0
    DB  0, StringLanguageSwitch

    DB 'SetupPkt',0
    DB 'SetupPacket',0
    DB  0, ControlPktSwitch

    DB 'RptTag',0
    DB  0, ReportTagSwitch

    DB 'RptDescriptor',0
    DB 'RptDescr',0
    DB  0, ReportDescrSwitch

    DB 'RptDelimiter',0
    DB  0, ReportDelimiterSwitch

    DB 'RptCollection',0
    DB  0, ReportCollectionSwitch

    DB 'ReportTag',0
    DB  0, ReportTagSwitch

    DB 'ReportDescriptor',0
    DB 'ReportDescr',0
    DB  0, ReportDescrSwitch

    DB 'ReportDelimiter',0
    DB  0, ReportDelimiterSwitch

    DB 'ReportCollection',0
    DB  0, ReportCollectionSwitch

    DB 'PhysicalQualifier',0
    DB  0, PhysicalQualifierSwitch

    DB 'PhysicalDesignator',0
    DB  0, PhysicalDesignatorSwitch

    DB 'PhysicalDescriptor',0
    DB 'PhysicalDescr',0
    DB  0, PhysicalDescrSwitch

    DB 'PhysicalBias',0
    DB  0, PhysicalBiasSwitch

    DB 'OptionAliases',0
    DB 'OptionAlias',0
    DB  0, AliasSwitch

    DB 'Language',0
    DB 'Lang',0
    DB  0, LanguageSwitch

    DB 'IntfSubClass',0
    DB  0, InterfaceSubClassSwitch

    DB 'IntfProtocol',0
    DB  0, InterfaceProtocolSwitch

    DB 'IntfClass',0
    DB 'Intf',0
    DB  0, InterfaceClassSwitch

    DB 'Interrupt14Structure',0
    DB 'Interrupt14Struc',0
    DB  0, Int14StrucSwitch

    DB 'Interrupt14RequestStructure',0
    DB 'Interrupt14RequestStruc',0
    DB  0, Int14StrucSwitch

    DB 'Interrupt14RequestError',0
    DB 'Interrupt14RequestErr',0
    DB  0, I14RErrorSwitch

    DB 'Interrupt14Request',0
    DB  0, Int14StrucSwitch

    DB 'Interrupt14ReqStructure',0
    DB 'Interrupt14ReqStruc',0
    DB  0, Int14StrucSwitch

    DB 'Interrupt14ReqErrorCode',0
    DB 'Interrupt14ReqError',0
    DB  0, I14RErrorSwitch

    DB 'Interrupt14ReqErrCode',0
    DB 'Interrupt14ReqErr',0
    DB  0, I14RErrorSwitch

    DB 'Interrupt14Req',0
    DB  0, Int14StrucSwitch

    DB 'Interrupt14ErrorCode',0
    DB 'Interrupt14Error',0
    DB  0, I14RErrorSwitch

    DB 'Interrupt14ErrCode',0
    DB 'Interrupt14Err',0
    DB  0, I14RErrorSwitch

    DB 'InterfaceSubClass',0
    DB  0, InterfaceSubClassSwitch

    DB 'InterfaceProtocol',0
    DB  0, InterfaceProtocolSwitch

    DB 'InterfaceClass',0
    DB 'Interface',0
    DB  0, InterfaceClassSwitch

    DB 'Int14Structure',0
    DB 'Int14Struc',0
    DB  0, Int14StrucSwitch

    DB 'Int14RequestStructure',0
    DB 'Int14RequestStruc',0
    DB  0, Int14StrucSwitch

    DB 'Int14RequestError',0
    DB 'Int14RequestErr',0
    DB  0, I14RErrorSwitch

    DB 'Int14Request',0
    DB  0, Int14StrucSwitch

    DB 'Int14ReqStructure',0
    DB 'Int14ReqStruc',0
    DB  0, Int14StrucSwitch

    DB 'Int14ReqErrorCode',0
    DB 'Int14ReqError',0
    DB  0, I14RErrorSwitch

    DB 'Int14ReqErrCode',0
    DB 'Int14ReqErr',0
    DB  0, I14RErrorSwitch

    DB 'Int14Req',0
    DB  0, Int14StrucSwitch

    DB 'Int14ErrorCode',0
    DB 'Int14Error',0
    DB  0, I14RErrorSwitch

    DB 'Int14ErrCode',0
    DB 'Int14Err',0
    DB  0, I14RErrorSwitch

    DB 'DvcSubClass',0
    DB  0, DeviceSubClassSwitch

    DB 'DvcProtocol',0
    DB  0, DeviceProtocolSwitch

    DB 'DvcDescription',0
    DB  0, DeviceDescriptionSwitch

    DB 'DvcClass',0
    DB 'Dvc',0
    DB  0, DeviceClassSwitch

    DB 'Dialect',0
    DB  0, DialectSwitch

    DB 'DeviceSubClass',0
    DB  0, DeviceSubClassSwitch

    DB 'DeviceProtocol',0
    DB  0, DeviceProtocolSwitch

    DB 'DeviceDescription',0
    DB  0, DeviceDescriptionSwitch

    DB 'DeviceClass',0
    DB 'Device',0
    DB  0, DeviceClassSwitch

    DB 'DescrType',0
    DB 'DescriptorType',0
    DB  0, DescriptorTypeSwitch

    DB 'Descriptor',0
    DB 'Descr',0
    DB  0, DescriptorSwitch

    DB 'CtrlSetupPkt',0
    DB 'CtrlSetupPacket',0
    DB 'CtrlPkt',0
    DB 'CtrlPacket',0
    DB 'Ctrl',0
    DB  0, ControlPktSwitch

    DB 'CtlSetupPkt',0
    DB 'CtlSetupPacket',0
    DB 'CtlPkt',0
    DB 'CtlPacket',0
    DB 'Ctl',0
    DB  0, ControlPktSwitch

    DB 'Country',0
    DB  0, CountrySwitch

    DB 'ControlSetupPkt',0
    DB 'ControlSetupPacket',0
    DB 'ControlPkt',0
    DB 'ControlPacket',0
    DB 'Control',0
    DB  0, ControlPktSwitch

    DB 'CommandLineAliases',0
    DB 'CommandLineAlias',0
    DB  0, AliasSwitch

    DB 'CmdLineAliases',0
    DB 'CmdLineAlias',0
    DB  0, AliasSwitch

    DB 'Aliases',0
    DB 'Alias',0
    DB  0, AliasSwitch

    DB  0 ;End of list

  ;----------------------------------------------------------------------------
  ;Table of Subroutine Offsets to Process the Various Command Line Options
  ;----------------------------------------------------------------------------
  SwitchTbl:
    DB AliasSwitch
       DW DoSwitchAlias
    DB ControlPktSwitch
       DW DoSwitchControlPkt
    DB CountrySwitch
       DW DoSwitchCountry
    DB DescriptorSwitch
       DW DoSwitchDescriptor
    DB DescriptorTypeSwitch
       DW DoSwitchDescriptorType
    DB DeviceClassSwitch
       DW DoSwitchDeviceClass
    DB DeviceDescriptionSwitch
       DW DoSwitchDvcDescription
    DB DeviceSubClassSwitch
       DW DoSwitchDeviceSubClass
    DB DeviceProtocolSwitch
       DW DoSwitchDeviceProtocol
    DB DialectSwitch
       DW DoSwitchDialect
    DB I14RErrorSwitch
       DW DoSwitchI14RError
    DB Int14StrucSwitch
       DW DoSwitchInt14Structure
    DB InterfaceClassSwitch
       DW DoSwitchInterfaceClass
    DB InterfaceSubClassSwitch
       DW DoSwitchInterfaceSubClass
    DB InterfaceProtocolSwitch
       DW DoSwitchInterfaceProtocol
    DB LanguageSwitch
       DW DoSwitchLanguage
    DB PhysicalBiasSwitch
       DW DoSwitchPhysicalBias
    DB PhysicalDescrSwitch
       DW DoSwitchPhysicalDescr
    DB PhysicalDesignatorSwitch
       DW DoSwitchPhysicalDesignator
    DB PhysicalQualifierSwitch
       DW DoSwitchPhysicalQualifier
    DB ReportCollectionSwitch
       DW DoSwitchReportCollection
    DB ReportDelimiterSwitch
       DW DoSwitchReportDelimiter
    DB ReportDescrSwitch
       DW DoSwitchReportDescr
    DB ReportTagSwitch
       DW DoSwitchReportTag
    DB StringLanguageSwitch
       DW DoSwitchStringLanguage
    DB TDStatusSwitch
       DW DoSwitchTDStatus
    DB UsageSwitch
       DW DoSwitchUsage
    DB UsagePageSwitch
       DW DoSwitchUsagePage
    DB VendorSwitch
       DW DoSwitchVendor

    DB TestSwitch
       DW DoSwitchTest

    DB 0 ;End of Table


;==============================================================================
;Data needed to write USB Vendor ID Data
;Note that writing Vendor Data calls another support program (VENDORID.COM)
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Screen Header needed to print the Entire Vendor Table
  ;----------------------------------------------------------------------------
  AllVendorHdr:
    DB ' ID                   USB VENDOR',CR,LF
    DB 'ÄÄÄÄÄ  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ',CR,LF
    DB 0


;==============================================================================
;Tables related to the INT 14h API (the API we developed)
;==============================================================================
  ;----------------------------------------------------------------------------
  ;Possible Error Codes to return to calling program on completion of TD
  ;  Errors are bit-mapped, and can have more than one at a time
  ;----------------------------------------------------------------------------
  TDStsTbl:
    DB TblFlagWord+TblFlagBitMap+TblFlagSequential
    DB 'NAK',0                  ;0001h = TDStsNAKReceived
    DB 'Stalled',0              ;0002h = TDStsStalled
    DB 'Ctrl/Bulk Timed Out',0  ;0004h = TDStsTimeout
    DB 'Int/Isoch OverDue',0    ;0008h = TDStsOverDue
    DB 'Short Packet',0         ;0010h = TDStsShortPacket
    DB 'Babble',0               ;0020h = TDStsBabbleDetected
    DB 'CRC/Timeout',0          ;0040h = TDStsCRCTOReceived
    DB 'Bit-Stuffing',0         ;0080h = TDStsBitStuffErr
    DB 'Data Buffer',0          ;0100h = TDStsDataBuffErr
    DB 0                        ;0200h = Nada
    DB 0                        ;0400h = Nada
    DB 0                        ;0800h = Nada
    DB 'Error in Setup Stage',0 ;1000h = TDStsControlSetup
    DB 'Device Removed',0       ;2000h = TDStsDvcRemoved
    DB 0                        ;4000h = Nada
    DB 'Large Call',0           ;8000h = TDStsLargeCallErr

    TDStsSuccessMsg: DB 'ACK (Success)',0

  ;----------------------------------------------------------------------------
  ;Error Codes Returned by Int 14h Requests
  ;----------------------------------------------------------------------------
  I14RErrorCodeTbl:
    DB TblFlagWord
    DW I14RErrNone
       DB 'No Error (Success)',0
    DW I14RErrResources
       DB 'Insufficient Resources/Memory',0
    DW I14RErrHostHardware
       DB 'Unknown/Hardware Problem with Host',0
    DW I14RErrReqTypeNoSupt
       DB 'Request Type recognized, not Supported',0
    DW I14RErrRequestType
       DB 'Invalid Request Type',0
    DW I14RErrFlags
       DB 'Invalid Flags',0
    DW I14RErrHostIndex
       DB 'Invalid Host Index',0
    DW I14RErrDeviceAddress
       DB 'Invalid Device Address',0
    DW I14RErrEndPoint
       DB 'Invalid EndPoint / Hub Port / Alt Intf',0
    DW I14RErrConfigValue
       DB 'Invalid Config / Closure / DataX Value',0
    DW I14RErrInterfaceNum
       DB 'Invalid Interface Number',0
    DW I14RErrSearchIndex
       DB 'Invalid Search Index',0
    DW I14RErrVendorProdID
       DB 'Invalid Vendor ID',0
    DW I14RErrDvcIntf
       DB 'Invalid Device / Interface Value',0
    DW I14RErrRequestHandle
       DB 'Invalid Request Handle',0
    DW I14RErrPeriodicity
       DB 'Invalid Periodicity / Beep Frequency',0
    DW I14RErrTimeOut
       DB 'Invalid Timeout',0
    DW I14RErrDataAddress
       DB 'Invalid Data Address',0
    DW I14RErrDataSize
       DB 'Invalid Data Size',0
    DW I14RErrCallBackAddr
       DB 'Invalid CallBack Addr / Large Rtn Code',0
    DW I14RErrUserPktID
       DB 'Invalid User Packet ID',0
    DW I14RErrSetupReqData
       DB 'Invalid Setup Request Data',0
    DW I14RErrFrameTiming
       DB 'Invalid Frame Timing / Frame Index',0
    DW I14RErrIsochArray
       DB 'Invalid Entry in Isochronous Array Data',0
    DW I14RErrHostHalted
       DB 'Host is Halted/Suspended',0
    DW I14RErrIntfNotFound
       DB 'Interface not found',0
    DW I14RErrIntfInConfig
       DB 'Interface on Device is being Configured',0
    DW I14RErrIntfAlreadyReg
       DB 'Interface already Registered',0
    DW I14RErrHostCallInUse
       DB 'Host Run/Stop/etc. already running',0
    DW I14RErrNoPortPower
       DB 'Per-Port-Power not Supported by Hub',0
    DW I14RErrAlreadyBeeping
       DB 'Another Beep Request is in progress',0
    DW I14RErrDebugMode
       DB 'Tried to Single Step with No Debug Mode',0
    DW I14RErrTimingOwned
       DB 'Problem with Frame Timing Owner',0
    DW I14RErrTimingLimit
       DB 'Frame Timing is already at the Limit',0
    DW I14RErrTmgChgInProg
       DB 'Timing Change already in progress',0
    DW    0   ;End of
       DB -1  ;  Table

  ;----------------------------------------------------------------------------
  ;INT 14h Request Structure
  ;----------------------------------------------------------------------------
  Int14ReqStrucTbl:
    DW DoNothing
        DB DTagHdrOnly +0, 'INTERRUPT 14h USB REQUEST',0
    DW DoI14RRequestType
        DB DTagColon   +1, 'Request Type',0
    DW DoI14RFlags
        DB DTagColon   +1, 'Flags',0
    DW DoI14RHostIndex
        DB DTagColon   +1, 'Host Index',0
    DW WriteByteMin
        DB DTagColon   +1, 'Device/Hub Address',0
    DW WriteByteMin
        DB DTagColon   +1, 'EndPoint/Port/AltIntf',0
    DW WriteByteMin
        DB DTagColon   +1, 'Config/CloseID/DataX',0
    DW WriteByteMin
        DB DTagColon   +1, 'Interface Number',0
    DW WriteDTagSLine
        DB DTagSkip    +0, 0
    DW WriteByteMin
        DB DTagColon   +1, 'Search Index',0
    DW DoI14RVendorID
        DB DTagColon   +2, 'Vendor ID',0
    DW DoI14RProductID
        DB DTagColon   +2, 'Product ID',0
    DW DoI14RDvcClass
        DB DTagColon   +1, 'Device Class',0
    DW DoI14RDvcSubClass
        DB DTagColon   +1, 'Device SubClass',0
    DW DoI14RDvcProtocol
        DB DTagColon   +1, 'Device Protocol',0
    DW DoI14RIntfClass
        DB DTagColon   +1, 'Interface Class',0
    DW DoI14RIntfSubClass
        DB DTagColon   +1, 'Interface SubClass',0
    DW DoI14RIntfProtocol
        DB DTagColon   +1, 'Interface Protocol',0
    DW WriteDTagSLine
        DB DTagSkip    +0, 0
    DW WriteWordMin
        DB DTagColon   +2, 'Request Handle Num',0
    DW WriteWordMin
        DB DTagColon   +2, 'Periodicity/Frequency',0
    DW DoI14RTimeout
        DB DTagColon   +2, 'Timeout (DeciSeconds)',0
    DW DoI14RDataAddress
        DB DTagColon   +4, 'Data Address',0
    DW WriteWordMin
        DB DTagColon   +2, 'Data Size',0
    DW WriteSegmentOffset
        DB DTagColon   +4, 'CallBack Addr/RtnCode',0
    DW WriteWordMin
        DB DTagColon   +2, 'User Packet ID',0
    DW WriteDTagSLine
        DB DTagSkip    +0, 0
    DW DoSetupReqType
        DB DTagColon   +1, 'Setup Request Type',0
    DW DoSetupReqRequest
        DB DTagColon   +1, 'Setup Request',0
    DW DoSetupReqValue
        DB DTagColon   +2, 'Setup Request Value',0
    DW DoSetupReqIndex
        DB DTagColon   +2, 'Setup Request Index',0
    DW WriteWordMin
        DB DTagColon   +2, 'Setup Request Length',0
    DW WriteDTagSLine
        DB DTagSkip    +0, 0
    DW WriteWordMin
        DB DTagColon   +2, 'Frame Timing/Index',0
    DW WriteSegmentOffset
        DB DTagColon   +4, 'Isoch Schedule Addr',0
    DW WriteDTagSLine
        DB DTagSkip    +0, 0
    DW FinishInt14ReqDescr
        DB DTagSkip+DTagEndOfDescr+0, 0
    DW 0 ;End of Table!!

  ;----------------------------------------------------------------------------
  ;INT 14h Request Flags
  ;----------------------------------------------------------------------------
  I14RFlagsTbl:
    DB 01h, 'Direction = ',0
    DB 00h, 'Out (Host to Device',0
    DB 01h, 'In (Device to Host',0
    DB      ')',0

    DB 06h, 0
    DB 00h, 'Full-Speed Device (12Mbps)',0
    DB 02h, 'Low-Speed Device (1.5Mbps)',0
    DB 04h, 'Hi-Speed Device (480Mbps)',0
    DB 06h, 'Illegal Speed Code!',0
    DB      0

    DB 10h, ,0
    DB 00h, '8 ',0
    DB 10h, 'No ',0
    DB      'Auto-Retries for Control Requests',0

    DB 20h, ,0
    DB 00h, ,0
    DB 20h, 'No ',0
    DB      'Auto-Retries for Short Packet Errors',0

    DB 40h, 'Use ',0
    DB 00h, 'Next Available Frame',0
    DB 40h, 'Specific Frame Number',0
    DB      0

    DB 80h, 'Data Address is ',0
    DB 00h, 'Segment:Offset',0
    DB 80h, 'is 32-bit Physical',0
    DB      0

    DB  0  ;End of Table

  ;----------------------------------------------------------------------------
  ;INT 14h Request Types
  ;----------------------------------------------------------------------------
  I14RRequestTypeTbl:
    DB -1, 0
    ;Host (00h)
    DB I14RRTGetHostSWInfo,   'Get Host Software Info',0
    DB I14RRTGetHostHWInfo,   'Get Host Hardware Info',0
    DB I14RRTGetHostVendInfo, 'Get Host Vendor Info',0
    DB I14RRTGetHostStatus,   'Get Host Status',0
    DB I14RRTHostRun,         'Start/Run/Resume Host',0
    DB I14RRTHostStop,        'Stop Host',0
    DB I14RRTHostReset,       'Reset Host',0
    DB I14RRTHostSuspend,     'Global Suspend on Host',0
    DB I14RRTHostResume,      'Force Global Resume on Host',0
    ;Timing (10h)
    DB I14RRTRegTmgOwner,     'Register as Frame Timing Owner',0
    DB I14RRTUnRegTmgOwner,   'UnRegister as Frame Timing Owner',0
    DB I14RRTIncTiming,       'Increment (Slow Down) Frame Timing',0
    DB I14RRTDecTiming,       'Decrement (Speed Up) Frame Timing',0
    DB I14RRTChangeTiming,    'Change Frame Timing (by Large Amount)',0
    ;Hub (20h)
    DB I14RRTGetDvcHubInfo,   'Get Hub Info for Device',0
    DB I14RRTNewDvcConn,      'Hub has Detected a New Device',0
    DB I14RRTDvcDisc,         'Device has been Disconnected from Hub',0
    DB I14RRTSendHubChar,     'Send Hub Characteristics to Host',0
    DB I14RRTEnableHubPort,   'Enable Device given Hub Addr & Port',0
    DB I14RRTDisableHubPort,  'Disable Device given Hub Addr & Port',0
    DB I14RRTResetHubPort,    'Reset Device given Hub Addr & Port',0
    DB I14RRTSuspendHubPort,  'Suspend Device given Hub Addr & Port',0
    DB I14RRTResumeHubPort,   'Resume Device given Hub Addr & Port',0
    DB I14RRTPwrOnHubPort,    'Power On Device given Hub Addr & Port',0
    DB I14RRTPwrOffHubPort,   'Power Off Device given Hub Addr & Port',0
    DB I14RRTPwrResetHubPort, 'Power Reset Device given Hub Addr & Port',0
    ;Power (30h)
    DB I14RRTGetDvcPowerInfo, 'Get Power Info for Device',0
    DB I14RRTGetHubPowerDraw, 'Get Power Draw Info for Hub/Port',0
    DB I14RRTPwrOnDevice,     'Power On Device given Device Addr',0
    DB I14RRTPwrOffDevice,    'Power Off Device given Device Addr',0
    DB I14RRTPwrResetDevice,  'Power Reset Device given Device Addr',0
    ;Device (40h)
    DB I14RRTGetDvcClassInfo, 'Get Device Class Info',0
    DB I14RRTGetDvcVendInfo,  'Get Device Vendor Info',0
    DB I14RRTGetDvcStatus,    'Get Device Status',0
    DB I14RRTEnableDevice,    'Enable/Resume Device given Device Addr',0
    DB I14RRTDisableDevice,   'Disable Device given Device Addr',0
    DB I14RRTResetDevice,     'Reset Device given Device Addr',0
    DB I14RRTSuspendDevice,   'Suspend Device given Device Addr',0
    DB I14RRTResumeDevice,    'Resume Device given Device Addr',0
    ;Config (50h)
    DB I14RRTConfigingIntf,   'Interface is being Configured',0
    DB I14RRTConfigIntfDone,  'Interface Configuration is Completed',0
    DB I14RRTSetNewConfig,    'Set/Change Device Configuration Value',0
    ;Interface (60h)
    DB I14RRTFindRegIntf,     'Look for Registered Interface',0
    DB I14RRTFindUnRegIntf,   'Look for Unregistered Interface',0
    DB I14RRTRegIntfOwner,    'Register as Interface/Device0 Owner',0
    DB I14RRTUnRegIntfOwner,  'UnRegister as Interface/Device0 Owner',0
    DB I14RRTIntfDontLook,    'Notify Current Intf Owner to Unregister',0
    ;Alt Interface (70h)
    DB I14RRTGetAltIntfInfo,  'Get Alternate Interface Info',0
    ;EndPoint (80h)
    DB I14RRTGetDataX,        'Get Current DataX Value',0
    DB I14RRTIncDataX,        'Increment/Toggle DataX Value',0
    ;Packet (90h)
    DB I14RRTDoIsoch,         'Schedule Isochronous Packet',0
    DB I14RRTDoInterruptPer,  'Schedule Periodic Interrupt Packet',0
    DB I14RRTDoControl,       'Send Control (Setup) Packet',0
    DB I14RRTDoBulk,          'Send Bulk Packet',0
    DB I14RRTDoInterrupt1T,   'Schedule One-time Interrupt Packet',0
    DB I14RRTCloseHandle,     'Close Scheduled Packet Handle',0
    DB I14RRTChangeIntPer,    'Change Periodicity of Periodic Interrupt',0
    DB I14RRTGetTransStatus,  'Get Status of Packet Transaction',0
    ;Misc (A0h)
    DB I14RRTLargeCallDone,   'A Large Call has been completed',0
    DB I14RRTBeepSpeaker,     'Beep the Speaker',0
    ;InterHost (E0h)
    DB I14RRTHostAdded,       'New Host Driver has been installed',0
    DB I14RRTHostDeleted,     'Host Driver is being removed from Memory',0
    DB I14RRTRegDvc0Host,     'Inform Hosts of Device 0 Registry',0
    DB I14RRTUnRegDvc0Host,   'Inform Hosts of Device 0 UnRegistry',0
    DB I14RRTCopyNDTable,     'Copy New Device Notification Table',0
    ;Internal (F0h)
    DB I14RRTHostDebug,       'Put Host in Debug Mode (UHCI)',0
    DB I14RRTHostSingleStep,  'Single-Step Host (UHCI)',0
    ;Default
    DB -1,                    'Unknown Request Type',0
    DB                        0
    DB  0

  ;----------------------------------------------------------------------------
  ;Strings for Certain Types of Default INT 14h Searches
  ;----------------------------------------------------------------------------
  AllHostsMsg:
    DB 'Any/All Hosts',0
  AnyVendorMsg:
    DB 'Any Vendor',0
  AnyProductMsg:
    DB 'Any Product',0
  AnyDvcClassMsg:
    DB 'Any Device Class',0
  AnyDvcSubClassMsg:
    DB 'Any Device SubClass',0
  AnyDvcProtocolMsg:
    DB 'Any Device Protocol',0
  AnyIntfClassMsg:
    DB 'Any Interface Class',0
  AnyIntfSubClassMsg:
    DB 'Any Interface SubClass',0
  AnyIntfProtocolMsg:
    DB 'Any Interface Protocol',0
  DefaultMsg:
    DB 'Use Default',0


;==============================================================================
;Tables related to Control Packets
;We do not have tables here for all possible Control Packets, because
;  many of them are uncommon, or are Device or Category-specific
;We only have Tables here for some of the most common Control Requests
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Basic Control Packet Structure
  ;----------------------------------------------------------------------------
  ControlPktTbl:
    DW DoNothing
        DB DTagHdrOnly             +0, 'CONTROL (SETUP) PACKET',0
    DW DoSetupReqType
        DB DTagColon               +1, 'Setup Request Type',0
    DW DoSetupReqRequest
        DB DTagColon               +1, 'Setup Request',0
    DW DoSetupReqValue
        DB DTagColon               +2, 'Setup Request Value',0
    DW DoSetupReqIndex
        DB DTagColon               +2, 'Setup Request Index',0
    DW WriteWordMin
        DB DTagEndOfDescr+DTagColon+2, 'Setup Request Length',0
    DW 0 ;End of Table!!


  ;----------------------------------------------------------------------------
  ;Control Packet: Request Type (Direction and Recipient)
  ;----------------------------------------------------------------------------
  SetupReqRecipientTbl:
    DB 1Fh, 'Recipient = ',0
    DB 00h, 'Device',0
    DB 01h, 'Interface',0
    DB 02h, 'EndPoint',0
    DB 03h, 'Other',0
    DB 1Fh, 'Unknown',0
    DB      0

    DB 60h, 'Category  = ',0
    DB 00h, 'Standard',0
    DB 20h, 'Class',0
    DB 40h, 'Vendor',0
    DB 60h, 'Unknown',0
    DB      0

  InOutDirectionTbl:
    DB 80h, 'Direction = ',0
    DB 00h, 'Out',0
    DB 80h, 'In',0
    DB      0
    DB  0 ;End of Table


  ;----------------------------------------------------------------------------
  ;Control Packet: Specific Request
  ;----------------------------------------------------------------------------
  SetupReqRequestTbl:
    DB -1,  0
    DB 00h, 'Get Status',0
    DB 01h, 'Clear Feature',0
    DB 02h, 'Get State',0
    DB 03h, 'Set Feature',0
;    DB 04h, 'Error!',0
    DB 05h, 'Set Address',0
    DB 06h, 'Get Descriptor',0
    DB 07h, 'Set Descriptor',0
    DB 08h, 'Get Configuration',0
    DB 09h, 'Set Configuration',0
    DB 0Ah, 'Get Interface',0
    DB 0Bh, 'Set Interface',0
    DB 0Ch, 'Synchronize Frame',0
    DB -1,  'Unknown Request Type',0
    DB      0
    DB  0 ;End of Table


  ;----------------------------------------------------------------------------
  ;Control Packet: Specific Request Values
  ;----------------------------------------------------------------------------
  SetupReqValueTbl:
    DB SRRQClearFeature
       DW DoClearFeature
    DB SRRQSetFeature
       DW DoSetFeature
    DB SRRQSetAddress
       DW DoSetAddress
    DB SRRQGetDescriptor
       DW DoGetDescriptor
    DB SRRQSetDescriptor
       DW DoSetDescriptor
    DB SRRQSetConfig
       DW DoSetConfig
    DB SRRQSetInterface
       DW DoSetInterface
    DB 0 ;End of Table

  DeviceFeatureTbl:
    DB TblFlagByte
    DB 01h, 'Remote Wakeup',0
    DB 02h, 'Test Mode',0
    DB 03h, 'Device B HNP Enable',0
    DB 04h, 'Device A HNP Support',0
    DB 05h, 'Device A HNP Alternate Support',0
    DB  0 , -1 ;End of Table

  InterfaceFeatureTbl:
    DB TblFlagByte
    DB  0 , -1 ;End of Table

  EndPointFeatureTbl:
    DB TblFlagByte
    DB 00h, 'Halt End Point',0
    DB  0 , -1 ;End of Table


;==============================================================================
;Table & Data needed to Print Descriptors
;==============================================================================

  ;----------------------------------------------------------------------------
  ;USB Descriptor Types
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;General Descriptors
  ;Most of these can appear in response to a "Get Full Configuration" Request
  ;Actually, all Descriptor Types >= 20h are Class-specific, so will vary
  ;  depending on the Device/Interface Class.  In this table, though,
  ;  we are including the HID and Hub Class-specific details, which will
  ;  not necessarily apply to other types of devices.
  ;----------------------------------------------------------------------------
  DescriptorTypeTbl:
    DB TblFlagByte
    DB 01h, 'Device',0
    DB 02h, 'Configuration',0
    DB 03h, 'String',0
    DB 04h, 'Interface',0
    DB 05h, 'EndPoint',0
    DB 06h, 'Device Qualifier',0
    DB 07h, 'Other Speed Configuration',0
    DB 08h, 'Interface Power (obsolete)',0
    DB 09h, 'On-The-Go',0
    DB 0Ah, 'Debug',0
    DB 0Bh, 'Interface Association',0
    ;Types 12 - 17 (0Ch - 11h) are added for Wireless USB
    DB 0Ch, 'Wireless USB Security',0
    DB 0Dh, 'Wireless USB Key',0
    DB 0Eh, 'Wireless USB Encryption Type',0
    DB 0Fh, 'Wireless USB Binary-device Object Store',0
    DB 10h, 'Wireless USB Device Capability',0
    DB 11h, 'Wireless USB Endpoint Companion',0

    DB  0 , -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;Class-specific Descriptor Strings
  ;----------------------------------------------------------------------------
    HIDDescrMsg: DB 'HID (Human Interface Device)',0
    HubDescrMsg: DB 'Hub',0

  ;----------------------------------------------------------------------------
  ;HID Device-Specific Descriptors
  ;----------------------------------------------------------------------------
  HIDDescriptorTypeTbl:
    DB TblFlagByte
    DB 22h, 'Report',0
    DB 23h, 'Physical',0
    DB  0 , -1 ;End of Table


;==============================================================================
;Audio Device Descriptors
;==============================================================================

  ;NOTE: Many Audio Version 1 and Version 2 Descriptors are incompatible
  ;        with each other (poor design of Audio Version 1 if you ask me).
  ;      Therefore, in order to interpret the Descriptors, it is necessary
  ;        to know the Audio Spec version (contained in one of the
  ;        Descriptors).

  ;----------------------------------------------------------------------------
  ;Class-Specific Audio Descriptor Types
  ;----------------------------------------------------------------------------
    DescrTypeAudioUndefined EQU 20h ;CS_Undefined
    DescrTypeAudioDevice    EQU 21h ;CS_Device
    DescrTypeAudioConfig    EQU 22h ;CS_Configuration
    DescrTypeAudioString    EQU 23h ;CS_String
    DescrTypeAudioInterface EQU 24h ;CS_Interface
    DescrTypeAudioEndPoint  EQU 25h ;CS_EndPoint

  ;----------------------------------------------------------------------------
  ;Class-Specific Audio v1 Control (AC) Interface Descriptor SubTypes
  ;----------------------------------------------------------------------------
    A1IntfDescSTypeACUndef    EQU 00h ;Undefined
    A1IntfDescSTypeACHeader   EQU 01h ;Header
    A1IntfDescSTypeACInTerm   EQU 02h ;Input Terminal
    A1IntfDescSTypeACOutTerm  EQU 03h ;Output Terminal
    A1IntfDescSTypeACMixUnit  EQU 04h ;Mixer Unit
    A1IntfDescSTypeACSelUnit  EQU 05h ;Selector Unit
    A1IntfDescSTypeACFtrUnit  EQU 06h ;Feature Unit
    A1IntfDescSTypeACProcUnit EQU 07h ;Processing Unit
    A1IntfDescSTypeACExtUnit  EQU 08h ;Extension Unit

  ;----------------------------------------------------------------------------
  ;Class-Specific Audio v2 Control (AC) Interface Descriptor SubTypes
  ;----------------------------------------------------------------------------
    A2IntfDescSTypeACUndef    EQU 00h ;Undefined
    A2IntfDescSTypeACHeader   EQU 01h ;Header
    A2IntfDescSTypeACInTerm   EQU 02h ;Input Terminal
    A2IntfDescSTypeACOutTerm  EQU 03h ;Output Terminal
    A2IntfDescSTypeACMixUnit  EQU 04h ;Mixer Unit
    A2IntfDescSTypeACSelUnit  EQU 05h ;Selector Unit
    A2IntfDescSTypeACFtrUnit  EQU 06h ;Feature Unit
    A2IntfDescSTypeACEFXUnit  EQU 07h ;Effect Unit
    A2IntfDescSTypeACProcUnit EQU 08h ;Processing Unit
    A2IntfDescSTypeACExtUnit  EQU 09h ;Extension Unit
    A2IntfDescSTypeACClkSrc   EQU 0Ah ;Clock Source
    A2IntfDescSTypeACClkSel   EQU 0Bh ;Clock Selector
    A2IntfDescSTypeACClkMul   EQU 0Ch ;Clock Multiplier
    A2IntfDescSTypeACSampCv   EQU 0Dh ;Sample Rate Converter

  ;----------------------------------------------------------------------------
  ;Class-Specific Audio v1 Streaming (AS) Interface Descriptor SubTypes
  ;----------------------------------------------------------------------------
    A1IntfDescSTypeASUndef   EQU 00h ;Undefined
    A1IntfDescSTypeASGeneral EQU 01h ;General
    A1IntfDescSTypeASFmtType EQU 02h ;Format Type
    A1IntfDescSTypeASFmtSpec EQU 03h ;Format Specific

  ;----------------------------------------------------------------------------
  ;Class-Specific Audio v2 Streaming (AS) Interface Descriptor SubTypes
  ;----------------------------------------------------------------------------
    A2IntfDescSTypeASUndef   EQU 00h ;Undefined
    A2IntfDescSTypeASGeneral EQU 01h ;General
    A2IntfDescSTypeASFmtType EQU 02h ;Format Type
    A2IntfDescSTypeASEncoder EQU 03h ;Encoder
    A2IntfDescSTypeASDecoder EQU 04h ;Decoder

  ;----------------------------------------------------------------------------
  ;Class-Specific Audio v2 Decoder Types
  ;----------------------------------------------------------------------------
    A2DecTypeUndef EQU 00h ;Undefined
    A2DecTypeOther EQU 01h ;Other
    A2DecTypeMPEG  EQU 01h ;MPEG
    A2DecTypeAC3   EQU 01h ;AC-3
    A2DecTypeWMA   EQU 01h ;WMA
    A2DecTypeDTS   EQU 01h ;DTS

  ;----------------------------------------------------------------------------
  ;Class-Specific MIDI Streaming (MS) Interface Descriptor SubTypes
  ;----------------------------------------------------------------------------
    AIntfDescSTypeMSUndef   EQU 00h ;Undefined
    AIntfDescSTypeMSHeader  EQU 01h ;Header
    AIntfDescSTypeMSJackIn  EQU 02h ;MIDI In Jack
    AIntfDescSTypeMSJackOut EQU 03h ;MIDI Out Jack
    AIntfDescSTypeMSElement EQU 04h ;Element

  ;----------------------------------------------------------------------------
  ;Audio Class-Specific EndPoint Descriptor SubTypes
  ;----------------------------------------------------------------------------
    AEndPtDescSTypeUndef   EQU 00h ;Undefined
    AEndPtDescSTypeGeneral EQU 01h ;General

  ;----------------------------------------------------------------------------
  ;MIDI Class-Specific EndPoint Descriptor SubTypes
  ;----------------------------------------------------------------------------
    MEndPtDescSTypeUndef   EQU 00h ;Undefined
    MEndPtDescSTypeGeneral EQU 01h ;General

  ;----------------------------------------------------------------------------
  ;MIDI In & MIDI Out Jack Types
  ;----------------------------------------------------------------------------
    MIDIJackTypeUndef  EQU 00h ;Undefined
    MIDIJackTypeEmbed  EQU 01h ;Embedded
    MIDIJackTypeExtern EQU 02h ;External

  ;----------------------------------------------------------------------------
  ;Audio Terminal Types
  ;----------------------------------------------------------------------------
   ;"Generic" USB Terminal Types
    AUTUndef      EQU 0100h ;USB Undefined
    AUTStream     EQU 0101h ;USB Streaming (on AudioStreaming Interface)
    AUTVendor     EQU 01FFh ;USB Vendor-specific (on Vendor=specific Interface)

   ;Input Terminal Types
    AITUndef      EQU 0200h ;Input Undefined
    AITMic        EQU 0201h ;Generic Microphone
    AITDTMic      EQU 0202h ;Desktop/Monitor Microphone
    AITPersMic    EQU 0203h ;Head-mounted or Clip-on Microphone
    AITOmniMic    EQU 0204h ;Multiple Speakers/Long Range Microphone
    AITMicArray   EQU 0205h ;Microphone Array (Host-based Signal Processing)
    AITProcMic    EQU 0206h ;Processing Microphone Array

   ;Output Terminal Types
    AOTUndef      EQU 0300h ;Output Undefined
    AOTSpeaker    EQU 0301h ;Generic Speaker
    AOTHdPhone    EQU 0302h ;Headphones/Head-mounted
    AOTHdMtVR     EQU 0303h ;Audio part of Head-mounted VR Display
                            ;  (HID Intf referenced in Associated Intf Descr)
    AOTDTSpkr     EQU 0304h ;Desktop/Monitor Speaker
    AOTRmSpkr     EQU 0305h ;Room Speaker
    AOTCommSpkr   EQU 0306h ;Voice Communications Speaker
    AOTLFreqFX    EQU 0307h ;Low Frequency Effects Speaker (Subwoofer)
                            ;  Not capable of Speech or Music

   ;Bidirectional Terminal Types
    ABTUndef      EQU 0400h ;Bidirectional Undefined
    ABTHandset    EQU 0401h ;Hand-held Device
    ABTHeadset    EQU 0402h ;Head-mounted Device
    ABTSpkrPhNE   EQU 0403h ;Hands-free with no Echo Reduction
                            ;  (Requires Host-based Echo cancellation)
    ABTSpkrPhES   EQU 0404h ;Hands-free with Echo Supression, Half Duplex
    ABTSpkrPhEC   EQU 0405h ;Hands-free with Echo Cancellation, Full Duplex

   ;Telephony Terminal Types
    ATTUndef      EQU 0500h ;Telephony Undefined
    ATTPhoneLine  EQU 0501h ;Analog Phone Jack, ISDN Line,
                            ;  Proprietary PBX Port, or Wireless Link
    ATTTelephone  EQU 0502h ;Telephone-type Device, can be used as a
                            ;  Bidirectional Audio Device when not a Phone
    ATTDownLine   EQU 0503h ;Standard Phone Set, can be used as a
                            ;  Bidirectional Audio Device when not a Phone

   ;External Terminal Types
    AXTUndef      EQU 0600h ;External Undefined
    AXTAnalog     EQU 0601h ;Generic Analog Connector
    AXTDigital    EQU 0602h ;Generic Digital Audio Interface
    AXTLineConn   EQU 0603h ;Analog Connector, Standard Line Levels,
                            ;  usually 3.5mm
    AXTLegacy     EQU 0604h ;Connection from Line Out of Legacy
                            ;  Host Computer Audio System
    AXTSPDIF      EQU 0605h ;S/PDIF Digital Audio Interface
    AXT1394Stream EQU 0606h ;Audio Stream on 1394 Bus
    AXT1394SndTrk EQU 0607h ;Soundtrack of A/V stream on 1394 Bus
    AXTADATLight  EQU 0608h ;ADAT (Alesis Digital Audio Tape) Lightpipe
    AXTTDIF       EQU 0609h ;Tascam Digital Interface
    AXTMADI       EQU 060Ah ;AES Multi-channel Audio Digital Interface

   ;Embedded Terminal Types
    AMTUndef      EQU 0700h ;Embedded Undefined
    AMTNoiseLvl   EQU 0701h ;Internal Noise Source for Level Calibration
                            ;  (MPEG, ProLogic, AC-3, etc.)
    AMTNoiseEq    EQU 0702h ;Internal Noise Source for Measurements
    AMTCDPlayer   EQU 0703h ;Audio CD Player or CD-ROM
    AMTDAT        EQU 0704h ;Digital Audio Tape
    AMTDCC        EQU 0705h ;Cigital Compact Cassette
    AMTCompressed EQU 0706h ;Compressed Audio Player (Minidisk)
    AMTAnalogTape EQU 0707h ;Analog Audio Tape
    AMTPhonograph EQU 0708h ;Analog Vinyl Record Player
    AMTVCR        EQU 0709h ;Video Cassette Recorder
    AMTVideoDisk  EQU 070Ah ;VideoDisc Player
    AMTDVD        EQU 070Bh ;DVD Player
    AMTTV         EQU 070Ch ;Television Tuner
    AMTSatellite  EQU 070Dh ;Satellite Receiver
    AMTCable      EQU 070Eh ;Cable Tuner
    AMTDSS        EQU 070Fh ;DSS Receiver
    AMTRadioRx    EQU 0710h ;AM/FM Radio Receiver
    AMTRadioTx    EQU 0711h ;AM/FM Radio Transmitter
    AMTMultiTrack EQU 0712h ;Multi-track Recording System
    AMTSynthesize EQU 0713h ;Synthesizer
    AMTPiano      EQU 0714h ;Piano
    AMTGuitar     EQU 0715h ;Guitar
    AMTRhythm     EQU 0716h ;Percussion/Drums/Rhythm
    AMTOtherInst  EQU 0717h ;Other Musical Instrument

  ;----------------------------------------------------------------------------
  ;Audio Spatial Configuration Bitmap
  ;  Used in Multiple Audio-related Descriptors
  ;NOTE: In Version 1 this was only a Word, in Version 2 it's a DWord
  ;----------------------------------------------------------------------------
  SpatialFrontLeft       EQU 0000_0001h ;Front Left
  SpatialFrontRight      EQU 0000_0002h ;Front Right
  SpatialFrontCenter     EQU 0000_0004h ;Front Center
  SpatialLowFreqEfx      EQU 0000_0008h ;Low Frequency Effects
  SpatialBackLeft        EQU 0000_0010h ;Back Left
  SpatialBackRight       EQU 0000_0020h ;Back Right
  SpatialFrontLeftOfCtr  EQU 0000_0040h ;Front Left of Center
  SpatialFrontRightOfCtr EQU 0000_0080h ;Front Right of Center
  SpatialBackCenter      EQU 0000_0100h ;Back Center
  SpatialSideLeft        EQU 0000_0200h ;Side Left
  SpatialSideRight       EQU 0000_0400h ;Side Right
  SpatialTopCenter       EQU 0000_0800h ;Top Center
  SpatialTopFrontLeft    EQU 0000_1000h ;Top Front Left
  SpatialTopFrontCenter  EQU 0000_2000h ;Top Front Center
  SpatialTopFrontRight   EQU 0000_4000h ;Top Front Right
  SpatialTopBackLeft     EQU 0000_8000h ;Top Back Left
  SpatialTopBackCenter   EQU 0001_0000h ;Top Back Center
  SpatialTopBackRight    EQU 0002_0000h ;Top Back Right
  SpatialTopFrLeftOfCtr  EQU 0004_0000h ;Top Front Left of Center
  SpatialTopFrRightOfCtr EQU 0008_0000h ;Top Front Right of Center
  SpatialLeftLowFreqEfx  EQU 0010_0000h ;Left Low Frequency Effects
  SpatialRightLowFreqEfx EQU 0020_0000h ;Right Low Frequency Effects
  SpatialTopSideLeft     EQU 0040_0000h ;Top Side Left
  SpatialTopSideRight    EQU 0080_0000h ;Top Side Right
  SpatialBottomCenter    EQU 0100_0000h ;Bottom Center
  SpatialBackLeftOfCtr   EQU 0200_0000h ;Back Left of Center
  SpatialBackRightOfCtr  EQU 0400_0000h ;Back Right of Center
  ;Bits 27-30 = Reserved
  SpatialRawData         EQU 8000_0000h ;Raw Data (Mutually exclusive of
                                          ;  all other Spatial Locations

  ;----------------------------------------------------------------------------
  ;Audio Format Types
  ;----------------------------------------------------------------------------
  AudFmtUndef  EQU 000h ;Undefined
  AudFmtType1  EQU 001h ;Type I (Typically PCM)
  AudFmtType2  EQU 002h ;Type II (non-PCM, Encoded Audio Frames)
  AudFmtType3  EQU 003h ;Type III (Based on IEC61937)
  ;From here down, they only apply to Audio v2
  AudFmtType4  EQU 004h ;Type IV (Non-USB Endpoint, e.g. Analog Line In/Out)
  AudFmtExt1   EQU 081h ;Extended Type I (Type I + Pkt Hdr & Synch Ctl Chan
  AudFmtExt2   EQU 082h ;Extended Type II (Type II + Pkt Hdr)
  AudFmtExt3   EQU 083h ;Extended Type III (Type III + Pkt Hdr)

  ;----------------------------------------------------------------------------
  ;Audio Version 2 Side Band Protocols (for Extended Data Format Descriptors)
  ;----------------------------------------------------------------------------
  A2SBProtocolUndef     EQU 00h ;Undefined
  A2SBProtocolTimeStamp EQU 01h ;Presentation Time-Stamp Protocol

  ;----------------------------------------------------------------------------
  ;Audio Lock Delay Units (for Class-Specific EndPoint Descrs)
  ;----------------------------------------------------------------------------
  AudLkDlyUnitUndef   EQU 00h ;Undefined
  AudLkDlyUnitMS      EQU 01h ;MilliSeconds
  AudLkDlyUnitPCMSamp EQU 02h ;Decoded PCM Samples


;==============================================================================
;Audio Version 1 Control Descriptor Structures
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Class-Specific Audio v1 Control Interface Header Descriptor
  ;----------------------------------------------------------------------------
  Audio1CtlIntfStruc STRUC ;Struc for Class-Spec Audio v1 Control Intf Descr
    A1CILength       DB ? ;Size of Descriptor in bytes
    A1CIDescrType    DB DescrTypeAudioInterface
    A1CIDescrSubType DB A1IntfDescSTypeACHeader
    A1CISpecRelease  DW ? ;Audio Device Class Spec Release (BCD)
    A1CITotalLength  DW ? ;Total Length of Descriptor, including all
                          ;  Unit and Terminal Descriptors
    A1CINumIntf      DB ? ;Number of Streaming Interfaces (Audio & Midi)
                          ;  to which this Audio Control Intf belongs
    A1CIIntfNum1     DB ? ;First Streaming Interface Num in Collection
      ;...                ;Remaining Streaming Interface Nums
   ENDS
   ;Followed by one or more Unit and/or Terminal Descriptors

  ;----------------------------------------------------------------------------
  ;Audio v1 Input Terminal Descriptor
  ;----------------------------------------------------------------------------
  Audio1InTermStruc STRUC   ;Structure for an Audio v1 Input Terminal Descr
    A1ITLength        DB 12 ;Size of Descriptor in bytes
    A1ITDescrType     DB DescrTypeAudioInterface
    A1ITDescrSubType  DB A1IntfDescSTypeACInTerm
    A1ITTerminalID    DB  ? ;Unique ID Identifying this Terminal
    A1ITTerminalType  DW  ? ;Input Terminal Type
    A1ITAssocOutTerm  DB  ? ;ID of Associated Output Terminal
    A1ITNumOutChans   DB  ? ;Number of Logical Output Channels
    A1ITSpatial       DW  ? ;Spatial Locations of Logical Channels (Bitmap)
    A1ITChanNameStr   DB  ? ;String Index describing First Logical Channel
    A1ITTermStr       DB  ? ;String Index describing this Terminal
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v1 Output Terminal Descriptor
  ;----------------------------------------------------------------------------
  Audio1OutTermStruc STRUC ;Structure for Audio v1 Output Terminal Descr
    A1OTLength       DB 9 ;Size of Descriptor in bytes
    A1OTDescrType    DB DescrTypeAudioInterface
    A1OTDescrSubType DB A1IntfDescSTypeACOutTerm
    A1OTTerminalID   DB ? ;Unique ID Identifying this Terminal
    A1OTTerminalType DW ? ;Output Terminal Type
    A1OTAssocInTerm  DB ? ;ID of Associated Input Terminal
    A1OTSourceID     DB ? ;ID of Unit or Term ID this Term is connected to
    A1OTTermStr      DB ? ;String Index describing this Terminal
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v1 Mixer Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio1MixUnitStruc STRUC ;Structure for Audio v1 Mixer Unit Descr
    A1MULength        DB ? ;Size of Descriptor in bytes
    A1MUDescrType     DB DescrTypeAudioInterface
    A1MUDescrSubType  DB A1IntfDescSTypeACMixUnit
    A1MUUnitID        DB ? ;Unique ID Identifying this Unit
    A1MUNumInPins     DB ? ;Number of Input Pins in this Unit (P)
    A1MUSourceID1     DB ? ;ID of First Input Pin (Terminal or Unit)
      ;...
    A1MUSourceIDP     DB ? ;ID of Last Input Pin (Terminal or Unit)
    A1MUNumOutChans   DB ? ;Number of Logical Output Channels (M)
    A1MUSpatial       DW ? ;Spatial Locations of Logical Channels (Bitmap)
    A1MUChanStr       DB ? ;String Index describing First Logical Channel
    A1MUPrgControls   DB ? ;Bitmap of which Controls are Programmable
      ;...                 ;Generally a very long field, depending on
                           ;  how many Pins/Channels are used.
                           ;Requires (#InputPins * #OutputChannels) bits
    A1MUUnitStr       DB ? ;String Index describing this Unit
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v1 Selector Unit Descriptor
  ;----------------------------------------------------------------------------
  AudioSelUnitStruc STRUC ;Structure for Audio v1 Selector Unit Descr
    A1SULength       DB ? ;Size of Descriptor in bytes
    A1SUDescrType    DB DescrTypeAudioInterface
    A1SUDescrSubType DB A1IntfDescSTypeACSelUnit
    A1SUUnitID       DB ? ;Unique ID Identifying this Unit
    A1SUNumInPins    DB ? ;Number of Input Pins in this Unit (P)
    A1SUSourceID1    DB ? ;ID of First Pin (Terminal or Unit)
      ;...
    A1SUSourceIDP    DB ? ;ID of Last Pin (Terminal or Unit)
    A1SUUnitStr      DB ? ;String Index describing this Unit
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v1 Feature Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio1FtrUnitStruc STRUC      ;Structure for Audio v1 Feature Unit Descr
    A1FULength         DB    ?  ;Size of Descriptor in bytes
    A1FUDescrType      DB DescrTypeAudioInterface
    A1FUDescrSubType   DB A1IntfDescSTypeACFtrUnit
    A1FUUnitID         DB    ?  ;Unique ID Identifying this Unit
    A1FUSourceID       DB    ?  ;ID of Unit or Term this Unit is connected to
    A1FUControlSize    DB    ?  ;Number of Bytes in Controls Array Element (N)
                                ;  NOTE: Array Element Size, NOT Array Size
    A1FUControls       DW    ?  ;Bit set if Control is is supported in
                                ;  Master Channel 0
      A1FUCtlMute     EQU 0001h ;Mute
      A1FUCtlVolume   EQU 0002h ;Volume
      A1FUCtlBass     EQU 0004h ;Bass
      A1FUCtlMid      EQU 0008h ;Midrange
      A1FUCtlTreble   EQU 0010h ;Treble
      A1FUCtlGraphEq  EQU 0020h ;Graphic Equalizer
      A1FUCtlAutoGain EQU 0040h ;Automatic Gain
      A1FUCtlDelay    EQU 0080h ;Delay
      A1FUCtlBassBst  EQU 0100h ;Bass Boost
      A1FUCtlLoudness EQU 0200h ;Loudness
      ;Remaining Bits Reserved
     ;...
     ;Multiple entries, 1 + number of channels in Source ID
    A1FUUnitStr      DB ? ;String Index describing this Unit
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v1 Processor Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio1ProcUnitStruc STRUC     ;Structure for Audio v1 Processor Unit Descr
    A1PULength         DB    ?  ;Size of Descriptor in bytes
    A1PUDescrType      DB DescrTypeAudioInterface
    A1PUDescrSubType   DB A1IntfDescSTypeACProcUnit
    A1PUUnitID         DB    ?  ;Unique ID Identifying this Unit
    A1PUProcessType    DW    ?  ;Type of Processing this Unit is performing
      A1PTypeUndef    EQU 0000h ;Undefined
      A1PTypeUpDnMix  EQU 0001h ;Up/Down Mix Process
      A1PTypeProLogic EQU 0002h ;Dolby ProLogic Process
      A1PTypeStereoX  EQU 0003h ;3D Stereo Extender Process
      A1PTypeReverb   EQU 0004h ;Reverberation Process
      A1PTypeChorus   EQU 0005h ;Chorus Process
      A1PTypeDynRange EQU 0006h ;Dynamic Range Compression Process
    A1PUNumInPins      DB    ?  ;Number of Input Pins in this Unit (P)
    A1PUSourceID1      DB    ?  ;Unit or Terminal ID of first Input Pin
      ;...
    A1PUSourceIDP      DB    ?  ;Unit or Terminal ID of last Input Pin
    A1PUNumOutChans    DB    ?  ;Number of Logical Output Channels
    A1PUSpatial        DW    ?  ;Spatial Locations of Logical Channels (Bitmap)
    A1PUChanStr        DB    ?  ;String Index of Name of First Logical Chan
    A1PUControlSize    DB    ?  ;Number of Bytes in Controls Field
    A1PUControls       DB    ?  ;Controls Bitmap
      A1PUCtlEnable   EQU   01h ;Enable Processing
      ;Remaining bits process-specific
     ;...
    A1PUAPUProcStr     DB    ?  ;String Index describing this Unit
    ;Followed by Process-specific Descriptor Data
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v1 Up/Down Mix Processing Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio1UpDownUnitStruc STRUC ;Structure for Audio v1 Up/Down Mix Proc Descr
   A1UDCommon        DB (TYPE Audio1ProcUnitStruc) DUP (?)
    ;A1PUProcessType = A1PTypeUpDnMix
    ;A1PUNumInPins   = 1
    ;A1PUControls for Up/Down Mix Processing Unit
     A1UDCtlEnable  EQU 01h ;Enable Processing
     A1UDCtlModeSel EQU 02h ;Mode Select
   A1UDNumModes      DB  ?  ;Number of Modes Supported by Unit (M)
   A1UDModes1        DW  ?  ;Bitmap of Active Logical Channels in Mode 1
                            ;  (Subset of Spatial Config)
                            ;  (Custom (Named) Chans must be Active)
     ;...
   A1UDModesM        DW  ?  ;Bitmap of Active Logical Channels in Mode M
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v1 Dolby ProLogic Processing Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio1ProLogicUnitStruc STRUC ;Structure for v1 Dolby Prologic Proc Descr
   A1PLCommon        DB (TYPE Audio1ProcUnitStruc) DUP (?)
    ;A1PUProcessType = A1PTypeProLogic
    ;A1PUNumInPins   = 1
    ;A1PUControls for Dolby ProLogic Processing Unit
     A1PLCtlEnable  EQU 01h ;Enable Processing
     A1PLCtlModeSel EQU 02h ;Mode Select
   A1PLNumModes      DB  ?  ;Number of Modes Supported by Unit (M)
                            ;  (Maximum of 3:
                            ;     0007h = Left, Right, Center
                            ;     0103h = Left, Right, Surround
                            ;     0107h = Left, Right, Center, Surround)
   A1PLModes1        DW  ?  ;Bitmap of Active Logical Channels in Mode 1
     ;...
   A1PLModesM        DW  ?  ;Bitmap of Active Logical Channels in Mode M
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v1 3D Stereo Processing Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio1StereoXUnitXStruc STRUC ;Structure for v1 3D Stereo Proc Unit Descr
   A1SXCommon       DB (TYPE Audio1ProcUnitStruc) DUP (?)
    ;A1PUProcessType = A1PTypeStereoX
    ;A1PUNumInPins   = 1
    ;A1PUControls for 3D Stereo Processing Unit
     A1SXCtlEnable EQU 01h ;Enable Processing
     A1SXCtlSpace  EQU 02h ;Spaciousness
   ;No special fields needed for 3D Stereo Processor Unit
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v1 Reverberation Processing Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio1ReverbUnitStruc STRUC ;Structure for v1 Reverberation Proc Unit Descr
   A1RVCommon        DB (TYPE Audio1ProcUnitStruc) DUP (?)
    ;A1PUProcessType = A1PTypeReverb
    ;A1PUNumInPins   = 1
    ;A1PUControls for Reverberation Processing Unit
     A1SXCtlEnable  EQU 01h ;Enable Processing
     A1RVCtlType    EQU 02h ;Reverb Type
     A1RVCtlLevel   EQU 04h ;Reverb Level
     A1RVCtlTime    EQU 08h ;Reverb Time
     A1RVCtlDlyFdbk EQU 10h ;Reverb Delay Feedback
   ;No special fields needed for Reverberation Processor Unit
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v1 Chorus Processing Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio1ChorusUnitStruc STRUC ;Structure for v1 Chorus Proc Unit Descr
   A1CHCommon         DB (TYPE Audio1ProcUnitStruc) DUP (?)
    ;A1PUProcessType = A1PTypeChorus
    ;A1PUNumInPins   = 1
    ;A1PUControls for Chorus Processing Unit
     A1CHCtlEnable   EQU 01h ;Enable Processing
     A1CHCtlLevel    EQU 02h ;Chorus Level
     A1CHCtlModRate  EQU 04h ;Chorus Modulation Rate
     A1CHCtlModDepth EQU 08h ;Chorus Modulation Depth
   ;No special fields needed for Chorus Processor Unit
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v1 Dynamic Range Compressor Processing Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio1DynRangeUnitStruc STRUC ;Structure for v1 Dynamic Range Comp Proc Descr
   A1DRCommon DB (TYPE Audio1ProcUnitStruc) DUP (?)
    ;A1PUProcessType = A1PTypeDynRange
    ;A1PUNumInPins   = 1
    ;A1PUControls for Dynamic Range Compressor Processing Unit
     A1CHCtlEnable   EQU 01h ;Enable Processing
     A1DRCtlRatio    EQU 02h ;Compression Ratio
     A1DRCtlMaxAmpl  EQU 04h ;Maximum Amplitude?
     A1DRCtlThresh   EQU 08h ;Threshold
     A1DRCtlAtkTime  EQU 10h ;Attack Time
     A1DRCtlRlsTime  EQU 20h ;Release Time
   ;No special fields needed for Dynamic Range Compression Processor Unit
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v1 Extension Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio1ExtUnitStruc STRUC    ;Structure for v1 Extension Unit Descr
    A1XULength         DB  ?  ;Size of Descriptor in bytes
    A1XUDescrType      DB DescrTypeAudioInterface
    A1XUDescrSubType   DB A1IntfDescSTypeACExtUnit
    A1XUUnitID         DB  ?  ;Unique ID Identifying this Unit
    A1XUExtensionCode  DW  ?  ;Vendor-specific Code Identifying the Ext Unit
    A1XUNumInPins      DB  ?  ;Number of Input Pins in Unit (P)
    A1XUSourceID1      DB  ?  ;Unit or Terminal ID for Input Pin 1
      ;...
    A1XUSourceIDP      DB  ?  ;Unit or Terminal ID for Input Pin P
    A1XUNumOutChans    DB  ?  ;Number of Logical Output Channels
    A1XUSpatial        DW  ?  ;Spatial Locations of Logical Channels (Bitmap)
    A1XUChanStr        DB  ?  ;String Index Describing First Logical Channel
    A1XUControlSize    DB  ?  ;Bytes in Control Fields (N)
    A1XUControls       DB  ?  ;Controls Bitmap
      A1XUEnableProc  EQU 01h ;Enable Processing
      ;Remaining bits Reserved
     ;...
    A1XUUnitStr        DB  ? ;String Index describing this Unit
   ENDS


;==============================================================================
;Audio Version 1 Streaming Descriptor Structures
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Class-Specific Audio v1 Streaming Interface Header Descriptor
  ;----------------------------------------------------------------------------
  Audio1StrIntfStruc STRUC       ;Struc for Audio v1 Streaming Intf Descr
    A1SILength          DB    7  ;Size of Descriptor in bytes
    A1SIDescrType       DB DescrTypeAudioInterface
    A1SIDescrSubType    DB A1IntfDescSTypeASGeneral
    A1SITermLink        DB    ?  ;Terminal ID to which EndPoint is connected
    A1SIDelay           DB    ?  ;Delay introduced by Data Path (for Synching)
    A1SIFormatTag       DW    ?  ;Audio Data Format used by this Interface
     ;-------------------------------------------------------------------------
     ;Type 1:
     ;-------------------------------------------------------------------------
      A1FT1Undefined   EQU 0000h ;Type I Undefined
      A1FT1PCM         EQU 0001h ;Pulse Code Modulation
      A1FT1PCM8        EQU 0002h ;8-bit Pulse Code Modulation
      A1FT1IEEEFloat   EQU 0003h ;IEEE Floating Point
      A1FT1ALaw        EQU 0004h ;A-Law (Non-US Telephony)
      A1FT1MuLaw       EQU 0005h ;æ-Law (US Telephony)
     ;-------------------------------------------------------------------------
     ;Type 2:
     ;-------------------------------------------------------------------------
      A1FT2Undefined   EQU 1000h ;Type II Undefined
      A1FT2MPEG        EQU 1001h ;MPEG
      A1FT2AC3         EQU 1002h ;AC-3
     ;-------------------------------------------------------------------------
     ;Type 3:
     ;-------------------------------------------------------------------------
      A1FT3Undefined   EQU 2000h ;Type III Undefined
      A1FT3IECAC3      EQU 2001h ;IEC61937 AC-3
      A1FT3IECMPEG1    EQU 2002h ;IEC61937 MPEG-1 Layer 1
      A1FT3IECMPEG2    EQU 2003h ;IEC61937 MPEG-1 Layer 2/3 or MPEG-2 No Ext
      A1FT3IECMPEG2Ext EQU 2004h ;IEC61937 MPEG-2 Ext
      A1FT3IECMPEG21LS EQU 2005h ;IEC61937 MPEG-2 Layer 1 LS
      A1FT3IECMPEG22LS EQU 2006h ;IEC61937 MPEG-2 Layer 2/3 LS
   ENDS
   ;May be followed by Format-specific Data Descriptor

  ;----------------------------------------------------------------------------
  ;Audio v1 Data Format Type I Descriptor Structure
  ;NOTE: This changed, in an incompatible way, between Audio Spec
  ;  Version 1 & Version 2!!
  ;----------------------------------------------------------------------------
  A1FmtType1Struc  STRUC   ;Struc for Audio v1 Data Format Type I Descriptor
    A1FT1Length       DB ? ;Size of Descriptor in bytes
    A1FT1DescrType    DB DescrTypeAudioInterface
    A1FT1DescrSType   DB A1IntfDescSTypeASFmtType
    A1FT1FormatType   DB AudFmtType1
    A1FT1NumChans     DB ? ;Number of Physical Channels in Audio Data Stream
    A1FT1SubSlotSize  DB ? ;Number of Bytes in Audio SubSlot (1-4)
    A1FT1Resolution   DB ? ;Number of effectively used bits per SubSlot
    A1FT1SampFreqType DB ? ;How sampling Frequency can be programmmed
                           ;0 = Continuous
                           ;1-255 = # of discrete frequencies supported by
                           ;  the Isoch Data Endpoint of Audio Streaming Intf
    A1FT1SampleFreq1  DB 3 DUP (?)
    A1FT1SampleFreq2  DB 3 DUP (?)
    ;...
    ;If SampFreqType = 0,
    ;   SampleFreq1 = Lower Sampling Bound (Hz),
    ;   SampleFreq2 = Upper Sampling Bound (Hz)
    ;If SampFreqType != 0,
    ;   SampleFreq1 = First Discrete Sampling Frequency (Hz)
    ;   SampleFreq2 = Second Discrete Sampling Frequency (Hz)
    ;   ... until Discrete Counter (SampFreqType) is met
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v1 Data Format Type II Descriptor Structure
  ;----------------------------------------------------------------------------
  A1FmtType2Struc   STRUC   ;Struc for Audio v1 Data Format Type II Descriptor
    A1FT2Length        DB ? ;Size of Descriptor in bytes
    A1FT2DescrType     DB DescrTypeAudioInterface
    A1FT2DescrSType    DB A1IntfDescSTypeASFmtType
    A1FT2FormatType    DB AudFmtType2
    A1FT2MaxKBPS       DW ? ;Maximim kbps Interface can handle
    A1FT2SampsPerFrame DW ? ;Number of PCM Samples per Audio Frame
    A1FT2SampFreqType  DB ? ;How sampling Frequency can be programmmed
                            ;0 = Continuous
                            ;1-255 = # of discrete frequencies supported by
                            ;  the Isoch Data Endpoint of Audio Streaming Intf
    A1FT2SampleFreq1   DB 3 DUP (?)
    A1FT2SampleFreq2   DB 3 DUP (?)
    ;...
    ;If SampFreqType = 0,
    ;   SampleFreq1 = Lower Sampling Bound (Hz),
    ;   SampleFreq2 = Upper Sampling Bound (Hz)
    ;If SampFreqType != 0,
    ;   SampleFreq1 = First Discrete Sampling Frequency (Hz)
    ;   SampleFreq2 = Second Discrete Sampling Frequency (Hz)
    ;   ... until Discrete Counter (SampFreqType) is met
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v1 MPEG Format-Specific Descriptor Structure
  ;----------------------------------------------------------------------------
  A1MPGStruc         STRUC       ;Struc for Audio v1 MPEG Format-Specific Descr
    A1MPGLength         DB    8  ;Size of Descriptor in bytes
    A1MPGDescrType      DB DescrTypeAudioInterface
    A1MPGDescrSType     DB A1IntfDescSTypeASFmtSpec
    A1MPGFormatTag      DW A1FT2MPEG ;Duplicate of value in Class-Spec Intf Descr
    A1MPGCapabilities   DW    ?  ;MPEG Decoder Capabilities bitmap
      A1MCLayer1Supp   EQU 0001h ;MPEG Layer 1 Supported
      A1MCLayer2Supp   EQU 0002h ;MPEG Layer 2 Supported
      A1MCLayer3Supp   EQU 0004h ;MPEG Layer 3 Supported
      A1MCMPEG1Only    EQU 0008h ;MPEG-1 Only
      A1MCMPEG1DualCh  EQU 0010h ;MPEG-1 Dual Channel
      A1MCMPEG2Stereo  EQU 0020h ;MPEG-2 Second Stereo
      A1MCMPEG271Aug   EQU 0040h ;MPEG-2 7.1 Channel Augmentation
      A1MCAMP          EQU 0080h ;Adaptive Multi-Channel Prediction
      A1MCMultiLingual EQU 0300h ;MPEG-2 Multilingual Support Mask
        A1MCLNoSupp    EQU 0000h ;Not Supported
        A1MCLFs        EQU 0100h ;Supported at Fs (Full Speed?)
        A1MCLReserved  EQU 0200h ;Reserved
        A1MCLFs12Fs    EQU 0300h ;Supported at Fs and 1/2 Fs (Full & 1/2 Speed?)
      ;Bits 10-15 = Reserved
    A1MPGFeatures       DB    ?  ;MPEG Decoder Features bitmap
      ;Bits 0-3 = Reserved
      A1MFDynRangeCtl  EQU   30h ;Dynamic Range Control Support Mask
        A1MFDNoSupp    EQU   00h ;Not supported
        A1MFDNoScale   EQU   10h ;Supported but no scalable
        A1MFDCommon    EQU   20h ;Scalable, Common Boost & Cut Scaling Value
        A1MFDSeparate  EQU   30h ;Scalable, Separate Boost & Cut Scaling Value
      ;Bits 6-7 = Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v1 AC-3 Format-Specific Descriptor Structure
  ;----------------------------------------------------------------------------
  A1AC3Struc         STRUC     ;Struc for Audio v1 AC-3 Format-Specific Descr
    A1AC3Length         DB 10  ;Size of Descriptor in bytes
    A1AC3DescrType      DB DescrTypeAudioInterface
    A1AC3DescrSType     DB A1IntfDescSTypeASFmtSpec
    A1AC3FormatTag      DW A1FT2AC3 ;Duplicate of value in Class-Spec Intf Descr
    A1AC3BSIDModes      DD  ?  ;Bitmap of BSID modes supported
    A1AC3Features       DB  ?  ;AC-3 Decoder Features bitmap
      A1AFRFMode       EQU 01h ;RF Mode Supported
      A1AFLineMode     EQU 02h ;Line Mode Supported
      A1AFCustom0Mode  EQU 04h ;Custom0 Mode Supported
      A1AFCustom1Mode  EQU 08h ;Custom1 Mode Supported
      A1AFDynRangeCtl  EQU 30h ;Dynamic Range Control Support Mask
        A1AFDNoSupp    EQU 00h ;Not supported
        A1AFDNoScale   EQU 10h ;Supported but no scalable
        A1AFDCommon    EQU 20h ;Scalable, Common Boost & Cut Scaling Value
        A1AFDSeparate  EQU 30h ;Scalable, Separate Boost & Cut Scaling Value
      ;Bits 6-7 = Reserved
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v1 Data Format Type III Descriptor Structure
  ;----------------------------------------------------------------------------
  ;This structure is EXACTLY the same as the Type I Descriptor, with the
  ;  following dedicated values in some of the fields:
  ;  FormatType  = AudFmtType3
  ;  NumChans    = 2
  ;  SubSlotSize = 2

  ;----------------------------------------------------------------------------
  ;Audio v1 Class-Specific Isochronous EndPoint Descriptor Structure
  ;----------------------------------------------------------------------------
  A1EndPointStruc   STRUC     ;Struc for Audio v1 Class-Specific Isoch EndPt Descr
    A1EPLength         DB  7  ;Size of Descriptor in bytes (7)
    A1EPDescrType      DB DescrTypeAudioEndPoint
    A1EPDescrSType     DB AEndPtDescSTypeGeneral
    A1EPAttribs        DB  ?  ;EndPoint Attributes Support Bitmap
      A1EPSampFreq    EQU 01h ;Sampling Frequency Supported
      A1EPPitch       EQU 02h ;Pitch Supported
      ;Bits 2-6 = Reserved
      A1EPMaxPktsOnly EQU 80h ;Max Packet Size Only
    A1EPLockDelayUnit  DB  ?  ;Units used for Lock Delay Field
      ;AudLkDlyUnitUndef, etc.
    A1EPLockDelay      DW  ?  ;Time it takes EndPoint to reliably lock to
                             ;  internal clock recovery circuitry
   ENDS


;==============================================================================
;MIDI Streaming Descriptor Structures
;There has not (yet) been a version 2 of the USB-MIDI standard released,
;  so these are the same whether we are talking Audio v1 or v2?
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Class-Specific MIDI Streaming Interface Header Descriptor
  ;----------------------------------------------------------------------------
  MIDIStrIntfStruc STRUC ;Struc for MIDI Streaming Intf Descr
    MSILength       DB 7 ;Size of Descriptor in bytes
    MSIDescrType    DB DescrTypeAudioInterface
    MSIDescrSubType DB AIntfDescSTypeMSHeader
    MSIMSCVersion   DW ? ;MIDIStreaming SubClass Spec Version (BCD)
    MSITotalLength  DW ? ;Total Length for all Descriptors, incl this one
                         ;  and all Jack & ELement Descriptors
   ENDS
   ;Followed by one or more Jack and/or Element Descriptors

  ;----------------------------------------------------------------------------
  ;Class-Specific MIDI Jack In Descriptor
  ;----------------------------------------------------------------------------
  MIDIJackInStruc STRUC    ;Structure for Class-Specific MIDI In Jack
    MJILength        DB  6 ;Size of Descriptor in bytes
    MJIDescrType     DB DescrTypeAudioInterface
    MJIDescrSubType  DB AIntfDescSTypeMSJackIn
    MJIJackType      DB  ?  ;Jack Type (Undefined, Embedded, External)
    MJIJackID        DB  ?  ;Unique Jack Identifer
    MJIJackString    DB  ?  ;Index of String describing this Jack
   ENDS

  ;----------------------------------------------------------------------------
  ;Class-Specific MIDI Jack Out Descriptor
  ;Variable Length
  ;----------------------------------------------------------------------------
  MIDIJackOutStruc STRUC  ;Structure for Class-Specific MIDI Out Jack
    MJOLength        DB ? ;Size of Descriptor in bytes
    MJODescrType     DB DescrTypeAudioInterface
    MJODescrSubType  DB AIntfDescSTypeMSJackOut
    MJOJackType      DB ? ;Jack Type
      ;Same values as MJIJackType (Embedded or External)
    MJOJackID        DB ? ;Unique Jack Identifer
    MJONumPins       DB ? ;Number of Input Pins (P)
    MJOSourceID1     DB ? ;Entity ID to which 1st Input Pin is connected
    MJOSourcePin1    DB ? ;Entity Output Pin # to which 1st Pin is connected
    ;;;
    MJOSourceIDP     DB ? ;Entity ID to which Last Input Pin is connected
    MJOSourcePinP    DB ? ;Entity Output Pin # to which Last Pin is connected
    MJOJackString    DB ? ;Index of String describing this Jack
   ENDS

  ;----------------------------------------------------------------------------
  ;Class-Specific MIDI Element Descriptor
  ;Variable Length
  ;----------------------------------------------------------------------------
  MIDIElementStruc STRUC      ;Structure for Class-Specific MIDI Element
    MELength         DB    ?  ;Size of Descriptor in bytes
    MEDescrType      DB DescrTypeAudioInterface
    MEDescrSubType   DB AIntfDescSTypeMSElement
    MEElementID      DB    ?  ;Unique Element Identifer
    MENumInPins      DB    ?  ;Number of Input Pins (P)
    MESourceID1      DB    ?  ;Entity ID to which 1st Input Pin is connected
    MESourcePin1     DB    ?  ;Entity Output Pin # to which 1st Pin is connected
    ;;;
    MESourceIDP      DB    ?  ;Entity ID to which Last Input Pin is connected
    MESourcePinP     DB    ?  ;Entity Output Pin # to which Last Pin is connected
    MENumOutPins     DB    ?  ;Number of Output Pins (Q)
    MEInTermLink     DB    ?  ;Input Terminal ID to which this Element is connected
    MEOutTermLink    DB    ?  ;Output Terminal ID to which this Element is connected
    MECapSize        DB    ?  ;Capabilities Size (N)
                              ;According to the v1.0 Spec, the size is 1,
                              ;  but they have more than 8 bits worth of data!
    MECapabilities   DB    ?  ;Element Capabilities
      MECapCustom   EQU 0001h ;Custom Undefined
      MECapClock    EQU 0002h ;MIDI Clock
      MECapMTC      EQU 0004h ;MIDI Time Code
      MECapMMC      EQU 0008h ;MIDI Machine Control
      MECapGM1      EQU 0010h ;General MIDI Syetem Level 1
      MECapGM2      EQU 0020h ;General MIDI Syetem Level 2
      MECapG5       EQU 0040h ;G5 Format (Roland)
      MECapXG       EQU 0080h ;XG Format (Yamaha)
      MECapEFX      EQU 0100h ;Audio Effects Processor
      MECapPatch    EQU 0200h ;Internal MIDI Patcher/Router
      MECapDLS1     EQU 0400h ;Downloadable Sounds Standard Level 1
      MECapDLS2     EQU 0800h ;Downloadable Sounds Standard Level 2
      ;Bits 12+ = Reserved
    MEElementString  DB  ?  ;Index of String describing this Element
   ENDS

  ;----------------------------------------------------------------------------
  ;MIDI Class-Specific Bulk Data EndPoint Descriptor Structure
  ;----------------------------------------------------------------------------
  MIDIBulkDataEndPointStruc STRUC ;Struc for MIDI Bulk Data EndPt Descr
    MBDLength         DB 7 ;Size of Descriptor in bytes (7)
    MBDDescrType      DB DescrTypeAudioEndPoint
    MBDDescrSType     DB MEndPtDescSTypeGeneral
    MBDNumEmbJacks    DB ? ;Number of Embedded MIDI Jacks (N)
    MBDJackID1        DB ? ;ID of First Associated Embedded Jack
    ;;;
    MBDJackIDN        DB ? ;ID of Last Associated Embedded Jack

   ENDS


;For Audio v2, the Device Descriptor and the Device Qualifier Descriptor MUST
;  contain the Interface Association Class/SubClass/Protocol codes
;  (EFh/02h/01h) rather than all zeroes.

;==============================================================================
;Audio Version 2 Control Descriptor Structures
;NOTE: These are all different, in some cases substantially different,
;        than the Audio Version 1 Descriptors.
;==============================================================================

;Find out what IP_VERSION_02_00 is all about
;  (Audio Function Protocol Codes, Section A.3 in Spec

  ;----------------------------------------------------------------------------
  ;Class-Specific Audio v2 Control Interface Header Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfStruc  STRUC      ;Struc for Class-Spec Audio v2 Control Intf Descr
    A2CILength           DB   9  ;Size of Descriptor in bytes
    A2CIDescrType        DB DescrTypeAudioInterface
    A2CIDescrSubType     DB A2IntfDescSTypeACHeader
    A2CISpecRelease      DW   ?  ;Audio Device Class Spec Release (BCD)
    A2CICategory         DB   ?  ;Primary use as intended by manufacturer
      A2CatUndef        EQU  00h ;Undefined
      A2CatDTSpkr       EQU  01h ;Desktop Speaker
      A2CatHmTheater    EQU  02h ;Home Theater
      A2CatMicrophone   EQU  03h ;Microphone
      A2CatHeadSet      EQU  04h ;Head Set
      A2CatTelephone    EQU  05h ;Telephone
      A2CatConverter    EQU  06h ;Converter
      A2CatRecorder     EQU  07h ;Voice/Sound Recorder
      A2CatIOBox        EQU  08h ;I/O Box
      A2CatMusicInst    EQU  09h ;Musical Instrument
      A2CatProAudio     EQU  0Ah ;Pro Audio
      A2CatAudioVideo   EQU  0Bh ;Audio/Video
      A2CatControlPnl   EQU  0Ch ;Control Panel
      ;Values 0Dh-FEh = Undefined
      A2CatOther        EQU 0FFh ;Other
    A2CITotalLength      DW   ?  ;Total Length of Descriptor, including all
                                 ;  Unit and Terminal Descriptors
    A2CIControls         DB   ?  ;Controls supported by Device
                                 ;  (configured in bit pairs)
      A2CICtlLatency    EQU  03h ;Latency Control Mask
        A2CtlNoSupt     EQU  00h ;Control Not Present
        A2CtlReadOnly   EQU  01h ;Control Present, but Read-Only
        A2CtlIllegal    EQU  02h ;Illegal/Unused/Not Allowed
        A2CtlFullSupt   EQU  03h ;Control Present and Programmable
      ;Bits 2-7 = Reserved
   ENDS
   ;Followed by one or more Clock, Unit, and/or Terminal Descriptors

  ;----------------------------------------------------------------------------
  ;Audio v2 Input Terminal Descriptor
  ;----------------------------------------------------------------------------
  Audio2InTermStruc  STRUC       ;Structure for an Audio v2 Input Terminal Descr
    A2ITLength          DB   17  ;Size of Descriptor in bytes
    A2ITDescrType       DB DescrTypeAudioInterface
    A2ITDescrSubType    DB A2IntfDescSTypeACInTerm
    A2ITTerminalID      DB    ?  ;Unique ID Identifying this Terminal
    A2ITTerminalType    DW    ?  ;Input Terminal Type
    A2ITAssocOutTerm    DB    ?  ;Associated Output Terminal ID
    A2ITClkSourceID     DB    ?  ;ID of Clock Entity to this this is Connected
    A2ITNumOutChans     DB    ?  ;Number of Logical Output Channels
    A2ITSpatial         DD    ?  ;Spatial Locations of Logical Channels (Bitmap)
    A2ITChanString1     DB    ?  ;Index of String describing first logical channel
                                 ;  (only used if Spatial bits don't apply)
    A2ITControls        DW    ?  ;Controls (organized in bit-pairs)
                                 ;Setting use A2CtlNoSupt, etc.
                                 ;  (No Support, Read-Only, Illegal, Full Support)
      A2ITCtlCopyProt  EQU 0003h ;Copy Protect Control
      A2ITCtlConnector EQU 000Ch ;Connector Control
      A2ITCtlOverload  EQU 0030h ;Overload Control
      A2ITCtlCluster   EQU 00C0h ;Cluster Control
      A2ITCtlUnderflow EQU 0300h ;Underflow Control
      A2ITCtlOverflow  EQU 0C00h ;Overflow Control
      ;Bits 12-15 = Reserved (0)
    A2ITTermStr         DB    ?  ;String Index Describing Input Terminal
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Output Terminal Descriptor
  ;----------------------------------------------------------------------------
  Audio2OutTermStruc STRUC       ;Structure for Audio v2 Output Terminal Descr
    A2OTLength          DB   12  ;Size of Descriptor in bytes
    A2OTDescrType       DB DescrTypeAudioInterface
    A2OTDescrSubType    DB A2IntfDescSTypeACOutTerm
    A2OTTerminalID      DB    ?  ;Unique ID Identifying this Terminal
    A2OTTerminalType    DW    ?  ;Output Terminal Type
    A2OTAssocInTerm     DB    ?  ;ID of Associated Input Terminal
    A2OTSourceID        DB    ?  ;ID of Unit/Term this Term is connected to
    A2OTClockSrcID      DB    ?  ;ID of Clock Entity this Term is connected to
    A2OTControls        DW    ?  ;Controls (organized in bit-pairs)
                                 ;Setting use A2CtlNoSupt, etc.
                                 ;  (No Supt, Read-Only, Illegal, Full Supt)
      A2OTCtlCopyProt  EQU 0003h ;Copy Protect Control
      A2OTCtlConnector EQU 000Ch ;Connector Control
      A2OTCtlOverload  EQU 0030h ;Overload Control
      A2OTCtlUnderflow EQU 00C0h ;Underflow Control
      A2OTCtlOverflow  EQU 0300h ;Overflow Control
      ;Bits 10-15 = Reserved (0)
    A2OTTermStr         DB    ?  ;String Index Describing Output Terminal
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Mixer Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio2MixUnitStruc STRUC     ;Structure for an Audio v2 Mixer Unit Descr
    A2MULength          DB  ?  ;Size of Descriptor in bytes
    A2MUDescrType       DB  DescrTypeAudioInterface
    A2MUDescrSubType    DB  A2IntfDescSTypeACMixUnit
    A2MUUnitID          DB  ?  ;Unique ID Identifying this Unit
    A2MUNumInPins       DB  ?  ;Number of Input Pins in this Unit (P)
    A2MUSourceID1       DB  ?  ;Terminal or Unit ID of first Pin
      ;...
    A2MUSourceIDP       DB  ?  ;Terminal or Unit ID of last Pin
    A2MUNumOutChans     DB  ?  ;Number of Logical Output Channels (M)
    A2MUSpatial         DD  ?  ;Spatial Locations of Logical Channels (Bitmap)
    A2MUChanStr         DB  ?  ;String Index Describing First Logical Chan
    A2MUPrgControls     DB  ?  ;Bitmap of which Controls are Programmable
      ;...                     ;Generally a very long field, depending on
                               ;  how many Pins/Channels are used.
                               ;Requires (#InputPins * #OutputChannels) bits
    A2MUControls        DB  ?  ;Controls (organized in bit-pairs)
                               ;Setting use A2CtlNoSupt, etc.
                               ;  (No Support, Read-Only, Illegal, Full Support)
      A2MUCtlCluster   EQU 03h ;Cluster Control
      A2MUCtlUnderflow EQU 0Ch ;Underflow Control
      A2MUCtlOverflow  EQU 30h ;Overflow Control
      ;Bits 6-7 = Reserved (0)
    A2MUUnitStr         DB  ?  ;String Index Describing Mixer Unit
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Selector Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio2SelUnitStruc STRUC     ;Structure for an Audio v2 Selector Unit Descr
    A2SULength          DB  ?  ;Size of Descriptor in bytes
    A2SUDescrType       DB  DescrTypeAudioInterface
    A2SUDescrSubType    DB  A2IntfDescSTypeACSelUnit
    A2SUUnitID          DB  ?  ;Unique ID Identifying this Unit
    A2SUNumInPins       DB  ?  ;Number of Input Pins in this Unit (P)
    A2SUSourceID1       DB  ?  ;Terminal or Unit ID of first Pin
      ;...
    A2SUSourceIDP       DB  ?  ;Terminal or Unit ID of last Pin
    A2SUControls        DB  ?  ;Controls (organized in bit-pairs)
                               ;Setting use A2CtlNoSupt, etc.
                               ;  (No Support, Read-Only, Illegal, Full Support)
      A2SUCtlSelector  EQU 03h ;Cluster Control
      ;Bits 2-7 = Reserved (0)
    A2SUUnitStr         DB  ?  ;String Index Describing Mixer Unit
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Feature Unit Descriptor
  ;NOTE: Variable Length Descriptor, where technically the length is determined
  ;        by the number of "Master Channels" of the Source Entity, which
  ;        is in another Descriptor.
  ;      The number of Channels defined in the Source Entity Descriptor
  ;        does NOT include Master Channel 0, so there is one more Control
  ;        channel here than there are CHannels in the Source.
  ;----------------------------------------------------------------------------
  Audio2FtrUnitStruc STRUC            ;Structure for an Audio v2 Ftr Unit Descr
    A2FULength          DB         ?  ;Size of Descriptor in bytes
    A2FUDescrType       DB  DescrTypeAudioInterface
    A2FUDescrSubType    DB  A2IntfDescSTypeACFtrUnit
    A2FUUnitID          DB         ?  ;Unique ID Identifying this Unit
    A2FUSourceID        DB         ?  ;ID of Terminal/Unit this is connected to
    A2FUControls0       DD         ?  ;Controls for Master Channel 0
                                      ;Organized in bit-pairs)
                                      ;Setting use A2CtlNoSupt, etc.
                                      ;  (No Supt, Read-Only, Illegal, Full)
      AFSUCtlMute      EQU 0000_0003h ;Mute Control
      AFSUCtlVolume    EQU 0000_000Ch ;Volume Control
      AFSUCtlBass      EQU 0000_0030h ;Bass Control
      AFSUCtlMidRange  EQU 0000_00C0h ;MidRange Control
      AFSUCtlTreble    EQU 0000_0300h ;Treble Control
      AFSUCtlGraphEq   EQU 0000_0C00h ;Graphics Equalizer Control
      AFSUCtlAutoGain  EQU 0000_3000h ;Automatic Gain Control
      AFSUCtlDelay     EQU 0000_C000h ;Delay Control
      AFSUCtlBassBoost EQU 0003_0000h ;Bass Boost Control
      AFSUCtlLoudness  EQU 000C_0000h ;Loudness Control
      AFSUCtlInGain    EQU 0030_0000h ;Input Gain Control
      AFSUCtlInGainPad EQU 00C0_0000h ;Input Gain Pad Control
      AFSUCtlPhaseInv  EQU 0300_0000h ;Phase Inverter Control
      AFSUCtlUnderflow EQU 0C00_0000h ;Underflow Control
      AFSUCtlOverflow  EQU 3000_0000h ;Overflow Control
      ;Bits 30-31 = Reserved (0)
    A2FUControls1       DD         ?  ;Controls for Master Channel 1
    ;...
    A2FUControlsN       DD         ?  ;Controls for Master Channel N
    A2FUUnitStr         DB         ?  ;String Index Describing Feature Unit
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Effect Unit Descriptor
  ;NOTE: Variable Length Descriptor, where technically the length is determined
  ;        by the number of "Master Channels" of the Source Entity, which
  ;        is in another Descriptor.
  ;      The number of Channels defined in the Source Entity Descriptor
  ;        does NOT include Master Channel 0, so there is one more Control
  ;        channel here than there are Channels in the Source.
  ;----------------------------------------------------------------------------
  Audio2EfxUnitStruc   STRUC           ;Structure for an Audio v2 Effect Unit Descr
    A2FXLength            DB        ?  ;Size of Descriptor in bytes
    A2FXDescrType         DB DescrTypeAudioInterface
    A2FXDescrSubType      DB A2IntfDescSTypeACEfxUnit
    A2FXUnitID            DB         ?  ;Unique ID Identifying this Unit
    A2FXEffectType        DW         ?  ;Effect Type
      A2FXTypeUndef      EQU      0000h ;Undefined
      A2FXTypeParamEq    EQU      0001h ;Parametric Equalizer Section
      A2FXTypeReverb     EQU      0002h ;Reverberation
      A2FXTypeModDelay   EQU      0003h ;Modulation Delay
      A2FXTypeDynRange   EQU      0004h ;Dynamic Range Compression
    A2FXSourceID          DB         ?  ;ID of Terminal/Unit this is connected to
    A2FXControls0         DD         ?  ;Controls for Master Channel 0
                                        ;Organized in bit-pairs)
                                        ;Setting use A2CtlNoSupt, etc.
                                        ;  (No Supt, Read-Only, Illegal, Full Supt)
     ;-------------------------------------------------------------------------
     ;Controls for Parametric Equalizer Section Effect Unit
     ;-------------------------------------------------------------------------
      A2FXPQCtlEnable    EQU 0000_0003h ;Enable Control
      A2FXPQCtlCtrFreq   EQU 0000_000Ch ;Center Frequency Control
      A2FXPQCtlQFactor   EQU 0000_0030h ;Q-Factor Control
      A2FXPQCtlGain      EQU 0000_00C0h ;Gain Control
      A2FXPQCtlUnderflow EQU 0000_0300h ;Underflow Control
      A2FXPQCtlOverflow  EQU 0000_0C00h ;Overflow Control
      ;Bits 12-31 = Reserved (0)
     ;-------------------------------------------------------------------------
     ;Controls for Reverberation Effect Unit
     ;-------------------------------------------------------------------------
      A2FXRvCtlEnable    EQU 0000_0003h ;Enable Control
      A2FXRvCtlType      EQU 0000_000Ch ;Type Control
      A2FXRvCtlLevel     EQU 0000_0030h ;Level Control
      A2FXRvCtlTime      EQU 0000_00C0h ;Time Control
      A2FXRvCtlDlyFeedbk EQU 0000_0300h ;Delay Feedback Control
      A2FXRvCtlPreDelay  EQU 0000_0C00h ;Pre-Delay Control
      A2FXRvCtlDensity   EQU 0000_3000h ;Density Control
      A2FXRvCtlHiFreqRO  EQU 0000_C000h ;High-Frequency Roll-Off Control
      A2FXRvCtlUnderflow EQU 0003_0000h ;Underflow Control
      A2FXRvCtlOverflow  EQU 000C_0000h ;Overflow Control
      ;Bits 20-31 = Reserved (0)
     ;-------------------------------------------------------------------------
     ;Controls for Modulation Delay Effect Unit
     ;-------------------------------------------------------------------------
      A2FXMDCtlEnable    EQU 0000_0003h ;Enable Control
      A2FXMDCtlBalance   EQU 0000_000Ch ;Balance Control
      A2FXMDCtlRate      EQU 0000_0030h ;Rate Control
      A2FXMDCtlDepth     EQU 0000_00C0h ;Depth Control
      A2FXMDCtlTime      EQU 0000_0300h ;Time Control
      A2FXMDCtlFdbkLvl   EQU 0000_0C00h ;Feedback Level Control
      A2FXMDCtlUnderflow EQU 0000_3000h ;Underflow Control
      A2FXMDCtlOverflow  EQU 0000_C000h ;Overflow Control
      ;Bits 16-31 = Reserved (0)
     ;-------------------------------------------------------------------------
     ;Controls for Dynamic Range Compressor Effect Unit
     ;-------------------------------------------------------------------------
      A2FXDRCtlEnable    EQU 0000_0003h ;Enable Control
      A2FXDRCtlCompRatio EQU 0000_000Ch ;Compression Ratio Control
      A2FXDRCtlMaxAmpl   EQU 0000_0030h ;Maximum Amplitude Control
      A2FXDRCtlThreshold EQU 0000_00C0h ;Threshold Control
      A2FXDRCtlAttackTm  EQU 0000_0300h ;Attack Time Control
      A2FXDRCtlReleaseTm EQU 0000_0C00h ;Release Time Control
      A2FXDRCtlUnderflow EQU 0000_3000h ;Underflow Control
      A2FXDRCtlOverflow  EQU 0000_C000h ;Overflow Control
      ;Bits 16-31 = Reserved (0)
    A2FXControls1         DD         ?  ;Controls for Master Channel 1
    ;...
    A2FXControlsN         DD         ?  ;Controls for Master Channel N
    A2FXUnitStr           DB         ?  ;String Index Describing Feature Unit
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Processor Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio2ProcUnitStruc STRUC     ;Structure for an Audio v2 Processor Unit Descr
    A2PULength         DB    ?  ;Size of Descriptor in bytes
    A2PUDescrType      DB DescrTypeAudioInterface
    A2PUDescrSubType   DB A2IntfDescSTypeACProcUnit
    A2PUUnitID         DB    ?  ;Unique ID Identifying this Unit
    A2PUProcessType    DW    ?  ;Type of Processing this Unit is performing
      A2PTypeUndef    EQU 0000h ;Undefined
      A2PTypeUpDnMix  EQU 0001h ;Up/Down Mix Process
      A2PTypeProLogic EQU 0002h ;Dolby ProLogic Process
      A2PTypeStereoX  EQU 0003h ;Stereo Extender Process
    A2PUNumInPins      DB    ?  ;Number of Input Pins in this Unit (P)
    A2PUSourceID1      DB    ?  ;Unit or Terminal ID of first Input Pin
      ;...
    A2PUSourceIDP      DB    ?  ;Unit or Terminal ID of last Input Pin
    A2PUNumOutChans    DB    ?  ;Number of Logical Output Channels
    A2PUSpatial        DD    ?  ;Spatial Locations of Logical Channels (Bitmap)
    A2PUChanStr        DB    ?  ;String Index of Name of First Logical Chan
    A2PUControls       DW    ?  ;Controls Bitmap
      A2PUEnableProc  EQU 0003h ;Enable Control
      ;Remaining bits process-specific
     ;...
    A2PUAPUProcStr     DB    ?  ;String Index describing Processing Unit
    ;Followed by Process-specific Descriptor Data
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Up/Down Mix Processing Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio2UpDownUnitStruc STRUC ;Structure for an Audio v2 Up/Down Mix Proc Descr
   A2UDCommon          DB (TYPE Audio2ProcUnitStruc) DUP (?)
    ;A2PUProcessType = A2PTypeUpDnMix
    ;A2PUNumInPins   = 1
    ;A2PUControls for Up/Down Mix Processing Unit
     A2UDCtlEnable    EQU 0003h ;Enable Control
     A2UDCtlModeSel   EQU 000Ch ;Mode Select Control
     A2UDCtlCluster   EQU 0030h ;Cluster Control
     A2UDCtlUnderflow EQU 00C0h ;Underflow Control
     A2UDCtlOverflow  EQU 0300h ;Overflow Control
     ;Bits 10-15 = Reserved (0)
   A2UDNumModes        DB    ?  ;Number of Modes Supported by Unit (M)
   A2UDModes1          DD    ?  ;Bitmap of Active Logical Channels in Mode 1
                                ;  (Subset of Spatial Config)
                                ;  (Custom (Named) Chans must be Active)
     ;...
   A2UDModesM          DD    ?  ;Bitmap of Active Logical Channels in Mode M
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Dolby ProLogic Processing Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio2ProLogicUnitStruc STRUC ;Structure for v2 Dolby Prologic Proc Descr
   A2PLCommon        DB (TYPE Audio2ProcUnitStruc) DUP (?)
    ;A2PUProcessType = A2PTypeProLogic
    ;A2PUNumInPins   = 1
    ;A2PUControls for Dolby ProLogic Processing Unit
     A2PLCtlEnable    EQU 0003h ;Enable Control
     A2PLCtlModeSel   EQU 000Ch ;Mode Select Control
     A2PLCtlCluster   EQU 0030h ;Cluster Control
     A2PLCtlUnderflow EQU 00C0h ;Underflow Control
     A2PLCtlOverflow  EQU 0300h ;Overflow Control
     ;Bits 10-15 = Reserved (0)
   A2PLNumModes        DB    ?  ;Number of Modes Supported by Unit (M)
                              ;  (Maximum of 3:
                              ;     0007h = Left, Right, Center
                              ;     0103h = Left, Right, Surround
                              ;     0107h = Left, Right, Center, Surround)
   A2PLModes1          DD  ?  ;Bitmap of Active Logical Channels in Mode 1
     ;...
   A2PLModesM          DD  ?  ;Bitmap of Active Logical Channels in Mode M
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Stereo Processing Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio2StereoXUnitXStruc STRUC ;Structure for v2 Stereo Proc Unit Descr
   A2SXCommon       DB (TYPE Audio2ProcUnitStruc) DUP (?)
    ;A2PULength      = 17
    ;A2PUProcessType = A2PTypeStereoX
    ;A2PUNumInPins   = 1
    ;APUControls for 3D Stereo Processing Unit
     A2PLCtlEnable    EQU 0003h ;Enable Control
     A2PLCtlWidth     EQU 000Ch ;Width Control
     A2PLCtlCluster   EQU 0030h ;Cluster Control
     A2PLCtlUnderflow EQU 00C0h ;Underflow Control
     A2PLCtlOverflow  EQU 0300h ;Overflow Control
     ;Bits 10-15 = Reserved (0)
   ;No special fields needed for Stereo Processor Unit
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Extension Unit Descriptor
  ;  (Vendor-specific Unit)
  ;----------------------------------------------------------------------------
  Audio2ExtUnitStruc STRUC     ;Structure for a v2 Extension Unit Descr
    A2XULength         DB   ?  ;Size of Descriptor in bytes
    A2XUDescrType      DB DescrTypeAudioInterface
    A2XUDescrSubType   DB A2IntfDescSTypeACExtUnit
    A2XUUnitID         DB   ?  ;Unique ID Identifying this Unit
    A2XUExtensionCode  DW   ?  ;Vendor-specific Code Identifying the Ext Unit
    A2XUNumInPins      DB   ?  ;Number of Input Pins in Unit (P)
    A2XUSourceID1      DB   ?  ;Unit or Terminal ID for Input Pin 1
      ;...
    A2XUSourceIDP      DB   ?  ;Unit or Terminal ID for Input Pin P
    A2XUNumOutChans    DB   ?  ;Number of Logical Output Channels
    A2XUSpatial        DD   ?  ;Spatial Locations of Logical Channels (Bitmap)
    A2XUChanStr        DB   ?  ;String Index Describing First Logical Channel
    A2XUControls       DB   ?  ;Controls Bitmap
     A2XUCtlEnable    EQU 003h ;Enable Control
     A2XUCtlCluster   EQU 00Ch ;Cluster Control
     A2XUCtlUnderflow EQU 030h ;Underflow Control
     A2XUCtlOverflow  EQU 0C0h ;Overflow Control
    A2XUUnitStr        DB   ? ;String Index Describing Extension Unit
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Clock Source Descriptor
  ;----------------------------------------------------------------------------
  Audio2ClockSrcStruc  STRUC     ;Structure for an Audio v2 Clock Source Descr
    A2CSrcLength          DB  8  ;Size of Descriptor in bytes
    A2CSrcDescrType       DB DescrTypeAudioInterface
    A2CSrcDescrSubType    DB A2IntfDescSTypeACClkSrc
    A2CSrcClockID         DB  ?  ;Unique ID Identifying this Clock Source
    A2CSrcAttributes      DB  ?  ;Attributes
      A2CSrcTypeMask     EQU 03h ;Clock Type
        A2CSrcTypeExt    EQU 00h ;External Clock
        A2CSrcTypeIntFix EQU 01h ;Internal Fixed Clock
        A2CSrcTypeIntVar EQU 02h ;Internal Variable Clock
        A2CSrcTypeIntPrg EQU 03h ;Internal Programmable Clock
      A2CSSrcSOFSync     EQU 04h ;Clock is synchronized to Start-of-Frame
      ;Bits 3-7 = Reserved (0)
    A2CSrcControls        DB  ?  ;Controls (organized in bit-pairs)
                                 ;Setting use A2CtlNoSupt, etc.
                                 ;  (No Support, Read-Only, Illegal, Full Support)
      A2CSrcCtlClkFreq   EQU 03h ;Clock Frequency Control
      A2CSrcCtlClkValid  EQU 0Ch ;Clock Validity Control
      ;Bits 4-7 = Reserved (0)
    A2CSrcAssocTermID     DB  ?  ;Terminal ID associated with Clock Source
    A2CSrcString          DB  ?  ;Index of String Describing Clock Source Entity
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Clock Selector Descriptor
  ;Variable Size
  ;----------------------------------------------------------------------------
  Audio2ClockSelStruc STRUC    ;Structure for an Audio v2 Clock Selector Descr
    A2CSelLength        DB  ?  ;Size of Descriptor in bytes
    A2CSelDescrType     DB DescrTypeAudioInterface
    A2CSelDescrSubType  DB A2IntfDescSTypeACClkSel
    A2CSelClockID       DB  ?  ;Unique ID Identifying this Clock Selector
    A2CSelNumInPins     DB  ?  ;Number of Input Pins (P)
    A2CSelSourceID1     DB  ?  ;ID of First Clock Entity this is Connected to
    ;...
    A2CSelSourceIDP     DB  ?  ;ID of Last Clock Entity this is Connected to
    A2CSelControls      DB  ?  ;Controls (organized in bit-pairs)
                               ;Setting use A2CtlNoSupt, etc.
                               ;  (No Support, Read-Only, Illegal, Full Support)
      A2CSelCtlSelect  EQU 03h ;Clock Selector Control
      ;Bits 2-7 = Reserved (0)
    A2CSelString        DB  ?  ;Index of String Describing Clock Selector Entity
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Clock Multiplier Descriptor
  ;Variable Size
  ;----------------------------------------------------------------------------
  Audio2ClockMulStruc STRUC  ;Structure for an Audio v2 Clock Selector Descr
    A2CMLength        DB  7  ;Size of Descriptor in bytes
    A2CMDescrType     DB DescrTypeAudioInterface
    A2CMDescrSubType  DB A2IntfDescSTypeACClkMul
    A2CMClockID       DB  ?  ;Unique ID Identifying this Clock Selector
    A2CMSourceID      DB  ?  ;Clock Entity ID to which last Clock Input Pin
                             ;  of this Clock Multiplier Entity is connected
    A2CMControls      DB  ?  ;Controls (organized in bit-pairs)
                             ;Setting use A2CtlNoSupt, etc.
                             ;  (No Support, Read-Only, Illegal, Full Support)
      A2CMCtlNumer   EQU 03h ;Clock Numerator Control
      A2CMCtlDenom   EQU 0Ch ;Clock Denominator Control
      ;Bits 4-7 = Reserved (0)
    A2CMlString       DB  ?  ;Index of String Describing Clock Multiplier Entity
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Sample Rate Converter Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio2SRCUnitStruc STRUC   ;Structure for an Audio v2 SRC Descr
    A2SCLength          DB 8 ;Size of Descriptor in bytes
    A2SCDescrType       DB DescrTypeAudioInterface
    A2SCDescrSubType    DB A2IntfDescSTypeACSampCv
    A2SCUnitID          DB ? ;Unique ID Identifying this Unit
    A2SCSourceID        DB ? ;ID of Terminal/Unit this is connected to
    A2SCClkInSourceID   DB ? ;ID of Clock Entity the Input is connected to
    A2SCClkOutSourceID  DB ? ;ID of Clock Entity the Output is connected to
    A2SCUnitStr         DB ? ;String Index Describing SRC Unit
   ENDS


;==============================================================================
;Audio Version 2 Streaming Descriptor Structures
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Class-Specific Audio v2 Streaming Interface Header Descriptor
  ;----------------------------------------------------------------------------
  Audio2StrIntfStruc STRUC            ;Struc for Class-Spec Audio v2 Streaming Intf Descr
    A2SILength          DB        16  ;Size of Descriptor in bytes
    A2SIDescrType       DB DescrTypeAudioInterface
    A2SIDescrSubType    DB A2IntfDescSTypeASGeneral
    A2SITermLink        DB         ?  ;Terminal ID to which EndPoint is connected
    A2SIControls        DB         ?  ;Controls (organized in bit-pairs)
                                      ;Setting use A2CtlNoSupt, etc.
                                      ;  (No Support, Read-Only, Illegal, Full Support)
      A2SICtlActivAlt  EQU        03h ;Active Alternate Setting Control
      A2SICtlValidAlt  EQU        0Ch ;Valid Alternate Setting Control
      ;Bits 4-7 = Reserved (0)
    A2SIFormatType      DB         ?  ;Format Type
      ;AudFmtUndef, AudFmtType1, etc.)
    A2SIFormats         DD         ?  ;Supported Data Formats (bitmap)
     ;-------------------------------------------------------------------------
     ;Type 1:
     ;-------------------------------------------------------------------------
      A2FT1PCM         EQU 0000_0001h ;Pulse Code Modulation
      A2FT1PCM8        EQU 0000_0002h ;8-bit Pulse Code Modulation
      A2FT1IEEEFloat   EQU 0000_0004h ;IEEE Floating Point
      A2FT1ALaw        EQU 0000_0008h ;A-Law (Non-US Telephony)
      A2FT1ULaw        EQU 0000_0010h ;æ-Law (US Telephony)
      ;Bits 5-30 = Reserved (0)
      A2FT1RawData     EQU 8000_0000h ;Raw Data
     ;-------------------------------------------------------------------------
     ;Type 2:
     ;-------------------------------------------------------------------------
      A2FT2MPEG        EQU 0000_0001h ;MPEG
      A2FT2AC3         EQU 0000_0002h ;AC-3
      A2FT2WMA         EQU 0000_0004h ;WMA
      A2FT2DTS         EQU 0000_0008h ;DTS
      ;Bits 4-30 = Reserved (0)
      A2FT2RawData     EQU 8000_0000h ;Raw Data
     ;-------------------------------------------------------------------------
     ;Type 3:
     ;-------------------------------------------------------------------------
      A2FT3IECAC3      EQU 0000_0001h ;IEC61937 AC-3
      A2FT3IECMPEG1    EQU 0000_0002h ;IEC61937 MPEG Layer 1
      A2FT3IECMPEG2    EQU 0000_0004h ;IEC61937 MPEG Layer 2/3 or MPEG 2 - No Ext
      A2FT3IECMPEG2Ext EQU 0000_0008h ;IEC61937 MPEG Layer 2 Ext
      A2FT3IECMPEG2AAC EQU 0000_0010h ;IEC61937 MPEG Layer 2 AAC ATDS
      A2FT3IECMPEG21LS EQU 0000_0020h ;IEC61937 MPEG Layer 2 Layer 1 LS
      A2FT3IECMPEG22LS EQU 0000_0040h ;IEC61937 MPEG Layer 2 Layer 2/3 LS
      A2FT3IECDTS1     EQU 0000_0080h ;IEC61937 DTS-I
      A2FT3IECDTS2     EQU 0000_0100h ;IEC61937 DTS-II
      A2FT3IECDTS3     EQU 0000_0200h ;IEC61937 DTS-III
      A2FT3IECATRAC    EQU 0000_0400h ;IEC61937 ATRAC
      A2FT3IECATRAC2   EQU 0000_0800h ;IEC61937 ATRAC2/3
      A2FT3WMA3        EQU 0000_1000h ;Type III WMA
      ;Bits 13-31 = Reserved (0)
     ;-------------------------------------------------------------------------
     ;Type 4:
     ;-------------------------------------------------------------------------
      A2FT4PCM         EQU 0000_0001h ;Pulse Code Modulation
      A2FT4PCM8        EQU 0000_0002h ;8-bit Pulse Code Modulation
      A2FT4IEEEFloat   EQU 0000_0004h ;IEEE Floating Point
      A2FT4ALaw        EQU 0000_0008h ;A-Law (Non-US Telephony)
      A2FT4ULaw        EQU 0000_0010h ;æ-Law (US Telephony)
      A2FT4MPEG        EQU 0000_0020h ;MPEG
      A2FT4AC3         EQU 0000_0040h ;AC-3
      A2FT4WMA         EQU 0000_0080h ;WMA
      A2FT4IECAC3      EQU 0000_0100h ;IEC61937 AC-3
      A2FT4IECMPEG1    EQU 0000_0200h ;IEC61937 MPEG Layer 1
      A2FT4IECMPEG2    EQU 0000_0400h ;IEC61937 MPEG Layer 2/3 or MPEG 2 - No Ext
      A2FT4IECMPEG2Ext EQU 0000_0800h ;IEC61937 MPEG Layer 2 Ext
      A2FT4IECMPEG2AAC EQU 0000_1000h ;IEC61937 MPEG Layer 2 AAC ATDS
      A2FT4IECMPEG21LS EQU 0000_2000h ;IEC61937 MPEG Layer 2 Layer 1 LS
      A2FT4IECMPEG22LS EQU 0000_4000h ;IEC61937 MPEG Layer 2 Layer 2/3 LS
      A2FT4IECDTS1     EQU 0000_8000h ;IEC61937 DTS-I
      A2FT4IECDTS2     EQU 0001_0000h ;IEC61937 DTS-II
      A2FT4IECDTS3     EQU 0002_0000h ;IEC61937 DTS-III
      A2FT4IECATRAC    EQU 0004_0000h ;IEC61937 ATRAC
      A2FT4IECATRAC2   EQU 0008_0000h ;IEC61937 ATRAC2/3
      A2FT4WMA3        EQU 0010_0000h ;Type III WMA
      A2FT4IECPCM      EQU 0020_0000h ;IEC60958 PCM
      ;Bits 22-31 = Reserved (0)
    A2SINumOutChans    DB          ?  ;Number of Physical Channels in Cluster
    A2SISpatial        DD          ?  ;Spatial Locations of Physical Channels (Bitmap)
    A2SIChanStr        DB          ?  ;String Index Describing First Physical Channel
   ENDS
   ;May be followed by Format-specific Data Descriptor

  ;----------------------------------------------------------------------------
  ;Audio v2 Audio Streaming Encoder Descriptor
  ;----------------------------------------------------------------------------
  Audio2EncoderStruc STRUC            ;Structure for an Audio v2 Encoder Descr
    A2EnLength          DB        18  ;Size of Descriptor in bytes
    A2EnDescrType       DB DescrTypeAudioInterface
    A2EnDescrSubType    DB A2IntfDescSTypeASEncoder
    A2EnEncoderID       DB         ?  ;Unique ID Identifying this Encoder
    A2EnEncoderType     DB         ?  ;Encoder Type
      A2EnTypeUndef    EQU        00h ;Undefined
      A2EnTypeOther    EQU        01h ;Other
      A2EnTypeMPEG     EQU        02h ;MPEG
      A2EnTypeAC3      EQU        03h ;AC-3
      A2EnTypeWMA      EQU        04h ;WMA
      A2EnTypeDTS      EQU        05h ;DTS
    A2EnControls        DD         ?  ;Controls (organized in bit-pairs)
                                      ;Setting use A2CtlNoSupt, etc.
                                      ;  (No Supt, Read-Only, Illegal, Full Supt)
      A2EnCtlBitRate   EQU 0000_0003h ;Bit Rate Control
      A2EnCtlQuality   EQU 0000_000Ch ;Quality Control
      A2EnCtlVBR       EQU 0000_0030h ;VBR (Variable Bit Rate?) Control
      A2EnCtlType      EQU 0000_00C0h ;Type Control
      A2EnCtlUnderflow EQU 0000_0300h ;Underflow Control
      A2EnCtlOverflow  EQU 0000_0C00h ;Overflow Control
      A2EnCtlError     EQU 0000_3000h ;Encoder Error Control
      A2EnCtlParam1    EQU 0000_C000h ;Parameter 1 Control
      A2EnCtlParam2    EQU 0003_0000h ;Parameter 2 Control
      A2EnCtlParam3    EQU 000C_0000h ;Parameter 3 Control
      A2EnCtlParam4    EQU 0030_0000h ;Parameter 4 Control
      A2EnCtlParam5    EQU 00C0_0000h ;Parameter 5 Control
      A2EnCtlParam6    EQU 0300_0000h ;Parameter 6 Control
      A2EnCtlParam7    EQU 0C00_0000h ;Parameter 7 Control
      A2EnCtlParam8    EQU 3000_0000h ;Parameter 8 Control
      ;Bits 30-31 = Reserved (0)
    A2EnParam1Str       DB         ?  ;String Index Describing Parameter 1
    A2EnParam2Str       DB         ?  ;String Index Describing Parameter 2
    A2EnParam3Str       DB         ?  ;String Index Describing Parameter 3
    A2EnParam4Str       DB         ?  ;String Index Describing Parameter 4
    A2EnParam5Str       DB         ?  ;String Index Describing Parameter 5
    A2EnParam6Str       DB         ?  ;String Index Describing Parameter 6
    A2EnParam7Str       DB         ?  ;String Index Describing Parameter 7
    A2EnParam8Str       DB         ?  ;String Index Describing Parameter 8
    A2EnEncoderStr      DB         ?  ;String Index Describing Encoder
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Audio Streaming MPEG Decoder Descriptor
  ;----------------------------------------------------------------------------
  Audio2MPEGDecoderStruc STRUC      ;Struc for Audio v2 MPEG Decoder Descr
    A2MDLength             DB   10  ;Size of Descriptor in bytes
    A2MDDescrType          DB DescrTypeAudioInterface
    A2MDDescrSubType       DB A2IntfDescSTypeASDecoder
    A2MDDecoderID          DB    ?  ;Unique ID Identifying this Decoder
    A2MDDecoderType        DB A2DecTypeMPEG
    A2MDCapabilities       DW    ?  ;Decoder Capabilites BitMap
      A2MDCapLayer1       EQU 0001h ;MPEG Layer 1 Support
      A2MDCapLayer2       EQU 0002h ;MPEG Layer 2 Support
      A2MDCapLayer3       EQU 0004h ;MPEG Layer 3 Support
      A2MDCap1Only        EQU 0008h ;MPEG-1 Only
      A2MDCap1DualChan    EQU 0010h ;MPEG-1 Dual-Channer
      A2MDCapSecStereo    EQU 0020h ;MPEG-2 Second Stereo
      A2MDCap271Augment   EQU 0040h ;MPEG-2 7.1 Channel Augmentation
      A2MDCapAMP          EQU 0080h ;Adaptive Multi-Channel Prediction
      A2MDCap2MLingual    EQU 0300h ;MPEG-2 Multilingual Support
        A2MDCapMLNoSupt   EQU 0000h ;Not Supported
        A2MDCapMLFs       EQU 0100h ;Supported at Fs (Full Speed??  Frame Speed??)
        A2MDCapMLRsvd     EQU 0200h ;Reserved
        A2MDCapMLBoth     EQU 0300h ;Supported at Fs and «Fs
      A2MDCapHalfFs       EQU 0400h ;Support for «Fs
      ;Bits 11-15 = Reserved (0)
    A2MDFeatures           DB    ?
      ;Bits 0-3 = Reserved (0)
      A2MDFtrDynRange     EQU   30h ;Internal Dynamic Range Control
        A2MDFtrDRNoSupt   EQU   00h ;Not Supported
        A2MDFtrDRNoScale  EQU   10h ;Supported but not Scalable
        A2MDFtrDRCommon   EQU   20h ;Scalable w/ Common Boost & Cut Scaling Value
        A2MDFtrDRSeparate EQU   30h ;Scalable w/ Separate Boost & Cut Scaling Value
      ;Bits 6-7 = Reserved (0)
    A2MDControls           DB    ?  ;Controls (organized in bit-pairs)
                                    ;Setting use A2CtlNoSupt, etc.
                                    ;  (No Supt, Read-Only, Illegal, Full Supt)
      A2MDCtlUnderflow    EQU   03h ;Underflow Control
      A2MDCtlOverflow     EQU   0Ch ;Overflow Control
      A2MDCtlError        EQU   30h ;Decoder Error Control
      ;Bits 6-7 = Reserved (0)
    A2MDDecoderStr         DB    ?  ;String Index Describing Encoder
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Audio Streaming AC-3 Decoder Descriptor
  ;----------------------------------------------------------------------------
  Audio2AC3DecoderStruc STRUC       ;Struc for Audio v2 AC-3 Decoder Descr
    A2ADLength             DB   12  ;Size of Descriptor in bytes
    A2ADDescrType          DB DescrTypeAudioInterface
    A2ADDescrSubType       DB A2IntfDescSTypeASDecoder
    A2ADDecoderID          DB    ?  ;Unique ID Identifying this Decoder
    A2ADDecoderType        DB A2DecTypeAC3
    A2ADBSIDModeSupt       DD    ?  ;BSID Modes Supported (Bit 0 = Mode 0, etc.)
                                    ; Bits 0-8 MUST be set
    A2ADFeatures           DB    ?  ;Supported Features
      A2ADFtrRFMode       EQU   01h ;RF Mode
      A2ADFtrLineMode     EQU   02h ;Line Mode
      A2ADFtrCustom0      EQU   04h ;Custom0 Mode
      A2ADFtrCustom1      EQU   08h ;Custom1 Mode
      A2ADFtrDynRange     EQU   30h ;Internal Dynamic Range Control
        A2ADFtrDRNoSupt   EQU   00h ;Not Supported
        A2ADFtrDRNoScale  EQU   10h ;Supported but not Scalable
        A2ADFtrDRCommon   EQU   20h ;Scalable w/ Common Boost & Cut Scaling Value
        A2ADFtrDRSeparate EQU   30h ;Scalable w/ Separate Boost & Cut Scaling Value
      ;Bits 6-7 = Reserved (0)
    A2ADControls           DB    ?  ;Controls (organized in bit-pairs)
                                    ;Setting use A2CtlNoSupt, etc.
                                    ;  (No Supt, Read-Only, Illegal, Full Supt)
      A2ADCtlUnderflow    EQU   03h ;Underflow Control
      A2ADCtlOverflow     EQU   0Ch ;Overflow Control
      A2ADCtlError        EQU   30h ;Decoder Error Control
      ;Bits 6-7 = Reserved (0)
    A2ADDecoderStr         DB    ?  ;String Index Describing Encoder
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Audio Streaming WMA Decoder Descriptor
  ;----------------------------------------------------------------------------
  Audio2WMADecoderStruc STRUC    ;Struc for Audio v2 WMA Decoder Descr
    A2WDLength          DB    9  ;Size of Descriptor in bytes
    A2WDDescrType       DB DescrTypeAudioInterface
    A2WDDescrSubType    DB A2IntfDescSTypeASDecoder
    A2WDDecoderID       DB    ?  ;Unique ID Identifying this Decoder
    A2WDDecoderType     DB A2DecTypeWMA
    A2WDWMAProfile      DW    ?  ;WMA Supported Features Profile
      A2WDPrfL1        EQU 0001h ;WMA Profile 1, L1
      A2WDPrfL2        EQU 0002h ;WMA Profile 2, L2
      A2WDPrfL3        EQU 0004h ;WMA Profile 3, L3
      A2WDPrfLOther    EQU 0008h ;WMA Profile Other, L
      A2WDPrfS1        EQU 0010h ;WMA Speech 1, S1
      A2WDPrfS2        EQU 0020h ;WMA Speech 2, S2
      A2WDPrfProM1     EQU 0040h ;WMAPro Profile 1, M1
      A2WDPrfProM2     EQU 0080h ;WMAPro Profile 2, M2
      A2WDPrfProM3     EQU 0100h ;WMAPro Profile 3, M3
      A2WDPrfProMOther EQU 0200h ;WMAPro Profile Other, M
      A2WDPrfLossless  EQU 0400h ;Lossless Decoding is Supported
      ;Bits 11-15 = Reserved (0)
    A2WDControls        DB    ?  ;Controls (organized in bit-pairs)
                                 ;Setting use A2CtlNoSupt, etc.
                                 ;  (No Supt, Read-Only, Illegal, Full Supt)
      A2WDCtlUnderflow EQU   03h ;Underflow Control
      A2WDCtlOverflow  EQU   0Ch ;Overflow Control
      A2WDCtlError     EQU   30h ;Decoder Error Control
      ;Bits 6-7 = Reserved (0)
    A2WDDecoderStr      DB    ?  ;String Index Describing Encoder
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Audio Streaming DTS Decoder Descriptor
  ;----------------------------------------------------------------------------
  Audio2DTSDecoderStruc STRUC     ;Struc for Audio v2 DTS Decoder Descr
    A2DDLength            DB   8  ;Size of Descriptor in bytes
    A2DDDescrType         DB DescrTypeAudioInterface
    A2DDDescrSubType      DB A2IntfDescSTypeASDecoder
    A2DDDecoderID         DB   ?  ;Unique ID Identifying this Decoder
    A2DDDecoderType       DB A2DecTypeDTS
    A2DDCapabilities      DB   ?  ;Decoder Capabilities Supported
      A2DDCapCore        EQU  01h ;Core
      A2DDCapLossless    EQU  02h ;Lossless
      A2DDCapLBR         EQU  04h ;LBR
      A2DDCapMultiStream EQU  08h ;Multiple Stream Mixing
      A2DDCapDualDecode  EQU  10h ;Dual Decode
      ;Bits 5-7 = Reserved (0)
    A2DDControls          DB   ?  ;Controls (organized in bit-pairs)
                                  ;Setting use A2CtlNoSupt, etc.
                                  ;  (No Supt, Read-Only, Illegal, Full Supt)
      A2DDCtlReserved    EQU  03h ;Reserved (must be set to 0)
      A2DDCtlUnderflow   EQU  0Ch ;Underflow Control
      A2DDCtlOverflow    EQU  30h ;Overflow Control
      A2DDCtlError       EQU 0C0h ;Decoder Error Control
    A2DDDecoderStr        DB   ?  ;String Index Describing Encoder
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Data Format Type I Descriptor Structure
  ;----------------------------------------------------------------------------
  A2FmtType1Struc STRUC   ;Struc for Audio v2 Data Format Type I Descriptor
    A2FT1Length      DB 6 ;Size of Descriptor in bytes
    A2FT1DescrType   DB DescrTypeAudioInterface
    A2FT1DescrSType  DB A2IntfDescSTypeASFmtType
    A2FT1FormatType  DB AudFmtType1
    A2FT1SubSlotSize DB ? ;Number of Bytes in Audio SubSlot (1-4)
    A2FT1Resolution  DB ? ;Number of effectively used bits per SubSlot
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Data Format Extended Type I Descriptor Structure
  ;  (Type I with a Packet Header)
  ;----------------------------------------------------------------------------
  A2FmtType1XStruc STRUC  ;Struc for Audio v2 Extended Type I Descr
    A2FT1XCommon     DB (TYPE A2FmtType1Struc) DUP (?)
      ;First part is same as basic Type I Structure, with following values:
      ;  Length   = 9
      ;  FormatType = AudFmtExt1
    A2FT1XHeaderLen  DB ? ;Size of Packet Header (Bytes)
    A2FT1XControlSz  DB ? ;Size of Control Channel Words (Bytes)
    A2FT1XSBProtocol DB ? ;Side Band Protocol
      ;A2SBProtocolUndef, etc.
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Data Format Type II Descriptor Structure
  ;----------------------------------------------------------------------------
  A2FmtType2Struc   STRUC   ;Struc for Audio v2 Data Format Type II Descriptor
    A2FT2Length        DB 8 ;Size of Descriptor in bytes
    A2FT2DescrType     DB DescrTypeAudioInterface
    A2FT2DescrSType    DB A2IntfDescSTypeASFmtType
    A2FT2FormatType    DB AudFmtType2
    A2FT2MaxKbps       DW ? ;Maximum bit rate Interface cn handle (kbps)
    A2FT2SlotsPerFrame DW ? ;Number of PCM Slots per Encoded Frame
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Data Format Extended Type II Descriptor Structure
  ;  (Type II with a Packet Header)
  ;----------------------------------------------------------------------------
  A2FmtType2XStruc STRUC  ;Struc for Audio v2 Extended Type II Descr
    A2FT2XCommon     DB (TYPE A2FmtType2Struc) DUP (?)
      ;First part is same as basic Type II Structure, with following values:
      ;  Length   = 10
      ;  FormatType = AudFmtExt2
    A2FT2XHeaderLen  DB ? ;Size of Packet Header (Bytes)
    A2FT2XSBProtocol DB ? ;Side Band Protocol
      ;A2SBProtocolUndef, etc.
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Data Format Type III Descriptor Structure
  ;----------------------------------------------------------------------------
  ;This structure is EXACTLY the same as the Type I Descriptor, with the
  ;  following dedicated values in some of the fields:
  ;  FormatType  = AudFmtType3
  ;  SubSlotSize = 2

  ;----------------------------------------------------------------------------
  ;Audio v2 Data Format Extended Type III Descriptor Structure
  ;  (Type III with a Packet Header)
  ;----------------------------------------------------------------------------
  A2FmtType3XStruc STRUC  ;Struc for Audio v2 Extended Type III Descr
    A2FT3XCommon     DB (TYPE A2FmtType1Struc) DUP (?)
      ;First part is same as basic Type II Structure, with following values:
      ;  Length     = 8
      ;  FormatType = AudFmtExt3
      ;  SubSlotSize = 2
    A2FT3XHeaderLen  DB ? ;Size of Packet Header (Bytes)
    A2FT3XSBProtocol DB ? ;Side Band Protocol
      ;A2SBProtocolUndef, etc.
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Data Format Type IV Descriptor Structure
  ;----------------------------------------------------------------------------
  A2FmtType4Struc STRUC  ;Struc for Audio v2 Data Format Type IV Descriptor
    A2FT2Length     DB 4 ;Size of Descriptor in bytes
    A2FT2DescrType  DB DescrTypeAudioInterface
    A2FT2DescrSType DB A2IntfDescSTypeASFmtType
    A2FT2FormatType DB AudFmtType4
   ENDS

  ;----------------------------------------------------------------------------
  ;Audio v2 Class-Specific Isochronous EndPoint Descriptor Structure
  ;----------------------------------------------------------------------------
  A2EndPointStruc   STRUC     ;Struc for Audio v2 Isoch EndPt Descr
    A2EPLength         DB  8  ;Size of Descriptor in bytes
    A2EPDescrType      DB DescrTypeAudioEndPoint
    A2EPDescrSType     DB AEndPtDescSTypeGeneral
    A2EPAttribs        DB  ?  ;EndPoint Attributes Support Bitmap
      ;Bits 0-6 = Reserved (0)
      A2EPAtrMaxPkts  EQU 80h ;Max Packet Size Only
    A2EPControls       DB  ?  ;Controls (organized in bit-pairs)
                              ;Setting use A2CtlNoSupt, etc.
                              ;  (No Support, Read-Only, Illegal, Full Support)
      A2EPCtlPitch    EQU 03h ;Pitch Control
      A2EPCtlOverrun  EQU 0Ch ;Data Overrun Control
      A2EPCtlUnderrun EQU 30h ;Data Underrun Control
      ;Bits 6-7 = Reserved (0)
    A2EPLockDelayUnit  DB  ?  ;Units used for Lock Delay Field
      ;AudLkDlyUnitUndef, etc.
    A2EPLockDelay      DW  ?  ;Time it takes EndPoint to reliably lock to
                              ;  internal clock recovery circuitry
   ENDS


  ;----------------------------------------------------------------------------
  ;For each Line in Table:
  ;First Byte of Each Entry is the Descriptor Type Code
  ;First Word of each Sub-Entry is a "special" subroutine pointer to perform
  ;  for the entry after the raw data is written.  In general, this is a
  ;  subroutine that "deciphers" the number to a description through one
  ;  of the lookup tables.  For Instance, one of the routines "converts"
  ;  a Version number from a "raw" BCD format to a Major.Minor string.
  ;Next byte of each sub-entry is the number of bytes of data (1 or 2)
  ;  that the entry uses.
  ;After that is the string to write describing the sub-entry item.
  ;In printing out the details, the String is written first, followed by the
  ;  "raw" number (a byte or a word), followed by the output of the "special"
  ;  subroutine.
  ;----------------------------------------------------------------------------


  ;----------------------------------------------------------------------------
  ;Debug Descriptor Structure (USB 2.0/EHCI)
  ;----------------------------------------------------------------------------
  DebugDescrStruc STRUC ;Struc for an Interface Association Descriptor
    DbgLength    DB ? ;Size of Descriptor in bytes (4)
    DbgDescrType DB DescrTypeDebug
    DbgEndPtIn   DB ? ;Debug In EndPoint
    DbgEndPtOut  DB ? ;Debug out EndPoint
   ENDS

  ;----------------------------------------------------------------------------
  ;Interface Association Descriptor Structure
  ;----------------------------------------------------------------------------
  IntfAssocDescrStruc STRUC ;Struc for an Interface Association Descriptor
    IADLength       DB ? ;Size of Descriptor in bytes (8)
    IADDescrType    DB DescrTypeIntfAssoc
    IADFirstInst    DB ? ;First Interface Number Associated with this Function
    IADIntfCount    DB ? ;# of contiguous Intf's associated with this Function
    IADFuncClass    DB ? ;Class Code
    IADFuncSubClass DB ? ;SubClass Code
    IADFuncProt     DB ? ;Protocol Code
    IADFuncString   DB ? ;Index of String Descriptor for this Function
   ENDS


  ;----------------------------------------------------------------------------
  ;Data gleaned from General USB Descriptors, needed to process
  ;  Class-Specific Descriptors appropriately.
  ;----------------------------------------------------------------------------
  DeviceClass        DB 0 ;Device Class
  DeviceSubClass     DB 0 ;Device SubClass
  DeviceProtocol     DB 0 ;Device Protocol
  InterfaceClass     DB 0 ;Interface Class
  InterfaceSubClass  DB 0 ;Interface SubClass
  InterfaceProtocol  DB 0 ;Interface Protocol
  DeviceUSBRelease   DW 0 ;USB Release Version of Device
  DeviceClassRelease DW 0 ;Class-Specific Release Version of Device

;  DvcDescriptionTbl:
;  ;Audio
;    DB 0FFh, 0FFh, 0FFh,  01h,  01h,  00h, 'Audio Ctl v1  ',0
;    DB 0FFh, 0FFh, 0FFh,  01h,  01h,  20h, 'Audio Ctl v2  ',0
;    DB 0FFh, 0FFh, 0FFh,  01h,  02h,  00h, 'Audio Strm v1 ',0
;    DB 0FFh, 0FFh, 0FFh,  01h,  02h,  20h, 'Audio Strm v2 ',0
;    DB 0FFh, 0FFh, 0FFh,  01h,  03h, 0FFh, 'MIDI Stream   ',0
;    DB 0FFh, 0FFh, 0FFh,  01h, 0FFh, 0FFh, 'Audio Device? ',0
;  ;Communications
;    DB  02h,  00h,  00h,  02h,  00h,  00h, 'Comm Device   ',0
;    DB  02h,  00h,  00h,  02h,  01h,  00h, 'Comm Direct Ln',0
;    DB  02h,  00h,  00h,  02h,  02h,  00h, 'Modem         ',0
;    DB  02h,  00h,  00h,  02h,  02h,  01h, 'Modem V.25ter ',0
;    DB  02h,  00h,  00h,  02h,  02h,  02h, 'Modem PCCA101 ',0
;    DB  02h,  00h,  00h,  02h,  02h,  03h, 'Modem PCCA101w',0
;    DB  02h,  00h,  00h,  02h,  02h,  04h, 'Modem GSM     ',0
;    DB  02h,  00h,  00h,  02h,  02h,  05h, 'Modem 3G      ',0
;    DB  02h,  00h,  00h,  02h,  02h,  06h, 'Modem CDMA    ',0
;    DB  02h,  00h,  00h,  02h,  02h, 0FEh, 'Modem Custom  ',0
;    DB  02h,  00h,  00h,  02h,  02h, 0FFh, 'Modem?        ',0
;    DB  02h,  00h,  00h,  02h,  03h,  00h, 'Telephone Comm',0
;    DB  02h,  00h,  00h,  02h,  04h,  00h, 'MultiChan Comm',0
;    DB  02h,  00h,  00h,  02h,  05h,  00h, 'ISDN CAPI Dvc ',0
;    DB  02h,  00h,  00h,  02h,  06h,  00h, 'Ethernet Dvc  ',0
;    DB  02h,  00h,  00h,  02h,  07h,  00h, 'ATM Device    ',0
;    DB  02h,  00h,  00h,  02h,  08h,  00h, 'Wirels Handset',0
;    DB  02h,  00h,  00h,  02h,  09h,  00h, 'Comm Dvc Mgmt ',0
;    DB  02h,  00h,  00h,  02h,  0Ah,  00h, 'Mobl Direct Ln',0
;    DB  02h,  00h,  00h,  02h,  0Bh,  00h, 'OBEX Comm Dvc ',0
;    DB  02h,  00h,  00h,  02h,  0Ch,  00h, 'Ethernet Emul ',0
;    DB  02h,  00h,  00h,  02h,  0Ch,  07h, 'Ethernet Emul ',0
;    DB  02h,  00h,  00h,  02h,  0Ch, 0FFh, 'Ethernet Emul?',0
;    DB  02h,  00h,  00h,  02h, 0FFh, 0FFh, 'Comm Device?  ',0
;  ;Communications Control
;    DB  02h,  00h,  00h,  0Ah,  00h,  30h, 'I.430 ISDN BRI',0
;    DB  02h,  00h,  00h,  0Ah,  00h,  31h, 'HDLC          ',0
;    DB  02h,  00h,  00h,  0Ah,  00h,  32h, 'Transp Data   ',0
;    DB  02h,  00h,  00h,  0Ah,  00h,  50h, 'Q.921M ISDN   ',0
;    DB  02h,  00h,  00h,  0Ah,  00h,  51h, 'Q.921 ISDN    ',0
;    DB  02h,  00h,  00h,  0Ah,  00h,  52h, 'Q.921TM ISDN  ',0
;    DB  02h,  00h,  00h,  0Ah,  00h,  90h, 'V.42bis       ',0
;    DB  02h,  00h,  00h,  0Ah,  00h,  91h, 'Q.931/EuroISDN',0
;    DB  02h,  00h,  00h,  0Ah,  00h,  92h, 'V.120 ISDN    ',0
;    DB  02h,  00h,  00h,  0Ah,  00h,  93h, 'CAPI 2.0 ISDN ',0
;    DB  02h,  00h,  00h,  0Ah,  00h, 0FDh, 'Host-Based    ',0
;    DB  02h,  00h,  00h,  0Ah,  00h, 0FEh, 'Protocol Unit ',0
;    DB  02h,  00h,  00h,  0Ah,  00h, 0FFh, 'Comm Device?  ',0
;  ;Human Interface Devices
;    DB 0FFh, 0FFh, 0FFh,  03h,  00h,  00h, 'Human Intf Dvc',0
;    DB 0FFh, 0FFh, 0FFh,  03h,  01h,  01h, 'Keyboard      ',0
;    DB 0FFh, 0FFh, 0FFh,  03h,  01h,  02h, 'Mouse         ',0
;    DB 0FFh, 0FFh, 0FFh,  03h, 0FFh, 0FFh, 'Human Int Dvc?',0
;  ;Physical
;    DB 0FFh, 0FFh, 0FFh,  05h,  00h,  00h, 'Physical Dvc  ',0
;    DB 0FFh, 0FFh, 0FFh,  05h, 0FFh, 0FFh, 'Physical Dvc? ',0
;  ;Imaging
;    DB 0FFh, 0FFh, 0FFh,  06h,  01h,  01h, 'Still Image   ',0
;    DB 0FFh, 0FFh, 0FFh,  06h, 0FFh, 0FFh, 'Image Device? ',0
;  ;Printer
;    DB 0FFh, 0FFh, 0FFh,  07h,  01h,  00h, 'Printer       ',0
;    DB 0FFh, 0FFh, 0FFh,  07h,  01h,  01h, 'UniDir Printer',0
;    DB 0FFh, 0FFh, 0FFh,  07h,  01h,  02h, 'BiDir Printer ',0
;    DB 0FFh, 0FFh, 0FFh,  07h,  01h,  03h, '1284.4 Printer',0
;    DB 0FFh, 0FFh, 0FFh,  07h,  01h, 0FFh, 'Printer?      ',0
;  ;Mass Storage
;    DB 0FFh, 0FFh, 0FFh,  08h,  00h,  00h, 'Mass Storage  ',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  01h,  00h, 'Reduc Blk CBI ',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  01h,  01h, 'Reduc Blk CB  ',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  01h,  50h, 'Reduc Blk Bulk',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  01h, 0FFh, 'Reduced Block ',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  02h,  00h, 'ATAPI CBI     ',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  02h,  01h, 'ATAPI CB      ',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  02h,  50h, 'ATAPI Bulk    ',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  02h, 0FFh, 'ATAPI (CD/DVD)',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  03h,  00h, 'QIC-157 CBI   ',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  03h,  01h, 'QIC-157 CB    ',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  03h,  50h, 'QIC-157 Bulk  ',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  03h, 0FFh, 'QIC-157 (Tape)',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  04h,  00h, 'UFI Floppy CBI',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  04h,  01h, 'UFI Floppy CB ',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  04h,  50h, 'UFI Floppy Blk',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  04h, 0FFh, 'UFI Floppy    ',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  05h,  00h, 'SFF-8070i CBI ',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  05h,  01h, 'SFF-8070i CB  ',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  05h,  50h, 'SFF-8070i Bulk',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  05h, 0FFh, 'SFF-8070i Flpy',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  06h,  00h, 'SCSI Trsp CBI ',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  06h,  01h, 'SCSI Trsp CB  ',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  06h,  50h, 'SCSI Trsp Bulk',0
;    DB 0FFh, 0FFh, 0FFh,  08h,  06h, 0FFh, 'SCSI Transp   ',0
;    DB 0FFh, 0FFh, 0FFh,  08h, 0FFh, 0FFh, 'Mass Storage? ',0
;  ;Hub
;    DB  09h,  00h,  00h, 0FFh, 0FFh, 0FFh, 'Hub v1 Generic',0
;    DB  09h,  00h,  01h, 0FFh, 0FFh, 0FFh, 'Hub v2 SinglTT',0
;    DB  09h,  00h,  02h, 0FFh, 0FFh, 0FFh, 'Hub v2 MultiTT',0
;    DB  09h,  00h, 0FFh, 0FFh, 0FFh, 0FFh, 'Generic Hub?  ',0
;  ;Smart Card
;    DB 0FFh, 0FFh, 0FFh,  0Bh,  00h,  00h, 'Chip/SmartCard',0
;    DB 0FFh, 0FFh, 0FFh,  0Bh, 0FFh, 0FFh, 'Chip/SmartCrd?',0
;  ;Content Security
;    DB 0FFh, 0FFh, 0FFh,  0Dh,  00h,  00h, 'Cont Security ',0
;    DB 0FFh, 0FFh, 0FFh,  0Dh, 0FFh, 0FFh, 'Cont Security?',0
;  ;Video
;    DB 0FFh, 0FFh, 0FFh,  0Eh,  00h,  00h, 'Video Device  ',0
;    DB 0FFh, 0FFh, 0FFh,  0Eh,  01h,  00h, 'Video Control ',0
;    DB 0FFh, 0FFh, 0FFh,  0Eh,  02h,  00h, 'Video Stream  ',0
;    DB 0FFh, 0FFh, 0FFh,  0Eh,  03h,  00h, 'Video Intf Col',0
;    DB 0FFh, 0FFh, 0FFh,  0Eh, 0FFh, 0FFh, 'Video Device? ',0
;  ;Personal Healthcare
;    DB 0FFh, 0FFh, 0FFh,  0Fh, 0FFh, 0FFh, 'Healthcare Dvc',0
;  ;Diagnostic Device
;    DB 0FFh, 0FFh, 0FFh, 0DCh,  00h,  00h, 'Diagnostic Dvc',0
;    DB 0DCh,  00h,  00h, 0FFh, 0FFh, 0FFh, 'Diagnostic Dvc',0
;    DB 0FFh, 0FFh, 0FFh, 0DCh,  01h,  01h, 'USB2 Complianc',0
;    DB 0DCh,  01h,  01h, 0FFh, 0FFh, 0FFh, 'USB2 Complianc',0
;    DB 0DCh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 'Diagnostic?   ',0
;    DB 0FFh, 0FFh, 0FFh, 0DCh, 0FFh, 0FFh, 'Diagnostic?   ',0
;  ;Wireless Controller
;    DB  00h,  00h,  00h, 0E0h,  00h,  00h, 'Wireless Dvc  ',0
;    DB 0FFh, 0FFh, 0FFh, 0E0h,  01h,  01h, 'BlueTooth Dvc ',0
;    DB  00h,  00h,  00h, 0E0h,  01h,  02h, 'Ultra WB Radio',0
;    DB  00h,  00h,  00h, 0E0h,  01h,  03h, 'Remote NDIS   ',0
;    DB  00h,  00h,  00h, 0E0h,  02h,  01h, 'Host Wire Ctl ',0
;    DB  00h,  00h,  00h, 0E0h,  02h,  02h, 'Dvc Wire Ctl  ',0
;    DB  00h,  00h,  00h, 0E0h,  02h,  03h, 'Dvc Wire Isoch',0
;    DB 0E0h,  01h,  01h, 0FFh, 0FFh, 0FFh, 'BlueTooth Dvc ',0
;    DB  00h, 0FFh, 0FFh, 0E0h, 0FFh, 0FFh, 'Wireless Dvc? ',0
;  ;Miscellaneous
;    DB 0FFh, 0FFh, 0FFh, 0EFh,  00h,  00h, 'Miscellaneous ',0
;    DB 0EFh,  00h,  00h, 0FFh, 0FFh, 0FFh, 'Miscellaneous ',0
;    DB 0FFh, 0FFh, 0FFh, 0EFh,  01h,  01h, 'Active Sync   ',0
;    DB 0EFh,  01h,  01h, 0FFh, 0FFh, 0FFh, 'Active Sync   ',0
;    DB 0FFh, 0FFh, 0FFh, 0EFh,  01h,  02h, 'Palm Sync     ',0
;    DB 0EFh,  01h,  02h, 0FFh, 0FFh, 0FFh, 'Palm Sync     ',0
;;    DB 0EFh,  02h,  01h, 0FFh, 0FFh, 0FFh, 'Intf Assoc    ',0
;    DB 0FFh, 0FFh, 0FFh, 0EFh,  02h,  02h, 'Wire Adapter  ',0
;    DB 0EFh,  02h,  02h, 0FFh, 0FFh, 0FFh, 'Wire Adapter  ',0
;    DB 0FFh, 0FFh, 0FFh, 0EFh,  03h,  02h, 'Cable Assoc   ',0
;    DB 0EFh,  03h,  02h, 0FFh, 0FFh, 0FFh, 'Cable Assoc   ',0
;    DB 0FFh, 0FFh, 0FFh, 0EFh, 0FFh, 0FFh, 'Miscellaneous?',0
;    DB 0EFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 'Miscellaneous?',0
;  ;Application Specific
;    DB 0FFh, 0FFh, 0FFh, 0FEh,  01h,  00h, 'Firmware Updat',0
;    DB 0FFh, 0FFh, 0FFh, 0FEh,  02h,  00h, 'IrDA Bridge   ',0
;    DB 0FFh, 0FFh, 0FFh, 0FEh,  03h,  00h, 'Test & Measure',0
;    DB 0FFh, 0FFh, 0FFh, 0FEh,  03h,  01h, 'Test&Meas 488 ',0
;    DB 0FFh, 0FFh, 0FFh, 0FEh, 0FFh, 0FFh, 'App-Specific? ',0

;  DeviceClassTbl:
;    DB 0DCh, 'Diagnostic Device',0
;    DB 0E0h, 'Wireless Controller',0
;    DB 0EFh, 'Miscellaneous Device',0

;  InterfaceClassTbl:
;    DB 0DCh, 'Diagnostic Device',0
;    DB 0E0h, 'Wireless Controller',0
;    DB 0EFh, 'Miscellaneous Devices',0
;    DB 0FEh, 'Application-specific',0



;------------------------------------------------------------------------------
;Device/Interface Class to Descriptor Definition Lookup Table
;The first 6 bytes of each table entry are the Device Class/SubClass/Protocol
;  and Interface Class/SubClass/Protocol for a particular "Type" of Device
;  or Interface.
;The next two words are the USB Version and Device/Interface Class Version.
;A -1 in any of the first entries means "don't care - match anything".
;The last entry (a word) is the pointer to the Descriptor Definition
;  Lookup Table.
;------------------------------------------------------------------------------
ClassDescrTbl:
  DB  -1,  -1,  -1 ;Audio Control Class Interface, Audio Spec v1
  DB 01h, 01h,   0
  DW  -1,  -1
  DW DescrMsgTblAudio1Ctl

  DB  -1,  -1,  -1 ;Audio Stream Class Interface, Audio Spec v1
  DB 01h, 02h,   0
  DW  -1,  -1
  DW DescrMsgTblAudio1Str

  DB  -1,  -1,  -1 ;Audio Control Class Interface, Audio Spec v2
  DB 01h, 01h,  20h
  DW  -1,  -1
  DW DescrMsgTblAudio2Ctl

  DB  -1,  -1,  -1 ;Audio Stream Class Interface, Audio Spec v2
  DB 01h, 02h,  20h
  DW  -1,  -1
  DW DescrMsgTblAudio2Str

  DB  -1,  -1,  -1 ;Audio MIDI Stream Class Interface, Audio Spec v1 & v2
  DB 01h, 03h,  -1
  DW  -1,  -1
  DW DescrMsgTblAudioMIDI

  DB 02h,  -1,  -1 ;Communications Control Interface
  DB 02h,  -1,  -1
  DW  -1,  -1
  DW DescrMsgTblCommCtl

  DB 02h,  -1,  -1 ;Communications Data Interface
  DB 0Ah,  -1,  -1
  DW  -1,  -1
  DW DescrMsgTblCommData

  DB  -1,  -1,  -1 ;Human Interface Device
  DB 03h,  -1,  -1
  DW  -1,  -1
  DW DescrMsgTblHID

  DB  -1,  -1,  -1 ;Physical Interface
  DB 05h,  -1,  -1
  DW  -1,  -1
  DW DescrMsgTblPhysical

  DB  -1,  -1,  -1 ;Imaging Interface
  DB 06h,  -1,  -1
  DW  -1,  -1
  DW DescrMsgTblImaging

  DB  -1,  -1,  -1 ;Printer Interface
  DB 07h,  -1,  -1
  DW  -1,  -1
  DW DescrMsgTblPrinter

  DB  -1,  -1,  -1 ;Mass Storage Interface
  DB 08h,  -1,  -1
  DW  -1,  -1
  DW DescrMsgTblMassStorage

  DB 09h,  -1,  -1 ;Hub Device
  DB  -1,  -1,  -1
  DW  -1,  -1
  DW DescrMsgTblHub

  DB  -1,  -1,  -1 ;CCID Interface
  DB 0Bh,  -1,  -1
  DW  -1,  -1
  DW DescrMsgTblCCID

  DB  -1,  -1,  -1 ;Content Security Interface
  DB 0Dh,  -1,  -1
  DW  -1,  -1
  DW DescrMsgTblContSec

  DB  -1,  -1,  -1 ;Video Interface
  DB 0Eh,  -1,  -1
  DW  -1,  -1
  DW DescrMsgTblVideo

  DB  -1,  -1,  -1 ;Personal Helthcare Interface
  DB 0Fh,  -1,  -1
  DW  -1,  -1
  DW DescrMsgTblPersHealth

  DB 0 ;End of Table!!



;The first line of each table entry describes how to determine if this
;  is the correct table entry to use or not.  For general USB Descriptors
;  (Device, Configuration, Interface, EndPoint, etc.), the only thing
;  we need to compare is the Descriptor Type byte.  This is also true
;  of many Class-specific Descriptors.
;However, for certain types of Devices (like Audio and Video), the
;  Class-Specific Descriptors have various "Sub-Type" fields embedded
;  in the Descriptor, and it is not possible to properly decipher the
;  Descriptor without knowledge of the various Sub-Type bytes.  In addition,
;  some of the deterministic bytes are not contiguous in the Descriptor.
;  Therefore, we need to build some flexibility into the first part of
;  our Descriptor Deciphering tables since determining the Descriptor
;  "Type" gets convoluted and complicated.
;The first byte of each table entry below is the number of bytes following
;  it that must be compared to the actual Descriptor to determine
;  which Deciphering Table Entry is the correct one to use.  Any bytes
;  that are -1's are "don't care's".
;General USB Descriptors, and many Class-Specific Descriptors, will only
;  need to test the Descriptor Type byte.  Certain Class-Specific Descriptors
;  (such as Audio and Video) will need to test multiple bytes.

;NOTES: Headers can be almost any length, but individual entity descriptor
;         strings are limited to 22 characters (21 if writing a TriByte).


;==============================================================================
;Unknown Descriptors
;==============================================================================

  DescrMsgTblUnknown:
  ;----------------------------------------------------------------------------
  ;Device Descriptor
  ;----------------------------------------------------------------------------
    DW DoNothing
        DB DTagSizeType+2, 'UNKNOWN DESCRIPTOR',0
    DW 0


;==============================================================================
;General USB Descriptors (DescriptorType < 20h)
;==============================================================================

  DescrMsgTblUSB:
  ;----------------------------------------------------------------------------
  ;Device Descriptor
  ;----------------------------------------------------------------------------
    DB 1, DescrTypeDevice
    DW DoNothing
        DB DTagSizeType+2, 'DEVICE DESCRIPTOR',0
    DW DoVersionStoreUSB
        DB DTagColon   +2, 'USB Release',0
    DW DoDvcClassStore
        DB DTagColon   +1, 'Device Class',0
    DW DoDvcSubClassStore
        DB DTagColon   +1, 'Device SubClass',0
    DW DoDvcProtocolStore
        DB DTagColon   +1, 'Device Protocol',0
    DW WriteByteMin
        DB DTagColon   +1, 'Max Packet Size EP0',0
    DW DoVendorID
        DB DTagColon   +2, 'Vendor ID',0
    DW WriteWordMin
        DB DTagColon   +2, 'Product ID',0
    DW DoVersion
        DB DTagColon   +2, 'Device Release',0
    DW DoGetString
        DB DTagColon   +1, 'Manufacturer String',0
    DW DoGetString
        DB DTagColon   +1, 'Product String',0
    DW DoGetString
        DB DTagColon   +1, 'Serial # String',0
    DW WriteByteMin
        DB DTagColon   +1, '# of Configs',0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Configuration Descriptor
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeConfig
    DW DoNothing
        DB DTagSizeType+2, 'CONFIGURATION DESCRIPTOR',0
    DW DoDescrTotalLength
        DB DTagSkip    +2, 0
    DW WriteByteMin
        DB DTagColon   +1, '# of Interfaces',0
    DW WriteByteMin
        DB DTagColon   +1, 'Configuration Value',0
    DW DoGetString
        DB DTagColon   +1, 'Configuration String',0
    DW DoConfigAttribs
        DB DTagColon   +1, 'Attributes',0
    DW DoPowerOver2
        DB DTagColon   +1, 'Current Draw / 2',0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;String Descriptor
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeString
    DW DoNothing
        DB DTagSizeType+2, 'STRING DESCRIPTOR',0
    DW FinishStringDescr
        DB DTagSkip+DTagEndOfDescr+0, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Interface Descriptor
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeInterface
    DW DoNothing
        DB DTagSizeType+2, 'INTERFACE DESCRIPTOR',0
    DW WriteByteMin
        DB DTagColon   +1, 'Interface Number',0
    DW WriteByteMin
        DB DTagColon   +1, 'Alternate Setting',0
    DW WriteByteMin
        DB DTagColon   +1, '# of End Points',0
    DW DoIntfClassStore
        DB DTagColon   +1, 'Interface Class',0
    DW DoIntfSubClassStore
        DB DTagColon   +1, 'Interface SubClass',0
    DW DoIntfProtocolStore
        DB DTagColon   +1, 'Interface Protocol',0
    DW DoGetString
        DB DTagColon   +1, 'Interface String',0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;EndPoint Descriptor
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeEndPoint
    DW DoNothing
        DB DTagSizeType+2, 'END POINT DESCRIPTOR',0
    DW DoEndPointNumber
        DB DTagColon   +1, 'End Point Number',0
    DW DoEndPointAttribs
        DB DTagColon   +1, 'Attributes',0
    DW WriteWordMin
        DB DTagColon   +2, 'Max Packet Size',0
    DW WriteByteMin
        DB DTagColon   +1, 'Max Poll Interval',0
    ;Some EndPoints also contain the following extra 2 bytes:
    DW DoRefreshRate
        DB DTagColon   +1, 'Refresh Rate (2^n)',0
    DW WriteByteMin
        DB DTagColon   +1, 'Synch End Point',0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Device Qualifier Descriptor
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeDvcQual
    DW DoNothing
        DB DTagSizeType+2, 'DEVICE QUALIFIER DESCRIPTOR',0
    DW DoVersion
        DB DTagColon   +2, 'USB Release',0
    DW DoDvcClassStore
        DB DTagColon   +1, 'Device Class',0
    DW DoDvcSubClassStore
        DB DTagColon   +1, 'Device SubClass',0
    DW DoDvcProtocolStore
        DB DTagColon   +1, 'Device Protocol',0
    DW WriteByteMin
        DB DTagColon   +1, 'Max Packet Size',0
    DW WriteByteMin
        DB DTagColon   +1, '# of Configs',0
    DW WriteByteMin
        DB DTagColon   +1, 'Reserved',0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Other Speed Configuration Descriptor
  ;This is exactly the same as a regular Configuration Descr, except for the
  ;  Descriptor Type byte
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeOtherSpd
    DW DoNothing
        DB DTagSizeType+2, 'OTHER SPEED CONFIG DESCRIPTOR',0
    DW DoDescrTotalLength
        DB DTagSkip    +2, 0
    DW WriteByteMin
        DB DTagColon   +1, '# of Interfaces',0
    DW WriteByteMin
        DB DTagColon   +1, 'Configuration Value',0
    DW DoGetString
        DB DTagColon   +1, 'Configuration String',0
    DW DoConfigAttribs
        DB DTagColon   +1, 'Attributes',0
    DW DoPowerOver2
        DB DTagColon   +1, 'Current Draw / 2',0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Interface Power Descriptor
  ;At one time there were plans for an Interface Power Descriptor Type,
  ;  but the USB organization seems to have dropped it into the ether.
  ;As far as I know, there was never an official document stating what
  ;  the descriptor should look like, so we'll basically treat it just
  ;  like an unkown descriptor.
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeIntfPower
    DW DoNothing
        DB DTagSizeType+2, 'INTERFACE POWER DESCRIPTOR',0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;On-The-Go Descriptor
  ;NOTE: An On-The-Go Device is a Device that can communicate directly with
  ;        other Devices, without actually needing a host to "arbritrate"
  ;        the bus between them.  This allow, for instance, cameras and
  ;        printers to "talk" to each other directly to be able to print
  ;        the pictures stored in the camera.
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeOnTheGo
    DW DoNothing
        DB DTagSizeType+2, 'ON-THE-GO DESCRIPTOR',0
    DW DoOnTheGoAttribs
        DB DTagColon   +1, 'Attributes',0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Debug Descriptor
  ;NOTE: This only appears in USB 2.0 (EHCI) Debug Test Devices
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeDebug
    DW DoNothing
        DB DTagSizeType+2, 'DEBUG DESCRIPTOR',0
    DW WriteByteMin
        DB DTagColon   +1, 'Debug In EndPoint',0
    DW WriteByteMin
        DB DTagColon   +1, 'Debug Out EndPoint',0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Interface Association Descriptor
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeIntfAssoc

;Is this variable sized??
;What happens if # of Interfaces > 1??

    DW DoNothing
        DB DTagSizeType+2, 'INTERFACE ASSOCIATION DESCRIPTOR',0
    DW WriteByteMin
        DB DTagColon   +1, 'First Interface',0
    DW WriteByteMin
        DB DTagColon   +1, '# of Interfaces',0
    DW DoIntfClass
        DB DTagColon   +1, 'Interface Class',0
    DW DoIntfSubClass
        DB DTagColon   +1, 'Interface SubClass',0
    DW DoIntfProtocol
        DB DTagColon   +1, 'Interface Protocol',0
    DW DoGetString
        DB DTagColon   +1, 'Function String',0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Wireless USB Security Descriptor
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeWSecurity
    DW DoNothing
        DB DTagSizeType+2, 'WUSB SECURITY DESCRIPTOR',0

    ;Fill in the rest of this

    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Wireless USB Key Descriptor
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeWKey
    DW DoNothing
        DB DTagSizeType+2, 'WUSB KEY DESCRIPTOR',0

    ;Fill in the rest of this

    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Wireless USB Key Descriptor
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeWEncrType
    DW DoNothing
        DB DTagSizeType+2, 'WUSB ENCRYPTION TYPE DESCRIPTOR',0

    ;Fill in the rest of this

    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Wireless USB Binary-device Object Store Descriptor
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeWBOS
    DW DoNothing
        DB DTagSizeType+2, 'WUSB BINARY OBJECT STORE DESCR',0
    DW DoDescrTotalLength
        DB DTagSkip    +2, 0
    DW WriteByteMin
        DB DTagColon   +1, '# of Capability Descrs',0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Wireless USB Device Capability Descriptor
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeWDvcCap
    DW DoNothing
        DB DTagSizeType+2, 'WUSB DEVICE CAPABILITY DESCR',0


;P 162/172 of Spec


    ;Fill in the rest of this

    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Wireless USB Endpoint Companion Descriptor
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeWEndPtCmp
    DW DoNothing
        DB DTagSizeType+2, 'WUSB ENDPOINT COMPANION DESCR',0

    ;Fill in the rest of this

    DW 0 ;End of Descriptor Entry


    DB 0 ;End of Table!!


;==============================================================================
;Class-Specific Descriptors (DescriptorType >= 20h)
;==============================================================================

;==============================================================================
;Data needed to Write Audio Descriptors
;==============================================================================

  ;------------------------------------------------------------------------------
  ;Miscellaneous Data Storage
  ;------------------------------------------------------------------------------
  DescrLength DB ? ;Total Length of Descriptor we're writing
  StoredByte  DB ? ;Byte Stored from early part of a Descriptor Decode process
                   ;Needed later in Descriptor but can't find it because the
                   ;  Descriptor has two variable length fields
  StoredByte2 DB ? ;Second early descriptor byte needed


  ;------------------------------------------------------------------------------
  ;Miscellaneous Strings
  ;------------------------------------------------------------------------------
  UnitIDMsg:          DB 'Unit ID',0
  TerminalIDMsg:      DB 'Terminal ID',0
  InputEntityMsg:     DB 'Input Entity ID',0
  SourceEntityMsg:    DB 'Source Entity ID',0
  ClockSrcMsg:        DB 'Clock Source ID',0
  UnitStringMsg:      DB 'Unit String',0
  TermStringMsg:      DB 'Terminal String',0
  InputPinsMsg:       DB '# of Input Pins',0

  AudioMsg:           DB 'Audio ',0
  AudioStreamIntfMsg: DB 'Stream Interface ID',0
  NumChansMsg:        DB '# of Channels',0
  SpatialConfigMsg:   DB 'Spatial Config',0
  ChanStringsMsg:     DB 'Chan Name String',0
  SuppControlsMsg:    DB 'Supported Controls',0
  ClkSrcPinIDMsg:     DB 'Clock Source ID',0
  MixerDescrMsg:      DB 'Input -> Output Ctl',0
  MixerPtrMsg:        DB ' -> ',0
  NotProgrammableMsg: DB 'Not '
  ProgrammableMsg:    DB 'Programmable',0
  AxFtrUnitCtlsMsg:   DB 'Controls on Chan',0
  NumCtlBytesMsg:     DB '# of Control Bytes',0
  NumModesMsg:        DB 'Number of Modes',0
  ModeChanMsg:        DB 'Channels in Mode',0


  ;----------------------------------------------------------------------------
  ;Audio Descriptor Types
  ;----------------------------------------------------------------------------
  AudioDescrTypeTbl:
    DB TblFlagByte
    DB 20h, 'Undefined',0
    DB 21h, 'Device',0
    DB 22h, 'Configuration',0
    DB 23h, 'String',0
    DB 24h, 'Interface',0
    DB 25h, 'EndPoint',0
    DB  0 , -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;Audio Terminal Types
  ;----------------------------------------------------------------------------
  AudioTermTypeTbl:
    DB TblFlagWord
    DW 0100h
       DB 'USB Undefined',0
    DW 0101h
       DB 'USB Streaming',0
    DW 01FFh
       DB 'USB Vendor-Specific',0
    DW 0200h
       DB 'Input Undefined',0
    DW 0201h
       DB 'Generic Microphone',0
    DW 0202h
       DB 'Desktop/Monitor Microphone',0
    DW 0203h
       DB 'Head-mounted or Clip-on Mic',0
    DW 0204h
       DB 'Multiple Spkrs/Long Range Mic',0
    DW 0205h
       DB 'Microphone Array',0
    DW 0206h
       DB 'Processing Microphone Array',0
    DW 0300h
       DB 'Output Undefined',0
    DW 0301h
       DB 'Generic Speaker',0
    DW 0302h
       DB 'Headphones/Head-mounted',0
    DW 0303h
       DB 'Head-mounted VR Display Audio',0
    DW 0304h
       DB 'Desktop/Monitor Speaker',0
    DW 0305h
       DB 'Room Speaker',0
    DW 0306h
       DB 'Voice Communications Speaker',0
    DW 0307h
       DB 'Subwoofer',0
    DW 0400h
       DB 'Bidirectional Undefined',0
    DW 0401h
       DB 'Hand-held Device',0
    DW 0402h
       DB 'Head-mounted Device',0
    DW 0403h
       DB 'Hands-free w/ no Echo Reduction',0
    DW 0404h
       DB 'Hands-free w/ Echo Supression',0
    DW 0405h
       DB 'Hands-free w/ Echo Cancellation',0
    DW 0500h
       DB 'Telephony Undefined',0
    DW 0501h
       DB 'Analog Phone or ISDN Line,',0
    DW 0502h
       DB 'Telephone-type Device',0
    DW 0503h
       DB 'Standard Phone Set',0
    DW 0600h
       DB 'External Undefined',0
    DW 0601h
       DB 'Generic Analog Connector',0
    DW 0602h
       DB 'Generic Digital Audio Interface',0
    DW 0603h
       DB 'Standard Analog Line Connector',0
    DW 0604h
       DB 'Legacy Line Out from Computer ',0
    DW 0605h
       DB 'S/PDIF Digital Audio Interface',0
    DW 0606h
       DB 'Audio Stream on 1394 Bus',0
    DW 0607h
       DB 'Soundtrack on 1394 Bus',0
    DW 0608h
       DB 'ADAT Lightpipe',0
    DW 0609h
       DB 'Tascam Digital Interface',0
    DW 060Ah
       DB 'AES Multi-chan Audio Digital Intf',0
    DW 0700h
       DB 'Embedded Undefined',0
    DW 0701h
       DB 'Level Calibration Noise Source',0
    DW 0702h
       DB 'Measurement Noise Source',0
    DW 0703h
       DB 'Audio CD Player or CD-ROM',0
    DW 0704h
       DB 'Digital Audio Tape',0
    DW 0705h
       DB 'Cigital Compact Cassette',0
    DW 0706h
       DB 'Compressed Audio Player',0
    DW 0707h
       DB 'Analog Audio Tape',0
    DW 0708h
       DB 'Analog Vinyl Record Player',0
    DW 0709h
       DB 'Video Cassette Recorder',0
    DW 070Ah
       DB 'VideoDisc Player',0
    DW 070Bh
       DB 'DVD Player',0
    DW 070Ch
       DB 'Television Tuner',0
    DW 070Dh
       DB 'Satellite Receiver',0
    DW 070Eh
       DB 'Cable Tuner',0
    DW 070Fh
       DB 'DSS Receiver',0
    DW 0710h
       DB 'AM/FM Radio Receiver',0
    DW 0711h
       DB 'AM/FM Radio Transmitter',0
    DW 0712h
       DB 'Multi-track Recording System',0
    DW 0713h
       DB 'Synthesizer',0
    DW 0714h
       DB 'Piano',0
    DW 0715h
       DB 'Guitar',0
    DW 0716h
       DB 'Percussion/Drums/Rhythm',0
    DW 0717h
       DB 'Other Musical Instrument',0
    DW     0 ;End of
       DB -1 ;  Table

  ;----------------------------------------------------------------------------
  ;Audio Spatial Configurations (BitMap)
  ;----------------------------------------------------------------------------
  AudioSpatialTbl:
    DB TblFlagDWord+TblFlagBitMap+TblFlagSequential
    DB 'Front Left',0                  ;0000_0001h
    DB 'Front Right',0                 ;0000_0002h
    DB 'Front Center',0                ;0000_0004h
    DB 'Low Frequency Effects',0       ;0000_0008h
    DB 'Back Left',0                   ;0000_0010h
    DB 'Back Right',0                  ;0000_0020h
    DB 'Front Left of Center',0        ;0000_0040h
    DB 'Front Right of Center',0       ;0000_0080h
    DB 'Back Center',0                 ;0000_0100h
    DB 'Side Left',0                   ;0000_0200h
    DB 'Side Right',0                  ;0000_0400h
    DB 'Top Center',0                  ;0000_0800h
    DB 'Top Front Left',0              ;0000_1000h
    DB 'Top Front Center',0            ;0000_2000h
    DB 'Top Front Right',0             ;0000_4000h
    DB 'Top Back Left',0               ;0000_8000h
    DB 'Top Back Center',0             ;0001_0000h
    DB 'Top Back Right',0              ;0002_0000h
    DB 'Top Front Left of Center',0    ;0004_0000h
    DB 'Top Front Right of Center',0   ;0008_0000h
    DB 'Left Low Frequency Effects',0  ;0010_0000h
    DB 'Right Low Frequency Effects',0 ;0020_0000h
    DB 'Top Side Left',0               ;0040_0000h
    DB 'Top Side Right',0              ;0080_0000h
    DB 'Bottom Center',0               ;0100_0000h
    DB 'Back Left of Center',0         ;0200_0000h
    DB 'Back Right of Center',0        ;0400_0000h
    DB 0                               ;0800_0000h
    DB 0                               ;1000_0000h
    DB 0                               ;2000_0000h
    DB 0                               ;4000_0000h
    DB 'Raw Data',0                    ;8000_0000h

  ;----------------------------------------------------------------------------
  ;Audio v1 Control Descriptor SubTypes
  ;----------------------------------------------------------------------------
  Audio1CtlDescrSubTypeTbl:
    DB TblFlagByte
    DB 00h, 'Undefined',0
    DB 01h, 'Control Header',0
    DB 02h, 'Input Terminal',0
    DB 03h, 'Output Terminal',0
    DB 04h, 'Mixer Unit',0
    DB 05h, 'Selector Unit',0
    DB 06h, 'Feature Unit',0
    DB 07h, 'Processing Unit',0
    DB 08h, 'Extension Unit',0
    DB  0 , -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;Audio v1 Stream Descriptor SubTypes
  ;----------------------------------------------------------------------------
  Audio1StrDescrSubTypeTbl:
    DB TblFlagByte
    DB 00h, 'Undefined',0
    DB 01h, 'General Stream',0
    DB 02h, 'Stream Format Type',0
    DB 03h, 'Stream Format Specific',0
    DB  0 , -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;Audio v1 Format Tag Unit Types
  ;----------------------------------------------------------------------------
  Audio1StrFmtTagTbl:
    DB TblFlagWord
    DW 0000h
       DB 'Type I Undefined',0
    DW 0001h
       DB 'Pulse Code Modulation',0
    DW 0002h
       DB '8-bit Pulse Code Modulation',0
    DW 0003h
       DB 'IEEE Floating Point',0
    DW 0004h
       DB 'A-Law (Non-US Telephony)',0
    DW 0005h
       DB 'æ-Law (US Telephony)',0
    DW 1000h
       DB 'Type II Undefined',0
    DW 1001h
       DB 'MPEG',0
    DW 1002h
       DB 'AC-3',0
    DW 2000h
       DB 'Type III Undefined',0
    DW 2001h
       DB 'IEC61937 AC-3',0
    DW 2002h
       DB 'IEC61937 MPEG-1 Layer 1',0
    DW 2003h
       DB 'IEC61937 MPEG-1 Layer 2/3 or MPEG-2 No Ext',0
    DW 2004h
       DB 'IEC61937 MPEG-2 Ext',0
    DW 2005h
       DB 'IEC61937 MPEG-2 Layer 1 LS',0
    DW 2006h
       DB 'IEC61937 MPEG-2 Layer 2/3 LS',0
    DW     0 ;End of
       DB -1 ;  Table

  ;----------------------------------------------------------------------------
  ;Audio v1 Stream Format Types
  ;----------------------------------------------------------------------------
  Audio1StrFmtTypeTbl:
    DB TblFlagByte
    DB 00h, 'Undefined',0
    DB 01h, 'Type 1 (PCM)',0
    DB 02h, 'Type 2 (non-PCM)',0
    DB 03h, 'Type 3 (IEC61937)',0
    DB 04h, 'Type 4 (non-USB)',0
    DB 81h, 'Extended Type 1 (PCM)',0
    DB 82h, 'Extended Type 2 (non-PCM)',0
    DB 83h, 'Extended Type 3 (IEC61937)',0
    DB  0 , -1 ;End of Table


  ;----------------------------------------------------------------------------
  ;Audio v1 Feature Unit Controls (BitMap)
  ;----------------------------------------------------------------------------
  Audio1FtrCtlTbl:
    DB TblFlagWord+TblFlagBitMap+TblFlagSequential
    DB 'Mute',0              ;0001h
    DB 'Volume',0            ;0002h
    DB 'Bass',0              ;0004h
    DB 'MidRange',0          ;0008h
    DB 'Treble',0            ;0010h
    DB 'Graphic Equalizer',0 ;0020h
    DB 'Automatic Gain',0    ;0040h
    DB 'Delay',0             ;0080h
    DB 'Bass Boost',0        ;0100h
    DB 'Loudness',0          ;0200h
    DB 0                     ;0400h
    DB 0                     ;0800h
    DB 0                     ;1000h
    DB 0                     ;2000h
    DB 0                     ;4000h
    DB 0                     ;8000h

  ;----------------------------------------------------------------------------
  ;Audio v1 Processing Unit Types
  ;----------------------------------------------------------------------------
  Audio1ProcTypeTbl:
    DB TblFlagWord
    DW 0000h
       DB 'Undefined',0
    DW 0001h
       DB 'Up/Down Mix',0
    DW 0002h
       DB 'Dolby ProLogic',0
    DW 0003h
       DB '3D Stereo Extender',0
    DW 0004h
       DB 'Reverberation',0
    DW 0005h
       DB 'Chorus',0
    DW 0006h
       DB 'Dynamic Range Compression',0
    DW     0 ;End of
       DB -1 ;  Table

  ;----------------------------------------------------------------------------
  ;Audio v1 Processing Unit Controls (BitMap Tables)
  ;----------------------------------------------------------------------------
  Audio1UpDnCtlTbl:     ;Up/Down Mix
  Audio1ProLogicCtlTbl: ;Dolby ProLogic
    DB TblFlagByte+TblFlagBitMap+TblFlagSequential
    DB 'Enable Processing',0 ;01h
    DB 'Mode Select',0       ;02h
    DB 0                     ;04h
    DB 0                     ;08h
    DB 0                     ;10h
    DB 0                     ;20h
    DB 0                     ;40h
    DB 0                     ;80h

  Audio1StereoXCtlTbl:  ;3D Stereo
    DB TblFlagByte+TblFlagBitMap+TblFlagSequential
    DB 'Enable Processing',0 ;01h
    DB 'Spaciousness',0      ;02h
    DB 0                     ;04h
    DB 0                     ;08h
    DB 0                     ;10h
    DB 0                     ;20h
    DB 0                     ;40h
    DB 0                     ;80h

  Audio1ReverbCtlTbl:   ;Reverberation
    DB TblFlagByte+TblFlagBitMap+TblFlagSequential
    DB 'Enable Processing',0 ;01h
    DB 'Reverb Type',0       ;02h
    DB 'Reverb Level',0      ;04h
    DB 'Reverb Time',0       ;08h
    DB 'Delay Feedback',0    ;10h
    DB 0                     ;20h
    DB 0                     ;40h
    DB 0                     ;80h

  Audio1ChorusCtlTbl:   ;Chorus
    DB TblFlagByte+TblFlagBitMap+TblFlagSequential
    DB 'Enable Processing',0 ;01h
    DB 'Chorus Level',0      ;02h
    DB 'Modulation Rate',0   ;04h
    DB 'Modulation Depth',0  ;08h
    DB 0                     ;10h
    DB 0                     ;20h
    DB 0                     ;40h
    DB 0                     ;80h
    DB -1,0 ;End of Table

  Audio1DynRangeCtlTbl: ;Dynamic Range Compression
    DB TblFlagByte+TblFlagBitMap+TblFlagSequential
    DB 'Enable Processing',0 ;01h
    DB 'Compression Ratio',0 ;02h
    DB 'Maximum Amplitude',0 ;04h
    DB 'Threshold',0         ;08h
    DB 'Attack Time',0       ;10h
    DB 'Release Time',0      ;20h
    DB 0                     ;40h
    DB 0                     ;80h
    DB -1,0 ;End of Table

  UnknownCtlByteTbl:    ;Unknown Control Bytes
    DB TblFlagByte+TblFlagBitMap+TblFlagSequential
    DB 0 ;01h
    DB 0 ;02h
    DB 0 ;04h
    DB 0 ;08h
    DB 0 ;10h
    DB 0 ;20h
    DB 0 ;40h
    DB 0 ;80h

  ;----------------------------------------------------------------------------
  ;Audio v1 Extension Unit Controls (BitMap)
  ;----------------------------------------------------------------------------
  Audio1ExtCtlTbl: ;Extension Unit
    DB TblFlagByte+TblFlagBitMap+TblFlagSequential
    DB 'Enable_Processing',0 ;01h
    DB 0                     ;02h
    DB 0                     ;04h
    DB 0                     ;08h
    DB 0                     ;10h
    DB 0                     ;20h
    DB 0                     ;40h
    DB 0                     ;80h

  ;----------------------------------------------------------------------------
  ;Lookup Table for Audio v1 Processing Unit Controls
  ;----------------------------------------------------------------------------
  Audio1ProcCtlTbl:
    DB A1PTypeUpDnMix
       DW Audio1UpDnCtlTbl
    DB A1PTypeProLogic
       DW Audio1ProLogicCtlTbl
    DB A1PTypeStereoX
       DW Audio1StereoXCtlTbl
    DB A1PTypeReverb
       DW Audio1ReverbCtlTbl
    DB A1PTypeChorus
       DW Audio1ChorusCtlTbl
    DB A1PTypeDynRange
       DW Audio1DynRangeCtlTbl
    DB 0

  ;----------------------------------------------------------------------------
  ;Audio v1 EndPoint Descriptor SubTypes
  ;----------------------------------------------------------------------------
  Audio1EPDescrSubTypeTbl:
    DB TblFlagByte
    DB 00h, 'Undefined',0
    DB 01h, 'General',0
    DB  0 , -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;Audio v1 EndPoint Attributes (BitMap)
  ;----------------------------------------------------------------------------
  Audio1EPAttribTbl:
    DB TblFlagByte+TblFlagBitMap+TblFlagSequential
    DB 'Sampling Freq',0     ;01h
    DB 'Pitch',0             ;02h
    DB 0                     ;04h
    DB 0                     ;08h
    DB 0                     ;10h
    DB 0                     ;20h
    DB 0                     ;40h
    DB 'Max Pkt Size Only',0 ;80h

  ;----------------------------------------------------------------------------
  ;Audio v1 EndPoint Lock Delay Units
  ;----------------------------------------------------------------------------
  Audio1EPLockUnitTbl:
    DB TblFlagByte
    DB 00h, 'Undefined',0
    DB 01h, 'Milliseconds',0
    DB 02h, 'Decoded PCM Samples',0
    DB  0 , -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;Audio v2 Control Descriptor SubTypes
  ;----------------------------------------------------------------------------
  Audio2CtlDescrSubTypeTbl:
    DB TblFlagByte
    DB 00h, 'Undefined',0
    DB 01h, 'Header',0
    DB 02h, 'Input Terminal',0
    DB 03h, 'Output Terminal',0
    DB 04h, 'Mixer Unit',0
    DB 05h, 'Selector Unit',0
    DB 06h, 'Feature Unit',0
    DB 07h, 'Effect Unit',0
    DB 08h, 'Processing Unit',0
    DB 09h, 'Extension Unit',0
    DB 0Ah, 'Clock Source',0
    DB 0Bh, 'Clock Selector',0
    DB 0Ch, 'Clock Multiplier',0
    DB 0Dh, 'Sample Rate Converter',0
    DB  0 , -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;Audio v2 Categories (Primary Use as intended by Manufacturer)
  ;----------------------------------------------------------------------------
  Audio2PrimaryUseTbl:
    DB TblFlagByte
    DB  00h, 'Undefined',0
    DB  01h, 'Desktop Speaker',0
    DB  02h, 'Home Theater',0
    DB  03h, 'Microphone',0
    DB  04h, 'Head Set',0
    DB  05h, 'Telephone',0
    DB  06h, 'Converter',0
    DB  07h, 'Voice/Sound Recorder',0
    DB  08h, 'I/O Box',0
    DB  09h, 'Musical Instrument',0
    DB  0Ah, 'Pro Audio',0
    DB  0Bh, 'Audio/Video',0
    DB  0Ch, 'Control Panel',0
    DB 0FFh, 'Other',0
    DB  0 , -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;Audio v2 Controls - Used in various Descriptors
  ;----------------------------------------------------------------------------
  Audio2CtlTbl:
    DB 03h, ': ',0
    DB 00h, 'Not Present',0
    DB 01h, 'Read-Only',0
    DB 02h, 'Illegal Value',0
    DB 03h, 'Programmable',0
    DB      0

    DB  0 ;End of Table

  ;----------------------------------------------------------------------------
  ;Audio v2 Effect Unit Types
  ;----------------------------------------------------------------------------
  Audio2EfxTypeTbl:
    DB TblFlagWord
    DW 0000h
       DB 'Undefined',0
    DW 0001h
       DB 'Parametric Equalizer',0
    DW 0002h
       DB 'Reverberation',0
    DW 0003h
       DB 'Modulation Delay',0
    DW 0004h
       DB 'Dynamic Range Compression',0
    DW     0 ;End of
       DB -1 ;  Table

  ;----------------------------------------------------------------------------
  ;Audio v2 Processor Unit Types
  ;----------------------------------------------------------------------------
  Audio2ProcTypeTbl:
    DB TblFlagWord
    DW 0000h
       DB 'Undefined',0
    DW 0001h
       DB 'Up/Down Mix',0
    DW 0002h
       DB 'Dolby ProLogic',0
    DW 0003h
       DB 'Stereo Extender',0
    DW     0 ;End of
       DB -1 ;  Table

  ;----------------------------------------------------------------------------
  ;Audio v2 Clock Source Attributes - Used in Audio v2 Clock Source Descriptor
  ;----------------------------------------------------------------------------
  Audio2ClkSrcAttrTbl:
    DB 03h, 'Clock Type: ',0
    DB 00h, 'External',0
    DB 01h, 'Internal Fixed',0
    DB 02h, 'Internal Variable',0
    DB 03h, 'Internal Programmable',0
    DB      0

    DB 04h, 0
    DB 00h, 'Not ',0
    DB 04h, 0
    DB      'Synchronized to Start-of-Frame',0

    DB  0 ;End of Table

  ;----------------------------------------------------------------------------
  ;Control Types for an Audio v2 Control Interface Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfCtlTbl:
    DB 'Latency',0
    DB 0

  ;----------------------------------------------------------------------------
  ;Control Types for an Audio v2 Input Terminal Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfInTermTbl:
    DB 'Copy Protect',0
    DB 'Connector',0
    DB 'Overload',0
    DB 'Cluster',0
    DB 'Underflow',0
    DB 'Overflow',0
    DB 0

  ;----------------------------------------------------------------------------
  ;Control Types for an Audio v2 Output Terminal Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfOutTermTbl:
    DB 'Copy Protect',0
    DB 'Connector',0
    DB 'Overload',0
    DB 'Underflow',0
    DB 'Overflow',0
    DB 0

  ;----------------------------------------------------------------------------
  ;Control Types for an Audio v2 Mixer Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfMixUnitTbl:
    DB 'Cluster',0
    DB 'Underflow',0
    DB 'Overflow',0
    DB 0

  ;----------------------------------------------------------------------------
  ;Control Types for an Audio v2 Selector Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfSelUnitTbl:
    DB 'Cluster',0
    DB 0

  ;----------------------------------------------------------------------------
  ;Control Types for an Audio v2 Feature Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfFtrUnitTbl:
    DB 'Mute',0
    DB 'Volume',0
    DB 'Bass',0
    DB 'MidRange',0
    DB 'Treble',0
    DB 'Graphics Equalizer',0
    DB 'Automatic Gain',0
    DB 'Delay',0
    DB 'Bass Boost',0
    DB 'Loudness',0
    DB 'Input Gain',0
    DB 'Input Gain Pad',0
    DB 'Phase Inverter',0
    DB 'Underflow',0
    DB 'Overflow',0
    DB 0

  ;----------------------------------------------------------------------------
  ;Control Types for an Audio v2 Parametric Equalizer Effect Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfParEqTbl:
    DB 'Enable',0
    DB 'Center Frequency',0
    DB 'Q-Factor',0
    DB 'Gain',0
    DB 'Underflow',0
    DB 'Overflow',0
    DB 0

  ;----------------------------------------------------------------------------
  ;Control Types for an Audio v2 Reverberation Effect Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfReverbTbl:
    DB 'Enable',0
    DB 'Type',0
    DB 'Level',0
    DB 'Time',0
    DB 'Delay Feedback',0
    DB 'Pre-Delay',0
    DB 'Density',0
    DB 'High-Frequency Roll-Off',0
    DB 'Underflow',0
    DB 'Overflow',0
    DB 0

  ;----------------------------------------------------------------------------
  ;Control Types for an Audio v2 Modulation Delay Effect Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfModDlyTbl:
    DB 'Enable',0
    DB 'Balance',0
    DB 'Rate',0
    DB 'Depth',0
    DB 'Time',0
    DB 'Feedback Level',0
    DB 'Underflow',0
    DB 'Overflow',0
    DB 0

  ;----------------------------------------------------------------------------
  ;Control Types for an Audio v2 Dynamic Range Effect Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfDynRgTbl:
    DB 'Enable',0
    DB 'Compression Ratio',0
    DB 'Maximum Amplitude',0
    DB 'Threshold',0
    DB 'Attack Time',0
    DB 'Release Time',0
    DB 'Underflow',0
    DB 'Overflow',0
    DB 0

  ;----------------------------------------------------------------------------
  ;Control Types for an Audio v2 Up/Down Mix Processor Descriptor
  ;Control Types for an Audio v2 Dolby ProLogic Processor Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfUpDnTbl:
  Audio2CtlIntfDolbyTbl:
    DB 'Enable',0
    DB 'Mode Select',0
    DB 'Cluster',0
    DB 'Underflow',0
    DB 'Overflow',0
    DB 0

  ;----------------------------------------------------------------------------
  ;Control Types for an Audio v2 Dolby ProLogic Processor Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfStereoXTbl:
    DB 'Enable',0
    DB 'Width',0
    DB 'Cluster',0
    DB 'Underflow',0
    DB 'Overflow',0
    DB 0

  ;----------------------------------------------------------------------------
  ;Control Types for an Audio v2 Extension Unit Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfExtUnitTbl:
    DB 'Enable',0
    DB 'Cluster',0
    DB 'Underflow',0
    DB 'Overflow',0
    DB 0

  ;----------------------------------------------------------------------------
  ;Control Types for an Audio v2 Clock Source Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfClkSrcTbl:
    DB 'Frequency',0
    DB 'Validity',0
    DB 0

  ;----------------------------------------------------------------------------
  ;Control Types for an Audio v2 Clock Source Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfClkSelTbl:
    DB 'Selector',0
    DB 0

  ;----------------------------------------------------------------------------
  ;Control Types for an Audio v2 Clock Multiplier Descriptor
  ;----------------------------------------------------------------------------
  Audio2CtlIntfClkMulTbl:
    DB 'Numerator',0
    DB 'Denominator',0
    DB 0


WriteAudioDescrType:
  PUSH AX,DX               ;Save used registers
  MOV  AL,ES:[DI]          ;Write the
  MOV  DX,DescrTypeMsg     ;  Descriptor Type
  CALL WriteDescrByteNoDec ;  Header
  MOV  DX,AudioMsg         ;Write the
  CALL WriteItDX           ;  Description prefix
  CALL DoAudioDescrType    ;Write the Description
  POP  DX,AX               ;Restore used registers
  RET

WriteAudio1CtlDescrSType:
  PUSH BX                       ;Save used registers
  MOV  BX,DoAudio1CtlDescrSType ;[BX] = Code to Call
  JMP >S00                      ;Do it
WriteAudio1StrDescrSType:
  PUSH BX                       ;Save used registers
  MOV  BX,DoAudio1StrDescrSType ;[BX] = Code to Call
  JMP >S00                      ;Do it
WriteAudio2CtlDescrSType:
  PUSH BX                       ;Save used registers
  MOV  BX,DoAudio2CtlDescrSType ;[BX] = Code to Call
  JMP >S00                      ;Do it
WriteAudio1EPDescrSType:
  PUSH BX                       ;Save used registers
  MOV  BX,DoAudio1EPDescrSType  ;[BX] = Code to Call
  JMP >S00                      ;Do it
S00:
  PUSH AX,DX                    ;Save used registers
  MOV  AL,ES:[DI]               ;Write the
  MOV  DX,DescrSubTypeMsg       ;  Descriptor Type
  CALL WriteDescrByteNoDec      ;  Header
  CALL BX                       ;Write the Description
  POP  DX,AX                    ;Restore used registers
  POP  BX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE DESCRIPTION OF AN AUDIO V2 CONTROLS FIELD
;Inputs:  ES:[DI] = Controls field to get
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
DoAudio2CtlIntfCtls:
  PUSH SI                     ;Save used registers
  MOV  SI,Audio2CtlIntfCtlTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsByte       ;Write the Status
  POP  SI                     ;Restore used registers
  RET

DoAudio2InTermCtls:
  PUSH SI                        ;Save used registers
  MOV  SI,Audio2CtlIntfInTermTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsWord          ;Do it
  POP  SI                        ;Restore used registers
  RET

DoAudio2OutTermCtls:
  PUSH SI                         ;Save used registers
  MOV  SI,Audio2CtlIntfOutTermTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsWord           ;Do it
  POP  SI                         ;Restore used registers
  RET

DoAudio2MixUnitCtls:
  PUSH SI                         ;Save used registers
  MOV  SI,Audio2CtlIntfMixUnitTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsByte           ;Do it
  POP  SI                         ;Restore used registers
  RET

DoAudio2SelUnitCtls:
  PUSH SI                         ;Save used registers
  MOV  SI,Audio2CtlIntfSelUnitTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsByte           ;Do it
  POP  SI                         ;Restore used registers
  RET

DoAudio2FtrUnitCtls:
  PUSH SI                         ;Save used registers
  MOV  SI,Audio2CtlIntfFtrUnitTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsDWord          ;Do it
  POP  SI                         ;Restore used registers
  RET

DoAudio2ParEqCtls:
  PUSH SI                       ;Save used registers
  MOV  SI,Audio2CtlIntfParEqTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsDWord        ;Do it
  POP  SI                       ;Restore used registers
  RET

DoAudio2ReverbCtls:
  PUSH SI                        ;Save used registers
  MOV  SI,Audio2CtlIntfReverbTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsDWord         ;Do it
  POP  SI                        ;Restore used registers
  RET

DoAudio2ModDlyCtls:
  PUSH SI                        ;Save used registers
  MOV  SI,Audio2CtlIntfModDlyTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsDWord         ;Do it
  POP  SI                        ;Restore used registers
  RET

DoAudio2DynRgCtls:
  PUSH SI                       ;Save used registers
  MOV  SI,Audio2CtlIntfDynRgTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsDWord        ;Do it
  POP  SI                       ;Restore used registers
  RET

DoAudio2UpDnCtls:
  PUSH SI                      ;Save used registers
  MOV  SI,Audio2CtlIntfUpDnTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsWord        ;Do it
  POP  SI                      ;Restore used registers
  RET

DoAudio2DolbyCtls:
  PUSH SI                       ;Save used registers
  MOV  SI,Audio2CtlIntfDolbyTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsWord         ;Do it
  POP  SI                       ;Restore used registers
  RET

DoAudio2StereoXCtls:
  PUSH SI                         ;Save used registers
  MOV  SI,Audio2CtlIntfStereoXTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsWord           ;Do it
  POP  SI                         ;Restore used registers
  RET

DoAudio2ExtUnitCtls:
  PUSH SI                         ;Save used registers
  MOV  SI,Audio2CtlIntfExtUnitTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsByte           ;Do it
  POP  SI                         ;Restore used registers
  RET

DoAudio2ClkSrcCtls:
  PUSH SI                        ;Save used registers
  MOV  SI,Audio2CtlIntfClkSrcTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsByte          ;Do it
  POP  SI                        ;Restore used registers
  RET

DoAudio2ClkSelCtls:
  PUSH SI                        ;Save used registers
  MOV  SI,Audio2CtlIntfClkSelTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsByte          ;Do it
  POP  SI                        ;Restore used registers
  RET

DoAudio2ClkMulCtls:
  PUSH SI                        ;Save used registers
  MOV  SI,Audio2CtlIntfClkMulTbl ;[SI] = Controls Table
  CALL DoAudio2CtlsByte          ;Do it
  POP  SI                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE DESCRIPTION FOR AN AUDI 2 CLOCK SOURCE ATTRIBUTES BYTE
;Inputs:  AL = Configuration Attribute Byte (from a Clock Source Descriptor)
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoAudio2ClkSrcAttribs:
  PUSH BX                     ;Save used
  MOV  BX,Audio2ClkSrcAttrTbl ;[BX] = Table to search in
  CALL DoByteBitMaskCr        ;Write the Attributes
  POP  BX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A VARIABLE-LENGTH LIST OF BYTE ENTITIES FROM A DESCRIPTOR
;Inputs:  AL = Number of Lines to write
;         ES:[DI] = First Input Value to write
;Outputs: To Screen
;Changes:
;NOTES: If AL = 0 in input, this simply writes "None"
;------------------------------------------------------------------------------
FinishAudio1CtlIntf:
  PUSH DX                    ;Save used registers
  MOV  DX,AudioStreamIntfMsg ;[DX] = Header Message
  JMP >P00                   ;Do it
DoAudioInputSources:
  PUSH DX                    ;Save used registers
  MOV  DX,InputPinsMsg       ;Write the
  CALL WriteDescrByteDec     ;  Header Line
  CALL WriteCrLf             ;Move down
  MOV  DX,InputEntityMsg     ;[DX] = Header Message
  MOV  StoredByte,AL         ;Save the number of Input Pins
  JMP >P00                   ;Do it
DoAudio2ClockSelPins:
  PUSH DX                    ;Save used registers
  MOV  DX,ClkSrcPinIDMsg     ;[DX] = Header Message
;  JMP >P00                   ;Do it
P00:
  PUSH AX,CX,DI              ;Save used registers
  OR   AL,AL                 ;Are there 0 values in the list?
  JZ  >P70                   ;If so, jump to handle it
  MOV  CH,AL                 ;CH = Number of Pins to write
  MOV  CL,1                  ;CL = Pin Index Number
P10:                         ;Loop to here for each Pin
  MOV  AL,ES:[DI]            ;Get the next Pin Number
  INC  DI                    ;Increment the Pointer
  CALL WriteDescrByteNumDec  ;Write the Pin ID
  CMP  CH,1                  ;Is this the last Pin?
  JE  >P90                   ;If so, we're done
  CALL WriteCrLf             ;If not, move down
  INC  CL                    ;Increment Pin Index
  DEC  CH                    ;Decrement Loop Counter
  JNZ  P10                   ;Keep going until we're done
  JMP >P90                   ;Done
P70:                         ;Error (Counter = 0)
  CALL WriteDTagColon        ;Write the Header
  CALL Write12Spaces         ;Move over
  CALL WriteNone             ;Write "None"
P90:                         ;Done
  POP  DI,CX,AX              ;Restore used registers
  POP  DX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE DATA FROM AN AUDIO 2 CONTROL FIELD
;Inputs:   AL/AX/EAX = Control Data Byte
;         [SI] = Control Type Description Table
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoAudio2CtlsByte:
  PUSH EAX,DX,DI                 ;Save used registers
  MOV  AL,ES:[DI]                ;Get the
  AND  EAX,0000_00FFh            ;  Data
  MOV  DX,SuppControlsMsg        ;Point at Message to write
  MOV  DI,WriteDescrByteNoDec    ;Write a Byte Header
  JMP >L00                       ;Do it
DoAudio2CtlsWord:
  PUSH EAX,DX,DI                 ;Save used registers
  MOV  AX,ES:[DI]                ;Get the
  AND  EAX,0000_FFFFh            ;  Data
  MOV  DX,SuppControlsMsg        ;Point at Message to write
  MOV  DI,WriteDescrWordNoDec    ;Write a Word Header
  JMP >L00                       ;Do it
DoAudio2CtlsTriByte:
  PUSH EAX,DX,DI                 ;Save used registers
  MOV  EAX,ES:[DI]               ;Get the
  AND  EAX,00FF_FFFFh            ;  Data
  MOV  DX,SuppControlsMsg        ;Point at Message to write
  MOV  DI,WriteDescrTriByteNoDec ;Write a TriByte Header
  JMP >L00                       ;Do it
DoAudio2CtlsDWord:
  PUSH EAX,DX,DI                 ;Save used registers
  MOV  EAX,ES:[DI]               ;Get the Data
  MOV  DX,NoMsg                  ;Point at Message to write
  MOV  DI,WriteDescrDWordNoDec   ;Write a DWord Header
;  JMP >L00                       ;Do it
L00:
  PUSH BX,CX,SI                  ;Save used registers
  MOV  EBP,0000_0003h            ;Start with first two bits
  CMP  DX,NoMsg                  ;Are we supposed to write the Header?
  JE  >L05                       ;If not, skip it
  CALL DI                        ;If so, write the Header
L05:                             ;Header written, if appropriate
  XOR  CX,CX                     ;CL = Number of tests made so far
                                 ;CH = End-of-Table Reached Flag
  MOV  BX,Audio2CtlTbl           ;[BX] = Audio v2 Controls translation table
L10:                             ;Loop to here for each value
  OR   CH,CH                     ;Already reached End-of-Table?
  JNZ >L15                       ;If so, skip test
  CMP  B [SI],0                  ;End of the Table?
  JNE >L15                       ;If not, continue
  DEC  CH                        ;If so, mark as End-of-Table
L15:                             ;Done determining End-of-Table
  OR   CH,CH                     ;Past End-of-Table?
  JNZ >L20                       ;If so, don't automatically write a new line
  OR   CL,CL                     ;If not, is this the first table entry?
  JZ  >L20                       ;If so, don't start a new line
  CALL WriteCrLf                 ;If not, start a new line
  CALL DoIndent                  ;Write Indent
L20:                             ;New line handled, if appropriate
  INC  CL                        ;Increment Test Counter
  CMP  CL,16                     ;Have we tested all the bits yet?
  JA  >L90                       ;If so, we're done
  OR   CH,CH                     ;Past End-of-Table?
  JNZ >L30                       ;If so, handle it
L25:                             ;Not at end-of-table
  CALL WriteItSISkip             ;Write and skip over the Control Description
  CALL DoByteBitMaskCr           ;Write the Control Value
  JMP >L50                       ;Done with this two-bit test
L30:                             ;Past End-of-Table (Illegal Bits)
  TEST AL,03h                    ;Any Illegal Bits set?
  JZ  >L50                       ;If not, we're done
  CALL WriteCrLf                 ;If so, start a new line
  CALL DoIndent                  ;Write Indent
  MOV  SI,IllegalMsg             ;Write
  CALL WriteItSI                 ;  "Illegal
  MOV  SI,AttribMsg              ;  Attribute "
  CALL WriteItSI                 ;  Message
  PUSH EAX                       ;Write
  AND  EAX,03h                   ; the
  ROL  EAX,CL                    ; illegal
  ROL  EAX,CL                    ; attribute
  ROR  EAX,2                     ; bit
  CALL WriteDWordMinHex          ; mask
  POP  EAX                       ; value
L50:                             ;Done with this two-bit set
  SHR  EAX,2                     ;Move over to the next two-bit entity
  JMP  L10                       ;Keep going until we're done
L90:                             ;Done
  POP  SI,CX,BX                  ;Restore used registers
  POP  DI,DX,EAX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE AN AUDIO v1 CLUSTER DESCRIPTION
;Inputs:  ES:[DI]   = # of Channels
;         ES:[DI+1] = Channel Spatial Configuration
;         ES:[DI+3] = First Channel String Index
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
DoAudio1Cluster:
  PUSH AX,CX,DX              ;Save used registers
  MOV  AL,ES:[DI]            ;Write the
  MOV  DX,NumChansMsg        ;  Number of
  CALL WriteDescrByteDec     ;  Channels
  CALL WriteCrLf             ;Move down
  MOV  AX,ES:[DI+1]          ;Write the
  MOV  DX,SpatialConfigMsg   ;  Spatial Configuration
  CALL WriteDescrWordNoDec   ;  Header
  CMP  B ES:[DI+3],1         ;Is it Monophonic?
  JNE >C20                   ;If not, continue
C10:                         ;Monophonic
  TEST AX,0FFFh              ;Is there a Spatial Configuration (shouldn't be!)
  JNZ >C20                   ;If so, write it
  CALL WriteMono             ;If not, write "Monophonic"
  JMP >C25                   ;Continue
C20:                         ;Not Monophonic
  CALL DoAudio1Spatial       ;Write Spatial Configuration
C25:                         ;Done writing Spatial Configuration
  CALL WriteCrLf             ;Move down
  AND  AX,0FFFh              ;Mask out Illegal Bits
  CALL CountAXBitsSet        ;Count how many bits are set in AX (CL)
  SUB  CL,ES:[DI]            ;Calculate how many possible Strings
  NEG  CL                    ;  there are
  MOV  AL,ES:[DI+3]          ;AL = First String Index
  CALL DoAudioClusterStrings ;Write the Strings
C90:                         ;Done
  POP  DX,CX,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE AN AUDIO v2 CLUSTER DESCRIPTION
;Inputs:  ES:[DI]   = # of Channels
;         ES:[DI+1] = Channel Spatial Configuration
;         ES:[DI+5] = First Channel String Index
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
DoAudio2Cluster:
  PUSH EAX,CX,DX             ;Save used registers
  MOV  AL,ES:[DI]            ;Write the
  MOV  DX,NumChansMsg        ;  Number of
  CALL WriteDescrByteDec     ;  Channels
  CALL WriteCrLf             ;Move down
  MOV  EAX,ES:[DI+1]         ;Write the
  MOV  DX,SpatialConfigMsg   ;  Spatial Configuration
  CALL WriteDescrDWordNoDec  ;  Header
  CMP  B ES:[DI+5],1         ;Is it Monophonic?
  JNE >C20                   ;If not, continue
C10:                         ;Monophonic
  OR   EAX,EAX               ;Is there a Spatial Configuration (shouldn't be!)
  JNZ >C20                   ;If so, write it
  CALL WriteMono             ;If not, write "Monophonic"
  JMP >C25                   ;Continue
C20:                         ;Not Monophonic
  CALL DoAudio2Spatial       ;Write Spatial Configuration
C25:                         ;Done writing Spatial Configuration
  CALL WriteCrLf             ;Move down
  CALL CountEAXBitsSet       ;Count how many bits are set in EAX (CL)
  SUB  CL,ES:[DI]            ;Calculate how many possible Strings
  NEG  CL                    ;  there are
  MOV  AL,ES:[DI+5]          ;AL = First String Index
  CALL DoAudioClusterStrings ;Write the Strings
C90:                         ;Done
  POP  DX,CX,EAX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE AN AUDIO SPATIAL CONFIGURATION DESCRIPTION
;Inputs:  AX/EAX = Spatial Word/DWord to write
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
DoAudio1Spatial:
  PUSH ECX                ;Save used registers
  MOV  ECX,0000_0FFFh     ;Audio Version 1 only has 12 possible bits
  TEST AH,0F0h            ;Any illegal bits set?
  JNZ >P70                ;If so, handle it
  JMP >P00                ;If not, continue
DoAudio2Spatial:
  PUSH ECX                ;Save used registers
  MOV  ECX,-1             ;Audio Version 2 uses all bits
  TEST EAX,8000_0000h     ;Raw Data?
  JZ  >P00                ;If not, continue
  TEST EAX,7FFF_FFFFh     ;If so, any other bits set too?
  JNZ >P70                ;If so, it's Illegal
;  JMP >P00                ;Do it
P00:
  PUSH EAX,BX             ;Save used registers
  MOV  BX,AudioSpatialTbl ;[SI] = Table to get bits from
  AND  EAX,ECX            ;Mask out unapplicable bits
  CALL SearchBitMapTbl    ;Write the Descriptions
  POP  BX,EAX             ;Restore used registers
  JMP >P90                ;Done
P70:                      ;Illegal Attributes
  CALL WriteIllegalAttr   ;Write Illegal Attributes
P90:                      ;Done
  POP  ECX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;;WRITE THE CHANNEL STRINGS FOR AN AUDIO v1 CONTROL INTERFACE
;WRITE THE CHANNEL STRINGS FOR AN AUDIO CONTROL INTERFACE
;         AL = First String Index to use
;              (others follow in ascending Index Sequence, they are not
;               referred to directly in the Descriptor)
;         CL = Number of Strings to write (could be 0)
;         Int14Request contains Host Index and Device Address (-1 if invalid)
;Outputs: Writes Channel Strings, as appropriate, to the screen
;Changes:
;------------------------------------------------------------------------------
DoAudioClusterStrings:
  PUSH AX,CX,DX               ;Save used registers
  MOV  DX,ChanStringsMsg      ;[DX] = Message to write on first line
  MOV  AH,CL                  ;AH = Number of Strings to write
  OR   AH,AH                  ;Any Channels at all?
  JZ  >G70                    ;If not, handle it
  OR   AL,AL                  ;Any Strings at all?
  JZ  >G70                    ;If not, handle it
  XOR  CH,CH                  ;CH = Channels Written
  ADD  AH,AL                  ;AH = Last String Index to write
  MOV  CL,1                   ;CL = String Number Index
G10:                          ;Loop to here for each Channel
  OR   CH,CH                  ;Is this the first one?
  JZ  >G30                    ;If so, no need for new line
G20:                          ;Add new line
  CALL WriteCrLf              ;Move down
G30:                          ;New line and indentation handled, if appropriate
  INC  CH                     ;Increment Counter
  CALL WriteDescrByteNumNoDec ;Write the Description
  CALL DoGetString            ;Write the String
  INC  CL                     ;Increment String Number Index
  INC  AL                     ;Increment String Index
  CMP  AL,AH                  ;Done yet?
  JB   G10                    ;If not, keep writing
  JMP >G90                    ;If so, quit
G70:                          ;No Strings available
  CALL WriteDescrByteNoDec    ;Write the Description
  CALL WriteNone              ;Write none
G90:                          ;Done
  POP  DX,CX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COUNT THE TOTAL NUMBER OF BITS THAT ARE SET IN A WORD OR DWORD
;Inputs:  AX/EAX = Word/DWord to Test
;Outputs: CL = Number of Bits set in the Word/Dword
;              ZF = Set if CL = 0
;                 = Clear if CL != 0
;Changes:
;------------------------------------------------------------------------------
CountAXBitsSet:
  PUSH EAX             ;Save used registers
  AND  EAX,0000_FFFFh  ;Get rid of high word
  CALL CountEAXBitsSet ;Count the bits
  POP  EAX             ;Restore used registers
  RET

CountEAXBitsSet:
  PUSH EAX,EBX ;Save used registers
  XOR  CL,CL   ;Initialize Counter
  OR   EAX,EAX ;Are there any bits set?
  JZ  >S90     ;If not, we're done
S10:           ;Loop to here for each bits set
  INC  CL      ;Increment Bit Counter
  MOV  EBX,EAX ;Subtract 1 from the
  DEC  EBX     ;  current value
  AND  EAX,EBX ;Mask out the smallest set bit
  JNZ  S10     ;If there are still bits set, keep going
S90:           ;Done
  OR   CL,CL   ;Set return flag
  POP  EBX,EAX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE TO THE SCREEN AS A DECIMAL, AND SAVE THE VALUE FOR LATER USE
;Inputs:  DS = Local Data Area
;         AL = Byte to write and store
;Outputs: Writes to the Screen
;         Stores AL in StoredByte
;Changes:
;------------------------------------------------------------------------------
WriteByteMinStore:
  MOV  StoredByte,AL ;Save the byte value
  CALL WriteByteMin  ;Write it tothe screen
  RET

;------------------------------------------------------------------------------
;WRITE THE LAST SEVERAL BYTES OF AN AUDIO V1 OR V2 MIXER UNIT DESCRIPTOR
;Inputs:  DS = Local Data Area
;         ES:[DI] = Mixer Unit Programmability data (variable length)
;         ES:[DI-4] = # of Output Channels
;         ES:[DI+x] = Mixer Unit Description String Index
;                       (immediately after Programmability Data)
;         StoredByte = # of Input Channels
;         DescrLength
;Outputs: To Screen
;------------------------------------------------------------------------------
FinishAudio1MixUnitDescr:
  PUSH AX                    ;Save used registers
  MOV  AH,ES:[DI-4]          ;AH = Number of Columns
  XOR  AL,AL                 ;Mark as Audio 1
  JMP >M00                   ;Do it
FinishAudio2MixUnitDescr:
  PUSH AX                    ;Save used registers
  MOV  AH,ES:[DI-6]          ;AH = Number of Columns
  MOV  AL,1                  ;Mark as Audio 2
;  JMP >M00                   ;Do it
M00:
  PUSH DI                    ;Save used registers
  CALL HandleAudioMixUnitPrg ;Write the Programmability
  OR   AL,AL                 ;Audio 1 or Audio 2?
  JZ  >M40                   ;If Audio 1, just write the Unit String
M10:                         ;Audio 2 -- Need to write Control Status
  CALL WriteCrLf             ;Move down
  CALL DoAudio2MixUnitCtls   ;Write Control Status
  INC  DI                    ;Point at the Unit String
M40:                         ;Write Unit String
  CALL WriteCrLf             ;Move down
  MOV  AL,ES:[DI]            ;Write the
  CALL WriteAudioUnitString  ;  Unit String
M90:                         ;Done
  POP  DI                    ;Restore used registers
  POP  AX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE PROGRAMMABILITY BYTES FOR AN AUDIO MIXER UNIT DESCRIPTOR
;Inputs:   AH  = Max Column Number
;         StoredByte = Max Row Number
;         [DI] = Programmability bytes
;         Indent = Indent to use
;Outputs: [DI] = Next Byte after the Programmability Bytes
;Changes:
;------------------------------------------------------------------------------
HandleAudioMixUnitPrg:
  PUSH AX,BX,CX,DX,BP       ;Save used registers
  MOV  DX,MixerDescrMsg     ;[DX] = First Line Header Message
  MOV  BX,0101h             ;BL = Current Row Number = 1
                            ;BH = Current Column Number = 1
  MOV  CH,1                 ;Start with needing a new byte
  XOR  BP,BP                ;Mark as not needing a new line
X10:                        ;Loop to here for each Bit
  OR   BP,BP                ;Need to write a new line?
  JZ  >X15                  ;If no, don't Move Down
  CALL WriteCrLf            ;Move down
X15:                        ;New line handled, if needed
  DEC  BP                   ;Mark as needing a new line
  DEC  CH                   ;Decrement Bit Counter
  JNZ >X20                  ;If not 0 yet, keep using the same byte
  MOV  AL,ES:[DI]           ;Get the next data byte
  INC  DI                   ;Increment the Pointer
  MOV  CH,8                 ;Reset the bit counter
  CALL WriteDescrByteNoDec  ;Write the new Data Byte
  JMP >X25                  ;Jump to write the Control Bit Value
X20:                        ;Using same byte -- don't write byte value
  CALL DoIndent             ;Move over
X25:                        ;AL MSB contains correct bit
  CALL WriteProgrammability ;Write the Programmability
X40:                        ;Done processing this bit
  MOV  DX,NoMsg             ;Write blank lines from now on
  INC  BH                   ;Increment Column Number
  JZ  >X45                  ;If Column Counter rolled over, go to the next Row
  CMP  BH,AH                ;Done with the Columns for this Row?
  JBE  X10                  ;If not, keep going
X45:                        ;Go to the next Row
  MOV  BH,1                 ;Start at Column 1
  INC  BL                   ;Increment Row Number
  JZ  >X90                  ;If Row Counter rolled over, we're done
  CMP  BL,StoredByte        ;Done with all Rows?
  JBE  X10                  ;If not, keep going
X90:                        ;Done
  POP  BP,DX,CX,BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs:   DS = Local Data Area
;          AL = Programmability Bit (MSB is what we need to look at)
;          BL = Row Number (Input Pin)
;          BH = Column Number (Output Channel)
;Outputs: To Screen
;Changes: AL is rotated left by 1 bit
;------------------------------------------------------------------------------
WriteProgrammability:
  PUSH CX,DX                 ;Save used registers
  PUSH AX                    ;Save used registers
  MOV  AL,BL                 ;Write the
  CALL WriteByteMin          ;  Row Number
  MOV  DX,MixerPtrMsg        ;Write the
  CALL WriteItDX             ;  Arrow
  MOV  AL,BH                 ;Write the
  CALL WriteByteMin          ;  Column Number
  POP  AX                    ;Restore used registers
  CALL WriteColon            ;Write a Colon
  CALL WriteSpace            ;Move over
  MOV  DX,NotProgrammableMsg ;Assume Not Programmable
  ROL  AL,1                  ;Is it programmable?
  JNC >P30                   ;If not, continue
  MOV  DX,ProgrammableMsg    ;If so, it is Programmable
P30:                         ;[SI] = Correct Programmability Message
  CALL WriteItDX             ;Write the Programmability Status
  POP  DX,CX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE AN AUDIO UNIT STRING DESCRIPTOR
;Inputs:  AL = String Index to write
;         Int14Request Host/Device Address already filled in
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteAudioUnitString:
  PUSH DX                  ;Save used registers
  MOV  DX,UnitStringMsg    ;Write the
  CALL WriteDescrByteNoDec ;  Header
  CALL DoGetString         ;Get and Write the String
  POP  DX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE LAST SEVERAL BYTES OF AN AUDIO V1 FEATURE UNIT DESCRIPTOR
;Inputs:  DS = Local Data Area
;         ES:[DI] = Feature Unit Control Data (variable Length)
;         ES:[DI-1] = Array element Size (should be 2)
;         ES:[DI+x] = Mixer Unit Description String Index
;                       (immediately after Control Data)
;         DescrLength
;Outputs: To Screen
;NOTE: Decoding this descriptor "correctly" actually requires tracing back
;        through the previous descriptors to discover the number of channels
;        that are in the Source ID Descriptor.  We are not going to go there.
;      We will simply use the length of this descriptor to determine how
;        many channels should be written.
;      Also, since the version 2 Spec changed things so significantly, the
;        byte previous to this one should always be 2, though we will actually
;        look at it and use it correctly (though we have no knowledge of what
;        the extra bits would be if the size is anything other than 2).
;------------------------------------------------------------------------------
FinishAudio1FtrUnit:
  PUSH AX,BX,CX,DX,DI         ;Save used registers
  XOR  BH,BH                  ;BX =
  MOV  BL,ES:[DI-1]           ;  Element Size
  XOR  AH,AH                  ;AX = Number
  MOV  AL,DescrLength         ;  of Elements
  SUB  AL,7                   ;  in Control Array
  DIV  BL                     ;Divide by Size of each Element
  MOV  CH,AL                  ;CH = Number of Elements - 1
  XOR  CL,CL                  ;Start with Channel 0 (Master Channel)
  MOV  DX,AxFtrUnitCtlsMsg    ;Point at the Header Message
F10:                          ;Loop to here for each Element
  MOV  AX,ES:[DI]             ;Write the
  CALL WriteDescrWordNumNoDec ;  Description & Number
  OR   AX,AX                  ;Any bits set?
  JNZ >F15                    ;If so, write the Descriptions
  CALL WriteNone              ;If not, write "None"
  JMP >F20                    ;Continue
F15:                          ;Write Control Descriptions
  CALL DoAudio1FtrCtl         ;Write the Bit-mapped Values
F20:                          ;Write the Control Descriptions
  CALL WriteCrLf              ;Move down
  ADD  DI,BX                  ;Point at next Element
  INC  CL                     ;Increment Element Number
  CMP  CL,CH                  ;Done with all Elements yet?
  JB   F10                    ;If not, keep going
F60:                          ;Done with Controls
  MOV  AL,ES:[DI]             ;Write the
  CALL WriteAudioUnitString   ;  Unit String
  POP  DI,DX,CX,BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE AN AUDIO v1 FEATURE UNIT CONTROL WORD DESCRIPTION
;Inputs:  AX = Feature Unit Word to write
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
DoAudio1FtrCtl:
  PUSH BX                  ;Save used registers
  MOV  BX,Audio1FtrCtlTbl  ;[SI] = Table to get bits from
  CALL SearchBitMapIllegal ;Write the Descriptions
  POP  BX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE AN AUDIO v1 END POINT ATTRIBUTES BYTE DESCRIPTION
;Inputs:  AL = Attribute Byte to Write
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
DoAudio1EPAttribs:
  PUSH BX                   ;Save used registers
  MOV  BX,Audio1EPAttribTbl ;[SI] = Table to get bits from
  CALL SearchBitMapIllegal  ;Write the Descriptions
  POP  BX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE LAST SEVERAL BYTES OF A v2 FEATURE OR EFFECT UNIT DESCRIPTOR
;Inputs:  DS = Local Data Area
;         ES:[DI] = Feature/Effect Unit Control Data (variable Length)
;         ES:[DI+x] = Mixer Unit Description String Index
;                       (immediately after Control Data)
;         DescrLength
;Outputs: To Screen
;NOTE: Decoding this descriptor "correctly" actually requires tracing back
;        through the previous descriptors to discover the number of channels
;        that are in the Source ID Descriptor.  We are not going to go there.
;      We will simply use the length of this descriptor to determine how
;        many channels should be written.
;------------------------------------------------------------------------------
FinishAudio2FtrUnit:
  PUSH BX,CX                   ;Save used registers
  MOV  CH,DescrLength          ;CH = Number of
  SUB  CH,6                    ;  Control Bytes
  MOV  BX,DoAudio2FtrUnitCtls  ;[BX] = Controls Translation Code to Call
  JMP >E00                     ;Do it
FinishAudio2EfxUnit:
  PUSH BX,CX                   ;Save used registers
  MOV  CX,ES:[DI-3]            ;Get the Effect Type
  OR   CH,CH                   ;Invalid Type?
  JNZ >E001                    ;If so, handle it
  MOV  BX,DoAudio2ParEqCtls    ;Assume Parametric Equalizer
  CMP  CL,A2FXTypeParamEq      ;Is it Parametric Equalizer?
  JE  >E002                    ;If so, continue
  MOV  BX,DoAudio2ReverbCtls   ;Assume Reverberation
  CMP  CL,A2FXTypeReverb       ;Is it Reverberation?
  JE  >E002                    ;If so, continue
  MOV  BX,DoAudio2ModDlyCtls   ;Assume Modulation Delay
  CMP  CL,A2FXTypeModDelay     ;Is it Modulation Delay?
  JE  >E002                    ;If so, continue
  MOV  BX,DoAudio2DynRgCtls    ;Assume Dynamic Range Compression
  CMP  CL,A2FXTypeDynRange     ;Is it Dynamic Range Compression?
  JE  >E002                    ;If so, continue
E001:                          ;Invalid Effect Type
  MOV  BX,WriteUnknown         ;Just write Unknown
E002:
  MOV  CH,DescrLength          ;CH = Number of
  SUB  CH,8                    ;  Control Bytes
;  JMP >E00                     ;Do it
E00:
  PUSH EAX,DX,DI               ;Save used registers
  SHR  CH,2                    ;Convert # Control Bytes to # Controls
  XOR  CL,CL                   ;Start with Control 0
  MOV  DX,AxFtrUnitCtlsMsg     ;Point at the Header Message
E10:                           ;Loop to here for each Element
  MOV  EAX,ES:[DI]             ;Write the
  CALL WriteDescrDWordNumNoDec ;  Description & Number
  CALL BX                      ;Write the Bit-mapped Values
  CALL WriteCrLf               ;Move down
  ADD  DI,4                    ;Point at next Channel
  INC  CL                      ;Increment Channel Number
  CMP  CL,CH                   ;Done with all Channels yet?
  JB   E10                     ;If not, keep going
E60:                           ;Done with Controls
  MOV  AL,ES:[DI]              ;Write the
  CALL WriteAudioUnitString    ;  Unit String
  POP  DI,DX,EAX               ;Restore used registers
  POP  CX,BX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FINISH UP THE LAST SEVERAL BYTES OF A v1 PROCESS OR EXTENSION UNIT DESCRIPTOR
;Inputs:  ES:[DI] = Descriptor Data
;         StoredByte2 = Processing Unit Type
;         AL = First byte of Descriptor Data (Num Bytes in Control Field)
;Outputs: To Screen
;Changes:
;NOTES: The Audio v1 Spec declares some variable-sized fields, even though
;         they are always exactly the same size.  We will treat them as
;         if they are actually variable-sized, though.
;------------------------------------------------------------------------------
FinishAudio1ExtUnit:
  PUSH BP                     ;Save used registers
  MOV  BP,-1                  ;Mark as an extension unit
  JMP >X00                    ;Do it
FinishAudio1ProcUnit:
  PUSH BP                     ;Save used registers
  XOR  BP,BP                  ;Mark as a Processing Unit
;  JMP >X00                    ;Do it
X00:
  PUSH AX,BX,CX,DX,DI         ;Save used registers
  MOV  AL,ES:[DI]             ;Get the Number of Control Bytes
  INC  DI                     ;Update the Pointer
  MOV  DX,NumCtlBytesMsg      ;Write the number of bytes
  CALL WriteDescrByteDec      ;  in the Control field
  CALL WriteCrLf              ;Move down
  MOV  DX,SuppControlsMsg     ;[DX] = Header message to use
  MOV  CL,AL                  ;Store number of bytes in CL
  MOV  BX,Audio1ExtCtlTbl     ;Assume Extension Unit
  OR   BP,BP                  ;Is it an Extension Unit?
  JNZ >X20                    ;If so, continue
  MOV  AL,StoredByte2         ;Look for
  MOV  BX,Audio1ProcCtlTbl    ;  the correct
  CALL Byte2WordTbl           ;  Controls Table to use
  JNC >X20                    ;[BX] = Controls Table
X10:                          ;Not a Known Table
  MOV  BX,UnknownCtlByteTbl   ;Need to use unknown Controls Table
X20:                          ;[BX] = Controls Bitmap Table to Use
  MOV  AL,ES:[DI]             ;Get the Controls Byte
  INC  DI                     ;Update the Pointer
  CALL WriteDescrByteNoDec    ;Write the Header Message
  MOV  DX,NoMsg               ;Write nothing next time
  CALL SearchBitMapUnknown    ;Write the Bit Descriptions
  CALL WriteCrLf              ;Move down
  DEC  CL                     ;Decrement the Byte Counter
  JNZ  X10                    ;If not 0 yet, keep writing
X30:                          ;Done with Controls
  MOV  AL,ES:[DI]             ;Get the String Index
  INC  DI                     ;Update the Pointer
  MOV  DX,UnitStringMsg       ;Assume Extension Unit
  CALL WriteDescrByteNoDec    ;  Header
  CALL DoGetString            ;Write the String
  OR   BP,BP                  ;Is it an Extension Unit?
  JNZ >X90                    ;If so, we're done
  MOV  AL,StoredByte2         ;AL = Process Type
  CMP  AL,A1PTypeUpDnMix      ;Any more fields to come?
  JB  >X90                    ;If not, we're done
  CMP  AL,A1PTypeProLogic     ;Any more fields to come?
  JA  >X90                    ;If not, we're done
X40:                          ;Need to write Mode Details
  CALL WriteCrLf              ;Move down
  MOV  AL,ES:[DI]             ;Write the
  INC  DI                     ;  number
  MOV  DX,NumModesMsg         ;  of
  CALL WriteDescrByteDec      ;  Modes
  MOV  CH,AL                  ;Put Number of Modes in CH
  MOV  CL,1                   ;Start with Mode 1
  MOV  DX,ModeChanMsg         ;[DX] = Mode Descriptor Message
X50:                          ;Loop to here for each Mode
  CALL WriteCrLf              ;Move down
  MOV  AX,ES:[DI]             ;Get the next Channel Layout
  INC  DI,2                   ;Update Pointer
  CALL WriteDescrWordNumNoDec ;Write the Header
  CALL DoAudio1Spatial        ;Write the Channel Description
  INC  CL                     ;Increment the Counter
  CMP  CL,CH                  ;Have we doen all of the Modes yet?
  JBE  X50                    ;If not, keep writing
X90:                          ;Done
  POP  DI,DX,CX,BX,AX         ;Restore used registers
  POP  BP                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE LAST SEVERAL BYTES OF A v2 PROCESS EFFECT UNIT DESCRIPTOR
;Inputs:  DS = Local Data Area
;         ES:[DI] = Feature/Effect Unit Control Data (variable Length)
;         ES:[DI+x] = Mixer Unit Description String Index
;                       (immediately after Control Data)
;         DescrLength
;         StoredByte = Number of Input Pins
;Outputs: To Screen
;------------------------------------------------------------------------------
FinishAudio2ProcUnit:
  PUSH AX,BX,CX,DX,DI          ;Save used registers
  MOV  BX,-9                   ;Get the
  SUB  BL,StoredByte           ;  Process
  MOV  CX,ES:[DI+BX]           ;  Type
  OR   CH,CH                   ;Invalid Type?
  JNZ >P10                     ;If so, handle it
  MOV  BX,DoAudio2UpDnCtls     ;Assume Up/Down Mix
  CMP  CL,A2PTypeUpDnMix       ;Is it Up/Down Mix?
  JE  >P15                     ;If so, continue
  MOV  BX,DoAudio2DolbyCtls    ;Assume Dolby ProLogic
  CMP  CL,A2PTypeProLogic      ;Is it Dolby ProLogic?
  JE  >P15                     ;If so, continue
  MOV  BX,DoAudio2StereoXCtls  ;Assume Stereo Extender
  CMP  CL,A2PTypeStereoX       ;Is it Stereo Extender?
  JE  >P15                     ;If so, continue
P10:                           ;Invalid Process Type
  MOV  BX,WriteUnknown         ;Just write Unknown
P15:                           ;[BX] = Process Type Lookup Code
  MOV  DX,SuppControlsMsg      ;Point at the Header Message
  MOV  AX,ES:[DI]              ;Get the Control Attributes
  CALL BX                      ;Write the Bit-mapped Values
  CALL WriteCrLf               ;Move down
  INC  DI,2                    ;Point at next Data
  MOV  AL,ES:[DI]              ;Write the
  CALL WriteAudioUnitString    ;  Unit String
  CMP  CL,A2PTypeStereoX       ;Is it Stereo Extender?
  JE  >P90                     ;If so, we're done
P30:                           ;Need to do Channel Modes
  INC  DI                      ;Point at Number of Modes
  CALL WriteCrLf               ;Move down
  MOV  AL,ES:[DI]              ;Write the
  INC  DI                      ;  number
  MOV  DX,NumModesMsg          ;  of
  CALL WriteDescrByteDec       ;  Modes
  MOV  CH,AL                   ;Put Number of Modes in CH
  MOV  CL,1                    ;Start with Mode 1
  MOV  DX,ModeChanMsg          ;[DX] = Mode Descriptor Message
P50:                           ;Loop to here for each Mode
  CALL WriteCrLf               ;Move down
  MOV  EAX,ES:[DI]             ;Get the next Channel Layout
  ADD  DI,4                    ;Update Pointer
  CALL WriteDescrDWordNumNoDec ;Write the Header
  CALL DoAudio2Spatial         ;Write the Channel Description
  INC  CL                      ;Increment the Counter
  CMP  CL,CH                   ;Have we doen all of the Modes yet?
  JBE  P50                     ;If not, keep writing
P90:                           ;Done
  POP  DI,DX,CX,BX,AX          ;Restore used registers
  RET


  MaxKbpsMsg:        DB 'Max kbps',0
  SubSlotSizeMsg:    DB 'SubSlot Size (Bytes)',0
  ResolutionBitsMsg: DB 'Resolution (Bits)',0
  NumFreqsMsg:       DB '# of Sample Freqs',0
  SampsPerFrameMsg:  DB 'Samples per Frame',0
  SamplingTypeMsg:   DB 'Sampling Rate Type',0
  ContinuousMsg:     DB 'Continuous',0
  DiscreteMsg:       DB 'Discrete',0
  MinSampFreqMsg:    DB 'Min Sampling Rate',0
  MaxSampFreqMsg:    DB 'Max Sampling Rate',0
  SamplingRateMsg:   DB 'Sampling Rate',0
  HertzMsg:          DB ' Hz',0

;------------------------------------------------------------------------------
;WRITE THE LAST SEVERAL BYTES OF A v1 STREAM FORMAT TYPE DESCRIPTOR
;Inputs:  DS = Local Data Area
;         ES:[DI] = Remaining Data in Descriptor
;         ES:[DI-1] = Format Type
;         DescrLength
;Outputs: To Screen
;------------------------------------------------------------------------------
FinishAudio1StrFmtType:
  PUSH AX,CX,DX,DI,SI          ;Save used registers
  MOV  SI,HertzMsg             ;Tailer Message to use
  MOV  CL,ES:[DI-1]            ;CL = Format Type
  OR   CL,CL                   ;Invalid?
  JZ  >Y701                    ;If so, handle it
  CMP  CL,3                    ;Invalid?
  JA  >Y701                    ;If so, handle it
  CMP  CL,2                    ;Type 2?
  JE  >Y20                     ;If so, handle it
Y10:                           ;Type 1 or 3
  MOV  DX,NumChansMsg          ;Write
  CALL WriteNextDescrByte      ;  Number of Channels
  CALL WriteCrLf               ;Move down
  MOV  DX,SubSlotSizeMsg       ;Write
  CALL WriteNextDescrByte      ;  SubSlot Size
  CALL WriteCrLf               ;Move down
  MOV  DX,ResolutionBitsMsg    ;Write
  CALL WriteNextDescrByte      ;  Resolution Bits
  JMP >Y30                     ;Done
Y20:                           ;Type 2
  MOV  DX,MaxKbpsMsg           ;Write
  CALL WriteNextDescrWord      ;  Maximum kbps
  CALL WriteCrLf               ;Move down
  MOV  DX,SampsPerFrameMsg     ;Write
  CALL WriteNextDescrWord      ;  Samples per Frame
Y30:                           ;Handle Sampling
  CALL WriteCrLf               ;Move down
  MOV  AL,ES:[DI]              ;Get the
  INC  DI                      ;  Sampling
  MOV  DX,SamplingTypeMsg      ;  Type
  CALL WriteDescrByteNoDec     ;Write it

  OR   AL,AL                   ;Is it Continuous or Discrete?
  JNZ >Y50                     ;If discrete, jumpp to handle it
Y40:                           ;Continuous
  MOV  DX,ContinuousMsg        ;Write
  CALL WriteItDX               ;  Continuous
  CALL WriteCrLf               ;Move down
  MOV  EAX,ES:[DI]             ;Write the
  MOV  DX,MinSampFreqMsg       ;  Minimum
  CALL WriteDescrTriByteDec    ;  Sampling Frequency
  CALL WriteItSI               ;Write Hertz
  CALL WriteCrLf               ;Move down
  MOV  EAX,ES:[DI+3]           ;Write the
  MOV  DX,MaxSampFreqMsg       ;  Maximum
  CALL WriteDescrTriByteDec    ;  Sampling Frequency
  MOV  DX,HertzMsg             ;Write
  CALL WriteItDX               ;  Hertz
  JMP >Y90                     ;Done
Y701:                          ;To avoid JMP > 128
  JMP >Y70                     ;Error
Y50:                           ;Discrete
  MOV  DX,DiscreteMsg          ;Write
  CALL WriteItDX               ;  Discrete
  CALL WriteCrLf               ;Move down
  MOV  CH,AL                   ;CH = Number of Discrete Sampling Rates
  MOV  CL,1                    ;Start with Number 1
  MOV  DX,SamplingRateMsg      ;Header to use
Y55:                           ;Loop to here for each Discrete Frequency
  MOV  EAX,ES:[DI]             ;Get the next frequency
  ADD  DI,3                    ;Update the Pointer
  CALL WriteDescrTriByteNumDec ;Write the Frequency
  CALL WriteItSI               ;Write Hertz
  INC  CL                      ;Increment the Index
  CMP  CL,CH                   ;Done all of them yet?
  JA  >Y90                     ;If so, we're done
  CALL WriteCrLf               ;If not, move down
  JMP  Y55                     ;Keep going
Y70:                           ;Invalid Type
  CALL WriteUnknown            ;Write Unknown
Y90:                           ;Done
  POP  SI,DI,DX,CX,AX          ;Restore used registers
  RET


;  A1FmtType1Struc  STRUC   ;Struc for Audio v1 Data Format Type I Descriptor
;    A1FT1Length       DB ? ;Size of Descriptor in bytes
;    A1FT1DescrType    DB DescrTypeAudioInterface
;    A1FT1DescrSType   DB A1IntfDescSTypeASFmtType
;    A1FT1FormatType   DB AudFmtType1

;    A1FT1NumChans     DB ? ;Number of Physical Channels in Audio Data Stream
;    A1FT1SubSlotSize  DB ? ;Number of Bytes in Audio SubSlot (1-4)
;    A1FT1Resolution   DB ? ;Number of effectively used bits per SubSlot

;    A1FT1SampFreqType DB ? ;How sampling Frequency can be programmmed
;                           ;0 = Continuous
;                           ;1-255 = # of discrete frequencies supported by
;                           ;  the Isoch Data Endpoint of Audio Streaming Intf
;    A1FT1SampleFreq1  DB 3 DUP (?)
;    A1FT1SampleFreq2  DB 3 DUP (?)
;    ;...
;    ;If SampFreqType = 0,
;    ;   SampleFreq1 = Lower Sampling Bound (Hz),
;    ;   SampleFreq2 = Upper Sampling Bound (Hz)
;    ;If SampFreqType != 0,
;    ;   SampleFreq1 = First Discrete Sampling Frequency (Hz)
;    ;   SampleFreq2 = Second Discrete Sampling Frequency (Hz)
;    ;   ... until Discrete Counter (SampFreqType) is met
;   ENDS

;  ;----------------------------------------------------------------------------
;  ;Audio v1 Data Format Type III Descriptor Structure
;  ;----------------------------------------------------------------------------
;  ;This structure is EXACTLY the same as the Type I Descriptor, with the
;  ;  following dedicated values in some of the fields:
;  ;  FormatType  = AudFmtType3
;  ;  NumChans    = 2
;  ;  SubSlotSize = 2

;
;  ;----------------------------------------------------------------------------
;  ;Audio v1 Data Format Type II Descriptor Structure
;  ;----------------------------------------------------------------------------
;  A1FmtType2Struc   STRUC   ;Struc for Audio v1 Data Format Type II Descriptor
;    A1FT2Length        DB ? ;Size of Descriptor in bytes
;    A1FT2DescrType     DB DescrTypeAudioInterface
;    A1FT2DescrSType    DB A1IntfDescSTypeASFmtType
;    A1FT2FormatType    DB AudFmtType2
;    A1FT2MaxKBPS       DW ? ;Maximim kbps Interface can handle
;    A1FT2SampsPerFrame DW ? ;Number of PCM Samples per Audio Frame
;    A1FT2SampFreqType  DB ? ;How sampling Frequency can be programmmed
;                            ;0 = Continuous
;                            ;1-255 = # of discrete frequencies supported by
;                            ;  the Isoch Data Endpoint of Audio Streaming Intf
;    A1FT2SampleFreq1   DB 3 DUP (?)
;    A1FT2SampleFreq2   DB 3 DUP (?)
;    ;...
;    ;If SampFreqType = 0,
;    ;   SampleFreq1 = Lower Sampling Bound (Hz),
;    ;   SampleFreq2 = Upper Sampling Bound (Hz)
;    ;If SampFreqType != 0,
;    ;   SampleFreq1 = First Discrete Sampling Frequency (Hz)
;    ;   SampleFreq2 = Second Discrete Sampling Frequency (Hz)
;    ;   ... until Discrete Counter (SampFreqType) is met
;   ENDS


;------------------------------------------------------------------------------
;Inputs:  ES:[DI] = Descriptor Data
;         [DX] = Description String to Write with the Data
;Outputs: Writes Description String, Colon, Hex Value,
;           & Decimal Value, with appropriate spacing
;Changes: Updates DI
;------------------------------------------------------------------------------
WriteNextDescrByte:
  PUSH BX,CX                    ;Save used registers
  MOV  BX,WriteDescrByteDec     ;[BX] = Code to call
  MOV  CX,1                     ;CX = Size of Data
  JMP >X00                      ;Do it
WriteNextDescrWord:
  PUSH BX,CX                    ;Save used registers
  MOV  BX,WriteDescrWordDec     ;[BX] = Code to call
  MOV  CX,2                     ;CX = Size of Data
  JMP >X00                      ;Do it
WriteNextDescrTriByte:
  PUSH BX,CX                    ;Save used registers
  MOV  BX,WriteDescrTriByteDec  ;[BX] = Code to call
  MOV  CX,2                     ;CX = Size of Data
  JMP >X00                      ;Do it
WriteNextDescrDWord:
  PUSH BX,CX                    ;Save used registers
  MOV  BX,WriteDescrDWordDec    ;[BX] = Code to call
  MOV  CX,3                     ;CX = Size of Data
  JMP >X00                      ;Do it
X00:
  PUSH EAX                      ;Save used registers
;  CALL WriteCrLf                ;Move down
  MOV  EAX,ES:[DI]              ;EAX = Data
  CALL BX                       ;Write the Data
  ADD  DI,CX                    ;update the Pointer
  POP  EAX                      ;Restore used registers
  POP  CX,BX                    ;Restore used registers
  RET













  ;============================================================================
  ;Audio Control Interface Class-Specific Descriptors
  ;  (Interface Class 01h, Interface SubClass 01h)
  ;  Audio Spec Version 1 Specific
  ;============================================================================

  DescrMsgTblAudio1Ctl:

  ;------------------------------------------------------------------------------
  ;Audio Version 1 Control Interface Descriptor
  ;------------------------------------------------------------------------------
    DB 4, DescrTypeAudioInterface, A1IntfDescSTypeACHeader, -1, 01h
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v1 CONTROL DESCRIPTOR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, 0
    DW WriteAudio1CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoVersionStoreClass
        DB DTagColon   +2, 'Audio Spec Version',0
    DW DoDescrTotalLength
        DB DTagSkip    +2, 0
    DW FinishAudio1CtlIntf
        DB DTagVariable+1, '# of Stream Interfaces',0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 1 Input Terminal Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A1IntfDescSTypeACInTerm
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v1 INPUT TERMINAL DESCR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, 0
    DW WriteAudio1CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrTerminalID
        DB DTagSkip    +1, 0
    DW DoAudioTermType
        DB DTagColon   +2, 'Terminal Type',0
    DW WriteByteMin
        DB DTagColon   +1, 'Assoc Output Term ID',0
    DW DoAudio1Cluster
        DB DTagSkip    +4, 0
    DW DoDescrTermString
        DB DTagSkip    +1, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 1 Output Terminal Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A1IntfDescSTypeACOutTerm
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v1 OUTPUT TERMINAL DESCR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, 0
    DW WriteAudio1CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrTerminalID
        DB DTagSkip    +1, 0
    DW DoAudioTermType
        DB DTagColon   +2, 'Terminal Type',0
    DW WriteByteMin
        DB DTagColon   +1, 'Assoc Input Term ID',0
    DW DoDescrSourceID
        DB DTagSkip    +1, 0
    DW DoDescrTermString
        DB DTagSkip    +1, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 1 Mixer Unit Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A1IntfDescSTypeACMixUnit
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v1 MIXER UNIT DESCRIPTOR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, 0
    DW WriteAudio1CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrUnitID
        DB DTagSkip    +1, 0
    DW DoAudioInputSources
        DB DTagVarSkip +1, 0
    DW DoAudio1Cluster
        DB DTagSkip    +4, 0
    DW FinishAudio1MixUnitDescr
        DB DTagSkip+DTagEndOfDescr+0, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 1 Selector Unit Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A1IntfDescSTypeACSelUnit
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v1 SELECTOR UNIT DESCRIPTOR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, 0
    DW WriteAudio1CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrUnitID
        DB DTagSkip    +1, 0
    DW DoAudioInputSources
        DB DTagVarSkip +1, 0
    DW WriteAudioUnitString
        DB DTagSkip    +1, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 1 Feature Unit Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A1IntfDescSTypeACFtrUnit
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v1 FEATURE UNIT DESCRIPTOR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, 0
    DW WriteAudio1CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrUnitID
        DB DTagSkip    +1, 0
    DW DoDescrSourceID
        DB DTagSkip    +1, 0
    DW WriteByteMin
        DB DTagColon   +1, 'Bytes per Ctl Element',0
    DW FinishAudio1FtrUnit
        DB DTagSkip+DTagEndOfDescr+0, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 1 Processing Unit Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A1IntfDescSTypeACProcUnit
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v1 PROCESSING UNIT DESCR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, 0
    DW WriteAudio1CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrUnitID
        DB DTagSkip    +1, 0
    DW DoAudio1ProcType
        DB DTagColon   +2, 'Unit Type',0
    DW DoAudioInputSources
        DB DTagVarSkip +1, 0
    DW DoAudio1Cluster
        DB DTagSkip    +4, 0
    DW FinishAudio1ProcUnit
        DB DTagSkip+DTagEndOfDescr+0, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 1 Extension Unit Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A1IntfDescSTypeACExtUnit
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v1 EXTENSION UNIT DESCR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, ,0
    DW WriteAudio1CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrUnitID
        DB DTagSkip    +1, 0
    DW WriteWordMin
        DB DTagColon   +2, 'Extension Code',0
    DW DoAudioInputSources
        DB DTagVarSkip +1, 0
    DW DoAudio1Cluster
        DB DTagSkip    +4, 0
    DW FinishAudio1ExtUnit
        DB DTagSkip+DTagEndOfDescr+0, 0
    DW 0 ;End of Descriptor Entry

    DB 0 ;End of Table!!


  ;============================================================================
  ;Audio Stream Interface Class-Specific Descriptors
  ;  (Interface Class 01h, Interface SubClass 02h)
  ;  Audio Spec Version 1 Specific
  ;============================================================================

  DescrMsgTblAudio1Str:

  ;------------------------------------------------------------------------------
  ;Audio Version 1 General Stream Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A1IntfDescSTypeASGeneral
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v1 GENERAL STREAM DESCR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, 0
    DW WriteAudio1StrDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrTerminalID
        DB DTagSkip    +1, 0
    DW WriteByteMin
        DB DTagColon   +1, 'Delay (Frames)',0
    DW DoAudio1StrFmtTag
        DB DTagColon   +2, 'Audio Format',0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 1 Stream Format Type Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A1IntfDescSTypeASFmtType
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v1 STREAM FORMAT TYPE DESCR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, 0
    DW WriteAudio1StrDescrSType
        DB DTagSkip    +1, 0
    DW DoAudio1StrFmtType
        DB DTagColon   +1, 'Format Type',0
    DW FinishAudio1StrFmtType
        DB DTagSkip+DTagEndOfDescr+0, 0
    DW 0 ;End of Descriptor Entry


;  ;----------------------------------------------------------------------------
;  ;Audio v1 MPEG Format-Specific Descriptor Structure
;  ;----------------------------------------------------------------------------
;  A1MPGStruc         STRUC       ;Struc for Audio v1 MPEG Format-Specific Descr
;    A1MPGLength         DB    8  ;Size of Descriptor in bytes
;    A1MPGDescrType      DB DescrTypeAudioInterface
;    A1MPGDescrSType     DB A1IntfDescSTypeASFmtSpec
;    A1MPGFormatTag      DW A1FT2MPEG ;Duplicate of value in Class-Spec Intf Descr
;    A1MPGCapabilities   DW    ?  ;MPEG Decoder Capabilities bitmap
;      A1MCLayer1Supp   EQU 0001h ;MPEG Layer 1 Supported
;      A1MCLayer2Supp   EQU 0002h ;MPEG Layer 2 Supported
;      A1MCLayer3Supp   EQU 0004h ;MPEG Layer 3 Supported
;      A1MCMPEG1Only    EQU 0008h ;MPEG-1 Only
;      A1MCMPEG1DualCh  EQU 0010h ;MPEG-1 Dual Channel
;      A1MCMPEG2Stereo  EQU 0020h ;MPEG-2 Second Stereo
;      A1MCMPEG271Aug   EQU 0040h ;MPEG-2 7.1 Channel Augmentation
;      A1MCAMP          EQU 0080h ;Adaptive Multi-Channel Prediction
;      A1MCMultiLingual EQU 0300h ;MPEG-2 Multilingual Support Mask
;        A1MCLNoSupp    EQU 0000h ;Not Supported
;        A1MCLFs        EQU 0100h ;Supported at Fs (Full Speed?)
;        A1MCLReserved  EQU 0200h ;Reserved
;        A1MCLFs12Fs    EQU 0300h ;Supported at Fs and 1/2 Fs (Full & 1/2 Speed?)
;      ;Bits 10-15 = Reserved
;    A1MPGFeatures       DB    ?  ;MPEG Decoder Features bitmap
;      ;Bits 0-3 = Reserved
;      A1MFDynRangeCtl  EQU   30h ;Dynamic Range Control Support Mask
;        A1MFDNoSupp    EQU   00h ;Not supported
;        A1MFDNoScale   EQU   10h ;Supported but no scalable
;        A1MFDCommon    EQU   20h ;Scalable, Common Boost & Cut Scaling Value
;        A1MFDSeparate  EQU   30h ;Scalable, Separate Boost & Cut Scaling Value
;      ;Bits 6-7 = Reserved
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Audio v1 AC-3 Format-Specific Descriptor Structure
;  ;----------------------------------------------------------------------------
;  A1AC3Struc         STRUC     ;Struc for Audio v1 AC-3 Format-Specific Descr
;    A1AC3Length         DB 10  ;Size of Descriptor in bytes
;    A1AC3DescrType      DB DescrTypeAudioInterface
;    A1AC3DescrSType     DB A1IntfDescSTypeASFmtSpec
;    A1AC3FormatTag      DW A1FT2AC3 ;Duplicate of value in Class-Spec Intf Descr
;    A1AC3BSIDModes      DD  ?  ;Bitmap of BSID modes supported
;    A1AC3Features       DB  ?  ;AC-3 Decoder Features bitmap
;      A1AFRFMode       EQU 01h ;RF Mode Supported
;      A1AFLineMode     EQU 02h ;Line Mode Supported
;      A1AFCustom0Mode  EQU 04h ;Custom0 Mode Supported
;      A1AFCustom1Mode  EQU 08h ;Custom1 Mode Supported
;      A1AFDynRangeCtl  EQU 30h ;Dynamic Range Control Support Mask
;        A1AFDNoSupp    EQU 00h ;Not supported
;        A1AFDNoScale   EQU 10h ;Supported but no scalable
;        A1AFDCommon    EQU 20h ;Scalable, Common Boost & Cut Scaling Value
;        A1AFDSeparate  EQU 30h ;Scalable, Separate Boost & Cut Scaling Value
;      ;Bits 6-7 = Reserved
;   ENDS


;  ;----------------------------------------------------------------------------
;  ;Audio Class-Specific EndPoint Descriptor SubTypes
;  ;----------------------------------------------------------------------------
;    AEndPtDescSTypeUndef   EQU 00h ;Undefined
;    AEndPtDescSTypeGeneral EQU 01h ;General

;  ;----------------------------------------------------------------------------
;  ;Audio Lock Delay Units (for Class-Specific EndPoint Descrs)
;  ;----------------------------------------------------------------------------
;  AudLkDlyUnitUndef   EQU 00h ;Undefined
;  AudLkDlyUnitMS      EQU 01h ;MilliSeconds
;  AudLkDlyUnitPCMSamp EQU 02h ;Decoded PCM Samples

  ;------------------------------------------------------------------------------
  ;Audio Version 1 Isochronous EndPoint Descriptor
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeAudioEndPoint
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v1 ISOCHRONOUS ENDPT DESCR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, 0
    DW WriteAudio1EPDescrSType
        DB DTagSkip    +1, 0
    DW DoAudio1EPAttribs
        DB DTagColon   +1, 'Attributes',0
    DW DoAudio1EPLockUnit
        DB DTagColon   +1, 'Lock Delay Units',0
    DW WriteWordMin
        DB DTagColon   +2, 'Lock Delay Value',0
    DW 0 ;End of Descriptor Entry

    DB 0 ;End of Table!!


  ;============================================================================
  ;Audio MIDI Stream Interface Class-Specific Descriptors
  ;  (Interface Class 01h, Interface SubClass 03h)
  ;  Either Audio Spec Version (1 or 2)
  ;============================================================================

  DescrMsgTblAudioMIDI:


;  ;----------------------------------------------------------------------------
;  ;Class-Specific MIDI Streaming (MS) Interface Descriptor SubTypes
;  ;----------------------------------------------------------------------------
;    AIntfDescSTypeMSUndef   EQU 00h ;Undefined
;    AIntfDescSTypeMSHeader  EQU 01h ;Header
;    AIntfDescSTypeMSJackIn  EQU 02h ;MIDI In Jack
;    AIntfDescSTypeMSJackOut EQU 03h ;MIDI Out Jack
;    AIntfDescSTypeMSElement EQU 04h ;Element
;
;  ;----------------------------------------------------------------------------
;  ;MIDI Class-Specific EndPoint Descriptor SubTypes
;  ;----------------------------------------------------------------------------
;    MEndPtDescSTypeUndef   EQU 00h ;Undefined
;    MEndPtDescSTypeGeneral EQU 01h ;General
;
;  ;----------------------------------------------------------------------------
;  ;MIDI In & MIDI Out Jack Types
;  ;----------------------------------------------------------------------------
;    MIDIJackTypeUndef  EQU 00h ;Undefined
;    MIDIJackTypeEmbed  EQU 01h ;Embedded
;    MIDIJackTypeExtern EQU 02h ;External



;;==============================================================================
;;MIDI Streaming Descriptor Structures
;;There has not (yet) been a version 2 of the USB-MIDI standard released,
;;  so these are the same whether we are talking Audio v1 or v2?
;;==============================================================================
;
;  ;----------------------------------------------------------------------------
;  ;Class-Specific MIDI Streaming Interface Header Descriptor
;  ;----------------------------------------------------------------------------
;  MIDIStrIntfStruc STRUC ;Struc for MIDI Streaming Intf Descr
;    MSILength       DB 7 ;Size of Descriptor in bytes
;    MSIDescrType    DB DescrTypeAudioInterface
;    MSIDescrSubType DB AIntfDescSTypeMSHeader
;    MSIMSCVersion   DW ? ;MIDIStreaming SubClass Spec Version (BCD)
;    MSITotalLength  DW ? ;Total Length for all Descriptors, incl this one
;                         ;  and all Jack & ELement Descriptors
;   ENDS
;   ;Followed by one or more Jack and/or Element Descriptors
;
;  ;----------------------------------------------------------------------------
;  ;Class-Specific MIDI Jack In Descriptor
;  ;----------------------------------------------------------------------------
;  MIDIJackInStruc STRUC    ;Structure for Class-Specific MIDI In Jack
;    MJILength        DB  6 ;Size of Descriptor in bytes
;    MJIDescrType     DB DescrTypeAudioInterface
;    MJIDescrSubType  DB AIntfDescSTypeMSJackIn
;    MJIJackType      DB  ?  ;Jack Type (Undefined, Embedded, External)
;    MJIJackID        DB  ?  ;Unique Jack Identifer
;    MJIJackString    DB  ?  ;Index of String describing this Jack
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Class-Specific MIDI Jack Out Descriptor
;  ;Variable Length
;  ;----------------------------------------------------------------------------
;  MIDIJackOutStruc STRUC  ;Structure for Class-Specific MIDI Out Jack
;    MJOLength        DB ? ;Size of Descriptor in bytes
;    MJODescrType     DB DescrTypeAudioInterface
;    MJODescrSubType  DB AIntfDescSTypeMSJackOut
;    MJOJackType      DB ? ;Jack Type
;      ;Same values as MJIJackType (Embedded or External)
;    MJOJackID        DB ? ;Unique Jack Identifer
;    MJONumPins       DB ? ;Number of Input Pins (P)
;    MJOSourceID1     DB ? ;Entity ID to which 1st Input Pin is connected
;    MJOSourcePin1    DB ? ;Entity Output Pin # to which 1st Pin is connected
;    ;;;
;    MJOSourceIDP     DB ? ;Entity ID to which Last Input Pin is connected
;    MJOSourcePinP    DB ? ;Entity Output Pin # to which Last Pin is connected
;    MJOJackString    DB ? ;Index of String describing this Jack
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Class-Specific MIDI Element Descriptor
;  ;Variable Length
;  ;----------------------------------------------------------------------------
;  MIDIElementStruc STRUC      ;Structure for Class-Specific MIDI Element
;    MELength         DB    ?  ;Size of Descriptor in bytes
;    MEDescrType      DB DescrTypeAudioInterface
;    MEDescrSubType   DB AIntfDescSTypeMSElement
;    MEElementID      DB    ?  ;Unique Element Identifer
;    MENumInPins      DB    ?  ;Number of Input Pins (P)
;    MESourceID1      DB    ?  ;Entity ID to which 1st Input Pin is connected
;    MESourcePin1     DB    ?  ;Entity Output Pin # to which 1st Pin is connected
;    ;;;
;    MESourceIDP      DB    ?  ;Entity ID to which Last Input Pin is connected
;    MESourcePinP     DB    ?  ;Entity Output Pin # to which Last Pin is connected
;    MENumOutPins     DB    ?  ;Number of Output Pins (Q)
;    MEInTermLink     DB    ?  ;Input Terminal ID to which this Element is connected
;    MEOutTermLink    DB    ?  ;Output Terminal ID to which this Element is connected
;    MECapSize        DB    ?  ;Capabilities Size (N)
;                              ;According to the v1.0 Spec, the size is 1,
;                              ;  but they have more than 8 bits worth of data!
;    MECapabilities   DB    ?  ;Element Capabilities
;      MECapCustom   EQU 0001h ;Custom Undefined
;      MECapClock    EQU 0002h ;MIDI Clock
;      MECapMTC      EQU 0004h ;MIDI Time Code
;      MECapMMC      EQU 0008h ;MIDI Machine Control
;      MECapGM1      EQU 0010h ;General MIDI Syetem Level 1
;      MECapGM2      EQU 0020h ;General MIDI Syetem Level 2
;      MECapG5       EQU 0040h ;G5 Format (Roland)
;      MECapXG       EQU 0080h ;XG Format (Yamaha)
;      MECapEFX      EQU 0100h ;Audio Effects Processor
;      MECapPatch    EQU 0200h ;Internal MIDI Patcher/Router
;      MECapDLS1     EQU 0400h ;Downloadable Sounds Standard Level 1
;      MECapDLS2     EQU 0800h ;Downloadable Sounds Standard Level 2
;      ;Bits 12+ = Reserved
;    MEElementString  DB  ?  ;Index of String describing this Element
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;MIDI Class-Specific Bulk Data EndPoint Descriptor Structure
;  ;----------------------------------------------------------------------------
;  MIDIBulkDataEndPointStruc STRUC ;Struc for MIDI Bulk Data EndPt Descr
;    MBDLength         DB 7 ;Size of Descriptor in bytes (7)
;    MBDDescrType      DB DescrTypeAudioEndPoint
;    MBDDescrSType     DB MEndPtDescSTypeGeneral
;    MBDNumEmbJacks    DB ? ;Number of Embedded MIDI Jacks (N)
;    MBDJackID1        DB ? ;ID of First Associated Embedded Jack
;    ;;;
;    MBDJackIDN        DB ? ;ID of Last Associated Embedded Jack
;
;   ENDS



    DB 0 ;End of Table!!


  ;============================================================================
  ;Audio Control Interface Class-Specific Descriptors
  ;  (Interface Class 01h, Interface SubClass 01h)
  ;  Audio Spec Version 2 Specific
  ;============================================================================

  DescrMsgTblAudio2Ctl:

  ;------------------------------------------------------------------------------
  ;Audio Version 2 Control Interface Descriptor
  ;------------------------------------------------------------------------------
    DB 4, DescrTypeAudioInterface, A2IntfDescSTypeACHeader, -1, 02h
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v2 CONTROL DESCRIPTOR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, 0
    DW WriteAudio2CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoVersionStoreClass
        DB DTagColon   +2, 'Audio Spec Version',0
    DW DoAudio2PrimaryUse
        DB DTagColon   +1, 'Category (Primary Use)',0
    DW DoDescrTotalLength
        DB DTagSkip    +2, 0
    DW DoAudio2CtlIntfCtls
        DB DTagSkip    +1, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 2 Input Terminal Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A2IntfDescSTypeACInTerm
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v2 INPUT TERMINAL DESCR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, ,0
    DW WriteAudio2CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrTerminalID
        DB DTagSkip    +1, 0
    DW DoAudioTermType
        DB DTagColon   +2, 'Terminal Type',0
    DW WriteByteMin
        DB DTagColon   +1, 'Assoc Output Term ID',0
    DW DoDescrClockSrcID
        DB DTagSkip    +1, 0
    DW DoAudio2Cluster
        DB DTagSkip    +6, 0
    DW DoAudio2InTermCtls
        DB DTagSkip    +2, 0
    DW DoDescrTermString
        DB DTagSkip    +1, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 2 Output Terminal Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A2IntfDescSTypeACOutTerm
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v2 OUTPUT TERMINAL DESCR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, ,0
    DW WriteAudio2CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrTerminalID
        DB DTagSkip    +1, 0
    DW DoAudioTermType
        DB DTagColon   +2, 'Terminal Type',0
    DW WriteByteMin
        DB DTagColon   +1, 'Assoc Input Term ID',0
    DW DoDescrSourceID
        DB DTagSkip    +1, 0
    DW DoDescrClockSrcID
        DB DTagSkip    +1, 0
    DW DoAudio2OutTermCtls
        DB DTagSkip    +2, 0
    DW DoDescrTermString
        DB DTagSkip    +1, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 2 Mixer Unit Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A2IntfDescSTypeACMixUnit
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v2 MIXER UNIT DESCRIPTOR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, ,0
    DW WriteAudio2CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrUnitID
        DB DTagSkip    +1, 0
    DW DoAudioInputSources
        DB DTagVarSkip +1, 0
    DW DoAudio2Cluster
        DB DTagSkip    +6, 0
    DW FinishAudio2MixUnitDescr
        DB DTagSkip+DTagEndOfDescr+0, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 2 Selector Unit Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A2IntfDescSTypeACSelUnit
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v2 SELECTOR UNIT DESCRIPTOR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, ,0
    DW WriteAudio2CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrUnitID
        DB DTagSkip    +1, 0
    DW DoAudioInputSources
        DB DTagVarSkip +1, 0
    DW DoAudio2SelUnitCtls
        DB DTagSkip    +1, 0
    DW DoDescrUnitString
        DB DTagSkip    +1, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 2 Feature Unit Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A2IntfDescSTypeACFtrUnit
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v2 FEATURE UNIT DESCRIPTOR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, ,0
    DW WriteAudio2CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrUnitID
        DB DTagSkip    +1, 0
    DW DoDescrSourceID
        DB DTagSkip    +1, 0
    DW FinishAudio2FtrUnit
        DB DTagSkip+DTagEndOfDescr+0, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 2 Effect Unit Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A2IntfDescSTypeACEfxUnit
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v2 EFFECT UNIT DESCRIPTOR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, ,0
    DW WriteAudio2CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrUnitID
        DB DTagSkip    +1, 0
    DW DoAudio2EfxType
        DB DTagColon   +2, 'Unit Type',0
    DW DoDescrSourceID
        DB DTagSkip    +1, 0
    DW FinishAudio2EfxUnit
        DB DTagSkip+DTagEndOfDescr+0, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 2 Process Unit Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A2IntfDescSTypeACProcUnit
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v2 PROCESS UNIT DESCRIPTOR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, ,0
    DW WriteAudio2CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrUnitID
        DB DTagSkip    +1, 0
    DW DoAudio2ProcType
        DB DTagColon   +2, 'Unit Type',0
    DW DoAudioInputSources
        DB DTagVarSkip +1, 0
    DW DoAudio2Cluster
        DB DTagSkip    +6, 0
    DW FinishAudio2ProcUnit
        DB DTagSkip+DTagEndOfDescr+0, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 2 Extension Unit Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A2IntfDescSTypeACExtUnit
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v2 EXTENSION UNIT DESCRIPTOR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, ,0
    DW WriteAudio2CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrUnitID
        DB DTagSkip    +1, 0
    DW WriteWordMin
        DB DTagColon   +2, 'Extension Code',0
    DW DoAudioInputSources
        DB DTagVarSkip +1, 0
    DW DoAudio2Cluster
        DB DTagSkip    +6, 0
    DW DoAudio2ExtUnitCtls
        DB DTagSkip    +1, 0
    DW DoDescrUnitString
        DB DTagSkip    +1, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 2 Clock Source Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A2IntfDescSTypeACClkSrc
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v2 CLOCK SOURCE UNIT DESCR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, ,0
    DW WriteAudio2CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrUnitID
        DB DTagSkip    +1, 0
    DW DoAudio2ClkSrcAttribs
        DB DTagColon   +1, 'Attributes',0
    DW DoAudio2ClkSrcCtls
        DB DTagSkip    +1, 0
    DW WriteByteMin
        DB DTagColon   +1, 'Assoc Terminal ID',0
    DW DoDescrUnitString
        DB DTagSkip    +1, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 2 Clock Selector Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A2IntfDescSTypeACClkSel
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v2 CLOCK SELECTOR DESCR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, ,0
    DW WriteAudio2CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrUnitID
        DB DTagSkip    +1, 0
    DW DoAudio2ClockSelPins
        DB DTagVariable+1, '# of Clk Input Pins',0
    DW DoAudio2ClkSelCtls
        DB DTagSkip    +1, 0
    DW DoDescrUnitString
        DB DTagSkip    +1, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 2 Clock Multiplier Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A2IntfDescSTypeACClkMul
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v2 CLOCK MULTIPLIER DESCR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, ,0
    DW WriteAudio2CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrUnitID
        DB DTagSkip    +1, 0
    DW DoDescrClockSrcID
        DB DTagSkip    +1, 0
    DW DoAudio2ClkMulCtls
        DB DTagSkip    +1, 0
    DW DoDescrUnitString
        DB DTagSkip    +1, 0
    DW 0 ;End of Descriptor Entry

  ;------------------------------------------------------------------------------
  ;Audio Version 2 Sample Rate Converter Descriptor
  ;------------------------------------------------------------------------------
    DB 2, DescrTypeAudioInterface, A2IntfDescSTypeACSampCv
    DW DoNothing
        DB DTagSizeOnly+1, 'AUDIO v2 SAMPLE RATE CONV DESCR',0
    DW WriteAudioDescrType
        DB DTagSkip    +1, ,0
    DW WriteAudio2CtlDescrSType
        DB DTagSkip    +1, 0
    DW DoDescrUnitID
        DB DTagSkip    +1, 0
    DW DoDescrSourceID
        DB DTagSkip    +1, 0
    DW WriteByteMin
        DB DTagColon   +1, 'Clock In Entity ID',0
    DW WriteByteMin
        DB DTagColon   +1, 'Clock Out Entity ID',0
    DW DoDescrUnitString
        DB DTagSkip    +1, 0
    DW 0 ;End of Descriptor Entry

    DB 0 ;End of Table!!


  ;============================================================================
  ;Audio Stream Interface Class-Specific Descriptors
  ;  (Interface Class 01h, Interface SubClass 02h)
  ;  Audio Spec Version 2 Specific
  ;============================================================================

  DescrMsgTblAudio2Str:


;  ;----------------------------------------------------------------------------
;  ;Class-Specific Audio v2 Streaming (AS) Interface Descriptor SubTypes
;  ;----------------------------------------------------------------------------
;    A2IntfDescSTypeASUndef   EQU 00h ;Undefined
;    A2IntfDescSTypeASGeneral EQU 01h ;General
;    A2IntfDescSTypeASFmtType EQU 02h ;Format Type
;    A2IntfDescSTypeASEncoder EQU 03h ;Encoder
;    A2IntfDescSTypeASDecoder EQU 04h ;Decoder
;

;;==============================================================================
;;Audio Version 2 Streaming Descriptor Structures
;;==============================================================================
;
;  ;----------------------------------------------------------------------------
;  ;Class-Specific Audio v2 Streaming Interface Header Descriptor
;  ;----------------------------------------------------------------------------
;  Audio2StrIntfStruc STRUC            ;Struc for Class-Spec Audio v2 Streaming Intf Descr
;    A2SILength          DB        16  ;Size of Descriptor in bytes
;    A2SIDescrType       DB DescrTypeAudioInterface
;    A2SIDescrSubType    DB A2IntfDescSTypeASGeneral
;    A2SITermLink        DB         ?  ;Terminal ID to which EndPoint is connected
;    A2SIControls        DB         ?  ;Controls (organized in bit-pairs)
;                                      ;Setting use A2CtlNoSupt, etc.
;                                      ;  (No Support, Read-Only, Illegal, Full Support)
;      A2SICtlActivAlt  EQU        03h ;Active Alternate Setting Control
;      A2SICtlValidAlt  EQU        0Ch ;Valid Alternate Setting Control
;      ;Bits 4-7 = Reserved (0)
;    A2SIFormatType      DB         ?  ;Format Type
;      ;AudFmtUndef, AudFmtType1, etc.)
;    A2SIFormats         DD         ?  ;Supported Data Formats (bitmap)
;     ;-------------------------------------------------------------------------
;     ;Type 1:
;     ;-------------------------------------------------------------------------
;      A2FT1PCM         EQU 0000_0001h ;Pulse Code Modulation
;      A2FT1PCM8        EQU 0000_0002h ;8-bit Pulse Code Modulation
;      A2FT1IEEEFloat   EQU 0000_0004h ;IEEE Floating Point
;      A2FT1ALaw        EQU 0000_0008h ;A-Law (Non-US Telephony)
;      A2FT1ULaw        EQU 0000_0010h ;æ-Law (US Telephony)
;      ;Bits 5-30 = Reserved (0)
;      A2FT1RawData     EQU 8000_0000h ;Raw Data
;     ;-------------------------------------------------------------------------
;     ;Type 2:
;     ;-------------------------------------------------------------------------
;      A2FT2MPEG        EQU 0000_0001h ;MPEG
;      A2FT2AC3         EQU 0000_0002h ;AC-3
;      A2FT2WMA         EQU 0000_0004h ;WMA
;      A2FT2DTS         EQU 0000_0008h ;DTS
;      ;Bits 4-30 = Reserved (0)
;      A2FT2RawData     EQU 8000_0000h ;Raw Data
;     ;-------------------------------------------------------------------------
;     ;Type 3:
;     ;-------------------------------------------------------------------------
;      A2FT3IECAC3      EQU 0000_0001h ;IEC61937 AC-3
;      A2FT3IECMPEG1    EQU 0000_0002h ;IEC61937 MPEG Layer 1
;      A2FT3IECMPEG2    EQU 0000_0004h ;IEC61937 MPEG Layer 2/3 or MPEG 2 - No Ext
;      A2FT3IECMPEG2Ext EQU 0000_0008h ;IEC61937 MPEG Layer 2 Ext
;      A2FT3IECMPEG2AAC EQU 0000_0010h ;IEC61937 MPEG Layer 2 AAC ATDS
;      A2FT3IECMPEG21LS EQU 0000_0020h ;IEC61937 MPEG Layer 2 Layer 1 LS
;      A2FT3IECMPEG22LS EQU 0000_0040h ;IEC61937 MPEG Layer 2 Layer 2/3 LS
;      A2FT3IECDTS1     EQU 0000_0080h ;IEC61937 DTS-I
;      A2FT3IECDTS2     EQU 0000_0100h ;IEC61937 DTS-II
;      A2FT3IECDTS3     EQU 0000_0200h ;IEC61937 DTS-III
;      A2FT3IECATRAC    EQU 0000_0400h ;IEC61937 ATRAC
;      A2FT3IECATRAC2   EQU 0000_0800h ;IEC61937 ATRAC2/3
;      A2FT3WMA3        EQU 0000_1000h ;Type III WMA
;      ;Bits 13-31 = Reserved (0)
;     ;-------------------------------------------------------------------------
;     ;Type 4:
;     ;-------------------------------------------------------------------------
;      A2FT4PCM         EQU 0000_0001h ;Pulse Code Modulation
;      A2FT4PCM8        EQU 0000_0002h ;8-bit Pulse Code Modulation
;      A2FT4IEEEFloat   EQU 0000_0004h ;IEEE Floating Point
;      A2FT4ALaw        EQU 0000_0008h ;A-Law (Non-US Telephony)
;      A2FT4ULaw        EQU 0000_0010h ;æ-Law (US Telephony)
;      A2FT4MPEG        EQU 0000_0020h ;MPEG
;      A2FT4AC3         EQU 0000_0040h ;AC-3
;      A2FT4WMA         EQU 0000_0080h ;WMA
;      A2FT4IECAC3      EQU 0000_0100h ;IEC61937 AC-3
;      A2FT4IECMPEG1    EQU 0000_0200h ;IEC61937 MPEG Layer 1
;      A2FT4IECMPEG2    EQU 0000_0400h ;IEC61937 MPEG Layer 2/3 or MPEG 2 - No Ext
;      A2FT4IECMPEG2Ext EQU 0000_0800h ;IEC61937 MPEG Layer 2 Ext
;      A2FT4IECMPEG2AAC EQU 0000_1000h ;IEC61937 MPEG Layer 2 AAC ATDS
;      A2FT4IECMPEG21LS EQU 0000_2000h ;IEC61937 MPEG Layer 2 Layer 1 LS
;      A2FT4IECMPEG22LS EQU 0000_4000h ;IEC61937 MPEG Layer 2 Layer 2/3 LS
;      A2FT4IECDTS1     EQU 0000_8000h ;IEC61937 DTS-I
;      A2FT4IECDTS2     EQU 0001_0000h ;IEC61937 DTS-II
;      A2FT4IECDTS3     EQU 0002_0000h ;IEC61937 DTS-III
;      A2FT4IECATRAC    EQU 0004_0000h ;IEC61937 ATRAC
;      A2FT4IECATRAC2   EQU 0008_0000h ;IEC61937 ATRAC2/3
;      A2FT4WMA3        EQU 0010_0000h ;Type III WMA
;      A2FT4IECPCM      EQU 0020_0000h ;IEC60958 PCM
;      ;Bits 22-31 = Reserved (0)
;    A2SINumOutChans    DB          ?  ;Number of Physical Channels in Cluster
;    A2SISpatial        DD          ?  ;Spatial Locations of Physical Channels (Bitmap)
;    A2SIChanStr        DB          ?  ;String Index Describing First Physical Channel
;   ENDS
;   ;May be followed by Format-specific Data Descriptor
;
;  ;----------------------------------------------------------------------------
;  ;Audio v2 Audio Streaming Encoder Descriptor
;  ;----------------------------------------------------------------------------
;  Audio2EncoderStruc STRUC            ;Structure for an Audio v2 Encoder Descr
;    A2EnLength          DB        18  ;Size of Descriptor in bytes
;    A2EnDescrType       DB DescrTypeAudioInterface
;    A2EnDescrSubType    DB A2IntfDescSTypeASEncoder
;    A2EnEncoderID       DB         ?  ;Unique ID Identifying this Encoder
;    A2EnEncoderType     DB         ?  ;Encoder Type
;      A2EnTypeUndef    EQU        00h ;Undefined
;      A2EnTypeOther    EQU        01h ;Other
;      A2EnTypeMPEG     EQU        02h ;MPEG
;      A2EnTypeAC3      EQU        03h ;AC-3
;      A2EnTypeWMA      EQU        04h ;WMA
;      A2EnTypeDTS      EQU        05h ;DTS
;    A2EnControls        DD         ?  ;Controls (organized in bit-pairs)
;                                      ;Setting use A2CtlNoSupt, etc.
;                                      ;  (No Supt, Read-Only, Illegal, Full Supt)
;      A2EnCtlBitRate   EQU 0000_0003h ;Bit Rate Control
;      A2EnCtlQuality   EQU 0000_000Ch ;Quality Control
;      A2EnCtlVBR       EQU 0000_0030h ;VBR (Variable Bit Rate?) Control
;      A2EnCtlType      EQU 0000_00C0h ;Type Control
;      A2EnCtlUnderflow EQU 0000_0300h ;Underflow Control
;      A2EnCtlOverflow  EQU 0000_0C00h ;Overflow Control
;      A2EnCtlError     EQU 0000_3000h ;Encoder Error Control
;      A2EnCtlParam1    EQU 0000_C000h ;Parameter 1 Control
;      A2EnCtlParam2    EQU 0003_0000h ;Parameter 2 Control
;      A2EnCtlParam3    EQU 000C_0000h ;Parameter 3 Control
;      A2EnCtlParam4    EQU 0030_0000h ;Parameter 4 Control
;      A2EnCtlParam5    EQU 00C0_0000h ;Parameter 5 Control
;      A2EnCtlParam6    EQU 0300_0000h ;Parameter 6 Control
;      A2EnCtlParam7    EQU 0C00_0000h ;Parameter 7 Control
;      A2EnCtlParam8    EQU 3000_0000h ;Parameter 8 Control
;      ;Bits 30-31 = Reserved (0)
;    A2EnParam1Str       DB         ?  ;String Index Describing Parameter 1
;    A2EnParam2Str       DB         ?  ;String Index Describing Parameter 2
;    A2EnParam3Str       DB         ?  ;String Index Describing Parameter 3
;    A2EnParam4Str       DB         ?  ;String Index Describing Parameter 4
;    A2EnParam5Str       DB         ?  ;String Index Describing Parameter 5
;    A2EnParam6Str       DB         ?  ;String Index Describing Parameter 6
;    A2EnParam7Str       DB         ?  ;String Index Describing Parameter 7
;    A2EnParam8Str       DB         ?  ;String Index Describing Parameter 8
;    A2EnEncoderStr      DB         ?  ;String Index Describing Encoder
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Class-Specific Audio v2 Decoder Types
;  ;----------------------------------------------------------------------------
;    A2DecTypeUndef EQU 00h ;Undefined
;    A2DecTypeOther EQU 01h ;Other
;    A2DecTypeMPEG  EQU 01h ;MPEG
;    A2DecTypeAC3   EQU 01h ;AC-3
;    A2DecTypeWMA   EQU 01h ;WMA
;    A2DecTypeDTS   EQU 01h ;DTS
;

;  ;----------------------------------------------------------------------------
;  ;Audio v2 Audio Streaming MPEG Decoder Descriptor
;  ;----------------------------------------------------------------------------
;  Audio2MPEGDecoderStruc STRUC      ;Struc for Audio v2 MPEG Decoder Descr
;    A2MDLength             DB   10  ;Size of Descriptor in bytes
;    A2MDDescrType          DB DescrTypeAudioInterface
;    A2MDDescrSubType       DB A2IntfDescSTypeASDecoder
;    A2MDDecoderID          DB    ?  ;Unique ID Identifying this Decoder
;    A2MDDecoderType        DB A2DecTypeMPEG
;    A2MDCapabilities       DW    ?  ;Decoder Capabilites BitMap
;      A2MDCapLayer1       EQU 0001h ;MPEG Layer 1 Support
;      A2MDCapLayer2       EQU 0002h ;MPEG Layer 2 Support
;      A2MDCapLayer3       EQU 0004h ;MPEG Layer 3 Support
;      A2MDCap1Only        EQU 0008h ;MPEG-1 Only
;      A2MDCap1DualChan    EQU 0010h ;MPEG-1 Dual-Channer
;      A2MDCapSecStereo    EQU 0020h ;MPEG-2 Second Stereo
;      A2MDCap271Augment   EQU 0040h ;MPEG-2 7.1 Channel Augmentation
;      A2MDCapAMP          EQU 0080h ;Adaptive Multi-Channel Prediction
;      A2MDCap2MLingual    EQU 0300h ;MPEG-2 Multilingual Support
;        A2MDCapMLNoSupt   EQU 0000h ;Not Supported
;        A2MDCapMLFs       EQU 0100h ;Supported at Fs (Full Speed??  Frame Speed??)
;        A2MDCapMLRsvd     EQU 0200h ;Reserved
;        A2MDCapMLBoth     EQU 0300h ;Supported at Fs and «Fs
;      A2MDCapHalfFs       EQU 0400h ;Support for «Fs
;      ;Bits 11-15 = Reserved (0)
;    A2MDFeatures           DB    ?
;      ;Bits 0-3 = Reserved (0)
;      A2MDFtrDynRange     EQU   30h ;Internal Dynamic Range Control
;        A2MDFtrDRNoSupt   EQU   00h ;Not Supported
;        A2MDFtrDRNoScale  EQU   10h ;Supported but not Scalable
;        A2MDFtrDRCommon   EQU   20h ;Scalable w/ Common Boost & Cut Scaling Value
;        A2MDFtrDRSeparate EQU   30h ;Scalable w/ Separate Boost & Cut Scaling Value
;      ;Bits 6-7 = Reserved (0)
;    A2MDControls           DB    ?  ;Controls (organized in bit-pairs)
;                                    ;Setting use A2CtlNoSupt, etc.
;                                    ;  (No Supt, Read-Only, Illegal, Full Supt)
;      A2MDCtlUnderflow    EQU   03h ;Underflow Control
;      A2MDCtlOverflow     EQU   0Ch ;Overflow Control
;      A2MDCtlError        EQU   30h ;Decoder Error Control
;      ;Bits 6-7 = Reserved (0)
;    A2MDDecoderStr         DB    ?  ;String Index Describing Encoder
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Audio v2 Audio Streaming AC-3 Decoder Descriptor
;  ;----------------------------------------------------------------------------
;  Audio2AC3DecoderStruc STRUC       ;Struc for Audio v2 AC-3 Decoder Descr
;    A2ADLength             DB   12  ;Size of Descriptor in bytes
;    A2ADDescrType          DB DescrTypeAudioInterface
;    A2ADDescrSubType       DB A2IntfDescSTypeASDecoder
;    A2ADDecoderID          DB    ?  ;Unique ID Identifying this Decoder
;    A2ADDecoderType        DB A2DecTypeAC3
;    A2ADBSIDModeSupt       DD    ?  ;BSID Modes Supported (Bit 0 = Mode 0, etc.)
;                                    ; Bits 0-8 MUST be set
;    A2ADFeatures           DB    ?  ;Supported Features
;      A2ADFtrRFMode       EQU   01h ;RF Mode
;      A2ADFtrLineMode     EQU   02h ;Line Mode
;      A2ADFtrCustom0      EQU   04h ;Custom0 Mode
;      A2ADFtrCustom1      EQU   08h ;Custom1 Mode
;      A2ADFtrDynRange     EQU   30h ;Internal Dynamic Range Control
;        A2ADFtrDRNoSupt   EQU   00h ;Not Supported
;        A2ADFtrDRNoScale  EQU   10h ;Supported but not Scalable
;        A2ADFtrDRCommon   EQU   20h ;Scalable w/ Common Boost & Cut Scaling Value
;        A2ADFtrDRSeparate EQU   30h ;Scalable w/ Separate Boost & Cut Scaling Value
;      ;Bits 6-7 = Reserved (0)
;    A2ADControls           DB    ?  ;Controls (organized in bit-pairs)
;                                    ;Setting use A2CtlNoSupt, etc.
;                                    ;  (No Supt, Read-Only, Illegal, Full Supt)
;      A2ADCtlUnderflow    EQU   03h ;Underflow Control
;      A2ADCtlOverflow     EQU   0Ch ;Overflow Control
;      A2ADCtlError        EQU   30h ;Decoder Error Control
;      ;Bits 6-7 = Reserved (0)
;    A2ADDecoderStr         DB    ?  ;String Index Describing Encoder
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Audio v2 Audio Streaming WMA Decoder Descriptor
;  ;----------------------------------------------------------------------------
;  Audio2WMADecoderStruc STRUC    ;Struc for Audio v2 WMA Decoder Descr
;    A2WDLength          DB    9  ;Size of Descriptor in bytes
;    A2WDDescrType       DB DescrTypeAudioInterface
;    A2WDDescrSubType    DB A2IntfDescSTypeASDecoder
;    A2WDDecoderID       DB    ?  ;Unique ID Identifying this Decoder
;    A2WDDecoderType     DB A2DecTypeWMA
;    A2WDWMAProfile      DW    ?  ;WMA Supported Features Profile
;      A2WDPrfL1        EQU 0001h ;WMA Profile 1, L1
;      A2WDPrfL2        EQU 0002h ;WMA Profile 2, L2
;      A2WDPrfL3        EQU 0004h ;WMA Profile 3, L3
;      A2WDPrfLOther    EQU 0008h ;WMA Profile Other, L
;      A2WDPrfS1        EQU 0010h ;WMA Speech 1, S1
;      A2WDPrfS2        EQU 0020h ;WMA Speech 2, S2
;      A2WDPrfProM1     EQU 0040h ;WMAPro Profile 1, M1
;      A2WDPrfProM2     EQU 0080h ;WMAPro Profile 2, M2
;      A2WDPrfProM3     EQU 0100h ;WMAPro Profile 3, M3
;      A2WDPrfProMOther EQU 0200h ;WMAPro Profile Other, M
;      A2WDPrfLossless  EQU 0400h ;Lossless Decoding is Supported
;      ;Bits 11-15 = Reserved (0)
;    A2WDControls        DB    ?  ;Controls (organized in bit-pairs)
;                                 ;Setting use A2CtlNoSupt, etc.
;                                 ;  (No Supt, Read-Only, Illegal, Full Supt)
;      A2WDCtlUnderflow EQU   03h ;Underflow Control
;      A2WDCtlOverflow  EQU   0Ch ;Overflow Control
;      A2WDCtlError     EQU   30h ;Decoder Error Control
;      ;Bits 6-7 = Reserved (0)
;    A2WDDecoderStr      DB    ?  ;String Index Describing Encoder
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Audio v2 Audio Streaming DTS Decoder Descriptor
;  ;----------------------------------------------------------------------------
;  Audio2DTSDecoderStruc STRUC     ;Struc for Audio v2 DTS Decoder Descr
;    A2DDLength            DB   8  ;Size of Descriptor in bytes
;    A2DDDescrType         DB DescrTypeAudioInterface
;    A2DDDescrSubType      DB A2IntfDescSTypeASDecoder
;    A2DDDecoderID         DB   ?  ;Unique ID Identifying this Decoder
;    A2DDDecoderType       DB A2DecTypeDTS
;    A2DDCapabilities      DB   ?  ;Decoder Capabilities Supported
;      A2DDCapCore        EQU  01h ;Core
;      A2DDCapLossless    EQU  02h ;Lossless
;      A2DDCapLBR         EQU  04h ;LBR
;      A2DDCapMultiStream EQU  08h ;Multiple Stream Mixing
;      A2DDCapDualDecode  EQU  10h ;Dual Decode
;      ;Bits 5-7 = Reserved (0)
;    A2DDControls          DB   ?  ;Controls (organized in bit-pairs)
;                                  ;Setting use A2CtlNoSupt, etc.
;                                  ;  (No Supt, Read-Only, Illegal, Full Supt)
;      A2DDCtlReserved    EQU  03h ;Reserved (must be set to 0)
;      A2DDCtlUnderflow   EQU  0Ch ;Underflow Control
;      A2DDCtlOverflow    EQU  30h ;Overflow Control
;      A2DDCtlError       EQU 0C0h ;Decoder Error Control
;    A2DDDecoderStr        DB   ?  ;String Index Describing Encoder
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Audio v2 Data Format Type I Descriptor Structure
;  ;----------------------------------------------------------------------------
;  A2FmtType1Struc STRUC   ;Struc for Audio v2 Data Format Type I Descriptor
;    A2FT1Length      DB 6 ;Size of Descriptor in bytes
;    A2FT1DescrType   DB DescrTypeAudioInterface
;    A2FT1DescrSType  DB A2IntfDescSTypeASFmtType
;    A2FT1FormatType  DB AudFmtType1
;    A2FT1SubSlotSize DB ? ;Number of Bytes in Audio SubSlot (1-4)
;    A2FT1Resolution  DB ? ;Number of effectively used bits per SubSlot
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Audio Format Types
;  ;----------------------------------------------------------------------------
;  AudFmtUndef  EQU 000h ;Undefined
;  AudFmtType1  EQU 001h ;Type I (Typically PCM)
;  AudFmtType2  EQU 002h ;Type II (non-PCM, Encoded Audio Frames)
;  AudFmtType3  EQU 003h ;Type III (Based on IEC61937)
;  ;From here down, they only apply to Audio v2
;  AudFmtType4  EQU 004h ;Type IV (Non-USB Endpoint, e.g. Analog Line In/Out)
;  AudFmtExt1   EQU 081h ;Extended Type I (Type I + Pkt Hdr & Synch Ctl Chan
;  AudFmtExt2   EQU 082h ;Extended Type II (Type II + Pkt Hdr)
;  AudFmtExt3   EQU 083h ;Extended Type III (Type III + Pkt Hdr)


;  ;----------------------------------------------------------------------------
;  ;Audio Version 2 Side Band Protocols (for Extended Data Format Descriptors)
;  ;----------------------------------------------------------------------------
;  A2SBProtocolUndef     EQU 00h ;Undefined
;  A2SBProtocolTimeStamp EQU 01h ;Presentation Time-Stamp Protocol

;  ;----------------------------------------------------------------------------
;  ;Audio v2 Data Format Extended Type I Descriptor Structure
;  ;  (Type I with a Packet Header)
;  ;----------------------------------------------------------------------------
;  A2FmtType1XStruc STRUC  ;Struc for Audio v2 Extended Type I Descr
;    A2FT1XCommon     DB (TYPE A2FmtType1Struc) DUP (?)
;      ;First part is same as basic Type I Structure, with following values:
;      ;  Length   = 9
;      ;  FormatType = AudFmtExt1
;    A2FT1XHeaderLen  DB ? ;Size of Packet Header (Bytes)
;    A2FT1XControlSz  DB ? ;Size of Control Channel Words (Bytes)
;    A2FT1XSBProtocol DB ? ;Side Band Protocol
;      ;A2SBProtocolUndef, etc.
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Audio v2 Data Format Type II Descriptor Structure
;  ;----------------------------------------------------------------------------
;  A2FmtType2Struc   STRUC   ;Struc for Audio v2 Data Format Type II Descriptor
;    A2FT2Length        DB 8 ;Size of Descriptor in bytes
;    A2FT2DescrType     DB DescrTypeAudioInterface
;    A2FT2DescrSType    DB A2IntfDescSTypeASFmtType
;    A2FT2FormatType    DB AudFmtType2
;    A2FT2MaxKbps       DW ? ;Maximum bit rate Interface cn handle (kbps)
;    A2FT2SlotsPerFrame DW ? ;Number of PCM Slots per Encoded Frame
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Audio v2 Data Format Extended Type II Descriptor Structure
;  ;  (Type II with a Packet Header)
;  ;----------------------------------------------------------------------------
;  A2FmtType2XStruc STRUC  ;Struc for Audio v2 Extended Type II Descr
;    A2FT2XCommon     DB (TYPE A2FmtType2Struc) DUP (?)
;      ;First part is same as basic Type II Structure, with following values:
;      ;  Length   = 10
;      ;  FormatType = AudFmtExt2
;    A2FT2XHeaderLen  DB ? ;Size of Packet Header (Bytes)
;    A2FT2XSBProtocol DB ? ;Side Band Protocol
;      ;A2SBProtocolUndef, etc.
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Audio v2 Data Format Type III Descriptor Structure
;  ;----------------------------------------------------------------------------
;  ;This structure is EXACTLY the same as the Type I Descriptor, with the
;  ;  following dedicated values in some of the fields:
;  ;  FormatType  = AudFmtType3
;  ;  SubSlotSize = 2
;
;  ;----------------------------------------------------------------------------
;  ;Audio v2 Data Format Extended Type III Descriptor Structure
;  ;  (Type III with a Packet Header)
;  ;----------------------------------------------------------------------------
;  A2FmtType3XStruc STRUC  ;Struc for Audio v2 Extended Type III Descr
;    A2FT3XCommon     DB (TYPE A2FmtType1Struc) DUP (?)
;      ;First part is same as basic Type II Structure, with following values:
;      ;  Length     = 8
;      ;  FormatType = AudFmtExt3
;      ;  SubSlotSize = 2
;    A2FT3XHeaderLen  DB ? ;Size of Packet Header (Bytes)
;    A2FT3XSBProtocol DB ? ;Side Band Protocol
;      ;A2SBProtocolUndef, etc.
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Audio v2 Data Format Type IV Descriptor Structure
;  ;----------------------------------------------------------------------------
;  A2FmtType4Struc STRUC  ;Struc for Audio v2 Data Format Type IV Descriptor
;    A2FT2Length     DB 4 ;Size of Descriptor in bytes
;    A2FT2DescrType  DB DescrTypeAudioInterface
;    A2FT2DescrSType DB A2IntfDescSTypeASFmtType
;    A2FT2FormatType DB AudFmtType4
;   ENDS
;
;  ;----------------------------------------------------------------------------
;  ;Audio Class-Specific EndPoint Descriptor SubTypes
;  ;----------------------------------------------------------------------------
;    AEndPtDescSTypeUndef   EQU 00h ;Undefined
;    AEndPtDescSTypeGeneral EQU 01h ;General
;
;  ;----------------------------------------------------------------------------
;  ;Audio v2 Class-Specific Isochronous EndPoint Descriptor Structure
;  ;----------------------------------------------------------------------------
;  A2EndPointStruc   STRUC     ;Struc for Audio v2 Isoch EndPt Descr
;    A2EPLength         DB  8  ;Size of Descriptor in bytes
;    A2EPDescrType      DB DescrTypeAudioEndPoint
;    A2EPDescrSType     DB AEndPtDescSTypeGeneral
;    A2EPAttribs        DB  ?  ;EndPoint Attributes Support Bitmap
;      ;Bits 0-6 = Reserved (0)
;      A2EPAtrMaxPkts  EQU 80h ;Max Packet Size Only
;    A2EPControls       DB  ?  ;Controls (organized in bit-pairs)
;                              ;Setting use A2CtlNoSupt, etc.
;                              ;  (No Support, Read-Only, Illegal, Full Support)
;      A2EPCtlPitch    EQU 03h ;Pitch Control
;      A2EPCtlOverrun  EQU 0Ch ;Data Overrun Control
;      A2EPCtlUnderrun EQU 30h ;Data Underrun Control
;      ;Bits 6-7 = Reserved (0)
;    A2EPLockDelayUnit  DB  ?  ;Units used for Lock Delay Field
;      ;AudLkDlyUnitUndef, etc.
;    A2EPLockDelay      DW  ?  ;Time it takes EndPoint to reliably lock to
;                              ;  internal clock recovery circuitry
;   ENDS



    DB 0 ;End of Table!!



;  ;----------------------------------------------------------------------------
;  ;Audio Class-Specific AS Interface Descriptor Subtypes
;  ;----------------------------------------------------------------------------
;  AudioASIntfSubTypeTbl:
;    DB TblFlagByte
;    DB 00h, 'Undefined',0
;    DB 01h, 'General',0
;    DB 02h, 'Format Type',0
;    DB 03h, 'Format-Specific',0
;    DB  0 , -1 ;End of Table

;  ;----------------------------------------------------------------------------
;  ;Audio Class-Specific EndPoint Descriptor Types
;  ;----------------------------------------------------------------------------
;  AudioEndPointSubTypeTbl:
;    DB TblFlagByte
;    DB 00h, 'Undefined',0
;    DB 01h, 'General',0
;    DB  0 , -1 ;End of Table


  ;============================================================================
  ;Communications Control Class-Specific Descriptors
  ;  (Device Class 02h, Interface Class 02h)
  ;============================================================================

  DescrMsgTblCommCtl:

    DB 0 ;End of Table!!

  ;============================================================================
  ;Communications Data Class-Specific Descriptors
  ;  (Device Class 02h, Interface Class 0Ah)
  ;============================================================================

  DescrMsgTblCommData:

    DB 0 ;End of Table!!

  ;============================================================================
  ;Human Interface Device Class-Specific Descriptors
  ;  (Interface Class 03h)
  ;============================================================================

  DescrMsgTblHID:
  ;------------------------------------------------------------------------------
  ;HID Descriptor
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeHID
    DW DoNothing
        DB DTagSizeOnly+1, 'HUMAN INTERFACE DEVICE DESCR',0
    DW WriteHIDDescrType
        DB DTagColon   +1, 'Descr Type',0
    DW DoVersion
        DB DTagColon   +2, 'HID Class Release',0
    DW DoHIDCountry
        DB DTagColon   +1, 'Country Code',0
    DW FinishHIDDescr
        DB DTagVariable+3, '# of Classes',0
    DW 0 ;End of Descriptor Entry

    DB 0 ;End of Table!!

  HIDTypeMsg: DB 'Class Descr Type',0
  HIDSizeMsg: DB 'Class Descr Size',0


  ;============================================================================
  ;Physical Interface Class-Specific Descriptors
  ;  (Interface Class 05h)
  ;============================================================================

  DescrMsgTblPhysical:

    DB 0 ;End of Table!!

  ;============================================================================
  ;Imaging Interface Class-Specific Descriptors
  ;  (Interface Class 06h)
  ;============================================================================

  DescrMsgTblImaging:

    DB 0 ;End of Table!!

  ;============================================================================
  ;Printer Interface Class-Specific Descriptors
  ;  (Interface Class 07h)
  ;============================================================================

  DescrMsgTblPrinter:

    DB 0 ;End of Table!!

  ;============================================================================
  ;Mass Storage Interface Class-Specific Descriptors
  ;  (Interface Class 08h)
  ;============================================================================

  DescrMsgTblMassStorage:

    DB 0 ;End of Table!!

  ;============================================================================
  ;Hub Class-Specific Descriptors
  ;  (Device/Interface Class 09h)
  ;============================================================================

  DescrMsgTblHub:
  ;------------------------------------------------------------------------------
  ;Hub Descriptor
  ;------------------------------------------------------------------------------
    DB 1, DescrTypeHub
    DW DoNothing
        DB DTagSizeOnly+1, 'HUB DESCRIPTOR',0
    DW WriteHubDescrType
        DB DTagColon   +1, 'Descr Type',0
    DW WriteByteMin
        DB DTagColon   +1, '# of Ports',0
    DW DoHubChars
        DB DTagColon   +2, 'Hub Attributes',0
    DW DoTimeOver2
        DB DTagColon   +1, 'Power Good Time/2',0
    DW DoPower
        DB DTagColon   +1, 'Current Draw',0
    DW FinishHubDescr
        DB DTagSkip+DTagEndOFDescr+0, 0
    DW 0 ;End of Descriptor Entry

    DB 0 ;End of Table!!

  ;============================================================================
  ;CCID Interface Class-Specific Descriptors
  ;  (Interface Class 0Bh)
  ;============================================================================

  DescrMsgTblCCID:

    DB 0 ;End of Table!!

  ;============================================================================
  ;Content Security Interface Class-Specific Descriptors
  ;  (Interface Class 0Dh)
  ;============================================================================

  DescrMsgTblContSec:

    DB 0 ;End of Table!!

  ;============================================================================
  ;Video Interface Class-Specific Descriptors
  ;  (Interface Class 0Eh)
  ;============================================================================

  DescrMsgTblVideo:

    DB 0 ;End of Table!!

  ;============================================================================
  ;Personal Healthcare Interface Class-Specific Descriptors
  ;  (Interface Class 0Fh)
  ;============================================================================

  DescrMsgTblPersHealth:

    DB 0 ;End of Table!!



;  ;------------------------------------------------------------------------------
;  ;IrDA Bridge Descriptor
;  ;  This is included for Reference, since we should never actually decipher
;  ;    an IrDA Descriptor with this program.
;  ;------------------------------------------------------------------------------
;     DB Length        ;Decriptor Length, >= 12
;     DB DescrTypeIrDA ;Descriptor Type (Class-Specific)
;     DW SpecRevision  ;IrDA Specification Revision (BCD)
;     DB MaxDataSize   ;Maximum Data Size
;                      ;Bit 0 =   64 bytes
;                      ;    1 =  128 bytes
;                      ;    2 =  256 bytes
;                      ;    3 =  512 bytes
;                      ;    4 = 1024 bytes
;                      ;    5 = 2048 bytes
;                      ;    6,7 = 0 (Reserved)
;     DB MaxWinSize    ;Maximum Window Size (unacknowledged frames)
;                      ;Bit 0 = 1 frame
;                      ;    1 = 2 rames
;                      ;   ...
;                      ;    6 = 7 frames
;                      ;    7 = 0 (Reserved)
;     DB MinTurnaround ;Minimum turnaround time (Transmit-to-Receive Transtion)
;                      ;Bit 0 = 10    ms
;                      ;    1 =  5    ms
;                      ;    2 =  1    ms
;                      ;    3 =  0.5  ms
;                      ;    4 =  0.1  ms
;                      ;    5 =  0.05 ms
;                      ;    6 =  0.01 ms
;                      ;    7 =  0    ms
;     DW BaudRate      ;Speeds supported by the Device
;                      ;Bit 0 =   2.4 kbps
;                      ;    1 =   9.6 kbps
;                      ;    2 =  19.2 kbps
;                      ;    3 =  38.4 kbps
;                      ;    4 =  57.6 kbps
;                      ;    5 = 115.2 kbps
;                      ;    6 =   576 kbps
;                      ;    7 = 1.152 Mbps
;                      ;    8 =     4 Mbps
;                      ;Bits 15-9 = 0 (Reserved)
;     DB ExtraBOFs     ;Extra BOFs needed to ensure reception at 115.2 Mbps
;                      ;If Device doesn't support speeds below 115.2, this is 0
;                      ;Bit 0 = 48 BOFs at 115.2 kbps
;                      ;    1 = 24 BOFs at 115.2 kbps
;                      ;    2 = 12 BOFs at 115.2 kbps
;                      ;    3 =  6 BOFs at 115.2 kbps
;                      ;    4 =  3 BOFs at 115.2 kbps
;                      ;    5 =  2 BOFs at 115.2 kbps
;                      ;    6 =  1 BOFs at 115.2 kbps
;                      ;    7 =  0 BOFs at 115.2 kbps
;     DB AutoRate      ;1 if Device will Auto-Adjust to any speed,
;                      ;0 if Device will only accept negotiated speed
;     DB MaxUnicast    ;Maximum number of Addresses in the UniCast List
;                      ;0 if Device cannot filter frames by their address


;  UnknownDescrMsg:
;    DB 'UNKNOWN DESCRIPTOR',0
  DescrLengthMsg:
    DB 'Descr Length',0
  DescrTypeMsg:
    DB 'Descr Type',0
  DescrSubTypeMsg:
    DB 'Descr SubType',0


  ;------------------------------------------------------------------------------
  ;Configuration Descriptor Attributes
  ;------------------------------------------------------------------------------
  ConfigAttrTbl:
    DB 80h, 0
    DB 00h, 'Illegal',0
    DB 80h, 'Valid',0
    DB      ' Historical Attribute 80h',0

    DB 40h, 0
    DB 00h, 'Bus',0
    DB 40h, 'Self',0
    DB      ' Powered',0

    DB 20h, 0
    DB 00h, 'No ',0
    DB 20h, 0
    DB      'Remote Wakeup',0

    DB 10h, 0
    DB 00h, 'Not ',0
    DB 10h, 0
    DB      'Battery Powered',0

    DB  0 ;End of Table

  ;------------------------------------------------------------------------------
  ;EndPoint Descriptor Attributes
  ;------------------------------------------------------------------------------
  EndPointAttrTbl:
    DB 03h, 0
    DB 00h, 'Control',0
    DB 01h, 'Isochronous',0
    DB 02h, 'Bulk',0
    DB 03h, 'Interrupt',0
    DB      0

    DB 0Ch, 0
    DB 00h, 'NonSynchronous',0
    DB 04h, 'Asynchronous',0
    DB 08h, 'Adaptive',0
    DB 0Ch, 'Synchronous',0
    DB      0

    DB 30h, 0
    DB 00h, 'Data',0
    DB 10h, 'Explicit_Feedback',0
    DB 20h, 'Implicit_Feedback',0
    DB 30h, 'Unknown_Feedback',0
    DB      0

    DB  0 ;End of Table


  ;------------------------------------------------------------------------------
  ;Hub Descriptor Attributes
  ;------------------------------------------------------------------------------
  HubCharTbl:
    DB 03h, 0
    DB 00h, 'Ganged',0
    DB 01h, 'Per-Port',0
    DB 02h, 'Ganged',0
    DB 03h, 'Per-Port',0
    DB      ' Power Switching',0

    DB 04h, 0
    DB 00h, 'Stand-Alone Hub',0
    DB 04h, 'Part of Compound Device',0
    DB      0

    DB 18h, 0
    DB 00h, 'Global',0
    DB 08h, 'Per-port',0
    DB 18h, 'No',0
    DB      ' Over-current Protection',0

    DB 60h, 'TT Think Time <= ',0
    DB 00h, '8',0
    DB 20h, '16',0
    DB 40h, '24',0
    DB 60h, '32',0
    DB      ' FS Bits',0

    DB 80h, 'LEDs ',0
    DB 00h, 'Hardware',0
    DB 80h, 'Software',0
    DB      ' Controlled',0

    DB  0 ;End of Table


  ;------------------------------------------------------------------------------
  ;On-the-Go Descriptor Attributes
  ;------------------------------------------------------------------------------
  OnTheGoAttrTbl:
    DB 01h, 'SRP (Session Request)  ',0
    DB 00h, 'Not ',0
    DB 01h, 0
    DB 'Supported',0

    DB 02h, 'HNP (Host Negotiation) ',0
    DB 00h, 'Not ',0
    DB 02h, 0
    DB 'Supported',0

    DB  0  ;End of Table


  ;------------------------------------------------------------------------------
  ;String needed to write a Hub Descriptor
  ;------------------------------------------------------------------------------
  HubRemovableMsg:
    DB 'Unremovable Dvc Ports',0
  HubPortPowerMsg:
    DB 'Port Power Control',0
  ObsoleteMsg:
    DB '(Obsolete)',0


;==============================================================================
;Data needed to write String Descriptors
;==============================================================================

  ;------------------------------------------------------------------------------
  ;String needed to write a Language ID 0 String Descriptor
  ;------------------------------------------------------------------------------
  LanguageIDMsg: DB 'Language ID',0
  TheStringMsg:  DB 'The String',0

  ;----------------------------------------------------------------------------
  ;USB Languages & Dialects
  ;Last Updated 2005/09/10
  ;----------------------------------------------------------------------------
  ;----------------------------------------------------------------------------
  ;Language IDs
  ;  A USB LANGID is a word, combining a Language ID in the lower 10 bits and
  ;    a dialect in the upper 6 bits.
  ;----------------------------------------------------------------------------
  LanguageTbl:
    DB TblFlagWord+TblFlagHasOffset
    DW 0000h
       DB 'Neutral/Default',0
       DW Language0Tbl
    DW 0001h
       DB 'Arabic',0
       DW ArabicTbl
    DW 0002h
       DB 'Bulgarian',0
       DW NoDialectTbl
    DW 0003h
       DB 'Catalan',0
       DW NoDialectTbl
    DW 0004h
       DB 'Chinese',0
       DW ChineseTbl
    DW 0005h
       DB 'Czech',0
       DW NoDialectTbl
    DW 0006h
       DB 'Danish',0
       DW NoDialectTbl
    DW 0007h
       DB 'German',0
       DW GermanTbl
    DW 0008h
       DB 'Greek',0
       DW NoDialectTbl
    DW 0009h
       DB 'English',0
       DW EnglishTbl
    DW 000Ah
       DB 'Spanish',0
       DW SpanishTbl
    DW 000Bh
       DB 'Finnish',0
       DW NoDialectTbl
    DW 000Ch
       DB 'French',0
       DW FrenchTbl
    DW 000Dh
       DB 'Hebrew',0
       DW NoDialectTbl
    DW 000Eh
       DB 'Hungarian',0
       DW NoDialectTbl
    DW 000Fh
       DB 'Icelandic',0
       DW NoDialectTbl
    DW 0010h
       DB 'Italian',0
       DW ItalianTbl
    DW 0011h
       DB 'Japanese',0
       DW NoDialectTbl
    DW 0012h
       DB 'Korean',0
       DW KoreanTbl
    DW 0013h
       DB 'Dutch',0
       DW DutchTbl
    DW 0014h
       DB 'Norwegian',0
       DW NorwegianTbl
    DW 0015h
       DB 'Polish',0
       DW NoDialectTbl
    DW 0016h
       DB 'Portugese',0
       DW PortugeseTbl
    DW 0017h
       DB 'forgotten',0
       DW NoDialectTbl
    DW 0018h
       DB 'Romanian',0
       DW NoDialectTbl
    DW 0019h
       DB 'Russian',0
       DW NoDialectTbl
    DW 001Ah
       DB 'Bosnian/Croatian/Serbian',0
       DW SerbianTbl
    DW 001Bh
       DB 'Slovak',0
       DW NoDialectTbl
    DW 001Ch
       DB 'Albanian',0
       DW NoDialectTbl
    DW 001Dh
       DB 'Swedish',0
       DW SwedishTbl
    DW 001Eh
       DB 'Thai',0
       DW NoDialectTbl
    DW 001Fh
       DB 'Turkish',0
       DW NoDialectTbl
    DW 0020h
       DB 'Urdu',0
       DW UrduTbl
    DW 0021h
       DB 'Indonesian',0
       DW NoDialectTbl
    DW 0022h
       DB 'Ukrainian',0
       DW NoDialectTbl
    DW 0023h
       DB 'Belarusian',0
       DW NoDialectTbl
    DW 0024h
       DB 'Slovenian',0
       DW NoDialectTbl
    DW 0025h
       DB 'Estonian',0
       DW NoDialectTbl
    DW 0026h
       DB 'Latvian',0
       DW NoDialectTbl
    DW 0027h
       DB 'Lithuanian',0
       DW LithuanianTbl
    DW 0028h
       DB 'forgotten',0
       DW NoDialectTbl
    DW 0029h
       DB 'Farsi',0
       DW NoDialectTbl
    DW 002Ah
       DB 'Vietnamese',0
       DW NoDialectTbl
    DW 002Bh
       DB 'Armenian',0
       DW NoDialectTbl
    DW 002Ch
       DB 'Azeri',0
       DW AzeriTbl
    DW 002Dh
       DB 'Basque',0
       DW NoDialectTbl
    DW 002Eh
       DB 'forgotten',0
       DW NoDialectTbl
    DW 002Fh
       DB 'Macedonian (FYROM)',0
       DW NoDialectTbl
    DW 0030h
       DB 'Sutu',0
       DW NoDialectTbl
    DW 0032h
       DB 'Setswana/Tswana (South Africa)',0
       DW NoDialectTbl
    DW 0034h
       DB 'isiXhosa/Xhosa (South Africa)',0
       DW NoDialectTbl
    DW 0035h
       DB 'isiZulu/Zulu (South Africa)',0
       DW NoDialectTbl
    DW 0036h
       DB 'Afrikaans',0
       DW NoDialectTbl
    DW 0037h
       DB 'Georgian',0
       DW NoDialectTbl
    DW 0038h
       DB 'Faeroese',0
       DW NoDialectTbl
    DW 0039h
       DB 'Hindi',0
       DW NoDialectTbl
    DW 003Ah
       DB 'Maltese (Malta)',0
       DW NoDialectTbl
    DW 003Bh
       DB 'Sami',0
       DW SamiTbl
    DW 003Eh
       DB 'Malay',0
       DW MalayTbl
    DW 003Fh
       DB 'Kazakh',0
       DW NoDialectTbl
    DW 0040h
       DB 'Kyrgyz',0
       DW NoDialectTbl
    DW 0041h
       DB 'Swahili (Kenya)',0
       DW NoDialectTbl
    DW 0043h
       DB 'Uzbek',0
       DW UzbekTbl
    DW 0044h
       DB 'Tatar (Tatarstan)',0
       DW NoDialectTbl
    DW 0045h
       DB 'Bengali (India)',0
       DW NoDialectTbl
    DW 0046h
       DB 'Punjabi',0
       DW NoDialectTbl
    DW 0047h
       DB 'Gujarati',0
       DW NoDialectTbl
    DW 0048h
       DB 'Oriya',0
       DW NoDialectTbl
    DW 0049h
       DB 'Tamil',0
       DW NoDialectTbl
    DW 004Ah
       DB 'Telugu',0
       DW NoDialectTbl
    DW 004Bh
       DB 'Kannada',0
       DW NoDialectTbl
    DW 004Ch
       DB 'Malayalam (India)',0
       DW NoDialectTbl
    DW 004Dh
       DB 'Assamese',0
       DW NoDialectTbl
    DW 004Eh
       DB 'Marathi',0
       DW NoDialectTbl
    DW 004Fh
       DB 'Sanskrit',0
       DW NoDialectTbl
    DW 0050h
       DB 'Mongolian',0
       DW NoDialectTbl
    DW 0052h
       DB 'Welsh (United Kingdom)',0
       DW NoDialectTbl
    DW 0055h
       DB 'Burmese',0
       DW NoDialectTbl
    DW 0056h
       DB 'Galician',0
       DW NoDialectTbl
    DW 0057h
       DB 'Konkani',0
       DW NoDialectTbl
    DW 0058h
       DB 'Manipuri',0
       DW NoDialectTbl
    DW 0059h
       DB 'Sindhi',0
       DW NoDialectTbl
    DW 005Ah
       DB 'Syriac',0
       DW NoDialectTbl
    DW 0060h
       DB 'Kashmiri',0
       DW KashmiriTbl
    DW 0061h
       DB 'Nepali',0
       DW NepaliTbl
    DW 0065h
       DB 'Divehi',0
       DW NoDialectTbl
    DW 006Bh
       DB 'Quechua',0
       DW QuechuaTbl
    DW 006Ch
       DB 'Sesotho sa Leboa/Northern Sotho (South Africa)',0
       DW NoDialectTbl
    DW 007Fh
       DB 'Locale Invariant',0
       DW LocaleInvariantTbl
    DW 0081h
       DB 'Maori (New Zealand)',0
       DW NoDialectTbl
    DW 00FFh
       DB 'USB HID Class',0
       DW HIDDialectTbl
    DW     0 ;End of
       DB -1 ;  Table

  ;----------------------------------------------------------------------------
  ;Dialects
  ;----------------------------------------------------------------------------
  Language0Tbl:
    DB TblFlagByte
    DB 00h, 'Language Neutral',0
    DB 01h, 'Processor/User Default Language',0
    DB 02h, 'System Default Language',0
    DB  0 , -1 ;End of Table

  NoDialectTbl:
    DB TblFlagByte
    DB 01h, 'No Dialects Defined',0
    DB  0 , -1 ;End of Table

  LocaleInvariantTbl:
    DB TblFlagByte
    DB 00h, 'No Dialects Allowed',0
    DB  0 , -1 ;End of Table

  ArabicTbl:
    DB TblFlagByte
    DB 01h, 'Saudi Arabia',0
    DB 02h, 'Iraq',0
    DB 03h, 'Egypt',0
    DB 04h, 'Libya',0
    DB 05h, 'Algeria',0
    DB 06h, 'Morocco',0
    DB 07h, 'Tunisia',0
    DB 08h, 'Oman',0
    DB 09h, 'Yemen',0
    DB 0Ah, 'Syria',0
    DB 0Bh, 'Jordan',0
    DB 0Ch, 'Lebanon',0
    DB 0Dh, 'Kuwait',0
    DB 0Eh, 'United Arab Emirates',0
    DB 0Fh, 'Bahrain',0
    DB 10h, 'Qatar',0
    DB  0 , -1 ;End of Table

  ChineseTbl:
    DB TblFlagByte
    DB 01h, 'Taiwan (Traditional)',0
    DB 02h, 'PRC (Simplified)',0
    DB 03h, 'Hongkong SAR, PRC',0
    DB 04h, 'Singapore',0
    DB 05h, 'Macao SAR',0
    DB  0 , -1 ;End of Table

  GermanTbl:
    DB TblFlagByte
    DB 01h, 'Germany (Standard)',0
    DB 02h, 'Switzerland',0
    DB 03h, 'Austria',0
    DB 04h, 'Luxembourg',0
    DB 05h, 'Liechtenstein',0
    DB  0 , -1 ;End of Table

  EnglishTbl:
    DB TblFlagByte
    DB 01h, 'United States',0
    DB 02h, 'United Kingdom',0
    DB 03h, 'Australia',0
    DB 04h, 'Canada',0
    DB 05h, 'New Zealand',0
    DB 06h, 'Ireland',0
    DB 07h, 'South Africa',0
    DB 08h, 'Jamaica',0
    DB 09h, 'Carribean',0
    DB 0Ah, 'Belize',0
    DB 0Bh, 'Trinidad',0
    DB 0Ch, 'Zimbabwe',0
    DB 0Dh, 'Philippines',0
    DB  0 , -1 ;End of Table

  SpanishTbl:
    DB TblFlagByte
    DB 01h, 'Castilian (Traditional)',0
    DB 02h, 'Mexican',0
    DB 03h, 'Spain (Modern)',0
    DB 04h, 'Guatemala',0
    DB 05h, 'Costa Rica',0
    DB 06h, 'Panama',0
    DB 07h, 'Dominican Republic',0
    DB 08h, 'Venezuela',0
    DB 09h, 'Colombia',0
    DB 0Ah, 'Peru',0
    DB 0Bh, 'Argentina',0
    DB 0Ch, 'Ecuador',0
    DB 0Dh, 'Chile',0
    DB 0Eh, 'Uruguay',0
    DB 0Fh, 'Paraguay',0
    DB 10h, 'Bolivia',0
    DB 11h, 'El Salvador',0
    DB 12h, 'Honduras',0
    DB 13h, 'Nicaragua',0
    DB 14h, 'Puerto Rico',0
    DB  0 , -1 ;End of Table

  FrenchTbl:
    DB TblFlagByte
    DB 01h, 'France (Standard)',0
    DB 02h, 'Belgium',0
    DB 03h, 'Canada',0
    DB 04h, 'Switzerland',0
    DB 05h, 'Luxembourg',0
    DB 06h, 'Monaco',0
    DB  0 , -1 ;End of Table

  ItalianTbl:
    DB TblFlagByte
    DB 01h, 'Italy (Standard)',0
    DB 02h, 'Switzerland',0
    DB  0 , -1 ;End of Table

  KoreanTbl:
    DB TblFlagByte
    DB 01h, 'Korea',0
    DB 02h, 'Johab',0
    DB  0 , -1 ;End of Table

  DutchTbl:
    DB TblFlagByte
    DB 01h, 'Netherlands',0
    DB 02h, 'Belgium',0
    DB  0 , -1 ;End of Table

  NorwegianTbl:
    DB TblFlagByte
    DB 01h, 'Bokmal',0
    DB 02h, 'Nynorsk',0
    DB  0 , -1 ;End of Table

  PortugeseTbl:
    DB TblFlagByte
    DB 01h, 'Brazil',0
    DB 02h, 'Portugal',0
    DB  0 , -1 ;End of Table

  SerbianTbl:
    DB TblFlagByte
    DB 01h, 'Croatian',0
    DB 02h, 'Serbian (Latin)',0
    DB 03h, 'Serbian (Cyrillic)',0
    DB 04h, 'Croatian (Bosnia & Herzegovina)',0
    DB 05h, 'Bosnian (Bosnia & Herzegovina)',0
    DB 06h, 'Serbian (Latin, Bosnia, & Herzegovina)',0
    DB 07h, 'Serbian (Cyrillic, Bosnia, & Herzegovina)',0
    DB  0 , -1 ;End of Table

  SwedishTbl:
    DB TblFlagByte
    DB 01h, 'Sweden',0
    DB 02h, 'Finland',0
    DB  0 , -1 ;End of Table

  UrduTbl:
    DB TblFlagByte
    DB 01h, 'Pakistan',0
    DB 02h, 'India',0
    DB  0 , -1 ;End of Table

  LithuanianTbl:
    DB TblFlagByte
    DB 01h, 'Lithuania',0
    DB 02h, 'Classic',0
    DB  0 , -1 ;End of Table

  AzeriTbl:
    DB TblFlagByte
    DB 01h, 'Latin',0
    DB 02h, 'Cyrillic',0
    DB  0 , -1 ;End of Table

  SamiTbl:
    DB TblFlagByte
    DB 01h, 'Norway Northern',0
    DB 02h, 'Sweden Northern',0
    DB 03h, 'Finland Northern',0
    DB 04h, 'Lule (Norway)',0
    DB 05h, 'Lule (Sweden)',0
    DB 06h, 'Norway Southern',0
    DB 07h, 'Sweden Southern',0
    DB 08h, 'Skolt (Finland)',0
    DB 09h, 'Inari (Finland)',0
    DB  0 , -1 ;End of Table

  MalayTbl:
    DB TblFlagByte
    DB 01h, 'Malaysia',0
    DB 02h, 'Brunei Darussalam',0
    DB  0 , -1 ;End of Table

  UzbekTbl:
    DB TblFlagByte
    DB 01h, 'Latin',0
    DB 02h, 'Cyrillic',0
    DB  0 , -1 ;End of Table

  KashmiriTbl:
    DB TblFlagByte
    DB 02h, 'India',0
    DB  0 , -1 ;End of Table

  NepaliTbl:
    DB TblFlagByte
    DB 02h, 'India',0
    DB  0 , -1 ;End of Table

  QuechuaTbl:
    DB TblFlagByte
    DB 01h, 'Bolivia',0
    DB 02h, 'Ecuador',0
    DB 03h, 'Peru',0
    DB  0 , -1 ;End of Table

  HIDDialectTbl:
    DB TblFlagByte
    DB 01h, 'HID Usage Data Descriptor',0
    DB 3Ch, 'HID Vendor-Defined #1',0
    DB 3Dh, 'HID Vendor-Defined #2',0
    DB 3Eh, 'HID Vendor-Defined #3',0
    DB 3Fh, 'HID Vendor-Defined #4',0
    DB  0 , -1 ;End of Table


;==============================================================================
;Device & Interface Classes, SubClasses, and Protocols
;Last updated 2002/07/31
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Device Classes
  ;----------------------------------------------------------------------------
  DeviceClassTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'Look at Interface',0
              DW NoneDvcIntfSubClsTbl
    DB  02h, 'Communications',0
              DW NoneDvcIntfSubClsTbl
    DB  09h, 'Hub',0
              DW HubDvcSubClsTbl
    DB  0Fh, 'Personal Healthcare',0
              DW NoneDvcIntfSubClsTbl
    DB 0DCh, 'Diagnostic Device',0
              DW DiagnosticDvcSubClsTbl
    DB 0E0h, 'Wireless Controller',0
              DW WirelessDvcSubClsTbl
    DB 0EFh, 'Miscellaneous Device',0
              DW MiscDvcSubClsTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfSubClsTbl
    DB   0 , -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;Device SubClasses
  ;----------------------------------------------------------------------------
  HubDvcSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW HubDvcProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  DiagnosticDvcSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB  01h, 'Reprogrammable Diagnostic Device',0
              DW DiagnosticDvcProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  WirelessDvcSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB  01h, 'RF Controller',0
              DW RFControllerDvcProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  MiscDvcSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB  02h, 'Common Class',0
              DW CommonClassDvcProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table


  ;----------------------------------------------------------------------------
  ;Device Protocols
  ;----------------------------------------------------------------------------
  HubDvcProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'Single Transaction Xlator',0
    DB  02h, 'Multiple Transaction Xlator',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  DiagnosticDvcProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'USB2 Compliance Device',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  RFControllerDvcProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'Bluetooth Programming Interface',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  CommonClassDvcProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'Interface Association',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;SubClasses Shared by both Devices and Interfaces
  ;----------------------------------------------------------------------------
  NoneDvcIntfSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  VendorDvcIntfSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;Protocols Shared by both Devices and Interfaces
  ;----------------------------------------------------------------------------
  NoneDvcIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  VendorDvcIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;Interface Classes
  ;----------------------------------------------------------------------------
  InterfaceClassTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfSubClsTbl
    DB  01h, 'Audio',0
              DW AudioIntfSubClsTbl
    DB  02h, 'Communications Control',0
              DW CommunicationIntfSubClsTbl
    DB  03h, 'HID (Human Interface Device)',0
              DW HIDIntfSubClsTbl
    DB  05h, 'Physical',0
              DW NoneDvcIntfSubClsTbl
    DB  06h, 'Imaging',0
              DW ImageIntfSubClsTbl
    DB  07h, 'Printer',0
              DW PrinterIntfSubClsTbl
    DB  08h, 'Mass Storage',0
              DW MassStorageIntfSubClsTbl
    DB  09h, 'Hub',0
              DW HubIntfSubClsTbl
    DB  0Ah, 'Communications Data',0
              DW CommDataIntfSubClsTbl
    DB  0Bh, 'CCID (Chip Card Interface Device)',0
              DW NoneDvcIntfSubClsTbl
    DB  0Dh, 'Content Security',0
              DW NoneDvcIntfSubClsTbl
    DB  0Eh, 'Video',0
              DW VideoIntfSubClsTbl
    DB  0Fh, 'Personal Healthcare',0
              DW NoneDvcIntfSubClsTbl
    DB 0DCh, 'Diagnostic Device',0
              DW DiagnosticIntfSubClsTbl
    DB 0E0h, 'Wireless Controller',0
              DW WirelessIntfSubClsTbl
    DB 0EFh, 'Miscellaneous Devices',0
              DW MiscDvcIntfSubClsTbl
    DB 0FEh, 'Application-specific',0
              DW ApplicationIntfSubClsTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfSubClsTbl
    DB   0 , -1 ;End of Table

  ;----------------------------------------------------------------------------
  ;Interface SubClasses
  ;----------------------------------------------------------------------------
  AudioIntfSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB  01h, 'Audio Control',0
              DW AudioIntfProTbl
    DB  02h, 'Audio Streaming',0
              DW AudioIntfProTbl
    DB  03h, 'MIDI Streaming',0
              DW NoneDvcIntfProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  CommunicationIntfSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB  01h, 'Direct Line Control',0
              DW NoneDvcIntfProTbl
    DB  02h, 'Abstract Control (modem)',0
              DW ModemIntfProTbl
    DB  03h, 'Telephone Control',0
              DW NoneDvcIntfProTbl
    DB  04h, 'Multi-Channel Control',0
              DW NoneDvcIntfProTbl
    DB  05h, 'ISDN CAPI Control',0
              DW NoneDvcIntfProTbl
    DB  06h, 'Ethernet Networking Control',0
              DW NoneDvcIntfProTbl
    DB  07h, 'ATM Networking Control',0
              DW NoneDvcIntfProTbl
    DB  08h, 'Wireless Handset Control',0
              DW NoneDvcIntfProTbl
    DB  09h, 'Device Management',0
              DW NoneDvcIntfProTbl
    DB  0Ah, 'Mobile Direct Line Control',0
              DW NoneDvcIntfProTbl
    DB  0Bh, 'OBEX Control',0
              DW NoneDvcIntfProTbl
    DB  0Ch, 'Ethernet Emulation',0
              DW EthernetEmuIntfProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  HIDIntfSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB  01h, 'Boot',0
              DW HIDBootIntfProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  ImageIntfSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB  01h, 'Still Image Capture',0
              DW StillImageIntfProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  PrinterIntfSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB  01h, 'Printer',0
              DW PrinterIntfProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  MassStorageIntfSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB  01h, 'Reduced Block Commands (RBC)',0
              DW MassStorageIntfProTbl
    DB  02h, 'SFF-8020i, MMC-2 (ATAPI) (typically CD/DVD)',0
              DW MassStorageIntfProTbl
    DB  03h, 'QIC-157 (typically Tape)',0
              DW MassStorageIntfProTbl
    DB  04h, 'Floppy Drive (USB Floppy Interface)',0
              DW MassStorageIntfProTbl
    DB  05h, 'SFF-8070i (typically Floppy Drive)',0
              DW MassStorageIntfProTbl
    DB  06h, 'SCSI Transparent',0
              DW MassStorageIntfProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  HubIntfSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW HubIntfProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  CommDataIntfSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW CommDataIntfProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  VideoIntfSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB  01h, 'Video Control',0
              DW NoneDvcIntfProTbl
    DB  02h, 'Video Streaming',0
              DW NoneDvcIntfProTbl
    DB  03h, 'Video Interface Collection',0
              DW NoneDvcIntfProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  DiagnosticIntfSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB  01h, 'Reprogrammable Diagnostic Device',0
              DW DiagnosticIntfProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  WirelessIntfSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB  01h, 'Radio Frequency Controller',0
              DW RFControllerIntfProTbl
    DB  02h, 'Wireless USB Wire Adapter',0
              DW WirelessUSBIntfProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  MiscDvcIntfSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB  01h, 'Synchronization?',0
              DW MiscSyncIntfProTbl
    DB  02h, 'Common Class',0
              DW MiscCommonIntfProTbl
    DB  03h, 'Cable?',0
              DW MiscCableIntfProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table


  ApplicationIntfSubClsTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB  01h, 'Device Firmware Update',0
              DW NoneDvcIntfProTbl
    DB  02h, 'IrDA (InfraRed) Bridge',0
              DW NoneDvcIntfProTbl
    DB  03h, 'Test and Measurement',0
              DW TestMeasureIntfProTbl
    DB 0FFh, 'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table


  ;----------------------------------------------------------------------------
  ;Interface Protocols
  ;----------------------------------------------------------------------------
  AudioIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'Audio Spec v1.0',0
    DB  20h, 'Audio Spec v2.0',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  ModemIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'AT commands V.25ter',0
    DB  02h, 'AT commands PCCA101',0
    DB  03h, 'AT commands PCCA101+wakeup',0
    DB  04h, 'AT commands GSM',0
    DB  05h, 'AT commands 3G',0
    DB  06h, 'AT commands CDMA',0
    DB 0FEh, 'Defined by Command Set Descriptor',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  EthernetEmuIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  07h, 'Ethernet Emulation (EEM)',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  HIDBootIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'Keyboard',0
    DB  02h, 'Mouse',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  StillImageIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'Picture Transfer Protocol (PIMA 15470)',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  PrinterIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'Uni-Directional',0
    DB  02h, 'Bi-Directional',0
    DB  03h, 'IEEE 1284.4 compatible Bi-Directional',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  MassStorageIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'Control/Bulk/Interrupt',0
    DB  01h, 'Control/Bulk',0
    DB  50h, 'Bulk-only (Zip)',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  HubIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'Single Transaction Xlator',0
    DB  02h, 'Multiple Transaction Xlator',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  CommDataIntfProTbl:
    DB  TblFlagByte+TblFlagHasOffset
    DB  00h, 'None',0
              DW NoneDvcIntfProTbl
    DB  30h, 'I.430 ISDN BRI',0
              DW NoneDvcIntfProTbl
    DB  31h, 'HDLC',0
              DW NoneDvcIntfProTbl
    DB  32h, 'Transparent',0
              DW NoneDvcIntfProTbl
    DB  50h, 'Q.921M (Management Protocol for Q.921)',0
              DW NoneDvcIntfProTbl
    DB  51h, 'Q.921 (Data Link Protocol for Q.931)',0
              DW NoneDvcIntfProTbl
    DB  52h, 'Q.921TM (TEI Multiplexor for Q.921)',0
              DW NoneDvcIntfProTbl
    DB  90h, 'V.42bis (Data Compression Procedures)',0
              DW NoneDvcIntfProTbl
    DB  91h, 'Q.931/EuroISDN',0
              DW NoneDvcIntfProTbl
    DB  92h, 'V.120 (V.24 rate adaptation to ISDN)',0
              DW NoneDvcIntfProTbl
    DB  93h, 'CAPI 2.0',0
              DW NoneDvcIntfProTbl
    DB 0FDh,  'Host-based Driver',0
              DW NoneDvcIntfProTbl
    DB 0FEh,  'CDC PUF (Protocol Unit Functional)',0
              DW NoneDvcIntfProTbl
    DB 0FFh,  'Vendor-specific',0
              DW VendorDvcIntfProTbl
    DB   0 , -1 ;End of Table

  DiagnosticIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'USB2 Compliance Device',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  RFControllerIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'Bluetooth Programming Interface',0
    DB  02h, 'Ultra Wideband Radio Control',0
    DB  03h, 'RNDIS',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  WirelessUSBIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'Host Wire Adapter Control/Data Streaming',0
    DB  02h, 'Device Wire Adapter Control/Data Streaming',0
    DB  03h, 'Device Wire Adapter Isochronous Streaming',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  MiscSyncIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'Microsoft ActiveSync',0
    DB  02h, 'Palm Sync',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  MiscCommonIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'Interface Association',0
    DB  02h, 'Wire Adapter Multifunction Peripheral',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  MiscCableIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'Cable Based Association',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table

  TestMeasureIntfProTbl:
    DB  TblFlagByte
    DB  00h, 'None',0
    DB  01h, 'TMC',0
    DB  02h, 'USB488',0
    DB 0FFh, 'Vendor-specific',0
    DB   0 , -1 ;End of Table


  ;----------------------------------------------------------------------------
  ;First six entries are Device Class, Device SubClass, Device Protocol,
  ;  Interface Class, Interface SubClass, Interface Protocol,
  ;  followed by a fixed-length (14-bytes) Description.
  ;A value of -1 (0FFh) in an entry indicates don't care (match anything)
  ;
  ;NOTE: References I've seen regarding these (which will also affect
  ;        the Class/SubClass/Protocol tables above) tend to confuse
  ;        Interfaces and Devices, and cross-pollenate between them.
  ;      Therefore, i am not sure these are 100% correct.  It seems that
  ;        Device classifications, as a rule, don't mean that much (most
  ;        of the useful information is in the Interface classifications).
  ;----------------------------------------------------------------------------
  DvcDescriptionTbl:


;Add -1's to Devices!!!!


  ;Audio
    DB 0FFh, 0FFh, 0FFh,  01h,  01h,  00h, 'Audio Ctl v1  ',0
    DB 0FFh, 0FFh, 0FFh,  01h,  01h,  20h, 'Audio Ctl v2  ',0
    DB 0FFh, 0FFh, 0FFh,  01h,  02h,  00h, 'Audio Strm v1 ',0
    DB 0FFh, 0FFh, 0FFh,  01h,  02h,  20h, 'Audio Strm v2 ',0
    DB 0FFh, 0FFh, 0FFh,  01h,  03h, 0FFh, 'MIDI Stream   ',0
    DB 0FFh, 0FFh, 0FFh,  01h, 0FFh, 0FFh, 'Audio Device? ',0
  ;Communications
    DB  02h,  00h,  00h,  02h,  00h,  00h, 'Comm Device   ',0
    DB  02h,  00h,  00h,  02h,  01h,  00h, 'Comm Direct Ln',0
    DB  02h,  00h,  00h,  02h,  02h,  00h, 'Modem         ',0
    DB  02h,  00h,  00h,  02h,  02h,  01h, 'Modem V.25ter ',0
    DB  02h,  00h,  00h,  02h,  02h,  02h, 'Modem PCCA101 ',0
    DB  02h,  00h,  00h,  02h,  02h,  03h, 'Modem PCCA101w',0
    DB  02h,  00h,  00h,  02h,  02h,  04h, 'Modem GSM     ',0
    DB  02h,  00h,  00h,  02h,  02h,  05h, 'Modem 3G      ',0
    DB  02h,  00h,  00h,  02h,  02h,  06h, 'Modem CDMA    ',0
    DB  02h,  00h,  00h,  02h,  02h, 0FEh, 'Modem Custom  ',0
    DB  02h,  00h,  00h,  02h,  02h, 0FFh, 'Modem?        ',0
    DB  02h,  00h,  00h,  02h,  03h,  00h, 'Telephone Comm',0
    DB  02h,  00h,  00h,  02h,  04h,  00h, 'MultiChan Comm',0
    DB  02h,  00h,  00h,  02h,  05h,  00h, 'ISDN CAPI Dvc ',0
    DB  02h,  00h,  00h,  02h,  06h,  00h, 'Ethernet Dvc  ',0
    DB  02h,  00h,  00h,  02h,  07h,  00h, 'ATM Device    ',0
    DB  02h,  00h,  00h,  02h,  08h,  00h, 'Wirels Handset',0
    DB  02h,  00h,  00h,  02h,  09h,  00h, 'Comm Dvc Mgmt ',0
    DB  02h,  00h,  00h,  02h,  0Ah,  00h, 'Mobl Direct Ln',0
    DB  02h,  00h,  00h,  02h,  0Bh,  00h, 'OBEX Comm Dvc ',0
    DB  02h,  00h,  00h,  02h,  0Ch,  00h, 'Ethernet Emul ',0
    DB  02h,  00h,  00h,  02h,  0Ch,  07h, 'Ethernet Emul ',0
    DB  02h,  00h,  00h,  02h,  0Ch, 0FFh, 'Ethernet Emul?',0
    DB  02h,  00h,  00h,  02h, 0FFh, 0FFh, 'Comm Device?  ',0
  ;Communications Control
    DB  02h,  00h,  00h,  0Ah,  00h,  30h, 'I.430 ISDN BRI',0
    DB  02h,  00h,  00h,  0Ah,  00h,  31h, 'HDLC          ',0
    DB  02h,  00h,  00h,  0Ah,  00h,  32h, 'Transp Data   ',0
    DB  02h,  00h,  00h,  0Ah,  00h,  50h, 'Q.921M ISDN   ',0
    DB  02h,  00h,  00h,  0Ah,  00h,  51h, 'Q.921 ISDN    ',0
    DB  02h,  00h,  00h,  0Ah,  00h,  52h, 'Q.921TM ISDN  ',0
    DB  02h,  00h,  00h,  0Ah,  00h,  90h, 'V.42bis       ',0
    DB  02h,  00h,  00h,  0Ah,  00h,  91h, 'Q.931/EuroISDN',0
    DB  02h,  00h,  00h,  0Ah,  00h,  92h, 'V.120 ISDN    ',0
    DB  02h,  00h,  00h,  0Ah,  00h,  93h, 'CAPI 2.0 ISDN ',0
    DB  02h,  00h,  00h,  0Ah,  00h, 0FDh, 'Host-Based    ',0
    DB  02h,  00h,  00h,  0Ah,  00h, 0FEh, 'Protocol Unit ',0
    DB  02h,  00h,  00h,  0Ah,  00h, 0FFh, 'Comm Device?  ',0
  ;Human Interface Devices
    DB 0FFh, 0FFh, 0FFh,  03h,  00h,  00h, 'Human Intf Dvc',0
    DB 0FFh, 0FFh, 0FFh,  03h,  01h,  01h, 'Keyboard      ',0
    DB 0FFh, 0FFh, 0FFh,  03h,  01h,  02h, 'Mouse         ',0
    DB 0FFh, 0FFh, 0FFh,  03h, 0FFh, 0FFh, 'Human Int Dvc?',0
  ;Physical
    DB 0FFh, 0FFh, 0FFh,  05h,  00h,  00h, 'Physical Dvc  ',0
    DB 0FFh, 0FFh, 0FFh,  05h, 0FFh, 0FFh, 'Physical Dvc? ',0
  ;Imaging
    DB 0FFh, 0FFh, 0FFh,  06h,  01h,  01h, 'Still Image   ',0
    DB 0FFh, 0FFh, 0FFh,  06h, 0FFh, 0FFh, 'Image Device? ',0
  ;Printer
    DB 0FFh, 0FFh, 0FFh,  07h,  01h,  00h, 'Printer       ',0
    DB 0FFh, 0FFh, 0FFh,  07h,  01h,  01h, 'UniDir Printer',0
    DB 0FFh, 0FFh, 0FFh,  07h,  01h,  02h, 'BiDir Printer ',0
    DB 0FFh, 0FFh, 0FFh,  07h,  01h,  03h, '1284.4 Printer',0
    DB 0FFh, 0FFh, 0FFh,  07h,  01h, 0FFh, 'Printer?      ',0
  ;Mass Storage
    DB 0FFh, 0FFh, 0FFh,  08h,  00h,  00h, 'Mass Storage  ',0
    DB 0FFh, 0FFh, 0FFh,  08h,  01h,  00h, 'Reduc Blk CBI ',0
    DB 0FFh, 0FFh, 0FFh,  08h,  01h,  01h, 'Reduc Blk CB  ',0
    DB 0FFh, 0FFh, 0FFh,  08h,  01h,  50h, 'Reduc Blk Bulk',0
    DB 0FFh, 0FFh, 0FFh,  08h,  01h, 0FFh, 'Reduced Block ',0
    DB 0FFh, 0FFh, 0FFh,  08h,  02h,  00h, 'ATAPI CBI     ',0
    DB 0FFh, 0FFh, 0FFh,  08h,  02h,  01h, 'ATAPI CB      ',0
    DB 0FFh, 0FFh, 0FFh,  08h,  02h,  50h, 'ATAPI Bulk    ',0
    DB 0FFh, 0FFh, 0FFh,  08h,  02h, 0FFh, 'ATAPI (CD/DVD)',0
    DB 0FFh, 0FFh, 0FFh,  08h,  03h,  00h, 'QIC-157 CBI   ',0
    DB 0FFh, 0FFh, 0FFh,  08h,  03h,  01h, 'QIC-157 CB    ',0
    DB 0FFh, 0FFh, 0FFh,  08h,  03h,  50h, 'QIC-157 Bulk  ',0
    DB 0FFh, 0FFh, 0FFh,  08h,  03h, 0FFh, 'QIC-157 (Tape)',0
    DB 0FFh, 0FFh, 0FFh,  08h,  04h,  00h, 'UFI Floppy CBI',0
    DB 0FFh, 0FFh, 0FFh,  08h,  04h,  01h, 'UFI Floppy CB ',0
    DB 0FFh, 0FFh, 0FFh,  08h,  04h,  50h, 'UFI Floppy Blk',0
    DB 0FFh, 0FFh, 0FFh,  08h,  04h, 0FFh, 'UFI Floppy    ',0
    DB 0FFh, 0FFh, 0FFh,  08h,  05h,  00h, 'SFF-8070i CBI ',0
    DB 0FFh, 0FFh, 0FFh,  08h,  05h,  01h, 'SFF-8070i CB  ',0
    DB 0FFh, 0FFh, 0FFh,  08h,  05h,  50h, 'SFF-8070i Bulk',0
    DB 0FFh, 0FFh, 0FFh,  08h,  05h, 0FFh, 'SFF-8070i Flpy',0
    DB 0FFh, 0FFh, 0FFh,  08h,  06h,  00h, 'SCSI Trsp CBI ',0
    DB 0FFh, 0FFh, 0FFh,  08h,  06h,  01h, 'SCSI Trsp CB  ',0
    DB 0FFh, 0FFh, 0FFh,  08h,  06h,  50h, 'SCSI Trsp Bulk',0
    DB 0FFh, 0FFh, 0FFh,  08h,  06h, 0FFh, 'SCSI Transp   ',0
    DB 0FFh, 0FFh, 0FFh,  08h, 0FFh, 0FFh, 'Mass Storage? ',0
  ;Hub
    DB  09h,  00h,  00h, 0FFh, 0FFh, 0FFh, 'Hub v1 Generic',0
    DB  09h,  00h,  01h, 0FFh, 0FFh, 0FFh, 'Hub v2 SinglTT',0
    DB  09h,  00h,  02h, 0FFh, 0FFh, 0FFh, 'Hub v2 MultiTT',0
    DB  09h,  00h, 0FFh, 0FFh, 0FFh, 0FFh, 'Generic Hub?  ',0
  ;Smart Card
    DB 0FFh, 0FFh, 0FFh,  0Bh,  00h,  00h, 'Chip/SmartCard',0
    DB 0FFh, 0FFh, 0FFh,  0Bh, 0FFh, 0FFh, 'Chip/SmartCrd?',0
  ;Content Security
    DB 0FFh, 0FFh, 0FFh,  0Dh,  00h,  00h, 'Cont Security ',0
    DB 0FFh, 0FFh, 0FFh,  0Dh, 0FFh, 0FFh, 'Cont Security?',0
  ;Video
    DB 0FFh, 0FFh, 0FFh,  0Eh,  00h,  00h, 'Video Device  ',0
    DB 0FFh, 0FFh, 0FFh,  0Eh,  01h,  00h, 'Video Control ',0
    DB 0FFh, 0FFh, 0FFh,  0Eh,  02h,  00h, 'Video Stream  ',0
    DB 0FFh, 0FFh, 0FFh,  0Eh,  03h,  00h, 'Video Intf Col',0
    DB 0FFh, 0FFh, 0FFh,  0Eh, 0FFh, 0FFh, 'Video Device? ',0
  ;Personal Healthcare
    DB 0FFh, 0FFh, 0FFh,  0Fh, 0FFh, 0FFh, 'Healthcare Dvc',0
  ;Diagnostic Device
    DB 0FFh, 0FFh, 0FFh, 0DCh,  00h,  00h, 'Diagnostic Dvc',0
    DB 0DCh,  00h,  00h, 0FFh, 0FFh, 0FFh, 'Diagnostic Dvc',0
    DB 0FFh, 0FFh, 0FFh, 0DCh,  01h,  01h, 'USB2 Complianc',0
    DB 0DCh,  01h,  01h, 0FFh, 0FFh, 0FFh, 'USB2 Complianc',0
    DB 0DCh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 'Diagnostic?   ',0
    DB 0FFh, 0FFh, 0FFh, 0DCh, 0FFh, 0FFh, 'Diagnostic?   ',0
  ;Wireless Controller
    DB  00h,  00h,  00h, 0E0h,  00h,  00h, 'Wireless Dvc  ',0
    DB 0FFh, 0FFh, 0FFh, 0E0h,  01h,  01h, 'BlueTooth Dvc ',0
    DB  00h,  00h,  00h, 0E0h,  01h,  02h, 'Ultra WB Radio',0
    DB  00h,  00h,  00h, 0E0h,  01h,  03h, 'Remote NDIS   ',0
    DB  00h,  00h,  00h, 0E0h,  02h,  01h, 'Host Wire Ctl ',0
    DB  00h,  00h,  00h, 0E0h,  02h,  02h, 'Dvc Wire Ctl  ',0
    DB  00h,  00h,  00h, 0E0h,  02h,  03h, 'Dvc Wire Isoch',0
    DB 0E0h,  01h,  01h, 0FFh, 0FFh, 0FFh, 'BlueTooth Dvc ',0
    DB  00h, 0FFh, 0FFh, 0E0h, 0FFh, 0FFh, 'Wireless Dvc? ',0
  ;Miscellaneous
    DB 0FFh, 0FFh, 0FFh, 0EFh,  00h,  00h, 'Miscellaneous ',0
    DB 0EFh,  00h,  00h, 0FFh, 0FFh, 0FFh, 'Miscellaneous ',0
    DB 0FFh, 0FFh, 0FFh, 0EFh,  01h,  01h, 'Active Sync   ',0
    DB 0EFh,  01h,  01h, 0FFh, 0FFh, 0FFh, 'Active Sync   ',0
    DB 0FFh, 0FFh, 0FFh, 0EFh,  01h,  02h, 'Palm Sync     ',0
    DB 0EFh,  01h,  02h, 0FFh, 0FFh, 0FFh, 'Palm Sync     ',0
;    DB 0EFh,  02h,  01h, 0FFh, 0FFh, 0FFh, 'Intf Assoc    ',0
    DB 0FFh, 0FFh, 0FFh, 0EFh,  02h,  02h, 'Wire Adapter  ',0
    DB 0EFh,  02h,  02h, 0FFh, 0FFh, 0FFh, 'Wire Adapter  ',0
    DB 0FFh, 0FFh, 0FFh, 0EFh,  03h,  02h, 'Cable Assoc   ',0
    DB 0EFh,  03h,  02h, 0FFh, 0FFh, 0FFh, 'Cable Assoc   ',0
    DB 0FFh, 0FFh, 0FFh, 0EFh, 0FFh, 0FFh, 'Miscellaneous?',0
    DB 0EFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 'Miscellaneous?',0
  ;Application Specific
    DB 0FFh, 0FFh, 0FFh, 0FEh,  01h,  00h, 'Firmware Updat',0
    DB 0FFh, 0FFh, 0FFh, 0FEh,  02h,  00h, 'IrDA Bridge   ',0
    DB 0FFh, 0FFh, 0FFh, 0FEh,  03h,  00h, 'Test & Measure',0
    DB 0FFh, 0FFh, 0FFh, 0FEh,  03h,  01h, 'Test&Meas 488 ',0
    DB 0FFh, 0FFh, 0FFh, 0FEh, 0FFh, 0FFh, 'App-Specific? ',0

    DB 253 ;End of Table


  ;----------------------------------------------------------------------------
  ;String to print an Unknown Descriptor Type
  ;----------------------------------------------------------------------------
  DvcDescriptionUnknown:
    DB 'Unknown Device',0
  DvcDescriptionSize  EQU $-DvcDescriptionUnknown


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;HID (Human Interface Device) related Tables
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

  ;----------------------------------------------------------------------------
  ;Country Codes for HID Devices
  ;----------------------------------------------------------------------------
  HIDCountryTbl:
    DB TblFlagByte
    DB 00h, 'None/Not Applicable',0
    DB 01h, 'Arabic',0
    DB 02h, 'Belgian',0
    DB 03h, 'Canadian Bilingual',0
    DB 04h, 'Canadian French',0
    DB 05h, 'Czech Republic',0
    DB 06h, 'Danish',0
    DB 07h, 'Finnish',0
    DB 08h, 'French',0
    DB 09h, 'German',0
    DB 0Ah, 'Greek',0
    DB 0Bh, 'Hebrew',0
    DB 0Ch, 'Hungary',0
    DB 0Dh, 'ISO (International)',0
    DB 0Eh, 'Italian',0
    DB 0Fh, 'Japan (Katakana)',0
    DB 10h, 'Korean',0
    DB 11h, 'Latin American',0
    DB 12h, 'Dutch (Netherlands)',0
    DB 13h, 'Norwegian',0
    DB 14h, 'Persian (Farsi)',0
    DB 15h, 'Poland',0
    DB 16h, 'Portugese',0
    DB 17h, 'Russia',0
    DB 18h, 'Slovokia',0
    DB 19h, 'Spanish',0
    DB 1Ah, 'Swedish',0
    DB 1Bh, 'Swiss French',0
    DB 1Ch, 'Swiss German',0
    DB 1Dh, 'Switzerland',0
    DB 1Eh, 'Taiwan',0
    DB 1Fh, 'Turkish-Q',0
    DB 20h, 'United Kingdom',0
    DB 21h, 'United States',0
    DB 22h, 'Yugoslovia',0
    DB 23h, 'Turkish-F',0
    DB  0 , -1 ;End of Table






TestDescr:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Example/Test Audio Version 1 Descriptors
;These are made up by me, so they are not necessarily and unbiased/foolproof
;  test scenario!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  DB   012h ;18                                  (Descr Size)
  DB   001h ;Device                              (Descr Type)
  DW 00110h ;1.10                                (USB Version)
  DB   000h ;Look at Interface                   (Class)
  DB   000h ;None                                (SubClass)
  DB   000h ;None                                (Protocol)
  DB   008h ;8                                   (Max Pkt Size EP0)
  DW 0047Fh ;Plantronics Inc                     (Vendor ID)
  DW 0FFFFh ;65,535                              (Device ID)
  DW 00100h ;1.00                                (Device Version)
  DB   066h ;Unavailable                         (Vendor String)
  DB   066h ;Unavailable                         (Device String)
  DB   066h ;Unavailable                         (Serial Number String)
  DB   001h ;1                                   (# of Configs)
;==============================================================================
  DB   009h ;9                                   (Descr Size)
  DB   004h ;Interface                           (Descr Type)
  DB   001h ;1                                   (Interface Number)
  DB   001h ;1                                   (Alternate Setting)
  DB   001h ;1                                   (# of Endpoints)
  DB   001h ;Audio                               (Intf Class)
  DB   002h ;Audio Streaming                     (Intf SubClass)
  DB   000h ;None                                (Intf Protocol)
  DB   066h ;Unavailable                         (Interface String)
;==============================================================================
  DB   007h ;7                                   (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   001h ;General Stream                      (Descr SubType)
  DB   022h ;34                                  (Terminal Link ID)
  DB   000h ;0                                   (Delay in Frames)
  DW 00005h ;Mu-Law PCM                          (Audio Format)
;==============================================================================
  DB   00Eh ;14                                  (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   002h ;Stream Format Type                  (Descr SubType)
  DB   001h ;Type 1 (PCM)                        (Format Type)
  DB   001h ;1                                   (Number of Channels)
  DB   002h ;2                                   (SubSlot Size)
  DB   010h ;16                                  (Resolution Bits)
  DB   000h ;Continuous                          (Sampling Rate Type)
  DB   000h ;6400                                (Min Sampling Rate)
  DB   019h ;"  "
  DB   000h ;"  "
  DB   080h ;48000                               (Max Sampling Rate)
  DB   0BBh ;"   "
  DB   000h ;"   "
;==============================================================================
  DB   00Fh ;15                                  (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   002h ;Stream Format Type                  (Descr SubType)
  DB   002h ;Type 2 (non-PCM)                    (Format Type)
  DW 00064h ;100                                 (Maximum kbps)
  DW 00100h ;256                                 (samples per Frame)
  DB   000h ;Continuous                          (Sampling Rate Type)
  DB   000h ;6400                                (Min Sampling Rate)
  DB   019h ;"  "
  DB   000h ;"  "
  DB   080h ;48000                               (Max Sampling Rate)
  DB   0BBh ;"   "
  DB   000h ;"   "
;==============================================================================
  DB   014h ;20                                  (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   002h ;Stream Format Type                  (Descr SubType)
  DB   003h ;Type 3                              (Format Type)
  DB   001h ;2                                   (Number of Channels)
  DB   002h ;2                                   (SubSlot Size)
  DB   020h ;32                                  (Resolution Bits)
  DB   004h ;Discrete                            (Sampling Rate Type)
  DB   000h ;6400                                (Sampling Rate 1)
  DB   019h ;"  "
  DB   000h ;"  "
  DB   080h ;48000                               (Sampling Rate 2)
  DB   0BBh ;"   "
  DB   000h ;"   "
  DB   000h ;49152                               (Sampling Rate 3)
  DB   0C0h ;"   "
  DB   000h ;"   "
  DB   000h ;61440                               (Sampling Rate 4)
  DB   0F0h ;"   "
  DB   000h ;"   "
;==============================================================================
  DB   008h ;8                                   (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   003h ;Stream Format Specific              (Descr SubType)
  DW 01001h ;MPEG                                (Format Tag)
  DW 0FFFFh ;All Capabilities                    (Decoder Capabilities)
  DB   0FFh ;All Features                        (Decoder Features)
;==============================================================================
  DB   00Ah ;10                                  (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   003h ;Stream Format Specific              (Descr SubType)
  DW 01002h ;AC-3                                (Format Tag)
  DD 0FFFF_FFFFh ;Modes 0-31                     (BSID Modes Supported)
  DB   0FFh ;All Features                        (Decoder Features)
;==============================================================================
  DB   007h ;7                                   (Descr Size)
  DB   025h ;Audio EndPoint                      (Descr Type)
  DB   001h ;General Audio EndPoint              (Descriptor SubType)
  DB   0FFh ;EndPoint Attributes                 (Supported Attributes)
  DB   001h ;Milliseconds                        (Lock Delay Units)
  DW 00010h ;16                                  (Lock Delay Value)




;;==============================================================================
;  DB   009h ;9                                   (Descr Size)
;  DB   004h ;Interface                           (Descr Type)
;  DB   000h ;0                                   (Interface Number)
;  DB   000h ;0                                   (Alternate Setting)
;  DB   000h ;0                                   (# of Endpoints)
;  DB   001h ;Audio                               (Intf Class)
;  DB   001h ;Audio Control Device                (Intf SubClass)
;  DB   000h ;None                                (Intf Protocol)
;  DB   066h ;Unavailable                         (Interface String)
;;==============================================================================
;  DB   00Ah ;10                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   001h ;Header                              (Descr SubType)
;  DW 00100h ;1.00                                (Audio Spec Version)
;  DW 000FFh ;255                                 (Total Size)
;  DB   002h ;2                                   (# of Stream Interfaces)
;  DB   001h ;1                                   (Stream Interface #)
;  DB   002h ;2                                   (Stream Interface #)
;;==============================================================================
;  DB   00Ch ;12                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   002h ;Input Terminal                      (Descr SubType)
;  DB   00Ch ;12                                  (Terminal ID)
;  DW 00101h ;USB Streaming                       (Terminal Type)
;  DB   000h ;0                                   (Assoc Output Terminal)
;  DB   002h ;2                                   (# of Output Channels)
;  DW 00003h ;Front Left, Front Right             (Spatial Configuration)
;  DB   000h ;None                                (First Channel String)
;  DB   066h ;Unavailable                         (Terminal String)
;;==============================================================================
;  DB   009h ;9                                   (Descr Size)
;  DB   024h ;Output Terminal                     (Descr Type)
;  DB   003h ;3                                   (Descr SubType)
;  DB   00Dh ;13                                  (Terminal ID)
;  DW 00101h ;USB Streaming                       (Terminal Type)
;  DB   000h ;0                                   (Assoc Input Term)
;  DB   002h ;2                                   (Source Unit/Term ID)
;  DB   066h ;Unavailable                         (Unit String)
;;==============================================================================
;  DB   00Fh ;15                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   004h ;Mixer Unit                          (Descr SubType)
;  DB   00Fh ;15                                  (Unit ID)
;  DB   003h ;3                                   (# of Input Pins)
;  DB   005h ;5                                   (Input Pin ID's)
;  DB   007h ;7
;  DB   009h ;9
;  DB   005h ;5                                   (# of Output Channels)
;  DW 00007h ;Left, Right, etc.                   (Spatial Configuration)
;  DB   066h ;Unavailable                         (Channel String Index 1)
;  DW 0B0BBh ;Out Chans 1, 3-4 = Programmable     (Controls (Out Chan Program))
;  DB   066h ;Unavailable                         (Mixer String)
;;==============================================================================
;  DB   00Eh ;14                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   005h ;Selector Unit                       (Descr SubType)
;  DB   00Fh ;15                                  (Unit ID)
;  DB   008h ;8                                   (# of Input Pins)
;  DB   040h ;64                                  (Input Pin IDs)
;  DB   041h ;65
;  DB   042h ;66
;  DB   043h ;67
;  DB   044h ;68
;  DB   045h ;69
;  DB   046h ;70
;  DB   047h ;71
;  DB   066h ;Unavailable                         (Selector String)
;;==============================================================================
;  DB   00Dh ;13                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   006h ;Feature Unit                        (Descr SubType)
;  DB   010h ;16                                  (Unit ID)
;  DB   007h ;7                                   (Source ID)
;  DB   002h ;2                                   (Bytes per Element)
;;  DW 003FFh ;Mute, Volume, etc. (All Controls)   (Controls for Master Chan 0)
;  DW 0FFFFh ;Mute, Volume, etc. (All Controls)   (Controls for Master Chan 0)
;  DW 00020h ;Graphics Equalizer                  (Controls for Logical Chan 1)
;  DW 00200h ;Loudness                            (Controls for Logical Chan 2)
;  DB   066h ;Unavailable                         (Feature String)
;;==============================================================================
;  DB   016h ;22                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   007h ;Processing Unit                     (Descr SubType)
;  DB   011h ;17                                  (Unit ID)
;  DW 00001h ;Up/Down Mix                         (Processing Unit Type)
;  DB   001h ;1                                   (# of Input Pins)
;  DB   051h ;81                                  (Input Pin IDs)
;  DB   005h ;5                                   (# of Output Channels)
;  DW 00007h ;Left, Right, Center                 (Spatial Configuration)
;  DB   066h ;Unavailable                         (Channel String Index 1)
;  DB   001h ;1                                   (Bytes per Control)
;  DB   0FFh ;Enable Processing, Mode Select      (Controls Bitmap)
;  DB   066h ;Unavailable                         (Processing Unit String)
;  ;;;
;  DB   003h ;3                                   (Number of Supported Modes)
;  DW 00007h ;Left, Right, Center                 (Active Channels in Mode 1)
;  DW 00003h ;Left, Right                         (Active Channels in Mode 2)
;  DW 00004h ;Center                              (Active Channels in Mode 3)
;;==============================================================================
;  DB   016h ;22                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   007h ;Processing Unit                     (Descr SubType)
;  DB   012h ;18                                  (Unit ID)
;  DW 00002h ;Dolby ProLogic                      (Processing Unit Type)
;  DB   001h ;1                                   (# of Input Pins)
;  DB   052h ;82                                  (Input Pin IDs)
;  DB   004h ;4                                   (# of Output Channels)
;  DW 00107h ;Left, Right, Center, Surround       (Spatial Configuration)
;  DB   000h ;None                                (First Channel String)
;  DB   001h ;1                                   (Bytes per Control)
;  DB   003h ;Enable Processing, Mode Select      (Controls Bitmap)
;  DB   066h ;Unavailable                         (Processing Unit String)
;  ;;;
;  DB   003h ;3                                   (Number of Supported Modes)
;  DW 00007h ;Left, Right, Center                 (Active Channels in Mode 1)
;  DW 00103h ;Left, Right, Surround               (Active Channels in Mode 2)
;  DW 00107h ;Left, Right, Center, Surround       (Active Channels in Mode 3)
;;==============================================================================
;  DB   00Fh ;15                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   007h ;Processing Unit                     (Descr SubType)
;  DB   013h ;19                                  (Unit ID)
;  DW 00003h ;3D Stereo                           (Processing Unit Type)
;  DB   001h ;1                                   (# of Input Pins)
;  DB   053h ;83                                  (Input Pin IDs)
;  DB   006h ;4                                   (# of Output Channels)
;  DW 00107h ;Left, Right, Center, Surround       (Spatial Configuration)
;  DB   066h ;Unavailable                         (First Channel String)
;  DB   001h ;1                                   (Bytes per Control)
;  DB   003h ;Enable Processing, Spaciousness     (Controls Bitmap)
;  DB   066h ;Unavailable                         (Processing Unit String)
;;==============================================================================
;  DB   00Fh ;15                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   007h ;Processing Unit                     (Descr SubType)
;  DB   014h ;20                                  (Unit ID)
;  DW 00004h ;Reverberation                       (Processing Unit Type)
;  DB   001h ;1                                   (# of Input Pins)
;  DB   054h ;84                                  (Input Pin IDs)
;  DB   004h ;4                                   (# of Output Channels)
;  DW 00107h ;Left, Right, Center, Surround       (Spatial Configuration)
;  DB   000h ;None                                (First Channel String)
;  DB   001h ;1                                   (Bytes per Control)
;  DB   01Fh ;All Possible Controls               (Controls Bitmap)
;  DB   066h ;Unavailable                         (Processing Unit String)
;;==============================================================================
;  DB   00Fh ;15                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   007h ;Processing Unit                     (Descr SubType)
;  DB   015h ;21                                  (Unit ID)
;  DW 00005h ;Chorus                              (Processing Unit Type)
;  DB   001h ;1                                   (# of Input Pins)
;  DB   055h ;85                                  (Input Pin IDs)
;  DB   008h ;8                                   (# of Output Channels)
;  DW 00107h ;Left, Right, Center, Surround       (Spatial Configuration)
;  DB   000h ;None                                (First Channel String)
;  DB   001h ;1                                   (Bytes per Control)
;  DB   00Fh ;All Possible Controls               (Controls Bitmap)
;  DB   066h ;Unavailable                         (Processing Unit String)
;;==============================================================================
;  DB   00Fh ;15                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   007h ;Processing Unit                     (Descr SubType)
;  DB   016h ;22                                  (Unit ID)
;  DW 00006h ;Dynamic Range Compressor            (Processing Unit Type)
;  DB   001h ;1                                   (# of Input Pins)
;  DB   056h ;86                                  (Input Pin IDs)
;  DB   008h ;8                                   (# of Output Channels)
;  DW 00107h ;Left, Right, Center, Surround       (Spatial Configuration)
;  DB   000h ;None                                (First Channel String)
;  DB   001h ;1                                   (Bytes per Control)
;  DB   03Fh ;All Possible Controls               (Controls Bitmap)
;  DB   066h ;Unavailable                         (Processing Unit String)
;;==============================================================================
;  DB   013h ;19                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   008h ;Extension Unit                      (Descr SubType)
;  DB   017h ;23                                  (Unit ID)
;  DW 00065h ;101                                 (Vendor Extension Code)
;  DB   003h ;3                                   (# of Input Pins)
;  DB   006h ;6                                   (Input Pin ID's)
;  DB   008h ;8
;  DB   00Ah ;10
;  DB   005h ;5                                   (# of Output Channels)
;  DW 00007h ;Left, Right, Center                 (Spatial Configuration)
;  DB   066h ;Unavailable                         (Channel String Index 1)
;  DB   003h ;3                                   (Bytes in Control Field)
;  DB   0FFh, 0FFh, 0FFh ;                        (Controls Bitmap)
;  DB   066h ;Unavailable                         (Extension Unit String)
;;==============================================================================
  DB  000h  ;End of Descriptor Set


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;Example/Test Audio Version 2 Descriptors
;;These are made up by me, so they are not necessarily and unbiased/foolproof
;;  test scenario!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  DB   012h ;18                                  (Descr Size)
;  DB   001h ;Device                              (Descr Type)
;  DW 00110h ;1.10                                (USB Version)
;  DB   000h ;Look at Interface                   (Dvc Class)
;  DB   000h ;None                                (Dvc SubClass)
;  DB   000h ;None                                (Dvc Protocol)
;  DB   008h ;8                                   (Max Pkt Size EP0)
;  DW 0047Fh ;Plantronics Inc                     (Vendor ID)
;  DW 00CA1h ;3,233                               (Device ID)
;  DW 00004h ;0.04                                (Device Version)
;  DB   066h ;Unavailable                         (Vendor String)
;  DB   066h ;Unavailable                         (Device String)
;  DB   066h ;Unavailable                         (Serial Number String)
;  DB   001h ;1                                   (# of Configs)
;;==============================================================================
;  DB   009h ;9                                   (Descr Size)
;  DB   002h ;Configuration                       (Descr Type)
;  DW 00171h ;369                                 (Total Size)
;  DB   004h ;4                                   (# of Interfaces)
;  DB   001h ;1                                   (Config Value)
;  DB   066h ;Unavailable                         (Config String)
;  DB   080h ;Bus_Powered No_Remote_Wakeup        (Attributes)
;  DB   032h ;50 (100 mA)                         (Current Draw)
;;==============================================================================
;  DB   009h ;9                                   (Descr Size)
;  DB   004h ;Interface                           (Descr Type)
;  DB   000h ;0                                   (Interface Number)
;  DB   000h ;0                                   (Alternate Setting)
;  DB   000h ;0                                   (# of Endpoints)
;  DB   001h ;Audio                               (Intf Class)
;  DB   001h ;Audio Control Device                (Intf SubClass)
;  DB   020h ;Audio Spec v2.0                     (Intf Protocol)
;  DB   066h ;Unavailable                         (Interface String)
;;==============================================================================
;  DB   009h ;9                                   (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   001h ;Header                              (Descr SubType)
;  DW 00200h ;2.00                                (Audio Spec Version)
;  DB   009h ;Musical Instrument                  (Category/Primary Use)
;  DW 00064h ;100                                 (Total Size)
;  DB   01h  ;Latency Control: Read-Only          (Controls)
;;==============================================================================
;  DB   011h ;17                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   002h ;Input Terminal                      (Descr SubType)
;  DB   00Ch ;12                                  (Terminal ID)
;  DW 00701h ;Calibration Noise Source            (Terminal Type)
;  DB   000h ;0                                   (Assoc Output Terminal)
;  DB   001h ;                                    (Clock Source ID)
;  DB   006h ;6                                   (# of Output Channels)
;  DD 0000_003Fh ;Left, Right, etc.               (Spatial Configuration)
;  DB   000h ;None                                (Channel 1 Description String)
;  DW 0FFFFh ;All Controls Programmable           (Controls Supported)
;  DB   066h ;Unavailable                         (Terminal String)
;;==============================================================================
;  DB   00Ch ;12                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   003h ;Output Terminal                     (Descr SubType)
;  DB   00Dh ;13                                  (Terminal ID)
;  DW 00701h ;Calibration Noise Source            (Terminal Type)
;  DB   003h ;3                                   (Assoc Input Terminal)
;  DB   004h ;4                                   (Source ID)
;  DB   001h ;1                                   (Clock Source ID)
;  DW 0FFFFh ;All Controls Programmable           (Controls Supported)
;  DB   066h ;Unavailable                         (Terminal String)
;;==============================================================================
;  DB   012h ;18                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   004h ;Mixer Unit                          (Descr SubType)
;  DB   00Eh ;14                                  (Unit ID)
;  DB   003h ;3                                   (# of Input Pins)
;  DB   016h ;22                                  (Input Pin ID's)
;  DB   017h ;23
;  DB   018h ;24
;  DB   005h ;5                                   (# of Output Channels)
;  DD 0000_0007h ;Left, Right, etc.               (Spatial Configuration)
;  DB   066h ;Unavailable                         (Channel String Index 1)
;  DW 0B0BBh ;Out Chans 1, 3-4 = Programmable     (Controls (Out Chan Program))
;  DB   015h ;All Controls Read-Only              (Controls)
;  DB   066h ;Unavailable                         (Mixer String)
;;==============================================================================
;  DB   00Dh ;13                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   005h ;Selector Unit                       (Descr SubType)
;  DB   00Fh ;15                                  (Unit ID)
;  DB   006h ;6                                   (# of Input Pins)
;  DB   019h ;25                                  (Input Pin ID's)
;  DB   01Ah ;26
;  DB   01Bh ;27
;  DB   01Ch ;28
;  DB   01Dh ;28
;  DB   01Eh ;28
;;  DB   003h ;Programmable                        (Controls);  DB   003h ;Programmable                        (Controls)
;  DB   0FFh ;Programmable                        (Controls);  DB   003h ;Programmable                        (Controls)
;  DB   066h ;Unavailable                         (Mixer String)
;;==============================================================================
;  DB   012h ;18                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   006h ;Feature Unit                        (Descr SubType)
;  DB   010h ;16                                  (Unit ID)
;  DB   022h ;34                                  (Source ID)
;  DD 05550_5555h ;Most Controls RO, incl Unknown (Controls Master Chan 0)
;  DD 01550_5555h ;Most Controls RO               (Controls Master Chan 1)
;  DD 01550_5555h ;Most Controls RO               (Controls Master Chan 2)
;  DB   066h ;Unavailable                         (Mixer String)
;;==============================================================================
;  DB   01Ch ;28                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   007h ;Effect Unit                         (Descr SubType)
;  DB   011h ;17                                  (Unit ID)
;  DW 00001h ;Parametric Equalizer                (Effect Type)
;  DB   023h ;35                                  (Source ID)
;  DD 00000_0000h ;All Controls Programmable      (Controls Master Chan 0)
;  DD 00000_0555h ;All Controls Programmable      (Controls Master Chan 1)
;  DD 00000_0AAAh ;All Controls Programmable      (Controls Master Chan 2)
;  DD 00000_0FFFh ;All Controls Programmable      (Controls Master Chan 3)
;  DD 0C000_0FFFh ;All Controls Programmable      (Controls Master Chan 4)
;  DB   066h ;Unavailable                         (Mixer String)
;;==============================================================================
;  DB   00Ch ;12                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   007h ;Effect Unit                         (Descr SubType)
;  DB   012h ;18                                  (Unit ID)
;  DW 00002h ;Reverb                              (Effect Type)
;  DB   024h ;36                                  (Source ID)
;  DD 0FFFF_FFFFh ;All Controls Programmable      (Controls Master Chan 0)
;  DB   066h ;Unavailable                         (Mixer String)
;;==============================================================================
;  DB   010h ;16                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   007h ;Effect Unit                         (Descr SubType)
;  DB   013h ;19                                  (Unit ID)
;  DW 00003h ;Modulation Delay                    (Effect Type)
;  DB   025h ;37                                  (Source ID)
;  DD 0FFFF_FFFFh ;All Controls Programmable      (Controls Master Chan 0)
;  DD 0FFFF_FFFFh ;All Controls Programmable      (Controls Master Chan 1)
;  DB   066h ;Unavailable                         (Mixer String)
;;==============================================================================
;  DB   014h ;20                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   007h ;Effect Unit                         (Descr SubType)
;  DB   014h ;20                                  (Unit ID)
;  DW 00004h ;Dynamic Range                       (Effect Type)
;  DB   026h ;38                                  (Source ID)
;  DD 0FFFF_FFFFh ;All Controls Programmable      (Controls Master Chan 0)
;  DD 0FFFF_FFFFh ;All Controls Programmable      (Controls Master Chan 1)
;  DD 0FFFF_FFFFh ;All Controls Programmable      (Controls Master Chan 1)
;  DB   066h ;Unavailable                         (Mixer String)
;;==============================================================================
;  DB   01Eh ;30                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   008h ;Processor Unit                      (Descr SubType)
;  DB   014h ;20                                  (Unit ID)
;  DW 00001h ;Up/Down Mix                         (Process Type)
;  DB   001h ;1                                   (# of Input Pins)
;  DB   01Bh ;27                                  (Input Pin ID's)
;  DB   006h ;6                                   (# of Output Channels)
;  DD 00000_0107h ;Left, Right, Center, Surround  (Spatial Configuration)
;  DB   063h ;Unavailable                         (Channel 1 Description String)
;  DW 0FFFFh ;All Controls Programmable           (Controls)
;  DB   066h ;Unavailable                         (Unit String)
;  DB   003h ;3                                   (# of Modes)
;  DD 00000_0107h ;Left, Right, Center, Surround  (Active Channels in Mode 1)
;  DD 00000_0007h ;Left, Right, Center            (Active Channels in Mode 2)
;  DD 00000_0003h ;Left, Right                    (Active Channels in Mode 3)
;;==============================================================================
;  DB   01Ah ;26                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   008h ;Processor Unit                      (Descr SubType)
;  DB   014h ;20                                  (Unit ID)
;  DW 00002h ;Dolby ProLogic                      (Process Type)
;  DB   001h ;1                                   (# of Input Pins)
;  DB   01Dh ;29                                  (Input Pin ID's)
;  DB   008h ;8                                   (# of Output Channels)
;  DD 08000_0000h ;Raw Data                       (Spatial Configuration)
;  DB   063h ;Unavailable                         (Channel 1 Description String)
;  DW 0FFFFh ;All Controls Programmable           (Controls)
;  DB   066h ;Unavailable                         (Unit String)
;  DB   002h ;2                                   (# of Modes)
;  DD 00000_0107h ;Left, Right, Center, Surround  (Active Channels in Mode 1)
;  DD 00000_0003h ;Left, Right, Center            (Active Channels in Mode 2)
;;==============================================================================
;  DB   011h ;17                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   008h ;Processor Unit                      (Descr SubType)
;  DB   014h ;20                                  (Unit ID)
;  DW 00003h ;Stereo Extender                     (Process Type)
;  DB   001h ;1                                   (# of Input Pins)
;  DB   01Eh ;30                                  (Input Pin ID's)
;  DB   002h ;8                                   (# of Output Channels)
;  DD 00000_0003h ;Left, Right                    (Spatial Configuration)
;  DB   000h ;None                                (Channel 1 Description String)
;  DW 0FFFFh ;All Controls Programmable           (Controls)
;  DB   066h ;Unavailable                         (Unit String)
;;==============================================================================
;  DB   013h ;19                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   009h ;Extension Unit                      (Descr SubType)
;  DB   015h ;21                                  (Unit ID)
;  DW 0000Eh ;15                                  (Vendor Extension Descr)
;  DB   004h ;4                                   (# of Input Pins)
;  DB   021h ;33                                  (Input Pin ID's)
;  DB   022h ;34
;  DB   023h ;35
;  DB   024h ;36
;  DB   005h ;5                                   (# of Output Channels)
;  DD 0000_0007h ;Left, Right, etc.               (Spatial Configuration)
;  DB   066h ;Unavailable                         (Channel String Index 1)
;  DB   0FFh ;All Controls Programmable           (Controls)
;  DB   066h ;Unavailable                         (Unit String)
;;==============================================================================
;  DB   008h ;8                                   (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   00Ah ;Clock Source                        (Descr SubType)
;  DB   005h ;5                                   (Clock Source ID)
;  DB   006h ;Internal Var Clock, Synch to SOF    (Attributes)
;  DB   001h ;Freq = Read-Only, Valid = No Supt   (Controls)
;  DB   009h ;9                                   (Associated Terminal ID)
;  DB   066h ;Unavailable                         (Source String)
;;==============================================================================
;  DB   00Ah ;10                                  (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   00Bh ;Clock Selector                      (Descr SubType)
;  DB   006h ;6                                   (Clock Selector ID)
;  DB   003h ;3                                   (# of Input Pins)
;  DB   004h ;4                                   (Input Pin Entity IDs)
;  DB   006h ;6
;  DB   007h ;7
;  DB   003h ;Selector Control = Programmable     (Controls)
;  DB   066h ;Unavailable                         (Selector String)
;;==============================================================================
;  DB   007h ;7                                   (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   00Ch ;Clock Multiplier                    (Descr SubType)
;  DB   007h ;7                                   (Clock Multiplier ID)
;  DB   006h ;6                                   (Clock Entity Source ID)
;  DB   00Fh ;Num & Denom = Programmable          (Controls)
;  DB   066h ;Unavailable                         (Multiplier String)
;;==============================================================================
;  DB   008h ;8                                   (Descr Size)
;  DB   024h ;Audio Interface                     (Descr Type)
;  DB   00Dh ;Sample Rate Converter               (Descr SubType)
;  DB   008h ;7                                   (SRC ID)
;  DB   027h ;39                                  (Source ID)
;  DB   030h ;48                                  (Clock In Source ID)
;  DB   031h ;49                                  (Clock Out Source ID)
;  DB   066h ;Unavailable                         (SRC String)
;;==============================================================================
;  DB  000h  ;End of Descriptor Set


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Actual Data from Cristian's Plantronics Headset
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  DB   012h ;18                                  (Descr Size)
  DB   001h ;Device                              (Descr Type)
  DW 00110h ;1.10                                (USB Version)
  DB   000h ;Look at Interface                   (Class)
  DB   000h ;None                                (SubClass)
  DB   000h ;None                                (Protocol)
  DB   008h ;8                                   (Max Pkt Size EP0)
  DW 0047Fh ;Plantronics Inc                     (Vendor ID)
  DW 00CA1h ;3,233                               (Device ID)
  DW 00004h ;0.04                                (Device Version)
  DB   000h ;"Plantronics"                       (Vendor String)
  DB   000h ;"Plantronics Headset"               (Device String)
  DB   000h ;"00400-0429034410003-V060000A"      (Serial Number String)
  DB   001h ;1                                   (# of Configs)

  DB   009h ;9                                   (Descr Size)
  DB   002h ;Configuration                       (Descr Type)
  DW 00171h ;369                                 (Total Size)
  DB   004h ;4                                   (# of Interfaces)
  DB   001h ;1                                   (Config Value)
  DB   000h ;None                                (Config String)
  DB   080h ;Bus_Powered No_Remote_Wakeup        (Attributes)
  DB   032h ;50 (100 mA)                         (Current Draw)

  DB   009h ;9                                   (Descr Size)
  DB   004h ;Interface                           (Descr Type)
  DB   000h ;0                                   (Interface Number)
  DB   000h ;0                                   (Alternate Setting)
  DB   000h ;0                                   (# of Endpoints)
  DB   001h ;Audio                               (Intf Class)
  DB   001h ;Audio Control Device                (Intf SubClass)
  DB   000h ;None                                (Intf Protocol)
  DB   000h ;None                                (Interface String)

  DB   00Ah ;10                                  (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   001h ;Header                              (Descr SubType)
  DW 00100h ;1.00                                (Audio Spec Version)
  DW 0004Eh ;78                                  (Total Size)
  DB   002h ;2                                   (# of Stream Interfaces)
  DB   001h ;1                                   (Stream Interface #)
  DB   002h ;2                                   (Stream Interface #)

  DB   00Ch ;12                                  (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   002h ;Input Terminal                      (Descr SubType)
  DB   00Ch ;12                                  (Terminal ID)
  DW 00101h ;USB Streaming                       (Terminal Type)
  DB   000h ;0                                   (Assoc Output Terminal)
  DB   002h ;2                                   (# of Output Channels)
  DW 00003h ;Front Left, Front Right             (Spatial Configuration)
  DB   000h ;None                                (First Channel String)
  DB   000h ;None                                (Terminal String)

  DB   00Dh ;13                                  (Descr Size)
  DB   024h ;Unknown!                            (Descr Type)
  DB   006h ;Feature Unit                        (Descr SubType)
  DB   001h ;1                                   (Unit ID)
  DB   00Ch ;12                                  (Source Entity ID)
  DB   002h ;2                                   (Bytes per Control Element)
  DW 00155h ;Mute, Bass, Treble, Gain, Bass Bst  (Chan 0 Controls)
  DW 00002h ;Volume                              (Chan 1 Controls)
  DW 00002h ;Volume                              (Chan 2 Controls)
  DB   000h ;None                                (Unit String)

  DB   009h ;9                                   (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   003h ;Output Terminal                     (Descr SubType)
  DB   014h ;20                                  (Terminal ID)
  DW 00301h ;Generic Speaker                     (Terminal Type)
  DB   000h ;0                                   (Associated Input Term ID)
  DB   001h ;1                                   (Source Entity ID)
  DB   000h ;None                                (Terminal String)

  DB   00Ch ;12                                  (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   002h ;Input Terminal                      (Descr SubType)
  DB   00Ah ;10                                  (Terminal ID)
  DW 00201h ;Generic Microphone                  (Terminal Type)
  DB   000h ;0                                   (Associated Output Term ID)
  DB   002h ;2                                   (# of Channels)
  DW 00003h ;Left, Right                         (Spatial Config)
  DB   000h ;None                                (Channel Name String)
  DB   000h ;None                                (Terminal String)

  DB   00Dh ;13                                  (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   006h ;Feature Unit                        (Descr SubType)
  DB   002h ;2                                   (Unit ID)
  DB   00Ah ;10                                  (Source Entity ID)
  DB   002h ;2                                   (Bytes per Ctl Element)
  DW 00003h ;Mute, Volume                        (Chan 0 Controls)
  DW 00000h ;None                                (Chan 1 Controls)
  DW 00000h ;None                                (Chan 2 Controls)
  DB   000h ;None                                (Unit String)

  DB   009h ;9                                   (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   003h ;Output Terminal                     (Descr SubType)
  DB   00Dh ;13                                  (Terminal ID)
  DW 00101h ;USB Streaming                       (Terminal Type)
  DB   000h ;0                                   (Associated Input Term ID)
  DB   002h ;2                                   (Source Entity ID)
  DB   000h ;None                                (Terminal String)

  DB   009h ;9                                   (Descr Size)
  DB   004h ;Interface                           (Descr Type)
  DB   001h ;1                                   (Interface Number)
  DB   000h ;0                                   (Alternate Setting)
  DB   000h ;0                                   (# of Endpoints)
  DB   001h ;Audio                               (Intf Class)
  DB   002h ;Audio Streaming                     (Intf SubClass)
  DB   000h ;None                                (Intf Protocol)
  DB   000h ;None                                (Interface String)

  DB   009h ;9                                   (Descr Size)
  DB   004h ;Interface                           (Descr Type)
  DB   001h ;1                                   (Interface Number)
  DB   001h ;1                                   (Alternate Setting)
  DB   001h ;1                                   (# of Endpoints)
  DB   001h ;Audio                               (Intf Class)
  DB   002h ;Audio Streaming                     (Intf SubClass)
  DB   000h ;None                                (Intf Protocol)
  DB   000h ;None                                (Interface String)

  DB   007h ;7                                   (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   001h ;General Stream                      (Descr SubType)
  DB   00Ch ;12                                  (Terminal Link ID)
  DB   000h ;0                                   (Delay in Frames)
  DW 00001h ;Pulse Code Modulation               (Audio Format)

  DB   00Eh ;14                                  (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   002h ;Stream Format Type                  (Descr SubType)
  DB   001h ;Type 1 (PCM)                        (Format Type)
  DB   001h ;1                                   (Number of Channels)
  DB   002h ;2                                   (SubSlot Size)
  DB   010h ;16                                  (Resolution Bits)
  DB   000h ;Continuous                          (Sampling Rate Type)
  DB   000h ;6400                                (Min Sampling Rate)
  DB   019h ;"  "
  DB   000h ;"  "
  DB   080h ;48000                               (Max Sampling Rate)
  DB   0BBh ;"   "
  DB   000h ;"   "

  DB   009h ;9                                   (Descr Size)
  DB   005h ;EndPoint                            (Descr Type)
  DB   001h ;EndPoint = 1  Direction = Out       (End Point Number)
  DB   009h ;Isochronous Adaptive Data           (Attributes)
  DW 00064h ;100                                 (Max Packet Size)
  DB   001h ;1                                   (Max Poll Interval)
  DB   000h ;1 mS                                (Refresh Rate)
  DB   000h ;0                                   (Synch End Point)

  DB   007h ;7                                   (Descr Size)
  DB   025h ;Audio EndPoint                      (Descr Type)
  DB   001h ;General Audio EndPoint              (Descriptor SubType)
  DB   001h ;EndPoint Attributes                 (Supported Attributes)
  DB   002h ;Decoded PCM Samples                 (Lock Delay Units)
  DW 00001h ;1                                   (Lock Delay Value)

  DB   009h ;9                                   (Descr Size)
  DB   004h ;Interface                           (Descr Type)
  DB   001h ;1                                   (Interface Number)
  DB   002h ;2                                   (Alternate Setting)
  DB   001h ;1                                   (# of Endpoints)
  DB   001h ;Audio                               (Intf Class)
  DB   002h ;Audio Streaming                     (Intf SubClass)
  DB   000h ;None                                (Intf Protocol)
  DB   000h ;None                                (Interface String)

  DB   007h ;7                                   (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   001h ;General Stream                      (Descr SubType)
  DB   00Ch ;12                                  (Terminal Link ID)
  DB   000h ;0                                   (Delay in Frames)
  DW 00001h ;Pulse Code Modulation               (Audio Format)

  DB   00Eh ;14                                  (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   002h ;Stream Format Type                  (Descr SubType)
  DB   001h ;Type 1 (PCM)                        (Format Type)
  DB   002h ;2                                   (Number of Channels)
  DB   002h ;2                                   (SubSlot Size)
  DB   010h ;16                                  (Resolution Bits)
  DB   000h ;Continuous                          (Sampling Rate Type)
  DB   000h ;6400                                (Min Sampling Rate)
  DB   019h ;"  "
  DB   000h ;"  "
  DB   080h ;48000                               (Max Sampling Rate)
  DB   0BBh ;"   "
  DB   000h ;"   "

  DB   009h ;9                                   (Descr Size)
  DB   005h ;EndPoint                            (Descr Type)
  DB   001h ;EndPoint = 1  Direction = Out       (End Point Number)
  DB   009h ;Isochronous Adaptive Data           (Attributes)
  DW 000C8h ;200                                 (Max Packet Size)
  DB   001h ;1                                   (Max Poll Interval)
  DB   000h ;1 mS                                (Refresh Rate)
  DB   000h ;0                                   (Synch End Point)

  DB   007h ;7                                   (Descr Size)
  DB   025h ;Audio EndPoint                      (Descr Type)
  DB   001h ;General Audio EndPoint              (Descriptor SubType)
  DB   001h ;EndPoint Attributes                 (Supported Attributes)
  DB   002h ;Decoded PCM Samples                 (Lock Delay Units)
  DW 00001h ;1                                   (Lock Delay Value)

  DB   009h ;9                                   (Descr Size)
  DB   004h ;Interface                           (Descr Type)
  DB   002h ;2                                   (Interface Number)
  DB   000h ;0                                   (Alternate Setting)
  DB   000h ;0                                   (# of Endpoints)
  DB   001h ;Audio                               (Intf Class)
  DB   002h ;Audio Streaming                     (Intf SubClass)
  DB   000h ;None                                (Intf Protocol)
  DB   000h ;None                                (Interface String)

  DB   009h ;9                                   (Descr Size)
  DB   004h ;Interface                           (Descr Type)
  DB   002h ;2                                   (Interface Number)
  DB   001h ;1                                   (Alternate Setting)
  DB   001h ;1                                   (# of Endpoints)
  DB   001h ;Audio                               (Intf Class)
  DB   002h ;Audio Streaming                     (Intf SubClass)
  DB   000h ;None                                (Intf Protocol)
  DB   000h ;None                                (Interface String)

  DB   007h ;7                                   (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   001h ;General Stream                      (Descr SubType)
  DB   00Dh ;13                                  (Terminal Link ID)
  DB   000h ;0                                   (Delay in Frames)
  DW 00001h ;Pulse Code Modulation               (Audio Format)

  DB   00Eh ;14                                  (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   002h ;Stream Format Type                  (Descr SubType)
  DB   001h ;Type 1 (PCM)                        (Format Type)
  DB   001h ;1                                   (Number of Channels)
  DB   001h ;1                                   (SubSlot Size)
  DB   008h ;8                                   (Resolution Bits)
  DB   000h ;Continuous                          (Sampling Rate Type)
  DB   000h ;6400                                (Min Sampling Rate)
  DB   019h ;"  "
  DB   000h ;"  "
  DB   080h ;48000                               (Max Sampling Rate)
  DB   0BBh ;"   "
  DB   000h ;"   "

  DB   009h ;9                                   (Descr Size)
  DB   005h ;EndPoint                            (Descr Type)
  DB   084h ;EndPoint = 4  Direction = In        (End Point Number)
  DB   009h ;Isochronous Adaptive Data           (Attributes)
  DW 00032h ;50                                  (Max Packet Size)
  DB   001h ;1                                   (Max Poll Interval)
  DB   000h ;1 mS                                (Refresh Rate)
  DB   000h ;0                                   (Synch End Point)

  DB   007h ;7                                   (Descr Size)
  DB   025h ;Audio EndPoint                      (Descr Type)
  DB   001h ;General Audio EndPoint              (Descriptor SubType)
  DB   001h ;EndPoint Attributes                 (Supported Attributes)
  DB   002h ;Decoded PCM Samples                 (Lock Delay Units)
  DW 00001h ;1                                   (Lock Delay Value)

  DB   009h ;9                                   (Descr Size)
  DB   004h ;Interface                           (Descr Type)
  DB   002h ;2                                   (Interface Number)
  DB   002h ;2                                   (Alternate Setting)
  DB   001h ;1                                   (# of Endpoints)
  DB   001h ;Audio                               (Intf Class)
  DB   002h ;Audio Streaming                     (Intf SubClass)
  DB   000h ;None                                (Intf Protocol)
  DB   000h ;None                                (Interface String)

  DB   007h ;7                                   (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   001h ;General Stream                      (Descr SubType)
  DB   00Dh ;13                                  (Terminal Link ID)
  DB   000h ;0                                   (Delay in Frames)
  DW 00001h ;Pulse Code Modulation               (Audio Format)

  DB   00Eh ;14                                  (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   002h ;Stream Format Type                  (Descr SubType)
  DB   001h ;Type 1 (PCM)                        (Format Type)
  DB   001h ;1                                   (Number of Channels)
  DB   002h ;2                                   (SubSlot Size)
  DB   010h ;16                                  (Resolution Bits)
  DB   000h ;Continuous                          (Sampling Rate Type)
  DB   000h ;6400                                (Min Sampling Rate)
  DB   019h ;"  "
  DB   000h ;"  "
  DB   080h ;48000                               (Max Sampling Rate)
  DB   0BBh ;"   "
  DB   000h ;"   "

  DB   009h ;9                                   (Descr Size)
  DB   005h ;EndPoint                            (Descr Type)
  DB   084h ;EndPoint = 4  Direction = In        (End Point Number)
  DB   009h ;Isochronous Adaptive Data           (Attributes)
  DW 00064h ;100                                 (Max Packet Size)
  DB   001h ;1                                   (Max Poll Interval)
  DB   000h ;1 mS                                (Refresh Rate)
  DB   000h ;0                                   (Synch End Point)

  DB   007h ;7                                   (Descr Size)
  DB   025h ;Audio EndPoint                      (Descr Type)
  DB   001h ;General Audio EndPoint              (Descriptor SubType)
  DB   001h ;EndPoint Attributes                 (Supported Attributes)
  DB   002h ;Decoded PCM Samples                 (Lock Delay Units)
  DW 00001h ;1                                   (Lock Delay Value)

  DB   009h ;9                                   (Descr Size)
  DB   004h ;Interface                           (Descr Type)
  DB   002h ;2                                   (Interface Number)
  DB   003h ;3                                   (Alternate Setting)
  DB   001h ;1                                   (# of Endpoints)
  DB   001h ;Audio                               (Intf Class)
  DB   002h ;Audio Streaming                     (Intf SubClass)
  DB   000h ;None                                (Intf Protocol)
  DB   000h ;None                                (Interface String)

  DB   007h ;7                                   (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   001h ;General Stream                      (Descr SubType)
  DB   00Dh ;13                                  (Terminal Link ID)
  DB   000h ;0                                   (Delay in Frames)
  DW 00001h ;Pulse Code Modulation               (Audio Format)

  DB   00Eh ;14                                  (Descr Size)
  DB   024h ;Audio Interface                     (Descr Type)
  DB   002h ;Stream Format Type                  (Descr SubType)
  DB   001h ;Type 1 (PCM)                        (Format Type)
  DB   002h ;2                                   (Number of Channels)
  DB   002h ;2                                   (SubSlot Size)
  DB   010h ;16                                  (Resolution Bits)
  DB   000h ;Continuous                          (Sampling Rate Type)
  DB   000h ;6400                                (Min Sampling Rate)
  DB   019h ;"  "
  DB   000h ;"  "
  DB   080h ;48000                               (Max Sampling Rate)
  DB   0BBh ;"   "
  DB   000h ;"   "

  DB   009h ;9                                   (Descr Size)
  DB   005h ;EndPoint                            (Descr Type)
  DB   084h ;EndPoint = 4  Direction = In        (End Point Number)
  DB   009h ;Isochronous Adaptive Data           (Attributes)
  DW 000C8h ;200                                 (Max Packet Size)
  DB   001h ;1                                   (Max Poll Interval)
  DB   000h ;1 mS                                (Refresh Rate)
  DB   000h ;0                                   (Synch End Point)

  DB   007h ;7                                   (Descr Size)
  DB   025h ;Audio EndPoint                      (Descr Type)
  DB   001h ;General Audio EndPoint              (Descriptor SubType)
  DB   001h ;EndPoint Attributes                 (Supported Attributes)
  DB   002h ;Decoded PCM Samples                 (Lock Delay Units)
  DW 00001h ;1                                   (Lock Delay Value)

  DB   009h ;9                                   (Descr Size)
  DB   004h ;Interface                           (Descr Type)
  DB   003h ;3                                   (Interface Number)
  DB   000h ;0                                   (Alternate Setting)
  DB   001h ;1                                   (# of Endpoints)
  DB   003h ;HID (Human Interface Device)        (Intf Class)
  DB   000h ;None                                (Intf SubClass)
  DB   000h ;None                                (Intf Protocol)
  DB   000h ;None                                (Interface String)

;  DB   009h ;9
  DB   00Fh ;15                                  (Descr Size)
  DB   021h ;HID (Human Interface Device)        (Descr Type)
  DW 00100h ;1.00                                (HID Version)
  DB   000h ;None/Not Applicable                 (Country Code)
  DB   003h ;3                                   (Number of Classes)
  DB   022h ;Report                              (Class Type 1)
  DW 00039h ;57                                  (Class Size 1)
  DB   001h ;Unknown!                            (Class Type 2)
  DW 00039h ;57                                  (Class Size 2)
  DB   023h ;Physical                            (Class Type 3)
  DW 0001Fh ;31                                  (Class Size 3)

  DB   007h ;7
  DB   005h ;EndPoint                            (Descr Size)
  DB   083h ;EndPoint = 3  Direction = In        (Descr Type)
  DB   003h ;Interrupt NonSynchronous Data       (End Point Number)
  DW 00002h ;2                                   (Attributes)
  DB   003h ;3                                   (Max Packet Size)

  DB  000h  ;End of Descriptor Set


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Miscellaneous General Descriptors we don't normally see.
;These are produced by me, so may not resemble reality!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  DB   008h ;8                                    (Descr Size)
  DB   003h ;String                               (Descr Type)
  DW 01C09h ;English - South Africa
  DW 00C07h ;German - Austria
  DW 0140Ah ;Spanish - Costa Rica

  DB   010h ;16                                   (Descr Size)
  DB   003h ;String                               (Descr Type)
  DB 'T',0  ;T
  DB 'e',0  ;e
  DB 's',0  ;s
  DB 't',0  ;t
  DB ' ',0  ;Space
  DW 01111h ;Invalid Char
  DB ' ',0  ;Space

  DB   00Ah ;10                                   (Descr Size)
  DB   006h ;Device Qualifier                     (Descr Type)
  DW 00200h ;02.00
  DB   009h ;Hub
  DB   000h ;None
  DB   000h ;None
  DB   040h ;64
  DB   001h ;1
  DB   002h ;2

  DB   009h ;9                                    (Descr Size)
  DB   007h ;Other Speed Configuration            (Descr Type)
  DW 00064h ;100
  DB   001h ;1
  DB   002h ;2
  DB   000h ;None
  DB   080h ;Bus_Powered No_Remote_Wakeup
  DB   032h ;50 (100 mA)

  DB   010h ;16                                   (Descr Size)
  DB   008h ;Interface Power (Obsolete)           (Descr Type)
  DB   003h
  DB   004h
  DB   005h
  DB   006h
  DB   007h
  DB   008h
  DB   009h
  DB   00Ah
  DB   00Bh
  DB   00Ch
  DB   00Dh
  DB   00Eh
  DB   00Fh
  DB   010h

  DB   003h ;3                                    (Descr Size)
  DB   009h ;On-The-Go                            (Descr Type)
  DB   001h ;SRP Supported

  DB   004h ;4                                    (Descr Size)
  DB   00Ah ;Debug                                (Descr Type)
  DB   001h ;1
  DB   002h ;2

  DB   008h ;8                                    (Descr Size)
  DB   00Bh ;Interface Association                (Descr Type)
  DB   001h ;1
  DB   002h ;2
  DB   003h ;3
  DB   004h ;4
  DB   005h ;5
  DB   000h ;0

  ;Incomplete!!
  DB   008h ;8                                    (Descr Size)
  DB   00Ch ;Wireless USB Security                (Descr Type)
  DB   001h ;1
  DB   002h ;2
  DB   003h ;3
  DB   004h ;4
  DB   005h ;5
  DB   006h ;6

  ;Incomplete!!
  DB   008h ;8                                    (Descr Size)
  DB   00Dh ;Wireless USB Key                     (Descr Type)
  DB   001h ;1
  DB   002h ;2
  DB   003h ;3
  DB   004h ;4
  DB   005h ;5
  DB   006h ;6

  ;Incomplete!!
  DB   008h ;8                                    (Descr Size)
  DB   00Eh ;Wireless USB Encryption Type         (Descr Type)
  DB   001h ;1
  DB   002h ;2
  DB   003h ;3
  DB   004h ;4
  DB   005h ;5
  DB   006h ;6

  ;Incomplete!!
  DB   005h ;5                                    (Descr Size)
  DB   00Fh ;Wireless USB Binary Object Store     (Descr Type)
  DW 00064h ;100                                  (Total Size)
  DB   006h ;6                                    (# of Capability Descrs)

  ;Incomplete!!
  DB   008h ;8                                    (Descr Size)
  DB   010h ;Wireless USB Device Capability       (Descr Type)
  DB   001h ;1
  DB   002h ;2
  DB   003h ;3
  DB   004h ;4
  DB   005h ;5
  DB   006h ;6

  ;Incomplete!!
  DB   008h ;8                                    (Descr Size)
  DB   011h ;Wireless USB Endpoint Companion      (Descr Type)
  DB   001h ;1
  DB   002h ;2
  DB   003h ;3
  DB   004h ;4
  DB   005h ;5
  DB   006h ;6


  DB  000h  ;End of Descriptor Set


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;Test Hub Descriptor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  DB   012h ;18
;  DB   001h ;Device
;  DW 00110h ;1.10
;  DB   009h ;Hub
;  DB   000h ;None
;  DB   000h ;None
;  DB   008h ;8
;  DW 0047Fh ;Plantronics Inc
;  DW 00CA1h ;3,233
;  DW 00004h ;0.04
;  DB   000h ;None
;  DB   000h ;None
;  DB   000h ;None
;  DB   001h ;1
;
;  DB   009h ;9
;  DB   002h ;Configuration
;  DW 00064h ;100
;  DB   004h ;1
;  DB   001h ;1
;  DB   000h ;None
;  DB   080h ;Bus_Powered No_Remote_Wakeup
;  DB   032h ;50 (100 mA)
;
;  DB   009h ;9
;  DB   004h ;Interface
;  DB   000h ;0
;  DB   000h ;0
;  DB   000h ;0
;  DB   009h ;Hub
;  DB   000h ;None
;  DB   000h ;None
;  DB   000h ;None
;
;  DB   00Ah ;10
;  DB   029h ;Hub
;  DB   00Ah ;10 Ports
;  DW 00044h ;Attributes = Gang Pwr, Cmpd Dvc, Glob Curr, 24 Bits, HW LEDs
;  DB   005h ;Power Good Time = 10mS
;  DB   00Ah ;Current Draw = 10 mA
;  DB   006h ;Unremovable Ports = 1, 2
;  DB   007h ; 8, 9, 10
;  DB   0FFh ;Power Port (Obsolete)
;
;  DB  000h  ;End of Descriptor Set

  DB  000h  ;End of Test Descriptor Table


;=============================================================================
;Sample MIDI Descriptor (from Spec)
;=============================================================================

;Appendix B. Example: Simple MIDI Adapter (Informative)
;
;B.1 Device Descriptor
;Table B-1: MIDI Adapter Device Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x12 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x01 DEVICE descriptor.
;2 bcdUSB 2 0x0110 1.10 - current revision of USB specification.
;4 bDeviceClass 1 0x00 Device defined at Interface level.
;5 bDeviceSubClass 1 0x00 Unused.
;6 bDeviceProtocol 1 0x00 Unused.
;7 bMaxPacketSize0 1 0x08 8 bytes.
;8 idVendor 2 0xXXXX Vendor ID.
;10 idProduct 2 0xXXXX Product ID.
;12 bcdDevice 2 0xXXXX Device Release Code.
;14 iManufacturer 1 0x01 Index to string descriptor that contains the string <Your Name> in Unicode.
;15 iProduct 1 0x02 Index to string descriptor that contains the string <Your Product Name> in Unicode.
;16 iSerialNumber 1 0x00 Unused.
;17 bNumConfigurations 1 0x01 One configuration.
;
;B.2 Configuration Descriptor
;Table B-2: MIDI Adapter Configuration Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x02 CONFIGURATION descriptor.
;2 wTotalLength 2 0x00XX Length of the total configuration block,including this descriptor, in bytes.
;4 bNumInterfaces 1 0x02 Two interfaces.
;5 bConfigurationValue 1 0x01 ID of this configuration.
;6 iConfiguration 1 0x00 Unused.
;7 bmAttributes 1 0x80 Bus Powered device, not Self Powered, no Remote wakeup capability.
;8 MaxPower 1 0x32 100 mA Max. power consumption.
;
;Table B-3: MIDI Adapter Standard AC Interface Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x04 INTERFACE descriptor.
;2 bInterfaceNumber 1 0x00 Index of this interface.
;3 bAlternateSetting 1 0x00 Index of this setting.
;4 bNumEndpoints 1 0x00 0 endpoints.
;5 bInterfaceClass 1 0x01 AUDIO.
;6 bInterfaceSubclass 1 0x01 AUDIO_CONTROL.
;7 bInterfaceProtocol 1 0x00 Unused.
;8 iInterface 1 0x00 Unused.
;
;Table B-4: MIDI Adapter Class-specific AC Interface Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE.
;2 bDescriptorSubtype 1 0x01 HEADER subtype.
;3 bcdADC 2 0x0100 Revision of class specification - 1.0
;5 wTotalLength 2 0x0009 Total size of class specific descriptors.
;7 bInCollection 1 0x01 Number of streaming interfaces.
;8 baInterfaceNr(1) 1 0x01 MIDIStreaming interface 1 belongs to this AudioControl interface.
;
;Table B-5: MIDI Adapter Standard MS Interface Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x04 INTERFACE descriptor.
;2 bInterfaceNumber 1 0x01 Index of this interface.
;3 bAlternateSetting 1 0x00 Index of this alternate setting.
;4 bNumEndpoints 1 0x02 2 endpoints.
;5 bInterfaceClass 1 0x01 AUDIO.
;6 bInterfaceSubclass 1 0x03 MIDISTREAMING.
;7 bInterfaceProtocol 1 0x00 Unused.
;8 iInterface 1 0x00 Unused.
;
;Table B-6: MIDI Adapter Class-specific MS Interface Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x07 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE descriptor.
;2 bDescriptorSubtype 1 0x01 MS_HEADER subtype.
;3 BcdADC 2 0x0100 Revision of this class specification.
;5 wTotalLength 2 0x0041 Total size of class-specific descriptors.
;
;Table B-7: MIDI Adapter MIDI IN Jack Descriptor (Embedded)
;Offset Field Size Value Description
;0 bLength 1 0x06 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE descriptor.
;2 bDescriptorSubtype 1 0x02 MIDI_IN_JACK subtype.
;3 bJackType 1 0x01 EMBEDDED.
;4 bJackID 1 0x01 ID of this Jack.
;5 iJack 1 0x00 Unused
;
;Table B-8: MIDI Adapter MIDI IN Jack Descriptor (External)
;Offset Field Size Value Description
;0 bLength 1 0x06 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE descriptor.
;2 bDescriptorSubtype 1 0x02 MIDI_IN_JACK subtype.
;3 bJackType 1 0x02 EXTERNAL.
;4 bJackID 1 0x02 ID of this Jack.
;5 iJack 1 0x00 Unused.
;
;Table B-9: MIDI Adapter MIDI OUT Jack Descriptor (Embedded)
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE descriptor.
;2 bDescriptorSubtype 1 0x03 MIDI_OUT_JACK subtype.
;3 bJackType 1 0x01 EMBEDDED.
;4 bJackID 1 0x03 ID of this Jack.
;5 bNrInputPins 1 0x01 Number of Input Pins of this Jack.
;6 BaSourceID(1) 1 0x02 ID of the Entity to which this Pin is connected.
;7 BaSourcePin(1) 1 0x01 Output Pin number of the Entity to which this Input Pin is connected.
;8 iJack 1 0x00 Unused.
;
;Table B-10: MIDI Adapter MIDI OUT Jack Descriptor (External)
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE descriptor.
;2 bDescriptorSubtype 1 0x03 MIDI_OUT_JACK subtype.
;3 bJackType 1 0x02 EXTERNAL.
;4 bJackID 1 0x04 ID of this Jack.
;5 bNrInputPins 1 0x01 Number of Input Pins of this Jack.
;6 BaSourceID(1) 1 0x01 ID of the Entity to which this Pin is connected.
;7 BaSourcePin(1) 1 0x01 Output Pin number of the Entity to which this Input Pin is connected.
;8 iJack 1 0x00 Unused.
;
;Table B-11: MIDI Adapter Standard Bulk OUT Endpoint Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x05 ENDPOINT descriptor.
;2 bEndpointAddress 1 0x01 OUT Endpoint 1.
;3 bmAttributes 1 0x02 Bulk, not shared.
;4 wMaxPacketSize 2 0x0040 64 bytes per packet.
;6 bInterval 1 0x00 Ignored for Bulk. Set to zero.
;7 bRefresh 1 0x00 Unused.
;8 bSynchAddress 1 0x00 Unused.
;
;Table B-12: MIDI Adapter Class-specific Bulk OUT Endpoint Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x05 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x25 CS_ENDPOINT descriptor
;2 bDescriptorSubtype 1 0x01 MS_GENERAL subtype.
;3 bNumEmbMIDIJack 1 0x01 Number of embedded MIDI IN Jacks.
;4 BaAssocJackID(1) 1 0x01 ID of the Embedded MIDI IN Jack.
;
;Table B-13: MIDI Adapter Standard Bulk IN Endpoint Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x05 ENDPOINT descriptor.
;2 bEndpointAddress 1 0x81 IN Endpoint 1.
;3 bmAttributes 1 0x02 Bulk, not shared.
;4 wMaxPacketSize 2 0x0040 64 bytes per packet.
;6 bInterval 1 0x00 Ignored for Bulk. Set to zero.
;7 bRefresh 1 0x00 Unused.
;8 bSynchAddress 1 0x00 Unused.
;
;Table B-14: MIDI Adapter Class-specific Bulk IN Endpoint Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x05 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x25 CS_ENDPOINT descriptor
;2 bDescriptorSubtype 1 0x01 MS_GENERAL subtype.
;3 bNumEmbMIDIJack 1 0x01 Number of embedded MIDI OUT Jacks.
;4 BaAssocJackID(1) 1 0x03 ID of the Embedded MIDI OUT Jack.


;=============================================================================
;Sample Audio v1 Descriptor #1 (from Spec)
;=============================================================================
;
;Appendix B. Example 1: USB Microphone (Informative)
;
;Table B-1: USB Microphone Device Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x12 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x01 DEVICE descriptor.
;2 bcdUSB 2 0x0100 1.00 - current revision of USB specification.
;4 bDeviceClass 1 0x00 Device defined at Interface level.
;5 bDeviceSubClass 1 0x00 Unused.
;6 bDeviceProtocol 1 0x00 Unused.
;7 bMaxPacketSize0 1 0x08 8 bytes.
;8 idVendor 2 0xXXXX Vendor ID.
;10 idProduct 2 0xXXXX Product ID.
;
;12 bcdDevice 2 0xXXXX Device Release Code.
;14 iManufacturer 1 0x01 Index to string descriptor that contains the string <Your Name> in Unicode.
;15 iProduct 1 0x02 Index to string descriptor that contains the string <Your Product Name> in Unicode.
;16 iSerialNumber 1 0x00 Unused.
;17 bNumConfigurations 1 0x01 One configuration.
;
;
;Table B-2: USB Microphone Configuration Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x02 CONFIGURATION descriptor.
;2 wTotalLength 2 0x0064 Length of the total configuration block, including this descriptor, in bytes.
;4 bNumInterfaces 1 0x02 Two interfaces.
;5 bConfigurationValue 1 0x01 ID of this configuration.
;6 iConfiguration 1 0x00 Unused.
;7 bmAttributes 1 0x80 Bus Powered device, not Self Powered, no Remote wakeup capability.
;8 MaxPower 1 0x0A 20 mA Max. power consumption.
;
;Table B-3: USB Microphone Standard AC Interface Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x04 INTERFACE descriptor.
;2 bInterfaceNumber 1 0x00 Index of this interface.
;3 bAlternateSetting 1 0x00 Index of this setting.
;4 bNumEndpoints 1 0x00 0 endpoints.
;5 bInterfaceClass 1 0x01 AUDIO.
;6 bInterfaceSubclass 1 0x01 AUDIO_CONTROL.
;7 bInterfaceProtocol 1 0x00 Unused.
;8 iInterface 1 0x00 Unused.
;
;Table B-4: USB Microphone Class-specific AC Interface Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE.
;2 bDescriptorSubtype 1 0x01 HEADER subtype.
;3 bcdADC 2 0x0100 Revision of class specification - 1.0
;5 wTotalLength 2 0x001E Total size of class specific descriptors.
;7 bInCollection 1 0x01 Number of streaming interfaces.
;8 baInterfaceNr(1) 1 0x01 AudioStreaming interface 1 belongs to this AudioControl interface.
;
;Table B-5: USB Microphone Input Terminal Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x0C Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE.
;2 bDescriptorSubtype 1 0x02 INPUT_TERMINAL subtype.
;3 bTerminalID 1 0x01 ID of this Input Terminal.
;4 wTerminalType 2 0x0201 Terminal is Microphone.
;6 bAssocTerminal 1 0x00 No association.
;7 bNrChannels 1 0x01 One channel.
;8 wChannelConfig 2 0x0000 Mono sets no position bits.
;10 iChannelNames 1 0x00 Unused.
;11 iTerminal 1 0x00 Unused.
;
;Table B-6: USB Microphone Output Terminal Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE.
;2 bDescriptorSubtype 1 0x03 OUTPUT_TERMINAL subtype.
;3 bTerminalID 1 0x02 ID of this Output Terminal.
;4 wTerminalType 2 0x0101 USB Streaming.
;6 bAssocTerminal 1 0x00 Unused.
;7 bSourceID 1 0x01 From Input Terminal.
;8 iTerminal 1 0x00 Unused.
;
;Table B-7: USB Microphone Standard AS Interface Descriptor (Alt. Set. 0)
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x04 INTERFACE descriptor.
;2 bInterfaceNumber 1 0x01 Index of this interface.
;3 bAlternateSetting 1 0x00 Index of this alternate setting.
;4 bNumEndpoints 1 0x00 0 endpoints.
;5 bInterfaceClass 1 0x01 AUDIO.
;6 bInterfaceSubclass 1 0x02 AUDIO_STREAMING.
;7 bInterfaceProtocol 1 0x00 Unused.
;8 iInterface 1 0x00 Unused.
;
;Table B-8: USB Microphone Standard AS Interface Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x04 INTERFACE descriptor.
;2 bInterfaceNumber 1 0x01 Index of this interface.
;3 bAlternateSetting 1 0x01 Index of this alternate setting.
;4 bNumEndpoints 1 0x01 One endpoint.
;5 bInterfaceClass 1 0x01 AUDIO.
;6 bInterfaceSubclass 1 0x02 AUDIO_STREAMING.
;7 bInterfaceProtocol 1 0x00 Unused.
;8 iInterface 1 0x00 Unused.
;
;Table B-9: USB Microphone Class-specific AS General Interface Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x07 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE descriptor.
;2 bDescriptorSubtype 1 0x01 GENERAL subtype.
;3 bTerminalLink 1 0x02 Unit ID of the Output Terminal.
;4 bDelay 1 0x01 Interface delay.
;5 wFormatTag 2 0x0001 PCM Format.
;
;Table B-10: USB Microphone Type I Format Type Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x0B Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE descriptor.
;2 bDescriptorSubtype 1 0x02 FORMAT_TYPE subtype.
;3 bFormatType 1 0x01 FORMAT_TYPE_I.
;4 bNrChannels 1 0x01 One channel.
;5 bSubFrameSize 1 0x02 Two bytes per audio subframe.
;6 bBitResolution 1 0x10 16 bits per sample.
;7 bSamFreqType 1 0x01 One frequency supported.
;8 tSamFreq 3 0x01F40 8000Hz.
;
;Table B-11: USB Microphone Standard Endpoint Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x05 ENDPOINT descriptor.
;2 bEndpointAddress 1 0x81 IN Endpoint 1.
;3 bmAttributes 1 0x01 Isochronous, not shared.
;4 wMaxPacketSize 2 0x0010 16 bytes per packet.
;6 bInterval 1 0x01 One packet per frame.
;7 bRefresh 1 0x00 Unused.
;8 bSynchAddress 1 0x00 Unused.
;
;Table B-12: USB Microphone Class-specific Isoc. Audio Data Endpoint Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x07 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x25 CS_ENDPOINT descriptor
;2 bDescriptorSubtype 1 0x01 GENERAL subtype.
;3 bmAttributes 1 0x00 No sampling frequency control, no pitch control, no packet padding.
;4 bLockDelayUnits 1 0x00 Unused.
;5 wLockDelay 2 0x0000 Unused.


;=============================================================================
;Sample Audio v1 Descriptor #1 (from Spec)
;=============================================================================
;
;Appendix C. Example 2: USB Telephone (Informative)
;
;Table C-1: USB Telephone Device Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x12 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x01 DEVICE descriptor.
;2 bcdUSB 2 0x0100 1.00 - current revision of USB spec.
;4 bDeviceClass 1 0x00 Device defined at Interface level.
;5 bDeviceSubClass 1 0x00 Unused.
;6 bDeviceProtocol 1 0x00 Unused.
;7 bMaxPacketSize0 1 0x08 8 bytes.
;8 idVendor 2 0xXXXX Vendor ID.
;10 idProduct 2 0xXXXX Product ID.
;12 bcdDevice 2 0xXXXX Device Release Code.
;14 iManufacturer 1 0x01 Index to string descriptor that contains the string <Your Name> in Unicode.
;15 iProduct 1 0x02 Index to string descriptor that contains the string <Your Product Name> in Unicode.
;16 iSerialNumber 1 0x00 Unused.
;17 bNumConfigurations 1 0x01 One configuration.
;
;Table C-2: USB Telephone Configuration Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x02 CONFIGURATION descriptor.
;2 wTotalLength 2 0x00XX Length of the total configuration block, including this descriptor, in bytes.
;4 bNumInterfaces 1 0x03 Three interfaces
;5 bConfigurationValue 1 0x01 ID of this configuration
;6 iConfiguration 1 0x00 Unused.
;7 bmAttributes 1 0x60 Self Powered Remote Wakeup capable.
;8 MaxPower 1 0x00 Not applicable.
;
;Table C-3: USB Telephone Standard AC Interface Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x04 INTERFACE descriptor.
;2 bInterfaceNumber 1 0x00 Index of this interface.
;3 bAlternateSetting 1 0x00 Index of this setting.
;4 bNumEndpoints 1 0x00 0 endpoints.
;5 bInterfaceClass 1 0x01 AUDIO.
;6 bInterfaceSubclass 1 0x01 AUDIO_CONTROL.
;7 bInterfaceProtocol 1 0x00 Unused.
;8 iInterface 1 0x00 Unused.
;
;Table C-4: USB Telephone Class-specific Interface Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x0A Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE.
;2 bDescriptorSubtype 1 0x01 HEADER subtype.
;3 bcdADC 2 0x0100 Revision of class specification - 1.0
;5 wTotalLength 2 0x0064 Total size of class specific descriptors.
;7 bInCollection 1 0x02 Number of streaming interfaces
;8 baInterfaceNr(1) 1 0x01 AudioStreaming interface 1 belongs to this AudioControl interface.
;9 BaInterfaceNr(2) 1 0x02 AudioStreaming interface 2 belongs to this AudioControl interface.
;
;Table C-5: USB Telephone Input Terminal Descriptor (ID1)
;Offset Field Size Value Description
;0 bLength 1 0x0C Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE.
;2 bDescriptorSubtype 1 0x02 INPUT_TERMINAL subtype.
;3 bTerminalID 1 0x01 ID of this Terminal.
;4 wTerminalType 2 0x0501 Terminal is Phone Line In.
;6 bAssocTerminal 1 0x04 Associated with Phone Line Out Terminal.
;7 bNrChannels 1 0x01 One channel.
;8 wChannelConfig 2 0x0000 Mono sets no position bits.
;10 iChannelNames 1 0x00 Unused.
;11 iTerminal 1 0x00 Unused.
;
;Table C-6: USB Telephone Input Terminal Descriptor (ID2)
;Offset Field Size Value Description
;0 bLength 1 0x0C Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE.
;2 bDescriptorSubtype 1 0x02 INPUT_TERMINAL subtype.
;3 bTerminalID 1 0x02 ID of this Terminal.
;4 wTerminalType 2 0x0401 Terminal is Handset In.
;6 bAssocTerminal 1 0x05 Associated with Handset Out Terminal.
;7 bNrChannels 1 0x01 One channel.
;8 wChannelConfig 2 0x0000 Mono sets no position bits.
;10 iChannelNames 1 0x00 Unused.
;11 iTerminal 1 0x04 Unused.
;
;Table C-7: USB Telephone Input Terminal Descriptor (ID3)
;Offset Field Size Value Description
;0 bLength 1 0x0C Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE.
;2 bDescriptorSubtype 1 0x02 INPUT_TERMINAL subtype.
;3 bTerminalID 1 0x03 ID of this Terminal.
;4 wTerminalType 2 0x0101 Terminal is USB Streaming In.
;6 bAssocTerminal 1 0x06 Associated with USB Streaming out Terminal.
;7 bNrChannels 1 0x01 One channel.
;8 wChannelConfig 2 0x0000 Mono sets no position bits.
;10 iChannelNames 1 0x00 Unused.
;11 iTerminal 1 0x05 Unused.
;
;Table C-8: USB Telephone Output Terminal Descriptor (ID4)
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE.
;2 bDescriptorSubtype 1 0x03 OUTPUT_TERMINAL subtype.
;3 bTerminalID 1 0x04 ID of this Terminal.
;4 wTerminalType 2 0x0501 Terminal is Phone Line Out.
;6 bAssocTerminal 1 0x01 Associated with Phone Line In Terminal.
;7 bSourceID 1 0x07 From Phone Line Selector Unit.
;8 iTerminal 1 0x06 Unused.
;
;Table C-9: USB Telephone Output Terminal Descriptor (ID5)
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE.
;2 bDescriptorSubtype 1 0x03 OUTPUT_TERMINAL subtype.
;3 bTerminalID 1 0x05 ID of this Terminal.
;4 wTerminalType 2 0x0401 Terminal is Handset Out.
;6 bAssocTerminal 1 0x01 Associated with Handset In Terminal.
;7 bSourceID 1 0x08 From Handset Selector Unit.
;8 iTerminal 1 0x00 Unused.
;
;Table C-10: USB Telephone Output Terminal Descriptor (ID6)
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE.
;2 bDescriptorSubtype 1 0x03 OUTPUT_TERMINAL subtype.
;3 bTerminalID 1 0x06 ID of this Terminal.
;4 wTerminalType 2 0x0101 Terminal is USB Streaming Out.
;6 bAssocTerminal 1 0x03 Associated with USB Streaming In Terminal.
;7 bSourceID 1 0x09 From USB Selector Unit.
;8 iTerminal 1 0x00 Unused.
;
;Table C-11: USB Telephone Selector Unit Descriptor (ID7)
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE.
;2 bDescriptorSubtype 1 0x05 SELECTOR_UNIT subtype.
;3 bUnitD 1 0x07 ID of this Unit.
;4 bNrInPins 1 0x02 Number of input pins.
;6 baSourceID(1) 1 0x02 From Handset In Terminal.
;7 baSourceID(2) 1 0x03 From USB Streaming In Terminal.
;8 iSelector 1 0x00 Unused.
;
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE.
;2 bDescriptorSubtype 1 0x05 SELECTOR_UNIT subtype.
;3 bUnitD 1 0x08 ID of this Unit.
;4 bNrInPins 1 0x02 Number of input pins.
;6 baSourceID(1) 1 0x01 From Phone Line In Terminal.
;7 baSourceID(2) 1 0x03 From USB Streaming In Terminal.
;8 iSelector 1 0x00 Unused.
;
;Table C-13: USB Telephone Selector Unit Descriptor (ID9)
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE.
;2 bDescriptorSubtype 1 0x05 SELECTOR_UNIT subtype.
;3 bUnitD 1 0x09 ID of this Unit
;4 bNrInPins 1 0x02 Number of input pins.
;6 baSourceID(1) 1 0x01 From Phone Line In Terminal.
;7 baSourceID(2) 1 0x02 From Handset In Terminal.
;8 iSelector 1 0x00 Unused.
;
;Table C-14: USB Telephone Standard Interface Descriptor (Alt. Set. 0)
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x04 INTERFACE descriptor.
;2 bInterfaceNumber 1 0x01 Index of this interface.
;3 bAlternateSetting 1 0x00 Index of this setting.
;4 bNumEndpoints 1 0x00 0 endpoints.
;5 bInterfaceClass 1 0x01 AUDIO.
;6 bInterfaceSubclass 1 0x02 AUDIO_STREAMING.
;7 bInterfaceProtocol 1 0x00 Unused.
;8 iInterface 1 0x00 Unused.
;
;Table C-15: USB Telephone Standard AS Interface Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x04 INTERFACE descriptor.
;2 bInterfaceNumber 1 0x01 Index of this interface.
;3 bAlternateSetting 1 0x01 Index of this setting.
;4 bNumEndpoints 1 0x01 1 endpoint.
;5 bInterfaceClass 1 0x01 AUDIO.
;6 bInterfaceSubclass 1 0x02 AUDIO_STREAMING.
;7 bInterfaceProtocol 1 0x00 Unused.
;8 iInterface 1 0x00 Unused.
;
;Table C-16: USB Telephone Class-specific AS Interface Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x07 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE descriptor.
;2 bDescriptorSubtype 1 0x01 GENERAL.
;3 bTerminalLink 1 0x03 Linked to USB Streaming In Terminal.
;4 bDelay 1 0x01 Interface delay.
;5 wFormatTag 2 0x0001 PCM format.
;
;Table C-17: USB Telephone Type I Format Type Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x0B Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE.
;2 bDescriptorSubtype 1 0x02 FORMAT_TYPE.
;3 bFormatType 1 0x01 FORMAT_TYPE_I.
;4 bNrChannels 1 0x01 One channel.
;5 bSubFrameSize 1 0x02 Two bytes per slot.
;6 bBitResolution 1 0x10 16 bits.
;7 bSamFreqType 1 0x01 One sampling frequency.
;8 tSamFreq 3 0x01F40 8000Hz is the sampling frequency.
;
;Table C-18: USB Telephone Standard Endpoint Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x05 ENDPOINT descriptor.
;2 bEndpointAddress 1 0x01 OUT Endpoint 1.
;3 bmAttributes 1 0x0B Isochronous transfer type, synchronous synchronization type.
;4 wMaxPacketSize 2 0x0010 16 bytes per packet (8 two-byte samples).
;6 bInterval 1 0x01 One packet every frame.
;7 bRefresh 1 0x00 Unused.
;8 bSynchAddress 1 0x00 Unused.
;
;Table C-19: USB Telephone Class-specific Isoc. Audio Data Endpoint Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x07 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x25 CS_ENDPOINT.
;2 bDescriptorSubtype 1 0x01 GENERAL.
;3 bmAttributes 1 0x00 No sampling frequency control, no pitch control.
;4 bLockDelayUnits 1 0x00 Unused.
;5 wLockDelay 2 0x0000 Unused.
;
;Table C-20: USB Telephone Standard Interface Descriptor (Alt. Set. 0)
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x04 INTERFACE descriptor.
;2 bInterfaceNumber 1 0x01 Index of this interface.
;3 bAlternateSetting 1 0x00 Index of this setting.
;4 bNumEndpoints 1 0x00 0 endpoints.
;5 bInterfaceClass 1 0x01 AUDIO.
;6 bInterfaceSubclass 1 0x02 AUDIO_STREAMING.
;7 bInterfaceProtocol 1 0x00 Unused.
;8 iInterface 1 0x00 Unused.
;
;Table C-21: USB Telephone Standard AS Interface Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x04 INTERFACE descriptor.
;2 bInterfaceNumber 1 0x01 Index of this interface.
;3 bAlternateSetting 1 0x01 Index of this setting.
;4 bNumEndpoints 1 0x01 1 endpoint.
;5 bInterfaceClass 1 0x01 AUDIO.
;6 bInterfaceSubclass 1 0x02 AUDIO_STREAMING.
;7 bInterfaceProtocol 1 0x00 Unused.
;8 iInterface 1 0x00 Unused.
;
;Table C-22: USB Telephone Class-specific AS Interface Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x07 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE descriptor.
;2 bDescriptorSubtype 1 0x01 GENERAL.
;3 bTerminalLink 1 0x06 USB Streaming Out Terminal
;4 bDelay 1 0x01 Interface delay.
;5 wFormatTag 2 0x0001 PCM format.
;
;Table C-23: USB Telephone Type I format type descriptor
;Offset Field Size Value Description
;0 bLength 1 0x0B Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x24 CS_INTERFACE.
;2 bDescriptorSubtype 1 0x02 FORMAT_TYPE.
;3 bFormatType 1 0x01 FORMAT_TYPE_I.
;4 bNrChannels 1 0x01 One channel.
;5 bSubFrameSize 1 0x02 Two bytes per slot.
;6 bBitResolution 1 0x10 16 bits.
;7 bSamFreqType 1 0x01 One sampling frequency.
;8 tSamFreq 3 0x01F40 8000Hz is the sampling frequency.
;
;Table C-24: USB Telephone Standard Endpoint descriptor
;Offset Field Size Value Description
;0 bLength 1 0x09 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x05 ENDPOINT descriptor.
;2 bEndpointAddress 1 0x81 IN Endpoint 1.
;3 bmAttributes 1 0x0B Isochronous transfer type, synchronous synchronization type.
;4 wMaxPacketSize 2 0x0010 16 bytes (8 two-byte samples).
;6 bInterval 1 0x01 One packet every frame.
;7 bRefresh 1 0x00 Unused
;8 bSynchAddress 1 0x00 Unused.
;
;Table C-25: USB Telephone Class-specific Isoc. Audio Data Endpoint Descriptor
;Offset Field Size Value Description
;0 bLength 1 0x07 Size of this descriptor, in bytes.
;1 bDescriptorType 1 0x25 CS_ENDPOINT.
;2 bDescriptorSubtype 1 0x01 GENERAL.
;3 bmAttributes 1 0x00 No sampling frequency control, no pitch
;control.
;4 bLockDelayUnits 1 0x00 Unused.
;5 wLockDelay 2 0x0000 Unused.




;There are no Sample Audio Version 2 Descriptors to be had!
;




;;=============================================================================
;;Sample Monitor Descriptor (HID) from Spec
;;=============================================================================
;DB 005h, 080h       ;USAGE_PAGE (Monitor)
;DB 009h, 001h       ;USAGE (Monitor Control)
;DB 0A1h, 001h       ;COLLECTION (Application)
;DB 085h, 001h       ;REPORT_ID (1)
;DB 015h, 000h       ;LOGICAL_MINIMUM (0)
;DB 026h, 0FFh, 000h ;LOGICAL_MAXIMUM (255)
;DB 075h, 008h       ;REPORT_SIZE (8)
;DB 095h, 080h       ;REPORT_COUNT (128)
;DB 009h, 002h       ;USAGE (EDID Information)
;DB 0B2h, 002h, 001h ;FEATURE (Data,Var,Abs,Buf)
;DB 085h, 002h       ;REPORT_ID (2)
;DB 095h, 0F3h       ;REPORT_COUNT (243)
;DB 009h, 003h       ;USAGE (VDIF Information)
;DB 0B2h, 002h, 001h ;FEATURE (Data,Var,Abs,Buf)
;DB 085h, 003h       ;REPORT_ID (3)
;DB 005h, 082h       ;USAGE_PAGE (VESA Virtual Controls)
;DB 075h, 010h       ;REPORT_SIZE (16)
;DB 095h, 001h       ;REPORT_COUNT (1)
;DB 026h, 0C8h, 000h ;LOGICAL_MAXIMUM (200)
;DB 009h, 010h       ;USAGE (Brightness)
;DB 0B1h, 002h       ;FEATURE (Data,Var,Abs)
;DB 085h, 004h       ;REPORT_ID (4)
;DB 025h, 064h       ;LOGICAL_MAXIMUM (100)
;DB 009h, 012h       ;USAGE (Contrast)
;DB 0B1h, 002h       ;FEATURE (Data,Var,Abs)
;DB 085h, 005h       ;REPORT_ID (5)
;DB 095h, 006h       ;REPORT_COUNT (6)
;DB 026h, 0FFh, 000h ;LOGICAL_MAXIMUM (255)
;DB 009h, 016h       ;USAGE (Video Gain Red)
;DB 009h, 018h       ;USAGE (Video Gain Green)
;DB 009h, 01Ah       ;USAGE (Video Gain Blue)
;DB 009h, 06Ch       ;USAGE (Video Black Level Red)
;DB 009h, 06Eh       ;USAGE (Video Black Level Green)
;DB 009h, 070h       ;USAGE (Video Black Level Blue)
;DB 0B1h, 002h       ;FEATURE (Data,Var,Abs)
;DB 085h, 006h       ;REPORT_ID (6)
;DB 025h, 07Fh       ;LOGICAL_MAXIMUM (127)
;DB 009h, 020h       ;USAGE (Horizontal Position )
;DB 009h, 022h       ;USAGE (Horizontal Size )
;DB 009h, 030h       ;USAGE (Vertical Position )
;DB 009h, 032h       ;USAGE (Vertical Size )
;DB 009h, 042h       ;USAGE (Trapezoidal Distortion)
;DB 009h, 044h       ;USAGE (Tilt)
;DB 0B1h, 002h       ;FEATURE (Data,Var,Abs)
;DB 075h, 002h       ;REPORT_SIZE (2)
;DB 095h, 001h       ;REPORT_COUNT (1)
;DB 015h, 001h       ;LOGICAL_MINIMUM (1)
;DB 025h, 003h       ;LOGICAL_MAXIMUM (3)
;DB 009h, 060h       ;USAGE (Input Source Select)
;DB 0A1h, 002h       ;COLLECTION (Logical)
;DB 005h, 081h       ;USAGE_PAGE (Monitor Enumerated Values)
;DB 009h, 001h       ;USAGE (ENUM 1)
;DB 009h, 004h       ;USAGE (ENUM 4)
;DB 009h, 006h       ;USAGE (ENUM 6)
;DB 0B1h, 000h       ;FEATURE (Data,Ary,Abs)
;DB 0C0h             ;END_COLLECTION
;DB 075h, 006h       ;REPORT_SIZE (6)
;DB 0B1h, 003h       ;FEATURE (Cnst,Var,Abs)
;DB 0C0h             ;END_COLLECTION
;
;DB 000h ;End of Descriptor












;------------------------------------------------------------------------------
;Switch to write the TestDescr.
;This can be eliminated in the final version of the program.
;------------------------------------------------------------------------------
DoSwitchTest:
  PUSH AX,CX,DI         ;Save used registers
  MOV  DI,TestDescr     ;Point at Table of Test Descriptors
  XOR  AX,AX            ;AH = 0
T10:                    ;Loop to here fore each Descriptor Set
  CALL WriteDescriptors ;Write the next set of Descriptors
T20:                    ;Loop to here to find the end of the Set
  MOV  AL,[DI]          ;Get the Descriptor Size
  OR   AL,AL            ;End of Descriptor Set?
  JZ  >T40              ;If so, handle it
  ADD  DI,AX            ;If not, point at the next Descriptor
  JMP  T20              ;Keep looking for the end of the Set
T40:                    ;End of Descriptor Set
  INC  DI               ;Skip over end-of-set marker
  CMP  B [DI],0         ;End of table?
  JE  >T90              ;If so, we're done
  CALL WriteCrLf        ;If not,
  CALL WriteCrLf        ;  move down
  MOV  AL,'±'           ;Write
  MOV  CL,79            ;  a
  CALL WriteChars       ;  Separator
  CALL WriteCrLf        ;Line
  CALL WriteChars       ;Write a
  CALL WriteCrLf        ;  Separator Line
  CALL WriteCrLf        ;Move
  CALL WriteCrLf        ;  down
  CALL WriteCrLf
  JMP  T10              ;Keep going until we're done
T90:                    ;Done
  POP  DI,CX,AX         ;Restore used regsiters
  RET









;ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
;CODE
;ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

;------------------------------------------------------------------------------
;DO THE PROGRAM THING!
;Inputs:
;Outputs: Lots of Stuff
;Changes: Everything
;------------------------------------------------------------------------------
Main:
  CLD                    ;Go forward with string functions
  MOV  SP,LastProgByte   ;Reset Stack Pointer
  CALL ResizeMemory      ;Resize our Memory Allocation
  CALL CopyNameToMCB     ;Copy our Program name to the MCB
  CALL SetupPauseNoHdr   ;Set up the Pause
  CALL TestParentShell   ;See if our Parent is a DOS Command Shell
  JNZ >M10               ;If not, don't write the Copyright
  MOV  DX,Copyright      ;If so, write the
  CALL WriteZPause       ;  Copyright message
M10:                     ;Copyright written, if appropriate
  CALL TestCompatibility ;Test for compatibility, quit if Error
  CALL SetupExec         ;Setup Exec Parameters
  CALL GetOurPath        ;Get the Pointer to Our Path
  CALL GetEnvPath        ;Get the Pointer to the Environment PATH
  CALL ParseCmdLine      ;Do what the user wants, quit if Error
  XOR  AX,AX             ;AL = ErrorLevel = 0
  MOV  DX,NoMsg          ;Write Nothing afterwards
;  JMP  Exit              ;QUIT

;------------------------------------------------------------------------------
;PRINT MESSAGE IN DX AND QUIT WITH ERRORLEVEL IN AL
;Inputs:  AL = Errorlevel to exit program with
;         DS:[DX] = Message to Print (to ERR)
;Outputs:
;Changes: Quits program
;------------------------------------------------------------------------------
Exit:
  OR   AL,AL       ;Was there an Error?
  JZ  >X80         ;If not, jump to handle a normal termination
  CALL BeepErr     ;If error, Beep Once
  CALL WriteZErr   ;Write message to ERR
  MOV  DX,CrLfMsg  ;Write a
  CALL WriteZErr   ;  new line
  JMP >X90         ;Jump to quit
X80:               ;No Error - Write to CON
  CALL WriteZPause ;Write the message to CON
X90:               ;We're done!!
  MOV  AH,4Ch      ;Service 4Ch (terminate program)
  INT  21h         ;Do it

;------------------------------------------------------------------------------
;MAKE SURE THE MCB (MEMORY CONTROL BLOCK) CONTAINS OUR PROGRAM NAME
;Inputs:  DS = Local Data Area
;         DS:RealName = ASCIIZ Real Name of our program
;         CLD Already Issued
;Outputs:
;Changes: Data in MCB
;NOTES:   This makes sure that the MCB (Memory Control Block) for our
;           program contains our program name.  DOS 4+ does this
;           automatically, but DOS versions 1-3 do not.  This code
;           does not verify whihc DOS version is in use, but simply
;           fills in the MCB no matter what.
;         Our program name is needed inthe MCB to make sure other programs
;           can identify that we are installed in memory.  This code should
;           be added to all TSR's, so that memory-mapping programs
;           (like MAPMEM or ISLOADED) can tell which TSR's are installed
;           in memory.  It should also be added to all programs that
;           EXEC other programs, so that the EXEC'd program can figure out
;           who called it.
;         Programs that are not TSR's and do not EXEC other programs
;           do not need this code.
;------------------------------------------------------------------------------
CopyNameToMCB:
  PUSH CX,DI,SI,ES              ;Save used registers
  MOV  CX,DS                    ;Point ES:[DI]
  DEC  CX                       ;  at the Owners Name
  MOV  ES,CX                    ;  in the MCB
  MOV  DI,(OFFSET MCBOwnerName) ;  of our program
  MOV  SI,RealName              ;Point DS:[SI] at our Program Name
  MOV  CX,4                     ;Copy 4 words (8 bytes)
  REP  MOVSW                    ;Copy our program name to the MCB
  POP  ES,SI,DI,CX              ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO DETERMINE WHO OUR PARENT PROGRAM IS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;COPY THE CAPITALIZED NAME OF OUR PARENT PROGRAM TO A LOCAL STRING (PARENTNAME)
;Inputs:  ParentIsShell = No
;Outputs: ParentIsShell = Yes if Parent Program has a Shell Name
;                         ZF = Set
;                       = No if Parent Program does not have a Shell Name
;                         ZF = Clear
;Changes:
;------------------------------------------------------------------------------
TestParentShell:
  PUSH AX,BX,DI,SI       ;Save used registers
  CALL GetParentNameCaps ;Get our Parents Capitalized Name
  JZ  >S80               ;If invalid, assume we're at a command-line
  MOV  SI,DOSShellTbl    ;Point at our table of Shell Names
S10:                     ;Loop to here for each table entry
  MOV  DI,ParentName     ;Point DI at our Parents Name
  MOV  BX,SI             ;Save the current table pointer
  CMP  B [BX],0          ;End of the Table?
  JE  >S90               ;If so, it's not a Command Shell
S20:                     ;Loop to here for each character in the string
  MOV  AL,[BX]           ;Get the next table character
  OR   AL,AL             ;End of the table string?
  JZ  >S40               ;If so, handle it
S30:                     ;Not end of table string
  CMP  AL,[DI]           ;Does the character match?
  JNE >S60               ;If not, try the next table entry
  INC  BX                ;If so, increment
  INC  DI                ;  our Pointers
  JMP  S20               ;and keep testing
S40:                     ;End of our table string
  CMP  B [DI],0          ;End of the Parents Name string?
  JE  >S80               ;If so, it's a match
S60:                     ;Not a match
  CALL SkipOverStringSI  ;Point at the next table entry
  JMP  S10               ;Keep going until we're done
S80:                     ;Is a Command Shell
  MOV  ParentIsShell,Yes ;Store the result for later
S90:                     ;Done
  CMP  ParentIsShell,Yes ;Set the return flag
  POP  SI,DI,BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY THE CAPITALIZED NAME OF OUR PARENT PROGRAM TO A LOCAL STRING (PARENTNAME)
;Inputs:  ES = Local Data Area
;         CLD already issued
;Outputs: ParentName
;         ZF = Clear if ParentName is valid (greater than 0 length)
;            = Set if Invalid (0-length, such as under the DOSBox program)
;Changes:
;------------------------------------------------------------------------------
GetParentNameCaps:
  PUSH AX,CX,DI,SI,DS         ;Save used registers
  MOV  AX,[PSPParentPSP]      ;Point DS at
  DEC  AX                     ;  the MCB of our
  MOV  DS,AX                  ;  Parents PSP
  MOV  SI,OFFSET MCBOwnerName ;Point DS:[SI] at the Owners name
  MOV  DI,ParentName          ;Point ES:[DI] at our storage area
  MOV  CX,8                   ;Copy 8 bytes
P10:                          ;Loop to here for each character
  LODSB                       ;Get the next byte
  CALL Capitalize             ;Capitalize it
  STOSB                       ;Store it
  LOOP P10                    ;Keep going until we're done
  CMP  ES:B ParentName[0],0   ;Set return flag
  POP  DS,SI,DI,CX,AX         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PARSE THE COMMAND LINE FOR SWITCHES AND OPTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PARSE THE COMMAND LINE FOR A SWITCH
;Inputs:
;Outputs:
;Changes:
;------------------------------------------------------------------------------
ParseCmdLine:
  PUSH AX,SI        ;Save used registers
  MOV  SI,81h       ;Point at command line tail
P10:                ;Look for the next switch
  CALL IsSpaceOrEOL ;Look for a valid character
  JZ  >P70          ;If End-of-Line, Error
  CALL GetSwitch    ;See if it matches one of our switches
  JNZ >P90          ;If a match, look for the next switch
P70:                ;Error
  MOV  DX,HelpMsg   ;Write the
  CALL WriteItDX    ;  Help Message
  MOV  DX,NoMsg     ;Write nothing
  XOR  AX,AX        ;AL = ErrorLevel = 0
  JMP  Exit         ;Print error message and quit
P90:                ;We're done
  POP  SI,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE SWITCH CHARACTERS, AND DO WHATEVER IT IS THEY'RE ASKING
;Inputs:  DS:[SI] = Command line pointer
;Outputs: Lots of stuff!!!
;         ZF = Set if Error
;            = Clear if OK
;Changes:
;------------------------------------------------------------------------------
GetSwitch:
  PUSH AX,BX          ;Save used registers
  MOV  BX,SwitchList  ;Point at the list of switch code words
  CALL GetCode        ;See if its a match
  JC  >S70            ;If not, error
  MOV  BX,SwitchTbl   ;Point at the Table of Offsets
  CALL Byte2WordTbl   ;Look for the Code Offset to perform
  JC  >S70            ;If not found, error
  CALL BX             ;If Found, perform the Code
  MOV  DX,NoMsg       ;Write nothing when done
  JMP >S90            ;And quit
S70:                  ;There's an error
  MOV  ParseError,Yes ;Mark the error flag
S90:                  ;We're done
  CMP  ParseError,Yes ;Set/Clear the error flag
  POP  BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;LOOK FOR A MATCHING ENTRY IN A BYTE-TO-WORD LOOKUP TABLE
;Inputs:      AL  = Byte to look for in the Table
;         DS:[BX] = Table to Look in
;         CLD already issued
;Outputs: CF = Clear if OK (Byte was found in the Table)
;              BX = Word from the Table
;            = Set if Error (Byte was not found in the Table)
;              BX = Unchanged
;Changes:
;NOTES: The end of the table is mark by a 0 byte.  The first byte of the
;         table can also be a 0, however, since the 0 is only looked for
;         starting with the second table entry.
;------------------------------------------------------------------------------
Byte2WordTbl:
  PUSH AX,SI    ;Save used registers
  MOV  AH,AL    ;Save original value we need to look for
  MOV  SI,BX    ;Point DS:[SI] at the Table
W10:            ;Loop to here for each table entry
  LODSB         ;Get the next byte from the table
  CMP  AL,AH    ;Is it the one we're looking for?
  JE  >W80      ;If so, we're done
  INC  SI,2     ;If not, skip over the word
  CMP  B [SI],0 ;End of the table?
  JNE  W10      ;If not, keep looking
W70:            ;No match
  STC           ;Set not-found flag
  JMP >W90      ;Done
W80:            ;Found it
  MOV  BX,[SI]  ;Set BX for the return
  CLC           ;Set found-it flag
W90:            ;Done
  POP  SI,AX    ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO GET A NUMBER FROM A STRING (HEX OR DECIMAL)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET A NUMBER FROM A STRING (CAN BE DECIMAL OR HEX)
;Inputs:  [SI] = String Pointer
;Outputs: CF = Clear if we got a valid number
;              AX = Number
;            = Set if Error (no number found)
;              AX = 0
;Changes: SI points at next byte after the number
;NOTES: A Hex String must start with '0x' and/or end in 'H'!
;------------------------------------------------------------------------------
GetNumber:
  PUSH BX           ;Save used registers
  MOV  BX,AX        ;Save original AX
  CALL IsSpaceOrEOL ;Skip past spaces
  JZ  >N70          ;If End-of-Line, Error
  CALL TestForHex   ;Is it a Hex Number?
  JC  >N20          ;If not, try a decimal
  CALL Test0xPrefix ;Skip over the 0x (C-style) prefix, if there
  CALL GetHex       ;If so, get it
  JNC >N80          ;If OK, we're done
  JMP >N70          ;If not, Error
N20:                ;Not Hex
  CALL GetDecimal   ;Try a Decimal
  JNC >N80          ;If OK, we're done
N70:                ;Error
  MOV  AX,BX        ;Restore original AX
  STC               ;Set Error Flag
  JMP >N90          ;Done
N80:                ;OK
  CLC               ;Set OK Flag
N90:                ;Done
  POP  BX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII STRING TO SEE IF IT IS A HEX STRING (ENDS IN H)
;Inputs:  [SI] = String to test
;Outputs: CF = Clear if it is a Hex String
;            = Set if Error (not a Hex String)
;Changes:
;NOTES: A valid Hex String will contain numerals 0-9, A-F, and Underscores,
;         and will end in an H.  It cannot contain spaces.
;------------------------------------------------------------------------------
TestForHex:
  PUSH AX,SI        ;Save used registers
  CALL Test0xPrefix ;Test for the 0x (C-style) prefix (changes SI)
  JNC >H80          ;If so, it's Hex
  MOV  AL,B [SI]    ;Get the first character
  CALL IsHexNumber  ;A valid Hex Number?
  JC  >H70          ;If not, Error
H10:                ;Loop to here for each character
  LODSB             ;Get the next character
  CALL IsHexNumber  ;A valid Hex Number?
  JNC  H10          ;If so, keep looking
  CMP  AL,'_'       ;An Underscore?
  JZ   H10          ;If so, keep looking
  CALL IsHexEnd     ;End of the Hex Number?
  JZ  >H80          ;If so, we're done
H70:                ;Not Hex
  STC               ;Set error Flag
  JMP >H90          ;Done
H80:                ;Is Hex
  CLC               ;Set OK Flag
H90:                ;Done
  POP  SI,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST FOR A 0x (C-STYLE) HEX PREFIX
;Inputs:  [SI] = String to test
;Outputs: CF = Set if not a 0x Prefix
;              SI unchanged
;            = Clear if not a 0x Prefix
;              [SI] = Character after the 0x
;Changes:
;------------------------------------------------------------------------------
Test0xPrefix:
  PUSH AX,BX       ;Save used registers
  MOV  BX,SI       ;Save original Pointer
  LODSB            ;Get the next character
  CMP  AL,'0'      ;Is it a 0?
  JNE >X70         ;If not, it's not a Prefix
X20:               ;Loop to here to skip over all zeroes
  LODSB            ;Get the next charcter
  CMP  AL,'0'      ;Is it another 0?
  JE   X20         ;If so, keep skipping the zeroes
  CALL Capitalize  ;If not, capitalize it
  CMP  AL,'X'      ;Is it an X?
  JNE >X70         ;If not, it's not a 0x Prefix
  LODSB            ;Get the next charcter
  CALL IsHexNumber ;Is it a Hex Number?
  JNC >X80         ;If so, it's a 0x Prefix
X70:               ;Not a 0x Prefix
  MOV  SI,BX       ;Restore original pointer
  STC              ;Set return flag
  JMP >X90         ;Done
X80:               ;Is a 0x Prefix
  DEC  SI          ;Point back at the first hex number
  CLC              ;Set return flag
X90:               ;Done
  POP  BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT SERIES OF HEX CHARACTERS, AND CONVERT THEM TO A NUMBER
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK
;              AX = Character string converted to a number, ?? if not
;            = Set if Error
;              AX = Unchanged
;Changes:
;NOTES: The string can either have an H at the end or not, and this code
;         will work.
;------------------------------------------------------------------------------
GetHex:
  PUSH BX,CX,DX    ;Save used registers
  MOV  DX,AX       ;Save original AX
  XOR  BX,BX       ;Start with zero
  MOV  CX,4        ;CL = bits to shift by, CH = Character Counter
  XOR  AH,AH       ;AH = 0
D10:               ;Loop to here for each character
  LODSB            ;Get the next character
  CALL IsHexNumber ;A valid Hex Number?
  JNC >D20         ;If so, continue
  CMP  AL,'_'      ;If not, is it an Underscore?
  JZ  >D45         ;If so, keep looking
  JMP >D50         ;If not, we're done
D20:               ;Valid Hex Number
  INC  CH          ;Increment the character counter
  SHL  BX,CL       ;Make room for the New Nibble
  JNC >D40         ;If we're not too big yet, keep going
  DEC  SI          ;If too big, Point back at bad character
  JMP >D70         ;Error
D40:               ;OK to add in new Nibble
  ADD  BX,AX       ;Add in the new Nibble
D45:               ;Done with this character
  JMP  D10         ;Jump to get next character
D50:               ;Done getting string
  DEC  SI          ;Point back at the bad character
  OR   CH,CH       ;Any valid characters at all?
  JZ  >D70         ;If not, error
  LODSB            ;Is the next character
  CALL IsHexEnd    ;  an H?
  JZ  >D80         ;If so, we're done
  DEC  SI          ;If not, point back at the non-H
  JMP >D80         ;Done
D70:               ;There was an error
  MOV  AX,DX       ;Restore original AX
  STC              ;Mark the error flag
  JMP >D90         ;And quit
D80:               ;We have a good number
  MOV  AX,BX       ;Put the value where it belongs
  CLC              ;Mark the OK flag
D90:               ;We're done
  POP  DX,CX,BX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT SERIES OF NUMERIC CHARACTERS, AND CONVERT THEM TO A NUMBER
;Inputs:  [SI] = Command Line Pointer
;Outputs: AX = decimal character string converted to a number, ?? if not
;         CF = Clear if AX is OK
;            = Set if no decimal found
;Changes: SI points at character after the number
;------------------------------------------------------------------------------
GetDecimal:
  PUSH BX,CX,DX     ;Save used registers
  XOR  AX,AX        ;Start with zero
  XOR  BX,BX        ;  "    "    "   - accumulator
  MOV  CX,10        ;CX = multiplier & digit limit comparer
  CALL IsSpaceOrEOX ;Skip over the spaces
  JZ  >D70          ;If EOL, Error
  SUB  AL,'0'       ;If not, convert it to a number
  CMP  AL,9         ;Is it really a number?
  JA  >D70          ;If not, there's an error
  DEC  SI           ;If so, step back to the number
D10:                ;Loop to here for each character
  LODSB             ;Get the next character
  SUB  AL,'0'       ;Change it to 0-9 range
  XOR  AH,AH        ;Extend byte to word
  CMP  AX,CX        ;Is it a digit?
  JAE >D80          ;If not, we're done
  CMP  BX,6553      ;Is our number getting too big?
  JB  >D20          ;If not, jump to store it
  CMP  AL,5         ;If so, will this number make it too big?
  JA  >D70          ;If so, there's an error
D20:                ;Add the digit to our number
  XCHG AX,BX        ;Swap accumulation into AX, new digit into BX
  MUL  CX           ;Multiply the previous accumulation by 10
  ADD  BX,AX        ;Add in the new digit
  JMP  D10          ;Jump to get next character
D70:                ;There was an error
  STC               ;Mark the error flag
  JMP >D90          ;And quit
D80:                ;We have a good number
  DEC  SI           ;Point back at the non-number
  MOV  AX,BX        ;Put the value where it belongs
  CLC               ;Mark the OK flag
D90:                ;We're done
  POP  DX,CX,BX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A HEX NUMERAL (BETWEEN 0 AND F)
;Inputs:  AL = ASCII Character to Test
;Outputs: CF = Clear if it is a Number
;              AL = ASCII Code converted to a real Number
;            = Set if Error (not a Number)
;              AL = Unchanged
;Changes:
;------------------------------------------------------------------------------
IsHexNumber:
  PUSH BX          ;Save used registers
  MOV  BL,AL       ;Save the character in case we need to restore it
  CALL IsNumber    ;A Decimal Number?
  JNC >H85         ;If so, we're done
  CALL Capitalize  ;If not, Capitalize it
  CMP  AL,'A'      ;A Hex Number?
  JB  >H70         ;If not, Error
  CMP  AL,'F'      ;A Hex Number?
  JBE >H80         ;If so, handle it
H70:               ;Not a Number
  MOV  AL,BL       ;Restore original character
  STC              ;Set Error Flag
  JMP >H90         ;Done
H80:               ;A Number > 9
  SUB  AL,('A'-10) ;Convert it to a real number
  JMP >H90         ;Done
H85:               ;OK (is a Number)
  CLC              ;Set OK Flag
H90:               ;Done
  POP  BX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A NUMERAL (BETWEEN 0 AND 9)
;Inputs:  AL = ASCII Character to Test
;Outputs: CF = Clear if it is a Number
;              AL = ASCII Code converted to a real Number
;            = Set if Error (not a Number)
;              AL = Unchanged
;Changes:
;------------------------------------------------------------------------------
IsNumber:
  CMP  AL,'0' ;A Number?
  JB  >N70    ;If not, Error
  CMP  AL,'9' ;A Number?
  JBE >N80    ;If so, handle it
N70:          ;Not a Number
  STC         ;Set Error Flag
  JMP >N90    ;Done
N80:          ;A number
  SUB  AL,'0' ;Convert it to a real number
  CLC         ;Set OK Flag
N90:          ;Done
  RET

;------------------------------------------------------------------------------
;TEST AN ASCII CHARACTER TO SEE IF IT IS A PARTICULAR CHARACTER
;Inputs:  AL = ASCII Character to Test
;Outputs: ZF = Set if it is the appropriate character
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
IsHexEnd:
  PUSH AX         ;Save used registers
  MOV  AH,'H'     ;Compare with H
  CALL Capitalize ;Capitalize the Character
  CMP  AL,AH      ;See if it matches
  POP  AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER SPACES TO FIND THE NEXT LEGITIMATE CHARACTER, TESTING FOR EOL
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: ZF = Set if EOL
;               AL  = Unchanged
;              [SI] = End-of-Line Character
;            = Clear if not EOL
;               AL  = First non-space character
;              [SI] = Character AFTER the next non-space character
;Changes:
;------------------------------------------------------------------------------
IsSpaceOrEOX:
  CALL IsSpaceOrEOL ;Skip over the spaces
  JZ  >X90          ;If end-of-line, we're done
  LODSB             ;If not, get the next character
  OR   AL,AL        ;Set return flag
X90:                ;Done
  RET

;------------------------------------------------------------------------------
;SKIP OVER SPACES TO FIND LEGITIMATE CHARACTERS, AND TEST FOR EOL
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: ZF = Set if EOL
;            = Clear if legitimate character
;              [SI] = The Next non-Space Character
;Changes:
;------------------------------------------------------------------------------
IsSpaceOrEOL:
  PUSH AX     ;Save used registers
L10:          ;Loop to here to skip over spaces
  LODSB       ;Get the next character
  CMP  AL,' ' ;Is it a space?
  JE   L10    ;If so, get the next character
  CMP  AL,Tab ;Is it a Tab?
  JE   L10    ;If so, get the next character
  DEC  SI     ;If not, point back at the character
  CMP  AL,CR  ;Set EOL flag
  POP  AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A CODE WORD FROM THE COMMAND LINE TO A WORD FROM THE LOOKUP TABLE
;Inputs:  DS:[SI] = Command Line Pointer
;         DS:[BX] = List to Test
;Outputs: CF = Clear if a match was found
;              AL = Entry from Table
;              [SI] = Next character after the Code Match
;         CF = Set if no match found (error)
;              AL = Unchanged
;              SI = Unchanged
;Changes: SI if valid match found
;------------------------------------------------------------------------------
GetCode:
  PUSH BX,DX         ;Save used registers
  MOV  DX,AX         ;Save AX in case there's no match
C10:                 ;Loop to here for each list of words
  CMP  B [BX],0      ;Are we at the end of our table?
  JE  >C80           ;If so, we couldn't find a match
  XOR  AH,AH         ;Assume it's a match
  PUSH SI            ;Save our command line pointer for a second
C20:                 ;Loop to here for each character in a word
  LODSB              ;Get the next character
  CALL Capitalize    ;Capitalize it
  CALL CmpALBXNoCase ;Is it a match?
  JZ  >C30           ;If so, handle it
  INC  AH            ;If not, mark us as no match
C30:                 ;The character is tested
  INC  BX            ;Point at the next character in our test word
  CMP  B [BX],0      ;Are we at the end of the word?
  JNE  C20           ;If not, keep going until we're done
  INC  BX            ;Point at the next word or code list
  OR   AH,AH         ;Was it a match?
  JZ  >C50           ;If so, jump to handle it
  POP  SI            ;If not, restore our command line pointer
  CMP  B [BX],0      ;Is this the end of our word list?
  JNE  C10           ;If not, just test the next word
  INC  BX,2          ;If so, skip over the codes
  JMP  C10           ;Keep going until we're done with our list
C50:                 ;We've found a match!
  POP  AX            ;Lose our original command line pointer
  DEC  BX            ;Point back at the end-of-word marker
C60:                 ;Loop to here to find the end-of-list
  MOV  AX,[BX]       ;Get the next two characters in our list
  INC  BX            ;Point at the next character for next time
  OR   AX,AX         ;Is this the start of our code list?
  JNE  C60           ;If not, keep looking
  INC  BX            ;If so, point at the character we're looking for
  MOV  DL,[BX]       ;Get the character from the Table
  CLC                ;Mark our OK flag
  JMP >C90           ;And we're done
C80:                 ;No match found
  STC                ;Mark us as no match
C90:                 ;We're done
  MOV  AX,DX         ;Set AX to the correct value
  POP  DX,BX         ;Restore used registers
  RET

CmpALBXNoCase:
  PUSH AX         ;Save used registers
  CALL Capitalize ;Capitalize AL
  MOV  AH,AL      ;Store it in AH
  MOV  AL,[BX]    ;Get [BX]
  CALL Capitalize ;Capitalize it
  CMP  AL,AH      ;Compare AL & [BX]
  POP  AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;BEEP THE SPEAKER
;Inputs:
;Outputs: Beeps the speaker
;Changes:
;------------------------------------------------------------------------------
BeepErr:
  PUSH AX,BX    ;Save used registers
  XOR  BX,BX    ;BH = Video page = 0
  MOV  AX,0E07h ;AH = 0Eh = Function = Write TTY
                ;AL = 07h = Character to write = BEL
  INT  10h      ;Do it
  POP  BX,AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CAPITALIZE A CHARACTER (Byte)
;Inputs:  AL = character to be capitalized
;Outputs: AL = capitalized character
;Changes:
;------------------------------------------------------------------------------
Capitalize:
  CMP  AL,'a'     ;Is it less than 'a'?
  JB  >C90        ;If so, quit
  CMP  AL,'z'     ;Is it more than 'z'?
  JA  >C90        ;If so, quit
  SUB  AL,'a'-'A' ;If between 'a' and 'z', capitalize it
C90:
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO GET "SPECIAL" VALUES FROM THE COMMAND-LINE (INDENTS, ADDRESSES, ETC.)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET THE CALL BACK ADDRESS FROM THE COMMAND-LINE, IF THERE
;Inputs:  [SI] = Command-Line Pointer
;         CallBackAddr = -1
;         ParentIsShell
;Outputs: CF = Clear if OK (got a valid Address)
;                CallBackAddr = Address (converted to a number) if
;                                 ParentShell = No
;            = Set if Error (invalid address format)
;                CallBackAddr = -1 in Offset if none or invalid address,
;                                 or ParentIsShell = Yes,
;                                 or anything follows the address
;Changes: SI
;------------------------------------------------------------------------------
GetCallBackAddr:
  PUSH AX,BX,CX,ES          ;Save used registers
  MOV  CX,SI                ;Save original command-line pointer
  CMP  ParentIsShell,Yes    ;Are we being run from the command-line?
  JE  >C75                  ;If so, don't bother looking for a call-back addr
  CALL IsSpaceOrEOL         ;Skip over the spaces
  JZ  >C75                  ;If end-of-line, no Call-Back Address provided
  CALL GetSegmentOffset     ;Look for a Segment:Offset (returns CF, ES:BX)
  JC  >C75                  ;If none found, no call-back address provided
  CALL IsSpaceOrEOL         ;If valid, is there anything else following it?
  JNZ >C70                  ;If so, error
  MOV  W CallBackAddr[0],BX ;If everything's OK, store the Offset
  MOV  W CallBackAddr[2],ES ;Store the Segment
  JMP >C80                  ;Done
C70:                        ;Error
  MOV  ParseError,Yes       ;Mark as an Error
C75:                        ;No Address/Invalid format
  MOV  SI,CX                ;Restore original command-line pointer
  STC                       ;Set error flag
  JMP >C90                  ;Done
C80:                        ;OK
  CLC                       ;Set OK flag
C90:                        ;Done
  POP  ES,CX,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT SERIES OF CHARACTERS, AND CONVERT THEM TO A SEGMENT:OFFSET
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK
;              ES:BX = Segment:Offset string converted to numbers
;            = Set if Error
;              ES:BX Unchanged
;Changes:
;------------------------------------------------------------------------------
GetSegmentOffset:
  PUSH AX,CX,DX     ;Save used registers
  MOV  CX,ES        ;Save original ES
  MOV  DX,BX        ;Save original BX
  CALL IsSpaceOrEOL ;Skip past the spaces
  JZ  >O70          ;If End of Line, Error
  CALL GetHex       ;Get the Segment
  JC  >O70          ;If error, quit
  MOV  ES,AX        ;If OK, store the Segment
  CALL IsSpaceOrEOX ;Skip over spaces
  JZ  >O70          ;If End of Line, Error
  CMP  AL,':'       ;Is it a Colon?
  JNZ >O70          ;If not, error
  CALL IsSpaceOrEOL ;Skip past the spaces
  JZ  >O70          ;If End of Line, Error
  CALL GetHex       ;Get the Offset
  JC  >O70          ;If error, quit
  MOV  BX,AX        ;If OK, store the Offset
  JMP >O80          ;Done
O70:                ;Error
  MOV  ES,CX        ;Restore original ES
  MOV  BX,DX        ;Restore original BX
  STC               ;Set error flag
  JMP >O90          ;Done
O80:                ;OK
  CLC               ;Set OK flag
O90:                ;Done
  POP  DX,CX,AX     ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PERFORM COMMAND LINE SWITCHES AND OPTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;Switches which involve straightforward table and/or sub-table lookups.
;The tables are simple byte-to-string or word-to-string lookup tables.
;Depending on the number of command-line parameters provided and the exact
;  characteristics of the data, these may either print a single table entry,
;  an entire table, or an entire table and its related sub-tables.
;
;Inputs:  DS:[SI] = Command-line Pointer
;------------------------------------------------------------------------------
DoSwitchCountry:
  MOV  BX,HIDCountryTbl     ;Table to Search
  JMP >S00                  ;Do it
DoSwitchDescriptorType:
  MOV  BX,DescriptorTypeTbl ;Table to Search
  JMP >S00                  ;Do it
DoSwitchDeviceClass:
  MOV  BX,DeviceClassTbl    ;Table to Search
  JMP >S00                  ;Do it
DoSwitchDeviceProtocol:
  MOV  BX,DeviceClassTbl    ;Table to Search
  JMP >S02                  ;Do it
DoSwitchDeviceSubClass:
  MOV  BX,DeviceClassTbl    ;Table to Search
  JMP >S01                  ;Do it
DoSwitchDialect:
  MOV  BX,LanguageTbl       ;Table to Search
  JMP >S01                  ;Do it
DoSwitchI14RError:
  MOV  BX,I14RErrorCodeTbl  ;Table to Search
  JMP >S00                  ;Do it
DoSwitchInterfaceClass:
  MOV  BX,InterfaceClassTbl ;Table to Search
  JMP >S00                  ;Do it
DoSwitchInterfaceProtocol:
  MOV  BX,InterfaceClassTbl ;Table to Search
  JMP >S02                  ;Do it
DoSwitchInterfaceSubClass:
  MOV  BX,InterfaceClassTbl ;Table to Search
  JMP >S01                  ;Do it
DoSwitchLanguage:
  MOV  BX,LanguageTbl       ;Table to Search
;  JMP >S00                  ;Do it
S00:                        ;No SubTables
  PUSH CX                   ;Save used registers
  XOR  CX,CX                ;Do no SubTables
  JMP >S10                  ;Do it
S01:                        ;1 SubTable
  PUSH CX                   ;Save used registers
  MOV  CL,1                 ;Do 1 SubTable
  JMP >S10                  ;Do it
S02:                        ;2 SubTables
  PUSH CX                   ;Save used registers
  MOV  CL,2                 ;Do 2 SubTables
;  JMP >S10                  ;Do it
S10:
  CALL DoSwitchGeneral      ;Handle it
  POP  CX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Switch to write a USB Vendor ID.
;We do not store USB Vendor ID's in this program, so this switch involves
;  calling (EXECuting) a sub-program called VENDOROD.COM.  The user or
;  calling program could call VENDORID.COM directly if it wanted to.
;  However, because we need to call VENDORID.COM ourselves at certain
;  times (specifically, to process USB Device Descriptors), we allow
;  ourselves to be called requesting a Vendor ID and we simply pass the
;  call through to VENDORID.COM.
;
;Inputs:  DS:[SI] = Command-line Pointer
;------------------------------------------------------------------------------
DoSwitchVendor:
  PUSH AX               ;Save used registers
  CALL GetCallBackAddr  ;Look for a call-back address
  JNC >V40              ;If we got one, write the whole table
  CALL GetNumber        ;Get the Number from the command line
  JC  >V40              ;If none, do the whole Table
  CALL GetCallBackAddr  ;Look for a call-back address
  CALL IsSpaceOrEOL     ;Is there anything after this on the command-line?
  JNZ >V70              ;If so, error
V20:                    ;AX = Number to use
  CALL WriteWordEquals  ;Write the Number and equals if at Command-line
  JMP >V50              ;Continue
V40:                    ;Write the Whole Table
  MOV  DoAllVendors,Yes ;Mark as doing the whole Table
V50:                    ;Do it
  CALL DoVendorID       ;Get/Write the ID
  JMP >V90              ;Done
V70:                    ;Error
  MOV  ParseError,Yes   ;Set Error Flag
V90:                    ;Done
  POP  AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Switch to write a String Language (Language & Dialect Combination)
;A String Language is a combination of a 10-bit Language ID and a
;  6-bit Dialect ID.  They are combined into a single word, with the
;  Language ID using the lower 10 bits and the Dialect ID using the
;  Upper 6 bits.
;Note that the way the two values are combined, with the main item
;  (Language) in the lower bits and the sub-item (Dialect) in the
;  higher bits, is backwards from what logic would dictate.  This means
;  that when the entire table is printed (sorted by Language first
;  and then by Dialect), it appears at first glance to not be sorted
;  even though it really is.  If the user wants things sorted numerically
;  (which is REALLY confusing from a logical perspective), they will need
;  to use DOS's SORT filter or some otehr method.
;We also have separate Language and Dialect command-line switches,
;  which treat the ID's as separate rather than combining them into
;  a single word.
;
;Inputs:  DS:[SI] = Command-line Pointer
;------------------------------------------------------------------------------
DoSwitchStringLanguage:
  PUSH AX                  ;Save used registers
  CALL GetCallBackAddr     ;Look for a call-back address
  JNC >L40                 ;If we got one, do the whole table
  CALL GetNumber           ;Get the Number from the command line
  JC  >L40                 ;If none, do the whole table
  CALL GetCallBackAddr     ;Look for a call-back address
  CALL IsSpaceOrEOL        ;Is there anything after this on the command-line?
  JNZ >L70                 ;If so, error
L10:                       ;AX contains number to write
  CALL DoStringLangWrite   ;Look it up and write it
  JMP >L90                 ;Done
L40:                       ;Do all possibilities
  CALL DoStringLanguageAll ;Write all possibilities
  JMP >L90                 ;Done
L70:                       ;Error
  MOV  ParseError,Yes      ;mark as an error
L90:                       ;Done
  POP  AX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Switch to write the returned status of a Transfer Descriptor (TD).
;A Transfer Descriptor is what is used to actually send or retrieve a
;  packet of data across the USB Bus.  There are several possible errors
;  that can occur during a packet transaction, and there can even be
;  more than one kind of error occurring at the same time.  The errors
;  are returned in a bit-mapped word.
;The reason this command-line Option is not included with the general
;  lookup table Options is because this requires a bitmap-to-string
;  lookup, rather than a byte- or word-to-string lookup.  This requires
;  a different type of prcessing.

;Inputs:  DS:[SI] = Command-line Pointer
;------------------------------------------------------------------------------
DoSwitchTDStatus:
  PUSH AX,BX,DX            ;Save used registers
  MOV  BX,TDStsTbl         ;Point at TD Status Table
  CALL GetCallBackAddr     ;Look for a call-back address
  JNC >S40                 ;If we got one, do the whole table
  CALL GetNumber           ;Get the Number from the command line
  JC  >S40                 ;If none, do the whole table
  CALL GetCallBackAddr     ;Look for a call-back address
  CALL IsSpaceOrEOL        ;Is there anything after this on the command-line?
  JNZ >S70                 ;If so, error
S10:                       ;AX contains number to write
  CALL WriteWordEquals     ;Write the Number and equals if at Command-line
  OR   AX,AX               ;Is the Code 0 (Success)?
  JNZ >S30                 ;If not, handle the Error
  MOV  DX,TDStsSuccessMsg  ;If so, write the
  CALL WriteItDX           ;  Success Message
  JMP >S90                 ;Done
S30:                       ;TD Status Code is not 0
  CMP  ParentIsShell,Yes   ;Are we at the Command-line?
  JNE >S35                 ;If not, don't do indentation
  MOV  Indent,8            ;Setup Indentation value
S35:                       ;Indent handled, if appropriate
  CALL SearchBitMapUnknown ;Write the Contents
  JMP >S90                 ;Done
S40:                       ;Do all possibilities
  CALL WriteBitMapTbl      ;Write All Possibilities
  JMP >S90                 ;Done
S70:                       ;Error
  MOV  ParseError,Yes      ;Mark as an error
S90:                       ;Done
  POP  DX,BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Switch to decipher "standard" USB Descriptors.
;This requires a Segment:Offset as an input parameter, which is the
;  memory address of a downloaded (or created) Descriptor or set of
;  Descriptors.
;The first two bytes of these "general" descriptor types are always in
;  the same format, a Descriptor Size byte followed by a Descriptor Type
;  byte.  In processing the Descriptor(s), we assume that there may be
;  several Descriptors next to each other in memory, one directly
;  following the other (this is how a "Get Complete Configuration
;  Descriptor" Request works, for example).  Therefore, we keep processing
;  the Descriptor(s) until we find a Descriptor with a Descriptor Size
;  (the first byte of the Descriptor) of 0.
;Also note that we do not find all possible errors in the Descriptors.
;  For example, when processing a "standard" Descriptor, we usually ignore
;  the Descriptor Size byte (other than making sure it's not 0), and
;  process the Descriptor based on its actual contents.
;
;Inputs:  DS:[SI] = Command-line Pointer
;------------------------------------------------------------------------------
DoSwitchDescriptor:
  PUSH AX,BX,DI,ES               ;Save used registers
  MOV  DI,Int14Request           ;Point at String Request Structure
  MOV  [DI].I14RHostIndex,-1     ;Start with Bad Host Index
  MOV  [DI].I14RDeviceAddress,-1 ;Start with Bad Device Address
  CALL GetSegmentOffset          ;Get Data Pointer from command line (ES:BX)
  JC  >D70                       ;If error, Quit
  CALL GetCallBackAddr           ;If OK, look for a Call-Back Address
  JNC >D50                       ;If we got one, continue
  CALL GetNumber                 ;Get the Host Index
  JC  >D50                       ;If none, write with no strings
  CMP  AX,15                     ;Valid Host Index?
  JA  >D70                       ;If not, error
  MOV  [DI].I14RHostIndex,AL     ;If OK, store it
  CALL GetNumber                 ;Get the Device Address
  JC  >D70                       ;If none, Error
  CMP  AX,127                    ;Valid Device Address?
  JA  >D70                       ;If not, error
  MOV  [DI].I14RDeviceAddress,AL ;If OK, store it
  CALL GetCallBackAddr           ;Look for a Call-Back Address
  CALL IsSpaceOrEOL              ;Anything else on the command-line?
  JNZ >D70                       ;If so, Error
D50:                             ;Write the Descriptor(s)
  CMP  ParseError,Yes            ;Was there an error (with a Call-Back Address)?
  JE  >D90                       ;If so, quit
  MOV  DI,BX                     ;Point ES:[DI] at the Data
  CALL WriteDescriptors          ;Do it
  JMP >D90                       ;Done
D70:                             ;Error
  MOV  ParseError,Yes            ;Mark as error
D90:                             ;Done
  POP  ES,DI,BX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Switches to decipher "non-standard" Descriptors or Structures.
;This processes "non-standard USB Descriptors, which do not have the
;  first two bytes of a Descriptor Size and Descriptor Type.  For now,
;  that only includes HID Report and Physical Descriptors.  Because
;  HID Report and Physical Descriptors do not include a size as part
;  of the Description, we process them until we come to a value of
;  0 where there shouldn't be one.  We do not ask the user for a
;  size as a parameter.
;In addition, this will process other types of structures (not
;  necessarily Descriptors).  The structures may either be of a
;  fixed length, or may be marked by a special ending byte/word
;  (usually a 0 or a -1 where it wouldn't make sense to have one).
;This requires a Segment:Offset as an input parameter, which is the
;  memory address of a downloaded (or created) Descriptor/Structure.
;  This will not process multiple Descriptors or Structures, since in
;  general it has no idea where one might end and the other start.
;
;Inputs:  DS:[SI] = Command-line Pointer
;------------------------------------------------------------------------------
DoSwitchControlPkt:
  PUSH DI                    ;Save used registers
  MOV  DI,WriteControlPkt    ;Code to Call
  JMP >D00                   ;Do it
DoSwitchInt14Structure:
  PUSH DI                    ;Save used registers
  MOV  DI,WriteInt14Struc    ;Code to Call
  JMP >D00                   ;Do it
DoSwitchPhysicalDescr:
  PUSH DI                    ;Save used registers
  MOV  DI,WritePhysicalDescr ;Code to Call
  JMP >D00                   ;Do it
DoSwitchReportDescr:
  PUSH DI                    ;Save used registers
  MOV  DI,WriteReportDescr   ;Code to Call
;  JMP >D00                   ;Do it
D00:
  PUSH BX,ES                 ;Save used registers
  CALL GetSegmentOffset      ;Get Data Pointer from command line (ES:BX)
  JC  >D70                   ;If error, Quit
  CALL GetCallBackAddr       ;If OK, look for a Call-Back Address
  CALL IsSpaceOrEOL          ;Is there anything after this on the command-line?
  JNZ >D70                   ;If so, error
D40:                         ;Have the command-line parameters
  CALL DI                    ;Do it
  JMP >D90                   ;Done
D70:                         ;Error
  MOV  ParseError,Yes        ;Mark as error
D90:                         ;Done
  POP  ES,BX                 ;Restore used registers
  POP  DI                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Switch to translate Device/Interface Numbers to a generic Description
;This requires 6 bytes as input parameters: Device Class, Device SubClass,
;  Device Protocol, Interface Class, Interface SubClass, and Interface
;  Protocol.  These are the six categories that USB uses to define "what"
;  a Device/Interface is and does.
;Given the six numbers, this returns a short 14-byte string that attempts
;  (in a general sense) to "describe" what kind of Device/Interface it is.
;The USB architecture is very flexible (too flexible in some respects), and
;  while there are a lot of pre-defined "standard" Device/Interface Types,
;  USB also allows "Vendor-Defined" Devices/Interfaces.  A Vendor-Defined
;  Device/Interface, as the name implies, can be anything that the Vendor
;  wants it to be.  In such a case (and in certain other cases), this
;  simply returns with an "I have absolutely no idea what kind of
;  Device/Interface that is".
;
;Inputs:  DS:[SI] = Command-line Pointer
;------------------------------------------------------------------------------
DoSwitchDvcDescription:
  PUSH AX,CX,DI,ES           ;Save used registers
  MOV  ES,DS                 ;Point ES:[DI] at
  MOV  DI,DvcDescriptionData ;  at the data area
  MOV  CX,6                  ;Need to get 6 bytes
V10:                         ;Loop to here for each byte
  CALL GetNumber             ;Get the Next Number from the command line
  JC  >V70                   ;If error, quit
  CMP  AX,0FFh               ;Valid number?
  JA  >V70                   ;If not, error
  STOSB                      ;If OK, save it
  LOOP V10                   ;Keep going until we're done
  CALL GetCallBackAddr       ;If OK, look for a Call-Back Address
  CALL IsSpaceOrEOL          ;Is there anything after this on the command-line?
  JNZ >V70                   ;If so, error
V20:                         ;Got valid data
  CMP  ParentIsShell,Yes     ;Are we at the command-line?
  JNE >V50                   ;If not, just write the Description
  MOV  SI,DvcDescriptionData ;Point DS:[SI] at the Data
  MOV  CX,6                  ;Need to write 6 numbers
V30:                         ;Loop to here for each number
  LODSB                      ;Get the next number
  CALL WriteByteHex          ;Write the Number
  CALL WriteHexEnd           ;Write an 'h'
  CALL WriteSpace            ;Write a Space
  LOOP V30                   ;Keep going until we're done
  CALL WriteEqualsSpace      ;Write an '= '
V50:                         ;OK to Write the Description
  MOV  DI,DvcDescriptionData ;Point ES:[DI] at the Data
  CALL WriteDvcDescription   ;Write the Description
  JMP >V90                   ;Done
V70:                         ;Error
  MOV  ParseError,Yes        ;Mark as error
V90:                         ;Done
  POP  ES,DI,CX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Switch to write our Command-line Aliases.
;This is not actually a USB-related Option, just an Option related
;  to our program itself.
;Unlike the other Options, we will not allow the user to provide a
;  call-back Address to write this to.  We always write this
;  directly to STDOUT.
;------------------------------------------------------------------------------
DoSwitchAlias:
  CALL IsSpaceOrEOL   ;Is there anything after this on the command-line?
  JNZ >A70            ;If so, error
  CALL DoAliases      ;If not, do it
  JMP >A90            ;Done
A70:                  ;Error
  MOV  ParseError,Yes ;mark as an error
A90:                  ;Done
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE REQUIRED TO PERFORM CERTAIN SPECIFIC SWITCHES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE THE DEVICE DESCRIPTION GIVEN THE DEVICE AND INTERFACE CODES
;Inputs:  ES:[DI] = Pointer to 6 Data Bytes
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteDvcDescription:
  PUSH AX,BX,CX,DX,DI,SI        ;Save used registers
  MOV  SI,DvcDescriptionTbl     ;Point at the Table of Descriptors
  MOV  DX,DI                    ;Save original pointer
D10:                            ;Loop to here for each table entry
  CMP  B [SI],253               ;Are we at the end of the table?
  JE  >D70                      ;If so, handle it
  MOV  CX,6                     ;CX = # of bytes to test
  XOR  BX,BX                    ;BL = # of matching bytes
D20:                            ;Loop to here for each test byte
  LODSB                         ;Get the byte from our Test Table
  CMP  AL,-1                    ;Do we care what it is?
  JE  >D30                      ;If not, it's an automatic match
  CMP  AL,ES:[DI]               ;If we care, does it match?
  JNE >D40                      ;If not, continue testing
D30:                            ;It's a match
  INC  BL                       ;Increment match Counter
D40:                            ;Done testing this byte
  INC  DI                       ;Point at the next byte
  LOOP D20                      ;Keep testing
  CMP  BL,6                     ;Did all 6 bytes match?
  JNE >D50                      ;If not, keep looking
  MOV  DX,SI                    ;Point at Description String
  JMP >D90                      ;Done
D50:                            ;This entry did not match
  ADD  SI,DvcDescriptionSize    ;Point at next table entry
  MOV  DI,DX                    ;Point back at original data
  JMP  D10                      ;Keep looking
D70:                            ;Not in table
  MOV  DX,DvcDescriptionUnknown ;Point at unknown Message
D90:                            ;Have Device Description
  CALL WriteItDX                ;Write Descriptuion
  POP  SI,DI,DX,CX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A VENDOR ID TO A STRING, AND WRITE IT
;Inputs:  DoAllVendors = No
;           AX = VendorID to Look for
;         DoAllVendors = Yes
;           AX is ignored, writes All Vendor ID's
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoVendorID:
  PUSH DX,DI              ;Save used registers
  CALL InitCmdTail        ;Initialize the Command Tail
  CMP  DoAllVendors,Yes   ;Do we need to do all Vendors?
  JNE >V30                ;If not, handle a single Vendor
  MOV  DX,AllVendorHdr    ;If so,
  CALL SetupPause         ;  Set up the Header
  MOV  DX,AllMsg          ;Write "All"
  CALL AppendString2Cmd   ;  to the command tail
  JMP >V40                ;Continue
V30:                      ;Single Vendor
  MOV  DX,USBMsg          ;Write "USB"
  CALL AppendString2Cmd   ;  to the Command tail
  CALL AppendHexWord2Cmd  ;Copy the Vendor ID to the Command Tail
V40:                      ;[BX] = Call Back Tail, [DX] = Start of Tail
  MOV  DI,SupportFileVend ;FileName to Look For
  CALL HandleExecCall     ;Execute the Support File
  POP  DI,DX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS A STRING LANGUGE REQUEST (WRITING OUTPUT OR JUST LOOKING UP)
;Inputs:  AX = String Language (Combined Language & Dialect) to look for
;         DS = Local Data Area
;Outputs: CF = Clear if String Language is found
;              If DoStringLangWrite, Writes Language & Dialect string
;              If DoStringLangNoWrite, does not write anything
;            = Set if String Language is not found
;Changes:
;------------------------------------------------------------------------------
DoStringLangWriteNoNum:
  PUSH CX               ;Save used registers
  MOV  CX,0FF00h        ;CH = Write Description = True
                        ;CL = Write Number = False
  JMP >G00              ;Do it
DoStringLangWrite:
  PUSH CX               ;Save used registers
  MOV  CX,-1            ;CH = Write Description = True
                        ;CL = Write Number = True
  JMP >G00              ;Do it
DoStringLangNoWrite:
  PUSH CX               ;Save used registers
  XOR  CX,CX            ;Mark as not writing anything (just looking for a match)
;  JMP >G00              ;Do it
G00:
  PUSH AX,BX,DX         ;Save used registers
  OR   CH,CH            ;Are we supposed to write anything?
  JZ  >G10              ;If not, skip down
  OR   CL,CL            ;Are we supposed to write the Number?
  JZ  >G10              ;If not, skip down
  CALL WriteWordEquals  ;Write the Number and equals if at Command-line
G10:                    ;Done writing number, if appropriate
  MOV  DX,LanguageSMsg  ;Assume Unknown Language
  MOV  CL,AH            ;Put the Dialect ID
  SHR  CL,2             ;  in CL
  AND  AX,03FFh         ;Put the Language ID in AX
  MOV  BX,LanguageTbl   ;Write the Language ID
  OR   CH,CH            ;Are we supposed to write anything?
  JZ  >G25              ;If not, handle it
G20:                    ;Search for & write Language
  CALL SearchTblWrite   ;  from the Table (returns BX)
  JMP >G30              ;Continue
G25:                    ;Search for, but don't write, Language
  CALL SearchTblNoWrite ;  from the Table
G30:                    ;Language searched for, and written if appropriate
  JC  >G70              ;If no Language match, handle it
  OR   CH,CH            ;Are we supposed to write anything?
  JZ  >G35              ;If not, skip it
  CALL WriteColon       ;Write a Colon
  CALL WriteSpace       ;  and a Space
G35:                    ;Wrote space and colon, if appropriate
  MOV  DX,DialectSMsg   ;Assume Unknown Dialect
  MOV  AL,CL            ;Write the
  OR   CH,CH            ;Are we supposed to write anything?
  JZ  >G45              ;If not, handle it
G40:                    ;Search for & write Dialect
  CALL SearchTblWrite   ;  from the Table (returns BX)
  JMP >G50              ;Continue
G45:                    ;Search for, but don't write, Dialect
  CALL SearchTblNoWrite ;  from the Table
G50:                    ;Dialect searched for, and written if appropriate
  JNC >G80              ;If OK, we're done
G70:                    ;Not Found
  OR   CH,CH            ;Are we supposed to write anything?
  JZ  >G78              ;If not, don't
G75:                    ;Need to write Unknown message
  CALL WriteUnknown     ;Write "Unknown"
  CALL WriteItDX        ;Write "Language" or "Dialect"
G78:                    ;Not Foune
  STC                   ;Set return flag
  JMP >G90              ;Done
G80:                    ;Found
  CLC                   ;Set return flag
G90:                    ;Done
  POP  DX,BX,AX         ;Restore used registers
  POP  CX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ALL STRING LANGUAGES TO THE SCREEN
;Inputs:  DS = Local Data Area
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoStringLanguageAll:
  PUSH AX,BX,DX,DI,SI   ;Save used registers
  MOV  SI,LanguageTbl+1 ;Point at the Language Table
A10:                    ;Loop to here for each Language Table Entry
  LODSW                 ;Get the language ID
  OR   AX,AX            ;Is it possibly the end of the Table?
  JNZ >A20              ;If not, continue
  CMP  B [SI],-1        ;Is it the actual end of the Table?
  JE  >A90              ;If so, we're done
A20:                    ;Valid Language Table Entry
  MOV  BX,AX            ;Save the Language ID in BX
  MOV  DX,SI            ;Point DX at the Language String
  CALL SkipOverStringSI ;Point SI
  MOV  SI,[SI]          ;  at the first
  INC  SI               ;  Dialect Entry
A30:                    ;Loop to here for each Dialect Table Entry
  CMP  W [SI],0FF00h    ;End of the Dialect Table?
  JE  >A50              ;If so, done with this Language Table Entry
A40:                    ;Not End-of-Dialect-Table
  LODSB                 ;Get the Dialect ID
  SHL  AX,10            ;Shift it over where it belongs
  OR   AX,BX            ;Mask in the Language ID
  CALL WriteWordHex     ;Write the
  CALL WriteHexEnd      ;  String Language ID
  CALL WriteSpace       ;Write a Space
  CALL WriteItDX        ;Write the Language String
  CALL WriteColon       ;Write a Colon
  CALL WriteSpace       ;Write a Space
  CALL WriteItSI        ;Write the Dialect String
  CALL WriteCrLf        ;Write a new line
  CALL SkipOverStringSI ;Skip past the Dialect String
  JMP  A30              ;Continue
A50:                    ;Done with this Language Table Entry
  MOV  SI,DX            ;Point SI at the Language String
  CALL SkipOverStringSI ;Skip over the Language String
  INC  SI,2             ;Skip over the Dialect Table Pointer
  JMP  A10              ;Keep going
A90:                    ;Do it
  POP  SI,DI,DX,BX,AX   ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE REQUIRED TO PERFORM THE ALIAS SWITCH
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PRINT THE COMMAND LINE ALIASES AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;Outputs: Writes Aliases to the screen
;Changes: Quits program
;------------------------------------------------------------------------------
DoAliases:
  PUSH BX,DX,SI         ;Save used registers
  CALL WriteCrLf        ;Move down
  MOV  DX,AliasHdrMsg   ;Set up
  CALL SetupPause       ;  the Header
  MOV  SI,SwitchList    ;Point at Tbl of Aliases
  MOV  BX,1+(40h SHL 8) ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNoNum ;Write the Aliases
A90:                    ;Done
  POP  SI,DX,BX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE LIST OF SWITCH CHARACTERS TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         BL = Minimum Value to look for in the Table
;         DH = Maximum Value to look for in the Table
;         SI = Switch List ("Code Word") Table
;Outputs: Writes List of Switch Characters to the Screen
;Changes:
;NOTES:   Sets CH =  0 if we write Blocks for Switches < " "
;                 = -1 if we write numbers for the all Switches (0-255)
;                 = -2 if we subtract 128 from the numbers (128-255)
;------------------------------------------------------------------------------
;DoAliasesGoNum80h:
;  PUSH CX               ;Save used registers
;  MOV  CH,2             ;Mark as writing Numbers, needing to subtract 128
;  JMP >G00              ;Continue
;DoAliasesGoNum:
;  PUSH CX               ;Save used registers
;  MOV  CH,1             ;Mark as writing Numbers, not needing to modify
;  JMP >G00              ;Continue
DoAliasesGoNoNum:
  PUSH CX               ;Save used registers
  XOR  CX,CX            ;Mark as not writing Numbers
;  JMP >G00              ;Continue
G00:
  PUSH AX,DI            ;Save used registers
  MOV  DI,AliasSortTbl  ;Point at the Alias Sort Table
  MOV  AL,BL            ;Start with the Lower Limit
G10:                    ;Loop to here for each Alias
  CALL GetAliasPointers ;Get the Alias Pointers
  JZ  >G60              ;If none for this entry, go to the next one
G20:                    ;Have at least one valid Alias
  CALL WriteCrLf        ;If valid, move down
  OR   CH,CH            ;Writing Single characters?
  JNZ >G40              ;If not, handle full numbers
  MOV  CL,78            ;Write this many characters per line
;  CMP  AL,' '           ;Is there a valid single-character equivalent?
;  JB  >G30              ;If not, don't write it
;  CALL WriteAL          ;If so, write it
;  JMP >G50              ;Continue
;G30:                    ;Not a writable character
  CALL WriteBlock       ;Write a Block Character
  JMP >G50              ;Continue
G40:                    ;Need to write Numbers
  MOV  CL,76            ;Write this many characters per line
  PUSH AX               ;Save the number for a second
  CMP  CH,2             ;Do we need to modify the Number?
  JNE >G45              ;If not, continue
  AND  AL,(NOT 80h)     ;Subtract 128 from it
G45:                    ;Write the Number
  CALL ByteToString     ;Write the Switch as a Number
  POP  AX               ;Restore the Number
G50:                    ;Done writing single character
  CALL WriteAliases     ;Write the Alias List
G60:                    ;Done with this Code
  CMP  AL,BH            ;Have we done the whole list yet?
  JE  >G90              ;If so, we're done
  INC  AL               ;If not, go to the next possibility
  JMP  G10              ;Keep going until we're done
G90:                    ;Done
  POP  DI,AX            ;Restore used registers
  POP  CX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET STRING POINTERS FOR ALL ALIASES FOR A SINGLE CHARACTER OPTION
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;          AL  = Switch Table entry to look for (not 0)
;         [SI] = Switch Table to look through, sorted backwards
;         [DI] = Alias Sort Table
;Outputs:  ZF = Clear if OK
;               [DI] = Filled with String Pointers, sorted backwards
;                      Last Entry is always a 0
;             = Set if no matches found
;                      First Entry is 0
;Changes:
;------------------------------------------------------------------------------
GetAliasPointers:
  PUSH AX,BX,CX,DX      ;Save used registers
  PUSH DI,SI            ;Save used registers
  MOV  CX,DI            ;Sve original pointer
P10:                    ;Loop to here for each Table Entry
  MOV  DX,SI            ;Save beginning Alias Pointer
P20:                    ;Loop to here to find the end of an Alias List Entry
  CMP  B [SI],0         ;End of Alias List?
  JE  >P30              ;If so, handle it
  CALL SkipOverStringSI ;If not, skip over the string
  JMP  P20              ;Keep looking
P30:                    ;End of Alias List Entry
  MOV  BX,SI            ;Save End-of-Entry Pointer
  CMP  AL,[SI+1]        ;Is this entry a match?
  JNE >P50              ;If not, go to the next one
  MOV  SI,DX            ;Point at Alias String
P40:                    ;Loop to here for each Alias String
  CMP  B [SI],0         ;End of the entry?
  JE  >P50              ;If so, we're done
  MOV  [DI],SI          ;If not, store it in the sort table
  INC  DI,2             ;Update the Table Pointer
  CALL SkipOverStringSI ;Skip over the string
  JMP  P40              ;Keep going until we have all of the strings
P50:                    ;Done with this entry
  MOV  SI,BX            ;Get End-of-Entry Pointer
  INC  SI,2             ;Skip over End-of-Entry stuff
  CMP  B [SI],0         ;End of Table?
  JNE  P10              ;If not, keep looking
P90:                    ;Done
  MOV  W [DI],0         ;Make sure last entry is a 0
  CMP  CX,DI            ;Set return flag
  POP  SI,DI            ;Restore used registers
  POP  DX,CX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ALL ALIAS STRINGS FOR A SINGLE CHARACTER OPTION
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = Alias String Pointer Table (Sorted backwards)
;                  Last Entry is a 0
;          CL  = Number of characters left available to write on first line
;                 (76 if Writing Numbers, 78 if Writing Characters)
;         CLD already issued
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteAliases:
  PUSH AX,BX,CX,DX   ;Save used registers
  PUSH DI,SI,ES      ;Save used registers
  MOV  ES,DS         ;Point ES at the Local Data Area
  MOV  BL,CL         ;BL = Character Countdown Measurer
  MOV  BH,CL         ;BH = Original Counter
  MOV  DX,DI         ;Save start-of-table Pointer
  MOV  CX,-1         ;Maximize counter
  XOR  AX,AX         ;Find the last
  REPNE SCASW        ;  entry in
  SUB  DI,4          ;  the Table
W10:                 ;Loop to here for each Alias String
  CMP  DI,DX         ;Are we done writing?
  JB  >W90           ;If so, quit
  MOV  SI,[DI]       ;Get the next string
  DEC  DI,2          ;Update the table pointer
  CALL CalcStrSizeSI ;See how long the string is
  OR   BL,BL         ;Is the character counter down to 0?
  JZ  >W20           ;If so, we need to reset it
  CMP  CL,BL         ;Is this string too long to fit on this line?
  JB  >W40           ;If not, go ahead and write it
W20:                 ;Need to start a new line
  CALL WriteCrLf     ;Start a new line
  PUSH CX            ;Save String Size for a second
  MOV  CL,79         ;Calculate how many
  SUB  CL,BH         ;  spaces to write
  CALL WriteSpaces   ;Write the spaces
  POP  CX            ;Restore String Size
  MOV  BL,BH         ;Reset the character counter
W40:                 ;Write the Alias String
  SUB  BL,CL         ;Update the
  DEC  BL            ;  character counter
  CALL WriteSpace    ;Write a Space
  CALL WriteItSI     ;Write the string
  JMP  W10           ;Keep writing
W90:                 ;Done
  CALL WriteCrLf     ;Move down
  POP  ES,SI,DI      ;Restore used registers
  POP  DX,CX,BX,AX   ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE REQUIRED TO PROCESS GENERAL DESCRIPTORS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE THE DESCRIPTORS OF THE LAST ENUMERATED DEVICE TO THE SCREEN
;Inputs:  ES:[DI] = Descriptor Data to write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteDescriptors:
  PUSH AX,CX,DX,DI,SI          ;Save used registers
  MOV  Indent,(DescrLineLen+2) ;Store the correct Indent
W10:                           ;Loop to here for each Descriptor we write
  MOV  AX,ES:[DI]              ;Get the Descriptor Length (AL) and Type (AH)
  OR   AL,AL                   ;End of the Descriptors?
  JZ  >W90                     ;If so, we're done
  MOV  SI,DescrMsgTblUSB       ;Assume a Standard USB Descriptor
  CMP  AH,20h                  ;Is it a Standard or Class-Specific Descriptor?
  JB  >W20                     ;If Standard, continue
  CALL LocateDescrTbl          ;If not, look for a Class-Specific Descriptor
  JC  >W50                     ;If none, write an Unknown Descriptor Type
W20:                           ;Loop to here for each Table Entry
  CMP  B [SI],0                ;End of our Table?
  JE  >W50                     ;If so, handle an Unknown Descriptor
  CALL TestDescrEntry          ;If not, see if it matches (changes SI)
  JC  >W30                     ;If not, keep looking
  CALL WriteDescriptor         ;If so, write it
  JMP >W80                     ;Done with this one
W30:                           ;Go to the next Descriptor Message Table Entry
  CMP  W [SI],0                ;End of the Table?
  JE  >W40                     ;If so, handle it
  ADD  SI,3                    ;If not, skip over
  CALL SkipOverStringSI        ;  the string
  JMP  W30                     ;Keep skipping throuhg this table
W40:                           ;At end of Table Entry
  INC  SI,2                    ;Skip over end-of-entry marker
  JMP  W20                     ;Keep looking
W50:                           ;Handle Unknown Descriptor Type
  CALL WriteUnknownDescr       ;Write it
W80:                           ;Done with this Descriptor, go to next one
  XOR  AX,AX                   ;Point at
  MOV  AL,ES:[DI]              ;  the next
  ADD  DI,AX                   ;  Descriptor
  JMP  W10                     ;Keep Writing
W90:                           ;Done
  POP  SI,DI,DX,CX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST A DESCRIPTOR DECIPHERING TABLE ENTRY TO SEE IF IT'S CORRECT
;Inputs:  ES:[DI] = Actual Descriptor to test
;         DS:[SI] = Descriptor Deciphering Table Entry to test
;Outputs: CF   = Clear if OK (this is the appropriate Table entry to use)
;              = Set if error (incorrect Table Entry to use)
;         [SI] = Table Entry value after the "Header" (the bytes to test)
;Changes:
;------------------------------------------------------------------------------
TestDescrEntry:
  PUSH AX,BX,CX,DX     ;Save used registers
  XOR  CX,CX           ;CX = Number of Bytes
  MOV  CL,[SI]         ;  to test
  INC  SI              ;[SI] = First Test Byte
  MOV  DX,SI           ;Store the
  ADD  DX,CX           ;  Ending Pointer
  XOR  BX,BX           ;BX = Test Offset = 0 to start
T10:                   ;Loop to here for each test byte
  MOV  AL,[SI+BX]      ;Get the Test Byte
  CMP  AL,-1           ;Is it a "don't care"?
  JE  >T30             ;If so, it's a  match
  CMP  AL,ES:[DI+BX+1] ;If we care, does it match?
  JNE >T70             ;If not, we're done
T30:                   ;It's a match
  INC  BX              ;Update the Offset value
  LOOP T10             ;Keep testing all bytes
  JMP >T80             ;If all bytes match, we're done
T70:                   ;Error (no match)
  STC                  ;Set return flag
  JMP >T90             ;Done
T80:                   ;OK (It's a Match!)
  CLC                  ;Set return flag
T90:                   ;Done
  MOV  SI,DX           ;Update the Pointer for the Return
  POP  DX,CX,BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIGURE OUT WHICH CLASS-SPECIFIC DESCRIPTOR TABLE TO USE
;Inputs:  DS = Local Data Area
;         ES:[DI] = Descriptor Data
;         DeviceClass, DeviceSubClass, etc., filled in
;         CLD already issued
;Outputs: CF = Clear if OK (Found a Match)
;              SI = Descriptor Translation Table to use
;            = Set if Error (Could not find a match)
;              [SI] = Unchanged
;Changes:
;------------------------------------------------------------------------------
LocateDescrTbl:
  PUSH AX,BX,CX,BP,ES        ;Save used registers
  MOV  BP,SI                 ;Save original SI
  MOV  SI,ClassDescrTbl      ;Point [SI] at the Lookup Table
L10:                         ;Loop to here for each Table entry
  CMP  B [SI],0              ;End of the Table?
  JE  >L70                   ;If so, no match
  MOV  BX,OFFSET DeviceClass ;Point [BX] at the first Test Value
  MOV  CX,10                 ;Need to test 10 bytes
L20:                         ;Loop to here for each Test byte
  LODSB                      ;AL = next Actual Class/SubClass/Protocol Value
  MOV  AH,[BX]               ;AH = Lookup value
  INC  BX                    ;  to test with
  CMP  AL,-1                 ;Do we care if it's really a match or not?
  JE  >L25                   ;If not, consider it a match
  CMP  AL,AH                 ;If so, does it match?
  JNE >L30                   ;If not, handle it
L25:                         ;This byte matches
  LOOP L20                   ;If so, keep testing
  JMP >L80                   ;If they all match, we're done
L30:                         ;All bytes match
  ADD  SI,CX                 ;Skip over the rest of the test bytes
  INC  SI                    ;  and the Pointer
  JMP  L10                   ;Keep looking
L70:                         ;Error
  MOV  SI,BP                 ;Restore original SI
  STC                        ;Set Error Flag
  JMP >L90                   ;Done
L80:                         ;OK ([SI] = Translation Table Pointer)
  MOV  SI,[SI]               ;Put the Translation Table Pointer in SI
  CLC                        ;Set return flag
L90:                         ;Done
  POP  ES,BP,CX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF A SPECIFIC DESCRIPTOR TO THE SCREEN
;Inputs:  ES:[DI] = Descriptor to Write
;         DS:[SI] = Descriptor Message Table Entry
;Outputs: Writes the Descriptor to the Screen
;         DescrLength
;Changes:
;------------------------------------------------------------------------------
WriteDescriptor:
  PUSH CX              ;Save used registers
  MOV  CL,ES:[DI]      ;Get Actual Descriptor Length
  MOV  DescrLength,CL  ;Save it (we may need it later)
  CALL DoDescriptorTbl ;Write it
  CALL WriteCrLf       ;Write a New Line
  POP  CX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF AN UNRECOGNIZED DESCRIPTOR TYPE TO THE SCREEN
;Inputs:  ES:[DI] = Unknown Descriptor
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteUnknownDescr:
  PUSH CX,SI                 ;Save used registers
  MOV  CL,ES:[DI]            ;CL = Number of Bytes in the Descriptor
  MOV  SI,DescrMsgTblUnknown ;Point at the Decoe Table Entry
  CALL DoDescriptorTbl       ;Write the Description
  CALL WriteCrLf             ;Move down
  POP  SI,CX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A SIMPLE, ONE-STEP LOOKUP-TABLE ATTRIBUTE FROM A DESCRIPTOR
;Inputs:  DS = Local Data Area
;         AL/AX = Descriptor Byte/Word to Look up
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoAudioDescrType:
  PUSH BX                          ;Save used registers
  MOV  BX,AudioDescrTypeTbl        ;Table to look in
  JMP >D00                         ;Do it
DoAudioTermType:
  PUSH BX                          ;Save used registers
  MOV  BX,AudioTermTypeTbl         ;Table to look in
  JMP >D00                         ;Do it
DoAudio1CtlDescrSType:
  PUSH BX                          ;Save used registers
  MOV  BX,Audio1CtlDescrSubTypeTbl ;Table to look in
  JMP >D00                         ;Do it
DoAudio1StrDescrSType:
  PUSH BX                          ;Save used registers
  MOV  BX,Audio1StrDescrSubTypeTbl ;Table to look in
  JMP >D00                         ;Do it
DoAudio1StrFmtTag:
  PUSH BX                          ;Save used registers
  MOV  BX,Audio1StrFmtTagTbl       ;Table to look in
  JMP >D00                         ;Do it
DoAudio1StrFmtType:
  PUSH BX                          ;Save used registers
  MOV  BX,Audio1StrFmtTypeTbl      ;Table to look in
  JMP >D00                         ;Do it
DoAudio1ProcType:
  PUSH BX                          ;Save used registers
  MOV  BX,Audio1ProcTypeTbl        ;Table to look in
  MOV  StoredByte2,AL              ;Store the value for later use
  JMP >D00                         ;Do it
DoAudio1EPDescrSType:
  PUSH BX                          ;Save used registers
  MOV  BX,Audio1EPDescrSubTypeTbl  ;Table to look in
  JMP >D00                         ;Do it
DoAudio1EPLockUnit:
  PUSH BX                          ;Save used registers
  MOV  BX,Audio1EPLockUnitTbl      ;Table to look in
  JMP >D00                         ;Do it
DoAudio2CtlDescrSType:
  PUSH BX                          ;Save used registers
  MOV  BX,Audio2CtlDescrSubTypeTbl ;Table to look in
  JMP >D00                         ;Do it
DoAudio2PrimaryUse:
  PUSH BX                          ;Save used registers
  MOV  BX,Audio2PrimaryUseTbl      ;Table to look in
  JMP >D00                         ;Do it
DoAudio2EfxType:
  PUSH BX                          ;Save used registers
  MOV  BX,Audio2EfxTypeTbl         ;Table to look in
  JMP >D00                         ;Do it
DoAudio2ProcType:
  PUSH BX                          ;Save used registers
  MOV  BX,Audio2ProcTypeTbl        ;Table to look in
  JMP >D00                         ;Do it
DoDescrType:
  PUSH BX                          ;Save used registers
  MOV  BX,DescriptorTypeTbl        ;Table to look in
  JMP >D00                         ;Do it
DoHIDDescrType:
  PUSH BX                          ;Save used registers
  MOV  BX,HIDDescriptorTypeTbl     ;Table to look in
  JMP >D00                         ;Do it
DoHIDCountry:
  PUSH BX                          ;Save used registers
  MOV  BX,HIDCountryTbl            ;Table to look in
  JMP >D00                         ;Do it
DoDvcClassStore:
  MOV  DeviceClass,AL              ;Store the value for later
DoDvcClass:
  PUSH BX                          ;Save used registers
  MOV  BX,DeviceClassTbl           ;Table to look in
  JMP >D10                         ;Do it
DoIntfClassStore:
  MOV  InterfaceClass,AL           ;Store the value for later
DoIntfClass:
  PUSH BX                          ;Save used registers
  MOV  BX,InterfaceClassTbl        ;Table to look in
  JMP >D10                         ;Do it
D00:                               ;Write "Unknown" if not found
  PUSH DX                          ;Save used registers
  MOV  DL,-1                       ;Mark as needing to write it
  JMP >D30                         ;Do it
D10:                               ;Write Number if not found
  PUSH DX                          ;Save used registers
  XOR  DX,DX                       ;Mark as not needing to write it
D30:                               ;Do it
  CALL SearchTblWrite              ;Look for a match
  JNC >D90                         ;If OK, we're done
  OR   DL,DL                       ;Are we supposed to write "Unknown"?
  JNZ >D40                         ;If so, do it
  CALL WriteWordMin                ;If not, just write the Number
  JMP >D90                         ;Done
D40:                               ;Write "Unknown"
  CALL WriteUnknownX               ;If so, write "Unknown!"
D90:                               ;Done
  POP  DX                          ;Restore used registers
  POP  BX                          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A SUBCLASS OR PROTOCOL DESCRIPTION FROM A DESCRIPTOR
;Inputs:  DS = Local Data Area
;         ES:[DI] = Class/SubClass/Protocol Parameters (Bytes)
;                   If SubClass, ES:[DI-1] = Class
;                   If Protocol, ES:[DI-2] = Class
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoDvcSubClassStore:
  MOV  DeviceSubClass,AL    ;Store the value for later
DoDvcSubClass:
  PUSH BX                   ;Save used registers
  MOV  BX,DeviceClassTbl    ;Point at Table
  JMP >C01                  ;Do it
DoIntfSubClassStore:
  MOV  InterfaceSubClass,AL ;Store the value for later
DoIntfSubClass:
  PUSH BX                   ;Save used registers
  MOV  BX,InterfaceClassTbl ;Point at Table
  JMP >C01                  ;Do it
DoDvcProtocolStore:
  MOV  DeviceProtocol,AL    ;Store the value for later
DoDvcProtocol:
  PUSH BX                   ;Save used registers
  MOV  BX,DeviceClassTbl    ;Point at Table
  JMP >C02                  ;Do it
DoIntfProtocolStore:
  MOV  InterfaceProtocol,AL ;Store the value for later
DoIntfProtocol:
  PUSH BX                   ;Save used registers
  MOV  BX,InterfaceClassTbl ;Point at Table
  JMP >C02                  ;Do it
C01:                        ;Do 1 level of SubTable
  PUSH CX,DI                ;Save used registers
  MOV  CL,1                 ;Do 1 SubTable
  DEC  DI                   ;Go back one Parameters
  JMP >C10                  ;Do it
C02:                        ;Do 2 levels of SubTable
  PUSH CX,DI                ;Save used registers
  MOV  CL,2                 ;Do 2 SubTable
  DEC  DI,2                 ;Go back two Parameters
;  JMP >C10                  ;Do it
C10:                        ;Do it
  CALL DoDescrSubTable      ;Do it
  POP  DI,CX                ;Restore used registers
  POP  BX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A DESCRIPTOR ATTRIBUTE THAT REQUIRES SUBTABLE SEARCHES
;Inputs:  [BX] = Starting Table to Search/Write
;         CL = Number of SubTables to Search/Write
;              1 = Table + 1 SubTable, etc.
;         ES:[DI] Points at Data (Bytes)
;Outputs: Writes appropriate things to the screen
;Changes: SI
;------------------------------------------------------------------------------
DoDescrSubTable:
  PUSH AX,BX,CX,DI      ;Save used registers
  MOV  CH,[BX]          ;Get the Table characteristics
  MOV  AL,ES:[DI]       ;Get the Parameter
  OR   CL,CL            ;Is this the last (Sub)Table to Handle?
  JNZ >G20              ;If not, handle it
  CALL SearchTblWrite   ;If so, write the Description
  JNC >G90              ;If it worked, we're done
  CALL WriteByteMin     ;If not, just write the number
  JMP >G90              ;Done
G20:                    ;Have valid Parameter, But not at end of SubTables
  CALL SearchTblNoWrite ;Look for a match in the Table (returns BX)
  JNC >G80              ;If OK, Look in the SubTable
G25:                    ;Loop to here to find the last Parameter
  DEC  CL               ;Decrement the SubTable Counter
  INC  DI               ;Increment the Parameter Pointer
  MOV  AL,ES:[DI]       ;Get the next Parameter
  OR   CL,CL            ;Is this the last Parameter we need?
  JNZ  G25              ;If not, keep looking
  CALL WriteByteMin     ;If so, just write the number
  JMP >G90              ;Done
G80:                    ;Go to the SubTable
  DEC  CL               ;Decrement SubTable Level
  INC  DI               ;Point at the next Parameter
  CALL DoDescrSubTable  ;Handle the SubTable
G90:                    ;Done
  POP  DI,CX,BX,AX      ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE REQUIRED TO PROCESS GENERAL DESCRIPTORS (APPLIES TO MANY TYPES)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;;------------------------------------------------------------------------------
;;WRITE A WORD OR BYTE, AND FINISH A DESCRIPTOR DECODING EARLY
;;Inputs:  DS = Local Data Area
;;Outputs: MiscFlags.EndOfDescr = True
;;Changes:
;;NOTES: This is needed when we are processing a descriptor that is not
;;         "standard" (the first byte is not the descriptor length).
;;------------------------------------------------------------------------------
;WriteWordMinDone:
;  CALL WriteWordMin         ;Write the Word Descriptor
;  OR   MiscFlags,EndOfDescr ;Mark as done with teh Descriptor
;  RET
;
;WriteByteMinDone:
;  CALL WriteByteMin         ;Write the Word Descriptor
;  OR   MiscFlags,EndOfDescr ;Mark as done with teh Descriptor
;  RET

;------------------------------------------------------------------------------
;WRITE A DESCRIPTOR TOTAL LENGTH LINE
;Inputs:  DS = Local Data Area
;         ES:[DI] = Descriptor Total Length
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoDescrTotalLength:
  PUSH AX,DX             ;Save used registers
  MOV  AX,ES:[DI]        ;Write the
  MOV  DX,TotalLengthMsg ;  Descriptor
  CALL WriteDescrWordDec ;  Tota Length
  POP  DX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A DESCRIPTOR ID LINE
;Inputs:  DS = Local Data Area
;         ES:[DI] = Byte Data to Write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoDescrUnitID:
  PUSH DX                 ;Save used registers
  MOV  DX,UnitIDMsg       ;[DX] = Header to write
  JMP >I00                ;Do it
DoDescrTerminalID:
  PUSH DX                 ;Save used registers
  MOV  DX,TerminalIDMsg   ;[DX] = Header to write
  JMP >I00                ;Do it
DoDescrSourceID:
  PUSH DX                 ;Save used registers
  MOV  DX,SourceEntityMsg ;[DX] = Header to write
  JMP >I00                ;Do it
DoDescrClockSrcID:
  PUSH DX                 ;Save used registers
  MOV  DX,ClockSrcMsg     ;[DX] = Header to write
;  JMP >I00                ;Do it
I00:
  PUSH AX                 ;Save used registers
  MOV  AL,ES:[DI]         ;Get the ID
  CALL WriteDescrByteDec  ;Write it
  POP  AX                 ;Restore used registers
  POP  DX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A DESCRIPTOR DESCRIPTION STRING LINE
;Inputs:  DS = Local Data Area
;         ES:[DI] = Byte Data to Write (String Index)
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoDescrUnitString:
  PUSH DX                  ;Save used registers
  MOV  DX,UnitStringMsg    ;[DX] = Header to write
  JMP >S00                 ;Do it
DoDescrTermString:
  PUSH DX                  ;Save used registers
  MOV  DX,TermStringMsg    ;[DX] = Header to write
;  JMP >S00                 ;Do it
S00:
  PUSH AX                  ;Save used registers
  MOV  AL,ES:[DI]          ;Get the ID
  CALL WriteDescrByteNoDec ;Write the String Index
  CALL DoGetString         ;Write the String
  POP  AX                  ;Restore used registers
  POP  DX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A VERSION NUMBER FROM A DESCRIPTOR
;Inputs:  DS = Local Data Area
;         AX = Version Number (from a Descriptor - BCD)
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoVersionStoreUSB:
  CALL ResetClassVer         ;Reset Class/SubClass/Protocol/Version Data
  MOV  DeviceUSBRelease,AX   ;Store the Word for Later Use
  JMP >V00                   ;Continue
DoVersionStoreClass:
  MOV  DeviceClassRelease,AX ;Store the Word for Later Use
;  JMP >V00                   ;Continue
V00:
DoVersion:
  PUSH AX,DX          ;Save used registers
  XCHG AL,AH          ;Put Major Version in AL
  CMP  AL,0Fh         ;Just a single Digit?
  JA  >V20            ;If not, write both digits
  CALL WriteNibbleHex ;If so, jsut write one digit
  JMP >V30            ;Continue
V20:                  ;Double-digit version
  CALL WriteByteHex   ;Write as a byte (both digits)
V30:                  ;Major version is done
  CALL WriteDot       ;Write the Dot
  XCHG AL,AH          ;Put Minor Version in AL
  CALL WriteByteHex   ;Write both characters of minor version
  POP  DX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESET THE CLASS/SUBCLASS/PROTOCOL/VERSION DATA FOR DESCRIPTORS
;Inputs:  DS = Local Data Area
;         CLD already issued
;Outputs: DeviceClass, etc., Reset to all zeroes
;Changes:
;------------------------------------------------------------------------------
ResetClassVer:
  PUSH AX,CX,DI,ES ;Save used registers
  MOV  ES,DS       ;Point ES:DI] at the data
  MOV  DI,(OFFSET DeviceClass)
  MOV  CX,5        ;Number of words in the data
  XOR  AX,AX       ;Store zeroes
  REP  STOSW       ;Fill the data area
  POP  ES,DI,CX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE STRING ASSOCIATED WITH A STRING INDEX FROM A DESCRIPTOR
;Inputs:  AL = String Index
;         Int14Request contains Host Index and Device Address (-1 if invalid)
;         ES = Data area of calling program
;Outputs: Write String, in QUotes, to the Screen (if available)
;         If string is Unavailable, writes "None"
;Changes:
;------------------------------------------------------------------------------
DoGetString:
  PUSH AX,CX,DX,DI,SI,ES             ;Save used registers
  MOV  ES,DS                         ;Point ES at our data area
  CALL ClearStringDescr              ;Zero-out the String Descriptor
  MOV  DI,Int14Request               ;Point at Request
  MOV  SI,StringDescrData            ;Point at String Data
  OR   AL,AL                         ;Valid String Index?
  JZ  >S70                           ;If not, write "None"
  CMP  [DI].I14RHostIndex,-1         ;Valid Host Index?
  JE  >S75                           ;If not, write "Unavailable"
  CMP  [DI].I14RDeviceAddress,-1     ;Valid Host Index??
  JE  >S75                           ;If not, write "Unavailable"
  MOV  GetStringIndex[0],AL          ;Store String Index
  MOV  [DI].I14REndPoint,0           ;End Point 0
  MOV  CX,DS                         ;Put Our Segment in CX
  MOV  W [DI].I14RDataAddress[2],CX  ;Where to store
  MOV  W [DI].I14RDataAddress[0],SI  ;  the String Descriptor
  MOV  W [DI].I14RCallBackAddr[2],CX ;Store our
  MOV  W [DI].I14RCallBackAddr[0],GetStringFarCall
  MOV  W [DI].I14RUserPktID,0        ;User Packet ID
  MOV  [DI].I14RRequestType,I14RRTDoControl
  MOV  CX,GetStringDescrReq          ;Copy the
  CALL CopySetupReqToInt14DI         ;  Setup Request
  OR   [DI].I14RFlags,I14RFlagShortPktOK ;No Retries for Short Packets
  MOV  W [DI].I14RStringDescrSize,2  ;Get the first two bytes of string (size)
  CALL SendStringReq                 ;Send the Request
  JC  >S75                           ;If error, write "Unavailable"
  MOV  AX,[SI]                       ;Get the String Size
  CMP  AX,MaxStrSize                 ;Will it fit in our buffer?
  JBE >S20                           ;If so, continue
  MOV  AX,MaxStrSize                 ;If not, just fill our buffer
S20:                                 ;Size is handled
  MOV  W [DI].I14RStringDescrSize,AX ;Store the Size
  CALL SendStringReq                 ;Send the Request
  JC  >S75                           ;If error, write "Unavailable"
  CALL WriteDoubleQuote              ;Write a Quote
  INC  SI,2                          ;Point DS:[SI] at the String (not Size)
  CALL WriteUniCodeString            ;Write it
  CALL WriteDoubleQuote              ;Write a Quote
  JMP >S90                           ;Done
S70:                                 ;No String to Write
  MOV  DX,NoneMsg                    ;Write the No String Message
  JMP >S78                           ;Done
S75:                                 ;String not available
  MOV  DX,UnAvailMsg                 ;Point at "Unavailable" message
S78:                                 ;DX pointed at correct Message
  CALL WriteItDX                     ;Write the message
S90:                                 ;Done
  AND  [DI].I14RFlags,(NOT I14RFlagShortPktOK) ;Retry for Short Packets again
  POP  ES,SI,DI,DX,CX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY THE REMOTE STRING DATA TO OUR LOCAL DATA AREA
;Inputs:  ES:[DI] = Remote String to Write
;         ES:[DI-2] = Size of String Descriptor (Bytes)
;         CS = Local Data Area
;         CLD already issued
;Outputs: Copies remote string to our local data area (StringDescrData)
;Changes:
;------------------------------------------------------------------------------
CopyStringDescr:
  PUSH CX,DI,SI,DS,ES     ;Save used registers
  CALL ClearStringDescr   ;Zero-out our String Descriptor
  SwapDSES                ;Point DS at remote data, ES at Local Data
  MOV  SI,DI              ;DS:[SI] = Remote Data (Actual String)
  MOV  DI,StringDescrData ;ES:[DI] = Local Data Area
  XOR  CX,CX              ;CX = Number
  MOV  CL,[SI-2]          ;  of Byte
  DEC  CX,2               ;  to Copy
  REP  MOVSB              ;Copy the Data
  POP  ES,DS,SI,DI,CX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ZERO OUT THE STRING DESCRIPTOR DATA AREA
;Inputs:  CS = Local Data Area
;         CLD already issued
;Outputs: Sets StringDescrData to all zeroes
;Changes:
;------------------------------------------------------------------------------
ClearStringDescr:
  PUSH AX,CX,DI,ES        ;Save used registers
  XOR  AX,AX              ;Write Zeroes
  MOV  CX,(MaxStrSize/2)  ;Number of Words to Write
  MOV  ES,CS              ;Point ES:[DI] at
  MOV  DI,StringDescrData ;  the string
  REP  STOSW              ;Write the data
  POP  ES,DI,CX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEND A REQUEST TO DOWNLOAD A STRING DESCRIPTOR
;Inputs:  [DI] = Int 14 Request (filled in)
;         [SI] = String pointer
;Outputs: CF = Clear if OK (string downloaded OK)
;            = Set if Error
;Changes:
;------------------------------------------------------------------------------
SendStringReq:
  PUSH AX                   ;Save used registers
  MOV  GotStringDescr,-1    ;Mark flag
  MOV  W [SI],0             ;Mark string as invalid
  CALL DoInt14CallSaveAllDI ;Do it
  JC  >Q70                  ;If error, quit
Q20:                        ;Loop to here to wait for request
  MOV  AX,GotStringDescr    ;Put Error Code in AX
  CMP  AX,-1                ;Got the string yet?
  JE   Q20                  ;If not, keep waiting
  OR   AX,AX                ;Any errors?
  JZ  >Q30                  ;If not, continue
  CMP  AX,TDStsShortPacket  ;If so, is it just a Short Packet?
  JNE >Q70                  ;If not, Error
Q30:                        ;No Packet Errors
  CMP  W [SI],4             ;Is it a valid string size?
  JAE >Q80                  ;If so, it's OK
Q70:                        ;Error
  STC                       ;Set error flag
  JMP >Q90                  ;Done
Q80:                        ;OK
  CLC                       ;Set OK flag
Q90:                        ;Done
  POP  AX                   ;Restore used registers
  RET

GetStringFarCall:
  MOV  GotStringDescr,AX ;Mark as done
  RETF

;------------------------------------------------------------------------------
;WRITE A UNICODE STRING TO THE SCREEN
;Inputs:  DS:[SI] = String to Write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteUniCodeString:
  PUSH AX,CX,DI          ;Save used registers
  CALL InitCmdTail       ;Initialize the Command-Tail String
  MOV  AX,DS             ;Append the
  MOV  CX,SI             ;  Memory Address
  CALL AppendSegOff2Cmd  ;  to the Command Tail
  MOV  DI,SupportFileUni ;FileName to Look For
  CALL HandleExecCall    ;Execute the Support File
  POP  DI,CX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A STRING DESCRIPTOR
;Inputs:  ES:[DI] = Descriptor Data to write (ES:[DI-2] = Start of Descr)
;Outputs: To Screen
;Changes: DI
;NOTES: Nothing in the String Descriptor itself can be used to directly tell
;         whether the String Descriptor was requested with Language ID 0 (in
;         which case the Descriptor Entries are Language ID Codes), or
;         whether the String was requested with a specific Language ID (in
;         which case the Descriptor Entries are UniCode characters).  But,
;         we want to make this code as "automatic" as possible, so we will
;         try to automatically determine whether or not the Descriptor was
;         requested with Language ID 0.
;       To do this, we will perform two different tests.  The first test
;         will compare each Descriptor entry to see if it matches any of
;         the known, valid Language ID's.  There are only a few dozen valid
;         Language ID's, and none of the Language ID codes match "common"
;         (English) UniCode characters, so this should be a pretty reliable
;         and accurate test.
;       The second test will be to see if there are any duplicate Descriptor
;         Entries.  A Language ID 0 String Descriptor should never return the
;         same Language ID more than once, while a "real" string more than
;         likely will use at least one UniCode character more than once (most
;         strings will have at least two spaces, for example).
;       It is still possible, though EXTREMELY unlikely, that a String
;         Descriptor could pass both tests and still be a "real" String
;         Descriptor (not Language ID 0).  If that ever happens, we'll deal
;         with it at that time.
;------------------------------------------------------------------------------
FinishStringDescr:
  PUSH AX,CX,DX,SI            ;Save used registers
  MOV  AL,ES:[DI-2]           ;Get the Descriptor Size
  SHR  AL,1                   ;If OK, divide by 2
  DEC  AL                     ;Compensate for Length/DescrType bytes
  XOR  CX,CX                  ;Put string size
  MOV  CL,AL                  ;  in CX
  CALL TestString0            ;Test for Language ID vs Actual String (rtns CF)
  MOV  CH,CL                  ;Put counter in CH
  MOV  CL,1                   ;Start with Language ID Number 1
  JC  >Z40                    ;If Language ID's, jump to handle it
Z10:                          ;Is a UniCode String
  MOV  DX,TheStringMsg        ;Write the
  CALL WriteDTagColon         ;  Description
  CALL Write12Spaces          ;Move over
  CALL WriteDoubleQuote       ;Start with a Quote
  CALL CopyStringDescr        ;Copy the remote data to our local data
  MOV  SI,StringDescrData     ;Point DS:[SI] at the String
  CALL WriteUniCodeString     ;Write the String
  CALL WriteDoubleQuote       ;Finish with a Quote
  JMP >Z90                    ;Done
Z30:                          ;Loop to here for each Language ID
  CALL WriteCrLf              ;Write a New Line
Z40:                          ;Write the Language ID
  MOV  AX,ES:[DI]             ;Get the Language ID
  MOV  DX,LanguageIDMsg       ;Write the
  CALL WriteDescrWordNumNoDec ;  Language ID Number
  CALL DoStringLangWriteNoNum ;Write the Description
  INC  DI,2                   ;Increment the Language ID
  INC  CL                     ;Increment eh Language ID Number
  DEC  CH                     ;Decrement Loop Counter
  JNZ  Z30                    ;If not 0 yet, keep writing
Z90:                          ;Done
  POP  SI,DX,CX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST A STRING DESCRIPTOR TO SEE IF IT WAS REQUESTED WITH LANGUAGE ID 0
;Inputs:  CX = Number of Entries to test
;         ES:[DI] = Entries to test
;Outputs: CF = Clear if appears to be Language ID <> 0
;            = Set if appears to be Language ID 0
;Changes:
;------------------------------------------------------------------------------
TestString0:
  PUSH AX,BX      ;Save used registers
  PUSH CX,DI      ;Save used registers
T10:              ;Loop to here for each Descriptor ENtry
  MOV  AX,ES:[DI] ;Get the next Entry
  INC  DI,2       ;Increment the Pointer
  CALL DoStringLangNoWrite ;Is it a valid Language ID?
  JC  >T80        ;If not, it can't be Language ID 0
  CMP  CX,1       ;Last Entry?
  JE  >T70        ;If so, it's Language ID 0
  PUSH CX,DI      ;If not, save Counter and Pointer
  DEC  CX         ;Number of other Entries to compare with
T30:              ;Loop to here for each Entry
  CMP  AX,ES:[DI] ;Is it a Repeat?
  JE  >T40        ;If so, exit the loop early (not Lang ID 0)
  INC  DI,2       ;If not, point at the next entry
  LOOP T30        ;Keep testing
T40:              ;Done with repeat Test
  OR   CX,CX      ;Get all the way to the end of the Descr?
  POP  DI,CX      ;Restore Counter and Pointer
  JNZ >T80        ;If not at end of Descr, not Lang ID 0
  LOOP T10        ;Keep going
T70:              ;Language ID 0
  STC             ;Set Return Flag
  JMP >T90        ;Done
T80:              ;Not Language ID 0
  CLC             ;Set return flag
T90:              ;Done
  POP  DI,CX      ;Restore used registers
  POP  BX,AX      ;Restore used registers
  RET

DoNothing:
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE REQUIRED TO PROCESS CONFIGURATION DESCRIPTORS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE THE DESCRIPTION FOR A CONFIGURATION ATTRIBUTES BYTE
;Inputs:  AL = Configuration Attribute Byte (from a Configuration Descriptor)
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoConfigAttribs:
  PUSH BX               ;Save used registers
  MOV  BX,ConfigAttrTbl ;Table to search in
  CALL DoByteBitMaskCr  ;Write the Attributes
C90:                    ;Done
  POP  BX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A POWER OVER 2
;Inputs:  AL = Power / 2 (mA)
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoPowerOver2:
  PUSH AX,DX           ;Save used registers
  CALL WriteByteMin    ;Write the number
  MOV  DX,MilliAmpMsg1 ;Write the first part
  CALL WriteItDX       ;  of the MilliAmp Message
  XOR  AH,AH           ;Multiply
  SHL  AX,1            ;  by 2
  CALL WriteWordMin    ;Write it
  MOV  DX,MilliAmpMsg2 ;Write the last part
  CALL WriteItDX       ;  of the MilliAmp Message
  POP  DX,AX           ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE REQUIRED TO PROCESS ENDPOINT DESCRIPTORS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE THE END POINT NUMBER BYTE (INCLUDES DIRECTION)
;Inputs:  AL = End Point Number & Direction (from an End Point Descriptor)
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoEndPointNumber:
  PUSH AX,BX,DX             ;Save used registers
  MOV  DX,EndPointMsg       ;Write the
  CALL WriteItDX            ;  Description
  MOV  AH,AL                ;Save the Direction Flag
  AND  AL,(NOT 80h)         ;Get rid of Direction Flag
  CALL WriteByteMin         ;Write the EndPoint Number in Decimal
  CALL Write2Spaces         ;Move over
  MOV  AL,AH                ;Restore Direction Flag
  MOV  BX,InOutDirectionTbl ;Write the
  CALL DoByteBitMaskCr      ;  Direction
  POP  DX,BX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE DESCRIPTION FOR AN ENDPOINT ATTRIBUTES BYTE
;Inputs:  AL = EndPoint Attribute Byte (from an EndPoint Descriptor)
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoEndPointAttribs:
  PUSH BX                 ;Save used registers
  MOV  BX,EndPointAttrTbl ;Table to search in
  CALL DoByteBitMaskSp    ;Write the Attributes
  POP  BX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A REFRESH RATE (2^N)
;Inputs:  AL = Refresh Rate Exponent (N in 2^N)
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoRefreshRate:
  PUSH AX,CX,DX        ;Save used registers
  CALL WriteByteMin    ;Write the number
  MOV  DX,MilliSecMsg1 ;Write the first part
  CALL WriteItDX       ;  of the MilliSecond Message
  MOV  CL,AL           ;Put Exponent in CL (to use as a Shift Byte)
  MOV  AX,1            ;Start with a Shift value of 1
  SHL  AX,CL           ;Calculate the enponentiated value
  CALL WriteWordMin    ;Write it
  MOV  DX,MilliSecMsg2 ;Write the last part
  CALL WriteItDX       ;  of the MilliSecond Message
  POP  DX,CX,AX        ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE REQUIRED TO PROCESS ON-THE-GO DESCRIPTORS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE THE DESCRIPTION FOR AN ON-THE-GO ATTRIBUTES BYTE
;Inputs:  AL = On-The-Go Characteristics Byte (from an OTG Descriptor)
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoOntheGoAttribs:
  PUSH BX                ;Save used registers
  MOV  BX,OnTheGoAttrTbl ;Table to search in
  CALL DoByteBitMaskCr   ;Write the Attributes
  POP  BX                ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE REQUIRED TO PROCESS HUB DESCRIPTORS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE A TIME OVER 2 (MS)
;Inputs:  AL = Time / 2 (mS)
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoTimeOver2:
  PUSH AX,DX           ;Save used registers
  CALL WriteByteMin    ;Write the number
  MOV  DX,MilliSecMsg1 ;Write the first part
  CALL WriteItDX       ;  of the MilliSecond Message
  XOR  AH,AH           ;Multiply
  SHL  AX,1            ;  by 2
  CALL WriteWordMin    ;Write it
  MOV  DX,MilliSecMsg2 ;Write the first part
  CALL WriteItDX       ;  of the MilliSecond Message
  POP  DX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A POWER
;Inputs:  AL = Power (mA)
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoPower:
  PUSH AX           ;Save used registers
  CALL WriteByteMin ;Write the number
  CALL WriteSpace   ;Move over
  MOV  AL,'m'       ;Write
  CALL WriteAL      ;  the
  MOV  AL,'A'       ;  "mA"
  CALL WriteAL      ;  message
  POP  AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE LAST SEVERAL BYTES OF A HUB DESCRIPTOR
;Inputs:  ES:[DI] = Descriptor Data to write
;         CL = Indent to use
;Outputs: To Screen
;Changes: DI
;------------------------------------------------------------------------------
FinishHubDescr:
  PUSH AX,BX,CX,DX,DI      ;Save used registers
  MOV  BL,ES:[DI-5]        ;Get the number of Ports
  MOV  CL,(DescrLineLen-3) ;Set proper value for space indents
  MOV  DX,HubRemovableMsg  ;Write the
  CALL WriteDTagColon      ;  Removable Ports Message
  CALL Write7Spaces        ;Move over
  MOV  AL,ES:[DI]          ;Get the Removable Ports value
  INC  DI                  ;Increment Pointer
  OR   AL,AL               ;Any Data?
  JNZ >H10                 ;If so, continue
  CALL WriteNone           ;If not, write None
  CALL WriteCrLf           ;Move Down
  JMP >H30                 ;Continue
H10:                       ;The byte contains some data
  MOV  BH,BL               ;Get the total number of bits to do
  MOV  DL,2                ;Start with first bit mask (bit 0 = reserved)
  MOV  DH,1                ;First Port number is 1
  CALL DoHubDescrNums      ;Do it
  JNC >H30                 ;If done with all Ports, continue
H20:                       ;Loop to here for each Removability Byte
  MOV  AL,ES:[DI]          ;Get the
  INC  DI                  ;  next byte
  CALL WriteSpaces         ;Write some spaces (uses CL)
  CALL DoHubDescrNums      ;Do it
  JC   H20                 ;If not done yet, keep going
H30:                       ;Done with Removability
  MOV  DX,HubPortPowerMsg  ;Write the
  MOV  AL,ES:[DI]          ;  Port Power
  CALL WriteDescrByteNoDec ;  Data Byte
  MOV  DX,ObsoleteMsg      ;Write
  CALL WriteItDX           ;  "Obsolete"
H90:                       ;Done
  POP  DI,DX,CX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE DESCRIPTION FOR A HUB CHARACTERISTICS WORD
;Inputs:  AX = Hub Characteristics Word (from a Hub Descriptor)
;Outputs: To Screen
;Changes:
;NOTES: Currently, only AL contains valid data, so we ignore AH
;------------------------------------------------------------------------------
DoHubChars:
  PUSH BX              ;Save used registers
  MOV  BX,HubCharTbl   ;Table to search in
  CALL DoByteBitMaskCr ;Write the Status
  POP  BX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE PORT NUMBERS ASSOCIATED WITH THE LAST BYTES OF A HUB DESCRIPTOR
;Inputs:  AL = Bit-mapped Byte to test (1 = write the number)
;         BH = Number of Ports left to test
;         DL = Starting Bit-mask to use
;         DH = Starting Number to write
;Outputs: CF = Clear if all ports are done
;              BH = 0
;              DL, DH Undefined
;            = Set if more ports left to do
;              BH = Number of ports still left to do
;              DL = 1
;              DH = Next Port Number to write
;         Write Data Byte (AL) to Screen in Hex, followed by "h",
;           followed by 2 spaces, followed by Masked Port Numbers,
;           followed by a CrLf
;Changes:
;------------------------------------------------------------------------------
DoHubDescrNums:
  CALL WriteByteHex ;Write the Byte
  CALL WriteHexEnd  ;Write the "h"
  CALL Write2Spaces ;Write some Spaces
N10:                ;Loop to here for each bit
  TEST AL,DL        ;Is this bit set?
  JZ  >N20          ;If not, continue
  PUSH AX           ;If so,
  MOV  AL,DH        ;  write
  CALL WriteByteMin ;  the
  POP  AX           ;  Port Number
  CALL WriteSpace   ;Write a Space
N20:                ;Done with this bit
  DEC  BH           ;Decrement Port Counter
  JZ  >N80          ;If no ports left, quit
  INC  DH           ;Increment the Port Number
  ROL  DL,1         ;Shift the bit-mask tester
  JC  >N70          ;If we've done all the bits, quit
  JMP  N10          ;Keep going
N70:                ;Done with this byte, more ports left
  STC               ;Set return flag
  JMP >N90          ;Done
N80:                ;Really Done (no Ports Left)
  CLC               ;Set return flag
N90:                ;Done
  PUSHF             ;Save return flag
  CALL WriteCrLf    ;Start a new line
  POPF              ;Restore return flag
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE REQUIRED TO WRITE AUDIO CLASS-SPECIFIC DESCRIPTORS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE REQUIRED TO WRITE HID CLASS-SPECIFIC DESCRIPTORS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE THE PORT NUMBERS ASSOCIATED WITH THE LAST BYTES OF A HUB DESCRIPTOR
;Inputs:  AL = Number of Classes
;         ES:[DI] = First HID Class Descriptor Type
;Outputs: Writes HID Descriptors, as appropriate, to the screen
;Changes:
;------------------------------------------------------------------------------
FinishHIDDescr:
  PUSH AX,CX,DX,DI            ;Save used registers
  MOV  CH,AL                  ;CH = Number of Classes
  MOV  CL,1                   ;Start with Class 1
H10:                          ;Loop to here for each Class Descriptor Entry
  MOV  DX,HIDTypeMsg          ;Write
  MOV  AL,ES:[DI]             ;  the
  CALL WriteDescrByteNumNoDec ;  Class
  CALL DoHIDDescrType         ;  Type
  CALL WriteCrLf              ;Move down
  INC  DI                     ;Increment the Pointer
  MOV  DX,HIDSizeMsg          ;Write the
  MOV  AX,ES:[DI]             ;  Class
  CALL WriteDescrWordNumDec   ;  Size
  INC  DI,2                   ;Increment the Pointer
  INC  CL                     ;Increment the Counter
  CMP  CL,CH                  ;Done all of the Descriptors yet?
  JA  >H90                    ;If so, we're done
  CALL WriteCrLf              ;If not, move down
  JMP  H10                    ;Keep going until we're done
H90:                          ;Done
  POP  DI,DX,CX,AX            ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS A CONTROL (SETUP) PACKET
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PRINT CONTROL (SETUP) PACKET
;Inputs:  ES:[BX] = Setup Packet Structure to Write
;         DS = Local Data Area
;Outputs: Writes Control Packet, with Descriptions, to the Screen
;Changes:
;------------------------------------------------------------------------------
WriteControlPkt:
  PUSH CX,DI,SI                ;Save used registers
  MOV  Indent,(DescrLineLen+2) ;Set Indent
  MOV  DI,BX                   ;Point ES:[DI] at the Structure
  MOV  CL,8                    ;CL = Number of Bytes in the Descriptor
  MOV  SI,ControlPktTbl        ;Point at the Description Table
  CALL DoDescriptorTbl         ;Write the Description
  POP  SI,DI,CX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs:  DS = Local Data Area
;         AL = Setup Request Type (from Control Setup Packet)
;         ES:[DI-1] = Control Setup Packet (SRRequestType)
;------------------------------------------------------------------------------
DoSetupReqType:
  PUSH BX                      ;Save used registers
  MOV  BX,SetupReqRecipientTbl ;Table to search
  CALL DoByteBitMaskCr         ;Write the Recipient
  POP  BX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs:  DS = Local Data Area
;         AL = Setup Request Specific Request (from Control Setup Packet)
;         ES:[DI-2] = Control Setup Packet (SRRequestType)
;------------------------------------------------------------------------------
DoSetupReqRequest:
  PUSH BX                    ;Save used registers
  MOV  BL,ES:[DI-2]          ;Get the
  AND  BL,SRRTTypeMask       ;  Request Type
  CMP  BL,SRRTTypeStandard   ;Is it a Standard Request?
  JNE >R80                   ;If not, just write the Number
  MOV  BX,SetupReqRequestTbl ;Table to search
  CALL DoByteBitMaskCr       ;Write the Request Type
  JMP >R90                   ;Done
R80:                         ;Just write the Number
  CALL WriteByteMin          ;Write the Number
R90:                         ;Done
  POP  BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs:  DS = Local Data Area
;         AX = Setup Request Value (from Control Setup Packet)
;         ES:[DI-4] = Control Setup Packet (SRRequestType)
;------------------------------------------------------------------------------
DoSetupReqValue:
  PUSH AX,BX,DX            ;Save used registers
  MOV  BX,ES:[DI-4]        ;Get the Request Type (BL) and Specific Req (BH)
  AND  BL,SRRTTypeMask     ;Is it a
  CMP  BL,SRRTTypeStandard ;  Standard Request?
  JNE >V80                 ;If not, just write the raw number
  MOV  DX,AX               ;Save original Value
  MOV  AL,BH               ;If so, put the Specific Request in AL
  MOV  BX,SetupReqValueTbl ;Point at the table of code offsets
  CALL Byte2WordTbl        ;See if it's a recognized Specific Request
  MOV  AX,DX               ;Restore the original Value
  JC  >V80                 ;If not a recognized Value, just write the raw number
  CALL BX                  ;Perform the code
  JC  >V90                 ;
V80:                       ;Need to write the original word
  CALL WriteWordMin        ;Write the Value
V90:                       ;Need to write the Value
  POP  DX,BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs:  DS = Local Data Area
;         AX = Setup Request Value (from Control Setup Packet)
;         ES:[DI-4] = Control Setup Packet (SRRequestType)
;------------------------------------------------------------------------------
DoSetFeature:
DoClearFeature:
  PUSH BX,DX                  ;Save used registers
  MOV  DX,FeatureMsg          ;Write the
  CALL WriteItDX              ;  Feature Message
  MOV  DL,ES:[DI-4]           ;Get the
  AND  DL,SRRTRecipientMask   ;  Recipient
  MOV  BX,DeviceFeatureTbl    ;Assume Device
  CMP  DL,SRRTRecipDevice     ;Is it Device?
  JE  >F20                    ;If so, handle it
  MOV  BX,InterfaceFeatureTbl ;Assume Interface
  CMP  DL,SRRTRecipInterface  ;Is it Interface?
  JE  >F20                    ;If so, handle it
  MOV  BX,EndPointFeatureTbl  ;Assume EndPoint
  CMP  DL,SRRTRecipEndPoint   ;Is it EndPoint?
  JNE >F70                    ;If not, just write the Number
F20:                          ;Search the Table
  CALL SearchTblWrite         ;Search for The Feature Description
  JNC >F80                    ;If success, we're done
  CALL WriteUnknown           ;If not, write Unknown!
F70:                          ;Need to write the Raw Number
  CLC                         ;Set return flag
  JMP >F90                    ;Done
F80:                          ;Don't need to write the Raw Number
  STC                         ;Set requrn flag
F90:                          ;Done
  POP  DX,BX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Inputs:  DS = Local Data Area
;         AX = Setup Request Value (from Control Setup Packet)
;         ES:[DI-4] = Control Setup Packet (SRRequestType)
;------------------------------------------------------------------------------
DoSetAddress:
  PUSH DX                 ;Save used registers
  MOV  DX,AddressMsg      ;Point at the Address Message
  JMP >S00                ;Do it
DoSetConfig:
  PUSH DX                 ;Save used registers
  MOV  DX,ConfigMsg       ;Point at the Configuration Message
  JMP >S00                ;Do it
DoSetInterface:
  PUSH DX                 ;Save used registers
  MOV  DX,AltInterfaceMsg ;Point at the Configuration Message
;  JMP >S00                ;Do it
S00:                      ;DX points at Message to write
  CALL WriteItDX          ;Write the Message
  POP  DX                 ;Restore used registers
  CLC                     ;Mark as needing to write the Raw Number
  RET

;------------------------------------------------------------------------------
;Inputs:  DS = Local Data Area
;         AX = Setup Request Value (from Control Setup Packet)
;         ES:[DI-4] = Control Setup Packet (SRRequestType)
;------------------------------------------------------------------------------
DoGetDescriptor:
DoSetDescriptor:
  XCHG AL,AH        ;Put Descriptor Type in AL
  CALL DoDescrType  ;Write the Descriptor Type
  CALL WriteSpace   ;Move over
  XCHG  AL,AH       ;Write the
  CALL WriteByteMin ;  Descriptor Index
  STC               ;Mark as not needing to write the raw number
  RET

;------------------------------------------------------------------------------
;Inputs:  DS = Local Data Area
;         AX = Setup Request Index (from Control Setup Packet)
;         ES:[DI-6] = Control Setup Packet (SRRequestType)
;------------------------------------------------------------------------------
DoSetupReqIndex:
  PUSH BX,DX                 ;Save used registers
  MOV  BX,ES:[DI-6]          ;Get the Request Type (BL)
  AND  BL,SRRTTypeMask       ;  & Specific Request (BH)
  CMP  BL,SRRTTypeStandard   ;Is it a Standard Request?
  JNE >X85                   ;If not, just write the Number
  CMP  BH,SRRQGetDescriptor  ;Is it Get Descriptor?
  JE  >X10                   ;If so, handle it
  CMP  BH,SRRQSetDescriptor  ;Is it Set Descriptor?
  JNE >X20                   ;If not, try next possibility
X10:                         ;Get/Set Descriptor
  CMP  B ES:[DI-3],DescrTypeString ;Is it a Get/Set String Descriptor?
  JNE >X20                   ;If not, try next possibility
  MOV  DX,LanguageMsg        ;Write the
  CALL WriteItDX             ;  Language Descriptor
  CALL DoStringLangWrite     ;Write the Language
  JMP >X90                   ;Done
X20:                         ;Not a Get/Set String Descriptor
  MOV  BL,ES:[DI-6]          ;Get the
  AND  BL,SRRTRecipientMask  ;  Recipient
  CMP  BL,SRRTRecipEndPoint  ;Is it an EndPoint?
  JE  >X40                   ;If so, handle it
  CMP  BL,SRRTRecipInterface ;Is it an Interface?
  JNE >X85                   ;If not, just write the Number
X30:                         ;Recipient = Interface
  MOV  DX,InterfaceMsg       ;Preface Interface
  JMP >X80                   ;Jump to write the Interface Number
X40:                         ;Recipient = EndPoint
  CALL DoEndPointNumber      ;Write the End Point Number and Direction
  JMP >X90                   ;Done
X80:                         ;Write the Raw Number with a Description
  CALL WriteItDX             ;Write the Description
X85:                         ;Write the Raw Index Number
  CALL WriteWordMin          ;Write the Raw Number
X90:                         ;Done
  POP  DX,BX                 ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS AN INT 14 REQUEST
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PRINT INT 14 REQUEST STRUCTURE
;Inputs:  ES:[BX] = Request Structure to Write
;         DS = Local Data Area
;Outputs: Writes Request Structure, with Descriptions, to the Screen
;Changes:
;------------------------------------------------------------------------------
WriteInt14Struc:
  PUSH CX,DI,SI                ;Save used registers
  MOV  Indent,(DescrLineLen+2) ;Set Indent
  MOV  DI,BX                   ;Point ES:[DI] at the Structure
  MOV  CL,64                   ;CL = Number of Bytes
  MOV  SI,Int14ReqStrucTbl     ;Point at the Description Table
  CALL DoDescriptorTbl         ;Write the Description
  POP  SI,DI,CX                ;Restore used registers
  RET

DoI14RRequestType:
  PUSH BX                    ;Save used registers
  MOV  BX,I14RRequestTypeTbl ;Table to Search
  CALL DoByteBitMaskCr       ;Write the Request Type
  POP  BX                    ;Restore used registers
  RET

DoI14RFlags:
  PUSH BX              ;Save used registers
  MOV  BX,I14RFlagsTbl ;Table to search in
  CALL DoByteBitMaskCr ;Write the Flags
  POP  BX              ;Restore used registers
  RET

DoI14RVendorID:
  PUSH DX              ;Save used registers
  CMP  AX,-1           ;Code for Any Vendor?
  JNE >V20             ;If not, handle a Regular Code
  MOV  DX,AnyVendorMsg ;If so, write the
  CALL WriteItDX       ;  Any Vendor Message
  JMP >V90             ;Done
V20:                   ;Not Any Vendor
  OR   AX,AX           ;Vendor 0?
  JNZ >V40             ;If not, it's a real Vendor Code
  CALL WriteWordMin    ;If so, just write the 0
  JMP >V90             ;Done
V40:                   ;Real Vendor Code
  CALL DoVendorID      ;Write the Real Vendor Description
V90:                   ;Done
  POP DX               ;Save used registers
  RET

DoI14RProductID:
  PUSH DX               ;Save used registers
  CMP  AX,-1            ;Code for Any Product?
  JNE >P20              ;If not, handle a Regular Code
  MOV  DX,AnyProductMsg ;If so, write the
  CALL WriteItDX        ;  Any Product Message
  JMP >P90              ;Done
P20:                    ;Not Any Vendor
  CALL WriteWordMin     ;If so, just write the 0
P90:                    ;Done
  POP DX                ;Save used registers
  RET

DoI14RHostIndex:
  PUSH BX,DX                 ;Save used registers
  MOV  BX,WriteByteMin       ;What to do if it is not Any/All Hosts
  MOV  DX,AllHostsMsg        ;What to write if it is Any/All Hosts
  JMP >F00                   ;Do it
DoI14RDvcClass:
  PUSH BX,DX                 ;Save used registers
  MOV  BX,DoDvcClass         ;What to do if it is not Any
  MOV  DX,AnyDvcClassMsg     ;What to write if it is Any
  JMP >F00                   ;Do it
DoI14RDvcSubClass:
  PUSH BX,DX                 ;Save used registers
  MOV  BX,DoDvcSubClass      ;What to do if it is not Any
  MOV  DX,AnyDvcSubClassMsg  ;What to write if it is Any
  JMP >F00                   ;Do it
DoI14RDvcProtocol:
  PUSH BX,DX                 ;Save used registers
  MOV  BX,DoDvcProtocol      ;What to do if it is not Any
  MOV  DX,AnyDvcProtocolMsg  ;What to write if it is Any
  JMP >F00                   ;Do it
DoI14RIntfClass:
  PUSH BX,DX                 ;Save used registers
  MOV  BX,DoIntfClass        ;What to do if it is not Any
  MOV  DX,AnyIntfClassMsg    ;What to write if it is Any
  JMP >F00                   ;Do it
DoI14RIntfSubClass:
  PUSH BX,DX                 ;Save used registers
  MOV  BX,DoIntfSubClass     ;What to do if it is not Any
  MOV  DX,AnyIntfSubClassMsg ;What to write if it is Any
  JMP >F00                   ;Do it
DoI14RIntfProtocol:
  PUSH BX,DX                 ;Save used registers
  MOV  BX,DoIntfProtocol     ;What to do if it is not Any
  MOV  DX,AnyIntfProtocolMsg ;What to write if it is Any
  JMP >F00                   ;Do it
F00:
  CMP  AL,-1                 ;Code for Any?
  JNE >F20                   ;If not, handle a Regular Code
  CALL WriteItDX             ;If so, write the Any Message
  JMP >F90                   ;Done
F20:                         ;Not Any
  CALL BX                    ;Write the Ral Description
F90:                         ;Done
  POP  DX,BX                 ;Save used registers
  RET

DoI14RTimeout:
  PUSH DX            ;Save used registers
  OR   AX,AX         ;Is it 0?
  JNZ >T20           ;If not, handle a regular Timeout
  MOV  DX,DefaultMsg ;If so, write the
  CALL WriteItDX     ;  "Use Default" message
  JMP >T90           ;Done
T20:                 ;Not 0
  CALL WriteWordMin  ;Just write the Number
T90:                 ;Done
  POP  DX            ;Restore used registers
  RET

DoI14RDataAddress:
  TEST B ES:[DI-4-((OFFSET I14RDataAddress)-(OFFSET I14RFlags))],I14RFlagAddrIsPhys
  JNZ >D20                ;If Data Address is Physical, jump to handle it
  CALL WriteSegmentOffset ;If not, write it as Segment:Offset
  JMP >D90                ;Done
D20:                      ;Data Address is Physical
  CALL WriteDWordHex
  CALL WriteHexEnd        ;Write the "h"
D90:                      ;Done
  RET

;------------------------------------------------------------------------------
;WRITE THE LAST SEVERAL BYTES OF AN INT 14h DESCRIPTOR
;Inputs:  ES:[DI] = Descriptor Data to write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
FinishInt14ReqDescr:
  PUSH AX,BX,CX,DX,DI    ;Save used registers
  MOV  CX,7              ;CX = Number of words to write
  MOV  DX,ReservedMsg    ;DX = Description String to use
Q10:                     ;Loop to here for each word
  MOV  AX,ES:[DI]        ;Write the
  CALL WriteDescrWordDec ;  Word Value
  CALL WriteCrLf         ;Move down
  INC  DI,2              ;Increment the Pointer
  LOOP Q10               ;Keep going until we're done
Q90:                     ;Done
  POP  DI,DX,CX,BX,AX    ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS HID-RELATED DESCRIPTORS AND TABLES
;  (Needs to Call a Sub-Program)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PRINT AN HID-RELATED TABLE TO THE SCREEN
;Inputs:   DS  = Local Data Area
;         [SI] = Command Tail Pointer
;Outputs: Writes Any One of Various HID Lookup Tables to the Screen
;Changes:
;------------------------------------------------------------------------------
DoSwitchPhysicalBias:
  PUSH DX                 ;Save used registers
  MOV  DX,PhysBiasMsg     ;Point at the basic EXEC Paremeter String
  JMP >W00                ;Do it
DoSwitchPhysicalDesignator:
  PUSH DX                 ;Save used registers
  MOV  DX,PhysDesigMsg    ;Point at the basic EXEC Paremeter String
  JMP >W00                ;Do it
DoSwitchPhysicalQualifier:
  PUSH DX                 ;Save used registers
  MOV  DX,PhysQualMsg     ;Point at the basic EXEC Paremeter String
  JMP >W00                ;Do it
DoSwitchReportCollection  :
  PUSH DX                 ;Save used registers
  MOV  DX,RptCollMsg      ;Point at the basic EXEC Paremeter String
  JMP >W00                ;Do it
DoSwitchReportDelimiter:
  PUSH DX                 ;Save used registers
  MOV  DX,RptDelimitMsg   ;Point at the basic EXEC Paremeter String
  JMP >W00                ;Do it
DoSwitchReportTag:
  PUSH DX                 ;Save used registers
  MOV  DX,RptTagMsg       ;Point at the basic EXEC Paremeter String
  JMP >W00                ;Do it
DoSwitchUsage:
  PUSH DX                 ;Save used registers
  MOV  DX,UsageMsg        ;Point at the basic EXEC Paremeter String
  JMP >W00                ;Do it
DoSwitchUsagePage:
  PUSH DX                 ;Save used registers
  MOV  DX,UsagePageMsg    ;Point at the basic EXEC Paremeter String
;  JMP >W00                ;Do it
W00:
  PUSH DI                 ;Save used registers
  CALL InitCmdTail        ;Initialize the Command Tail
  CALL AppendString2Cmd   ;Append the basic EXEC Parameter to the command Tail
  PUSH SI                 ;Save used registers
  CALL IsSpaceOrEOL       ;Skip over the spaces
W33:                      ;Convert the CR
  LODSB                   ;  at the end
  CMP  AL,CR              ;  of our
  JNE  W33                ;  command tail
  MOV  B [SI-1],0         ;  to an ASCII 0
  POP  SI                 ;Restore used registers
  MOV  DX,SI              ;Copy the end of our command tail
  CALL AppendString2Cmd   ;  to the Exec Command tail
  MOV  DI,SupportFileHID  ;Point [DI] at the Support File to use
  CALL HandleExecCall     ;Perform the Exec Call
  POP  DI                 ;Restore used registers
  POP  DX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PRINT AN HID REPORT OR PHYSICAL DESCRIPTOR TO THE SCREEN
;Inputs:  ES:[BX] = Descriptor to Write
;         DS = Local Data Area
;Outputs: Writes Descriptor, with Descriptions, to the Screen
;Changes:
;------------------------------------------------------------------------------
WriteReportDescr:
  PUSH DX                ;Save used registers
  MOV  DX,RptDescrMsg    ;Point [DX] at the basic EXEC Parameter String
  JMP >P00               ;Do it
WritePhysicalDescr:
  PUSH DX                ;Save used registers
  MOV  DX,PhysDescrMsg   ;Point [DX] at the basic EXEC Parameter String
;  JMP >P00               ;Do it
P00:
  PUSH AX,CX,DI          ;Save used registers
  CALL InitCmdTail       ;Initialize the Command Tail
  CALL AppendString2Cmd  ;Append the basic EXEC Parameter to the command Tail
  MOV  AX,ES             ;Write the
  MOV  CX,BX             ;  Memory Address
  CALL AppendSegOff2Cmd  ;  to the command Tail
  MOV  DI,SupportFileHID ;Point [DI] at the Support File to use
  CALL HandleExecCall    ;Perform the Exec Call
  POP  DI,CX,AX          ;Restore used registers
  POP  DX                ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE NEEDED TO PRINT VARIOUS TABLES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE A "GENERAL" PRINT TABLE SWITCH (PRINT SUBTABLES)
;Inputs:  [BX] = Starting Table to Search/Write
;         CL = Maximum Number of SubTables to Search/Write
;              0 = No SubTables, 1 = Table + 1 SubTable, etc.
;         [SI] = Command Line (Parameter) Pointer
;Outputs: Writes appropriate things to the screen
;Changes: SI
;------------------------------------------------------------------------------
DoSwitchGeneral:
  PUSH AX,BX,CX,DX       ;Save used registers
  OR   BX,BX             ;Valid Table Offset?
  JZ  >G30               ;If not, just write the number and quit
  MOV  CH,[BX]           ;Get the Table characteristics
  CALL GetCallBackAddr   ;Look for a Call-Back Address
  JNC >G60               ;If found (no regular parameter provided), handle it
  CALL GetNumber         ;If not found, look for a Parameter (AX)
  JNC >G05               ;If found, continue
  CALL IsSpaceOrEOL      ;If not, anything else on the command-line?
  JNZ >G70               ;If so, error
  JMP >G60               ;If not, write the whole table
G05:                     ;We have a number
  OR   CL,CL             ;Is this the last (Sub)Table to Handle?
  JNZ >G40               ;If not, handle it
  CALL GetCallBackAddr   ;If so, look for a Call-back address
  JNC >G10               ;If found, continue
  CALL IsSpaceOrEOL      ;If not found, anything else on the command-line?
  JNZ >G70               ;If so, error
G10:                     ;We have a single parameter to write
  PUSH BX                ;If so, save the Table Pointer
  CALL SearchTblNoWrite  ;See if it's in the Table
  POP  BX                ;Restore the Table Pointer
  JC  >G30               ;If no match, Handle it
G20:                     ;Is a match
  CALL WriteWordEquals   ;Write the number and equals (if at Command Line)
  CALL SearchTblWrite    ;Write the Description
  JMP >G90               ;Done
G30:                     ;No match in the Table
  CALL WriteWordUnknownX ;Write the number followed by " = Unknown!"
  JMP >G90               ;Done
G40:                     ;Have valid Parameter, but not at end of SubTables
  CALL SearchTblNoWrite  ;Look for a match in the Table (returns [BX])
  JNC >G80               ;If OK, Look in the SubTable
G50:                     ;Loop to here to find the last Parameter
  DEC  CL                ;Decrement the SubTable Counter
  CALL GetNumber         ;Get the next Parameter
  JC  >G90               ;If error, we're done
  OR   CL,CL             ;Is this the last Parameter we need?
  JNZ  G50               ;If not, keep looking
  CALL WriteWordUnknownX ;Write the number followed by " = Unknown!"
  JMP >G90               ;Done
G60:                     ;Invalid (empty) Parameter
  CALL WriteTblAndSubs   ;Write all Tables and SubTables
  JMP >G90               ;Done
G70:                     ;Error
  MOV  ParseError,Yes    ;Mark as an Error
  JMP >G90               ;Done
G80:                     ;Go to the SubTable
  DEC  CL                ;Decrement SubTable Level
  CALL DoSwitchGeneral   ;Handle the SubTable
G90:                     ;Done
  POP  DX,CX,BX,AX       ;Restore used registers
  RET

  ;Values for Descriptor Tag Attribute byte
  DTagNumBytes   EQU 0Fh ;Low nibble = Size of Data (Bytes, usually 0-4)
  ;First three bits of High Nibble are what to do with the string
  DTagColon      EQU 00h ;Write the string, colon, and appropriate spacing
                         ;  If String length = 0, don't write the Colon
  DTagSkip       EQU 10h ;Don't do anything at all with the string (Skip it)
                         ;  Appropriate tagging is performed by the Code
  DTagHdrOnly    EQU 20h ;Write the String Centered, followed by a Double Line
  DTagSizeOnly   EQU 30h ;Write the String as a Header, followed by the
                         ;  Descriptor Size (first byte of Descr is the Size)
  DTagSizeType   EQU 40h ;Write the String as a Header, followed by the
                         ;  Descriptor Size and Type.  First byte of Descriptor
                         ;  is the size, second is the Type.  This can only
                         ;  be used for general descr's, not class-specific's.
  DTagVariable   EQU 50h ;Next byte is a variable "size" bite, indicating
                         ;  the number of entries following.  The low nibble
                         ;  contains the size of each entry.  Writes first
                         ;  line (number of entries) with the description,
                         ;  passes AL (# of entries) and updated pointer
                         ;  to the subroutine.
  DTagVarSkip    EQU 60h ;Same as DTagVariable, except we do not write any
                         ;  sort of Header -- the subroutine is responsible
                         ;  for ALL writing
  DTagEndOfDescr EQU 80h ;Last entry in variable-length Decode Table
                         ;  All bytes after this one are handle by the Code

;------------------------------------------------------------------------------
;WRITE A "GENERIC" DESCRIPTOR TABLE
;Inputs:  DS:[SI] = Descriptor Table to Write From
;         ES:[DI] = Data to Write From
;         CL = Maximum number of bytes to get (if before end of Descriptor Tbl)
;Outputs: Writes Descriptor Description to the Screen
;Changes:
;NOTES: The first byte of the Table entry contains the number of bytes
;         of data are in the table element (usually 1, 2, or 4).
;       The byte can also contain "special" values which can be used
;         to do special things here.
;       A -1 indicates that we only want the Descriptor String written,
;         (there are 0 bytes of data).  This is commonly used to write
;         separator lines in the output.
;       A -2 indicates that we are writing the Header line of a Descriptor.
;         This indicates that we need to write the String, followed by
;         a double separator line, followed by a Descriptor Length line.
;------------------------------------------------------------------------------
DoDescriptorTbl:
  PUSH EAX,BX,CX,DX         ;Save used registers
  PUSH DI,SI,BP             ;Save used registers
  AND  MiscFlags,(NOT EndOfDescr) ;Mark Descriptor as Incomplete
  XOR  BX,BX                ;Byte Counter = 0
  JMP >D12                  ;Don't write new line
D10:                        ;Loop to here for each line in Structure
  CALL WriteCrLf            ;If so, write a new line
D12:                        ;Done with new line
  TEST MiscFlags,EndOfDescr ;Are we done processing the Descriptor?
  JNZ >D95                  ;If so, we're done
  MOV  BP,[SI]              ;BP = Subroutine to perform
  OR   BP,BP                ;End of the Table?
  JZ  >D90                  ;If so, quit
  LEA  DX,[SI+3]            ;[DX] = Tag String
  MOV  BL,[SI+2]            ;BL = Number of Bytes & Flags
  CALL HandleVarDescrSize   ;Handle a variable-sized descriptor entry
  JNC >D50                  ;If it was variable-sized, we're done with it
  AND  BL,DTagNumBytes      ;BL = of Bytes in Entry
  SUB  CL,BL                ;Subtract Entry Size from Total
  JC  >D95                  ;If done with Descriptor, quit
  CALL WriteDescrTag        ;Write the Tag
  TEST B [SI+2],NOT (DTagNumBytes+DTagEndOfDescr) ;Need to write the value?
  JNZ >D40                  ;If not, don't
  CALL WriteDescrValSpaced  ;Get and Write the Number (returns EAX)
D40:                        ;Process the Appropriate Subroutine
  CALL BP                   ;Process the Subroutine
  ADD  DI,BX                ;Point at the next set of Data
D50:                        ;Done handling this entry
  ADD  SI,3                 ;Point at the next
  CALL SkipOverStringSI     ;  table Entry
  JMP  D10                  ;Keep going until we're done
D90:                        ;Done
  CALL WriteDescrExtraBytes ;Write any extra bytes at the end of the descriptor
D95:                        ;Really done, no need to write extra bytes
  POP  BP,SI,DI             ;Restore used registers
  POP  DX,CX,BX,EAX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST FOR AND HANDLE A VARIABLE DESCRIPTOR ELEMENT SIZE
;Inputs:  ES:[DI] = Descriptor value (Variable Size Number)
;            [SI] = Decode Table Entry
;            [DX] = Tag String to write for Variable Size Byte
;             BL  = Number of Bytes & Flags Code
;             CL  = Number of bytes left to write in Descriptor
;Outputs: If BL indicates DTagVariable:
;           CF = Clear
;         If BL does not indicate DTagVariable
;           CF = Set
;Changes:
;------------------------------------------------------------------------------
HandleVarDescrSize:
  PUSH AX,BX                ;Save used registers
  MOV  BH,BL                ;Save Size & Flags
  AND  BH,NOT (DTagNumBytes+DTagEndOfDescr) ;Mask out all non-flags
  MOV  AL,ES:[DI]           ;Get the possible number of bytes
  CMP  BH,DTagVariable      ;Is it a variable-sized entry?
  JE  >V10                  ;If so, continue
  CMP  BH,DTagVarSkip      ;If not, is it Variable with no Header?
  JE  >V20                  ;If so, handle it
  JMP >V70                  ;If not, we're done
V10:                        ;Variable sized, write First Line
  CALL WriteDescrByteDec    ;Write the Variable Size Byte
  CALL WriteCrLf            ;Move down
V20:                        ;Variable Size written, if appropriate
  INC  DI                   ;Point at the data after the Variable Size Byte
  CALL BP                   ;Do the subroutine
  MOV  AH,BL                ;AH = Number of bytes
  AND  AH,DTagNumBytes      ;  per entry
  MUL  AH                   ;Multiply Num Entries * Entry Size
  ADD  DI,AX                ;Update the Descriptor Pointer
  INC  AL                   ;Subtract Total Entry Size
  SUB  CL,AL                ;  from Descriptor Total
  JNC >V80                  ;If not done with Descriptor yet, quit
  OR   MiscFlags,EndOfDescr ;If done with Descriptor, mark as done
  JMP >V80                  ;Done
V70:                        ;Not a variable-sized entry
  STC                       ;Set return flag
  JMP >V90                  ;Done
V80:                        ;Is a variable-sized entry
  CLC                       ;Set return flag
V90:                        ;Done
  POP  BX,AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE AN APPROPRIATELY ALIGNED BYTE/WORD/TRIBYTE/DWORD, FOLLOWED BY SPACES
;Inputs:  ES:[DI] = Next Descriptor value
;         BL = Number of Bytes to get (1, 2, 3, or 4)
;              If BL = 0 or BL > 4, we do nothing
;Outputs: EAX = Appropriate value from Descriptor
;               (higher bytes of EAX set to 0, if required)
;         Writes Hex value to the screen, with appropriate indentation
;           (all values right-aligned)
;         Value is followed by 2 spaces
;Changes:
;------------------------------------------------------------------------------
WriteDescrValSpaced:
  MOV  EAX,ES:[DI]     ;If not, get the DWord from the Descriptor
  OR   BL,BL           ;0 bytes?
  JZ  >P90             ;If so, write nothing
  CMP  BL,4            ;Is it a DWord or Illegal Byte Count?
  JA  >P90             ;If Illegal, we're done
  JE  >P40             ;If a DWord, jump to handle it
  CMP  BL,2            ;Is it a Byte, Word, or TriByte?
  JA  >P30             ;If a TriByte, jump to handle it
  JE  >P20             ;If a Word, jump to handle it
P10:                   ;Write a Byte
  AND  EAX,0000_00FFh  ;Mask out unwanted bits
  CALL Write7Spaces    ;Move over
  CALL WriteByteHex    ;Write the Number
  JMP >P60             ;Done
P20:                   ;Write a Word
  AND  EAX,0000_FFFFh  ;Mask out unwanted bits
  CALL Write5Spaces    ;Move over
  CALL WriteWordHex    ;Write the Number
  JMP >P60             ;Done
P30:                   ;Write a TriByte
  AND  EAX,00FF_FFFFh  ;Mask out unwanted bits
  CALL Write3Spaces    ;Move over
  CALL WriteTriByteHex ;If a TriByte, write the Number
  JMP >P60             ;Continue
P40:                   ;Write a DWord
  CALL WriteDWordHex   ;Write the DWord
P60:                   ;Value is written
  CALL WriteHexEnd     ;Write the "h"
  CALL Write2Spaces    ;Move over
P90:                   ;Done
  RET

;------------------------------------------------------------------------------
;WRITE THE DESCRIPTOR TAG STRING DESCRIPTION, IN AN APPROPRIATE FORMAT
;Inputs:  DS      = Local Data Area
;         DS:[SI] = Decode Table Tag Entry
;                   (Includes Tag String & Attributes)
;         ES:[DI] = Descriptor Data
;Outputs: To Screen, as appropriate
;         MiscFlags.EndOfDescr, if appropriate
;Changes:
;------------------------------------------------------------------------------
WriteDescrTag:
  PUSH AX,BX,DX             ;Save used registers
  MOV  BL,[SI+2]            ;BL = Descriptor Tag Attributes & Size
  TEST BL,DTagEndOfDescr    ;Is this the end of the Descriptor?
  JZ  >G10                  ;If not, continue
  OR   MiscFlags,EndOfDescr ;If so, mark it as the end
G10:                        ;End-of-Descriptor handled as needed
  AND  BL,NOT (DTagNumBytes+DTagEndOfDescr) ;Get rid of non-Attribute bits
  CMP  BL,DTagSkip          ;Are we supposed to do anything with the string?
  JE  >G90                  ;If not, we're done
  LEA  DX,[SI+3]            ;If so, point [DX] at the string
  CMP  BL,DTagColon         ;Are we supposed to write the colon and spaces?
  JNE >G30                  ;If not, continue testing
G20:                        ;Need to write Colon and Spaces
  CALL WriteDTagColon       ;Write the Description with Colon and Spaces
  JMP >G90                  ;Done
G30:                        ;Need to write at least the Header
  CALL WriteDTagHdr         ;Write the Header
  CMP  BL,DTagHdrOnly       ;Are we supposed to write anything else?
  JE  >G90                  ;If not, we're done
G40:                        ;Need to write at least the Descriptor Length
  CALL WriteCrLf            ;Move down
  MOV  AX,ES:[DI]           ;Get the Descriptor Length (AL) and Type (AH)
  MOV  DX,DescrLengthMsg    ;Write the
  CALL WriteDescrByteDec    ;  Descriptor Length
  CMP  BL,DTagSizeOnly      ;Are we supposed to write the Type?
  JE  >G90                  ;If not, we're done
G50:                        ;Need to write the Descriptor Type
  CALL WriteCrLf            ;Move down
  MOV  AL,AH                ;AL = Descriptor Type
  MOV  DX,DescrTypeMsg      ;Write the
  CALL WriteDescrByteNoDec  ;  Descriptor
  CALL DoDescrType          ;  Type
G90:                        ;Done
  POP  DX,BX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ANY EXTRA (UNKNOWN) BYTES AT THE END OF A DESCRIPTOR
;Inputs:  CL = Number of extra bytes to write
;         ES:[DI] = Descriptor data to write
;Outputs: Writes "???" Description to the screen
;Changes:
;------------------------------------------------------------------------------
WriteDescrExtraBytes:
  PUSH CX,DX,DI          ;Save used registers
  OR   CL,CL             ;Anything to do?
  JZ  >X90               ;If not, quit
  XOR  CH,CH             ;If so, convert counter to a Word
  MOV  DX,UnknownDataMsg ;Description of value = "???"
X10:                     ;Loop to here for each byte we write
  MOV  AL,ES:[DI]        ;Get teh next byte
  CALL WriteDescrByteDec ;Write the Value
  CALL WriteCrLf         ;Move down
  INC  DI                ;Point at the next byte
  LOOP  X10              ;Keep going until we're done
X90:                     ;Done
  POP  DI,DX,CX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE, WORD,TRIBYTE, OR DWORD AS A PART OF A DESCRIPTOR MESSAGE
;Inputs:  DS:[DX] = Descriptor String to Write
;         AL/AX/EAX = Byte/Word/TriByte/DWord to Write
;         CL = Number to write after the Description String (if appropriate)
;Outputs: Writes the byte/word as a Hex Value, followed by 2 spaces, followed
;           optionally by the value in minimized decimal form.
;Changes:
;------------------------------------------------------------------------------
WriteDescrDWordDec:
  PUSH EAX,CX            ;Save used registers
  MOV  BX,0100h          ;BL = Spaces needed for alignment
                         ;BH = Flag for needing to write the Decimal Value
  JMP >Y001              ;Do it
WriteDescrDWordNoDec:
  PUSH EAX,BX            ;Save used registers
  MOV  BX,0000h          ;BL = Spaces needed for alignment
                         ;BH = Flag for not needing to write Decimal Value
  JMP >Y001              ;Do it
WriteDescrDWordNumNoDec:
  PUSH EAX,BX            ;Save used registers
  MOV  BX,0000h          ;BL = Spaces needed for alignment
                         ;BH = Flag for not needing to write Decimal Value
  JMP >Y0001             ;Do it
WriteDescrTriByteDec:
  PUSH EAX,CX            ;Save used registers
  AND  EAX,00FF_FFFFh    ;Mask out unwanted bits
  MOV  BX,0103h          ;BL = Spaces needed for alignment
                         ;BH = Flag for needing to write the Decimal Value
  JMP >Y00               ;Do it
WriteDescrTriByteNoDec:
  PUSH EAX,BX            ;Save used registers
  AND  EAX,00FF_FFFFh    ;Mask out unwanted bits
  MOV  BX,0003h          ;BL = Spaces needed for alignment
                         ;BH = Flag for not needing to write Decimal Value
  JMP >Y00               ;Do it
WriteDescrTriByteNumDec:
  PUSH EAX,BX            ;Save used registers
  AND  EAX,00FF_FFFFh    ;Mask out unwanted bits
  MOV  BX,0103h          ;BL = Spaces needed for alignment
                         ;BH = Flag for needing to write Decimal Value
  JMP >Y000              ;Do it
WriteDescrWordDec:
  PUSH EAX,BX            ;Save used registers
  MOV  BX,0105h          ;BL = Spaces needed for alignment
                         ;BH = Flag for needing to write the Decimal Value
Y001:                    ;To avoid JMP > 128
  JMP >Y00               ;Do it
WriteDescrWordNoDec:
  PUSH EAX,BX            ;Save used registers
  MOV  BX,0005h          ;BL = Spaces needed for alignment
                         ;BH = Flag for not needing to write Decimal Value
  JMP >Y00               ;Do it
WriteDescrWordNumDec:
  PUSH EAX,BX            ;Save used registers
  MOV  BX,0105h          ;BL = Spaces needed for alignment
                         ;BH = Flag for needing to write Decimal Value
Y0001:                    ;To avoid JMP > 128
  JMP >Y000              ;Do it
WriteDescrWordNumNoDec:
  PUSH EAX,BX            ;Save used registers
  MOV  BX,0005h          ;BL = Spaces needed for alignment
                         ;BH = Flag for not needing to write Decimal Value
  JMP >Y000              ;Do it
WriteDescrByteDec:
  PUSH EAX,BX            ;Save used registers
  XOR  AH,AH             ;Make sure high byte is zero
  MOV  BX,0107h          ;BL = Spaces needed for alignment
                         ;BH = Flag for needing to write the Decimal Value
  JMP >Y00               ;Do it
WriteDescrByteNumDec:
  PUSH EAX,BX            ;Save used registers
  XOR  AH,AH             ;Make sure high byte is zero
  MOV  BX,0107h          ;BL = Spaces needed for alignment
                         ;BH = Flag for needing to write the Decimal Value
  JMP >Y000              ;Do it
WriteDescrByteNoDec:
  PUSH EAX,BX            ;Save used registers
  XOR  AH,AH             ;Make sure high byte is zero
  MOV  BX,0007h          ;BL = Spaces needed for alignment
                         ;BH = Flag for not needing to write the Decimal Value
  JMP >Y00               ;Do it
WriteDescrByteNumNoDec:
  PUSH EAX,BX            ;Save used registers
  XOR  AH,AH             ;Make sure high byte is zero
  MOV  BX,0007h          ;BL = Spaces needed for alignment
                         ;BH = Flag for not needing to write the Decimal Value
  JMP >Y000              ;Do it

Y00:                     ;Write plain Descriptor
  CALL WriteDTagColon    ;Write the Descriptor String
  JMP >Y05               ;Continue
Y000:                    ;Write Descriptor with a Number
  CALL WriteDTagNumColon ;Write the Description with a Number
Y05:                     ;Done writing Descriptor String
  PUSH CX                ;Save used registers
  MOV  CL,BL             ;Write the
  CALL WriteSpaces       ;  alignment spaces
  CMP  BL,3              ;Writing a Byte, Word, TriByte, or Dword?
  JB  >Y40               ;If a DWord, jump to handle it
  JE  >Y30               ;If a TriByte, jump to handle it
  CMP  BL,5              ;Writing a Byte, Word, TriByte, or Dword?
  JE  >Y20               ;If a Word, jump to handle it
Y10:                     ;Writing a Byte
  CALL WriteByteHex      ;Write the Byte
  JMP >Y60               ;Continue
Y20:                     ;Writing a Word
  CALL WriteWordHex      ;Write the Word
  JMP >Y60               ;Continue
Y30:                     ;Writing a TriByte
  CALL WriteTriByteHex   ;Write the TriByte
  JMP >Y60               ;Continue
Y40:                     ;Writing a DWord
  CALL WriteDWordHex     ;Write the DWord
;  JMP >Y60               ;Continue
Y60:                     ;Done writing Hex Value
  CALL WriteHexEnd       ;Write the "h"
  CALL Write2Spaces      ;Move over
  OR   BH,BH             ;Need to write the Decimal value?
  JZ  >Y90               ;If not, we're done
  CALL WriteWordMin      ;If so, write the value as a decimal
Y90:                     ;Done
  POP  CX                ;Restore used registers
  POP  BX,EAX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE HEADER FOR A DESCRIPTOR
;Inputs:  DS:[DX] = Header String to Write
;Outputs: Writes the String, Centered, followed by a double line
;Changes:
;------------------------------------------------------------------------------
WriteDTagHdr:
  PUSH CX              ;Save used registers
  CALL CalcStrSizeDX   ;Get the size of the String (CX)
  SUB  CL,DescrLineLen ;Is the string too long to center?
  JNC >H20             ;If so, don't center it
  NEG  CL              ;If not, calculate how many spaces
  SHR  CL,1            ;  we need to write in order to center it
  CALL WriteSpaces     ;Write the Spaces
H20:                   ;Centering spaces written as needed
  CALL WriteItDX       ;Write the String
  CALL WriteCrLf       ;Move down
  CALL WriteDTagDLine  ;Write a double-line Separater
H90:                   ;Done
  POP  CX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE TAG DESCRIPTION FOR A DESCRIPTOR
;Inputs:  DS:[DX] = Description String to Write
;         If WriteDTagNumColon, CL = Number to write after the String
;Outputs: Writes the String, Followed possibly by a Space & a Decimal Number,
;           Followed by a Colon, followed by enough spacing characters
;           to align things appropriately
;         If the string is 0 length, no colon is written, just
;           the alignment spaces characters
;Changes:
;------------------------------------------------------------------------------
WriteDTagNumColon:
  PUSH BX                   ;Save used registers
  MOV  BL,CL                ;Save number to write
  MOV  BH,-1                ;Mark as needing to write the Number
  JMP >L00                  ;Do it
WriteDTagColon:
  PUSH BX                   ;Save used registers
  XOR  BH,BH                ;Mark as not needing to write the Number
;  JMP >D00                  ;Do it
L00:
  PUSH AX,CX                ;Save used registers
  MOV  AL,' '               ;Assume a zero-length string
  CALL CalcStrSizeDX        ;Calculate the size of the String (CL)
  JZ  >L60                  ;If zero length, jump to handle it
L10:                        ;String is not zero-length
  CALL WriteItDX            ;Write the String
  OR   BH,BH                ;Are we supposed to write a number?
  JZ  >L50                  ;If not, continue
L20:                        ;Need to write a number
  CALL WriteSpace           ;Write a space
  MOV  AL,BL                ;Write the
  CALL WriteByteMin         ;  Number
  ADD  CL,2                 ;Adjust the string length counter
  CMP  AL,9                 ;Was the number just one character long?
  JBE >L50                  ;If so, continue
  INC  CL                   ;If not, assume it was two characters long
  CMP  AL,99                ;Was the number two character longs?
  JBE >L50                  ;If so, continue
  INC  CL                   ;If not, it was three characters long
L50:                        ;String is zero-length
  MOV  AL,':'               ;Need to write a Colon
L60:                        ;AL contains appropriate termination character
  CALL WriteAL              ;Write the character
  SUB  CL,(DescrLineLen-11) ;Calculate Number of Spaces
  NEG  CL                   ;  to Write
  CALL WriteSpaces          ;Write them
L90:                        ;Done
  POP  CX,AX                ;Restore used registers
  POP  BX                   ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE TO SEARCH THROUGH AND/OR PRINT A STRING LOOKUP TABLE
;  THIS INCLUDES STRAIGHT VALUE, BITMAP, AND BITMASK LOOKUP TABLES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SEARCH A STRING OR STRING-AND-OFFSET TABLE FOR A MATCH, AND MAYBE WRITE STRING
;Inputs:  DS:[BX] = Table to Search In
;         AL/AX = Byte/Word to Look for
;Outputs: CF = Clear if OK (Byte/Word Found)
;              Writes String to Screen
;              If String and Code Table, BX = Offset From Table
;              If String-Only Table, BX = 0
;            = Set if Error (Byte not found)
;              BX = 0
;Changes:
;------------------------------------------------------------------------------

;Change to Handle DWords & Sequential Tables
;Change Sequentials to allow "long spaces" (like -1's at end, or so many
;  missing nummers that just using 0's is inefficient)
;Change All to have a Default String
;Need special flags for "spaces" (needs to include how many entries to
;  skip), for default strings, and for actual end-of-tables

SearchTblNoWrite:
  PUSH BP                  ;Save used registers
  XOR  BP,BP               ;Mark as not needing to write
  JMP >S00                 ;Do it
SearchTblWrite:
  PUSH BP                  ;Save used registers
  MOV  BP,-1               ;Mark as needing to write
;  JMP >S00                 ;Do it
S00:
  PUSH AX,CX,DX,SI         ;Save used registers
  OR   BX,BX               ;Valid Table?
  JZ  >S70                 ;If not, error
  MOV  CL,[BX]             ;Save Table Flags
  MOV  SI,BX               ;Point SI at
  INC  SI                  ;  the Table
  MOV  DX,AX               ;Put test-for-word in DX
  TEST CL,TblFlagWord      ;A Word Table?
  JNZ >S10                 ;If so, continue
  XOR  DH,DH               ;If not, high byte
  XOR  AH,AH               ;  is 0
S10:                       ;Loop to here for each Table Entry
  TEST CL,TblFlagWord      ;A Word Table?
  JNZ >S20                 ;If so, handle it
  LODSB                    ;Get the Byte
  JMP >S30                 ;Continue
S20:                       ;Getting a Word
  LODSW                    ;Get the Word
S30:                       ;Have the Table Index
  OR   AX,AX               ;End of Table?
  JNZ >S35                 ;If not, continue
  CMP  B [SI],-1           ;End of table?
  JE  >S70                 ;If so, Error (no match)
S35:                       ;Valid table Entry
  CMP  AX,DX               ;Is it a match?
  JNE >S40                 ;If not, go to the next one
  OR   BP,BP               ;Are we supposed to write the string?
  JZ  >S37                 ;If not, skip the writing part
  CALL WriteItSI           ;Write the String
S37:                       ;Done writing
  XOR  BX,BX               ;Assume Table has no Offset
  TEST CL,TblFlagHasOffset ;Does the Table Have an Offset?
  JZ  >S80                 ;If not, we're done
  CALL SkipOverStringSI    ;If so, skip over the String
  MOV  BX,[SI]             ;Put the Offset in BX
  JMP >S80                 ;Done
S40:                       ;Not a match
  CALL SkipOverStringSI    ;Skip over the String
  TEST CL,TblFlagHasOffset ;Does the Table have an Offset?
  JZ  >S50                 ;If not, continue
  INC  SI,2                ;If so, skip over the Offset
S50:                       ;Done testing this Table Entry
  JMP  S10                 ;Keep looking
S70:                       ;Error
  XOR  BX,BX               ;Set return Flag
  STC                      ;Set error flag
  JMP >S90                 ;Done
S80:                       ;OK
  CLC                      ;Set OK Flag
S90:                       ;Done
  POP  SI,DX,CX,AX         ;Restore used registers
  POP  BP                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE AN ENTIRE STRING OR STRING-AND-CODE TABLE TO THE SCREEN, POSS W/ SUBTABLES
;Inputs:  [BX] = Table To Write
;         CL   = Maximum number of SubTables to write (0 = No Subs, etc.)
;                (If WriteTblAndSubs)
;Outputs: Writes Entire Table to Screen, possibly with the SubTables Also
;Changes: Indent
;------------------------------------------------------------------------------
WriteTblAndSubs:
  PUSH CX                  ;Save used registers
  JMP >W00                 ;Do it
WriteTbl:
  PUSH CX                  ;Save used registers
  XOR  CX,CX               ;Mark as not needing to write SubTables
;  JMP >W00                 ;Do it
W00:
  PUSH AX,BX,DX,SI         ;Save used registers
  MOV  CH,[BX]             ;Save Table Flags
  MOV  SI,BX               ;Point SI at
  INC  SI                  ;  the Table
W10:                       ;Loop to here for each Table Entry
  MOV  DH,4                ;Amount to Increase Indent
  TEST CH,TblFlagWord      ;Doing a Word?
  JNZ >W20                 ;If so, handle it
  LODSB                    ;Get next Table Entry
  OR   AL,AL               ;End of Table?
  JNZ >W15                 ;If not, continue
  CMP  B [SI],-1           ;End of table?
  JE  >W90                 ;If so, Quit
W15:                       ;Valid Table Entry
  CALL DoIndent            ;Handle the Indent
  CALL WriteByteHex        ;Write the Table Value
  JMP >W30                 ;Continue
W20:                       ;Do a Word
  ADD  DH,2                ;Increase Indent some more
  LODSW                    ;Get next Table Entry
  OR   AX,AX               ;End of Table?
  JNZ >W25                 ;If not, continue
  CMP  B [SI],-1           ;End of table?
  JE  >W90                 ;If so, Quit
W25:                       ;Valid Table Entry
  CALL DoIndent            ;Handle the Indent
  CALL WriteWordHex        ;Write the Table Value
W30:                       ;Done writing Index
  CALL WriteHexEnd         ;Write the 'h'
  CALL WriteSpace          ;Write a Space
  CALL WriteItSI           ;Write the String
  CALL SkipOverStringSI    ;Skip over the String
  TEST CH,TblFlagHasOffset ;Does the Table have an Offset?
  JZ  >W40                 ;If not, continue
  INC  SI,2                ;If so, skip over the Offset
  OR   CL,CL               ;Do we need to write the Offset Table?
  JZ  >W40                 ;If not, continue
  CMP  W [SI-2],0          ;Is it a vlaid Index?
  JE  >W40                 ;If not, we're done
  CALL WriteCrLf           ;If so, start a new line
  PUSH BX                  ;Save used registers
  MOV  BX,[SI-2]           ;Point at the SubTable
  ADD  Indent,DH           ;Add in the appropriate Indent
  DEC  CL                  ;Decrement SubTable Counter
  CALL WriteTblAndSubs     ;Write the SubTable, and it's SubTables
  INC  CL                  ;Increment SubTable Counter
  SUB  Indent,DH           ;Restore the original Indent
  POP  BX                  ;Restore used registers
  JMP >W45                 ;Go to next Entry
W40:                       ;Done with this Table Entry
  CALL WriteCrLf           ;Start a new line
W45:                       ;Keep going, no new Line
  JMP  W10                 ;Keep going
W90:                       ;Done
  POP  SI,DX,BX,AX         ;Restore used registers
  POP  CX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ALL MATCHING DESCRIPTIONS FROM A BIT-MAP TABLE
;Inputs:   DS  = Local Data Area
;          AL/AX/EAX = Bit-map value to test
;         [BX] = Table to write from
;                First byte of table is Table Format Flags
;         Indent = Indentation to use (after first line)
;Outputs: To Screen
;         Places each mapped description bit on a new line
;Changes:
;NOTES: If TblFlagSequential is set, unused (ignored) values must have a
;         zero-length string.  The End-of-Table marker is a string of
;         DB -1,0 (a string with a single character of 255).  If the
;         table is "complete" (8 entries for a byte, etc.) no end-of-table
;         marker is required.
;       If TblFlagSequential is not set, the End-of-Table marker is a bit
;         mask Index of 0.
;------------------------------------------------------------------------------
SearchBitMapIllegal:
  PUSH BP                   ;Save used registers
  MOV  BP,IllegalMsg        ;Point at Illegal Message
  JMP >P00                  ;Do it
SearchBitMapUnknown:
  PUSH BP                   ;Save used registers
  MOV  BP,UnknownMsg        ;Point at Unknown Message
  JMP >P00                  ;Do it
SearchBitMapTbl:
  PUSH BP                   ;Save used registers
  MOV  BP,NoMsg             ;Point at No Message
;  JMP >P00                  ;Do it
P00:
  PUSH EAX,BX,CX,EDX,DI,SI  ;Save used regsiters
  CALL GetBitMapTblParams   ;Get the Size Parameters (rtns BH, BL, CX, DX, SI)
  MOV  DI,DX                ;Put Entry Size in DI
  TEST BL,TblFlagSequential ;Is it a Sequential Table?
  JZ  >P10                  ;If not, continue
  MOV  EDX,EAX              ;Put original test value in EDX
  MOV  EAX,8000_0000h       ;Initialize the bit mask to test
P10:                        ;Loop to here for bit to test
  ROL  EAX,1                ;Update the test bit-mask (if Sequential Table)
  TEST BL,TblFlagSequential ;Is it a Sequential Table?
  JZ  >P15                  ;If not, jump to handle it
  CMP  W [SI],00FFh         ;If so, is it the end-of-table marker?
  JE  >P90                  ;If so, we're done
  JMP >P25                  ;If not, continue
P15:                        ;Not a Sequential Table
  MOV  EAX,[SI]             ;Get the test bit-mask
  CALL MaskOutEAXTblBits    ;Convert Byte/Word to a DWord (EAX)
  OR   EAX,EAX              ;Is it the end-of-table marker?
  JZ  >P90                  ;If so, we're done
  ADD  SI,DI                ;Skip over the Table Index Value
P25:                        ;EDX = test bit, EAX = test value, [SI] = String
  TEST EAX,EDX              ;Is the bit set?
  JZ  >P60                  ;If not, don't write anything
  CMP  B [SI],0             ;Is it a zero length string?
  JNE >P50                  ;If not, write the String
P30:                        ;Illegal/Unused Attribute
  CALL WriteIllUknAttr      ;Write Illegal/Unknown Attribute Message
  JMP >P60                  ;Done with this bit
P50:                        ;It's matching bit
  OR   BH,BH                ;Is this the first one?
  JZ  >P55                  ;If so, don't start a new line
;  JZ  >P55                  ;If so, don't indent
;  CALL WriteSpaces          ;If not, move over 2 spaces
  CALL WriteCrLf            ;If not, move down
  CALL DoIndent             ;Move over
P55:                        ;Indentation handled, if appropriate
  INC  BH                   ;Mark as having written a line
  CALL WriteItSI            ;Write the Description
P60:                        ;Done with this test bit
  CALL SkipOverStringSI     ;Go to the next table entry
  LOOP P10                  ;Keep going until we're done
P90:                        ;Done
  POP  SI,DI,EDX,CX,BX,EAX  ;Restore used registers
  POP  BP                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE APPROPRIATE ILLEGAL/UNKNOWN ATTRIBUTE BIT DESCRIPTION
;Inputs:   BP = Illegal/Unknown/No Message
;          BH = Bit written counter
;Outputs: To Screen
;         Increments BH if appropriate
;Changes:
;------------------------------------------------------------------------------
WriteIllUknAttr:
  PUSH SI               ;Save used registers
  MOV  SI,BP            ;[SI] = String to Write
  CMP  B [SI],0         ;Is it NoMsg?
  JE  >T90              ;If so, we're done
  OR   BH,BH            ;Is this the first one?
  JZ  >T20              ;If so, don't start a new line
  CALL WriteCrLf        ;If not, move down
  CALL DoIndent         ;Move over
T20:                    ;Indentaion handled, if appropriate
  INC  BH
  CALL WriteItSI        ;Write the first part of the message
  MOV  SI,AttribMsg     ;Write the second part
  CALL WriteItSI        ;  of the message
  CALL WriteDWordMinHex ;Write the Attribute
T90:                    ;Done
  POP  SI               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ALL POSSIBLE DESCRIPTIONS FROM A BIT-MAP TABLE
;Inputs:   DS  = Local Data Area
;         [BX] = Table to write from
;                First byte of table is Table Format Flags
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteBitMapTbl:
  PUSH EAX,BX,CX,DX,SI      ;Save used regsiters
  CALL GetBitMapTblParams   ;Get the Size Parameters (rtns BH, BL, CX, DX, SI)
  TEST BL,TblFlagSequential ;Is it a Sequential Table?
  JZ  >B10                  ;If not, continue
  MOV  EAX,8000_0000h       ;If so, initialize the bit mask to test
B10:                        ;Loop to here for bit to test
  ROL  EAX,1                ;Update the bit-mask (if Sequential Table)
  TEST BL,TblFlagSequential ;Is it a Sequential Table?
  JZ  >B20                  ;If not, jump to handle it
  CMP  W [SI],00FFh         ;If so, is it the end-of-table marker?
  JE  >B90                  ;If so, we're done
  JMP >B30                  ;If not, continue
B20:                        ;Not a Sequential Table
  MOV  EAX,[SI]             ;Get the test bit-mask
  CALL MaskOutEAXTblBits    ;Convert Byte/Word to a DWord (EAX)
  OR   EAX,EAX              ;Is it the end-of-table marker?
  JZ  >B90                  ;If so, we're done
  ADD  SI,DX                ;Skip over the Table Index Value
B30:                        ;EAX = Index Value, [SI] = String
  CMP  B [SI],0             ;Is it a zero length string?
  JE  >B60                  ;If so, don't write anything
  OR   BH,BH                ;Is this the first one?
  JZ  >B50                  ;If so, don't start a new line
  CALL WriteCrLf            ;If not, move down
B50:                        ;New line handled, if needed
  INC  BH                   ;Mark as having written a line
  CALL WriteEAXTblValue     ;Write the Value
  CALL WriteItSI            ;Write the Description
B60:                        ;Done with this Table Entry
  CALL SkipOverStringSI     ;Go to the next table entry
  LOOP B10                  ;Keep going until we're done
B90:                        ;Done
  POP  SI,DX,CX,BX,EAX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE SIZE PARAMETERS ASSOCIATED WITH A BIT-MAP TABLE
;Inputs:   DS  = Local Data Area
;         [BX] = Table to Get Data From
;                (First byte of table is Table Format Flags)
;Outputs: [SI] = First Actual Table Entry
;          BH  = 0 (Number of lines written so far)
;          BL  = Table Format Flags Byte
;          CX  = Maximum Number of Table Entries (Byte Table = 8, etc.)
;          DX  = Size of each Table Index Entry (Byte Table = 1, etc.)
;Changes:
;------------------------------------------------------------------------------
GetBitMapTblParams:
  MOV  SI,BX   ;Point [SI] at the Table
  XOR  BX,BX   ;BH = Number of lines written so far (0)
  MOV  BL,[SI] ;Put table flags in BL
  INC  SI      ;Point [SI] at the Table Data
  XOR  DX,DX   ;DX = size
  MOV  DL,BL   ;  of each
  AND  DL,07h  ;  index entry
  XOR  CX,CX   ;CX = Maximum
  MOV  CL,DL   ;  Number of Entries
  SHL  CL,3    ;  to write
  RET

;------------------------------------------------------------------------------
;MASK OUT THE HIGH-ORDER BITS OF A DWORD, IF NEEDED
;Inputs:  EAX = DWord to Mask
;          BL = Table Format Flags byte (TblFlagByte, etc.)
;Outputs: EAX = Masked output (if BL = TblFlagByte, masks out 24 high bits, ...
;Changes:
;------------------------------------------------------------------------------
MaskOutEAXTblBits:
  TEST BL,TblFlagDWord ;Doing a DWord?
  JNZ >K90             ;If so, we're done
  AND  EAX,0000_FFFFh  ;If not, assume a Word
  TEST BL,TblFlagWord  ;Are we doing Word?
  JNZ >K90             ;If so, continue
  XOR  AH,AH           ;If not, it must be a byte
K90:                   ;Done
  RET

;------------------------------------------------------------------------------
;WRITE THE TABLE VALUE (BYTE, WORD, OR DWORD)
;Inputs:  AL/AX/EAX = Value to write
;          BL = Table Format Flags byte (TblFlagByte, etc.)
;Outputs: To screen
;         Writes Hex Number (correctly sized), followed by "h "
;Changes:
;------------------------------------------------------------------------------
WriteEAXTblValue:
  PUSH DI               ;Save used registers
  MOV  DI,WriteDWordHex ;Assume a DWord
  TEST BL,TblFlagDWord  ;Is it a DWord?
  JNZ >V30              ;If so, continue
  MOV  DI,WriteWordHex  ;If not, assume a Word
  TEST BL,TblFlagWord   ;Is it a Word?
  JNZ >V30              ;If so, continue
  MOV  DI,WriteByteHex  ;If not, it's a Byte
V30:                    ;[DI] = Appropriate Subroutine to Call
  CALL DI               ;Write the Value
  CALL WriteHexEnd      ;Write the "h"
  CALL WriteSpace       ;Move over
  POP  DI               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE-ORIENTED BIT-MASKED TABLE
;Inputs:  DS:[BX] = Bit-Map Table to Write From
;         AL = Byte to write
;         If DoByteBitMaskCr:
;           Indent = Correct Spacing to use after first line
;         If DoByteBitMaskSp:
;           Indent is not used
;Outputs: Writes Bit-Masked information to the screen
;           If DoByteBitMaskCr: Writes each on a separate line
;           If DoByteBitMaskSp: Writes each on same line, separated by spaces
;Changes:
;NOTES: The format of the Table is as follows.  It can have multiple entries.
;       Each Entry starts with the ENTIRE bit-mask (what to AND with the
;         original AL to get rid of unwanted bits).
;       It is followed by an ASCIIZ string to use as a "header, which is
;         written no matter what.
;       This is followed by 0 or more individual bit-mask/ASCIIZ combinations.
;         If the ANDed AL exactly equals the bit mask, the ASCIIZ string
;         is written.  If it does not match, we skip to the next Entry.
;       The last, or "default", bit-mask is marked by a bit mask that exactly
;         matches the original (Entire) bit mask for the Table entry.
;         If no match was found in a previous bit-mask in the table, the
;         string associated with the default entry is used.
;         The default entry also has a second string, to be used as a "footer".
;         The footer string is written no matter what.
;       The end of the Table is marked by a bit-mask of 0.

;       This Does NOT write a new line at the end of the routine, but writes
;         spaces or new lines after each bit-mask attribute written
;         up to the next-to-last one.
;------------------------------------------------------------------------------
DoByteBitMaskCr:
  PUSH DX               ;Save used registers
  XOR  DX,DX            ;DL = Space/New Line Flag = New Line
                        ;DH = Flag Counter = 0
  JMP >K00              ;Do it
DoByteBitMaskSp:
  PUSH DX               ;Save used registers
  MOV  DX,1             ;DL = Space/New Line Flag = Space
                        ;DH = Flag Counter = 0
;  JMP >K00              ;Do it
K00:
  PUSH AX,BX,SI         ;Save used registers
  MOV  SI,BX            ;Point DS:[SI] at the Table
  MOV  BL,AL            ;Save byte we're testing
K10:                    ;Loop to here for each Table Entry
  LODSB                 ;Get next Table Entry
  OR   DL,DL            ;Writing Spaces?
  JNZ >K15              ;If so, don't do the Indent
  OR   DH,DH            ;First flag?
  JZ  >K15              ;If so, don't do the Indent
  CALL DoIndent         ;Write the Indent
K15:                    ;Indent handled, if appropriate
  INC  DH               ;Increment the counter
  CALL WriteItSISkip    ;Write and skip over the Header
  MOV  BH,AL            ;Save the original bit-mask
  MOV  AH,BL            ;Put byte we're testing in AH
  AND  AH,AL            ;Mask out the unwanted bits
K20:                    ;Loop to here to find the correct bit-mask entry
  LODSB                 ;Get the next bit mask
  CMP  AL,BH            ;Is it the last (default) bit-mask entry?
  JE  >K40              ;If so, handle it
  CMP  AL,AH            ;If not, is it the correct bit-mask?
  JE  >K30              ;If so, handle it
  CALL SkipOverStringSI ;If not, skip over the string
  JMP  K20              ;Keep looking for the correct bit-mask
K30:                    ;Correct bit-mask
  CALL WriteItSISkip    ;Write and skip over the String
K35:                    ;Loop to here to find default entry
  LODSB                 ;Get the next bit-mask
  CMP  AL,BH            ;Is it the default?
  JE  >K50              ;If so, handle it
  CALL SkipOverStringSI ;If not, skip over the string
  JMP  K35              ;Keep looking for the default string
K40:                    ;Is default entry
  CALL WriteItSI        ;Write the default String
K50:                    ;Done with this Table entry
  CALL SkipOverStringSI ;Skip Over the default String
  CALL WriteItSISkip    ;Write and skip over the Footer
  CMP  B [SI],0         ;End of the Table?
  JE  >K90              ;If so, we're done
  OR   DL,DL            ;If not, should we write a space or a new-line?
  JZ  >K60              ;If a new line, jump to handle it
  CALL WriteSpace       ;If not, write a space
  JMP >K65              ;Continue
K60:                    ;Write a new line
  CALL WriteCrLf        ;Write a New Line
K65:                    ;DOne with this entry
  JMP  K10              ;Keep looking for more Table entries
K90:                    ;Done
  POP  SI,BX,AX         ;Restore used registers
  POP  DX               ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO SETUP AND ISSUE A USB INT 14h REQUEST
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;COPY A REQUEST (CONTROL) STRUCTURE INTO THE INT14 STRUCTURE
;Inputs:  [CX] = Request Structure to Copy
;         ES = ES = Data Area
;         [DI] = Int14 Request Structure to copy it to
;Outputs:
;Changes: Int14 Structure contains Request Structure Data
;------------------------------------------------------------------------------
CopySetupReqToInt14DI:
  PUSH CX,DI,SI                   ;Save used registers
  ADD  DI,OFFSET I14RSetupReqData ;Point at correct part of structure
  MOV  SI,CX                      ;Point at structure to copy
  MOV  CX,(SetupRequestSize/2)    ;Number of words to copy
  REP  MOVSW                      ;Copy it
  POP  SI,DI,CX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ISSUE AN INT 14 CALL TO THE USB HOST
;Inputs:  DS:[DX] = Int 14 Request (filled with appropriate data)
;      OR DS:[DI]
;      OR DS:[SI]
;Outputs: CF = Set if error (host stalled, etc.)
;            = Clear if OK
;Changes: Sends the appropriate info to the USB Host via Int 14 call
;------------------------------------------------------------------------------
DoInt14CallSaveAllDI:       ;Save all changed registers, [DI] = Int14 Structure
  PUSH DX                   ;Save used registers
  MOV  DX,DI                ;Point DX at the Data Offset
  CALL DoInt14CallSaveAllDX ;Do it
  POP  DX                   ;Restore used registers
  RET

DoInt14CallSaveAllDX: ;Save all changed registers, [DX] = Int14 Structure
  PUSH AX,BX,CX,DX    ;Save registers that Int14 changes!
  CALL DoInt14Call    ;Do it
  POP  DX,CX,BX,AX    ;Restore used registers
  RET

;Int 14 returns various values in AX, BX, CX, & DX
DoInt14Call:
  STI           ;Enable Interrupts
  MOV  AX,5001h ;Set Function
  MOV  BX,'US'  ;Set
  MOV  CX,'B!'  ;  Registers
  STC           ;Preset Error Flag
  INT  14h      ;Do it
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO TEST THE COMPUTER FOR MINIMUM COMPATIBILITY (DOS VERSION, ETC)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST THE COMPUTER TO SEE IF IT'S COMPATIBLE (CPU, DOS VERSION, WHATEVER)
;Inputs:  InMemory
;Outputs: Quits the program if Computer is Incompatible
;         Returns if Computer is OK
;         Stores all kinds of values in memory variables
;Changes:
;------------------------------------------------------------------------------
TestCompatibility:
  PUSH AX,DX          ;Save used registers
  MOV  AL,ErLvlDOSVer ;Assume incorrect
  MOV  DX,DOSVerMsg   ;  DOS Version
  CALL TestDOSVer     ;  new enough?
  JC  >C70            ;If not, quit
  MOV  AL,ErLvlNo386  ;Assume CPU is
  MOV  DX,No386Msg    ;  not 386+
  CALL Test80386      ;Is the CPU at least an 80386?
  JNC >C90            ;If not, quit
C70:                  ;The computer is incompatible for some reason
  JMP  Exit           ;Quit!
C90:                  ;The computer is compatible!
  POP  DX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST THE CURRENT DOS VERSION
;Inputs:  MinDOSVer (EQUate)
;Outputs: CF = Clear if DOS version >= MinDOSVer
;         CF = Set if DOS version < MinDOSVer
;Changes:
;------------------------------------------------------------------------------
TestDOSVer:
  PUSH AX,BX,CX     ;Save used registers
  MOV  AX,3000h     ;Service 30h (get DOS version number)
                    ;  DOS 5.0 requires AL = 00h, may change BX and CX
  INT  21h          ;Do it (Returns AL= Major, AH = Minor)
  XCHG AL,AH        ;Swap Major and Minor versions for testing
  CMP  AX,MinDOSVer ;Is the version new enough?
  JAE >D80          ;If so, it's OK
D70:                ;DOS is older than the minimum
  STC               ;Set the "too old" flag
  JMP >D90          ;We're done
D80:                ;DOS is >= the minimum
  CLC               ;Set the OK flag
D90:                ;We're done
  POP  CX,BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THE CPU IS AN 80386+ (CAN HANDLE 32-BIT INSTRUCTIONS)
;Inputs:
;Outputs: CF = Clear if the CPU is an 80386+
;            = Set if CPU is not an 80386+
;Changes:
;------------------------------------------------------------------------------
Test80386:
  PUSH AX,BX     ;Save used registers
  PUSHF          ;Save flags
  CALL Test8086  ;Is it an 8086?
  JNC >E70       ;If so, it can't be an 80386
  MOV  BX,0F000h ;Flags mask for testing (these bits always clear on 80286)
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  OR   AX,BX     ;Try to set the
  PUSH AX        ;  four high bits
  POPF           ;  of the flags
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  TEST AX,BX     ;Are any of the four high bits set?
  JNZ >E80       ;If so, it's not an 80286 - it must be an 80386+
E70:             ;It's not an 80386
  POPF           ;Restore flags
  STC            ;Set the not 80386 flag
  JMP >E90       ;We're done
E80:             ;It is an 80386
  POPF           ;Restore flags
  CLC            ;Set the 80386 flag
E90:             ;We're done
  POP  BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THE CPU IS AN 8086/8088
;Inputs:
;Outputs: CF = Clear if the CPU is an 8086/8088
;            = Set if not at 8086/8088
;Changes:
;NOTE: Unlike the other CPU tests, this is not a "greater than or equal to".
;      The CPU must be EXACTLY an 8086/8088, or this returns with CF set.
;------------------------------------------------------------------------------
Test8086:
  PUSH AX,BX     ;Save used registers
  PUSHF          ;Save flags
  MOV  BX,0F000h ;Flags mask for testing (these bits always set on 8086/8088)
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  AND  AX,0FFFh  ;Try to clear the
  PUSH AX        ;  four high bits
  POPF           ;  of the flags
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  AND  AX,BX     ;Are the four high bits
  CMP  AX,BX     ;  of the flags set?
  JE  >E80       ;If so, it's an 8086/8088
  POPF           ;Restore flags
E70:             ;It is not an 8086/8088
  STC            ;Set the not 8086/8088 flag
  JMP >E90       ;We're done
E80:             ;It is an 8086/8088
  POPF           ;Restore flags
  CLC            ;Set the 8086/8088 flag
E90:             ;We're done
  POP  BX,AX     ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO SET UP COMMAND TAIL WITH PROPER PARAMETERS FOR EXEC CALL
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;APPEND A STRING (ASCIIZ) TO THE EXEC COMMAND-TAIL STRING
;Inputs:  CS = DS = Local Data Area
;         CmdTail, already appended with CR's
;         DS:[DX] = String to Append
;         CLD already issued
;Outputs: String is Appended to CmdTail
;Changes:
;------------------------------------------------------------------------------
AppendString2Cmd:
  PUSH DI,SI,ES       ;Save used registers
  MOV  SI,DX          ;Point DS:[SI] at the String to Copy
  MOV  ES,DS          ;Point ES:[DI] at the end
  CALL FindCmdTailEnd ;  of the Command Tail
A10:                  ;Loop to here for each character in the String
  CMP  B [SI],0       ;End of the string?
  JE  >A90            ;If so, we're done
  MOVSB               ;If not, copy the character to the Command-Tail String
  JMP  A10            ;Keep going until we're done
A90:                  ;Done
  POP  ES,SI,DI       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;APPEND A HEX BYTE TO THE EXEC COMMAND-TAIL STRING
;Inputs:  CS = DS = Local Data Area
;         CmdTail, already appended with CR's
;         AL = Byte to Append
;         CLD already issued
;Outputs: Byte is Appended to CmdTail (Hex Value, followed by an "h")
;Changes:
;------------------------------------------------------------------------------
AppendHexByte2Cmd:
  PUSH DI             ;Save used registers
  CALL FindCmdTailEnd ;Point DS:[DI] at the end of the Command Tail
  CALL Byte2HexString ;Append the Hex Byte (modifies DI)
  MOV  B [DI],'h'     ;Append an 'h'
  POP  DI             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;APPEND A HEX WORD TO THE EXEC COMMAND-TAIL STRING
;Inputs:  CS = DS = Local Data Area
;         CmdTail, already appended with CR's
;         AX = Word to Append
;         CLD already issued
;Outputs: Word is Appended to CmdTail (Hex Value, followed by an "h")
;Changes:
;------------------------------------------------------------------------------
AppendHexWord2Cmd:
  PUSH DI             ;Save used registers
  CALL FindCmdTailEnd ;Point DS:[DI] at the end of the Command Tail
  CALL Word2HexString ;Append the Hex Word (modifies DI)
  MOV  B [DI],'h'     ;Append an 'h'
  POP  DI             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;APPEND A SEGMENT:OFFSET VALUE TO THE EXEC COMMAND-TAIL STRING
;Inputs:   AX  = Segment to Write
;          CX  = Offset to Write
;Outputs: CX:AX is Appended to CmdTail (Hex Values)
;Changes:
;------------------------------------------------------------------------------
AppendSegOff2Cmd:
  PUSH AX,DI          ;Save used registers
  CALL FindCmdTailEnd ;Point DS:[DI] at the end of the Command Tail
  CALL Word2HexString ;Append the Hex Segment Word (modifies DI)
  MOV  B [DI],':'     ;Append a
  INC  DI             ;  colon
  MOV  AX,CX          ;Append the
  CALL Word2HexString ;  Hex Offset Word (modifies DI)
  POP  DI,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;APPEND THE APPROPRIATE CALL-BACK ADDRESS TO THE EXEC COMMAND-TAIL STRING
;Inputs:  CS = DS = Local Data Area
;         CallBackAddr
;         ParentIsShell
;Outputs: Appropriate Call-Back Address is Appended to CmdTail (Hex Values)
;         CmdTailSize is calculated and stored
;Changes:
;NOTES: If we were EXEC'd from another program which provided us with
;         a Call-Back Address, we pass the EXECing program Call-Back Address
;         on to our EXEC'd program.  If we were not EXEC'd by another
;         program, or if the EXECing program, did not provide us with a
;         Call-Back Address, we pass our own Call-Back Address to the
;         EXEC'd Program.
;------------------------------------------------------------------------------
AppendCallBack2Cmd:
  PUSH AX,CX,DI               ;Save used registers
  MOV  AX,CS                  ;Assume we'll use our own
  MOV  CX,WriteZPauseFar      ;  Call-Back Address
  CMP  ParentIsShell,Yes      ;Are we at the command-line?
  JE  >K50                    ;If so, continue
  MOV  DI,OFFSET CallBackAddr ;If not, point at the Call-back Address
  CMP  W [DI+0],-1            ;Is it valid (Offset != -1)?
  JE  >K50                    ;If not, use our address
  MOV  AX,[DI+2]              ;If so, use the
  MOV  CX,[DI+0]              ;  externally-provided Call-back Address
K50:                          ;AX:CX contains Segment:Offset to use
  CALL AppendSegOff2Cmd       ;Store the Segment:Offset
  CALL FindCmdTailEnd         ;Calculate how many
  DEC  DI                     ;  characters
  MOV  B [DI],CR              ;  are in
  SUB  DI,CmdTail             ;  the command tail
  MOV  AX,DI                  ;Store it
  MOV  CmdTailSize,AL         ;  in CmdTailSize
  POP  DI,CX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE THE EXEC COMMAND-TAIL STRING (FILL IT UP WITH CR's)
;Inputs:  CS = DS = Local Data Area
;         CmdTail
;         CLD already issued
;Outputs: CmdTail is filled with Carriage Returns
;Changes:
;------------------------------------------------------------------------------
InitCmdTail:
  PUSH AX,CX,DI,ES   ;Save used registers
  MOV  AL,CR         ;Write Carriage Returns
  MOV  CX,CmdTailMax ;CX = Number of Bytes to Write
  MOV  ES,DS         ;Point ES:[DI] at
  MOV  DI,CmdTail    ;  the Command tail
  REP  STOSB         ;Do it
  POP  ES,DI,CX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE END OF THE COMMAND-TAIL STRING, ADD A SPACE, AND RETURN POINTER
;Inputs:  CS = DS = Local Data Area
;         CmdTail, already filled with CR's
;         CLD already issued
;Outputs: [DI] = Command Tail Pointer (end of Command String), after a
;           space has been added
;Changes:
;------------------------------------------------------------------------------
FindCmdTailEnd:
  PUSH AX,CX,ES       ;Save used registers
  MOV  AL,CR          ;Look for a CR (end-of-tail marker)
  MOV  CX,-1          ;Maximize the Counter
  MOV  ES,DS          ;Point ES:[DI] at
  MOV  DI,CmdTail     ;  the Command tail
  REPNE SCASB         ;Look for the end of the Command-Tail String
  CMP  DI,(CmdTail+1) ;Is there anything yet in the Command-Tail String?
  JNE >E20            ;If so, continue
E10:                  ;Nothing yet in the Command-Tail String
  DEC  DI             ;Point at String Start (don't need a Space)
  JMP >E90            ;Done
E20:                  ;Something already in the Comand-Tail String
  MOV  B [DI-1],' '   ;Append a Space to the Command Tail
E90:                  ;Done
  POP  ES,CX,AX       ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO EXEC ANOTHER PROGRAM
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SETUP PARAMETERS TO BE ABLE TO PERFORM THE EXEC FUNCTION
;Inputs:
;Outputs:
;Changes: Lots of stuff
;------------------------------------------------------------------------------
SetupExec:
  PUSH AX,SI                       ;Save used registers
  MOV  SI,ParamBlock               ;Point at Parameter Block
  MOV  AX,CS                       ;Use our data segment
  MOV  [SI].PBEnvirSegment,0       ;Use Copy of our Environment
  MOV  W [SI].PBCmdTailPtr[0],OFFSET CmdTailSize
  MOV  W [SI].PBCmdTailPtr[2],AX   ;Command Tail Pointer
  MOV  W [SI].PBFCB1Offset[0],FCB1
  MOV  W [SI].PBFCB1Offset[2],AX   ;FCB #1 Pointer
  MOV  W [SI].PBFCB2Offset[0],FCB2
  MOV  W [SI].PBFCB2Offset[2],AX   ;FCB #2 Pointer
  POP  SI,AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PERFORM THE EXEC FUNCTION
;Inputs:  ParamBlock set up with appropriate data
;         CmdTail/CmdTailSize set up with appropriate Info
;         PathToUse contains Child Program to Call
;         DS = Our Data Area
;Outputs: CF = Clear if Program Returned ErrorLevel 0
;Changes: Performs EXEC Function
;------------------------------------------------------------------------------
DoExec:
  PUSH ES            ;Save used register
  MOV  ES,DS         ;Point ES at our Data Area
  PUSHA              ;Save all registers
  MOV  OldSPExec,SP  ;Save the Stack Pointer (may be destroyed by Call)
  MOV  DX,PathToUse  ;DS:[DX] = Child Program to Run
  MOV  BX,ParamBlock ;ES:[BX] = Parameter Block
  MOV  AX,4B00h      ;Function 4B00h (Load and Execute child program)
  INT  21h           ;Do it (May Destroy BX & DX)
  JC  >X70           ;If Error, quit
X00:                 ;When the Child Program Exits, here we are!
  CLD                ;Go forward with string functions
  CLI                ;Disable interrupts
  MOV  DS,CS         ;Restore
  MOV  ES,DS         ;  all
  MOV  SS,CS         ;  Segments
  MOV  SP,OldSPExec  ;Restore Stack Pointer
  STI                ;Enable interrupts
  MOV  AH,4Dh        ;Function 4Dh (Get ErrorLevel)
  INT  21h           ;Do it (Returns AH = Term Type, AL = ErrorLevel)
  OR   AL,AL         ;ErrorLevel 0?
  JZ  >X80           ;If so, it was OK
X70:                 ;Error
  STC                ;Set Error Flag
  JMP >X90           ;Done
X80:                 ;OK
  CLC                ;Set OK Flag
X90:                 ;Done
  POPA               ;Restore all registers
  NOP                ;POPA Bug Fix
  POP  ES            ;Restore used registers
  RET

;-----------------------------------------------------------------------------
;EXECUTE AN EXEC CALL, PRINTING A "FILE NOT FOUND" MESSAGE IF ERROR
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = Support File (Executable File) to Call
;         CmdTail already filled in with Parameters
;Outputs: CF = Clear if Success
;            = Set if Error
;                Writes Error Message to the Screen (including Exec Filename)
;Changes:
;-----------------------------------------------------------------------------
HandleExecCall:
  PUSH DX                 ;Save used registers
  CALL FindSupportFile    ;Look for the Support File (DI)
  JNC >X50                ;If OK, continue
  MOV  DX,NoSuptFileMsg   ;If not, write the first part
  CALL WriteZPause        ;  of the Error Message
  MOV  DX,DI              ;Write the
  CALL WriteZPause        ;  File Name
  STC                     ;Set Error Flag
  JMP >X90                ;Done
X50:                      ;Support File exists
  CALL AppendCallBack2Cmd ;Append the Call-Back Address to the Command Tail
  CALL DoExec             ;Call the Support Program
  CLC                     ;Set OK flag
X90:                      ;Done
  POP  DX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE LOCATION OF THE SUPPORT FILE
;Inputs:  [DI] = FIleName to Look for
;Outputs: CF = Clear if OK (File Found)
;              PathToUse = Path & FileName Concatenated Together
;            = Set if Error (File not Found)
;              PathToUse = Undefined
;Changes: Various Path pointer Registers (OurPathPointer, PathVarPointer, etc.)
;------------------------------------------------------------------------------
FindSupportFile:
  PUSH AX,SI,ES          ;Save used registers
F10:                     ;Do Our Path
  MOV  SI,OurPathPointer ;Point [SI] at our program's Path
  CMP  SI,-1             ;Valid?
  JE  >F20               ;If not, skip it
  MOV  ES,[PSPEnvirSeg]  ;Point ES at the Environment Segment
  CALL CopyPathName      ;Copy it
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F20:                     ;Do Current Path
  MOV  ES,CS             ;Point ES at us
  MOV  SI,CurrentPath    ;Point at the Current Path
  CALL CopyPathName      ;Copy it
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F30:                     ;Do Environment PATH
  MOV  SI,PathVarPointer ;SI = Environment PATH Pointer
  CMP  SI,-1             ;Is it valid?
  JE  >F70               ;If not, we're done
  MOV  ES,[PSPEnvirSeg]  ;Point ES at the PATH (Environment) Segment
F35:                     ;Loop to here for each element in PATH
  CALL CopyPathName      ;Copy the PATH element
  JC  >F70               ;If End of Path, we're done
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F40:                     ;Loop to here to skip over PATH Element
  MOV  AL,ES:[SI]        ;Get next character
  INC  SI                ;Increment Pointer
  OR   AL,AL             ;End of PATH?
  JZ  >F70               ;If so, we're done
  CMP  AL,';'            ;End of PATH Element?
  JNE  F40               ;If not, Keep looking
  JMP  F35               ;Try the next Element
F70:                     ;Error
  STC                    ;Set Error Flag
  JMP >F90               ;Done
F80:                     ;Found our File
  CLC                    ;Set OK flag
F90:                     ;Done
  POP  ES,SI,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEE IF THE SUPPORT FILE EXISTS
;Inputs:  PathToUse
;Outputs: CF = Clear if OK (File Found)
;            = Set if Error (File not Found)
;Changes:
;------------------------------------------------------------------------------
FindFile:
  PUSH AX,BX,CX,DX   ;Save used registers
  PUSH DS,ES         ;Save used registers
  MOV  AH,2Fh        ;Function 2Fh (Get DTA Address)
  INT  21h           ;Do it (returns ES:BX)
  MOV  AH,1Ah        ;Function 1Ah (Set DTA Address)
  MOV  DX,FCB1       ;DS:DX = New DTA Address
  INT  21h           ;Do it
  MOV  AX,4E00h      ;Function 4Eh (Find First Matching File)
  MOV  CX,FAttrToUse ;Search for any file, including Hidden
  MOV  DX,PathToUse  ;DS:DX = ASCIIZ FileName to search for
  INT  21h           ;Do it (returns CF)
  PUSHF              ;Save return flag
  MOV  DS,ES         ;Point DS:DX
  MOV  DX,BX         ;  at the old DTA
  MOV  AH,1Ah        ;Function 1Ah (Set DTA Address)
  INT  21h           ;Do it
  POPF               ;Restore return flag
  POP  ES,DS         ;Restore used registers
  POP  DX,CX,BX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CREATE A COMPLETE PATH NAME GIVEN A PATH AND A FILE NAME
;Inputs:  ES:[SI] = Path name to Copy
;         DS:[DI] = FileName to Append to the Path
;Outputs: PathToUse = Path & File Concatenated Together
;NOTES: The Path String can either end with a 0 (ASCIIZ String) or a SemiColon
;         (the way strings are stored in the PATH Environment variable).
;       This code will properly handle an empty Path String, which will
;         simply set PathToUse to the FileName.
;       The FileName must be an ASCIIZ String.
;------------------------------------------------------------------------------
CopyPathName:
  PUSH AX,BX,CX,DI,SI,DS,ES  ;Save used registers
  SwapDSES                   ;Point ES at our Data, DS at Data Path
  MOV  BX,DI                 ;Save File Name Pointer
  XOR  AX,AX                 ;Fill with Zeroes
  MOV  CX,(MaxPathSize/2)    ;Number of Words to Write
  MOV  DI,PathToUse          ;Where to write them
  PUSH DI                    ;Save Pointer
  REP  STOSW                 ;Reset the Buffer
  POP  DI                    ;Restore Pointer
  XOR  CX,CX                 ;Start String Length Counter at 0
N10:                         ;Loop to here for each character in Path
  LODSB                      ;Get next character
  OR   AL,AL                 ;End of Path?
  JZ  >N20                   ;If so, do Filename
  CMP  AL,';'                ;End of Path (Environment PATH)?
  JE  >N20                   ;If so, do FileName
  INC  CL                    ;Increment String Length Counter
  STOSB                      ;If not, store the character
  JMP  N10                   ;Keep going
N20:                         ;Done with Path
  OR   CL,CL                 ;Any characters at all in the Path?
  JZ  >N30                   ;If so, is Current Path, and don't want backslash!
  CMP  B ES:[DI-1],Backslash ;Path ends in a Backslash?
  JE  >N30                   ;If so, it's OK
  MOV  AL,Backslash          ;If not, store
  STOSB                      ;  a Backslash
N30:                         ;Path is OK
  MOV  DS,ES                 ;Point DS:[SI]
  MOV  SI,BX                 ;  at the File Name
N40:                         ;Loop to here for each character in File name
  LODSB                      ;Get next character
  OR   AL,AL                 ;End of File Name?
  JZ  >N90                   ;If so, we're done
  STOSB                      ;If not, store it
  JMP  N40                   ;Keepgoing
N90:                         ;Done
  POP  ES,DS,SI,DI,CX,BX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE PATH THAT OUR PROGRAM IS IN
;Inputs:
;Outputs: OurPathPointer = Pointer to Our Path String (in Environment Segment)
;                        = -1 if we couldn't find our own Path
;Changes:
;------------------------------------------------------------------------------
GetOurPath:
  PUSH AX,BX,CX,DI,SI   ;Save used registers
  PUSH DS,ES            ;Save used registers
  MOV  BX,OFFSET OurPathPointer ;Point at where we're storing
  MOV  DS,[PSPEnvirSeg] ;Point DS and ES
  MOV  ES,DS            ;  at the Environment segment
  XOR  DI,DI            ;Point at the beginning of Environment list
  MOV  CX,-1            ;Max out the count limiter
  XOR  AX,AX            ;Need to look for a double 0
N10:                    ;Loop to here to skip over Environment vars
  REPNE SCASB           ;Look for the end of this environment variable
  CMP  [DI],AL          ;Is it the end of the variable list (double 0)?
  JNE  N10              ;If not, keep skipping over Environment vars
  CMP  [DI+1],AX        ;If so, is there a string after the Envir?
  JE  >N70              ;If not, we're done
  ADD  DI,3             ;Point DI and SI at the
  MOV  SI,DI            ;  True Name
  MOV  CS:[BX],DI       ;Store the Pointer
N20:                    ;Loop to here to find the end of the PATH
  LODSB                 ;Get the next character of the name
  CMP  AL,':'           ;Is it a Colon?
  JE  >N30              ;If so, possible end-of-path
  CMP  AL,Backslash     ;Is it a backslash?
  JE  >N30              ;If so, possible end-of-path
  OR   AL,AL            ;End of File Name?
  JZ  >N50              ;If so, we're done
  JMP >N40              ;If not, keep looking
N30:                    ;Update end-of-path Pointer
  MOV  DI,SI            ;Save possible end-of-path pointer
N40:                    ;Not end-of-path yet
  JMP  N20              ;Keep looking
N50:                    ;At end of Path
  CMP  DI,CS:[BX]       ;Was there a real path?
  JE  >N70              ;If not, error
  MOV  B [DI],0         ;If OK, put 0 at end of Path
  JMP >N90              ;Done
N70:                    ;No Path
  MOV  W CS:[BX],-1     ;Set Pointer as Invalid
N90:                    ;Done
  POP  ES,DS            ;Restore used registers
  POP  SI,DI,CX,BX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE PATH STATEMENT IN THE ENVIRONMENT
;Inputs:
;Outputs: PathVarPointer = Pointer to Environment PATH variable (in Env Segment)
;                        = -1 if No PATH or Empty PATH
;Changes:
;------------------------------------------------------------------------------
GetEnvPath:
  PUSH CX,SI,BP                 ;Save used registers
  MOV  SI,PathVarString1        ;Get
  MOV  BP,OFFSET PathVarPointer ;  the
  MOV  CX,PathVarSize           ;  PATH
  CALL GetEnvVarPointer         ;  Pointer
  JNZ >P90                      ;If OK, continue
  MOV  SI,PathVarString2        ;If no, try
  CALL GetEnvVarPointer         ;  "Path" instead of "PATH"
P90:                            ;Done
  POP  BP,SI,CX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE POINTER TO AN ENVIRONMENT VARIABLE
;Inputs:   DS  = Segment containing PSP
;         [SI] = Environment Variable String to Look for (ends in =)
;          CX  = Length of String
;         [BP] = Where to store the Pointer at
;Outputs: ZF = Set if Error (Variable not found)
;              [BP] = -1
;            = Clear if OK (variable was found)
;              [BP] = Pointer to String (in Environment Segment, NOT PSP!!)
;Changes:
;------------------------------------------------------------------------------
GetEnvVarPointer:
  PUSH AX,BX,CX,DX      ;Save used registers
  PUSH DI,SI,ES         ;Save used registers
  MOV  W DS:[BP],-1     ;Default = -1 (does not exist)
  MOV  ES,[PSPEnvirSeg] ;Point ES at the Environment segment
  MOV  DX,CX            ;Save the Size
  MOV  BX,SI            ;Save the original Pointer
  XOR  DI,DI            ;Point at the beginning of Environment list
  XOR  AX,AX            ;Need to look for 0's
V10:                    ;Loop to here for each Environment variable
  MOV  CX,DX            ;Number of bytes to test
  MOV  SI,BX            ;String to Test for
  REPE CMPSB            ;Is it a match?
  JZ   >V30             ;If so, continue
  MOV  CX,-1            ;Max out the count limiter
  REPNE SCASB           ;Look for the end of this environment variable
  CMP  B ES:[DI],AL     ;End of Environment?
  JNE  V10              ;If not, keep looking
  JMP >V90              ;If so, no variable
V30:                    ;Found it!
  CMP  B ES:[DI],0      ;Anything at all in the variable?
  JE  >V90              ;If not, we're done
  MOV  DS:[BP],DI       ;If OK, store the Pointer
V90:                    ;Done
  CMP  W DS:[BP],-1     ;Set return flag
  POP  ES,SI,DI         ;Restore used registers
  POP  DX,CX,BX,AX      ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO WRITE STRINGS AND NUMBERS TO THE SCREEN
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE A BYTE OR WORD IN HEX, FOLLOWED BY " = Unknown!"
;Inputs:  AL, AX = Byte/Word to Write
;         ParentIsShell
;Outputs: If ParentIsShell = Yes, writes number followed by " = Unknown"
;         If ParentIsShell = No,  just writes "Unknown!"
;Changes:
;------------------------------------------------------------------------------
WriteWordUnknownX:
  CALL WriteWordEquals ;Write number and equals (if at command-line)
  CALL WriteUnknownX   ;Write "Unknown!"
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE OR WORD IN HEX, FOLLOWED BY " = "
;Inputs:  AL, AX = Byte/Word to Write
;         ParentIsShell
;Outputs: Writes to Screen if ParentIsShell = Yes
;         Does nothing if ParentIsShell = No
;Changes:
;------------------------------------------------------------------------------
WriteWordEquals:
  CMP  ParentIsShell,Yes ;Are we at the Command-line?
  JNE >Q90               ;If not, don't write it
  CALL WriteWordHex      ;Write the byte/word in hex
  CALL WriteHexEnd       ;Write the "h"
  CALL WriteSpace        ;Move over
  CALL WriteEqualsSpace  ;Write "= "
Q90:                     ;Done
  RET

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF A WORD OR DWORD IN THE MINIMUM SPACE POSSIBLE (AS HEX)
;Inputs:  AL/AX/EAX = Byte/Word/DWord to Write
;Outputs: Writes to Screen
;Changes:
;NOTES: This writes a Byte, Word, or DWord, whichever is appropriate
;------------------------------------------------------------------------------
WriteDWordMinHex:
  CMP  EAX,0FFFFh    ;More than a Word can handle?
  JA  >M40           ;If so, write the DWord
WriteWordMinHex:
  CMP  EAX,0FFh      ;More than a Byte can handle?
  JA  >M20           ;If so, jump to handle more than a byte
  CALL WriteByteHex  ;Write the Byte
  JMP >M90           ;Done
M20:                 ;More than a Byte
  CALL WriteWordHex  ;Write the Word
  JMP >M90           ;Done
M40:                 ;More than a Word
  CALL WriteDWordHex ;Write the DWord
M90:                 ;Done
  CALL WriteHexEnd   ;Write the 'h'
  RET

;------------------------------------------------------------------------------
;WRITE A DWORD IN SEGMENT:OFFSET FORMAT
;Inputs:  EAX = DWord to be written
;         CLD must be set already!
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteSegmentOffset:
  PUSH EAX          ;Save used registers
  ROR  EAX,16       ;Write the
  CALL WriteWordHex ;  High Word (Segment)
  CALL WriteColon   ;Write a Colon
  POP  EAX          ;Restore used registers
  CALL WriteWordHex ;Write the Low Word (Offset)
  RET

;------------------------------------------------------------------------------
;CONVERT BYTE, WORD, OR DWORD TO HEX CHARACTER STRING, AND WRITE IT
;Inputs:  AL/AX = Nibble/Byte/Word to be written
;         CLD must be set already!
;Outputs: Writes to the Screen
;Changes: HexString
;------------------------------------------------------------------------------
WriteNibbleHex:
  PUSH BX             ;Save used registers
  MOV  BX,8           ;Need to start of offset 8 in string
  JMP >H00            ;Jump to do it
WriteByteHex:
  PUSH BX             ;Save used registers
  MOV  BX,7           ;Need to start of offset 7 in string
  JMP >H00            ;Jump to do it
WriteWordHex:
  PUSH BX             ;Save used registers
  MOV  BX,5           ;Need to start of offset 5 in string
  JMP >H00            ;Jump to do it
WriteTriByteHex:
  PUSH BX             ;Save used registers
  MOV  BX,3           ;Need to start at offset 3 in string
  JMP >H00            ;Jump to do it
WriteDWordHex:
  PUSH BX             ;Save used registers
  XOR  BX,BX          ;Need to start of offset 0 in string
;  JMP >H00            ;Jump to do it
H00:                  ;Start converting the strings
  PUSH DX,DI          ;Save used registers
  MOV  DI,HexString   ;Point DS:[DI] at HexString
  MOV  B [DI+4],'_'   ;Fill in the underscore
  MOV  DX,DI          ;Point DS:[DX] at HexString
  ROR  EAX,16         ;Convert the High Word
  CALL Word2HexString ;  to a String
  INC  DI             ;Skip over the Underscore
  ROR  EAX,16         ;Convert the Low Word
  CALL Word2HexString ;  to a String
  ADD  DX,BX          ;Point DX at the beginning of where we write
  CMP  BL,3           ;Writing a TriByte?
  JNE >H40            ;If not, it's Ok like it is
  MOV  BX,[DI-7]      ;If so, move the
  MOV  [DI-6],BX      ;  third byte over the underscore
H40:                  ;String is filled in
  CALL WriteItDX      ;Write it
  POP  DI,DX          ;Restore used registers
  POP  BX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A BYTE OR WORD TO A HEXADECIMAL STRING (2 OR 4 CHARACTERS)
;Inputs:  AX = Word to Convert to a Hex String
;         DS:[DI] = Location to store the String
;         CLD already issued
;Outputs: DS:[DI]
;Changes: DI
;------------------------------------------------------------------------------
Word2HexString:
  PUSH AX,BX,ES         ;Save used registers
  MOV  BX,AX            ;Save original Word
  MOV  ES,DS            ;Point ES:[DI] at
  CALL Word2HexString00 ;Convert it
  POP  ES,BX,AX         ;Restore used registers
  RET

Word2HexString00:
  MOV  AL,BH            ;Convert High Byte
  CALL Word2HexString10 ;  to ASCII
  MOV  AL,BL            ;Work with Low Byte
Word2HexString10:       ;Convert Byte to ASCII
  AAM  10h              ;Separate Low & High Nibbles
  XCHG AH,AL            ;Put High Nibble in AL
  CALL Word2HexString20 ;Convert High Nibble to ASCII
  XCHG AH,AL            ;Work with Low Nibble
Word2HexString20:       ;Convert Nibble to ASCII
  ADD  AL,90h           ;Convert BCD
  DAA                   ;  to Decimal
  ADC  AL,40h           ;Convert Decimal
  DAA                   ;  to ASCII
  STOSB                 ;Store the Nibble
  RET

Byte2HexString:
  PUSH AX,ES            ;Save used registers
  MOV  ES,DS            ;Point ES:[DI] at the String
  CALL Word2HexString10 ;Convert it
  POP  ES,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A NIBBLE/BYTE/WORD/DWORD AS AN INTEGER TO THE SCREEN
;Inputs:  AL/AX/EAX = Nibble/Byte/Word/DWORD to write
;Outputs: Writes to Con
;Changes:
;------------------------------------------------------------------------------
WriteNibbleInteger:
  PUSH EAX           ;Save used registers
  TEST AL,08h        ;Negative number?
  JZ  >B00           ;If not, continue
  OR   AL,0F0h       ;If so, make the entire byte negative
  JMP >B00           ;Continue
WriteByteInteger:
  PUSH EAX           ;Save used registers
B00:
  CBW                ;Sign-extend Byte to Word
  JMP >O00           ;Continue
WriteWordInteger:
  PUSH EAX           ;Save used registers
O00:
  CWDE               ;Sign-extend Word to DWord
  JMP >I00           ;Continue
WriteDWordInteger:
  PUSH EAX           ;Save used registers
I00:
  OR   EAX,EAX       ;Is it Zero or Negative?
  JZ  >I40           ;If zero, don't write anything
  JS  >I20           ;If negative, jump to handle it
  CALL WritePlus     ;Write a Plus Sign
  JMP >I40           ;Continue
I20:                 ;Is negative
  CALL WriteMinus    ;Write a minus sign
  NOT  EAX           ;Convert it
  INC  EAX           ;  to a positive number
I40:                 ;Have negativity accounted for
  CALL WriteDWordMin ;Write the Number
  POP  EAX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE/WORD/TRIBYTE/DWORD TO THE SCREEN AS A DECIMAL
;Inputs:  AL/AX/EAX = Byte/Word/DWord to Write
;Outputs:
;Changes:
;NOTES: If ByteToString, WordToString, or DWordToString, fills front
;         of string with spaces, and does NOT include any commas.
;       If WriteByteMin, WriteWordMin, or WriteDWordMin, does NOT
;         include spaces at front, and includes comma separators
;------------------------------------------------------------------------------
WriteByteMin:
  PUSH EAX,BX                ;Save used registers
  XOR  AH,AH                 ;Make sure high byte is 0
  JMP >O00                   ;Continue
WriteWordMin:
  PUSH EAX,BX                ;Save used registers
O00:
  AND  EAX,0000_FFFFh        ;Make sure High Word is 0
  JMP >D00                   ;Continue
WriteTriByteMin:
  PUSH EAX,BX                ;Save used registers
  AND  EAX,00FF_FFFFh        ;Make sure high byte is 0
  JMP >D00                   ;Continue
WriteDWordMin:
  PUSH EAX,BX                ;Save used registers
D00:
  MOV  BH,WriteByteMinFlag   ;Mark as doing minimum
  JMP >W00                   ;Do it

ByteToString:
  PUSH EAX,BX                ;Save used registers
  XOR  AH,AH                 ;Make sure high byte is 0
  XOR  BX,BX                 ;BH = No Minimum, Byte
;  JMP >O01                   ;Continue
;WordToString:
;  PUSH EAX,BX                ;Save used registers
;  MOV  BH,WriteByteWordFlag  ;BH = No Minimum, Word
O01:
  AND  EAX,0000_FFFFh        ;Make sure High Word is 0
;  JMP >D01                   ;Continue
;DWordToString:
;  PUSH EAX,BX                ;Save used registers
;  MOV  BH,WriteByteDWordFlag ;BH = No Minimum, DWord
D01:
W00:                         ;Do a word or a byte
  PUSH ECX,EDX,SI            ;Save used registers
  MOV  SI,SingleMsg          ;Point at the single character message
  XOR  BL,BL                 ;Test for first non-zero character is false
  MOV  ECX,1000000000        ;First divisor is 1,000,000,000
W20:                         ;Loop to here for each character
  XOR  EDX,EDX               ;High word of Dividend = 0
  DIV  ECX                   ;Divide EDX:EAX by current divisor
  OR   EAX,EAX               ;Is this a non-zero character?
  JNZ >W30                   ;If so, we need to write it
  OR   BL,BL                 ;Has there already been a non-zero character?
  JNZ >W30                   ;If so, we need to write it
  CMP  ECX,1                 ;Is this the last character?
  JE  >W30                   ;If so, we need to write it
  TEST BH,WriteByteMinFlag   ;Are we doing a minimum?
  JNZ >W40                   ;If not, don't write anything
  MOV  AL,' '                ;Assume a space
  TEST BH,WriteByteDWordFlag ;Writing a DWord?
  JNZ >W35                   ;If so, write the space
  TEST BH,WriteByteWordFlag  ;Doing a Word?
  JZ  >W25                   ;If not, handle a Byte
  CMP  ECX,10000             ;If so, doing the ten-thousands character?
  JBE >W35                   ;If so, write the space
  JMP >W40                   ;If not, don't write anything
W25:                         ;Doing a Byte
  CMP  ECX,100               ;Doing the hundreds character?
  JBE >W35                   ;If so, write the space
  JMP >W40                   ;If not, don't write anything
W30:                         ;We need to write this character
  INC  BL                    ;Test for first non-zero character is true
  ADD  AL,'0'                ;Convert the Number to ASCII
W35:                         ;Write the character
  MOV  [SI],AL               ;Write the
  CALL WriteItSI             ;  character
  CMP  AL,' '                ;Should we write a comma or a space?
  JE  >W36                   ;If a space, continue
  MOV  AL,','                ;If not, mark as a comma
W36:                         ;AL contains space or Comma
  MOV  [SI],AL               ;Store it in the String
  CMP  ECX,1000000000        ;Need to write the space or comma?
  JE  >W38                   ;If so, jump to write it
  CMP  ECX,1000000           ;Need to write the space or comma?
  JE  >W38                   ;If so, jump to write it
  CMP  ECX,1000              ;Need to write the space or comma?
  JNE >W40                   ;If not, continue
W38:                         ;Need to write a Space or Comma Separator
  CALL WriteItSI             ;Write the space or Comma
W40:                         ;Done writing the Character
  CMP  ECX,1                 ;Was this the last division to do?
  JE  >W90                   ;If so, we're done
  MOV  EAX,EDX               ;If not, start next loop with remainder of division
  PUSH EAX                   ;Save register for a second
  XOR  EDX,EDX               ;So dividend won't be messed up
  MOV  EAX,ECX               ;Want to divide divisor in ECX
  MOV  ECX,10                ;Want to divide by 10
  DIV  ECX                   ;Divide it
  MOV  ECX,EAX               ;Store it back in ECX
  POP  EAX                   ;Restore register
  JMP  W20                   ;And do it again
W90:                         ;We're done
  POP  SI,EDX,ECX            ;Restore used registers
  POP  BX,EAX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DO THE APPROPRIATE INDENTATION
;Inputs:  DS:Indent = Number of Spaces to Indent
;Outputs: Writes an appropriate number of spaces to the screen
;Changes:
;------------------------------------------------------------------------------
DoIndent:
  PUSH CX          ;Save used registers
  MOV  CL,Indent   ;Write the
  CALL WriteSpaces ;  Indent Spaces
  POP  CX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE MULTIPLE SPACES TO THE SCREEN
;Inputs:  CL = Number of times to write the character
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
Write12Spaces:
  PUSH CX          ;Save used registers
  MOV  CL,12       ;Write 9 Spaces
  JMP >P00         ;Do it
;Write9Spaces:
;  PUSH CX          ;Save used registers
;  MOV  CL,9        ;Write 9 Spaces
;  JMP >P00         ;Do it
;Write8Spaces:
;  PUSH CX          ;Save used registers
;  MOV  CL,8        ;Write 8 Spaces
;  JMP >P00         ;Do it
Write7Spaces:
  PUSH CX          ;Save used registers
  MOV  CL,7        ;Write 7 Spaces
  JMP >P00         ;Do it
Write6Spaces:
  PUSH CX          ;Save used registers
  MOV  CL,6        ;Write 6 Spaces
  JMP >P00         ;Do it
Write5Spaces:
  PUSH CX          ;Save used registers
  MOV  CL,5        ;Write 5 Spaces
  JMP >P00         ;Do it
Write4Spaces:
  PUSH CX          ;Save used registers
  MOV  CL,4        ;Write 4 Spaces
  JMP >P00         ;Do it
Write3Spaces:
  PUSH CX          ;Save used registers
  MOV  CL,3        ;Write 3 Spaces
  JMP >P00         ;Do it
Write2Spaces:
  PUSH CX          ;Save used registers
  MOV  CL,2        ;Write 2 Spaces
  JMP >P00         ;Do it
WriteSpace:
  PUSH CX          ;Save used registers
  MOV  CL,1        ;Write 1 Space
;  JMP >P00         ;Do it
P00:
  CALL WriteSpaces ;Write the Spaces
  POP  CX          ;Restore used registers
  RET

WriteSpaces:
  PUSH AX         ;Save used registers
  MOV  AL,' '     ;Write Spaces
  CALL WriteChars ;Do it
  POP  AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE DESCRIPTOR SEPARATOR LINE (SINGLE OR DOUBLE LINE) TO THE SCREEN
;Inputs:
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
WriteDTagDLine:
  PUSH AX              ;Save used registers
  MOV  AL,'Í'          ;Write a Double-line character
  JMP >L00             ;Do it
WriteDTagSLine:
  PUSH AX              ;Save used registers
  MOV  AL,'Ä'          ;Write a Single-line character
;  JMP >L00             ;Do it
L00:
  PUSH CX              ;Save used registers
  MOV  CX,DescrLineLen ;How many to write
  CALL WriteChars      ;Do it
  POP  CX              ;Restore used registers
  POP  AX              ;Restore used registers
  RET


;------------------------------------------------------------------------------
;WRITE MULTIPLE COPIES OF THE SAME CHARACTER TO THE SCREEN
;Inputs:  AL = Character to write
;         CL = Number of times to write it
;Outputs: To the screen
;Changes:
;------------------------------------------------------------------------------
WriteChars:
  PUSH CX      ;Save used registers
  OR   CL,CL   ;Should we write 0 characters?
  JZ  >C90     ;If so, we're done
  XOR  CH,CH   ;If OK, change it to a word
C10:           ;Loop to here for each space
  CALL WriteAL ;Write the character
  LOOP C10     ;Keep going until we're done
C90:           ;Done
  POP  CX      ;Restore used registers
  RET


;------------------------------------------------------------------------------
;WRITE A SPECIFIC CHARACTER OR SET OF CHARACTERS TO THE SCREEN
;Inputs:
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
WriteAL:
  PUSH DX                ;Save used registers
  MOV  DL,AL             ;Write what's in AL
  JMP >C00               ;Do it
WriteBlock:
  PUSH DX                ;Save used registers
  MOV  DL,'±'            ;Write a Block Character
  JMP >C00               ;Do it
WriteColon:
  PUSH DX                ;Save used registers
  MOV  DL,':'            ;Write a Colon
  JMP >C00               ;Do it
WriteCommaSpace:
  PUSH DX                ;Save used registers
  MOV  DX,CommaSpaceMsg  ;Point at Message
  JMP >C10               ;Do it
WriteCrLf:
  PUSH DX                ;Save used registers
  MOV  DX,CrLfMsg        ;Point at Message
  JMP >C10               ;Do it
WriteCurlyLeft:
  PUSH DX                ;Save used registers
  MOV  DL,'{'            ;Write a Left Curly Bracket
  JMP >C00               ;Do it
WriteDot:
  PUSH DX                ;Save used registers
  MOV  DL,'.'            ;Write a Dot
  JMP >C00               ;Do it
WriteHexEnd:
  PUSH DX                ;Save used registers
  MOV  DL,'h'            ;Write an h
  JMP >C00               ;Do it
WriteMinus:
  PUSH DX                ;Save used registers
  MOV  DL,'-'            ;Write a Minus
  JMP >C00               ;Do it
WritePlus:
  PUSH DX                ;Save used registers
  MOV  DL,'+'            ;Write a Plus
  JMP >C00               ;Do it
WriteQuestion:
  PUSH DX                ;Save used registers
  MOV  DL,'?'            ;Write a ?
  JMP >C00               ;Do it
WriteDoubleQuote:
  PUSH DX                ;Save used registers
  MOV  DL,'"'            ;Write a ?
  JMP >C00               ;Do it
WriteEqualsSpace:
  PUSH DX                ;Save used registers
  MOV  DX,EqualsSpaceMsg ;Point at Message
  JMP >C10               ;Do it
WriteIllegalAttr:
  PUSH DX                ;Save used registers
  MOV  DX,IllegalAttrMsg ;Point at Message
  JMP >C10               ;Do it
WriteMono:
  PUSH DX                ;Save used registers
  MOV  DX,MonoMsg        ;Point at Message
  JMP >C10               ;Do it
WriteNone:
  PUSH DX                ;Save used registers
  MOV  DX,NoneMsg        ;Point at Message
  JMP >C10               ;Do it
WriteUnknown:
  PUSH DX                ;Save used registers
  MOV  DX,UnknownMsg     ;Point at Message
  JMP >C10               ;Do it
WriteUnknownX:
  PUSH DX                ;Save used registers
  MOV  DX,UnknownXMsg    ;Point at Message
  JMP >C10               ;Do it
WriteHIDDescrType:
  PUSH DX                ;Save used registers
  MOV  DX,HIDDescrMsg    ;Point at Message
  JMP >C10               ;Do it
WriteHubDescrType:
  PUSH DX                ;Save used registers
  MOV  DX,HubDescrMsg    ;Point at Message
  JMP >C10               ;Do it
C00:
  MOV  SingleMsg[0],DL   ;Put the character in the Single Character String
  MOV  DX,SingleMsg      ;Point at Single Character String
C10:                     ;DX is pointed at String
  CALL WriteItDX         ;Write the String
  POP  DX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ASCIIZ STRING TO CON OR TO ERR
;Inputs:  DS:[DX] = Pointer to string
;         CS = Local Data Area
;Outputs: Writes the string to CON or ERR
;Changes:
;------------------------------------------------------------------------------
WriteZCon:                  ;Write to CON
  CMP  CS:PauseHeaderPtr,-1 ;Should we write anything?
  JE  >Z90                  ;If not, just quit
  PUSH BX                   ;Save used register
  MOV  BX,StdOutHandle      ;Write to STDOUT
  JMP >Z00                  ;Jump to do it
WriteZErr:                  ;Write to ERR
  PUSH BX                   ;Save used register
  MOV  BX,StdErrHandle      ;Write to STDERR
Z00:
  PUSH AX,CX                ;Save used registers
  CALL CalcStrSizeDX        ;Calculate the size of the string (returns CX)
  JZ  >Z80                  ;If nothing to write, just quit
  MOV  AH,40h               ;Function 40h (Write to Device)
  INT  21h                  ;Do it
Z80:                        ;We're done
  POP  CX,AX                ;Restore used registers
  POP  BX                   ;Restore used register
Z90:                        ;We're done
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LENGTH OF AN ASCIIZ STRING
;Inputs:  DS:[SI] = ASCIIZ String to wrok with
;Outputs: CX = Length of String
;         ZF = Set if string is 0 length
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
CalcStrSizeSI:
  PUSH DX            ;Save used registers
  MOV  DX,SI         ;Calculate the
  CALL CalcStrSizeDX ;  length of the string
  POP  DX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LENGTH OF AN ASCIIZ STRING
;Inputs:  DS:[DX] = Pointer to the string
;Outputs: CX = Length of the string
;         ZF = Set if string is 0 length
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
CalcStrSizeDX:
  PUSH AX,DI  ;Save used registers
  PUSH ES     ;Save used registers
  MOV  ES,DS  ;Point ES:[DI]
  MOV  DI,DX  ; at the string
  XOR  AX,AX  ;Look for a 0
  MOV  CX,-1  ;Start with max count for REPNE
  REPNE SCASB ;Find the end of the string
  NOT  CX     ;Calculate the size
  DEC  CX     ;  of the string (sets ZF)
  POP  ES     ;Restore used registers
  POP  DI,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP TO THE END OF AN ASCIIZ STRING
;Inputs:  DS:[SI] = ASCIIZ String to Skip Over
;Outputs: [SI]    = Next Byte After String
;Changes:
;------------------------------------------------------------------------------
SkipOverStringSI:
  PUSH CX,DX         ;Save used registers
  MOV  DX,SI         ;Calculate the size
  CALL CalcStrSizeDX ;  of the string (CX, does not include the Zero)
  INC  CX            ;Compensate for the Zero
  ADD  SI,CX         ;Add it to the Pointer
  POP  DX,CX         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO WRITE OUR OUTPUT, EITHER TO PAUSE OR TO THE USER-PROVIDED ADDRESS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE AN ASCIIZ STRING POINTED AT BY DS:[SI], THEN SKIP OVER THE STRING
;Inputs:  DS:[SI] = ASCIIZ String to Write
;Outputs: To Pause or to user-provided Code Address
;         [SI] points to next character after the string
;Changes:
;------------------------------------------------------------------------------
WriteItSISkip:
  CALL WriteItSI        ;Write the string
  CALL SkipOverStringSI ;Skip over the string
  RET

;------------------------------------------------------------------------------
;WRITE AN ASCIIZ STRING, POINTED AT BY SI, TO PAUSE OR TO PROVIDED CALL-BACK
;Inputs:  DS:[SI] = ASCIIZ String to Write
;Outputs: To Pause or to user-provided Code Address
;Changes:
;------------------------------------------------------------------------------
WriteItSI:
  PUSH DX        ;Save used registers
  MOV  DX,SI     ;Write the
  CALL WriteItDX ;  string
  POP  DX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE OUR OUTPUT TO PAUSE, OR TO THE PROVIDED CALL-BACK ADDRESS
;Inputs:  DS:[DX] = ASCIIZ String to Write
;         CalloBackAddr (-1 in Offset if invalid)
;Outputs: Either to Pause, or to the call-back address
;Changes:
;------------------------------------------------------------------------------
WriteItDX:
  CMP  W CallBackAddr[0],-1 ;Is there a valid call-back address?
  JE  >W50                  ;If not, write to Pause
  CMP  ParentIsShell,Yes    ;Double-check whether we are at a command-line
                            ;  (we shouldn't need to do this, but will anyway)
  JE  >W50                  ;If so, write to Pause
  PUSH AX,BX,CX,DX,DI,SI    ;Save
  PUSH BP,DS,ES             ;  all registers
  CALL D CallBackAddr       ;If not, call the provided code address
  POP  ES,DS,BP             ;Restore
  POp  SI,DI,DX,CX,BX,AX    ;  all registers
  JMP >W90                  ;Done
W50:                        ;Write to Pause
  CALL WriteZPause          ;Write to Pause
W90:                        ;Done
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED TO SET UP AND DO SCREEN PAUSES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SETUP PARAMETERS FOR DOING A SCREEN PAUSE (FOR PRINTING A LARGE TABLE)
;Inputs:  DS = Local Data Area
;         DS:[DX] = ASCIIZ Header to Print at top of each screen
;                   Last character of the Header MUST be an LF
;                   If SetupPauseNoHdr, we "inject" NoMsg as the Header
;Outputs: Pauses the screen with a MORE message every time it gets full
;NOTES:   If a Screen Header is really large (almost taking up the whole
;           screen itself, with little room for data), this procedure
;           may not work correctly.  This procedure does not validate
;           the size of the Header -- it simply assumes that it is a
;           "reasonable" size compared to the size of the screen.  Most
;           anything that needs a Screen Header (a long data table) will
;           only have a few lines of Header, so this should be OK as a
;           general purpose procedure.
;         After this Setup is complete (which should be near the beginning
;           of MAIN, before anything is sent to the screen), WriteZPause
;           must be called for ALL screen writing to CON:, not WriteZCon!
;         The Pausing occurs in "real time", meaning we can send things
;           to the Pause routine a byte, line, or several screens at a
;           time for processing.  Because we do it in "real time",
;           we can end up with extra MORE's and screen Headers appearing
;           on screen than are actually needed.  During a screen
;           transition (or a transition to a new Header) whether we
;           actually need to write anything or not depends on if there
;           is actually any real data coming afterward (in time), which
;           of course we don't know (since it hasn't happened yet).
;           So, we must assume there is more data to come and process the
;           MORE's and Screen Headers accordingly.  This only causes problems
;           (in the form of extraneous MORE's and Screen Headers)
;           when things happen near the bottom of the screen.
;           DOS's MORE utiltiy (and other programs of similar ilk) do not
;           process in "real time", but rather store things in a Temporary
;           File and then process the file.
;------------------------------------------------------------------------------
SetupPauseNoHdr:
  PUSH DX         ;Save used registers
  MOV  DX,NoMsg   ;Point at 0-length Message
  CALL SetupPause ;Setup the Pause
  POP  DX         ;Restore used registers
  RET

SetupPause:
  PUSH AX,BX,CX,DI,SI     ;Save used registers
  MOV  SI,OFFSET PauseHeaderPtr ;Point [SI] at PauseHeaderPtr
  CMP  W [SI],-1          ;Has the user already cancelled us?
  JE  >S90                ;If so, just quit
  CMP  W [SI],0           ;Has the user stopped pausing already?
  JE  >S85                ;If so, just write the header
  CALL TestRedir          ;Is our output redirected?
  JNC >S10                ;If not, setup our Headers
  MOV  W [SI],0           ;Mark as Redirected or Pausing Stopped/Disabled
  JMP >S85                ;Jump to write the Header and Quit
S10:                      ;Output not redirected
  CALL GetScreenRows      ;Store the number of rows
  MOV  PauseRows,AX       ;  on the screen
  CALL CountZLinesCX      ;Calculate the number of lines
  INC  CX,2               ;  in the new Header
  MOV  DI,PauseRowCount   ;Get the Current Row count
  ADD  DI,CX              ;Add the size of the new header
  SUB  DI,3               ;Adjust for Headers
  DEC  AX                 ;Will writing the new Header
  CMP  DI,AX              ;  cause a Pause event?
  JB  >S50                ;If not, handle it
S20:                      ;New Header is too big to fit on screen
  MOV  W [SI],NoMsg       ;Point Header for second page at nothing
  MOV  PauseHeaderSize,2  ;Set Pause Header Size
  PUSH CX                 ;Save New Header Size
  SUB  AX,PauseRowCount   ;Calculate how many rows to fill up the screen
  MOV  CX,AX              ;Put number of rows in CX
  INC  CX                 ;Adjust it
S30:                      ;Loop to here to fill up the screen
  CALL WriteCrLf          ;Write a new line
  LOOP S30                ;Keep going until we're done
  POP  CX                 ;Restore New Header Size
  CMP  W [SI],-1          ;Did the user cancel during the header transition?
  JE  >S90                ;If so, we're done
  CMP  W [SI],0           ;Did the user stop Pausing during the transition?
  JE  >S85                ;If so, just write the Header
S50:                      ;Need to adjust current Row Count
  SUB  PauseRowCount,2    ;Adjust things for the previous Header
S80:                      ;Store new Header Info
  MOV  [SI],DX            ;Store the Header Address
  MOV  PauseHeaderSize,CX ;Store the Header Size
  ADD  PauseRowCount,CX   ;Add the Header Size to the Row Count
  MOV  AX,PauseRows       ;Compensate if
  CMP  AX,PauseRowCount   ;  the new header
  JAE >S85                ;  put us past
  DEC  AX                 ;  the end
  MOV  PauseRowCount,AX   ;  of hte screen
S85:                      ;Write Header
  CALL WriteZCon          ;Write the Header
S90:                      ;We're done
  POP  SI,DI,CX,BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHECK TO SEE IF STDOUT HAS BEEN REDIRECTED
;Inputs:
;Outputs: CF = Clear if STDOUT is normal (usually the screen)
;            = Set if STDOUT been redirected
;Changes:
;------------------------------------------------------------------------------
TestRedir:
  PUSH AX,BX,DX        ;Save used registers
  MOV  AX,4400h        ;Function 4400h (Get Device Info)
  MOV  BX,StdOutHandle ;Device = STDOUT
  INT  21h             ;Do it (returns DX, changes AX)
  JC  >R80             ;If error, assume not Redirected
  AND  DL,(DvcInfoIsDevice+DvcInfoIsStdOut) ;Mask out unwanted bits
  CMP  DL,(DvcInfoIsDevice+DvcInfoIsStdOut) ;Is it still the STDOUT Device?
  JE  >R80             ;If so, it's not Redirected
R70:                   ;STDOUT has been Redirected
  STC                  ;Set the Redirected flag
  JMP >R90             ;Done
R80:                   ;STDOUT is not Redirected
  CLC                  ;Set the Not-Redirected flag
R90:                   ;Done
  POP  DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NUMBER OF VIDEO ROWS ON THE SCREEN
;Inputs:
;Outputs: AX = Number of text rows on the screen
;                (usually 25, 43, or 50)
;Changes:
;------------------------------------------------------------------------------
GetScreenRows:
  PUSH BX,CX,DS  ;Save used registers
  MOV  AX,40h    ;Point ES to
  MOV  DS,AX     ;  BIOS data area
  MOV  AH,12h    ;Function 12h (EGA Alternate Select)
  MOV  BX,0FF10h ;Subfunction (BL) 10h (Return EGA information)
                 ;  Preset unrealistic return value (BH)
  INT  10h       ;Do it (returns AX, BX, CX)
  CMP  BL,10h    ;Is the function supported (EGA or better)?
  JE  >R50       ;If not, jump to handle MDA/CGA
  CMP  BH,0FFh   ;Is the return value valid?
  JE  >R50       ;If not, jump to handle MDA/CGA
  TEST B [87h],8 ;If so, is bit 3 of the EGA information byte set?
  JNZ >R50       ;If so, EGA is not the active display
  XOR  AX,AX     ;Get # of
  MOV  AL,[84h]  ;  rows - 1
  JMP >R90       ;We're done
R50:             ;Video card is less than EGA (MDA or CGA)
  MOV  AX,24     ;Number of rows must be 25
R90:             ;We're done
  INC  AX        ;Bump the number of rows by 1
  POP  DS,CX,BX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ASCIIZ STRING(s) TO THE SCREEN, PAUSING WHEN IF NECESSARY
;Inputs:  DS:[DX] = String to write
;         PauseRows, PauseHeaderPtr, PauseHeaderSize, PauseRowCount
;         CS = Local Data Area
;Outputs: PauseRowCount
;Changes: Pauses the screen and waits for user input, if necessary
;NOTES: This should be called instead of WriteZCon every time something
;         is written during the Pausing.
;       A string can be written by WriteZCon during the pausing, as long
;         as the string does not contain a Line Feed.  Any line containing
;         a Line Feed must come through here or the Line Count will get
;         screwed up!
;------------------------------------------------------------------------------
WriteZPauseFar:
  CALL WriteZPause
  RETF

WriteZPause:
  PUSH AX,BX,CX,DX          ;Save used registers
  MOV  AX,CS:PauseHeaderPtr ;Put Header Pointer in AX
  CMP  AX,-1                ;Has the Output been cancelled by the user?
  JE  >P90                  ;If so, don't write anything at all
  OR   AX,AX                ;Is STDOUT Redirected?
  JZ  >P80                  ;If so, just write it with no Pausing
  CALL CountZLinesCX        ;Count how many Lines are in the string
  MOV  AX,CS:PauseRowCount  ;Add the new lines
  ADD  AX,CX                ;  to the current lines
  CMP  AX,CS:PauseRows      ;Will we be at or past the end of the screen?
  JB  >P70                  ;If not, just write it
  JE  >P20                  ;If at the end of the screen, handle it
  SUB  AX,CS:PauseRows      ;If not, find
  SUB  CX,AX                ;  the end of the String
  CALL FindEndOfLines       ;  we need to write ([BX])
  MOV  AL,[BX]              ;Save the character that's there now
  MOV  B [BX],0             ;Replace it with a 0
  CALL WriteZPause          ;Write it (will Pause correctly)
  MOV  [BX],AL              ;Restore original character
  MOV  DX,BX                ;Use the new string pointer
  CALL WriteZPause          ;Write it (Pausing if necessary)
  JMP >P90                  ;Done
P20:                        ;At end of screen
  CALL WriteZCon            ;Write the String
  CALL HandlePause          ;Handle the Pause (may change Pointers/Counters)
  JMP >P90                  ;We're done for now
P70:                        ;Store new Row Count
  MOV  CS:PauseRowCount,AX  ;Save the new Row Count
P80:                        ;Write the String
  CALL WriteZCon            ;Write the string
P90:                        ;Done
  POP  DX,CX,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE PAUSE LINE, AND WAIT FOR A KEYSTROKE
;Inputs:  CS = Local Data Area
;         PauseRows, PauseHeaderPtr, PauseHeaderSize, PauseRowCount
;Outputs: PauseRowCount, PauseHeaderPtr
;Changes: Pauses the screen and waits for user input, if necessary
;------------------------------------------------------------------------------
HandlePause:
  PUSH AX,BX,DX,DS        ;Save String Segment
  MOV  DS,CS              ;Point DS at our Data Segment
  MOV  BX,OFFSET PauseHeaderPtr ;Point [BX] at the Pause Header
  MOV  DX,PauseMsg        ;Write the
  CALL WriteZCon          ;  Enter a Keystroke message
  CALL FlushKbdBuff       ;Clear the keyboard buffer
L10:                      ;Loop to here to wait for a keystroke
  CALL GetKey             ;Is there a key in the keystroke buffer?
  JZ   L10                ;If not, keep waiting until there is
  MOV  DX,PauseDMsg       ;Delete the
  CALL WriteZCon          ;  MORE Message
  CMP  AL,CtrlC           ;Was the keystroke a Control-C?
  JE  >L40                ;If so, jump to handle it
  CMP  AL,Escape          ;Was the keystroke an Escape?
  JNE >L20                ;If not, just keep going
  MOV  W [BX],0           ;If so, mark us as redirected (stop Pausing)
  JMP >L90                ;And quit
L20:                      ;Continue with the Pause
  MOV  DX,PauseNMsg       ;Write the
  CALL WriteZCon          ;  MORE Replacement Line
  MOV  DX,[BX]            ;Point DX at the Header
  CALL WriteZCon          ;Write it
  MOV  AX,PauseHeaderSize ;Reset the Row Count
  MOV  PauseRowCount,AX   ;Store the new Row Count
  JMP >L90                ;We're done for now
L40:                      ;Ctrl-C (stop altogether)
  MOV  W [BX],-1          ;Mark as stopped
L90:                      ;Done
  POP  DS,DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE NUMBER OF LINES IN AN ASCIIZ STRING (COUNT CR/LF COMBINATIONS)
;Inputs:  DS:[DX] = Pointer to String to measure
;         CLD already issued
;Outputs: CX = Number of LF's in the String (may be 0)
;         ZF = Set if CX = 0
;            = Clear if CX > 0
;Changes:
;------------------------------------------------------------------------------
CountZLinesCX:
  PUSH AX,SI ;Save used registers
  MOV  SI,DX ;Put the pointer in DI
  XOR  CX,CX ;Initialize Lines Counter
Z10:         ;Loop to here for each character
  LODSB      ;Get the next character
  OR   AL,AL ;Is it the end of the string?
  JZ  >Z90   ;If so, we're done
  CMP  AL,LF ;Is it a Line Feed?
  JNE  Z10   ;If not, it's not a new line
  INC  CX    ;If so, Increment the Line Counter
  JMP  Z10   ;Keep looking
Z90:         ;We're done
  OR   CX,CX ;Set return flag
  POP  SI,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE POINTER AFTER THE FIRST SEVERAL LINES OF A STRING
;Inputs:  DS:[DX] = String to use
;         CX = Number of lines to "skip"
;         CLD already issued
;Outputs: DS:[BX] = "New" String Pointer (after the last line written)
;Changes:
;NOTES: This assumes that the string actually has MORE than the number of
;         lines in AX (it does not look for the end of an ASCIIZ string).
;------------------------------------------------------------------------------
FindEndOfLines:
  PUSH AX,CX  ;Save used registers
  PUSH DI,ES  ;Save used registers
  MOV  BX,CX  ;BX = Line Counter
  MOV  ES,DS  ;Point ES:[DI] at
  MOV  DI,DX  ;  the string
  MOV  AL,LF  ;Look for Line Feeds
  MOV  CX,-1  ;Maximize counter
L10:          ;Loop to here for each new line
  REPNE SCASB ;Look for the end-of-line character
  DEC  BX     ;Decrement the Line Counter
  JNZ  L10    ;If not 0 yet, keep looking
  MOV  BX,DI  ;Store the new string beginning
L90:          ;Done
  POP  ES,DI  ;Restore used registers
  POP  CX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FLUSH KEYBOARD BUFFER
;Inputs:
;Outputs:
;Changes: Flushes the Keyboard Buffer
;------------------------------------------------------------------------------
FlushKbdBuff:
  PUSH AX     ;Save used registers
F10:          ;Loop to here for each key
  CALL GetKey ;Get a key from the keyboard buffer
  JNZ  F10    ;If there was one, get another
  POP  AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ CHARACTER FROM THE KEYBOARD BUFFER
;Inputs:
;Outputs: AH = Keyboard scan code
;         AL = ASCII value of keypress (0 if extended ASCII)
;         AX = 0 if no key is waiting
;Changes: ZF = Set if no key in buffer (AX = 0)
;            = Clear if a key was found (AX = key)
;------------------------------------------------------------------------------
GetKey:
  MOV  AH,1  ;Service 1 (Keystroke waiting?)
  INT  16h   ;Do It
  JZ  >K10   ;If no key waiting, we're done
  XOR  AX,AX ;If a key is waiting, service 0 (Get keystroke)
  INT  16h   ;Do It
  JMP >K90   ;We're done
K10:         ;No keystroke waiting
  XOR  AX,AX ;Make sure AX=0
K90:         ;We're done
  OR   AX,AX ;Set the return flag
  RET

;------------------------------------------------------------------------------
;WRITE MULTIPLE CR/LF's TO THE SCREEN
;Inputs:
;Outputs: To Screen, Updates Pause Counters
;Changes:
;------------------------------------------------------------------------------
WriteCrLf2:
  CALL WriteCrLf ;Move down
  CALL WriteCrLf ;  2 lines
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SPACE AND CODE TO PROCESS OUR PROGRAM STACK
;  This code and must be physically at the END of the Program,
;    but must be one of the FIRST procedures called by the Program.
;  In addition, the Stack Pointer (SP) must be set properly
;    (to LastProgByte - 2) BEFORE this code is called.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;RESIZE OUR MEMORY ALLOCATION TO THE MINIMUM SIZE NEEDED
;Inputs:  SP = LastProgByte - 2
;         ES = Local Segment
;Outputs: Rellocates Memory to the minimum size required to run the program
;Changes:
;------------------------------------------------------------------------------
ResizeMemory:
  PUSH AX,BX  ;Save used registers
  MOV  AH,4Ah ;Function 4Ah (Resize Memory Block pointed at by ES)
  MOV  BX,(LastProgByte SHR 4) ;BX = Number of Paragraphs to Resize to
  INT  21h    ;Do it
  POP  BX,AX  ;Restore used registers
  RET

  EVEN 16
  DB (ProgStackSize/8) DUP ('PrgStack')

LastProgByte:



